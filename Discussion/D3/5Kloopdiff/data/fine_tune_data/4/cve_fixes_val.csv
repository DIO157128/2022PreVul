,source,target,group
0,"resend : if ( ! setup_stratum_socket ( pool ) ) {sockd = false ;goto out ;}sockd = true ;if ( recvd ) {clear_sock ( pool ) ;sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;}else {if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\"",<S2SV_blank>\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\""]}"" , swork_id ++ ) ;}if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) {",resend : if ( ! valid_hex ( nonce1 ) ) {,0
1,"applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ;if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;nonce1 = json_array_string ( res_val , 1 ) ;if ( ! nonce1 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;","applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;if ( n2size < 2 || n2size > 16 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;",0
2,"ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ;tptr += sizeof ( const struct eap_frame_t ) ;tlen -= sizeof ( const struct eap_frame_t ) ;switch ( eap -> type ) {case EAP_FRAME_TYPE_PACKET :  type = * ( tptr ) ;len = EXTRACT_16BITS ( tptr + 2 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\","ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , subtype ) , subtype ) ) ;ND_TCHECK_8BITS ( tptr + 4 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\",1
3,"ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST :  ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM :  ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" ,  tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;","ND_TCHECK_8BITS ( tptr + count ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ;if ( subtype == EAP_TYPE_TTLS ) ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS : ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;",1
4,"
",kfree_skb ( skb ) ;,2
5,return - ETIMEDOUT ;},return - ETIMEDOUT ;},2
6,case SIOCYAMGCFG :  yi . cfg . mask = 0xffffffff ;yi . cfg . iobase = yp -> iobase ;,"case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;yi . cfg . mask = 0xffffffff ;yi . cfg . iobase = yp -> iobase ;",3
7,"if ( unlikely ( skb -> len <= mss ) ) goto out ;if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) {int type = skb_shinfo ( skb ) -> gso_type ;if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ;skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ;segs = NULL ;goto out ;}if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ;else {offset = skb_checksum_start_offset ( skb ) ;csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ;offset += skb -> csum_offset ;* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ;skb -> ip_summed = CHECKSUM_NONE ;tnl_hlen = skb_tnl_header_len ( skb ) ;if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;","if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;",4
8,"int64_t time , offset ;if ( version == 1 ) {","int64_t time , offset ;if ( avio_feof ( f ) ) {index -> item_count = 0 ;av_freep ( & index -> items ) ;return AVERROR_INVALIDDATA ;}if ( version == 1 ) {",5
9,"unsigned long tpgt ;int ret ;if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ;if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX )  return ERR_PTR ( - EINVAL ) ;","u16 tpgt ;int ret ;if ( kstrtou16 ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) return ERR_PTR ( - EINVAL ) ;",6
10,"TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ;gf_isom_box_del ( writer -> stco ) ;","TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ;gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ;gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc ) ;gf_isom_box_del ( writer -> stco ) ;",7
11,u32 data ;void * vapic ;vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ;kunmap_atomic ( vapic ) ;,"u32 data ;kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ;",8
12,* dst = * src ;clear_task_ebb ( dst ) ;,__switch_to_tm ( src ) ;tm_recheckpoint_new_task ( src ) ;* dst = * src ;clear_task_ebb ( dst ) ;,9
13,cJSON * c = array -> child ;while ( c && item > 0 ) {-- item ;c = c -> next ;}return c ;,"cJSON * c = array ? array -> child : 0 ;while ( c && item > 0 ) item -- , c = c -> next ;}return c ;",10
14,"ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" ,  ( char * ) * data ) ;","ext3_msg ( sb , KERN_ERR , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , ( char * ) * data ) ;",11
15,"ipv6_select_ident ( fptr ) ;segs = skb_segment ( skb , features ) ;","ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ;segs = skb_segment ( skb , features ) ;",12
16,"void __perf_sw_event ( u32 event_id , u64 nr , int nmi ,  struct pt_regs * regs , u64 addr ) {do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ;perf_swevent_put_recursion_context ( rctx ) ;","void __perf_sw_event ( u32 event_id , u64 nr , struct pt_regs * regs , u64 addr ) {do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , & data , regs ) ;perf_swevent_put_recursion_context ( rctx ) ;",13
17,"# ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;# endif struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;return - 1 ;","char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;if ( ! buf ) {return - 1 ;}struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;free ( buf ) ;return - 1 ;",14
18,"if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;else  {return fileblock + start ;}return - 1 ;}}if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;","if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) {free ( buf ) ;return 0 ;}else {free ( buf ) ;return fileblock + start ;}free ( buf ) ;return - 1 ;}free ( buf ) ;}if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;",14
19,"if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;","if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;",14
20,"static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) {int step1 [ 8 ] ;int step2 [ 8 ] ;int step3 [ 8 ] ;int input [ 8 ] ;int temp1 , temp2 ;input [ 0 ] = in [ 0 ] + in [ 15 ] ;","static void fdct16 ( const tran_low_t in [ 16 ] , int16_t out [ 16 ] ) {tran_high_t step1 [ 8 ] ;int step2 [ 8 ] ;tran_high_t step3 [ 8 ] ;int input [ 8 ] ;tran_high_t temp1 , temp2 ;input [ 0 ] = in [ 0 ] + in [ 15 ] ;",15
21,"int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;int t0 , t1 , t2 , t3 ;int x0 , x1 , x2 , x3 ;s0 = input [ 0 ] + input [ 7 ] ;","tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;tran_high_t t0 , t1 , t2 , t3 ;tran_high_t x0 , x1 , x2 , x3 ;s0 = input [ 0 ] + input [ 7 ] ;",15
22,out [ 0 ] = fdct_round_shift ( t0 ) ;out [ 4 ] = fdct_round_shift ( t2 ) ;out [ 8 ] = fdct_round_shift ( t1 ) ;out [ 12 ] = fdct_round_shift ( t3 ) ;t0 = ( s6 - s5 ) * cospi_16_64 ;,out [ 0 ] = ( tran_low_t ) fdct_round_shift ( t0 ) ;out [ 4 ] = ( tran_low_t ) fdct_round_shift ( t2 ) ;out [ 8 ] = ( tran_low_t ) fdct_round_shift ( t1 ) ;out [ 12 ] = ( tran_low_t ) fdct_round_shift ( t3 ) ;t0 = ( s6 - s5 ) * cospi_16_64 ;,15
23,out [ 2 ] = fdct_round_shift ( t0 ) ;out [ 6 ] = fdct_round_shift ( t2 ) ;out [ 10 ] = fdct_round_shift ( t1 ) ;out [ 14 ] = fdct_round_shift ( t3 ) ;},out [ 2 ] = ( tran_low_t ) fdct_round_shift ( t0 ) ;out [ 6 ] = ( tran_low_t ) fdct_round_shift ( t2 ) ;out [ 10 ] = ( tran_low_t ) fdct_round_shift ( t1 ) ;out [ 14 ] = ( tran_low_t ) fdct_round_shift ( t3 ) ;},15
24,temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ;step2 [ 1 ] = fdct_round_shift ( temp1 ) ;temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ;temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ;step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ;step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ;step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ;out [ 1 ] = fdct_round_shift ( temp1 ) ;out [ 9 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ;out [ 5 ] = fdct_round_shift ( temp1 ) ;out [ 13 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ;out [ 3 ] = fdct_round_shift ( temp1 ) ;out [ 11 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ;out [ 7 ] = fdct_round_shift ( temp1 ) ;out [ 15 ] = fdct_round_shift ( temp2 ) ;},temp2 = step3 [ 2 ] * cospi_24_64 + step3 [ 5 ] * cospi_8_64 ;step2 [ 1 ] = fdct_round_shift ( temp1 ) ;temp1 = step3 [ 2 ] * cospi_8_64 - step3 [ 5 ] * cospi_24_64 ;temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ;step1 [ 2 ] = step3 [ 3 ] + step2 [ 2 ] ;step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ;step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ;step1 [ 5 ] = step3 [ 4 ] + step2 [ 5 ] ;out [ 1 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 9 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ;out [ 5 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 13 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ;out [ 3 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 11 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ;out [ 7 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 15 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;},15
25,if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ;,if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) sanitize_dead_code ( env ) ;if ( ret == 0 ) return - EINVAL ;,16
26,if ( ret == 0 )  ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,if ( ret == 0 ) ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,16
27,int i ;wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ;,"int i ;if ( ! config -> sample_rate ) {strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ;return FALSE ;}wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ;",17
28,"SDev = cd -> device ;retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) {result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen ,  ( unsigned char * ) cgc -> sense , & sshdr ,  cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ;","unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ;SDev = cd -> device ;if ( cgc -> sense ) senseptr = sense_buffer ;retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) {result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ;if ( cgc -> sense ) ) ;",18
29,if ( get4 ( ) == 0x48454150 )  {# ifdef LIBRAW_LIBRARY_BUILD  imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ;imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ;,if ( get4 ( ) == 0x48454150 # ifdef LIBRAW_LIBRARY_BUILD && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) {# ifdef LIBRAW_LIBRARY_BUILD imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ;imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ;,19
30,"static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi ,  int partial_frame ) {VP9_COMMON * const cm = & cpi -> common ;struct loopfilter * const lf = & cm -> lf ;const int min_filter_level = 0 ;int best_err ;int filt_best ;int filt_direction = 0 ;int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ;int ss_err [ MAX_LOOP_FILTER + 1 ] ;vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ;int filt_err ;int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;if ( cpi -> twopass . section_intra_rating < 20 )   bias = bias * cpi -> twopass . section_intra_rating / 20 ;if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ;filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;ss_err [ filt_low ] = filt_err ;}else {filt_err = ss_err [ filt_low ] ;if ( ( filt_err - bias ) < best_err ) {if ( filt_err < best_err )  best_err = filt_err ;if ( ss_err [ filt_high ] < 0 ) {filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ;ss_err [ filt_high ] = filt_err ;}else {filt_err = ss_err [ filt_high ] ;}if ( filt_err < ( best_err - bias ) ) {best_err = filt_err ;filt_best = filt_high ;","static int search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , int partial_frame ) {const VP9_COMMON * const cm = & cpi -> common ;const struct loopfilter * const lf = & cm -> lf ;const int min_filter_level = 0 ;int filt_direction = 0 ;int64_t best_err ;int filt_best ;int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ;int64_t ss_err [ MAX_LOOP_FILTER + 1 ] ;memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ;int64_t bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;if ( ( cpi -> oxcf . pass == 2 ) && ( cpi -> twopass . section_intra_rating < 20 ) ) bias = ( bias * cpi -> twopass . section_intra_rating ) / 20 ;if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ;ss_err [ filt_low ] = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;if ( ( ss_err [ filt_low ] - bias ) < best_err ) {if ( filt_err < best_err ) best_err = filt_err ;if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] ;filt_best = filt_high ;",20
31,lf -> filter_level = filt_best ;},lf -> filter_level = filt_best ;},20
32,"lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;",21
33,"static void encode_mv_component ( vp9_writer * w , int comp ,  const nmv_component * mvcomp , int usehp ) {","static void encode_mv_component ( vpx_writer * w , int comp , const nmv_component * mvcomp , int usehp ) {",22
34,"vp9_write ( w , sign , mvcomp -> sign ) ;vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ;","vpx_write ( w , sign , mvcomp -> sign ) ;vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ;",22
35,"++ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;}if ( usehp )  vp9_write ( w , hp ,  mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ;","+ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;++ i ) vpx_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;}if ( usehp ) vpx_write ( w , hp , mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ;",22
36,return alg -> cra_rng . rng_make_random ?  alg -> cra_rng . seedsize : ralg -> seedsize ;,return ralg -> seedsize ;,23
37,if ( sp -> sa_protocol != PX_PROTO_PPTP )  return - EINVAL ;,if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;if ( sp -> sa_protocol != PX_PROTO_PPTP ) return - EINVAL ;,24
38,if ( blockSize == 16 )  request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ;else if ( blockSize == 32 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ;else if ( blockSize == 64 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ;else if ( blockSize == 128 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ;else if ( blockSize == 256 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ;else if ( blockSize == 512 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ;else   request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ;if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) )  request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ;osReleaseMutex ( & request -> context -> mutex ) ;,if ( blockSize == 16 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ;}else if ( blockSize == 32 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ;}else if ( blockSize == 64 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ;}else if ( blockSize == 128 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ;}else if ( blockSize == 256 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ;}else if ( blockSize == 512 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ;}else {request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ;}if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) {request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ;}osReleaseMutex ( & request -> context -> mutex ) ;,25
39,"char * fmtname ;if ( jas_init ( ) ) {while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_INFILE :  infile = jas_optarg ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {","char * fmtname ;int debug ;if ( jas_init ( ) ) {debug = 0 ;while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_DEBUG : debug = atoi ( jas_optarg ) ;break ;case OPT_INFILE : infile = jas_optarg ;jas_setdbglevel ( debug ) ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {jas_stream_close ( instream ) ;",26
40,"if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\","if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\",26
41,"asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr )  {console_verbose ( ) ;die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ;local_irq_disable ( ) ;panic ( ""bad<S2SV_blank>mode"" ) ;","asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) {siginfo_t info ;void __user * pc = ( void __user * ) instruction_pointer ( regs ) ;console_verbose ( ) ;__show_regs ( regs ) ;info . si_signo = SIGILL ;info . si_errno = 0 ;info . si_code = ILL_ILLOPC ;info . si_addr = pc ;arm64_notify_die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , & info , 0 ) ;",27
42,"ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str ,  ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ;if ( length > 5 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ;}","if ( length < 5 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( dat ) ) ) ;ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;dat += 2 ;length -= 2 ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str , ""Direction-#%u"" , EXTRACT_8BITS ( ptr ) ) ) ) ;length -- ;if ( length != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length ) ;}",28
43,"int alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( alt < 0 )  return alt ;return usb_set_interface ( udev ,  intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ;}","struct usb_host_interface * alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( ! alt ) return - ENODEV ;return usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ;}",29
44,"static void udf_pc_to_char ( struct super_block * sb , unsigned char * from ,   int fromlen , unsigned char * to )  {unsigned char * p = to ;while ( elen < fromlen ) {case 2 :  p = to ;* p ++ = \'/\' ;break ;case 3 : memcpy ( p , ""../"" , 3 ) ;break ;case 4 :  memcpy ( p , ""./"" , 2 ) ;p += 2 ;break ;case 5 :  p += udf_get_filename ( sb , pc -> componentIdent , p ,  pc -> lengthComponentIdent ) ;* p ++ = \'/\' ;break ;}","static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) {int comp_len ;unsigned char * p = to ;tolen -- ;while ( elen < fromlen ) {case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ;p = to ;* p ++ = \'/\' ;tolen -- ;break ;case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ;memcpy ( p , ""../"" , 3 ) ;tolen -= 3 ;break ;case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ;memcpy ( p , ""./"" , 2 ) ;p += 2 ;tolen -= 2 ;break ;case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ;p += comp_len ;tolen -= comp_len ;if ( tolen == 0 ) return - ENAMETOOLONG ;* p ++ = \'/\' ;tolen -- ;break ;return 0 ;}",30
45,"if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) {err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;","if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 || class == CLIENT_TYPE_MASTER ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\\\'master\\\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" ;",31
46,"if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;","if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;",31
47,"unsigned long flags ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;","unsigned long flags ;if ( qid > NVMET_NR_QUEUES ) return NULL ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;",32
48,"dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ;usb_set_intfdata ( interface , dev ) ;retval = usb_register_dev ( interface , & tower_class ) ;if ( retval ) {dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\\usb_set_intfdata ( interface , NULL ) ;goto error ;}dev -> minor = interface -> minor ;dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\\","
",33
49,exit :  return retval ;,"usb_set_intfdata ( interface , dev ) ;retval = usb_register_dev ( interface , & tower_class ) ;if ( retval ) {dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\\usb_set_intfdata ( interface , NULL ) ;goto error ;}dev -> minor = interface -> minor ;dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\\exit : return retval ;",33
50,"if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return false ;}Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ;if ( ! defs ) {return false ;}if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) {section_name = & bin -> shstrtab [ shdr -> sh_name ] ;}if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) {link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ;}if ( ! defs ) {bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\return NULL ;}sdb = sdb_new0 ( ) ;end = ( char * ) defs + shdr -> sh_size ;sdb_set ( sdb , ""section_name"" , section_name , 0 ) ;sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ;++ cnt ) {Sdb * sdb_verdef = sdb_new0 ( ) ;char * vstart = ( ( char * ) defs ) + i ;char key [ 32 ] = {0 };Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;Elf_ ( Verdaux ) aux = {0 };int j = 0 ;int isum = 0 ;r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ;verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ;if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {sdb_free ( sdb_verdef ) ;",+ cnt ) {if ( shdr -> sh_size < 1 || vstart + vdaux < vstart ) {sdb_free ( sdb_verdef ) ;,34
51,"static void construct_get_dest_keyring ( struct key * * _dest_keyring )  {kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {key_get ( dest_keyring ) ;}else {switch ( cred -> jit_keyring ) {case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) {authkey = cred -> request_key_auth ;down_read ( & authkey -> sem ) ;rka = authkey -> payload . data [ 0 ] ;if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ;up_read ( & authkey -> sem ) ;if ( dest_keyring )  break ;}","static int construct_get_dest_keyring ( struct key * * _dest_keyring ) {int ret ;kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {do_perm_check = false ;break ;}}",35
52,}* _dest_keyring = dest_keyring ;return ;},"if ( dest_keyring && do_perm_check ) {ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ;if ( ret ) {key_put ( dest_keyring ) ;return 0 ret ;}}}* _dest_keyring = dest_keyring ;return ;}",35
53,sc = create_spnego_ctx ( ) ;if ( sc == NULL ) return GSS_S_FAILURE ;,sc = create_spnego_ctx ( 1 ) ;if ( sc == NULL ) return GSS_S_FAILURE ;,36
54,"if ( ! sock_flag ( sk , SOCK_ZAPPED ) )  return - EINVAL ;if ( addr_len < sizeof ( struct sockaddr_l2tpip ) )  return - EINVAL ;if ( addr -> l2tp_family != AF_INET )  return - EINVAL ;lock_sock ( sk ) ;if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;","if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ;if ( addr -> l2tp_family != AF_INET ) return - EINVAL ;if ( addr -> l2tp_family != AF_INET ) return - EINVAL ;lock_sock ( sk ) ;if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out ;if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;",37
55,static unsigned int stack_maxrandom_size ( void )  {unsigned int max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ;},static unsigned long stack_maxrandom_size ( void ) {unsigned long max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1UL ) & STACK_RND_MASK ) << PAGE_SHIFT ;},38
56,"gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;","gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;",39
57,tm = localtime ( & t ) ;str = g_strdup ( asctime ( tm ) ) ;,"tm = localtime ( & t ) ;if ( tm == NULL ) return g_strdup ( ""???"" ) ;str = g_strdup ( asctime ( tm ) ) ;",40
58,"memcpy ( hashed , password , strlen ( password ) ) ;attr = find_attribute ( request , PW_PASSWORD ) ;","memcpy ( hashed , password , length ) ;attr = find_attribute ( request , PW_PASSWORD ) ;",41
59,"static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ ] = {0x51 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;","static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;mutex_unlock ( & d -> data_mutex ) ;adap -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;",42
60,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",43
61,"if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;","fix_google_param ( google_out ) ;fix_google_param ( google_sig ) ;fix_google_param ( google_reqId ) ;fix_google_param ( google_version ) ;fix_google_param ( responseHandler ) ;fix_google_param ( outFileName ) ;if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;",44
62,"static void  horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % stride ) == 0 ) ;if ( cc > stride ) {","static int horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ;return 0 ;}if ( cc > stride ) {",45
63,"
",return 1 ;,45
64,},},45
65,inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;,"uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",46
66,"struct address_space * mapping ;mapping = ( struct address_space * ) page_private ( page ) ;if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) {update_and_free_page ( h , page ) ;h -> surplus_huge_pages -- ;h -> surplus_huge_pages_node [ nid ] -- ;}else {enqueue_huge_page ( h , page ) ;}spin_unlock ( & hugetlb_lock ) ;if ( mapping )  hugetlb_put_quota ( mapping , 1 ) ;","struct hugepage_subpool * spool = ( struct hugepage_subpool * ) page_private ( page ) ;hugepage_subpool_put_pages ( spool , 1 ) ;",47
67,"
",if ( avio_feof ( pb ) ) {return AVERROR_EOF ;},48
68,"if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\","if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\",48
69,if ( ! e || e == p )  goto not_found ;,if ( ! e || e == p ) goto not_found ;if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;,49
70,"void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf )  {get_page ( buf -> page ) ;}","bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {return try_get_page ( buf -> page ) ;}",50
71,"while ( cp < ep && cp < ep2 ) {if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;}if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ;","while ( cp < ep && cp < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ;",51
72,"if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  attr -> ia_mode &= ~ S_ISGID ;","if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) attr -> ia_mode &= ~ S_ISGID ;",52
73,"timeout . tv_usec = 0 ;select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ;return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ;","TEMP_FAILURE_RETRY ( timeout . tv_usec = 0 ;select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ) ;return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ;",53
74,fpm_globals . max_requests = wp -> config -> pm_max_requests ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,fpm_globals . max_requests = wp -> config -> pm_max_requests ;fpm_globals . listening_socket = dup ( wp -> listening_socket ) ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,54
75,"static int detect_transition_to_still ( struct twopass_rc * twopass ,  int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) {int trans_to_still = 0 ;if ( frame_interval > MIN_GF_INTERVAL &&  loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) {const FIRSTPASS_STATS * position = twopass -> stats_in ;FIRSTPASS_STATS tmp_next_frame ;if ( EOF == input_stats ( twopass , & tmp_next_frame ) )  break ;if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 )  break ;reset_fpf_position ( twopass , position ) ;if ( j == still_interval )  trans_to_still = 1 ;return trans_to_still ;}","static int detect_transition_to_still ( VP9_COMP * cpi , int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) {TWO_PASS * const twopass = & cpi -> twopass ;RATE_CONTROL * const rc = & cpi -> rc ;if ( frame_interval > rc -> min_gf_interval && loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) {if ( EOF == input_stats ( twopass , & tmp_next_frame ) ) break ;if ( stats -> pcnt_inter - stats -> pcnt_motion < 0.999 ) break ;return j == still_interval ) trans_to_still = 1 ;}return 0 ;",55
76,if ( ! handle -> h_transaction ) {err = jbd2_journal_stop ( handle ) ;return handle -> h_err ? handle -> h_err : err ;}sb = handle -> h_transaction -> t_journal -> j_private ;err = handle -> h_err ;,err = handle -> h_err ;if ( ! handle -> h_transaction ) {rc = jbd2_journal_stop ( handle ) ;return err ? err : rc ;}sb = handle -> h_transaction -> t_journal -> j_private ;,56
77,"if ( io -> flag != EXT4_IO_UNWRITTEN ) return ret ;if ( offset + size <= i_size_read ( inode ) )  ret = ext4_convert_unwritten_extents ( inode , offset , size ) ;","ret = ext4_convert_unwritten_extents ( inode , offset , size ) ;",57
78,"
",args -> rmtvaluelen = args -> valuelen ;,58
79,"}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;","}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;",58
80,"request_module ( ""%s"" , name ) ;if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) )  request_module ( ""%s-all"" , name ) ;alg = crypto_alg_lookup ( name , type , mask ) ;","request_module ( ""crypto-%s"" , name ) ;if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) request_module ( ""crypto-%s-all"" , name ) ;alg = crypto_alg_lookup ( name , type , mask ) ;",59
81,"stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;switch ( stlv_type ) {case ISIS_SUBTLV_SPB_INSTANCE :  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\","ND_TCHECK2 ( * tptr , 2 ) ;stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;if ( len < stlv_len ) goto trunc ;ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;switch ( stlv_type ) {case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",60
82,"while ( tmp )  {ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ;ND_PRINT ( ( ndo , ""\\\len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;tmp -- ;case ISIS_SUBTLV_SPBM_SI :  ND_TCHECK2 ( * tptr , 8 ) ;ND_PRINT ( ( ndo , ""\\\","stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;while ( tmp ) {if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;tmp -- ;case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",60
83,}return 0 ;,tptr += stlv_len ;len -= stlv_len ;}return 0 ;,60
84,"return reply_msg ( c , MSG_BAD_FORMAT ) ;type = which_cmd ( c ) ;dprintf ( ""got<S2SV_blank>%s<S2SV_blank>command:<S2SV_blank>\\\\""%s\\\\""\\\switch ( type ) {case OP_PUT : r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;r = read_delay ( & delay , delay_buf , & ttr_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;r = read_ttr ( & ttr , ttr_buf , & size_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;errno = 0 ;body_size = strtoul ( size_buf , & end_buf , 10 ) ;if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ;if ( body_size > job_data_size_limit ) {return reply_msg ( c , MSG_JOB_TOO_BIG ) ;}","return skip ( c , body_size + 2 , MSG_JOB_TOO_BIG ) ;",61
85,"ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;","memset ( & ddi , 0 , sizeof ( ddi ) ) ;ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;",62
86,if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;,if ( ! ( opt_len == 12 && ( flags & TH_SYN ) ) && ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;,63
87,int procfd = payload -> procfd ;lxc_attach_options_t * options = payload -> options ;,lxc_attach_options_t * options = payload -> options ;,64
88,"uid_t new_uid ;gid_t new_gid ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;","int lsm_labelfd ;uid_t new_uid ;gid_t new_gid ;ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;",64
89,"ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ;ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}new_uid = 0 ;new_gid = 0 ;if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ;if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ;if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ;if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) {if ( setsid ( ) < 0 ) {SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ;if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) {SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}}","ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s."" , strerror ( errno ) ) ;ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>"" ""that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s"" , strerror ( errno ) ) ;",64
90,"ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;","ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;",64
91,"rexit ( - 1 ) ;}INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;}on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {rexit ( - 1 ) ;}rexit ( - 1 ) ;}lxc_proc_put_context_info ( init_ctx ) ;if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ;if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ;if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ;if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ;if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ;if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ;for ( fd = 0 ;fd <= 2 ;fd ++ ) {flags = fcntl ( fd , F_GETFL ) ;if ( flags < 0 ) continue ;if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ;}close ( procfd ) ;rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;","shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>"" ""gainable<S2SV_blank>privileges."" ) ;}status = 3 ;ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ;if ( ret <= 0 ) {ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ;if ( ret <= 0 ) {ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( lsm_labelfd , on_exec , init_ctx -> lsm_label ) < 0 ) {SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label."" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;close ( lsm_labelfd ) ;rexit ( - 1 ) ;}close ( lsm_labelfd ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;",64
92,"line += 3 ;if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) )  goto out_err ;line = ptr + 1 ;if ( ! ( ptr = strchr ( line , '\\\","if ( len < 3 ) goto out_err ;line += 3 ;len -= 3 ;if ( ! ( ptr = memchr ( line , '<S2SV_blank>' , len ) ) ) goto out_err ;if ( len < 1 ) goto out_err ;line = ptr + 1 ;len -= 1 ;if ( ! ( ptr = memchr ( line , '\\\",65
93,switch ( header -> biSize ) {,"switch ( header -> biBitCount == 0 ) {fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\\return OPJ_FALSE ;}if ( header -> biSize ) {",66
94,if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,66
95,"SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\","sas_probe_devices ( port ) ;SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\",67
96,"
",if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;,68
97,"if ( tga_info . colormap_type != 0 )  {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","if ( tga_info . colormap_type != 0 ) {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",68
98,"ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;",69
99,}line . clock_type = get_status ( port ) -> clocking ;,"}memset ( & line , 0 , sizeof ( line ) ) ;line . clock_type = get_status ( port ) -> clocking ;",70
100,"return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;}","int ret ;ret = scsi_verify_blk_ioctl ( bd , cmd ) ;if ( ret < 0 ) return ret ;return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;}",71
101,"void nego_process_negotiation_request ( rdpNego * nego , wStream * s )  {UINT16 length ;Stream_Read_UINT8 ( s , flags ) ;}","BOOL nego_process_negotiation_request ( rdpNego * nego , wStream * s ) {UINT16 length ;if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE ;Stream_Read_UINT8 ( s , flags ) ;return TRUE ;}",72
102,int req_len ;struct qeth_arp_query_info qinfo = {,unsigned int req_len ;struct qeth_arp_query_info qinfo = {,73
103,"if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  return - EFAULT ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;","if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) return - EFAULT ;if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;",73
104,int m ;m = n ;,"int m ;if ( n < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ;}m = n ;",74
105,int xd_size = 0 ;int data_len [ 256 ] ;,int xd_size = 1 ;int data_len [ 256 ] ;,75
106,"xd_size += len ;}ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ;","xd_size += len + 1 + len / 255 ;}ret = ff_alloc_extradata ( st -> codecpar , xd_size ) ;",75
107,if ( delta > data_len [ j ] ) {return AVERROR_INVALIDDATA ;},av_assert0 ( delta <= xd_size - offset ) ;,75
108,offset += data_len [ j ] ;},av_assert0 ( data_len [ j ] <= xd_size - offset ) ;offset += data_len [ j ] ;},75
109,"av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\\","av_log ( mxf -> fc -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\\",76
110,"av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\\continue ;","av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\\continue ;",76
111,"return mount_entry_on_generic ( mntent , path ) ;}","return mount_entry_on_generic ( mntent , path , rootfs ) ;}",77
112,"-------------------\\\psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;return 1 ;return 0 ;}","if ( psf -> fileoffset < psf -> filelength ) {psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;return 1 ;};return 0 ;}",78
113,"
",ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;,79
114,l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,79
115,return NF_ACCEPT ;},return err == 0 ? NF_ACCEPT : NF_DROP ;},80
116,"if ( ! rta )  return 0 ;p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;if ( ! p ) return - ENOMEM ;pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;if ( ! pp ) {* replay_esn = p ;* preplay_esn = pp ;","int klen , ulen ;if ( ! rta ) return 0 ;klen = xfrm_replay_state_esn_len ( up ) ;ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ;p = kzalloc ( klen , GFP_KERNEL ) ;if ( ! p ) return - ENOMEM ;pp = kzalloc ( klen , GFP_KERNEL ) ;if ( ! pp ) {memcpy ( p , up , ulen ) ;memcpy ( pp , up , ulen ) ;* replay_esn = p ;* preplay_esn = pp ;",81
117,io -> io_cleanup = mem_cleanup ;switch ( io -> regsize ) {,switch ( io -> regsize ) {,82
118,"
",io -> io_cleanup = mem_cleanup ;,82
119,return 0 ;},return 0 ;},82
120,result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;break ;,result = ( MagickRealType ) ( ( ssize_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;break ;,83
121,result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;break ;,result = ( MagickRealType ) ( ( ssize_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;break ;,83
122,result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;break ;,result = ( MagickRealType ) ( ( ssize_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;break ;,83
123,result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;break ;,result = ( MagickRealType ) ( ( ssize_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;break ;,83
124,"result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ;break ;}case ThresholdBlackEvaluateOperator : {result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ;case ThresholdWhiteEvaluateOperator : {result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ;break ;}case UniformNoiseEvaluateOperator : {result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ;break ;}case XorEvaluateOperator : {result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;break ;}",result = ( MagickRealType ) ( ( ssize_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;,83
125,btif_config_flush ( ) ;return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ;,"if ( is_restricted_mode ( ) ) {BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\\\'%s\\\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ;btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ;}btif_config_flush ( ) ;return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ;",84
126,"if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;","if ( ! ( buf = jas_alloc3 ( bufsize , numcols , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;",85
127,vpx_codec_enc_cfg_map_t * map ;if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ;for ( map = iface -> enc . cfg_maps ;map -> usage >= 0 ;map ++ ) {if ( map -> usage == ( int ) usage ) {,vpx_codec_enc_cfg_map_t * map ;int i ;if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ;for ( i = 0 ;i < iface -> enc . cfg_map_count ;++ i ) {map = iface -> enc . cfg_maps + i ;if ( map -> usage == ( int ) usage ) {,86
128,"netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\\return - EINVAL ;netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\\return - EINVAL ;","netdev_err ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;netdev_err ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;",87
129,"static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  {if ( bitmap_pos < 0 ) {char * name = path_name ( path , last ) ;bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}","static void show_object ( struct object * object , const char * last , void * data ) {if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}",88
130,"run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;free ( fname ) ;","run_cmd ( tty_fd , xfr_cmd , fname ) ;free ( fname ) ;",89
131,static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer )  {kfree ( mixer -> id_elems ) ;,static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) {snd_usb_mixer_disconnect ( mixer ) ;kfree ( mixer -> id_elems ) ;,90
132,"struct packet_sock * po = pkt_sk ( sk ) ;struct packet_fanout * f , * match ;","struct packet_rollover * rollover = NULL ;struct packet_sock * po = pkt_sk ( sk ) ;struct packet_fanout * f , * match ;",91
133,"if ( ! po -> running )   return - EINVAL ;if ( po -> fanout )  return - EALREADY ;if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ;if ( ! po -> rollover )  return - ENOMEM ;atomic_long_set ( & po -> rollover -> num , 0 ) ;atomic_long_set ( & po -> rollover -> num_huge , 0 ) ;atomic_long_set ( & po -> rollover -> num_failed , 0 ) ;}mutex_lock ( & fanout_mutex ) ;match = NULL ;list_for_each_entry ( f , & fanout_list , list ) {if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {match = f ;break ;}}if ( match && match -> flags != flags ) goto out ;if ( ! match ) {match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match ) goto out ;write_pnet ( & match -> net , sock_net ( sk ) ) ;match -> id = id ;match -> type = type ;match -> flags = flags ;INIT_LIST_HEAD ( & match -> list ) ;spin_lock_init ( & match -> lock ) ;atomic_set ( & match -> sk_ref , 0 ) ;fanout_init_data ( match ) ;match -> prot_hook . type = po -> prot_hook . type ;match -> prot_hook . dev = po -> prot_hook . dev ;match -> prot_hook . func = packet_rcv_fanout ;match -> prot_hook . af_packet_priv = match ;match -> prot_hook . id_match = match_fanout_group ;dev_add_pack ( & match -> prot_hook ) ;list_add ( & match -> list , & fanout_list ) ;}err = - EINVAL ;if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {err = - ENOSPC ;if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) {__dev_remove_pack ( & po -> prot_hook ) ;po -> fanout = match ;atomic_inc ( & match -> sk_ref ) ;__fanout_link ( sk , po ) ;err = 0 ;}}out :  mutex_unlock ( & fanout_mutex ) ;if ( err ) {kfree ( po -> rollover ) ;po -> rollover = NULL ;","mutex_lock ( & fanout_mutex ) ;if ( ! po -> running ) goto out ;err = - EALREADY ;if ( po -> fanout ) goto out ;if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ;if ( ! rollover ) goto out ;atomic_long_set ( & po -> rollover -> num , 0 ) ;atomic_long_set ( & rollover -> num_huge , 0 ) ;atomic_long_set ( & rollover -> num_failed , 0 ) ;mutex_lock ( & fanout_mutex ) ;",91
134,"memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;rcu_read_lock ( ) ;","memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;rcu_read_lock ( ) ;",92
135,return NULL ;},kfree ( table ) ;return NULL ;},93
136,"void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) {fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ;","static void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) {fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ;",94
137,buffer -> buffer_length = fbh -> length ;buffer -> buffer = ( char * ) fbh -> data ;if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) {,buffer -> buffer = ( char * ) fbh -> data ;imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ;imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ;buffer -> buffer = ( char * ) fbh -> data ;if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) {,95
138,"enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteBuffer ( interface , buffer , offset ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ;return NO_ERROR ;","enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ;enc28j60WriteReg ( interface , ENC28J60_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteBuffer ( interface , ENC28J60_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS ) ;return NO_ERROR ;",96
139,"
","value = ast2obj_string ( o -> type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;",97
140,value = ast2obj_int ( o -> lineno ) ;if ( ! value ) goto failed ;,value = ast2obj_int ( o -> lineno ) ;if ( ! value ) goto failed ;,97
141,"if ( page && ( access ( page , R_OK ) == 0 ) )  {file_write ( page , wikitext ) ;http_response_printf ( res , ""success"" ) ;return ;}if ( page && ( unlink ( page ) > 0 ) )  {","if ( page && page_name_is_good ( page ) && ( access ( page , R_OK ) == 0 ) ) {if ( page_name_is_good ( page ) ) {}file_write ( page , wikitext ) ;http_response_printf ( res , ""success"" ) ;return ;}if ( page && page_name_is_good ( page ) && ( unlink ( page ) > 0 ) ) {",98
142,"if ( page == NULL ) page = http_request_get_query_string ( req ) ;if ( page && ( access ( page , R_OK ) == 0 ) )  {","if ( page && page_name_is_good ( page ) == NULL ) page = http_request_get_query_string ( req ) ;if ( page && ( access ( page , R_OK ) == 0 ) ) {",98
143,"if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else  ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;goto out ;if ( flags == EXT4_GET_BLOCKS_CONVERT ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;","if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;goto out ;if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;",99
144,"ND_PRINT ( ( ndo , ""\\\switch ( opt ) {case IPCPOPT_2ADDR : if ( len != 10 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 6 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ;break ;case IPCPOPT_IPCOMP : if ( len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;",ND_TCHECK_16BITS ( p + 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;,100
145,"
","if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) {ret = - ENOENT ;goto out ;}",101
146,"if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;",101
147,"void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh ,  int flag )  {int mb_rows = source -> y_width >> 4 ;int mb_cols = source -> y_height >> 4 ;unsigned char * limits = cm -> pp_limits_buffer ;int mbr , mbc ;( void ) post ;vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;for ( mbr = 0 ;vp8_post_proc_down_and_across_mb_row (  source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride ,  source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;}","void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , int flag , int uvfilter ) {int mbr ;int mb_rows = cm -> mb_rows ;int mb_cols = source -> y_height >> 4 ;unsigned char * limits = cm -> pp_limits_buffer ;( void ) post ;memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;for ( mbr = 0 ;if ( uvfilter == 1 ) {vp8_post_proc_down_and_across_mb_row ( source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;}}",102
148,"ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;","struct floppy_raw_cmd cmd = * ptr ;cmd . next = NULL ;cmd . kernel_data = NULL ;ret = copy_to_user ( param , & cmd , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;",103
149,"skip :  if ( ( new -> euid != old -> uid ||  new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {","skip : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ;if ( ( new -> euid != old -> uid || new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {",104
150,"static void  ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh )  {struct mb_cache_entry * ce ;int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;error = 0 ;}else {ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;mb_cache_entry_release ( ce ) ;}","static void ext4_xattr_cache_insert ( struct mb2_cache * ext4_mb_cache , struct buffer_head * bh ) {int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;else ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;",105
151,"return NULL ;}host += 3 ;char * port = strchr ( host , \':\' ) ;if ( ! port ) {port = ( ssl ) ? ""443"" : ""80"" ;}else {* port ++ = 0 ;}char * path = strchr ( host , \'/\' ) ;if ( ! path ) {path = """" ;}else {* path ++ = 0 ;}s = r_socket_new ( ssl ) ;if ( ! s ) {printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\\free ( uri ) ;return NULL ;}if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) {","return socket_http_answer ( s , host , port , 0 ) ) {",106
152,"return r_socket_http_answer ( s , code , rlen ) ;}","return r_socket_http_answer ( s , code , rlen , 0 ) ;}",106
153,"tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z ,  & p -> buff , p -> name ) ;","tf = ( luaY_parser ) ( L , p -> z , & p -> buff , p -> name ) ;",107
154,int err ;sock -> state = SS_UNCONNECTED ;,int err ;if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ;sock -> state = SS_UNCONNECTED ;,108
155,"int ip_options_get_from_user ( struct net * net , struct ip_options * * optp ,  unsigned char __user * data , int optlen ) {struct ip_options * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) {kfree ( opt ) ;","int ip_options_get_from_user ( struct net * net , struct ip_options_rcu * * optp , unsigned char __user * data , int optlen ) {struct ip_options_rcu * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen && copy_from_user ( opt -> opt . __data , data , optlen ) ) {kfree ( opt ) ;",109
156,"dl = kmalloc ( size , GFP_KERNEL ) ;if ( ! dl ) return - ENOMEM ;","dl = kzalloc ( size , GFP_KERNEL ) ;if ( ! dl ) return - ENOMEM ;",110
157,"dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;","dagid_str = ip6addr_string ( ndo , ""%s"" , rpl_tstr ) ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",111
158,"static int   rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent )  {pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) ,  pdu_type , pdu_len ) ) ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU :  case RPKI_RTR_END_OF_DATA_PDU :  msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU :  break ;case RPKI_RTR_CACHE_RESPONSE_PDU :  ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ;tlen = pdu_len ;tptr += sizeof ( * pdu ) ;tlen -= sizeof ( * pdu ) ;if ( encapsulated_pdu_length &&  ( encapsulated_pdu_length <= tlen ) ) {if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) )  goto trunc ;tptr += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = 0 ;if ( tlen > 4 ) {text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;}ND_TCHECK2 ( * tptr , text_length ) ;if ( text_length && ( text_length <= tlen ) ) {ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ;if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ;}break ;default : hexdump = TRUE ;return 0 ;trunc :  return 1 ;}","static u_int rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , const u_int len , const u_char recurse , const u_int indent ) {ND_TCHECK_8BITS ( tptr ) ;if ( * tptr != 0 ) {ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ;return len ;}if ( len < sizeof ( rpki_rtr_pdu ) ) {ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ;goto invalid ;}ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , pdu_type , pdu_len ) ) ;if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;break ;case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;tlen = sizeof ( rpki_rtr_pdu ) ;if ( pdu_len < tlen + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , tlen + 4 ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;tlen += 4 ;if ( encapsulated_pdu_length && ( encapsulated_pdu_length <= tlen ) ) {rpki_rtr_pdu_print ( ndo , tptr + tlen , encapsulated_pdu_length , 0 , indent + 2 ) ;tlen += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = TRUE ;return 0 ;trunc : ND_PRINT ( ( ndo , ""\\\return len ;}",112
159,"int n , len ;skb -> sk = NULL ;memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ;len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ;len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ;if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) {rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ;","int n ;skb -> sk = NULL ;memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ;if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) {rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ;",113
160,addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;addr . sin_port = htons ( port ) ;,addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;addr . sin_port = htons ( port ) ;,114
161,# endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap )  {errmsg = keymap_init ( ) ;,# endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;else errmsg = keymap_init ( ) ;,115
162,if ( ! gui_mch_set_rendering_options ( p_rop ) )  errmsg = e_invarg ;,if ( ! gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ;}# endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;}# endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;,115
163,"ret = posix_acl_equiv_mode ( acl , & new_mode ) ;if ( ret < 0 ) goto out ;if ( ret == 0 ) acl = NULL ;","ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ;if ( ret ) goto out ;",116
164,"struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;int ret , i ;","struct o2nm_cluster * cluster ;int ret , i ;",117
165,ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;,o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {o2nm_unlock_subsystem ( ) ;return - EINVAL ;}ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;o2nm_unlock_subsystem ( ) ;,117
166,if ( ret )  return ret ;,if ( ret ) return ret ;,117
167,"case BSD_AFNUM_ISO :  isoclns_print ( ndo , p , length , caplen ) ;break ;","case BSD_AFNUM_ISO : isoclns_print ( ndo , p , length , caplen ) ;break ;",118
168,# endif if ( * src == \'/\' )  separator = * src ++ ;for ( ;,"# endif if ( * src == \'/\' ) {if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ;return ( ARCHIVE_FAILED ) ;}separator = * src ++ ;}for ( ;",119
169,"TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg ,  TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {TPM2B_DIGEST tmpResult ;TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;TPM_RC rval ;int i , j ;","TPM_RC tpm_kdfa ( TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;TPM_RC rval = TPM_RC_SUCCESS ;int i , j ;",120
170,"while ( resultKey -> t . size < bytes )  {i_Swizzled = string_bytes_endian_convert_32 ( i ) ;* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;if ( rval != TPM_RC_SUCCESS )  {return ( rval ) ;return TSS2_SYS_RC_BAD_VALUE ;}return TPM_RC_SUCCESS ;","const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ;if ( ! md ) {LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ;return TPM_RC_HASH ;}HMAC_CTX ctx ;HMAC_CTX_init ( & ctx ) ;int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;return TPM_RC_MEMORY ;}while ( resultKey -> t . size < bytes ) {TPM2B_DIGEST tmpResult ;i_Swizzled = string_bytes_endian_convert_32 ( i ) ;* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ;int c ;for ( c = 0 ;c < j ;c ++ ) {TPM2B_DIGEST * digest = bufferList [ c ] ;int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;rval = TPM_RC_MEMORY ;goto err ;tmpResult . t . size = size ;rval = TSS2_SYS_RC_BAD_VALUE ;goto err ;}err : HMAC_CTX_cleanup ( & ctx ) ;return rval ;",120
171,"cmpt = 0 ;if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) {if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) ||  ! jas_safe_intfast32_add ( tly , height , 0 ) ) {goto error ;}if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) {goto error ;}cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ;cmpt -> tlx_ = tlx ;cmpt -> tly_ = tly ;cmpt -> hstep_ = hstep ;cmpt -> vstep_ = vstep ;cmpt -> width_ = width ;cmpt -> height_ = height ;cmpt -> prec_ = depth ;cmpt -> sgnd_ = sgnd ;cmpt -> stream_ = 0 ;cmpt -> cps_ = ( depth + 7 ) / 8 ;if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) ||  ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) {","JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\\cmpt = 0 ;if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) {if ( ! jas_safe_size_mul3 ( cmpt -> width_ , cmpt -> height_ , & size ) || ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) {",121
172,tdata_t _TIFFmalloc ( tsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,tdata_t _TIFFmalloc ( tsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,122
173,if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ;if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,123
174,"
","( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;",124
175,MinVal = 0 ;MaxVal = 0 ;,MinVal = 0 ;MaxVal = 0 ;,124
176,if ( peer )  get_net ( peer ) ;spin_unlock_bh ( & net -> nsid_lock ) ;,if ( peer ) peer = maybe_get_net ( peer ) ;spin_unlock_bh ( & net -> nsid_lock ) ;,125
177,while ( header_buf [ i ] == '\\\\r' || header_buf [ i ] == '\\\,while ( ( i < ( int ) header_buf_used ) && ( header_buf [ i ] == '\\\\r' || header_buf [ i ] == '\\\,126
178,"assert ( proto != LLDP_MGMT_ADDR_NONE ) ;if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ;","if ( proto == LLDP_MGMT_ADDR_NONE ) continue ;if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ;",127
179,if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) ||  dp == datalen ) {flags &= ~ FLAG_LAST_MATCHED ;,if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) ) {flags &= ~ FLAG_LAST_MATCHED ;,128
180,"list_add_tail ( & sp -> auto_asconf_list ,  & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;}else   sp -> do_auto_asconf = 0 ;local_bh_enable ( ) ;","spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;list_add_tail ( & sp -> auto_asconf_list , & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;}else {sp -> do_auto_asconf = 0 ;}local_bh_enable ( ) ;",129
181,"static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb )  {s -> avctx -> profile = get_bits ( gb , 4 ) ;s -> avctx -> level = get_bits ( gb , 4 ) ;if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) {s -> avctx -> level = 0 ;}","static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb , int * profile , int * level ) {* profile = get_bits ( gb , 4 ) ;* level = get_bits ( gb , 4 ) ;if ( * profile == 0 && s -> avctx -> level == 8 ) {* level = 0 ;}",130
182,"spin_lock_irqsave ( & mpu -> input_lock , flags ) ;while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) !=  readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) {u16 wTmp , val ;val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ;if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ;wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ;if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ;else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ;spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ;","u16 head , tail , size ;spin_lock_irqsave ( & mpu -> input_lock , flags ) ;head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ;tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ;size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ;if ( head > size || tail > size ) goto out ;while ( head != tail ) {unsigned char val = readw ( pwMIDQData + 2 * head ) ;if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val , 1 ) ;if ( ++ head > size ) head = 0 ;writew ( head , mpu -> dev -> MIDQ + JQS_wHead ) ;out : spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ;",131
183,return result ;},if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;return result ;},132
184,file_sb_list_del ( file ) ;file_free ( file ) ;,file_free ( file ) ;,133
185,passert ( GLOBALS_ARE_RESET ( ) ) ;},},134
186,\\\\\\,\\\\\\,135
187,"if ( s_poll_interval == NULL )  s_poll_interval = ""3000"" ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id ,  session_state , op_iframe_id , s_poll_interval , redirect_uri ,  redirect_uri ) ;","int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ;if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , session_state , op_iframe_id , poll_interval , redirect_uri , redirect_uri ) ;",135
188,"static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req ,  size_t * acl_len )  {__be32 * savep ;uint32_t attrlen , bitmap [ 3 ] = {* acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 )  goto out ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;recvd = req -> rq_rcv_buf . len - hdrlen ;dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr""  ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\* acl_len = attrlen ;}","static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , struct nfs_getaclres * res ) {__be32 * savep , * bm_p ;uint32_t attrlen , bitmap [ 3 ] = {res -> acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) goto out ;bm_p = xdr -> p ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;xdr -> p = bm_p ;res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ;res -> acl_data_offset <<= 2 ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;attrlen += res -> acl_data_offset ;recvd = req -> rq_rcv_buf . len - hdrlen ;if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) {res -> acl_len = attrlen ;goto out ;}dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\res -> acl_len = attrlen ;}",136
189,nexthdr = * prevhdr ;* prevhdr = NEXTHDR_FRAGMENT ;,if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;nexthdr = * prevhdr ;* prevhdr = NEXTHDR_FRAGMENT ;,137
190,while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) {i ++ ;,while ( ( i < to_read ) && ( tmpName [ i ] != 0 ) ) {i ++ ;,138
191,"long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",139
192,"for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ;","for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ;",140
193,"strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ;}","strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 ) ;}",141
194,"owner = stok ( auth , "":"" , & tok ) ;if ( owner && * owner ) {","owner = ssplit ( auth , "":"" , & tok ) ;if ( owner && * owner ) {",142
195,"group = stok ( tok , "":"" , & perms ) ;if ( group && * group ) {","group = ssplit ( tok , "":"" , & perms ) ;if ( group && * group ) {",142
196,"q = ( const uint8_t * ) ( const void * )  ( ( const char * ) ( const void * ) p +  CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {","size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {",143
197,if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;,"struct ip_options_rcu * inet_opt ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;",144
198,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_INET_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",145
199,"tlen = len - sizeof ( struct eigrp_common_header ) ;ND_PRINT ( ( ndo , ""\\\","if ( len < sizeof ( struct eigrp_common_header ) ) {ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ;if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ;break ;}return ;}tlen = len - sizeof ( struct eigrp_common_header ) ;ND_PRINT ( ( ndo , ""\\\",146
200,"tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;if ( bit_length > 32 ) {","tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ;if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ;break ;}bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;if ( bit_length > 32 ) {",146
201,bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;if ( bit_length > 32 ) {,"if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ;break ;}bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;if ( bit_length > 32 ) {",146
202,"ND_PRINT ( ( ndo , ""\\\case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\","if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case EIGRP_TLV_AT_INT : tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\",146
203,"# if CONFIG_MEM_MANAGER  int number_aau ;if ( vpx_mm_create_heap_memory ( ) < 0 ) {_P ( printf ( ""[vpx][mm]<S2SV_blank>ERROR<S2SV_blank>vpx_memalign()<S2SV_blank>Couldn\\\'t<S2SV_blank>create<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Heap.\\\) }number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ;# endif  if ( addr ) {",addr = malloc ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ;if ( addr ) {,147
204,"int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ;long long export_index_table [ indexes ] ;res = read_fs_bytes ( fd , sBlk . s . lookup_table_start ,  SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ;","int indexes = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ;int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) sBlk . s . inodes ) ;long long * export_index_table ;if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) {ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\return FALSE ;}export_index_table = alloc_index_table ( indexes ) ;res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , length , export_index_table ) ;",148
205,"ptr = strchr ( ptr + 1 , '/' ) + 1 ;rw_exit ( & sdvp -> sdev_contents ) ;","ptr = strchr ( ptr + 1 , '/' ) ;if ( ptr == NULL ) return ( ENOENT ) ;ptr ++ ;rw_exit ( & sdvp -> sdev_contents ) ;",149
206,"flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;","if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;",150
207,"ret = posix_acl_equiv_mode ( acl , & new_mode ) ;if ( ret < 0 ) goto out ;if ( ret == 0 ) acl = NULL ;","ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ;if ( ret ) goto out ;",151
208,"else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SecRuleEngine:<S2SV_blank>%s"" , p1 ) ;return NULL ;","else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SexHashEngine:<S2SV_blank>%s"" , p1 ) ;return NULL ;",152
209,"
",rcu_read_lock ( ) ;,153
210,"final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",153
211,"uint16 nstrips = 0 , ntiles = 0 , planar = 0 ;uint16 bps = 0 , spp = 0 , res_unit = 0 ;","uint32 nstrips = 0 , ntiles = 0 ;uint16 planar = 0 ;uint16 bps = 0 , spp = 0 , res_unit = 0 ;",154
212,"if ( ! read_buff )  read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;else  {if ( prev_readsize < buffsize )  {new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ;","if ( ! read_buff ) {if ( buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ;return ( - 1 ) ;}read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;}else {if ( prev_readsize < buffsize ) {if ( buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ;return ( - 1 ) ;}new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ;",154
213,if ( 0 ) {# if CONFIG_VP8_ENCODER },"# if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ;# endif # if CONFIG_VP10_ENCODER }else if ( strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) {ctrl_args = vp10_args ;ctrl_args_map = vp10_arg_ctrl_map ;# endif if ( 0 ) {# if CONFIG_VP8_ENCODER }",155
214,# endif  }for ( argi = argj = argv ;,# endif }for ( argi = argj = argv ;,155
215,"if ( 0 ) {}else if ( arg_match ( & arg , & outputfile , argi ) ) {}","if ( arg_match ( & arg , & outputfile , argi ) ) {# if CONFIG_FP_MB_STATS }else if ( arg_match ( & arg , & fpmbf_name , argi ) ) {config -> fpmb_stats_fn = arg . val ;# endif }else if ( arg_match ( & arg , & use_webm , argi ) ) {# if CONFIG_WEBM_IO config -> write_webm = 1 ;# else die ( ""Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled."" ) ;# endif }else if ( arg_match ( & arg , & use_ivf , argi ) ) {config -> write_webm = 0 ;}else if ( arg_match ( & arg , & fpf_name , argi ) ) {config -> stats_fn = arg . val ;# if CONFIG_VP9_HIGHBITDEPTH }else if ( arg_match ( & arg , & bitdeptharg , argi ) ) {config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ;# endif }else if ( arg_match ( & arg , & resize_width , argi ) ) {config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_height , argi ) ) {config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) {config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ;# endif # if CONFIG_WEBM_IO }",155
216,}config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;},}config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;},155
217,"if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) {warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\\config -> cfg . g_lag_in_frames = 0 ;}}else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) {config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_allowed , argi ) ) {config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) {config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & end_usage , argi ) ) {config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ;}else if ( arg_match ( & arg , & target_bitrate , argi ) ) {config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & min_quantizer , argi ) ) {config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & max_quantizer , argi ) ) {config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & undershoot_pct , argi ) ) {config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & overshoot_pct , argi ) ) {config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_sz , argi ) ) {config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) {config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) {config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & bias_pct , argi ) ) {config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & minsection_pct , argi ) ) {config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & maxsection_pct , argi ) ) {config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & kf_min_dist , argi ) ) {config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & kf_max_dist , argi ) ) {config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ;config -> have_kf_max_dist = 1 ;}else if ( arg_match ( & arg , & kf_disabled , argi ) ) {config -> cfg . kf_mode = VPX_KF_DISABLED ;}else {int i , match = 0 ;for ( i = 0 ;ctrl_args [ i ] ;i ++ ) {if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) {int j ;match = 1 ;for ( j = 0 ;j < config -> arg_ctrl_cnt ;j ++ )  if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] )  break ;assert ( j < ARG_CTRL_CNT_MAX ) ;if ( j < ARG_CTRL_CNT_MAX ) {config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ;return eos_mark_found ;}","if ( ctrl_args_map != NULL && j < ( int ) ARG_CTRL_CNT_MAX ) {config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ;# if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) {config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ;# endif }return eos_mark_found ;}",155
218,"if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) {","if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ! use_privsep || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) {",156
219,if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0  || no_port_forwarding_flag || options . disable_forwarding ) {success = 0 ;,if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding ) {success = 0 ;,156
220,dev -> netdev_ops = & l2tp_eth_netdev_ops ;dev -> destructor = free_netdev ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & l2tp_eth_netdev_ops ;dev -> destructor = free_netdev ;,157
221,"
","if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",158
222,for ( ;offset ++ )  {,for ( ;offset ++ ) {,158
223,"if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;","gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . length = 4 ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;",159
224,if ( ext_depth ( inode ) )  goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ;,size_t ext_size = 0 ;if ( ext_depth ( inode ) ) goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ;,160
225,"memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data ,   sizeof ( EXT4_I ( inode ) -> i_data ) ) ;neh = ext_block_hdr ( bh ) ;","ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ;memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , ext_size ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;neh = ext_block_hdr ( bh ) ;",160
226,"if ( verify_checks ( c , preverify_ok , callback_ctx ) ) {SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ;int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated ,  ( void * ) ( - 1 ) ) ;SSL_SESSION_free ( sess ) ;","if ( verify_checks ( c , preverify_ok , callback_ctx ) ) return 1 ;if ( c -> opt -> option . client || c -> opt -> protocol ) return 0 ;if ( c -> opt -> redirect_addr . names ) {SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ;int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated , NULL ) ;SSL_SESSION_free ( sess ) ;",161
227,if ( c -> opt -> option . client || c -> opt -> protocol )  return 0 ;if ( c -> opt -> redirect_addr . names )  return 1 ;,"
",161
228,"int ret ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;","int ret ;if ( current_chrooted ( ) ) return - EPERM ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;",162
229,"if ( is_signed ) {if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ;fixed_length = at91_aes_roundup ( data_length ) ;cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ;if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) )  goto exit ;","if ( ! consttime_memequal ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) goto exit ;",163
230,"c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ;if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) {av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\\return AVERROR_INVALIDDATA ;}if ( c -> nreslevels < s -> reduction_factor )   c -> nreslevels2decode = 1 ;else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ;",c -> nreslevels <= s -> reduction_factor ) c -> nreslevels2decode = 1 ;else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ;,164
231,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",165
232,"bool is_drop_n_account = false ;BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ;if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ;sk = pt -> af_packet_priv ;po = pkt_sk ( sk ) ;if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ;if ( dev -> header_ops ) {",bool is_drop_n_account = false ;bool do_vnet = false ;BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ;if ( do_vnet ) {,166
233,if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;macoff = netoff - maclen ;},if ( po -> has_vnet_hdr ) {netoff += sizeof ( struct virtio_net_hdr ) ;do_vnet = true ;}macoff = netoff - maclen ;},166
234,if ( ( int ) snaplen < 0 )   snaplen = 0 ;},if ( ( int ) snaplen < 0 ) {snaplen = 0 ;do_vnet = false ;}},166
235,}},do_vnet = false ;}},166
236,"if ( po -> has_vnet_hdr ) {if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {","if ( po -> has_vnet_hdr ) {if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {",166
237,"}if ( ! asoc -> assoc_id ) {sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ;}}kfree ( asoc -> peer . peer_random ) ;asoc -> peer . peer_random = new -> peer . peer_random ;new -> peer . peer_random = NULL ;kfree ( asoc -> peer . peer_chunks ) ;asoc -> peer . peer_chunks = new -> peer . peer_chunks ;new -> peer . peer_chunks = NULL ;kfree ( asoc -> peer . peer_hmacs ) ;asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ;new -> peer . peer_hmacs = NULL ;sctp_auth_key_put ( asoc -> asoc_shared_key ) ;sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ;","sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ;",167
238,return true ;},if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ;else return true ;},168
239,"int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) {int labelfd = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 )  goto out ;if ( strcmp ( name , ""none"" ) == 0 )  goto out ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;if ( on_exec ) {labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ;}else {labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ;}if ( labelfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}ret = - 1 ;goto out ;ret = - 1 ;goto out ;}if ( write ( labelfd , command , size + 1 ) < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}else if ( strcmp ( name , ""SELinux"" ) == 0 ) {if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) {ret = - 1 ;ret = - 1 ;goto out ;if ( labelfd != - 1 )   close ( labelfd ) ;return ret ;}","static int lsm_set_label_at ( int lsm_labelfd , int on_exec , char * lsm_label ) {int fret = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 ) return 0 ;if ( strcmp ( name , ""none"" ) == 0 ) return 0 ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;ret = - 1 ;goto out ;goto out ;if ( write ( labelfd , command , size + 1 ) < 0 ) {INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ;ret = - 1 ;goto out ;if ( labelfd != - 1 ) close ( labelfd ) ;return fret ;}",169
240,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},170
241,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,170
242,"static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  {","static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) {",171
243,"if ( perf_event_overflow ( event , nmi , & data , regs ) )  power_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) power_pmu_stop ( event , 0 ) ;",171
244,"# ifdef DISABLE_RC_LONG_TERM_MEM  const uint64_t bits_used = cpi -> rc . this_frame_target ;# else const uint64_t bits_used = cpi -> rc . projected_frame_size ;# endif cpi -> twopass . bits_left -= bits_used ;cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ;if ( cpi -> common . frame_type == KEY_FRAME ) {cpi -> twopass . kf_group_bits += cpi -> rc . this_frame_target - bits_used ;cpi -> twopass . kf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ;}cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ;","TWO_PASS * const twopass = & cpi -> twopass ;RATE_CONTROL * const rc = & cpi -> rc ;const int bits_used = rc -> base_frame_target ;rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ;twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ;if ( rc -> total_actual_bits ) {rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ;rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ;rc -> rate_error_estimate = 0 ;}if ( cpi -> common . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) {twopass -> kf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits = MAX ( twopass -> kf_group_bits , 0 ) ;++ twopass -> gf_group . index ;if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) {const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ;const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ;if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) {-- twopass -> extend_maxq ;if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ;}else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) {-- twopass -> extend_minq ;if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ;}else {if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ;if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ;else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ;}twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ;twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ;if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) {int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ;if ( rc -> projected_frame_size < fast_extra_thresh ) {rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ;rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ;if ( rc -> avg_frame_bandwidth ) {twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ;}twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ;}else if ( rc -> vbr_bits_off_target_fast ) {twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ;}else {twopass -> extend_minq_fast = 0 ;}}}",172
245,num ++ ;curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ;,"num ++ ;if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) ) ;curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ;",173
246,"static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header ,  struct mb_cache_entry * * pce )  {struct mb_cache_entry * ce ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;again :   ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev ,  hash ) ;if ( IS_ERR ( ce ) ) {if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ;break ;}","static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , struct mb2_cache_entry * * pce ) {struct mb2_cache_entry * ce ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ce = mb2_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , hash ) ;",174
247,"ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;}","ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce ) ;}",174
248,"gint64 offset ;int pkt_len ;pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len ,   wth -> frame_buffer , err , err_info ) ;}","gint64 offset ;return parse_cosine_packet ( wth -> fh , & wth -> phdr , pkt_len , wth -> frame_buffer , line , err , err_info ) ;}",175
249,if ( pkt == NULL )  continue ;,"
",176
250,"
",if ( left == 0 && extend ) return 0 ;,177
251,if ( left > 0 && n > left )  n = left ;,if ( left > 0 && n > left ) n = left ;,177
252,"# ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;# endif struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;return - 1 ;","char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;if ( ! buf ) {return - 1 ;}struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;free ( buf ) ;return - 1 ;",178
253,"if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;else  {return fileblock + start ;}return - 1 ;}}if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;","if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) {free ( buf ) ;return 0 ;}else {free ( buf ) ;return fileblock + start ;}free ( buf ) ;return - 1 ;}free ( buf ) ;}if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;",178
254,"if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;","if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;",178
255,UnpackRaster :  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {,"UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) break ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {",179
256,"else {if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}if ( bpp == 1 ) {if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) {image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ;}}if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) {DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ;}if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) {if ( BitmapHeader2 . RotAngle & 0x8000 ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x2000 ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x0FFF ) {Image * rotate_image ;rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ;if ( rotate_image != ( Image * ) NULL ) {DuplicateBlob ( rotate_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , rotate_image ) ;}}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ;break ;}}break ;case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ;StartWPG . PosSizePrecision = 0 ;while ( ! EOFBlob ( image ) ) {( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ;if ( EOFBlob ( image ) ) break ;Rec2 . Class = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rd_WP_DWORD ( image , & Rec2 . Extension ) ;Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ;if ( EOFBlob ( image ) ) break ;Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ;switch ( Rec2 . RecType ) {case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ;StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ;StartWPG . PosSizePrecision = ReadBlobByte ( image ) ;break ;case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ;WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ;image -> colors = WPG_Palette . NumOfEntries ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = WPG_Palette . StartIndex ;i < ( int ) WPG_Palette . NumOfEntries ;i ++ ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;( void ) ReadBlobByte ( image ) ;}break ;case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ;Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ;if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;Bitmap2Header1 . Depth = ReadBlobByte ( image ) ;Bitmap2Header1 . Compression = ReadBlobByte ( image ) ;if ( Bitmap2Header1 . Compression > 1 ) continue ;switch ( Bitmap2Header1 . Depth ) {case 1 : bpp = 1 ;break ;case 2 : bpp = 2 ;break ;case 3 : bpp = 4 ;break ;case 4 : bpp = 8 ;break ;case 8 : bpp = 24 ;break ;default : continue ;}image -> columns = Bitmap2Header1 . Width ;image -> rows = Bitmap2Header1 . Height ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {size_t one ;one = 1 ;image -> colors = one << bpp ;if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ;}else {if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}switch ( Bitmap2Header1 . Compression ) {case 0 : {ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ;BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;for ( i = 0 ;i < ( ssize_t ) image -> rows ;i ++ ) {( void ) ReadBlob ( image , ldblk , BImgBuff ) ;InsertRow ( image , BImgBuff , i , bpp , exception ) ;}if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;break ;}case 1 : {if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ;break ;}}if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x12 : i = ReadBlobLSBShort ( image ) ;if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ;break ;case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ;( void ) WPG2Flags ;break ;}}break ;default : {ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;}}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;","
",179
257,"if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ;if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ;if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ;size = max ( hdr . size_in , hdr . size_out ) ;if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ;if ( size > SZ_16M ) return - E2BIG ;is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ;if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ;else buf = kmalloc ( size , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) {ret = - EFAULT ;","if ( copy_from_user ( & hdr , ( void * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) ) ) {ret = - EFAULT ;",180
258,"int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;","int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;",181
259,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,181
260,"if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}case RMT_RAW : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ;if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ;image -> columns = sun_info . width ;image -> rows = sun_info . height ;if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;","if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;",182
261,"if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;","if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ;else {if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ;}sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;",182
262,# define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ;,"# define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\\\if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( ( exception ) , ( message ) ) ;colormap = ( unsigned char * ) NULL ;pixel_info = ( MemoryInfo * ) NULL ;\\\\\char magick [ 12 ] ;",183
263,"if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;assert ( exception != ( ExceptionInfo * ) NULL ) ;assert ( exception -> signature == MagickCoreSignature ) ;image = AcquireImage ( image_info , exception ) ;status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;if ( ( count != 2 ) || ( memcmp ( magick , ""\\\\122\\\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;do {image -> page . x = ReadBlobLSBShort ( image ) ;image -> page . y = ReadBlobLSBShort ( image ) ;image -> columns = ReadBlobLSBShort ( image ) ;image -> rows = ReadBlobLSBShort ( image ) ;flags = ( MagickStatusType ) ReadBlobByte ( image ) ;image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ;number_planes = ( size_t ) ReadBlobByte ( image ) ;bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ;number_colormaps = ( size_t ) ReadBlobByte ( image ) ;map_length = ( unsigned char ) ReadBlobByte ( image ) ;if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;one = 1 ;map_length = one << map_length ;","if ( image_info -> debug != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;one = 1 ;map_length = one << map_length ;",183
264,"if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;colormap = ( unsigned char * ) NULL ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;}","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;colormap = ( unsigned char * ) NULL ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ;if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ) ;}",183
265,"if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;break ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ;if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {ssize_t j ;p = pixels ;for ( i = 0 ;i < ( ssize_t ) number_pixels ;i ++ ) {if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ;j < ( ssize_t ) number_planes ;j ++ ) * p ++ = background_color [ j ] ;else {for ( j = 0 ;j < ( ssize_t ) ( number_planes - 1 ) ;j ++ ) * p ++ = background_color [ j ] ;* p ++ = 0 ;}}}plane = 0 ;x = 0 ;y = 0 ;opcode = ReadBlobByte ( image ) ;do  {switch ( opcode & 0x3f ) {case SkipLinesOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x = 0 ;y += operand ;break ;}case SetColorOp : {operand = ReadBlobByte ( image ) ;plane = ( unsigned char ) operand ;if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ;x = 0 ;break ;}case SkipPixelsOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x += operand ;break ;}case ByteDataOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;operand ++ ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;",183
266,if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;operand ++ ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {,if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ;operand ++ ;if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,183
267,}if ( number_colormaps != 0 ) {,}if ( number_colormaps != 0 ) {,183
268,"ValidateColormapValue ( image , * p & mask , & index , exception ) ;* p = colormap [ ( ssize_t ) index ] ;","ValidateColormapValue ( image , * p & mask , & index , exception ) ;* p = colormap [ ( ssize_t ) index ] ;",183
269,"ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ;","ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ;",183
270,"SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;","SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;",183
271,"if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;( void ) ReadBlobByte ( image ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;","if ( number_colormaps != 0 ) colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ;if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( colormap == ( unsigned char * ) magick ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;",183
272,ext2_xattr_put_super ( sb ) ;if ( ! ( sb -> s_flags & MS_RDONLY ) ) {,if ( sbi -> s_mb_cache ) {ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;sbi -> s_mb_cache = NULL ;}if ( ! ( sb -> s_flags & MS_RDONLY ) ) {,184
273,"endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\","if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\\error = - EINVAL ;goto err_free_urb ;}endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\",185
274,"if ( ! cfg . shell )  cfg . shell = guess_shell ( ) ;if ( ! cfg . shell ) {fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\\exit ( 1 ) ;}arg [ 0 ] = cfg . shell ;arg [ 1 ] = ""-c"" ;","arg [ 0 ] = cfg . shell ;arg [ 1 ] = ""-c"" ;",186
275,return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;},if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;else return NULL ;},187
276,"static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags )  {nfs_set_open_stateid_locked ( state , stateid , open_flags ) ;write_sequnlock ( & state -> seqlock ) ;","static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , fmode_t fmode ) {nfs_set_open_stateid_locked ( state , stateid , fmode ) ;write_sequnlock ( & state -> seqlock ) ;",188
277,"
",if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;,189
278,"uint32_t vsize = avio_rb32 ( pb ) ;avio_skip ( pb , 8 ) ;","uint32_t vsize = avio_rb32 ( pb ) ;avio_skip ( pb , 8 ) ;",189
279,"if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\","if ( q < p || q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\",190
280,"# ifdef AUTOKEY  filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;# endif  # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;# endif  step_callback = & ntpd_time_stepped ;","filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;# endif step_callback = & ntpd_time_stepped ;",191
281,"char * dir = ""/etc"" ;if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;","if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;",192
282,"attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;","n -> mounts += n -> pending_mounts ;n -> pending_mounts = 0 ;attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;",193
283,"savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds | prev -> ds ) )  loadsegment ( ds , next -> ds ) ;savesegment ( fs , fsindex ) ;","savesegment ( fs , fsindex ) ;savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds ) ;",194
284,problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;,"
",195
285,"
",if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) {return IHEVCD_INVALID_HEADER ;},196
286,"BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ;ps_pps -> i1_entropy_coding_sync_enabled_flag = value ;","BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ;ps_pps -> i1_entropy_coding_sync_enabled_flag = value ;",196
287,eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) |  ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ;if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ;,eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) | ( 1u << AC_VECTOR ) ;if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ;,197
288,"static char temp [ NFSX_V3FHMAX + 1 ] ;strncpy ( temp , sfsname , NFSX_V3FHMAX ) ;temp [ sizeof ( temp ) - 1 ] = \'\\\\0\' ;spacep = strchr ( temp , \'<S2SV_blank>\' ) ;","char temp [ NFSX_V3FHMAX + 1 ] ;u_int stringlen ;stringlen = len ;if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ;strncpy ( temp , sfsname , stringlen ) ;temp [ sizeof ( temp ) - 1 ] = \'\\\\0\' ;spacep = strchr ( temp , \'<S2SV_blank>\' ) ;",198
289,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen ,  int transhdrlen , int mtu , unsigned int flags )  {","static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) {",199
290,ipv6_select_ident ( & fhdr ) ;skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;,"ipv6_select_ident ( & fhdr , rt ) ;skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;",199
291,if ( res )  return res ;res = register_netdevice ( hsr_dev ) ;,if ( res ) goto err_add_port ;res = register_netdevice ( hsr_dev ) ;,200
292,return res ;},err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;return res ;},200
293,"
",flush_cmd ( ) ;,201
294,( void ) tls_init_new_session ( ) ;},( void ) tls_init_new_session ( ) ;},201
295,"void vp9_setup_dst_planes ( MACROBLOCKD * xd ,  const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) {uint8_t * const buffers [ 4 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride }struct macroblockd_plane * const pd = & xd -> plane [ i ] ;setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ;","void vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) {uint8_t * const buffers [ MAX_MB_PLANE ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride }struct macroblockd_plane * const pd = & planes [ i ] ;setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ;",202
296,len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 ;len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,203
297,"static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst )  {switch ( ctxt -> op_bytes ) {case 2 : ctxt -> _eip = ( u16 ) dst ;break ;case 4 : ctxt -> _eip = ( u32 ) dst ;break ;case 8 : ctxt -> _eip = dst ;break ;default : WARN ( 1 , ""unsupported<S2SV_blank>eip<S2SV_blank>assignment<S2SV_blank>size\\\}","static inline int assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) {return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 ) ;",204
298,"static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {ctx -> invert_tile_order = va_arg ( args , int ) ;","static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , va_list args ) {ctx -> invert_tile_order = va_arg ( args , int ) ;",205
299,"remaining = tvb_captured_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {","remaining = tvb_reported_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {",206
300,"if ( iov_iter_rw ( iter ) == READ )  get_block = ocfs2_get_block ;else  get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;","if ( iov_iter_rw ( iter ) == READ ) get_block = ocfs2_lock_get_block ;else get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;",207
301,msg -> msg_namelen = 0 ;copied = skb -> len ;,copied = skb -> len ;,208
302,"if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\\","if ( fscanf ( f , ""%79s<S2SV_blank>%99[^\\\",209
303,"if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ;perf_read_regs ( regs ) ;nmi = perf_intr_is_nmi ( regs ) ;if ( nmi ) nmi_enter ( ) ;else irq_enter ( ) ;for ( i = 0 ;i < cpuhw -> n_events ;++ i ) {event = cpuhw -> event [ i ] ;if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ;val = read_pmc ( event -> hw . idx ) ;if ( ( int ) val < 0 ) {found = 1 ;record_and_restart ( event , val , regs , nmi ) ;}}if ( ! found ) {for ( i = 0 ;i < ppmu -> n_counter ;++ i ) {if ( is_limited_pmc ( i + 1 ) ) continue ;val = read_pmc ( i + 1 ) ;if ( ( int ) val < 0 )  write_pmc ( i + 1 , 0 ) ;","+ i ) {+ i ) {if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ;",210
304,"else len = get_line_size ( * b , * avail , nl ) ;","else len = get_line_size ( * b + len , * avail - len , nl ) ;",211
305,"len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;","len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;",211
306,"int all_whitespace = 1 ;int kind ;void * data ;mod_ty mod ;char * str ;PyObject * o , * fstring_name ;Py_ssize_t len ;o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ;if ( o == NULL ) return NULL ;len = PyUnicode_GET_LENGTH ( o ) ;kind = PyUnicode_KIND ( o ) ;data = PyUnicode_DATA ( o ) ;for ( i = 0 ;i < len ;i ++ ) {if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) {all_whitespace = 0 ;Py_DECREF ( o ) ;if ( all_whitespace ) {if ( str == NULL )  return NULL ;str [ 0 ] = \'(\' ;fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ;mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ;PyMem_RawFree ( str ) ;if ( ! mod ) return NULL ;","node * mod_n ;mod_ty mod ;char * str ;PyObject * o , * fstring_name ;Py_ssize_t len ;for ( s = expr_start ;s != expr_end ;s ++ ) {char c = * s ;if ( ! ( c == \'<S2SV_blank>\' || c == \'\\\\t\' || c == \'\\\if ( s == expr_end ) {if ( str == NULL ) return NULL ;str [ 0 ] = \'(\' ;mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ;if ( ! mod_n ) {PyMem_RawFree ( str ) ;Ta3Node_Free ( mod_n ) ;return NULL ;}str [ 0 ] = \'{\' ;str [ len + 1 ] = \'}\' ;fstring_fix_node_location ( n , mod_n , str ) ;fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ;mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ;PyMem_RawFree ( str ) ;if ( ! mod ) return NULL ;",212
307,"void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name )  {","static void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) {",213
308,"cJSON * c = object -> child ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ;","cJSON * c = object ? object -> child : 0 ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ;",214
309,"if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;up_write ( & key -> sem ) ;","if ( ret == 0 ) mark_key_instantiated ( key , 0 ) ;up_write ( & key -> sem ) ;",215
310,"if ( ! ( plen <= * len ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;","if ( ! ( plen <= * len && plen > 0 ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;",216
311,"args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;","args . rmtvaluelen = valuelen ;args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;",217
312,"if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ;if ( COMPAT_USE_64BIT_TIME )  return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ;if ( get_compat_timespec ( & ktspec , timeout ) )  return - EFAULT ;if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) )  datagrams = - EFAULT ;","if ( get_compat_timespec ( & ktspec , timeout ) ) return - EFAULT ;if ( compat_get_timespec ( & ktspec , timeout ) ) datagrams = - EFAULT ;",218
313,"image -> columns = sun_info . width ;image -> rows = sun_info . height ;image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ;if ( sun_info . depth < 24 ) {size_t one ;image -> storage_class = PseudoClass ;image -> colors = sun_info . maplength ;}switch ( sun_info . maptype ) {case RMT_NONE :  {if ( sun_info . depth < 24 ) {break ;}unsigned char  * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","image -> colors = sun_info . maplength ;switch ( sun_info . maptype ) {unsigned char * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",219
314,"int ret ;assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;ret = hns_nic_net_xmit_hw ( ndev , skb ,  & tx_ring_data ( priv , skb -> queue_mapping ) ) ;if ( ret == NETDEV_TX_OK ) {netif_trans_update ( ndev ) ;ndev -> stats . tx_bytes += skb -> len ;ndev -> stats . tx_packets ++ ;}return ( netdev_tx_t ) ret ;","assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;return hns_nic_net_xmit_hw ( ndev , skb , & tx_ring_data ( priv , skb -> queue_mapping ) ) ;",220
315,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,221
316,"if ( settings . num_threads > 64 ) {fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\\}break ;case \'D\' : if ( ! optarg || ! optarg [ 0 ] ) {fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\\return 1 ;}settings . prefix_delimiter = optarg [ 0 ] ;settings . detail_enabled = 1 ;break ;case \'L\' : if ( enable_large_pages ( ) == 0 ) {preallocate = true ;}else {fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\\return 1 ;}break ;case \'C\' : settings . use_cas = false ;break ;case \'b\' : settings . backlog = atoi ( optarg ) ;break ;case \'B\' : protocol_specified = true ;if ( strcmp ( optarg , ""auto"" ) == 0 ) {settings . binding_protocol = negotiating_prot ;}else if ( strcmp ( optarg , ""binary"" ) == 0 ) {settings . binding_protocol = binary_prot ;}else if ( strcmp ( optarg , ""ascii"" ) == 0 ) {settings . binding_protocol = ascii_prot ;}else {fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\\exit ( EX_USAGE ) ;}break ;case \'I\' : buf = strdup ( optarg ) ;unit = buf [ strlen ( buf ) - 1 ] ;if ( unit == \'k\' || unit == \'m\' || unit == \'K\' || unit == \'M\' ) {buf [ strlen ( buf ) - 1 ] = \'\\\\0\' ;size_max = atoi ( buf ) ;if ( unit == \'k\' || unit == \'K\' ) size_max *= 1024 ;if ( unit == \'m\' || unit == \'M\' ) size_max *= 1024 * 1024 ;settings . item_size_max = size_max ;}else {settings . item_size_max = atoi ( buf ) ;}free ( buf ) ;break ;case \'S\' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\\exit ( EX_USAGE ) ;# endif settings . sasl = true ;break ;case \'F\' : settings . flush_enabled = false ;break ;case \'X\' : settings . dump_enabled = false ;break ;case \'o\' : subopts_orig = subopts = strdup ( optarg ) ;while ( * subopts != \'\\\\0\' ) {switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) {case MAXCONNS_FAST : settings . maxconns_fast = true ;break ;case HASHPOWER_INIT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\\return 1 ;}settings . hashpower_init = atoi ( subopts_value ) ;if ( settings . hashpower_init < 12 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\\return 1 ;}else if ( settings . hashpower_init > 32 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\\return 1 ;}break ;case NO_HASHEXPAND : start_assoc_maint = false ;break ;case SLAB_REASSIGN : settings . slab_reassign = true ;break ;case SLAB_AUTOMOVE : if ( subopts_value == NULL ) {settings . slab_automove = 1 ;break ;}settings . slab_automove = atoi ( subopts_value ) ;if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) {fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\\return 1 ;}break ;case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_ratio = atof ( subopts_value ) ;if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) {fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\\return 1 ;}break ;case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_window = atoi ( subopts_value ) ;if ( settings . slab_automove_window < 3 ) {fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\\return 1 ;}break ;case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\\return 1 ;}settings . tail_repair_time = atoi ( subopts_value ) ;if ( settings . tail_repair_time < 10 ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\\return 1 ;}break ;case HASH_ALGORITHM : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\\return 1 ;};if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) {hash_type = JENKINS_HASH ;}else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) {hash_type = MURMUR3_HASH ;}else {fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\\return 1 ;}break ;case LRU_CRAWLER : start_lru_crawler = true ;break ;case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_sleep = atoi ( subopts_value ) ;if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) {fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\\return 1 ;}break ;case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) {fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_tocrawl = tocrawl ;break ;case LRU_MAINTAINER : start_lru_maintainer = true ;settings . lru_segmented = true ;break ;case HOT_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . hot_lru_pct = atoi ( subopts_value ) ;if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case WARM_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . warm_lru_pct = atoi ( subopts_value ) ;if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) {fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case HOT_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\\return 1 ;}settings . hot_max_factor = atof ( subopts_value ) ;if ( settings . hot_max_factor <= 0 ) {fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case WARM_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\\return 1 ;}settings . warm_max_factor = atof ( subopts_value ) ;if ( settings . warm_max_factor <= 0 ) {fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case TEMPORARY_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\\return 1 ;}settings . temp_lru = true ;settings . temporary_ttl = atoi ( subopts_value ) ;break ;case IDLE_TIMEOUT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\\return 1 ;}settings . idle_timeout = atoi ( subopts_value ) ;break ;case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\\return 1 ;}settings . logger_watcher_buf_size *= 1024 ;break ;case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\\return 1 ;}settings . logger_buf_size *= 1024 ;case SLAB_SIZES : slab_sizes_unparsed = subopts_value ;break ;case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\\}if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\\}slab_chunk_size_changed = true ;break ;case TRACK_SIZES : item_stats_sizes_init ( ) ;break ;case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ;break ;case INLINE_ASCII_RESP : settings . inline_ascii_response = true ;break ;case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ;break ;case NO_SLAB_REASSIGN : settings . slab_reassign = false ;break ;case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ;break ;case NO_MAXCONNS_FAST : settings . maxconns_fast = false ;break ;case NO_LRU_CRAWLER : settings . lru_crawler = false ;start_lru_crawler = false ;break ;case NO_LRU_MAINTAINER : start_lru_maintainer = false ;settings . lru_segmented = false ;break ;# ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\\return 1 ;}ext_cf . page_size *= 1024 * 1024 ;break ;case EXT_PAGE_COUNT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\\return 1 ;}break ;case EXT_WBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\\return 1 ;}ext_cf . wbuf_size *= 1024 * 1024 ;settings . ext_wbuf_size = ext_cf . wbuf_size ;break ;case EXT_THREADS : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\\return 1 ;}break ;case EXT_IO_DEPTH : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\\return 1 ;}break ;case EXT_ITEM_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\\return 1 ;}break ;case EXT_ITEM_AGE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\\return 1 ;}break ;case EXT_LOW_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\\return 1 ;}break ;case EXT_RECACHE_RATE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\\return 1 ;}break ;case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\\return 1 ;}break ;case EXT_DROP_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\\return 1 ;}break ;case EXT_MAX_FRAG : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\\return 1 ;}break ;case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\\return 1 ;}break ;case EXT_DROP_UNREAD : settings . ext_drop_unread = true ;break ;case EXT_PATH : storage_file = strdup ( subopts_value ) ;break ;# endif case MODERN : break ;case NO_MODERN : if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size ;}settings . slab_reassign = false ;settings . slab_automove = 0 ;settings . maxconns_fast = false ;settings . inline_ascii_response = true ;settings . lru_segmented = false ;hash_type = JENKINS_HASH ;start_lru_crawler = false ;start_lru_maintainer = false ;break ;case NO_DROP_PRIVILEGES : settings . drop_privileges = false ;break ;# ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ;break ;# endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\\\""%s\\\\""\\\return 1 ;}}free ( subopts_orig ) ;break ;default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\\\""%c\\\\""\\\return 1 ;}}if ( settings . item_size_max < 1024 ) {fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > 1024 * 1024 ) {if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size / 2 ;}}if ( settings . slab_chunk_size_max > settings . item_size_max ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\\exit ( EX_USAGE ) ;}# ifdef EXTSTORE if ( storage_file ) {if ( settings . item_size_max > ext_cf . wbuf_size ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\\exit ( EX_USAGE ) ;}if ( settings . inline_ascii_response ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( settings . udpport ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\\exit ( EX_USAGE ) ;}}# endif if ( slab_sizes_unparsed != NULL ) {if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) {use_slab_sizes = true ;}else {exit ( EX_USAGE ) ;}}if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\\exit ( EX_USAGE ) ;}if ( settings . temp_lru && ! start_lru_maintainer ) {fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( hash_init ( hash_type ) != 0 ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\\exit ( EX_USAGE ) ;}if ( settings . inter != NULL && strchr ( settings . inter , \',\' ) ) {settings . num_threads_per_udp = 1 ;}else {settings . num_threads_per_udp = settings . num_threads ;}if ( settings . sasl ) {if ( ! protocol_specified ) {settings . binding_protocol = binary_prot ;}else {if ( settings . binding_protocol != binary_prot ) {fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\\exit ( EX_USAGE ) ;}}}if ( tcp_specified && settings . port != 0 && ! udp_specified ) {settings . udpport = settings . port ;}else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {",if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {,222
317,"RAnalOp next_op ;avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;","RAnalOp next_op = {0 };avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;",223
318,px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;,if ( ! px -> ft ) {return FALSE ;}px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;,224
319,"int ret = 0 , found = 0 ;char * repo_config = NULL ;","int ret = 0 , found = 0 ;",225
320,"repo_config = perf_pathdup ( ""config"" ) ;if ( ! access ( repo_config , R_OK ) ) {ret += perf_config_from_file ( fn , repo_config , data ) ;found += 1 ;}free ( repo_config ) ;","
",225
321,"static int  validate_event ( struct pmu_hw_events * hw_events ,  struct perf_event * event ) {struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF )  return 1 ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}","static int validate_event ( struct pmu * pmu , struct pmu_hw_events * hw_events , struct perf_event * event ) {struct arm_pmu * armpmu ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != pmu ) return 0 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;armpmu = to_arm_pmu ( event -> pmu ) ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}",226
322,"static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid ,  struct uid_gid_map * new_map ) {","static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) {",227
323,"if ( ns_capable ( ns -> parent , cap_setid ) )  return true ;","if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ;",227
324,"j ++ )  {body [ j ] = XMALLOC ( VarLenData , 1 ) ;return body ;}","j ++ ) {if ( a -> type == szMAPI_BINARY ) {body [ j ] = XMALLOC ( VarLenData , 1 ) ;}return body ;}",228
325,"u8 reset ;int ret , pos = 0 ;hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! hx ) return - ENOMEM ;reset = 1 ;if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 )  err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;","u8 * buf ;int ret , pos = 0 ;u16 cpu_cs_register = cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;",229
326,"kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( hx ) ;return ret ;","kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register ;buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;hx = ( struct hexline * ) buf ;buf [ 0 ] = 1 ;if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( buf ) ;return ret ;",229
327,"static void  l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat )  {ptr ++ ;val_h = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;","static void l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ptr ++ ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;",230
328,"if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0  && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) {if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ;else success = 1 ;}","success = data_eq_string ( * realm , handle -> params . realm ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ;",231
329,if ( uniforms_offset < shader_rec_offset ||  exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) {,if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) {,232
330,# endif  # if HAVA_LZMA_H && HAVE_LIBLZMA  if ( zip -> zipx_lzma_valid ) {,# endif # if HAVE_LZMA_H && HAVE_LIBLZMA if ( zip -> zipx_lzma_valid ) {,233
331,"struct file * file = vma -> vm_file ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {","struct file * file = vma -> vm_file ) ;down_read ( & EXT4_I ( inode ) -> i_mmap_sem ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {",234
332,out :  sb_end_pagefault ( inode -> i_sb ) ;return ret ;,out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;sb_end_pagefault ( inode -> i_sb ) ;return ret ;,234
333,"ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;",235
334,"r_return_val_if_fail ( arg , NULL ) ;char * a = malloc ( strlen ( arg ) + 1 ) ;if ( ! a ) {return NULL ;}char * b = a ;while ( * arg ) {switch ( * arg ) {case '@' : case '`' : case '|' : case ';' :  case '\\\default :  * b ++ = * arg ;break ;",char ch = * arg ;switch ( ch ) {case '@' : case '`' : case '|' : case ';' : case '=' : case '\\\default : * b ++ = * arg ;break ;,236
335,"if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;","if ( map && nmap ) cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;else cp = ikev1_attr_print ( ndo , cp , ep2 ) ;if ( cp == NULL ) goto trunc ;",237
336,"static gboolean  accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) {IceListenObj listener ;IceConn ice_conn ;IceAcceptStatus status ;GsmClient * client ;GsmXsmpServer * server ;listener = data -> listener ;server = data -> server ;g_debug ( ""GsmXsmpServer:<S2SV_blank>accept_ice_connection()"" ) ;ice_conn = IceAcceptConnection ( listener , & status ) ;if ( status != IceAcceptSuccess ) {g_debug ( ""GsmXsmpServer:<S2SV_blank>IceAcceptConnection<S2SV_blank>returned<S2SV_blank>%d"" , status ) ;return TRUE ;client = gsm_xsmp_client_new ( ice_conn ) ;ice_conn -> context = client ;gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ;g_object_unref ( client ) ;return TRUE ;","typedef struct {guint watch_id ;guint protocol_timeout ;GsmIceConnectionWatch ;static void disconnect_ice_connection ( IceConn ice_conn ) {IceSetShutdownNegotiation ( ice_conn , FALSE ) ;IceCloseConnection ( ice_conn ) ;",238
337,"if ( ( skb_headroom ( skb ) < frag_hdr_sz ) &&  pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;","if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;",239
338,"# ifdef GIT_WIN32  test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ;# endif  }","test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ;test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ;}",240
339,"case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ;","case SO_DEBUG : v . val = ! ! sock_flag ( sk , SOCK_DBG ) ;",241
340,"case SO_PASSCRED :  v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ;break ;","case SO_PASSCRED : v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ;break ;",241
341,"case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ;case SO_PASSSEC :  v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ;break ;","case SO_ACCEPTCONN : v . val = ! ! sk -> sk_state == TCP_LISTEN ;break ;case SO_PASSSEC : v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ;",241
342,if ( sk -> sk_shutdown & RCV_SHUTDOWN ) {msg -> msg_namelen = 0 ;return 0 ;},if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ;,242
343,else  msg -> msg_namelen = 0 ;,"
",242
344,return in ;},return NULL ;},243
345,"uint8_t * const buffers [ 4 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride }","uint8_t * const buffers [ MAX_MB_PLANE ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride }",244
346,"char buf [ DN_BUF_LEN ] ;unsigned int bufsize = sizeof ( buf ) ;X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;md -> subject_dn = strdup ( buf ) ;if ( md -> subject_dn == NULL ) {ret = ENOMEM ;goto cleanup ;}X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;md -> issuer_dn = strdup ( buf ) ;if ( md -> issuer_dn == NULL ) {ret = ENOMEM ;goto cleanup ;}","X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , & md -> subject_dn = strdup ( buf ) ;if ( md -> subject_dn ) ;if ( ret ) goto cleanup ;ret = rfc2253_name ( X509_get_issuer_name ( cert ) , buf , & bufsize , XN_FLAG_SEP_COMMA_PLUS ) ;md -> issuer_dn ) ;if ( ret ) goto cleanup ;",245
347,if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,if ( ! npages || base_gfn != old . base_gfn ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,246
348,if ( ! npages ) {struct kvm_memory_slot * slot ;,if ( ! npages ) {struct kvm_memory_slot * slot ;,246
349,if ( err > 0 ) {signo = SIGCHLD ;err = 0 ;}if ( ! err ) {,"
",247
350,struct skcipher_ctx * ctx = ask -> private ;unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ;struct skcipher_sg_list * sgl ;struct scatterlist * sg ;unsigned long iovlen ;struct iovec * iov ;int err = - EAGAIN ;int used ;long copied = 0 ;lock_sock ( sk ) ;msg -> msg_namelen = 0 ;,"
",248
351,"register u_int amt ;register u_int i ;int j ;int trunc ;if ( ndo -> ndo_snapend < dat ) return ;amt = ndo -> ndo_snapend - dat ;i = min ( length , amt ) ;if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ;i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ;case RIP6_REQUEST :  j = length / sizeof ( * ni ) ;if ( j == 1  && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6  && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ;else  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE :  j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i >= sizeof ( * ni ) ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( trunc )  ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;}if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;}","unsigned int length_left ;u_int j ;ND_TCHECK ( rp -> rip6_cmd ) ;case RIP6_REQUEST : j = length / sizeof ( * ni ) ;if ( j == 1 && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {}if ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length ) ) ;else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE : j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;length_left >= sizeof ( * ni ) ;length_left -= sizeof ( * ni ) , ++ ni ) {ND_TCHECK ( * ni ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( length_left != 0 ) goto trunc ;}ND_TCHECK ( rp -> rip6_vers ) ;if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;return ;trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;return ;}",249
352,if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,250
353,"vpx_memcpy ( sortlist , cpi -> mb_activity_map ,  sizeof ( unsigned int ) * cpi -> common . MBs ) ;","memcpy ( sortlist , cpi -> mb_activity_map , sizeof ( unsigned int ) * cpi -> common . MBs ) ;",251
354,"retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ;bprm -> argc ++ ;bprm -> interp = iname ;interp_file = open_exec ( iname ) ;","retval = bprm_change_interp ( iname , bprm ) ;interp_file = open_exec ( iname ) ;",252
355,int iSrc ;res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;,int iSrc ;,253
356,for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},253
357,_ipmi_destroy_user ( user ) ;cleanup_srcu_struct ( & user -> release_barrier ) ;,_ipmi_destroy_user ( user ) ;,254
358,"Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",255
359,int sl = strlen ( cursor -> ns ) + 1 ;int limit = 0 ;,size_t sl = strlen ( cursor -> ns ) + 1 ;int limit = 0 ;,256
360,"if ( mobj )   memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ;return mobj ;","if ( mobj ) {size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ;memset ( mobj_get_va ( mobj , 0 ) , 0 , ROUNDUP ( size , granularity ) ) ;}return mobj ;",257
361,timer -> it_overrun += 1 << i ;delta -= incr ;,timer -> it_overrun += 1LL << i ;delta -= incr ;,258
362,"if ( n_fors == - 1 ) return NULL ;comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ;if ( ! comps ) return NULL ;for ( i = 0 ;i < n_fors ;i ++ ) {comprehension_ty comp ;asdl_seq * t ;expr_ty expression , first ;node * for_ch ;int is_async = 0 ;REQ ( n , comp_for ) ;if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) {is_async = 1 ;}if ( is_async && c -> c_feature_version < 6 ) {for_ch = CHILD ( n , 1 + is_async ) ;t = ast_for_exprlist ( c , for_ch , Store ) ;expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ;if ( ! expression ) return NULL ;if ( NCH ( n ) == ( 5 + is_async ) ) {int j , n_ifs ;n = CHILD ( n , 4 + is_async ) ;n_ifs = count_comp_ifs ( c , n ) ;","if ( NCH ( n ) == 2 ) {is_async = 1 ;}if ( is_async && c -> c_feature_version < 6 ) {for_ch = CHILD ( n , 1 + is_async ) ;t = ast_for_exprlist ( c , for_ch , Store ) ;expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ;if ( ! expression ) return NULL ;if ( NCH ( n ) == ( 5 + is_async ) ) {int j , n_ifs ;n = CHILD ( n , 4 + is_async ) ;n_ifs = count_comp_ifs ( c , n ) ;",259
363,"expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ;","expression = ast_for_expr ( c , CHILD ( sync_n , 3 ) ) ;",259
364,}dst_state -> curframe = src -> curframe ;,}dst_state -> speculative = src -> speculative ;dst_state -> curframe = src -> curframe ;,260
365,"static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 ,   vp9_writer * w ) {const VP9_COMMON * const cm = & cpi -> common ;const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ;const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;write_skip ( cpi , mbmi -> segment_id , mi , w ) ;if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT )  write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ;if ( bsize >= BLOCK_8X8 ) {","static void write_mb_modes_kf ( const VP9_COMMON * cm , const MACROBLOCKD * xd , MODE_INFO * * mi_8x8 , vpx_writer * w ) {const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ;const MODE_INFO * const left_mi = xd -> left_mi ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;write_skip ( cm , xd , mbmi -> segment_id , mi , w ) ;if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT ) write_selected_tx_size ( cm , xd , w ) ;if ( bsize >= BLOCK_8X8 ) {",261
366,saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;,saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,262
367,"SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;int n ;if ( r -> req . aiocb != NULL ) {r -> req . aiocb = NULL ;bdrv_acct_done ( s -> bs , & r -> acct ) ;}if ( ret ) {if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) {return ;}}DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\\n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}","SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> qiov . size ) ;n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}",263
368,"if ( cs > CQSPI_MAX_CHIPSELECT ) {dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\","if ( cs >= CQSPI_MAX_CHIPSELECT ) {dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\",264
369,"if ( n > maxn ) SWF_error ( ""Action<S2SV_blank>overflow!!"" ) ;# ifdef DEBUG fprintf ( stderr , ""%d:\\\\tACTION[%3.3d]:<S2SV_blank>%s\\\# endif  switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode )  {","# ifdef DEBUG fprintf ( stderr , ""%d:\\\\tACTION[%3.3d]:<S2SV_blank>%s\\\# endif switch ( OpCode ( actions , n , maxn ) ) {",265
370,"memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;","if ( l > ll ) l = ll ;memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;",266
371,}},}}if ( free < 0 ) {err = - ENOMEM ;goto out ;},267
372,if ( len < sizeof ( * prep ) ) {return ( - 1 ) ;}n = EXTRACT_32BITS ( & prep -> pp_n ) ;,if ( len < sizeof ( * prep ) || ! ND_TTEST ( * prep ) ) return ( - 1 ) ;n = EXTRACT_32BITS ( & prep -> pp_n ) ;,268
373,"rq -> skip_clock_update = 0 ;prev -> sched_class -> put_prev_task ( rq , prev ) ;","prev -> sched_class -> put_prev_task ( rq , prev ) ;",269
374,"uint8_t value ;dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\\ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV ,  0 , reg , & value , 1 , 1000 ) ;return ret >= 0 ? value : ret ;}","uint8_t * buffer ;uint8_t value ;buffer = kmalloc ( 1 , GFP_KERNEL ) ;if ( ! buffer ) return - ENOMEM ;dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\\ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , 0 , reg , buffer , 1 , 1000 ) ;return ret >= 0 ) {value = buffer [ 0 ] ;kfree ( buffer ) ;return value ;}else {kfree ( buffer ) ;return ret ;}}",270
375,"static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) {int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ;char * * azModuleArg ;azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ;","static void addModuleArgument ( Parse * pParse , Table * pTable , char * zArg ) {sqlite3_int64 nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ;char * * azModuleArg ;sqlite3 * db = pParse -> db ;if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) {sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s"" , pTable -> zName ) ;}azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ;",271
376,"memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;}","s -> append_char ( s , 0 ) ;strncpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;}",272
377,CurrentColorSpace = ColorSpaceOut ;}Error :  cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,Lut = NULL ;CurrentColorSpace = ColorSpaceOut ;}Error : if ( Lut != NULL ) cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,273
378,for ( i = 0 ;i < sec -> size ;ut32 addr32 = r_read_le32 ( buf + i ) ;,for ( i = 0 ;( i + 3 ) < sec -> size ;ut32 addr32 = r_read_le32 ( buf + i ) ;,274
379,for ( i = 0 ;i < sec -> size ;ut64 addr64 = r_read_le64 ( buf + i ) ;,for ( i = 0 ;( i + 7 ) < sec -> size ;ut64 addr64 = r_read_le64 ( buf + i ) ;,274
380,"case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD :  ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" ,  ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ;ND_TCHECK2 ( * tptr , 4 ) ;bw . i = EXTRACT_32BITS ( tptr ) ;","case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ;ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ;ND_TCHECK2 ( * tptr , 4 ) ;bw . i = EXTRACT_32BITS ( tptr ) ;",275
381,if ( anal_size == 40 ) {,if ( ptr_hbe_txposer -> anal_size == 40 ) {,276
382,"if ( ixheaacd_cmplx_anal_fft != NULL )   ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ;else return - 1 ;","if ( ixheaacd_cmplx_anal_fft != NULL ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) ( u_in , u_out , anal_size * 2 ) ;else return - 1 ;",276
383,"while ( p < q ) p += enclen ( reg -> enc , p ) ;}","if ( q >= end ) return 0 ;while ( p < q ) p += enclen ( reg -> enc , p ) ;}",277
384,"static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq )  {struct bfq_data * bfqd = bfqq -> bfqd ;enum bfqq_expiration reason ;spin_lock_irqsave ( & bfqd -> lock , flags ) ;bfq_clear_bfqq_wait_request ( bfqq ) ;}if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ;","static void bfq_idle_slice_timer_body ( struct bfq_data * bfqd , struct bfq_queue * bfqq ) {enum bfqq_expiration reason ;spin_lock_irqsave ( & bfqd -> lock , flags ) ;}bfq_clear_bfqq_wait_request ( bfqq ) ;if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ;",278
385,"if ( key_is_instantiated ( key ) &&  ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ;","if ( key_is_positive ( key ) && ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ;",279
386,"RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;if ( ! work_to_do ) {","if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) {netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\\netbk_fatal_tx_err ( vif ) ;continue ;}RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;if ( ! work_to_do ) {",280
387,"if ( unlikely ( work_to_do < 0 ) ) {netbk_tx_err ( vif , & txreq , idx ) ;continue ;}if ( unlikely ( ret < 0 ) ) {netbk_tx_err ( vif , & txreq , idx - ret ) ;continue ;}",if ( unlikely ( work_to_do < 0 ) ) continue ;if ( unlikely ( ret < 0 ) ) continue ;,280
388,"netdev_dbg ( vif -> dev ,  ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\\netbk_tx_err ( vif , & txreq , idx ) ;continue ;","netdev_err ( vif -> dev , ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\\netbk_fatal_tx_err ( vif ) ;continue ;",280
389,"netbk_tx_err ( vif , & txreq , idx ) ;continue ;",continue ;,280
390,"
",flush_cmd ( ) ;,281
391,( void ) tls_init_new_session ( ) ;},( void ) tls_init_new_session ( ) ;},281
392,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;struct net * net = sock_net ( cb -> skb -> sk ) ;,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ;struct net * net = sock_net ( cb -> skb -> sk ) ;,282
393,return ;update_idle_timeout ( conn ) ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {,if ( return ;update_idle_timeout ( conn ) != 0 ) return ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {,283
394,"struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ;struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ;struct xen_netif_tx_request * txp ;if ( unlikely ( err ) ) {pending_ring_idx_t index ;index = pending_index ( netbk -> pending_prod ++ ) ;txp = & pending_tx_info [ pending_idx ] . req ;make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;netbk -> pending_ring [ index ] = pending_idx ;xenvif_put ( vif ) ;pending_ring_idx_t index ;pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ;if ( unlikely ( err ) )  xen_netbk_idx_release ( netbk , pending_idx ) ;continue ;txp = & netbk -> pending_tx_info [ pending_idx ] . req ;make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;index = pending_index ( netbk -> pending_prod ++ ) ;netbk -> pending_ring [ index ] = pending_idx ;xen_netbk_idx_release ( netbk , pending_idx ) ;for ( j = start ;xen_netbk_idx_release ( netbk , pending_idx ) ;}","if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ;netbk -> pending_ring [ index ] = pending_idx ;xenvif_put ( vif ) ;pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ;if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ;continue ;xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY , XEN_NETIF_RSP_ERROR ) ;index = pending_index ( netbk -> pending_prod ++ ) ;netbk -> pending_ring [ index ] = pending_idx ;xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ;for ( j = start ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",284
395,assert ( image_info != ( const ImageInfo * ) NULL ) ;,assert ( image_info != ( const ImageInfo * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,285
396,"if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;","}if ( chroma_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;",285
397,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,285
398,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,285
399,"if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( y = 0 ;","if ( resize_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}for ( y = 0 ;",285
400,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,285
401,"if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;","if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;if ( addr . nl_pid ) {syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ;continue ;}incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;",286
402,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;",287
403,"if ( client -> ipc == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;","if ( client -> ipc == NULL && client -> session == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;",288
404,"if ( PyTuple_GET_SIZE ( tuple ) != 3 ) {PyMem_Free ( newData ) ;PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ;return NULL ;}x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ;y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ;z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ;if ( newpos + x > newDataLength ||  diffPtr + x > diffBlock + diffBlockLength ||  extraPtr + y > extraBlock + extraBlockLength ) {memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;","memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;for ( j = 0 ;j < x ;j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ;newpos += x ;oldpos += x ;if ( newpos + y > newDataLength || extraPtr + y > extraBlock + extraBlockLength ) {memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;",289
405,"flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;","flen = udf_get_filename ( dir -> i_sb , nameptr , lfi , fname , UDF_NAME_LEN ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;",290
406,"__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;","memset ( & t , 0 , sizeof ( t ) ) ;__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;",291
407,"if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , req , IPPROTO_TCP ) ) == NULL ) goto done ;err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ;err = net_xmit_eval ( err ) ;","if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , rcu_dereference ( req , IPPROTO_TCP ) ) == NULL ) goto done ;err = ip6_xmit ( sk , skb , fl6 , np -> opt ) , np -> tclass ) ;err = net_xmit_eval ( err ) ;",292
408,ssize_t result ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,ssize_t result ;if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,293
409,"char * fpath = NULL , * path1 , * cgdir = NULL , * controller ;const char * cgroup ;if ( ! fc ) return - EIO ;controller = pick_controller_from_path ( fc , path ) ;if ( ! controller ) return - EINVAL ;cgroup = find_cgroup_in_path ( path ) ;if ( ! cgroup ) return - EINVAL ;get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ;if ( ! fpath ) path1 = ""/"" ;else path1 = cgdir ;if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {ret = - EACCES ;goto out ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {ret = - EACCES ;return ret ;}","char * fpath = NULL , * path1 , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next ) ) {ret = - EACCES ;goto out ;}if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {ret = - EACCES ;goto out ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {ret = - EACCES ;free ( next ) ;return ret ;}",294
410,disk -> queue = NULL ;continue ;,put_disk ( disk ) ;disk -> queue = NULL ;continue ;,295
411,"void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  {","static void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) {",296
412,"if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ;( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ;( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ;( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ;( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ;( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ;count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ;viff_info . comment [ 511 ] = \'\\\\0\' ;if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ;if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ;else image -> endian = MSBEndian ;viff_info . rows = ReadBlobLong ( image ) ;viff_info . columns = ReadBlobLong ( image ) ;viff_info . subrows = ReadBlobLong ( image ) ;viff_info . x_offset = ReadBlobSignedLong ( image ) ;viff_info . y_offset = ReadBlobSignedLong ( image ) ;viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . location_type = ReadBlobLong ( image ) ;viff_info . location_dimension = ReadBlobLong ( image ) ;viff_info . number_of_images = ReadBlobLong ( image ) ;viff_info . number_data_bands = ReadBlobLong ( image ) ;viff_info . data_storage_type = ReadBlobLong ( image ) ;viff_info . data_encode_scheme = ReadBlobLong ( image ) ;viff_info . map_scheme = ReadBlobLong ( image ) ;viff_info . map_storage_type = ReadBlobLong ( image ) ;viff_info . map_rows = ReadBlobLong ( image ) ;viff_info . map_columns = ReadBlobLong ( image ) ;viff_info . map_subrows = ReadBlobLong ( image ) ;viff_info . map_enable = ReadBlobLong ( image ) ;viff_info . maps_per_cycle = ReadBlobLong ( image ) ;viff_info . color_space_model = ReadBlobLong ( image ) ;for ( i = 0 ;i < 420 ;i ++ ) ( void ) ReadBlobByte ( image ) ;if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ;number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ;if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ;if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ;if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ;if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ;if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ;if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ;if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ;switch ( ( int ) viff_info . map_scheme ) {case VFF_MS_NONE : {if ( viff_info . number_data_bands < 3 ) {if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;status = AcquireImageColormap ( image , image -> colors , exception ) ;if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",297
413,"int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( pos != last_pos ) {","int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( avio_feof ( s -> pb ) ) {ret = AVERROR_INVALIDDATA ;goto end ;}if ( pos != last_pos ) {",298
414,"rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE ,  GFP_KERNEL ) ;","rinfo = kzalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , GFP_KERNEL ) ;",299
415,"# endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ;","# endif install_keyword ( ""umask"" , & umask_handler ) ;install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ;",300
416,# endif  },# endif },300
417,return encoder_common_init ( ctx ) ;},"vpx_codec_err_t res = VPX_CODEC_OK ;( void ) data ;if ( ctx -> priv == NULL ) {vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ;if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ;ctx -> priv = ( vpx_codec_priv_t * ) priv ;ctx -> priv -> init_flags = ctx -> init_flags ;ctx -> priv -> enc . total_encoders = 1 ;priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ;if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ;# if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) {return VPX_CODEC_MEM_ERROR ;}# endif if ( ctx -> config . enc ) {priv -> cfg = * ctx -> config . enc ;ctx -> config . enc = & priv -> cfg ;}priv -> extra_cfg = default_extra_cfg ;once ( vp9_initialize_enc ) ;res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ;if ( res == VPX_CODEC_OK ) {set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ;# if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ;# endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ;if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ;else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ;}}return res ;}",301
418,char * tmpptr = key + strlen ( key ) ;* tmpptr = \'=\' ;,char * tmpptr = key + strlen ( key ) ;* tmpptr = \'=\' ;,302
419,"else if ( errno == ENOENT )  touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;}","else if ( errno == ENOENT ) touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID ) ;}",303
420,"if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {goto error ;box -> ops = & jp2_boxinfo_unk . ops ;JAS_DBGLOG ( 10 , (  ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\if ( box -> len == 1 ) {if ( jp2_getuint64 ( in , & extlen ) ) {","if ( ! ( box = jp2_box_create0 ( ) ) ) {goto error ;JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\\if ( box -> len == 1 ) {JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\\if ( jp2_getuint64 ( in , & extlen ) ) {",304
421,"static int  _Unpickler_ResizeMemoList ( UnpicklerObject * self , Py_ssize_t new_size )  {Py_ssize_t i ;assert ( new_size > self -> memo_size ) ;","static int _Unpickler_ResizeMemoList ( UnpicklerObject * self , size_t new_size ) {Py_ssize_t i ;assert ( new_size > self -> memo_size ) ;",305
422,int copylen ;bool zerocopy = false ;,int copylen = 0 ;bool zerocopy = false ;err = - EMSGSIZE ;if ( unlikely ( count > UIO_MAXIOV ) ) goto err ;,306
423,"if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) )  zerocopy = true ;copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;","if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) zerocopy = true ;if ( count > MAX_SKB_FRAGS ) {copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ;if ( copylen < vnet_hdr_len ) copylen = 0 ;else copylen -= vnet_hdr_len ;}if ( copylen < vnet_hdr . hdr_len ) copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;",306
424,u16 offset = sizeof ( struct ipv6hdr ) ;struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ;while ( offset + 1 <= packet_len ) {switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,u16 offset = sizeof ( struct ipv6hdr ) ;while ( offset <= packet_len ) {struct ipv6_opt_hdr * exthdr ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,307
425,offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) +  offset ) ;return offset ;,if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ;offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;return - EINVAL ;,307
426,"static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) {if ( delta_q != 0 ) {vp9_wb_write_bit ( wb , 1 ) ;vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ;vp9_wb_write_bit ( wb , delta_q < 0 ) ;}vp9_wb_write_bit ( wb , 0 ) ;}","static void write_delta_q ( struct vpx_write_bit_buffer * wb , int delta_q ) {if ( delta_q != 0 ) {vpx_wb_write_bit ( wb , 1 ) ;vpx_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ;vpx_wb_write_bit ( wb , delta_q < 0 ) ;}vpx_wb_write_bit ( wb , 0 ) ;}",308
427,mv . as_mv . col = mvy [ vcnt / 2 ] ;find = 1 ;* sr = 0 ;,* sr = 0 ;,309
428,"put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;}","aux . tp_padding = 0 ;put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;}",310
429,"}if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) ||  ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) {dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\\return ;","
",311
430,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_ARP_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",312
431,"int bson_check_field_name ( bson * b , const char * string ,  const int length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ;","int bson_check_field_name ( bson * b , const char * string , const size_t length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ;",313
432,sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;int all_param_pass = 1 ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ;bool all_param_pass = true ;union sctp_params param ;sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,314
433,"while ( chunk_len > 0 ) {err_code = sctp_process_asconf_param ( asoc , asconf ,  asconf_param ) ;if ( SCTP_ERROR_NO_ERROR != err_code )  all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack ,  asconf_param -> crr_id , err_code ,  asconf_param ) ;length = ntohs ( asconf_param -> param_hdr . length ) ;asconf_param = ( void * ) asconf_param + length ;chunk_len -= length ;","sctp_walk_params ( param , addip , addip_hdr . params ) {if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ;err_code = sctp_process_asconf_param ( asoc , asconf , param . addip ) ;if ( err_code != SCTP_ERROR_NO_ERROR ) all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , param . addip -> crr_id , err_code , asconf_param ) ;",314
434,"JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\\result = realloc ( ptr , size ) ;","JAS_DBGLOG ( 101 , ( ""jas_realloc(%x,<S2SV_blank>%zu)\\\result = realloc ( ptr , size ) ;",315
435,"m -> msg_namelen = 0 ;timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;","timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;",316
436,# endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) &&  is_kvmppc_hv_enabled ( kvm ) ;break ;,# endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && hv_enabled ;break ;,317
437,"pci_populate_msicap ( & msicap , msgnum , 0 ) ;return pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ;","return pci_populate_msicap ( & msicap , msgnum , 0 ) || pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ;",318
438,"keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) ,   ( wchar_t * ) kvp_data -> data . key ) ;kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;valuelen = utf8s_to_utf16s ( value , strlen ( value ) ,   ( wchar_t * ) kvp_data -> data . value ) ;kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ;","keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 ) ;kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;valuelen = utf8s_to_utf16s ( value , strlen ( value ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2 ) ;kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ;",319
439,ctx = d -> log_ctx ;d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ;,d -> log_file = eventfp ;ctx = d -> log_ctx ;d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ;,320
440,"if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) {sycc420_to_rgb ( img ) ;else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) {sycc422_to_rgb ( img ) ;}else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) {sycc444_to_rgb ( img ) ;}else {fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\\return ;}img -> color_space = OPJ_CLRSPC_SRGB ;}","
",321
441,void * parg = NULL ;long err = - EINVAL ;int is_ext_ctrl ;size_t ctrls_size = 0 ;void __user * user_ptr = NULL ;is_ext_ctrl = ( cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS || cmd == VIDIOC_TRY_EXT_CTRLS ) ;switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE :  parg = NULL ;case _IOC_READ :  case _IOC_WRITE :  case ( _IOC_WRITE | _IOC_READ ) :  if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;,"void * parg = ( void * ) arg ;long err = - EINVAL ;if ( has_array_args ) {* kernel_ptr = user_ptr ;if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ;goto out_array_args ;}if ( err < 0 ) goto out ;out_array_args : switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE : parg = NULL ;case _IOC_READ : case _IOC_WRITE : case ( _IOC_WRITE | _IOC_READ ) : if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;",322
442,"if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ;return REDIS_OK ;}if ( server . maxmemory ) freeMemoryIfNeeded ( ) ;if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\\\'maxmemory\\\'"" ) ;return REDIS_OK ;}if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ;return REDIS_OK ;}if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ;return REDIS_OK ;}if ( server . loading && cmd -> proc != infoCommand ) {addReply ( c , shared . loadingerr ) ;return REDIS_OK ;}if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {queueMultiCommand ( c , cmd ) ;addReply ( c , shared . queued ) ;}else {if ( server . vm_enabled && server . vm_max_threads > 0 &&  blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;","if ( server . ds_enabled && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;",323
443,"static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data )  {return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) ,  RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE ,  indx , 0 , data , size , 500 ) ;}","static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , const void * data ) {void * buf ;int ret ;buf = kmemdup ( data , size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE , indx , 0 , buf , size , 500 ) ;kfree ( buf ) ;return ret ;}",324
444,"endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\","if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\\error = - EINVAL ;goto err_free_urb ;}endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\",325
445,"case RESPONSE_RUN :  {nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ;g_free ( uri ) ;}break ;case RESPONSE_MARK_TRUSTED : {file = nautilus_file_get_location ( parameters -> file ) ;nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;","case GTK_RESPONSE_OK : {file = nautilus_file_get_location ( parameters -> file ) ;nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ;nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;nautilus_file_invalidate_all_attributes ( parameters -> file ) ;",326
446,if ( status ) {if ( edge_port -> lsr_event ) {edge_port -> lsr_event = 0 ;,if ( urb -> actual_length > 0 && status ) {if ( edge_port -> lsr_event ) {edge_port -> lsr_event = 0 ;,327
447,"static struct cifsSesInfo *  cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username )  {struct list_head * tmp ;list_for_each ( tmp , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) )   continue ;++ ses -> ses_count ;","static struct cifsSesInfo * cifs_find_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * vol ) {+ ses -> ses_count ;list_for_each_entry ( ses , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , vol -> username , MAX_USERNAME_SIZE ) ) continue ;if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ;}++ ses -> ses_count ;",328
448,"if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) )   && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) )   ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;","if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) {if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values"" ) ;}if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;",329
449,"if ( input [ 0 ] == \'<S2SV_blank>\' )  input ++ ;ptr = strchr ( input , \'<S2SV_blank>\' ) ;","if ( input [ 0 ] == \'<S2SV_blank>\' ) {input ++ ;}ptr = strchr ( input , \'<S2SV_blank>\' ) ;",330
450,"if ( ! r_fs_mount ( core -> fs , ptr , input , off ) )  eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) )  eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\\else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) )   eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\free ( ptr ) ;","if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) {eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}}if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) {eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\\}else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) {eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}free ( ptr ) ;",330
451,"if ( vm_flags & VM_NORESERVE )  return 0 ;if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ;else {struct resv_map * resv_map = resv_map_alloc ( ) ;if ( ! resv_map ) return - ENOMEM ;chg = to - from ;set_vma_resv_map ( vma , resv_map ) ;set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ;}if ( chg < 0 ) return chg ;if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;","struct hugepage_subpool * spool = subpool_inode ( inode ) ;if ( hugepage_subpool_get_pages ( spool , chg ) ) return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;",331
452,"struct key * keyring ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;","struct key * keyring ;if ( new -> thread_keyring ) return 0 ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;",332
453,static size_t scanned ;static size_t readnbd ;,"
",333
454,"fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;fptr_orig = io_get_open_fptr ( mrb , orig ) ;","fptr_orig = io_get_open_fptr ( mrb , orig ) ;fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;",334
455,". index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = user_match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",". index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",335
456,"cpi -> zbin_mode_boost = 0 ;vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;}","vp9_init_plane_quantizers ( cpi , & cpi -> td . mb ) ;}",336
457,"utee_param_to_param ( param , callee_params ) ;}","res = utee_param_to_param ( utc , param , callee_params ) ;if ( res != TEE_SUCCESS ) return res ;}",337
458,"old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ;old_eip = ctxt -> _eip ;if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) )  return X86EMUL_CONTINUE ;ctxt -> _eip = 0 ;memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;return em_push ( ctxt ) ;","struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;old_eip = ctxt -> _eip ;ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ;rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ;if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ;rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;if ( rc != X86EMUL_CONTINUE ) goto fail ;rc = em_push ( ctxt ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;return rc ;fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ;return rc ;",338
459,"reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;","reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;",339
460,"band -> prec = av_malloc_array ( reslevel -> num_precincts_x *  ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;","band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;",339
461,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",340
462,"amount = n_got * sizeof ( ut32 ) ;if ( amount < n_got || amount > UT32_MAX ) {goto out_error ;}struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ;if ( got_table ) {",amount = n_got * sizeof ( struct reloc_struct_t ) ) ;if ( got_table ) {,341
463,if ( info -> si_code >= 0 )   return - EPERM ;info -> si_signo = sig ;,if ( info -> si_code != SI_QUEUE ) {WARN_ON_ONCE ( info -> si_code < 0 ) ;return - EPERM ;}info -> si_signo = sig ;,342
464,"* p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ;* p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ;* p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ;* p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ;* p_max_prec = 0 ;","* p_tx0 = ( OPJ_INT32 ) opj_uint_max ( p_cp -> tx0 + p * p_cp -> tdx , p_image -> x0 ) ;* p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx , p_image -> x1 ) ;* p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy , p_image -> y0 ) ;* p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy , p_image -> y1 ) ;* p_max_prec = 0 ;",343
465,"static char * create_output_name ( unsigned char * fname , unsigned char * dir ,  int lower , int isunix , int utf8 ) {unsigned char * p , * name , c , * fe , sep , slash ;unsigned int x ;sep = ( isunix ) ? \'/\' : \'\\\\\\\\\' ;slash = ( isunix ) ? \'\\\\\\\\\' : \'/\' ;x = strlen ( ( char * ) fname ) ;if ( utf8 ) x *= 3 ;if ( dir ) x += strlen ( ( char * ) dir ) ;fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\\return NULL ;while ( * fname == sep ) fname ++ ;p = & name [ strlen ( ( char * ) name ) ] ;fe = & fname [ strlen ( ( char * ) fname ) ] ;if ( utf8 ) {do {if ( fname >= fe ) {free ( name ) ;if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) {x = ( c & 0x1F ) << 6 ;x |= * fname ++ & 0x3F ;}else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) {x = ( c & 0xF ) << 12 ;x |= ( * fname ++ & 0x3F ) << 6 ;x |= * fname ++ & 0x3F ;}else x = \'?\' ;}if ( x == sep ) x = \'/\' ;else if ( x == slash ) x = \'\\\\\\\\\' ;else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ;if ( x < 0x80 ) {* p ++ = ( unsigned char ) x ;}else if ( x < 0x800 ) {* p ++ = 0xC0 | ( x >> 6 ) ;* p ++ = 0x80 | ( x & 0x3F ) ;}else {* p ++ = 0xE0 | ( x >> 12 ) ;* p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ;* p ++ = 0x80 | ( x & 0x3F ) ;}while ( x ) ;}else {do {c = * fname ++ ;if ( c == sep ) c = \'/\' ;else if ( c == slash ) c = \'\\\\\\\\\' ;else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ;while ( ( * p ++ = c ) ) ;return ( char * ) name ;","char * create_output_name ( unsigned char * fname ) {char * out , * p ;if ( utf8 ) x *= 3 ;if ( dir ) x += strlen ( ( char * ) dir ) ;fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\\return NULL ;while ( * fname == \'/\' || * fname == \'\\\\\\\\\' ) fname ++ ;strcpy ( out , ( * fname ) ? fname : ""x"" ) ;for ( p = out ;* p ;p ++ ) {if ( fname >= fe ) {free ( name ) ;if ( p [ 0 ] == \'.\' && p [ 1 ] == \'.\' && ( p [ 2 ] == \'/\' || p [ 2 ] == \'\\\\\\\\\' ) ) {p [ 0 ] = p [ 1 ] = \'x\' ;return out ;",344
466,"zval * options = NULL , * classes = NULL ;HashTable * class_hash = NULL ;","zval * options = NULL , * classes = NULL ;zval * retval ;HashTable * class_hash = NULL ;",345
467,"if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;zval_ptr_dtor ( return_value ) ;if ( ! EG ( exception ) ) {var_push_dtor ( & var_hash , return_value ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;","retval = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize_ex ( retval , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;if ( ! EG ( exception ) ) {ZVAL_COPY ( return_value , retval ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;",345
468,kfree ( tu -> queue ) ;tu -> queue = NULL ;,tu -> qhead = tu -> qtail = tu -> qused = 0 ;kfree ( tu -> queue ) ;tu -> queue = NULL ;,346
469,if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ;tmp_strsize = ( u32 ) ptr -> size - 8 ;tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ;,if ( ptr -> size ;tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ;,347
470,else  buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ;},else buf = ctx -> iface -> enc . get_glob_hdrs ( get_alg_priv ( ctx ) ) ;},348
471,if ( exim_uid == 0 ) {,"if ( exim_uid == 0 ) if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}else {",349
472,uschar * p = & argrest [ 2 ] ;,"uschar * hn ;if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}p = & argrest [ 2 ] ;",349
473,"else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;","else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;",349
474,"uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {","uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {",349
475,if ( info -> si_code >= 0 )   return - EPERM ;info -> si_signo = sig ;,if ( info -> si_code != SI_QUEUE ) {WARN_ON_ONCE ( info -> si_code < 0 ) ;return - EPERM ;}info -> si_signo = sig ;,350
476,"s -> off = strtoll ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 )  s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ;}","s -> off = strtoull ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 ) s -> filesize = strtoull ( slash + 1 , NULL , 10 ) ;}",351
477,"unsigned int maxw , maxh , max ;int offset , upb ;unsigned int i , j ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;for ( i = 0U ;++ i )  {for ( j = 0U ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {","size_t maxw , maxh , max , offx , loopmaxw ;int offset , upb ;size_t i ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;offx = img -> x0 & 1U ;loopmaxw = maxw - offx ;for ( i = 0U ;+ i )  {++ i ) {size_t j ;if ( offx > 0U ) {sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ;++ y ;++ r ;++ g ;++ b ;}for ( j = 0U ;j < ( loopmaxw & ~ ( unsigned int ) 1U ) ;j += 2U ) {",352
478,"if ( j < maxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;","if ( j < loopmaxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;",352
479,# if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = maxw ;img -> comps [ 2 ] . h = maxh ;# else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;# endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;},img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;img -> comps [ 2 ] . h = img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ;img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails : free ( r ) ;if ( g ) free ( g ) ;free ( b ) ;},352
480,"void  nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode )  {if ( state -> state == mode )  return ;if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) {if ( mode & FMODE_WRITE )  list_move ( & state -> open_states , & state -> owner -> so_states ) ;state -> state = mode ;}","void nfs4_state_set_mode_locked ( struct nfs4_state * state , fmode_t fmode ) {if ( state -> state == fmode ) return ;if ( ( fmode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) {if ( fmode & FMODE_WRITE ) list_move ( & state -> open_states , & state -> owner -> so_states ) ;state -> state = fmode ;}",353
481,"ptr = sshpkt_ptr ( ssh , & dlen ) ;if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ;","ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;ptr = sshpkt_ptr ( ssh , & dlen ) ;if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ;",354
482,"assert_true_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" ,  NULL ) ;","assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;",355
483,"assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" ,  NULL ) ;","assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""foo\\\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""bar\\\\"")<S2SV_blank>==<S2SV_blank>-1\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\\\""FOO\\\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\\\""FOO\\\\\\\"" , NULL ) ;",355
484,( void ) CloseBlob ( pwp_image ) ;pwp_image = DestroyImage ( pwp_image ) ;,"
",356
485,"char lbase [ 256 ] ;char strbase [ 256 ] ;char ltest [ 256 ] ;char strtest [ 256 ] ;if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) {","char lbase [ 512 ] ;char strbase [ 256 ] ;char ltest [ 512 ] ;char strtest [ 256 ] ;if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) {",357
486,"while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) {int nbase = sscanf ( lbase , ""%255[^\\\\r\\\int ntest = sscanf ( ltest , ""%255[^\\\\r\\\assert ( nbase != 255 && ntest != 255 ) ;if ( nbase != 1 || ntest != 1 ) {","while ( fgets ( lbase , ""%511[^\\\\r\\\int ntest = sscanf ( ltest , ""%255[^\\\\r\\\assert ( nbase != 255 && ntest != 255 ) ;if ( nbase != 1 || ntest != 1 ) {",357
487,"int ret ;if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;usbnet_link_change ( dev , 0 , 0 ) ;return ret ;","if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;return cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;",358
488,"if ( ! virtqueue_pop ( vq , & elem ) ) {return 0 ;}memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ;virtqueue_push ( vq , & elem , len ) ;","iov_from_buf ( elem . in_sg [ 0 ] . iov_base , buf , len ) ;virtqueue_push ( vq , & elem , len ) ;",359
489,\\\},\\\},360
490,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",361
491,}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) && c -> format != CHUNKY ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,362
492,"isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return ( 1 ) ;","isoclns_print ( ndo , p + 1 , length - 1 ) ;return ( 1 ) ;",363
493,snd_seq_timer_stop ( q -> timer ) ;snd_seq_timer_close ( q ) ;snd_use_lock_sync ( & q -> use_lock ) ;,mutex_lock ( & q -> timer_mutex ) ;snd_seq_timer_stop ( q -> timer ) ;snd_seq_timer_close ( q ) ;mutex_unlock ( & q -> timer_mutex ) ;snd_use_lock_sync ( & q -> use_lock ) ;,364
494,"u64 start = offset >> PAGE_CACHE_SHIFT ;unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ;u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ;pgoff_t curr ;struct page * page ;unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ;unsigned int from , to ;if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ;if ( unlikely ( error ) ) goto out ;curr = start ;offset = start << PAGE_CACHE_SHIFT ;from = start_offset ;to = PAGE_CACHE_SIZE ;while ( curr <= end ) {page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ;if ( unlikely ( ! page ) ) {error = - ENOMEM ;if ( curr == end ) to = end_offset ;error = write_empty_blocks ( page , from , to , mode ) ;if ( ! error && offset + to > inode -> i_size &&  ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {i_size_write ( inode , offset + to ) ;}","unsigned int nr_blks ;sector_t lblock = offset >> inode -> i_blkbits ;if ( unlikely ( error ) ) return error ;while ( len ) {struct buffer_head bh_map = {. b_state = 0 , . b_blocknr = 0 };bh_map . b_size = len ;set_buffer_zeronew ( & bh_map ) ;error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ;if ( unlikely ( error ) ) goto out ;len -= bh_map . b_size ;nr_blks = bh_map . b_size >> inode -> i_blkbits ;lblock += nr_blks ;if ( ! buffer_new ( & bh_map ) ) continue ;if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) {error = - EIO ;}if ( offset + len > inode -> i_size && ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {i_size_write ( inode , offset + to ) ;}",365
495,mark_inode_dirty ( inode ) ;brelse ( dibh ) ;out :  return error ;},mark_inode_dirty ( inode ) ;brelse ( dibh ) ;out : brelse ( dibh ) ;return error ;},365
496,"VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( ! load -> real ) {if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ;# ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\\# endif load -> real -> progress_signal = load -> out ;g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ;if ( class -> load ( load ) ||  vips_image_pio_input ( load -> real ) )  return ( NULL ) ;if ( ! vips_foreign_load_iscompat ( load -> real , out ) )  return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;","VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( load -> error ) return ( NULL ) ;if ( ! load -> real ) || vips_foreign_load_iscompat ( load -> real , out ) ) return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;",366
497,"const char * name = fit_get_name ( fit , noffset , NULL ) ;if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) {","const char * name = fit_get_name ( fit , noffset , NULL ) ;if ( strchr ( name , \'@\' ) ) {err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ;goto error ;}if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) {",367
498,"if ( context -> resynch ) {entry = & entries [ 0 ] ;for ( i = 0 ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) {if ( cursor -> offset == context -> dupcnt ) {context -> dupcnt = 0 ;break ;}context -> dupcnt ++ ;}else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) {context -> dupcnt = 0 ;break ;}}if ( i == ichdr . count ) {trace_xfs_attr_list_notfound ( context ) ;return 0 ;}}else {entry = & entries [ 0 ] ;i = 0 ;}context -> resynch = 0 ;retval = 0 ;for ( ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) {cursor -> hashval = be32_to_cpu ( entry -> hashval ) ;cursor -> offset = 0 ;}if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ;if ( entry -> flags & XFS_ATTR_LOCAL ) {xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ;retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;","if ( ! retval ) retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;",368
499,if ( retval )  return retval ;,if ( retval ) return retval ;,368
500,"if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) )  return - ENOMEM ;state -> dev = dev ;sd = & state -> sd ;","if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) {kfree ( state ) ;return - ENOMEM ;}state -> dev = dev ;sd = & state -> sd ;",369
501,"size += service_name_tlv_length ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;size += rw_tlv_length ;pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\\","if ( ! service_name_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += service_name_tlv_length ;}if ( ! miux_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;if ( ! rw_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += rw_tlv_length ;pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\\",370
502,"struct ssh * ssh = active_state ;struct monitor * mon ;if ( options . compression ) {mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ;mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ;ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ;}",struct monitor * mon ;,371
503,"vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_dec_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) {else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ;","vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , const vpx_codec_dec_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) {",372
504,res = VPX_CODEC_OK ;if ( ! ( flags & VPX_CODEC_USE_XMA ) ) {}if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ;,"
",372
505,"unsigned int channo ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {","unsigned int channo ;cdef -> ents = 0 ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {",373
506,"value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ;value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ;tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ;","value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL ;value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ;tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ;",374
507,"if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) )  goto out_unlock ;","if ( ip_options_echo ( & icmp_param . replyopts . opt . opt , skb_in ) ) goto out_unlock ;",375
508,ipc . opt = & icmp_param . replyopts ;ipc . tx_flags = 0 ;room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ;room -= sizeof ( struct icmphdr ) ;,ipc . opt = & icmp_param . replyopts . opt ;ipc . tx_flags = 0 ;room -= sizeof ( struct iphdr ) + icmp_param . replyopts . opt . opt . optlen ;room -= sizeof ( struct icmphdr ) ;,375
509,"ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;","ND_TCHECK_32BITS ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",376
510,skb_dst_drop ( skb ) ;},if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ;else skb_dst_drop ( skb ) ;},377
511,crypto_free_skcipher ( private ) ;},struct skcipher_tfm * tfm = private ;crypto_free_skcipher ( tfm -> skcipher ) ;kfree ( tfm ) ;},378
512,struct inode * inode = file_inode ( bprm -> file ) ;umode_t mode = inode -> i_mode ;bprm -> cred -> euid = current_euid ( ) ;bprm -> cred -> egid = current_egid ( ) ;,bprm -> cred -> euid = current_euid ( ) ;bprm -> cred -> egid = current_egid ( ) ;,379
513,"return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;","if ( unlikely ( datalen > 0 ) ) {r = UIO_MAXIOV + 1 ;goto err ;}return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;",380
514,"for ( ;* s && dlen ;s ++ ) {if ( strchr ( quote , * s ) ) {dlen -= 2 ;if ( dlen == 0 ) break ;","
",381
515,"rq = blk_mq_tag_to_rq ( tags , off + bit ) ;fn ( rq , data , reserved ) ;","rq = tags -> rqs [ off + bit ) ;fn ( rq , data , reserved ) ;",382
516,else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ;,"
",383
517,if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ;,"
",383
518,msg -> msg_namelen = 0 ;err = 0 ;,err = 0 ;,384
519,if ( skb_is_nonlinear ( skb ) )  return 0 ;,if ( skb_is_nonlinear ( skb ) ) return 0 ;if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;,385
520,"encode_share_access ( xdr , arg -> open_flags ) ;RESERVE_SPACE ( 28 ) ;","encode_share_access ( xdr , arg -> fmode ) ;RESERVE_SPACE ( 28 ) ;",386
521,"if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ;","if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len ) ) goto trunc ;",387
522,"case ETHERTYPE_GRE_ISO :  isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;","case ETHERTYPE_GRE_ISO : isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;",387
523,tilebuf = _TIFFmalloc ( tile_buffsize ) ;if ( tilebuf == 0 )  return 0 ;dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ;,"if ( tile_buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ;exit ( - 1 ) ;}tilebuf = _TIFFmalloc ( tile_buffsize + 3 ) ;if ( tilebuf == 0 ) return 0 ;tilebuf [ tile_buffsize ] = 0 ;tilebuf [ tile_buffsize + 1 ] = 0 ;tilebuf [ tile_buffsize + 2 ] = 0 ;dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ;",388
524,"int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( fd == - 1 ) {","int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( fd == - 1 ) {",389
525,"static void  modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) {return ;}","static int modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) {return 0 ;}",390
526,assert ( error == 0 ) ;},return error ;},390
527,struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;unsigned long tmp ;if ( tmp && tmp == cluster -> cl_has_local &&  cluster -> cl_local_node != node -> nd_num )  return - EBUSY ;if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret )  return ret ;},struct o2nm_cluster * cluster ;unsigned long tmp ;o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {ret = - EINVAL ;goto out ;}if ( tmp && tmp == cluster -> cl_has_local && cluster -> cl_local_node != node -> nd_num ) {ret = - EBUSY ;goto out ;}if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret ) goto out ;},391
528,return count ;},ret = count ;out : o2nm_unlock_subsystem ( ) ;return ret ;},391
529,"if ( fscanf ( fp , ""\\\if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ;if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\\","if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\\",392
530,"
",if ( len > 1 ) {,393
531,"if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;","if ( data [ 1 ] <= 127 ) {op -> jump = addr + data [ 1 ] + op -> size ;}else {op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;}}else {op -> jump = addr ;}op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;",393
532,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",394
533,"s = strchr ( token , \'?\' ) ;if ( s != NULL ) {","s = osStrchr ( token , \'?\' ) ;if ( s != NULL ) {",395
534,"if ( fop == NULL )  return - E_NOTHANDLED ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;","if ( fop == NULL ) return - E_NOTHANDLED ;if ( ninst == 0 ) return - E_INVALID ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;",396
535,ND_TCHECK ( lshp -> ls_type ) ;ND_TCHECK ( lshp -> ls_seq ) ;,ND_TCHECK ( lshp -> ls_length ) ;,397
536,"static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val )  {","static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) {",398
537,"case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ssid . length != 0 ) {if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;if ( length < ssid . length ) return 0 ;memcpy ( & ssid . ssid , p + offset , ssid . length ) ;offset += ssid . length ;length -= ssid . length ;}ssid . ssid [ ssid . length ] = '\\\\0' ;if ( ! pbody -> ssid_present ) {pbody -> ssid = ssid ;pbody -> ssid_present = 1 ;}break ;case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( challenge . length != 0 ) {if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ;if ( length < challenge . length ) return 0 ;memcpy ( & challenge . text , p + offset , challenge . length ) ;offset += challenge . length ;length -= challenge . length ;}challenge . text [ challenge . length ] = '\\\\0' ;if ( ! pbody -> challenge_present ) {pbody -> challenge = challenge ;pbody -> challenge_present = 1 ;}break ;case E_RATES : memcpy ( & rates , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( rates . length != 0 ) {if ( rates . length > sizeof rates . rate ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ;if ( length < rates . length ) return 0 ;memcpy ( & rates . rate , p + offset , rates . length ) ;offset += rates . length ;length -= rates . length ;}if ( ! pbody -> rates_present && rates . length != 0 ) {pbody -> rates = rates ;pbody -> rates_present = 1 ;}break ;case E_DS : memcpy ( & ds , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ds . length != 1 ) {offset += ds . length ;length -= ds . length ;break ;}ds . channel = * ( p + offset ) ;offset += 1 ;length -= 1 ;if ( ! pbody -> ds_present ) {pbody -> ds = ds ;pbody -> ds_present = 1 ;}break ;case E_CF : memcpy ( & cf , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( cf . length != 6 ) {offset += cf . length ;length -= cf . length ;break ;}memcpy ( & cf . count , p + offset , 6 ) ;offset += 6 ;length -= 6 ;if ( ! pbody -> cf_present ) {pbody -> cf = cf ;pbody -> cf_present = 1 ;}break ;case E_TIM : memcpy ( & tim , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( tim . length <= 3 ) {","case E_SSID : memcpy ( & ssid , p + offset + 3 , tim . length <= 3 ) {",399
538,"memcpy ( tim . bitmap , p + ( tim . length - 3 ) ,   ( tim . length - 3 ) ) ;offset += tim . length - 3 ;length -= tim . length - 3 ;if ( ! pbody -> tim_present ) {","memcpy ( tim . bitmap , p + ( tim . length - 3 ) , ( tim . length - 3 ) ) ;offset += tim . length - 3 ;length -= tim . length - 3 ;if ( ! pbody -> tim_present ) {",399
539,"pipe_buf_get ( ipipe , ibuf ) ;* obuf = * ibuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}* obuf = * ibuf ;",400
540,"r_buf_set_bytes ( tbuf , buf , sz ) ;struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ;","if ( ! tbuf ) {return NULL ;}r_buf_set_bytes ( tbuf , buf , sz ) ;struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ;",401
541,"mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;","unsigned int status = 0 ;mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ( unsigned int __user * ) & status , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= put_user ( status , ustatus ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;",402
542,",  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL }LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL },  {","LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/tty"" , NULL , MS_BIND , NULL }, {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/tty"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL }, {",403
543,"r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ;saved_errno = errno ;","r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL ) ;saved_errno = errno ;",403
544,"ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ;st -> st_oakley . group = lookup_group ( ke -> isak_group ) ;if ( st -> st_oakley . group == NULL ) {libreswan_log (  ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return v2N_INVALID_KE_PAYLOAD ;}","libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return STF_FAIL + v2N_INVALID_KE_PAYLOAD ;}",404
545,"void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride )  {nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ;if ( context -> ChromaSubsamplingLevel ) {nsc_encode_subsampling ( context ) ;}","BOOL nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) {if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ;if ( ! nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ) return FALSE ;if ( context -> ChromaSubsamplingLevel ) {if ( ! nsc_encode_subsampling ( context ) ) return FALSE ;}return TRUE ;",405
546,"void vp9_tree_probs_from_distribution ( vp9_tree tree ,  unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) {","void vp9_tree_probs_from_distribution ( vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) {",406
547,if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_xgmac_stats_string ) ;,if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ;,407
548,if ( image -> depth == 1 )  return ( ( image -> columns + 7 ) / 8 ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;,if ( image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;,408
549,"p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;if ( p_dev -> fd < 0 ) {","p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ;if ( p_dev -> fd < 0 ) {",409
550,"p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;if ( p_dev -> fd < 0 ) {","p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ;if ( p_dev -> fd < 0 ) {",409
551,alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,if ( ! pcu -> ctrl_intf ) return - EINVAL ;alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;if ( ! pcu -> data_intf ) return - EINVAL ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,410
552,"const char * name = d -> name ;struct device dev = d -> udev -> dev ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\dvb_usbv2_exit ( d ) ;dev_info ( & dev , ""%s:<S2SV_blank>\\\'%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}","const char * devname = kstrdup ( dev_name ( & d -> udev -> dev ) , GFP_KERNEL ) ;const char * drvname = d -> name ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\pr_info ( ""%s:<S2SV_blank>\\\'%s:%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}",411
553,xstep = picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;,"if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",412
554,if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",412
555,"r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end ,  & cpat , & cpat_end ) ;if ( r != 0 ) return r ;",return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION ;,413
556,"static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y ,  ExceptionInfo * exception ) {size_t bit ;ssize_t x ;register Quantum * q ;Quantum index ;switch ( depth )  {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}for ( bit = 0 ;bit ++ )  {index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}( void ) SyncAuthenticPixels ( image , exception ) ;break ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL )  break ;index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;","static MagickBooleanType InsertRow ( Image * image , ssize_t bpp , unsigned char * p , ssize_t y , ExceptionInfo * exception ) {int bit ;Quantum index ;register Quantum * q ;Quantum index ;switch ( bpp ) {index = ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}for ( bit = 0 ;bit ++ ) {index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;}break ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns - 3 ) ;x += 4 ) {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 4 ) > 2 ) {index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;}}p ++ ;}break ;}case 4 : {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;",414
557,"index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;q += GetPixelChannels ( image ) ;}}( void ) SyncAuthenticPixels ( image , exception ) ;break ;}case 4 : {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 1 ) ;x += 2 ) {q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ;SetPixelIndex ( image , index , q ) ;if ( ( image -> columns % 2 ) != 0 ) {index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;}q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL )  break ;index = ConstrainColormapIndex ( image , * p , exception ) ;SetPixelIndex ( image , index , q ) ;( void ) SyncAuthenticPixels ( image , exception ) ;","index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 ) {if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;p ++ ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;index = ConstrainColormapIndex ( image , * p , exception ) ;SetPixelIndex ( image , index , q ) ;",414
558,"static int cfm_network_addr_print ( netdissect_options * ndo ,  register const u_char * tptr )  {u_int hexdump = FALSE ;network_addr_type = * tptr ;case AFNUM_INET :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;","static int cfm_network_addr_print ( netdissect_options * ndo , register const u_char * tptr , const u_int length ) {u_int hexdump = FALSE ;if ( length < 1 ) {ND_PRINT ( ( ndo , ""\\\return hexdump ;}network_addr_type = * tptr ;case AFNUM_INET : if ( length != 1 + 4 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 : if ( length != 1 + 16 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;",415
559,u64 msr_data ;int usermode ;cs . dpl = 3 ;ss . dpl = 3 ;,"u64 msr_data , rcx , rdx ;int usermode ;rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ;rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ;cs . dpl = 3 ;ss . dpl = 3 ;",416
560,"break ;}ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ;* reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;return X86EMUL_CONTINUE ;","if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ;break ;}ctxt -> _eip = rdx ;* reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;return X86EMUL_CONTINUE ;",416
561,"return sprintf ( buf , ""%s\\\}","ssize_t len ;device_lock ( dev ) ;len = sprintf ( buf , ""%s\\\device_unlock ( dev ) ;return len ;}",417
562,"BIO * tmpout = NULL ;if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ;else if ( flags & CMS_TEXT ) {tmpout = BIO_new ( BIO_s_mem ( ) ) ;BIO_set_mem_eof_return ( tmpout , 0 ) ;else tmpout = out ;","BIO * tmpout ;tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ;goto err ;for ( ;;) {i = BIO_read ( in , buf , sizeof ( buf ) ) ;if ( i <= 0 ) {if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) {if ( ! BIO_get_cipher_status ( in ) ) goto err ;}if ( i < 0 ) goto err ;break ;}if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ;}if ( flags & CMS_TEXT ) {",418
563,"rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;}","if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;}",419
564,"static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs ,  int i , int c ) {const vp9_prob prob = probs [ i / 2 ] ;int b ;const vp9_tree_index ii = tree [ i + b ] ;if ( ii <= 0 ) costs [ - ii ] = cc ;","static void cost ( int * costs , vpx_tree tree , const vp9_prob * probs , int i , int c ) {const vpx_prob prob = probs [ i / 2 ] ;int b ;const vpx_tree_index ii = tree [ i + b ] ;if ( ii <= 0 ) costs [ - ii ] = cc ;",420
565,create_option_search_table ( ) ;goto open_rc ;,"# ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ;if ( tmp_dir == NULL ) tmp_dir = rc_dir ;# endif create_option_search_table ( ) ;goto open_rc ;",421
566,"switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;","size_t pathlen = 0 ;switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;",422
567,"case AF_UNIX :  strncpy ( addr_text ,   ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ,  sizeof ( addr_text ) - 1 ) ;addr_text [ sizeof ( addr_text ) - 1 ] = \'\\\\0\' ;","case AF_UNIX : pathlen = sizeof ( ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ) ;if ( MAXPATHLEN <= pathlen ) {pathlen = MAXPATHLEN - 1 ;}strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ;addr_text [ pathlen ] = \'\\\\0\' ;",422
568,"static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 ,  __m128i * in1 , int stride ) {","static INLINE void write_buffer_16x16 ( tran_low_t * output , __m128i * in0 , __m128i * in1 , int stride ) {",423
569,"err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ;if ( err < 0 ) return err ;","err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf + p , c , 0 ) ;if ( err < 0 ) return err ;",424
570,"struct hstate * h = hstate_vma ( vma ) ;struct page * page ;struct address_space * mapping = vma -> vm_file -> f_mapping ;struct inode * inode = mapping -> host ;if ( chg )  if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return ERR_PTR ( - VM_FAULT_SIGBUS ) ;page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ;if ( ! page ) {hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;","struct hugepage_subpool * spool = subpool_vma ( vma ) ;struct hstate * h = hstate_vma ( vma ) ;struct page * page ;if ( chg ) if ( hugepage_subpool_get_pages ( spool , chg ) ) return ERR_PTR ( - VM_FAULT_SIGBUS ) ;hugepage_subpool_put_pages ( spool , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;",425
571,"DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\","if ( NULL == filegen ) {msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ;continue ;}DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\",426
572,filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;,"if ( NULL == filegen ) {msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\\\'%s\\\'<S2SV_blank>unrecognized"" , filegen_file ) ;continue ;}filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;",426
573,"if ( t -> stamp_path )  touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ;timer_set_state ( t , TIMER_RUNNING ) ;","if ( t -> stamp_path ) touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , MODE_INVALID ) ;timer_set_state ( t , TIMER_RUNNING ) ;",427
574,"static void fadst16 ( const int16_t * input , int16_t * output ) {int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ;int x0 = input [ 15 ] ;int x1 = input [ 0 ] ;int x2 = input [ 13 ] ;int x3 = input [ 2 ] ;int x4 = input [ 11 ] ;int x5 = input [ 4 ] ;int x6 = input [ 9 ] ;int x7 = input [ 6 ] ;int x8 = input [ 7 ] ;int x9 = input [ 8 ] ;int x10 = input [ 5 ] ;int x11 = input [ 10 ] ;int x12 = input [ 3 ] ;int x13 = input [ 12 ] ;int x14 = input [ 1 ] ;int x15 = input [ 14 ] ;s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ;","static void fadst16 ( const tran_low_t * input , int16_t * output ) {tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 ;tran_high_t s9 , s10 , s11 , s12 , s13 , s14 , s15 ;tran_high_t x0 = input [ 15 ] ;tran_high_t x1 = input [ 0 ] ;tran_high_t x2 = input [ 13 ] ;tran_high_t x3 = input [ 2 ] ;tran_high_t x4 = input [ 11 ] ;tran_high_t x5 = input [ 4 ] ;tran_high_t x6 = input [ 9 ] ;tran_high_t x7 = input [ 6 ] ;tran_high_t x8 = input [ 7 ] ;tran_high_t x9 = input [ 8 ] ;tran_high_t x10 = input [ 5 ] ;tran_high_t x11 = input [ 10 ] ;tran_high_t x12 = input [ 3 ] ;tran_high_t x13 = input [ 12 ] ;tran_high_t x14 = input [ 1 ] ;tran_high_t x15 = input [ 14 ] ;s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ;",428
575,output [ 0 ] = x0 ;output [ 1 ] = - x8 ;output [ 2 ] = x12 ;output [ 3 ] = - x4 ;output [ 4 ] = x6 ;output [ 5 ] = x14 ;output [ 6 ] = x10 ;output [ 7 ] = x2 ;output [ 8 ] = x3 ;output [ 9 ] = x11 ;output [ 10 ] = x15 ;output [ 11 ] = x7 ;output [ 12 ] = x5 ;output [ 13 ] = - x13 ;output [ 14 ] = x9 ;output [ 15 ] = - x1 ;},output [ 0 ] = ( tran_low_t ) x0 ;output [ 1 ] = ( tran_low_t ) - x8 ;output [ 2 ] = ( tran_low_t ) x12 ;output [ 3 ] = ( tran_low_t ) - x4 ;output [ 4 ] = ( tran_low_t ) x6 ;output [ 5 ] = ( tran_low_t ) x14 ;output [ 6 ] = ( tran_low_t ) x10 ;output [ 7 ] = ( tran_low_t ) x2 ;output [ 8 ] = ( tran_low_t ) x3 ;output [ 9 ] = ( tran_low_t ) x11 ;output [ 10 ] = ( tran_low_t ) x15 ;output [ 11 ] = ( tran_low_t ) x7 ;output [ 12 ] = ( tran_low_t ) x5 ;output [ 13 ] = ( tran_low_t ) - x13 ;output [ 14 ] = ( tran_low_t ) x9 ;output [ 15 ] = ( tran_low_t ) - x1 ;},428
576,# if HAVE_EDSP  flags |= HAS_EDSP ;# endif # if HAVE_MEDIA flags |= HAS_MEDIA ;# endif  # if HAVE_NEON  flags |= HAS_NEON ;,# if HAVE_MEDIA flags |= HAS_MEDIA ;# endif # if HAVE_NEON || HAVE_NEON_ASM flags |= HAS_NEON ;,429
577,"MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi ,  const MODE_INFO * left_mi , int b ) {","PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO * left_mi , int b ) {",430
578,"static void  swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc16 ( tif , cp0 , cc ) ;}","static int swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc16 ( tif , cp0 , cc ) ;}",431
579,opt2 -> tot_len = tot_len ;p = ( char * ) ( opt2 + 1 ) ;,"atomic_set ( & opt2 -> refcnt , 1 ) ;opt2 -> tot_len = tot_len ;p = ( char * ) ( opt2 + 1 ) ;",432
580,"for ( i = 0 ;i ++ )  av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;return 0 ;}","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;}return 0 ;}",433
581,if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) ||  dp == datalen ) {flags &= ~ FLAG_LAST_MATCHED ;,if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) ) {flags &= ~ FLAG_LAST_MATCHED ;,434
582,"char * fpath = NULL , * cgdir = NULL , * controller ;const char * cgroup ;","char * fpath = NULL , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;",435
583,"fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\\if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;return ret ;}","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , & next ) ) {if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;goto out ;}if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ;else ret = - ENOENT ;if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) {ret = - EACCES ;goto out ;}if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;free ( next ) ;return ret ;}",435
584,if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ;if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ;else mnt -> mnt_group_id = old -> mnt_group_id ;if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) {err = mnt_alloc_group_id ( mnt ) ;if ( err ) goto out_free ;mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ;if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) )  mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) )  mnt -> mnt . mnt_flags |= MNT_LOCKED ;,if ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ;if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ;if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) mnt -> mnt . mnt_flags |= MNT_LOCKED ;,436
585,"}if ( trans == NULL ) {kmem_cache_free ( rds_conn_slab , conn ) ;conn = ERR_PTR ( - ENODEV ) ;goto out ;","
",437
586,if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 &&  rdesc [ 106 ] == 0x03 ) {,if ( * rsize >= 112 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && rdesc [ 106 ] == 0x03 ) {,438
587,"if ( ( tot_len - offset - 4 ) < bodyLength ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;","if ( ( ( tot_len - offset - 4 ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;",439
588,"if ( likely ( port -> exists && ! filtered ) )  serio_interrupt ( serio , data , dfl ) ;","if ( likely ( serio && ! filtered ) ) serio_interrupt ( serio , data , dfl ) ;",440
589,"if ( ! er )  ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ;return ;",if ( ! er ) {ND_TCHECK ( dp [ 0 ] ) ) ) ;return ;,441
590,"static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName ,   int udfLen , uint8_t * fidName ,  int fidNameLen ) {","static int udf_translate_to_linux ( uint8_t * newName , int newLen , uint8_t * udfName , int udfLen , uint8_t * fidName , int fidNameLen ) {",442
591,if ( newIndex < 256 )  newName [ newIndex ++ ] = curr ;,if ( newIndex < newLen ) newName [ newIndex ++ ] = curr ;,442
592,maxFilenameLen = 250 - localExtIndex ;if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ;else newIndex = newExtIndex ;}else if ( newIndex > 250 )  newIndex = 250 ;,maxFilenameLen = newLen - CRC_LEN - localExtIndex ;if ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN ;,442
593,"static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) {const VP9_COMMON * const cm = & cpi -> common ;const int mis = cm -> mi_stride ;const int bs = num_8x8_blocks_wide_lookup [ bsize ] , hbs = bs / 2 ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;if ( bw == bs && bh == bs ) {count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts ,  temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ;count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 + hbs ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ;","static void count_segs_sb ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi_8x8 , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) {const int mis = cm -> mi_stride ;const int bs = num_8x8_blocks_wide_lookup [ mi [ 0 ] -> mbmi . sb_type ] ;bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;if ( bw == bs && bh == bs ) {count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi + hbs * mis , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ;count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi + hbs , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ;",443
594,"count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ;","count_segs_sb ( cm , xd , tile , & mi [ mi_dr * mis + mi_dc ] , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ;",443
595,if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ;if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ;if ( ! c -> reqtype ) {,if ( ! ( c -> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) ) break ;if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ;if ( ! c -> reqtype ) {,444
596,get_blocks_flags = EXT4_GET_BLOCKS_CREATE ;if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ;,get_blocks_flags = EXT4_GET_BLOCKS_CREATE ;if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT ;if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ;,445
597,"int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err :  DSA_SIG_free ( s ) ;return ( ret ) ;","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & p , siglen ) == NULL ) goto err ;derlen = i2d_DSA_SIG ( s , & der ) ;if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}DSA_SIG_free ( s ) ;return ( ret ) ;",446
598,"gdImageGifCtx ( im , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;","if ( ! _gdImageGifCtx ( im , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",447
599,kfree ( bprm ) ;},if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;kfree ( bprm ) ;},448
600,"size_t canonnamelen = 0 ;if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) )  {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle ,  & p -> ai_flags ,   & p -> ai_family ,   & p -> ai_socktype ,   & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen ,  NULL ,  canonnamelen ,  & canonnamelen , NULL ) != OE_OK ) {","size_t canonnamelen_in = 0 ;if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , & p_out . ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol , p -> ai_addrlen , & p -> ai_addrlen , NULL , canonnamelen , & canonnamelen , NULL ) != OE_OK ) {",449
601,"if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) )  {if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) )  {if ( oe_syscall_getaddrinfo_read_ocall (  & retval , handle , & p -> ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen , p -> ai_addr ,  canonnamelen ,  & canonnamelen , p -> ai_canonname ) != OE_OK ) {if ( tail )  {","if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) ) {if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) ) {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , & p -> ai_flags , & p_out . ai_family , & p -> ai_socktype , & p_out . ai_protocol , p_out . ai_addrlen , & p -> ai_addrlen , p -> ai_addr , canonnamelen_in , & canonnamelen_out , p -> ai_canonname ) != OE_OK ) {if ( ( p -> ai_flags != p_out . ai_flags ) || ( p -> ai_family != p_out . ai_family ) || ( p -> ai_socktype != p_out . ai_socktype ) || ( p -> ai_protocol != p_out . ai_protocol ) || ( p -> ai_addrlen != p_out . ai_addrlen ) || ( canonnamelen_out != canonnamelen_in ) || ( canonnamelen_out && p -> ai_canonname [ canonnamelen_out - 1 ] != '\\\\0' ) ) {ret = OE_EAI_FAIL ;goto done ;}if ( tail ) {",449
602,"separator = strchr ( token , \':\' ) ;if ( separator != NULL ) {","separator = osStrchr ( token , \':\' ) ;if ( separator != NULL ) {",450
603,"separator = strchr ( token , \'=\' ) ;if ( separator != NULL ) {","separator = osStrchr ( token , \'=\' ) ;if ( separator != NULL ) {",450
604,rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ;,"if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) {iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ;goto done ;}rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ;",451
605,"vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs ,  sizeof ( default_coef_probs ) ) ;","memcpy ( pc -> fc . coef_probs , default_coef_probs , sizeof ( default_coef_probs ) ) ;",452
606,"static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data )  {int ret ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 ,  indx , data , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}","static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , const void * data ) {u8 * buf ;int ret ;buf = kmemdup ( data , size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , indx , buf , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\kfree ( buf ) ;return ret ;}",453
607,"mod_ty  Module ( asdl_seq * body , PyArena * arena )  {return p ;}","mod_ty Module ( asdl_seq * body , asdl_seq * type_ignores , PyArena * arena ) {p -> v . Module . type_ignores = type_ignores ;return p ;}",454
608,"sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ;}",},455
609,"int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src ,  int64_t ts_start , int64_t ts_end , unsigned int flags ) {struct lookahead_entry * buf ;# endif  if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ;# if USE_PARTIAL_COPY   if ( ctx -> max_sz == 1 && active_map && ! flags ) {for ( row = 0 ;","int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src , int64_t ts_start , int64_t ts_end , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif unsigned int flags ) {struct lookahead_entry * buf ;# endif int width = src -> y_crop_width ;int height = src -> y_crop_height ;int uv_width = src -> uv_crop_width ;int uv_height = src -> uv_crop_height ;int subsampling_x = src -> subsampling_x ;int subsampling_y = src -> subsampling_y ;int larger_dimensions , new_dimensions ;if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ;new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ;larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ;assert ( ! larger_dimensions || new_dimensions ) ;# if USE_PARTIAL_COPY if ( ! new_dimensions && ctx -> max_sz == 1 && active_map && ! flags ) {for ( row = 0 ;",456
610,"vp9_copy_and_extend_frame ( src , & buf -> img ) ;}# else vp9_copy_and_extend_frame ( src , & buf -> img ) ;","# endif if ( larger_dimensions ) {YV12_BUFFER_CONFIG new_img ;memset ( & new_img , 0 , sizeof ( new_img ) ) ;if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ;vpx_free_frame_buffer ( & buf -> img ) ;# if USE_PARTIAL_COPY }",456
611,"rc = fuse_dev_release ( inode , file ) ;return rc ;","fuse_conn_put ( & cc -> fc ) ;rc = fuse_dev_release ( inode , file ) ;return rc ;",457
612,"if ( code )  return code ;code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;","if ( code ) {* status = ""DECODE_PA_S4U_X509_USER"" ;return code ;}code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;",458
613,"static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf )  {","static int scsi_disk_emulate_command ( SCSIDiskReq * r ) {uint8_t * outbuf ;if ( ! r -> iov . iov_base ) {if ( req -> cmd . xfer > 65536 ) {goto illegal_request ;}r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}outbuf = r -> iov . iov_base ;",459
614,if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f ||  s -> cur_pic . field_picture ||  s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ;,if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture ) return 0 ;,460
615,"if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;}return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;}","struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ;int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ;goto out ;}out : return ret ;}",461
616,"if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) )  return 0 ;ext_block = ( struct grub_ext4_extent_header * ) buf ;","if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) ) {return 0 ;}ext_block = ( struct grub_ext4_extent_header * ) buf ;",462
617,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}",ret = key_read_state ( key ) ;if ( ret < 0 ) goto error2 ;,463
618,"ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;",464
619,"ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 1 ) ;if ( bp [ hlen ] & 0xf0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( bp [ hlen ] & 0x10 )  ND_PRINT ( ( ndo , ""K"" ) ) ;hlen += 1 ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;hlen += 2 ;break ;case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( * mh , hlen + 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;if ( bp [ hlen ] & 0xf0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;}if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , ""K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( bp [ hlen ] , 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;",464
620,dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,465
621,uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,uint32_t data_siz ;uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,466
622,}UNUSED ( hmi_size ) ;,"}if ( hmi_track_offset [ i ] >= hmi_size ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz = hmi_size - hmi_track_offset [ i ] ;",466
623,"if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_track_offset [ i ] += hmi_tmp ;}else if ( hmi_data [ 1 ] == 0x15 ) {hmi_data += 4 ;}hmi_data += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;","if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_tmp += 4 ;hmi_tmp = 8 ;}else {hmi_tmp = 4 ;}hmi_data += 4 ;if ( hmi_tmp > data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -= hmi_tmp ;}hmi_data += 4 ;hmi_track_offset [ i ] += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , data_siz , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;",466
624,hmi_track_offset [ i ] += setup_ret ;note [ hmi_tmp ] . length = 0 ;if ( * hmi_data > 0x7f ) {do {note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;hmi_track_offset [ i ] ++ ;}}hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {,"data_siz -= setup_ret ;}}if ( data_siz && * hmi_data > 0x7f ) {do {if ( ! data_siz ) break ;if ( ! data_siz ) break ;note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;}}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {",466
625,}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,466
626,release_sock ( sk ) ;return 0 ;,haddr -> hci_channel = 0 ;release_sock ( sk ) ;return 0 ;,467
627,fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,fh16 [ 3 ] = 0 ;fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,468
628,"if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) {* status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ;","if ( check_anon ( kdc_active_realm , client . princ , request -> server ) != 0 ) {* status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ;",469
629,if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {,"
",470
630,}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {,if ( src_known && dst_known ) {,470
631,if ( dst_reg -> smin_value < 0 ) {if ( umin_val ) {}},if ( dst_reg -> smin_value < 0 ) {if ( umin_val ) {}},470
632,"if ( method == LPF_PICK_FROM_Q ) {const int min_filter_level = 0 ;const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ;int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ;search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;}","if ( method == LPF_PICK_MINIMAL_LPF && lf -> filter_level ) {lf -> filter_level = 0 ;}else if ( method >= LPF_PICK_FROM_Q ) {const int min_filter_level = 0 ;const int q = vp9_ac_quant ( cm -> base_qindex , 0 , cm -> bit_depth ) ;# if CONFIG_VP9_HIGHBITDEPTH int filt_guess ;switch ( cm -> bit_depth ) {case VPX_BITS_8 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;break ;case VPX_BITS_10 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 4060632 , 20 ) ;break ;case VPX_BITS_12 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 16242526 , 22 ) ;break ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>"" ""or<S2SV_blank>VPX_BITS_12"" ) ;return ;}# else int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;# endif if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ;lf -> filter_level = search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;}",471
633,for ( i = 0 ;,TEMP_FAILURE_RETRY ( for ( i = 0 ;,472
634,"usleep ( 100000 ) ;kill ( getpid ( ) , SIGKILL ) ;","usleep ( 100000 ) ) ;kill ( getpid ( ) , SIGKILL ) ;",472
635,quantum_info = DestroyQuantumInfo ( quantum_info ) ;return ( DestroyImageList ( image ) ) ;,quantum_info = DestroyQuantumInfo ( quantum_info ) ;canvas_image = DestroyImage ( canvas_image ) ;return ( DestroyImageList ( image ) ) ;,473
636,"int a = getnum ( fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;","int a = getnum ( L , fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;",474
637,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\\",475
638,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,476
639,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",476
640,"if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) )  break ;SetImageColorspace ( image , CMYKColorspace ) ;","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;SetImageColorspace ( image , CMYKColorspace ) ;",477
641,"long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",478
642,"if ( ! ctx || ( ! data && data_sz ) )  res = VPX_CODEC_INVALID_PARAM ;res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz ,  user_priv , deadline ) ;","if ( ! ctx || ( ! data && data_sz ) || ( data && ! data_sz ) ) res = VPX_CODEC_INVALID_PARAM ;res = ctx -> iface -> dec . decode ( get_alg_priv ( ctx ) , data , data_sz , user_priv , deadline ) ;",479
643,"if ( ! strcmp ( attr , ""packetization-mode"" ) ) {","if ( * value == 0 || ! strcmp ( attr , ""packetization-mode"" ) ) {",480
644,"if ( value [ strlen ( value ) - 1 ] == \',\' ) {av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\\","if ( value [ strlen ( value ) - 1 ] == \',\' ) {av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\\",480
645,static int isofs_read_inode ( struct inode * inode )  {,"static int isofs_read_inode ( struct inode * inode , int relocated ) {",481
646,"parse_rock_ridge_inode ( de , inode ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;","parse_rock_ridge_inode ( de , inode , relocated ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;",481
647,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",482
648,"if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ;if ( length <= 2 ) {ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ;return ;}esis_header = ( const struct esis_header_t * ) pptr ;ND_TCHECK ( * esis_header ) ;li = esis_header -> length_indicator ;optr = pptr ;if ( esis_header -> nlpid != NLPID_ESIS ) {ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ;return ;}if ( esis_header -> version != ESIS_VERSION ) {ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ;return ;}if ( li > length ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ;return ;}if ( li < sizeof ( struct esis_header_t ) + 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ;while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ;return ;}esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ;if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ;return ;}else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\\ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ;osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ;if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\\pptr += sizeof ( struct esis_header_t ) ;li -= sizeof ( struct esis_header_t ) ;switch ( esis_pdu_type ) {case ESIS_PDU_REDIRECT : {const uint8_t * dst , * snpa , * neta ;u_int dstl , snpal , netal ;ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}dstl = * pptr ;pptr ++ ;li -- ;ND_TCHECK2 ( * pptr , dstl ) ;if ( li < dstl ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}dst = pptr ;pptr += dstl ;li -= dstl ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}snpal = * pptr ;pptr ++ ;li -- ;ND_TCHECK2 ( * pptr , snpal ) ;if ( li < snpal ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}snpa = pptr ;pptr += snpal ;li -= snpal ;ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}netal = * pptr ;pptr ++ ;ND_TCHECK2 ( * pptr , netal ) ;if ( li < netal ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}neta = pptr ;pptr += netal ;li -= netal ;if ( netal == 0 )   ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\","if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\if ( netal != 0 ) ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\",483
649,"outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ;}}","sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ;}sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ;}sendClean ( outputbuffer ) ;}",484
650,BUG ( ) ;}BUG ( ) ;},return false ;}}else if ( r -> CRn == 0 && r -> CRm == 9 ) {if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ;idx = ARMV8_PMU_CYCLE_IDX ;return false ;},485
651,case IS_STRING :  convert_to_double_ex ( zval_affine_elem ) ;affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ;break ;,case IS_STRING : {zval dval ;dval = * * zval_affine_elem ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;affine [ i ] = Z_DVAL ( dval ) ;}break ;,486
652,"convert_to_long_ex ( tmp ) ;rect . x = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;convert_to_long_ex ( tmp ) ;rect . height = Z_LVAL_PP ( tmp ) ;}","if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . x = Z_LVAL ( lval ) ;}}rect . x = Z_LVAL_PP ( tmp ) ;}else {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . y = Z_LVAL ( lval ) ;}}else {rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . width = Z_LVAL ( lval ) ;}}else {rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . height = Z_LVAL ( lval ) ;}else {rect . height = Z_LVAL_PP ( tmp ) ;}}",486
653,static void ast_dealloc ( AST_object * self )  {Py_CLEAR ( self -> dict ) ;,static void ast_dealloc ( AST_object * self ) {PyObject_GC_UnTrack ( self ) ;Py_CLEAR ( self -> dict ) ;,487
654,free ( szSepLine ) ;return 0 ;,return 0 ;,488
655,"r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ;if ( r ) return - EFAULT ;","r = __copy_from_user ( data , ( void __user * ) addr + offset , len ) ;if ( r ) return - EFAULT ;",489
656,"char * p , * q , * r ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;","char * p , * q ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;",490
657,"printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;","printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;",490
658,"if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( * p ) ;p ++ )  ;lenIV = atoi ( line + 6 ) ;}else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) )  && strstr ( line , ""readstring"" ) ) {* p = \'\\\\0\' ;q = strrchr ( line , \'/\' ) ;if ( q ) {r = cs_start ;++ q ;while ( ! isspace ( * q ) && * q != \'{\' ) * r ++ = * q ++ ;* r = \'\\\\0\' ;* p = \'s\' ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) )  ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) )  ever_active = active = 1 ;for ( q = p ;isspace ( * q ) && * q != \'\\\q ++ )  ;","if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( ( unsigned char ) line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( ( unsigned char ) * p ) ;p ++ ) ;+ q ;set_lenIV ( line ) ;else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) ) ) {set_cs_start ( line ) ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( ( unsigned char ) p [ 7 ] ) ) ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( ( unsigned char ) p [ 13 ] ) ) ever_active = active = 1 ;for ( q = p ;isspace ( ( unsigned char ) * q ) && * q != \'\\\q ++ ) ;",490
659,"
",info -> port = NULL ;,491
660,usb_autopm_put_interface ( serial -> interface ) ;error_get_interface : usb_serial_put ( serial ) ;,usb_autopm_put_interface ( serial -> interface ) ;error_get_interface : usb_serial_put ( serial ) ;,491
661,"lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ;lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ;cpuctx -> ctx . type = cpu_context ;cpuctx -> ctx . pmu = pmu ;",lockdep_set_class ( & cpuctx -> ctx . pmu = pmu ;,492
662,"static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len ,  struct iovec * iovec )  {return 0 ;}","static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , struct iovec * iovec , struct iov_iter * iter ) {if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ;iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;return 0 ;}",493
663,int groups_per_flex = 0 ;size_t size ;groups_per_flex = 1 << sbi -> s_log_groups_per_flex ;if ( groups_per_flex < 2 ) {sbi -> s_log_groups_per_flex = 0 ;return 1 ;},unsigned int groups_per_flex = 0 ;size_t size ;,494
664,if ( unlikely ( chunk_length < required_length ) )  return 0 ;,if ( unlikely ( chunk -> pdiscard ) ) return 0 ;if ( unlikely ( chunk_length < required_length ) ) return 0 ;,495
665,for ( i = 0 ;++ i ) {n = cJSON_CreateString ( strings [ i ] ) ;if ( ! i )  a -> child = n ;,for ( i = 0 ;+ i ) {i ++ ) {n = cJSON_CreateString ( strings [ i ] ) ;if ( ! n ) {cJSON_Delete ( a ) ;return 0 ;}if ( ! i ) a -> child = n ;,496
666,"
","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;",497
667,"if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",497
668,"if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;","if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",497
669,else # endif  for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,else # endif for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,498
670,match_length += callback_args -> forward_matches ;if ( callback_args -> full_word ) {,match_length += callback_args -> forward_matches ;assert ( match_offset + match_length <= callback_args -> data_size ) ;if ( callback_args -> full_word ) {,499
671,"if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 &&  ! no_port_forwarding_flag && ! options . disable_forwarding ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;","if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 && ! no_port_forwarding_flag && ! options . disable_forwarding && use_privsep ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;",500
672,if ( ! bitstream_read_bit ( bc ) ) {if ( hc -> current >= 256 ) {,"if ( length > SMKTREE_DECODE_MAX_RECURSION ) {av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\\return AVERROR_INVALIDDATA ;}if ( ! bitstream_read_bit ( bc ) ) {if ( hc -> current >= 256 ) {",501
673,m -> msg_name = address ;},if ( m -> msg_name ) m -> msg_name = address ;},502
674,"if ( obj == Py_None ) {* out = NULL ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;","if ( lookup_attr_id ( obj , ( PyObject * ) Module_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;return 1 ;}else {int res ;Py_ssize_t i ;",503
675,"stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ;","stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""type_ignores\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;else {Py_ssize_t i ;",503
676,"type_ignore_ty value ;res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( type_ignores , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""type_ignores\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;return 1 ;","type_ignore_ty val ;res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( type_ignores , i , val ) ;}",503
677,"if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;","if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ;return 1 ;}else {Py_ssize_t i ;",503
678,"stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ;return 1 ;","stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}",503
679,"if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {asdl_seq * argtypes ;expr_ty returns ;if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ;","if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;}else {Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , & PyId_argtypes ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ;",503
680,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( argtypes , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;return 1 ;tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;if ( tmp == NULL ) goto failed ;","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( argtypes , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;return 1 ;tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;if ( tmp == NULL ) goto failed ;",503
681,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;",Py_ssize_t i ;,503
682,"stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;","stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;}int res ;res = obj2ast_expr ( tmp , & returns , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}* out = Suite ( body , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}PyErr_Format ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;",503
683,int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;,int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;,504
684,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,504
685,"iwl_sta_ucode_activate ( priv , sta_id ) ;ret = 0 ;","ret = iwl_sta_ucode_activate ( priv , sta_id ) ;",505
686,"log_file = NULL ;}if ( ! name ) return ;file_name = make_file_name ( name , prog , namespace , instance ) ;log_file = fopen ( file_name , ""a"" ) ;if ( log_file ) {","log_file = fopen_safe ( file_name , ""a"" ) ;if ( log_file ) {",506
687,},"assert_regexp_syntax_error ( ""\\\\\\\\x0"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\xxy"" ) ;}",507
688,"if ( hashbin -> hb_type & HB_LOCK ) {spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ;}queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;while ( queue ) {if ( free_func )  ( * free_func ) ( queue ) ;queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;}}hashbin -> hb_current = NULL ;hashbin -> magic = ~ HB_MAGIC ;if ( hashbin -> hb_type & HB_LOCK ) {spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP  hashbin_lock_depth -- ;","if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ;while ( 1 ) {queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;if ( ! queue ) break ;if ( free_func ) {if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;free_func ( queue ) ;if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP hashbin_lock_depth -- ;",508
689,"err = security_sb_remount ( sb , data ) ;if ( err ) return err ;","if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) {return - EPERM ;}err = security_sb_remount ( sb , data ) ;if ( err ) return err ;",509
690,"int copied , err ;struct sockaddr_ll * sll ;","int copied , err ;",510
691,"sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;if ( sock -> type == SOCK_PACKET )  msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;else  msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name )  memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa ,  msg -> msg_namelen ) ;if ( pkt_sk ( sk ) -> auxdata ) {","copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name ) {if ( sock -> type == SOCK_PACKET ) {msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;}else {struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;}memcpy ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ;}if ( pkt_sk ( sk ) -> auxdata ) {",510
692,uchar buf [ RAS_MAGICLEN ] ;int i ;,jas_uchar buf [ RAS_MAGICLEN ] ;int i ;,511
693,if ( serial -> num_ports < 2 )  return - 1 ;,if ( serial -> num_bulk_out < 2 ) return - 1 ;,512
694,"int do_rf64 = 0 , write_junk = 1 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;JunkChunk junkchunk ;","int do_rf64 = 0 , write_junk = 1 , table_length = 0 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;CS64Chunk cs64_chunk ;JunkChunk junkchunk ;",513
695,"if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;","total_riff_bytes += table_length * sizeof ( CS64Chunk ) ;if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;",513
696,ds64hdr . ckSize = sizeof ( ds64_chunk ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;riffhdr . ckSize = ( uint32_t ) - 1 ;,ds64hdr . ckSize = sizeof ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;ds64_chunk . tableLength = table_length ;riffhdr . ckSize = ( uint32_t ) - 1 ;,513
697,"WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {","if ( table_length ) {strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ;cs64_chunk . chunkSize64 = 12345678 ;WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ;}WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}if ( ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {",513
698,"if ( MSG_CMSG_COMPAT & flags ) {if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ;else {err = copy_msghdr_from_user ( msg_sys , msg ) ;if ( err ) return err ;}if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) {err = - EMSGSIZE ;if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ;err = - ENOMEM ;iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ;if ( ! iov ) goto out ;}uaddr = ( __force void __user * ) msg_sys -> msg_name ;uaddr_len = COMPAT_NAMELEN ( msg ) ;if ( MSG_CMSG_COMPAT & flags ) {err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;}else  err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;","if ( MSG_CMSG_COMPAT & flags ) err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;else err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ;msg_sys -> msg_namelen = 0 ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;",514
699,"struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;u64 bn , dblock = 0 ;const unsigned end_of_metadata = height - 1 ;int eob = 0 ;","struct super_block * sb = sdp -> sd_vfs ;struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;u64 bn , dblock = 0 ;const unsigned end_of_metadata = height - 1 ;int ret ;int eob = 0 ;",515
700,"
","if ( buffer_zeronew ( bh_map ) ) {ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ;if ( ret ) {fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\\clear_buffer_zeronew ( bh_map ) ;}}",515
701,break ;},break ;},515
702,"fprintf ( stderr , ""Codec:<S2SV_blank>%s\\\fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\\}SHOW ( g_timebase . num ) ;SHOW ( g_timebase . den ) ;SHOW ( rc_resize_allowed ) ;SHOW ( rc_resize_up_thresh ) ;","fprintf ( stderr , ""Codec:<S2SV_blank>%s\\\fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\\}SHOW ( g_bit_depth ) ;SHOW ( g_input_bit_depth ) ;SHOW ( g_timebase . num ) ;SHOW ( g_timebase . den ) ;SHOW ( rc_resize_allowed ) ;SHOW ( rc_scaled_width ) ;SHOW ( rc_scaled_height ) ;SHOW ( rc_resize_up_thresh ) ;",516
703,"
",{BOOL rc ;,517
704,"PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;","PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) rc = nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ;}{BOOL rc ;PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) rc = context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) if ( ! rc ) return FALSE ;}if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;",517
705,else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) &&  ( target -> doc -> dict == ctxt -> dict ) )  {,"else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) && ( target -> doc -> dict == ctxt -> dict ) && xmlDictOwns ( ctxt -> dict , value ) ) {",518
706,"if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;}else {}}free ( fname ) ;}else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) {if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( fname , & s ) == 0 ) return ;if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ;}else {FILE * fp = fopen ( fname , ""w"" ) ;if ( fp ) {fprintf ( fp , ""\\\SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ;fclose ( fp ) ;}}","copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;}else {else {touch_file_as_user ( fname , u , g , 0644 ) ;}}",519
707,"if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ;}free ( fname ) ;","if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ;}free ( fname ) ;",519
708,"static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req ,  size_t * acl_len )  {__be32 * savep ;uint32_t attrlen , bitmap [ 3 ] = {* acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 )  goto out ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;recvd = req -> rq_rcv_buf . len - hdrlen ;dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr""  ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\* acl_len = attrlen ;}","static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , struct nfs_getaclres * res ) {__be32 * savep , * bm_p ;uint32_t attrlen , bitmap [ 3 ] = {res -> acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) goto out ;bm_p = xdr -> p ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;xdr -> p = bm_p ;res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ;res -> acl_data_offset <<= 2 ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;attrlen += res -> acl_data_offset ;recvd = req -> rq_rcv_buf . len - hdrlen ;if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) {res -> acl_len = attrlen ;goto out ;}dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\res -> acl_len = attrlen ;}",520
709,if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {},if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {}else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) {return false ;},521
710,"assert ( msix_tab_size % 4096 == 0 ) ;bzero ( msixcap , sizeof ( struct msixcap ) ) ;","bzero ( msixcap , sizeof ( struct msixcap ) ) ;",522
711,when = timespec_to_ns ( new_setting -> it_value ) ;period = timespec_to_ns ( new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( n ) ;if ( when > now ) when -= now ;,when = timespec_to_ns ( & new_setting -> it_value ) ;period = timespec_to_ns ( & new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( & n ) ;if ( when > now ) when -= now ;,523
712,"if ( ! js_regexec ( re -> prog , text , & m , 0 ) )  js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;","if ( ! js_doregexec ( J , re -> prog , text , & m , 0 ) ) js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;",524
713,"case OFreshOID :  if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 )  caml_set_oo_id ( ( value ) dest ) ;","case OFreshOID : if ( Long_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) caml_set_oo_id ( ( value ) dest ) ;",525
714,"struct range * range ;struct evbuffer * evb = NULL ;size_t content_length ;int code = 500 , fd = - 1 , i , nranges , ret ;uint32_t boundary ;if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) {code = 416 ;if ( ( evb = evbuffer_new ( ) ) == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ;goto abort ;}( void ) snprintf ( content_range , sizeof ( content_range ) ,  ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;content_length = range -> end - range -> start + 1 ;if ( buffer_add_range ( fd , evb , range ) == 0 )  goto abort ;content_length = 0 ;boundary = arc4random ( ) ;-%ud\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\\\r\\\range ++ ;}if ( ( i = evbuffer_add_printf ( evb , ""\\\\r\\\-%ud--\\\\r\\\content_length += i ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) ,  ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ;media = & multipart_media ;-%llu--\\\\r\\\close ( fd ) ;fd = - 1 ;case 0 :  goto done ;default : break ;if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 )  goto fail ;bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ;if ( clt -> clt_persist )  clt -> clt_toread = TOREAD_HTTP_HEADER ;else clt -> clt_toread = TOREAD_HTTP_NONE ;clt -> clt_done = 0 ;done : evbuffer_free ( evb ) ;server_reset_http ( clt ) ;abort :  if ( evb != NULL )  evbuffer_free ( evb ) ;","struct range_data * r = & clt -> clt_ranges ;struct range * range ;size_t content_length = 0 ;int code = 500 , fd = - 1 , i , nranges , ret ;if ( ( nranges = parse_ranges ( clt , range_str , st -> st_size ) ) < 1 ) {code = 416 ;r -> range_media = media ;range = & r -> range [ 0 ] ;( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;range = & r -> range [ 0 ] ;content_length += range -> end - range -> start + 1 ;content_length = 0 ;boundary = arc4random ( ) ;content_length += ret + range -> end , st -> st_size ) ) == - 1 ) goto abort ;range ++ ;}if ( ( ret = snprintf ( NULL , 0 , ""\\\\r\\\content_length += ret ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary ) ;media = & multipart_media ;r -> range_toread = TOREAD_HTTP_RANGE ;case 0 : close ( fd ) ;goto done ;default : break ;}clt -> clt_fd = fd ;if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ;clt -> clt_srvbev_throttled = 0 ;clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ;if ( clt -> clt_srvbev == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ;goto fail ;bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ;bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ;bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ;bufferevent_disable ( clt -> clt_bev , EV_READ ) ;done : server_reset_http ( clt ) ;abort : if ( evb != NULL ) evbuffer_free ( evb ) ;",526
715,"ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ;ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ;isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ;if ( ( isr & ISR_LCIS ) != 0 ) {ier &= ~ IER_LCIE ;interface -> nicEvent = TRUE ;if ( ( isr & ISR_TXIS ) != 0 )  {ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ;n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ;if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) {if ( ( isr & ISR_RXIS ) != 0 )  {ier &= ~ IER_RXIE ;interface -> nicEvent = TRUE ;ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ;return flag ;","ier = ksz8851ReadReg ( interface , KSZ8851_IER ) ;ksz8851WriteReg ( interface , KSZ8851_IER , 0 ) ;isr = ksz8851ReadReg ( interface , KSZ8851_ISR ) ;if ( ( isr & KSZ8851_ISR_LCIS ) != 0 ) {ier &= ~ KSZ8851_IER_LCIE ;interface -> nicEvent = TRUE ;if ( ( isr & KSZ8851_ISR_TXIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS ) ;n = ksz8851ReadReg ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA ;if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) {if ( ( isr & KSZ8851_ISR_RXIS ) != 0 ) {ier &= ~ KSZ8851_IER_RXIE ;interface -> nicEvent = TRUE ;ksz8851WriteReg ( interface , KSZ8851_IER , ier ) ;return flag ;",527
716,"static void encode_quantization ( VP9_COMMON * cm ,   struct vp9_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ;write_delta_q ( wb , cm -> y_dc_delta_q ) ;","static void encode_quantization ( const VP9_COMMON * const cm , struct vp9_write_bit_buffer * wb ) {vpx_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ;write_delta_q ( wb , cm -> y_dc_delta_q ) ;",528
717,}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) && c -> format != CHUNKY ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,529
718,"if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 )  {","if ( TEMP_FAILURE_RETRY ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) ) < 0 ) {",530
719,return tmp ;}return tmp ;}return state -> ptr = tmp ;},goto softfail ;}goto softfail ;}softfail : state -> offset = 0 ;return state -> ptr = tmp ;},531
720,struct fb_vblank vblank ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;,"struct fb_vblank vblank ;memset ( & vblank , 0 , sizeof ( vblank ) ) ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;",532
721,"static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags )  {if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {}else if ( ctx -> might_cancel ) {timerfd_remove_cancel ( ctx ) ;}","static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) {spin_lock ( & ctx -> cancel_lock ) ;if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {else {__timerfd_remove_cancel ( ctx ) ;}spin_unlock ( & ctx -> cancel_lock ) ;}",533
722,"
","if ( c16 -> Curves [ i ] == NULL ) {for ( j = 0 ;j < i ;j ++ ) {_cmsFree ( ContextID , c16 -> Curves [ j ] ) ;}_cmsFree ( ContextID , c16 -> Curves ) ;_cmsFree ( ContextID , c16 ) ;return NULL ;}",534
723,"c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {","c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {",534
724,"if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;","if ( ! dev_name || kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;",535
725,"isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return ( 1 ) ;","isoclns_print ( ndo , p + 1 , length - 1 ) ;return ( 1 ) ;",536
726,"struct tmComResBusInfo * bus = & dev -> bus ;u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ;struct tmComResInfo msg_tmp ;int ret = SAA_ERR_BAD_PARAMETER ;saa7164_bus_verify ( dev ) ;if ( msg == NULL ) return ret ;if ( msg -> size > dev -> bus . m_wMaxReqSize ) {printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\\return ret ;}if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) {printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\\return ret ;}mutex_lock ( & bus -> lock ) ;curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ;curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ;if ( curr_gwp == curr_grp ) {ret = SAA_ERR_EMPTY ;goto out ;}bytes_to_read = sizeof ( * msg ) ;write_distance = 0 ;if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ;else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ;if ( bytes_to_read > write_distance ) {printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\\ret = SAA_ERR_INVALID_COMMAND ;goto out ;}new_grp = curr_grp + bytes_to_read ;if ( new_grp > bus -> m_dwSizeGetRing ) {new_grp -= bus -> m_dwSizeGetRing ;space_rem = bus -> m_dwSizeGetRing - curr_grp ;memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ;}else {memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ;}msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ;msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ;msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ;if ( peekonly ) {memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ;goto peekout ;",goto peekout ;,537
727,"memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing ,  sizeof ( * msg ) - space_rem ) ;if ( buf )  memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) -  space_rem , buf_size ) ;}memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;","memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , sizeof ( * msg ) - space_rem ) ;if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ;}memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;",537
728,"memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ;msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ;msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ;msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ;","memcpy_fromio ( msg , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ;}else if ( space_rem == sizeof ( * msg ) ) {if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ;memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ;",537
729,"RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}","if ( new_len > INT_MAX ) {efree ( replaced ) ;RETURN_FALSE ;}RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}",538
730,"if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) {log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ;","if ( peerkey && EVP_PKEY_cmp ( peerkey , localkey ) != 1 ) {log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ;",539
731,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",540
732,"static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col ,  BLOCK_SIZE bsize , BLOCK_SIZE subsize ) {MACROBLOCKD * xd = & x -> e_mbd ;int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ;assert ( bsize >= BLOCK_8X8 ) ;case PARTITION_NONE :  set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;case PARTITION_VERT :  * get_sb_index ( x , subsize ) = 0 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ;}case PARTITION_HORZ :  * get_sb_index ( x , subsize ) = 0 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;set_modeinfo_offsets ( cm , xd , mi_row + hbs , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ;}case PARTITION_SPLIT :  * get_sb_index ( x , subsize ) = 0 ;fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 1 ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 2 ;fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 3 ;break ;default : break ;","static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {MACROBLOCKD * xd = & x -> e_mbd ;int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ;PARTITION_TYPE partition = pc_tree -> partitioning ;BLOCK_SIZE subsize = get_subsize ( bsize , partition ) ;assert ( bsize >= BLOCK_8X8 ) ;case PARTITION_NONE : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> none . mic ;* ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;case PARTITION_VERT : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 0 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , subsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , subsize ) ;}case PARTITION_HORZ : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 0 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , subsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , subsize ) ;}case PARTITION_SPLIT : {fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize , * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 1 ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 0 ] ) ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) ;fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) ;break ;}default : break ;",541
733,free ( name ) ;return 0 ;,"if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;free ( name ) ;return 0 ;",542
734,int pixel_ptr = 0 ;int block_ptr ;,int pixel_ptr = - 4 ;int block_ptr ;,543
735,ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,ADVANCE_BLOCK ( ) ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
736,ADVANCE_BLOCK ( ) ;},},543
737,block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
738,ADVANCE_BLOCK ( ) ;}block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,}ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
739,ADVANCE_BLOCK ( ) ;break ;,break ;,543
740,int n ;assert ( cnt >= 0 ) ;,ssize_t n ;assert ( cnt >= 0 ) ;,544
741,__be16 type ;off = skb_gro_offset ( skb ) ;,__be16 type ;if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ;NAPI_GRO_CB ( skb ) -> encap_mark = 1 ;off = skb_gro_offset ( skb ) ;,545
742,if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,if ( numrows < 0 || numcols < 0 ) {return 0 ;}if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,546
743,"rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) ,  & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;","rval = tpm_kdfa ( session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;",547
744,"ret = key_permission ( key_ref , KEY_NEED_READ ) ;if ( ret == 0 ) goto can_read_key ;","if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}ret = key_permission ( key_ref , KEY_NEED_READ ) ;if ( ret == 0 ) goto can_read_key ;",548
745,if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  {,if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) {ps_dec -> u4_slice_start_code_found = 0 ;,549
746,if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) {if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  {,if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) {if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) {,549
747,dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {,if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {,550
748,"
","switch ( rc ) {case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) {CIFSSMBClose ( xid , pTcon , fileHandle ) ;break ;}case - ENOENT : posix_open = true ;case - EOPNOTSUPP : break ;default : pTcon -> broken_posix_open = true ;}}if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ;}else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ;",551
749,"if ( ( rc == 0 ) || ( rc == - ENOENT ) )  posix_open = true ;else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ;}if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ;}else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ;","
",551
750,"
","rc = PTR_ERR ( filp ) ;CIFSSMBClose ( xid , pTcon , fileHandle ) ;goto lookup_out ;}cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ;if ( cfile == NULL ) {fput ( filp ) ;CIFSSMBClose ( xid , pTcon , fileHandle ) ;rc = - ENOMEM ;goto lookup_out ;}}renew_parental_timestamps ( direntry ) ;}else if ( rc == - ENOENT ) {",551
751,"info . flags = VFIO_DEVICE_FLAGS_PCI ;if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ;info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ;info . num_irqs = VFIO_PCI_NUM_IRQS ;return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) {struct pci_dev * pdev = vdev -> pdev ;struct vfio_region_info info ;struct vfio_info_cap caps = {. buf = NULL , . size = 0 };int i , ret ;minsz = offsetofend ( struct vfio_region_info , offset ) ;if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( info . argsz < minsz ) return - EINVAL ;switch ( info . index ) {case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = pdev -> cfg_size ;info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;break ;case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = pci_resource_len ( pdev , info . index ) ;if ( ! info . size ) {info . flags = 0 ;break ;}info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;if ( vdev -> bar_mmap_supported [ info . index ] ) {info . flags |= VFIO_REGION_INFO_FLAG_MMAP ;if ( info . index == vdev -> msix_bar ) {ret = msix_sparse_mmap_cap ( vdev , & caps ) ;if ( ret ) return ret ;}}case VFIO_PCI_ROM_REGION_INDEX : {void __iomem * io ;size_t size ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . flags = 0 ;info . size = pci_resource_len ( pdev , info . index ) ;if ( ! info . size ) {if ( pdev -> resource [ PCI_ROM_RESOURCE ] . flags & IORESOURCE_ROM_SHADOW ) info . size = 0x20000 ;else break ;}io = pci_map_rom ( pdev , & size ) ;if ( ! io || ! size ) {info . size = 0 ;}pci_unmap_rom ( pdev , io ) ;info . flags = VFIO_REGION_INFO_FLAG_READ ;}case VFIO_PCI_VGA_REGION_INDEX : if ( ! vdev -> has_vga ) return - EINVAL ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = 0xc0000 ;info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;break ;default : if ( info . index >= VFIO_PCI_NUM_REGIONS + vdev -> num_regions ) return - EINVAL ;i = info . index - VFIO_PCI_NUM_REGIONS ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = vdev -> region [ i ] . size ;info . flags = vdev -> region [ i ] . flags ;ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ;if ( ret ) return ret ;}if ( caps . size ) {info . flags |= VFIO_REGION_INFO_FLAG_CAPS ;if ( info . argsz < sizeof ( info ) + caps . size ) {info . argsz = sizeof ( info ) + caps . size ;info . cap_offset = 0 ;}else {vfio_info_cap_shift ( & caps , sizeof ( info ) ) ;if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) {kfree ( caps . buf ) ;return - EFAULT ;}info . cap_offset = sizeof ( info ) ;}kfree ( caps . buf ) ;}return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_GET_IRQ_INFO ) {struct vfio_irq_info info ;minsz = offsetofend ( struct vfio_irq_info , count ) ;if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( info . argsz < minsz || info . index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ;switch ( info . index ) {case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX : case VFIO_PCI_REQ_IRQ_INDEX : break ;case VFIO_PCI_ERR_IRQ_INDEX : if ( pci_is_pcie ( vdev -> pdev ) ) break ;info . flags = VFIO_IRQ_INFO_EVENTFD ;info . count = vfio_pci_get_irq_count ( vdev , info . index ) ;if ( info . index == VFIO_PCI_INTX_IRQ_INDEX ) info . flags |= ( VFIO_IRQ_INFO_MASKABLE | VFIO_IRQ_INFO_AUTOMASKED ) ;else info . flags |= VFIO_IRQ_INFO_NORESIZE ;return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_SET_IRQS ) {struct vfio_irq_set hdr ;u8 * data = NULL ;int ret = 0 ;minsz = offsetofend ( struct vfio_irq_set , count ) ;if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( hdr . argsz < minsz || hdr . index >= VFIO_PCI_NUM_IRQS ||  hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK |  VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ;if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) {size_t size ;int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL )  size = sizeof ( uint8_t ) ;else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ;else return - EINVAL ;if ( hdr . argsz - minsz < hdr . count * size ||  hdr . start >= max || hdr . start + hdr . count > max )  return - EINVAL ;","max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) size = sizeof ( uint8_t ) ;else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ;else return - EINVAL ;if ( hdr . argsz - minsz < hdr . count * size || hdr . start >= max || hdr . start + hdr . count > max ) return - EINVAL ;switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) {case VFIO_IRQ_SET_DATA_NONE : size = 0 ;case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ;case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ;if ( size ) {if ( hdr . argsz - minsz < hdr . count * size ) return - EINVAL ;",552
752,"if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) {ret = ext4_jbd2_file_inode ( handle , inode ) ;if ( ret ) {unlock_page ( page ) ;put_page ( page ) ;goto errout ;}}","
",553
753,s -> filesize = - 1 ;s -> location = av_strdup ( uri ) ;,s -> filesize = UINT64_MAX ;s -> location = av_strdup ( uri ) ;,554
754,"int opt_size = sizeof ( struct ip_options ) + opt -> optlen ;ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ;if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) {kfree ( ireq -> opt ) ;","int opt_size = sizeof ( struct ip_options_rcu ) + opt -> optlen ;ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ;if ( ireq -> opt != NULL && ip_options_echo ( & ireq -> opt -> opt , skb ) ) {kfree ( ireq -> opt ) ;",555
755,"int mutt_b64_decode ( char * out , const char * in )  {","int mutt_b64_decode ( char * out , const char * in , size_t olen ) {",556
756,* out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;len ++ ;* out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;len ++ ;* out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;len ++ ;,if ( len == olen ) return len ;* out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;len ++ ;if ( len == olen ) return len ;* out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;len ++ ;if ( len == olen ) return len ;* out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;len ++ ;,556
757,pinctrl_unregister ( gpio_dev -> pctrl ) ;return 0 ;,return 0 ;,557
758,"size_t copied , len , cur_len ;ssize_t total_written = 0 ;","size_t bytes , copied , len , cur_len ;ssize_t total_written = 0 ;",558
759,"copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it ,  0 , copied ) ;cur_len -= copied ;}cur_len = save_len - cur_len ;wdata -> sync_mode = WB_SYNC_ALL ;","bytes = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , bytes ) ;cur_len -= copied ;if ( copied < bytes ) break ;}cur_len = save_len - cur_len ;if ( ! cur_len ) {for ( i = 0 ;i < nr_pages ;i ++ ) put_page ( wdata -> pages [ i ] ) ;kfree ( wdata ) ;rc = - EFAULT ;break ;}for ( ;nr_pages > i + 1 ;nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) ;wdata -> sync_mode = WB_SYNC_ALL ;",558
760,if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) )  return rdesc ;,if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ;if ( * rsize < 4 ) return rdesc ;,559
761,"int number_of_frames , number_of_keyframes , encode_frame_count ;int i , j ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || si == NULL ) return NULL ;svc_log_reset ( svc_ctx ) ;encode_frame_count = si -> encode_frame_count ;if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ;svc_log ( svc_ctx , SVC_LOG_INFO , ""\\\number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ;for ( i = 0 ;number_of_frames = encode_frame_count ;if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) {number_of_frames -= number_of_keyframes ;}","int number_of_frames ;int i , j ;SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;number_of_frames = si -> psnr_pkt_received ;if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ;svc_log ( svc_ctx , SVC_LOG_INFO , ""\\\for ( i = 0 ;",560
762,"si -> encode_frame_count = 0 ;svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\\","si -> psnr_pkt_received = 0 ;svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\\",560
763,"static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize )  {","static BOOL nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 outSize , UINT32 originalSize ) {",561
764,* out ++ = value ;left -- ;,if ( outSize < 1 ) return FALSE ;outSize -- ;* out ++ = value ;left -- ;,561
765,"FillMemory ( out , len , value ) ;out += len ;* out ++ = value ;left -- ;* ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ;","if ( outSize < len ) return FALSE ;outSize -= len ;FillMemory ( out , len , value ) ;out += len ;if ( outSize < 1 ) return FALSE ;outSize -- ;* out ++ = value ;left -- ;if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ;memcpy ( out , in , 4 ) ;return TRUE ;",561
766,"if ( screen -> sb_buffer )  vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ;","vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ;",562
767,"static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) {const char * literal_start = * str ;const char * literal_end ;int in_named_escape = 0 ;for ( ;char ch = * * str ;if ( ! in_named_escape && ch == \'{\' && ( * str ) - literal_start >= 2 &&  * ( * str - 2 ) == \'\\\\\\\\\' && * ( * str - 1 ) == \'N\' ) {in_named_escape = 0 ;}if ( * str + 1 < end && * ( * str + 1 ) == ch ) {literal_end = * str + 1 ;ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\\\'}return - 1 ;break ;}literal_end = * str ;assert ( * str <= end ) ;assert ( * str == end || * * str == \'{done :  if ( literal_start != literal_end ) {if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start ,  literal_end - literal_start ,  NULL , NULL ) ;else * literal = decode_unicode_with_escapes ( c , n , literal_start ,  literal_end - literal_start ) ;if ( ! * literal ) return - 1 ;","static int fstring_find_literal ( const char * s = * str ;const char * literal_start = s ;for ( ;char ch = * * str ;if ( ! in_named_escape && ch == \'{\' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == \'\\\\\\\\\' && * ( * str - 1 ) == \'N\' ) {in_named_escape = 0 ;}if ( * str + 1 < end && * ( * str + 1 ) == ch ) {literal_end = * str + 1 ;ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\\\'}return - 1 ;}break ;literal_end = * str ;assert ( * str <= end ) ;assert ( * str == end || * * str == \'{done : if ( literal_start != literal_end ) {if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ;while ( s < end ) {char ch = * s ++ ;if ( ! * literal ) return - 1 ;",563
768,"static int mem_resize ( jas_stream_memobj_t * m , int bufsize )  {assert ( bufsize >= 0 ) ;JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {","static int mem_resize ( jas_stream_memobj_t * m , size_t bufsize ) {JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {if ( ! bufsize ) {jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\\}",564
769,"struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ;char * problem_id = NULL ;","struct dump_dir * dd = NULL ;if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ;else dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ;char * problem_id = NULL ;",565
770,"if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) {log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\\\""%s\\\\"";","if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) || ! expr -> action . args ) {log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\\\""%s\\\\"";",566
771,static void pcrypt_free ( struct crypto_instance * inst )  {struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;crypto_drop_aead ( & ctx -> spawn ) ;,static void pcrypt_free ( struct aead_instance * inst ) {struct pcrypt_instance_ctx * ctx = aead_instance_ctx ( inst ) ;crypto_drop_aead ( & ctx -> spawn ) ;,567
772,z ++ )  pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ;break ;,z ++ ) pixel_value += ( ( unsigned long ) srcptr2 [ z ] << ( 8 * z ) ) ;break ;,568
773,if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) )  if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;,"if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",569
774,"in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) ;}skip_defrtr : if ( in6_dev -> nd_parms ) {unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ;if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ ) {rtime = ( rtime * HZ ) / 1000 ;if ( rtime < HZ / 10 ) rtime = HZ / 10 ;NEIGH_VAR_SET ( in6_dev -> nd_parms , RETRANS_TIME , rtime ) ;in6_dev -> tstamp = jiffies ;inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ;}rtime = ntohl ( ra_msg -> reachable_time ) ;if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) ) {rtime = ( rtime * HZ ) / 1000 ;if ( rtime < HZ / 10 ) rtime = HZ / 10 ;if ( rtime != NEIGH_VAR ( in6_dev -> nd_parms , BASE_REACHABLE_TIME ) ) {NEIGH_VAR_SET ( in6_dev -> nd_parms , BASE_REACHABLE_TIME , rtime ) ;NEIGH_VAR_SET ( in6_dev -> nd_parms , GC_STALETIME , 3 * rtime ) ;in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ) ;in6_dev -> tstamp = jiffies ;inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ;}}}skip_linkparms : if ( ! neigh ) neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ) ;if ( neigh ) {u8 * lladdr = NULL ;if ( ndopts . nd_opts_src_lladdr ) {lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ) ;if ( ! lladdr ) {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>link-layer<S2SV_blank>address<S2SV_blank>length\\\goto out ;}}neigh_update ( neigh , lladdr , NUD_STALE , NEIGH_UPDATE_F_WEAK_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE_ISROUTER | NEIGH_UPDATE_F_ISROUTER ) ;if ( ! ipv6_accept_ra ( in6_dev ) ) {ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>accept_ra<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\\goto out ;}# ifdef CONFIG_IPV6_ROUTE_INFO if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) {ND_PRINTK ( 2 , info , ""RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>router<S2SV_blank>info<S2SV_blank>ignored.\\\goto skip_routeinfo ;}if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri ) {struct nd_opt_hdr * p ;for ( p = ndopts . nd_opts_ri ;p ;p = ndisc_next_option ( p , ndopts . nd_opts_ri_end ) ) {struct route_info * ri = ( struct route_info * ) p ;# ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT && ri -> prefix_len == 0 ) continue ;# endif if ( ri -> prefix_len == 0 && ! in6_dev -> cnf . accept_ra_defrtr ) continue ;if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen ) continue ;rt6_route_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , & ipv6_hdr ( skb ) -> saddr ) ;}}skip_routeinfo : # endif # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) {ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT<S2SV_blank>(interior<S2SV_blank>routes),<S2SV_blank>dev:<S2SV_blank>%s\\\goto out ;}# endif if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi ) {struct nd_opt_hdr * p ;for ( p = ndopts . nd_opts_pi ;p ;p = ndisc_next_option ( p , ndopts . nd_opts_pi_end ) ) {addrconf_prefix_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , ndopts . nd_opts_src_lladdr != NULL ) ;}}if ( ndopts . nd_opts_mtu && in6_dev -> cnf . accept_ra_mtu ) {__be32 n ;u32 mtu ;memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ) ;mtu = ntohl ( n ) ;if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu ) {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>mtu:<S2SV_blank>%d\\\else if ( in6_dev -> cnf . mtu6 != mtu ) {in6_dev -> cnf . mtu6 = mtu ;","if ( in6_dev -> cnf . hop_limit < ra_msg -> icmph . icmp6_hop_limit ;if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) {in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;else {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\\",570
775,"static void  l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat )  {const uint16_t * ptr = ( const uint16_t * ) dat ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ;","static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint16_t * ptr = ( const uint16_t * ) dat ;if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ;",571
776,if ( ! replay_esn || ! rp )  return 0 ;if ( xfrm_replay_state_esn_len ( replay_esn ) !=   xfrm_replay_state_esn_len ( up ) )  return - EINVAL ;,int ulen ;if ( ! replay_esn || ! rp ) return 0 ;ulen = xfrm_replay_state_esn_len ( up ) ;if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) return - EINVAL ;,572
777,"int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;","int ret = proc_dointvec_minmax ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;",573
778,"bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",574
779,"fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ;for ( i = 0 ;i < 3 ;i ++ ) {thissad = sad_array [ i ] ;if ( thissad < bestsad ) {this_mv . as_mv . col = c ;thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride ) ;",574
780,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {",574
781,"l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;if  ( ! l_current_pi -> include ) {","l_current_pi -> include = 00 ;if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}if ( ! l_current_pi -> include ) {",575
782,"return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" ,  name ) ;","return try_then_request_module ( __crypto_lookup_template ( name ) , ""crypto-%s"" , name ) ;",576
783,"int start = 0 ;u32 prev_legacy , cur_legacy ;kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;","int start = 0 ;int i ;u32 prev_legacy , cur_legacy ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , kvm -> arch . vpit -> pit_state . channels [ i ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",577
784,"static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , TOKENEXTRA * * tp ) {VP9_COMMON * cm = & cpi -> common ;MACROBLOCKD * xd = & cpi -> mb . e_mbd ;vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {int dummy_rate = 0 ;int64_t dummy_dist = 0 ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ;MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ;BLOCK_SIZE bsize ;cpi -> mb . source_variance = UINT_MAX ;vp9_zero ( cpi -> mb . pred_mv ) ;switch ( cpi -> sf . partition_search_type ) {case VAR_BASED_PARTITION :  choose_partitioning ( cpi , tile , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case SOURCE_VAR_BASED_PARTITION :  set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case VAR_BASED_FIXED_PARTITION :  case FIXED_PARTITION :  bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ?  cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ;set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case REFERENCE_PARTITION :  if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) {nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 ,   & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ;}else {copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col ,   BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;}}}","static void encode_nonrd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) {SPEED_FEATURES * const sf = & cpi -> sf ;VP9_COMMON * const cm = & cpi -> common ;TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;memset ( & xd -> left_context ) ) ;memset ( xd -> left_seg_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile_info -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {const struct segmentation * const seg = & cm -> seg ;RD_COST dummy_rdc ;MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ;PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type ;BLOCK_SIZE bsize ;cpi -> mb . source_variance = UINT_MAX ;vp9_zero ( x -> pred_mv ) ;switch ( cpi -> sf . partition_search_type ) {case VAR_BASED_PARTITION : choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ;nonrd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;break ;case SOURCE_VAR_BASED_PARTITION : set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ;break ;case VAR_BASED_FIXED_PARTITION : case FIXED_PARTITION : bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ? cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , tile_info , x , mi , mi_row , mi_col , bsize ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;break ;case REFERENCE_PARTITION : if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) {nonrd_pick_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;}break ;}}",578
785,"pipe_buf_get ( ipipe , ibuf ) ;obuf = opipe -> bufs + nbuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}obuf = opipe -> bufs + nbuf ;",579
786,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;BUG_ON ( dh == NULL ) ;","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;BUG_ON ( dh == NULL ) ;",580
787,"Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL )  return HTTP_UNAUTHORIZED ;}","# ifdef UPNP_ENABLE_POST_WRITE Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL ) return HTTP_UNAUTHORIZED ;# else return HTTP_NOT_FOUND ;# endif }",581
788,"char * dir = ""/etc"" ;if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;","if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;",582
789,if ( IS_ERR ( blkg ) ) {blkg_free ( new_blkg ) ;return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,if ( IS_ERR ( blkg ) ) return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,583
790,if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,if ( bpp == 1 && buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,584
791,if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( bpp == 8 && pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,584
792,"krb5_data rspac ;const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ;","krb5_data rspac ;const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ;const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ;",585
793,"ret = krb5_unparse_name ( context , cp , & cpn ) ;","ret = krb5_unparse_name ( context , cp , tgt_realm , & cpn ) ;",585
794,"ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp ,  krbtgt_out ,  tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ;","ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp , krbtgt_out , tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ;",585
795,"cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;","nd -> last_type = LAST_BIND ;cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;",586
796,"struct usbdevfs_connectinfo ci = {. devnum = ps -> dev -> devnum ,  . slow = ps -> dev -> speed == USB_SPEED_LOW  };if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;","struct usbdevfs_connectinfo ci ;memset ( & ci , 0 , sizeof ( ci ) ) ;ci . devnum = ps -> dev -> devnum ;ci . slow = ps -> dev -> speed == USB_SPEED_LOW ;if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;",587
797,"static int ip_options_get_finish ( struct net * net , struct ip_options * * optp ,   struct ip_options * opt , int optlen )  {while ( optlen & 3 )  opt -> __data [ optlen ++ ] = IPOPT_END ;opt -> optlen = optlen ;if ( optlen && ip_options_compile ( net , opt , NULL ) ) {kfree ( opt ) ;","static int ip_options_get_finish ( struct net * net , struct ip_options_rcu * * optp , struct ip_options * opt , int optlen ) {while ( optlen & 3 ) opt -> opt . __data [ optlen ++ ] = IPOPT_END ;opt -> opt . optlen = optlen ;if ( optlen && ip_options_compile ( net , & opt -> opt , NULL ) ) {kfree ( opt ) ;",588
798,"}retval = xfs_attr3_leaf_add ( bp , args ) ;","args -> rmtvaluelen2 = args -> rmtvaluelen ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;args -> rmtvaluelen = 0 ;}retval = xfs_attr3_leaf_add ( bp , args ) ;",589
799,if ( args -> rmtblkno ) {error = xfs_attr_rmtval_remove ( args ) ;,args -> rmtvaluelen = args -> rmtvaluelen2 ;if ( args -> rmtblkno ) {error = xfs_attr_rmtval_remove ( args ) ;,589
800,ACCESS_MASK access = FILE_READ_ATTRIBUTES ;,"size_t devicePathLen = 0 ;if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\\\\\Device\\\\\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) {byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ;if ( ! readBuffer ) {Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ;Irp -> IoStatus . Information = 0 ;}else {Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;break ;}",590
801,"
",if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) {,590
802,"
",Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;}TCfree ( readBuffer ) ;}}else {,590
803,"byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) )  {","byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , sizeof ( readBuffer ) , & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) ) {",590
804,Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},590
805,if ( connection == NULL )  goto error ;,if ( connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE ) goto error ;,591
806,"uint16 nif = 0 ;if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) {","uint32 replylen ;uint16 nif = 0 ;if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) {",592
807,"for ( d = alldevs ;d = d -> next )  {if ( d -> description )  plen += strlen ( d -> description ) ;if ( d -> name )  plen += strlen ( d -> name ) ;plen += sizeof ( struct rpcap_findalldevs_if ) ;for ( address = d -> addresses ;case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif  plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ;break ;rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver ,  RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ;for ( d = alldevs ;","replylen = 0 ;for ( d = alldevs ;d = d -> next ) {if ( d -> description ) replylen += strlen ( d -> description ) ;if ( d -> name ) replylen += strlen ( d -> name ) ;replylen += sizeof ( struct rpcap_findalldevs_if ) ;for ( address = d -> addresses ;case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif replylen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ;break ;rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_FINDALLIF_REPLY , nif , replylen ) ;for ( d = alldevs ;",592
808,"struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ;if ( ! dd ) {","struct dump_dir * dd = dd_create ( path , g_settings_privatereports ? 0 : client_uid , DEFAULT_DUMP_DIR_MODE ) ;if ( ! dd ) {",593
809,x += 8 ) {for ( bit = 0 ;bit < 8 ;bit ++ ) {,x += 4 ) {,594
810,for ( x = 0 ;x += 2 )  {,for ( x = 0 ;x += 2 ) {,594
811,"BN_ULONG t1 , t2 ;BN_ULONG c1 , c2 , c3 ;","BN_ULONG c1 , c2 , c3 ;",595
812,"static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk ,  int tstype )  {int err ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {","static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , int tstype , bool opt_stats ) {int err ;BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;serr -> opt_stats = opt_stats ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {",596
813,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",597
814,"if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue )  {","if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) {",597
815,"if ( in_cksum ( vec , 1 ) )  ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" ,  EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;}","if ( in_cksum ( vec , 1 ) ) {ND_TCHECK_16BITS ( & bp [ 6 ] ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;}}",598
816,"
","run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ;",599
817,"run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;","run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;",599
818,"if ( same_thread_group ( task , current ) ) return 0 ;rcu_read_lock ( ) ;tcred = __task_cred ( task ) ;if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ;if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ;ok : rcu_read_unlock ( ) ;smp_rmb ( ) ;if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ;rcu_read_lock ( ) ;if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {rcu_read_unlock ( ) ;return - EPERM ;","if ( dumpable != SUID_DUMP_USER && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {",600
819,for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,601
820,"if ( flags & __GFP_ZERO )  memset ( addr , 0 , size ) ;","memset ( addr , 0 , size ) ;",602
821,int i ;int j ;int rowstep ;if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) {,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) {,603
822,"
","if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) {for ( i = 0 ;i < u4_payload_size / 4 ;i ++ ) {ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ;}ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ;}else {",604
823,"ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;break ;","ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ;}break ;",604
824,"ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;break ;","if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) {for ( i = 0 ;i < u4_payload_size / 4 ;i ++ ) {ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ;}ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ;}else {ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ;}break ;",604
825,"priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;","if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) {dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\\return - ENODEV ;}priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;",605
826,"if ( ret < 0 ) goto bail ;if ( ret < 0 )  goto bail ;dd -> sdma_rht = tmp_sdma_rht ;dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\\","if ( ret < 0 ) {kfree ( tmp_sdma_rht ) ;goto bail ;}if ( ret < 0 ) goto bail ;dd -> sdma_rht = tmp_sdma_rht ;dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\\",606
827,put_device ( & dev -> dev ) ;return 0 ;,cancel_autoload_drivers ( ) ;put_device ( & dev -> dev ) ;return 0 ;,607
828,"int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  {","int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick , my_bool no_copy_stat ) {",608
829,"if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {mi_check_print_error ( param , ""Can\\\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\\\'%s\\\'"" , param -> temp_filename ) ;goto err ;}if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ;if ( param -> testflag & T_UNPACK ) {share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;mi_int2store ( share -> state . header . options , share -> options ) ;}share -> state . dellink = HA_OFFSET_ERROR ;info -> rec_cache . file = new_file ;}info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;mi_drop_all_indexes ( param , info , FALSE ) ;key_map = share -> state . key_map ;if ( param -> testflag & T_CREATE_MISSING_KEYS ) {key_map = ~ key_map ;}sort_info . info = info ;sort_info . param = param ;set_data_file_type ( & sort_info , share ) ;sort_info . dupp = 0 ;sort_info . buff = 0 ;param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ;if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ;else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ;else rec_length = share -> base . pack_reclength ;sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ;del = info -> state -> del ;param -> glob_crc = 0 ;max_pack_reclength = share -> base . pack_reclength ;if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ;if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) {mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>key!"" ) ;goto err ;}total_key_length = 0 ;rec_per_key_part = param -> rec_per_key_part ;info -> state -> records = info -> state -> del = share -> state . split = 0 ;info -> state -> empty = 0 ;for ( i = key = 0 , istep = 1 ;key < share -> base . keys ;rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) {sort_param [ i ] . key = key ;sort_param [ i ] . keyinfo = share -> keyinfo + key ;sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ;if ( ! mi_is_key_active ( key_map , key ) ) {memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;istep = 0 ;continue ;}istep = 1 ;if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\\if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) {sort_param [ i ] . key_read = sort_ft_key_read ;sort_param [ i ] . key_write = sort_ft_key_write ;}else {sort_param [ i ] . key_read = sort_key_read ;sort_param [ i ] . key_write = sort_key_write ;}sort_param [ i ] . key_cmp = sort_key_cmp ;sort_param [ i ] . lock_in_memory = lock_memory ;sort_param [ i ] . tmpdir = param -> tmpdir ;sort_param [ i ] . sort_info = & sort_info ;sort_param [ i ] . master = 0 ;sort_param [ i ] . fix_datafile = 0 ;sort_param [ i ] . calc_checksum = 0 ;sort_param [ i ] . filepos = new_header_length ;sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ;sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ;if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) {mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory!"" ) ;goto err ;}sort_param [ i ] . key_length = share -> rec_reflength ;for ( keyseg = sort_param [ i ] . seg ;keyseg -> type != HA_KEYTYPE_END ;keyseg ++ ) {sort_param [ i ] . key_length += keyseg -> length ;if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ;if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ;if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ;}total_key_length += sort_param [ i ] . key_length ;if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) {uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ;sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ;init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ;}}sort_info . total_keys = i ;sort_param [ 0 ] . master = 1 ;sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ;sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ;if ( ! ftparser_alloc_param ( info ) ) goto err ;sort_info . got_error = 0 ;mysql_mutex_lock ( & sort_info . mutex ) ;if ( i > 1 ) {if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ;else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ;}else io_share . total_threads = 0 ;( void ) pthread_attr_init ( & thr_attr ) ;( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ;for ( i = 0 ;i < sort_info . total_keys ;i ++ ) {sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ;DBUG_PRINT ( ""io_cache_share"" , ( ""thread:<S2SV_blank>%u<S2SV_blank><S2SV_blank>read_cache:<S2SV_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ;sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ;# else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ;# endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) {mi_check_print_error ( param , ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread<S2SV_blank>(errno=<S2SV_blank>%d)"" , error ) ;if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ;DBUG_PRINT ( ""error"" , ( ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread"" ) ) ;sort_info . got_error = 1 ;}else sort_info . threads_running ++ ;}( void ) pthread_attr_destroy ( & thr_attr ) ;while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ;mysql_mutex_unlock ( & sort_info . mutex ) ;if ( ( got_error = thr_write_keys ( sort_param ) ) ) {param -> retry_repair = 1 ;goto err ;}got_error = 1 ;if ( sort_param [ 0 ] . fix_datafile ) {if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ;if ( param -> testflag & T_SAFE_REPAIR ) {if ( info -> state -> records + 1 < start_records ) {info -> state -> records = start_records ;goto err ;}}share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ;share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;info -> dfile = new_file ;share -> data_file_type = sort_info . new_data_file_type ;share -> pack . header_length = ( ulong ) new_header_length ;}else info -> state -> data_file_length = sort_param -> max_pos ;if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {mi_check_print_error ( param , ""Couldn\\\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ;mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ;param -> retry_repair = 1 ;param -> testflag |= T_RETRY_WITHOUT_QUICK ;goto err ;}if ( rep_quick & T_FORCE_UNIQUENESS ) {my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ;# ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ;# endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;}if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;if ( ! ( param -> testflag & T_SILENT ) ) {if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\\if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ;}got_error = 0 ;if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;( void ) end_io_cache ( & info -> rec_cache ) ;if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ;if ( ! got_error ) {if ( new_file >= 0 ) {mysql_file_close ( new_file , MYF ( 0 ) ) ;info -> dfile = new_file = - 1 ;if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;","if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;",608
830,if ( p == q || size < 16 || size > 256 )  return ( ( Image * ) NULL ) ;,if ( ( p == q ) || ( size < 16 || size > 256 ) ) return ( ( Image * ) NULL ) ;,609
831,"uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ;nblks += dblocks ;","uint dblocks = xfs_attr3_rmt_blocks ( mp , valuelen ) ;nblks += dblocks ;",610
832,pairs = palloc ( pcount * sizeof ( Pairs ) ) ;for ( i = 0 ;,"if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;pairs = palloc ( pcount * sizeof ( Pairs ) ) ;for ( i = 0 ;",611
833,"ruleaddvar ( r , var , val ) ;if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ;","ruleaddvar ( r , var , val ) ;if ( ! val ) continue ;if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ;",612
834,if ( text [ 1 ] == EOF )  return 0 ;if ( text [ 1 ] == 'x' ) {text [ 2 ] = RE_YY_INPUT ( yyscanner ) ;if ( text [ 2 ] == EOF )  return 0 ;if ( text [ 3 ] == EOF )  return 0 ;,if ( text [ 1 ] == EOF || text [ 1 ] == 0 ) return 0 ;if ( ! isxdigit ( text [ 1 ] == 'x' ) {text [ 2 ] ) ) return 0 ;if ( ! isxdigit ( text [ 3 ] ) ) return 0 ;,613
835,"
","memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;",614
836,c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ;c -> req -> path . len = ( int ) ( path . end - path . start ) ;,c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ;c -> req -> path . len = ( int ) ( path . end - path . start ) ;,614
837,"void vp9_fht16x16_c ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {vp9_fdct16x16_c ( input , output , stride ) ;}int16_t out [ 256 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;int16_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = FHT_16 [ tx_type ] ;++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j )  outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;}","void vp9_fht16x16_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {vpx_fdct16x16_c ( input , output , stride ) ;}tran_low_t out [ 256 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;tran_low_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = FHT_16 [ tx_type ] ;+ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j ) out [ j * stride + i ] * 4 ;+ j )  outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;++ j ) outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;}",615
838,"else if ( g_str_has_prefix ( arg , ""@@"" ) )  g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\\else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;","else if ( g_str_has_prefix ( arg , ""@@"" ) ) {flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" ) , arg ) ;goto out ;}else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;",616
839,"if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;if ( error )  goto out_errno ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;","error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;",617
840,"BUG_IF ( tree_root == NULL ) ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;","if ( tree_root == NULL ) return 0 ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;",618
841,"char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ;if ( ! temp_filename ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ;return false ;strcpy ( temp_filename , filename ) ;strcat ( temp_filename , "".new"" ) ;FILE * fp = fopen ( temp_filename , ""wt"" ) ;","int dir_fd = - 1 ;FILE * fp = NULL ;static const char * temp_file_ext = "".new"" ;const int filename_len = strlen ( filename ) ;const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ;char * temp_filename = osi_calloc ( temp_filename_len ) ;snprintf ( temp_filename , temp_filename_len , ""%s%s"" , filename , temp_file_ext ) ;char * temp_dirname = osi_strdup ( filename ) ;const char * directoryname = dirname ( temp_dirname ) ;if ( ! directoryname ) {LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ;goto error ;dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ;if ( dir_fd < 0 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;goto error ;}fp = fopen ( temp_filename , ""wt"" ) ;",619
842,"fprintf ( fp , ""[%s]\\\for ( const list_node_t * enode = list_begin ( section -> entries ) ;fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\\}if ( list_next ( node ) != list_end ( config -> sections ) )  fputc ( \'\\\}fflush ( fp ) ;fclose ( fp ) ;if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) {","if ( fprintf ( fp , ""[%s]\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}for ( const list_node_t * enode = list_begin ( section -> entries ) ;if ( fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}}if ( list_next ( node ) != list_end ( config -> sections ) ) {if ( fputc ( \'\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}}}if ( fsync ( fileno ( fp ) == EOF ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}if ( fsync ( dir_fd ) < 0 ) {LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;}if ( close ( dir_fd ) < 0 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;goto error ;}fp = NULL ) < 0 ) {LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;}if ( fclose ( fp ) ;if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) {",619
843,osi_free ( temp_filename ) ;return true ;error : ;unlink ( temp_filename ) ;osi_free ( temp_filename ) ;return false ;,osi_free ( temp_filename ) ;osi_free ( temp_dirname ) ;return true ;error : unlink ( temp_filename ) ;if ( fp ) fclose ( fp ) ;if ( dir_fd != - 1 ) close ( dir_fd ) ;osi_free ( temp_filename ) ;osi_free ( temp_dirname ) ;return false ;,619
844,"switch ( pc -> componentType ) {case 1 : if ( pc -> lengthComponentIdent > 0 )  break ;case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ;p = to ;* p ++ = \'/\' ;tolen -- ;break ;case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ;memcpy ( p , ""../"" , 3 ) ;p += 3 ;tolen -= 3 ;break ;case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ;memcpy ( p , ""./"" , 2 ) ;p += 2 ;tolen -= 2 ;break ;case 5 :  comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ;p += comp_len ;tolen -= comp_len ;if ( tolen == 0 ) return - ENAMETOOLONG ;* p ++ = \'/\' ;tolen -- ;elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ;}",elen += sizeof ( struct pathComponent ) ;switch ( pc -> componentType ) {case 1 : if ( pc -> lengthComponentIdent > 0 ) {elen += pc -> lengthComponentIdent ;},620
845,ND_TCHECK ( dp [ 0 ] ) ;,ND_TCHECK ( dp [ 4 ] ) ;,621
846,"ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;dp += 3 ;ND_TCHECK ( dp [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ;","ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] ) ) ) ) ;",621
847,"if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""\\\mgmtd_len = * ( tptr + 3 ) ;if ( mgmtd_len < 1 || mgmtd_len > 32 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ;return ;}fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ;tptr += VTP_HEADER_LEN ;switch ( type ) {case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ;ND_PRINT ( ( ndo , ""\\\tptr += 8 ;ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ;tptr += VTP_UPDATE_TIMESTAMP_LEN ;ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ;tptr += VTP_MD5_DIGEST_LEN ;break ;case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ;tptr += 4 ;while ( tptr < ( pptr + length ) ) {ND_TCHECK_8BITS ( tptr ) ;len = * tptr ;if ( len == 0 ) break ;ND_TCHECK2 ( * tptr , len ) ;vtp_vlan = ( const struct vtp_vlan_ * ) tptr ;ND_TCHECK ( * vtp_vlan ) ;ND_PRINT ( ( ndo , ""\\\fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ;len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;while ( len > 0 ) {type = * tptr ;tlv_len = * ( tptr + 1 ) ;if ( type == 0 || tlv_len == 0 ) {return ;ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;tlv_value = EXTRACT_16BITS ( tptr + 2 ) ;","len -= VTP_VLAN_INFO_FIXED_PART_LEN ;tptr += VTP_VLAN_INFO_FIXED_PART_LEN ;if ( len < 4 * ( ( vtp_vlan -> name_len , NULL ) ;len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += 4 * ( ( vtp_vlan -> name_len , NULL ) ;len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;while ( len > 0 ) {if ( len < 2 ) goto trunc ;ND_TCHECK2 ( * tptr , 2 ) ;if ( tlv_len != 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ;else {type = * tptr ;tlv_len = * ( tptr + 1 ) ;if ( type == 0 || tlv_len == 0 ) {return ;ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;tlv_value = EXTRACT_16BITS ( tptr + 2 ) ;",622
848,len -= 2 + tlv_len * 2 ;tptr += 2 + tlv_len * 2 ;,}len -= 2 + tlv_len * 2 ;tptr += 2 + tlv_len * 2 ;,622
849,"if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData ,  target , NULL ) ;ctxt -> instate = state ;","if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , target , NULL ) ;if ( ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate = state ;",623
850,SKIP_BLANKS ;,if ( SKIP_BLANKS ;,623
851,ctxt -> instate = state ;,ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate = state ;,623
852,ctxt -> instate = state ;},ctxt -> instate = state ;},623
853,bool slow ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,bool slow ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,624
854,"}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",624
855,"u_int tlen , pdu_type , pdu_len ;const u_char * tptr ;const rpki_rtr_pdu * pdu_header ;tptr = pptr ;tlen = len ;while ( tlen >= sizeof ( rpki_rtr_pdu ) ) {ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;","while ( tlen >= sizeof ( rpki_rtr_pdu ) ) {ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;",625
856,"if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) )  goto trunc ;tlen -= pdu_len ;tptr += pdu_len ;}return ;trunc : ND_PRINT ( ( ndo , ""\\\","if ( rpki_rtr_pdu_print ( ndo , pptr , len , 1 , 8 ) ;len -= pdu_len ;tptr += pdu_len ;}",625
857,"s = tcp_recv ( NULL , 4 ) ;if ( s == NULL ) return False ;if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) {logger ( Protocol , Error , ""cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x"" , s -> p [ 0 ] ) ;return False ;if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ;else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ;else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ;else return False ;s = tcp_recv ( s , length ) ;if ( ! ber_in_header ( s , & tagval , & length ) ||  tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ;in_uint8s ( s , length ) ;if ( token ) {if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ;token -> end = token -> p = token -> data ;out_uint8p ( token , s -> p , length ) ;","struct stream packet ;s = tcp_recv ( NULL , 4 ) ;if ( s == NULL ) return False ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;s_realloc ( token , length ) ;s_reset ( token ) ;out_uint8p ( token , s -> p , length ) ;",626
858,"int chars_processed ;int elt ;int data_size = ndo -> ndo_snapend - bp ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed = 1 ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {","int elt ;u_int offset , max_offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;max_offset = ( u_int ) ( cp - bp ) ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {",627
859,"cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {","offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( offset >= max_offset ) {ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ;return ( NULL ) ;}max_offset = offset ;cp = bp + offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {",627
860,"chars_processed += l ;ND_PRINT ( ( ndo , ""."" ) ) ;chars_processed ++ ;if ( ! compress ) rp += l + 1 ;","ND_PRINT ( ( ndo , ""."" ) ) ;if ( ! compress ) rp += l + 1 ;",627
861,"blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ;error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ;","blkcnt = xfs_attr3_rmt_blocks ( mp , args -> rmtvaluelen ) ;error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ;",628
862,lblkno = args -> rmtblkno ;blkcnt = args -> rmtblkcnt ;valuelen = args -> valuelen ;while ( valuelen > 0 ) {,lblkno = args -> rmtvaluelen ;while ( valuelen > 0 ) {,628
863,"int rv = Socket_print ( S ,  ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\\\r\\\","MD_T token ;StringBuffer_append ( data , ""%ssecuritytoken=%s"" , StringBuffer_length ( data ) > 0 ? ""&"" : """" , Util_getToken ( token ) ) ;int rv = Socket_print ( S , ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\\\r\\\",629
864,"pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 )  errExit ( ""chown"" ) ;if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 )  errExit ( ""chmod"" ) ;","copy_file_as_user ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chmod"" ) ;",630
865,if ( rc != BFA_STATUS_OK )  return NULL ;wait_for_completion ( & fcomp . comp ) ;hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ;,if ( rc != BFA_STATUS_OK ) {kfree ( fcstats ) ;return NULL ;}wait_for_completion ( & fcomp . comp ) ;hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ;,631
866,"value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ;value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ;value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ;}","value -> x = MagickMin ( 1.0f , MaxF ( 0.0f , value -> x ) ) ;value -> y = MinF ( 1.0f , MagickMax ( 0.0f , value -> y ) ) ;value -> z = MinF ( 1.0f , MagickMax ( 0.0f , value -> z ) ) ;}",632
867,* head = NULL ;* out = line ;return 0 ;,"giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ;return GIT_ERROR ;",633
868,"if ( check_stack_guard_page ( vma , address ) < 0 )  return VM_FAULT_SIGSEGV ;","if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ;if ( check_stack_guard_page ( vma , address ) < 0 ) return VM_FAULT_SIGSEGV ;",634
869,rec -> sasl_username = src -> sasl_username ;rec -> sasl_password = src -> sasl_password ;* dest = ( SERVER_CONNECT_REC * ) rec ;,rec -> sasl_username = g_strdup ( src -> sasl_username ) ;rec -> sasl_password = g_strdup ( src -> sasl_password ) ;* dest = ( SERVER_CONNECT_REC * ) rec ;,635
870,"struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ;if ( cnt == 1 ) return 0 ;env -> insn_aux_data = new_data ;vfree ( old_data ) ;","struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ;int i ;if ( cnt == 1 ) return 0 ;for ( i = off ;i < off + cnt - 1 ;i ++ ) new_data [ i ] . seen = true ;env -> insn_aux_data = new_data ;vfree ( old_data ) ;",636
871,ND_TCHECK ( dp -> ip6f_offlg ) ;if ( ndo -> ndo_vflag ) {,ND_TCHECK ( * dp ) ;if ( ndo -> ndo_vflag ) {,637
872,"
",ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;,638
873,"ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" ,  EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ;","ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ;",638
874,"vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;","memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;",639
875,"assert ( ( occ0 % rowsize ) == 0 ) ;assert ( sp -> decodepfunc != NULL ) ;( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ;occ0 -= rowsize ;","if ( ( occ0 % rowsize ) != 0 ) {if ( ! TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize<S2SV_blank>!=<S2SV_blank>0"" ) ;return 0 ;}assert ( sp -> decodepfunc != NULL ) ;( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ) return 0 ;occ0 -= rowsize ;",640
876,"size_t i , tcount , o , datao ;if ( ! n || ! buf || ! buf_size ) {","size_t i , tcount , o , datao ;long failsafe_size = 0 ;if ( ! n || ! buf || ! buf_size ) {",641
877,++ tcount ;},"+ tcount ;failsafe_size += mnote_canon_entry_count_values ( & n -> entries [ tcount ] ) ;if ( failsafe_size > FAILSAFE_SIZE_MAX ) {exif_mem_free ( ne -> mem , n -> entries [ tcount ] . data ) ;exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Failsafe<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%ld)"" , failsafe_size , FAILSAFE_SIZE_MAX ) ;break ;}++ tcount ;}",641
878,if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,if ( ctx -> terminated || ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,642
879,kfree ( sbi ) ;},if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;kfree ( sbi ) ;},643
880,"if ( param -> testflag & T_REP_BY_SORT )  error = mi_repair_by_sort ( param , info , filename , rep_quick ) ;else  error = mi_repair_parallel ( param , info , filename , rep_quick ) ;state_updated = 1 ;else if ( param -> testflag & T_REP_ANY )  error = mi_repair ( param , info , filename , rep_quick ) ;}","if ( param -> testflag & T_REP_BY_SORT ) error = mi_repair_by_sort ( param , info , filename , rep_quick , FALSE ) ;else error = mi_repair_parallel ( param , info , filename , rep_quick , FALSE ) ;state_updated = 1 ;}else if ( param -> testflag & T_REP_ANY ) error = mi_repair ( param , info , filename , rep_quick , FALSE ) ;",644
881,"error = mi_repair_by_sort ( param , info , filename , 1 ) ;}if ( ! error && param -> testflag & T_SORT_INDEX )  error = mi_sort_index ( param , info , filename ) ;if ( ! error ) share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ;","error = mi_repair_by_sort ( param , info , filename , 1 , FALSE ) ;}if ( ! error && param -> testflag & T_SORT_INDEX ) error = mi_sort_index ( param , info , filename , FALSE ) ;if ( ! error ) share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ;",644
882,int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ;char * ns = malloc ( alloc ) ;unsigned char in ;int strindex = 0 ;unsigned long hex ;CURLcode res ;if ( ! ns ) return NULL ;,char * str = NULL ;size_t inputlen = length ;size_t outputlen ;CURLcode res ;if ( ! ns ) return NULL ;,645
883,"res = Curl_convert_from_network ( handle , & in , 1 ) ;if ( res ) {free ( ns ) ;return NULL ;}string += 2 ;alloc -= 2 ;}ns [ strindex ++ ] = in ;string ++ ;}ns [ strindex ] = 0 ;if ( olen )  * olen = strindex ;return ns ;","res = Curl_convert_from_network ( handle , string , inputlen , & str , & outputlen , FALSE ) ;if ( res ) return NULL ;if ( olen ) * olen = curlx_uztosi ( outputlen ) ;return str ;",645
884,"RAnalOp next_op ;avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;","RAnalOp next_op = {0 };avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;",646
885,"
","iov_iter_advance ( i , copied ) ;",647
886,"if ( unlikely ( copied == 0 ) ) {bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ;iov_iter_advance ( i , copied ) ;pos += copied ;","if ( unlikely ( copied == 0 ) ) {bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ;pos += copied ;",647
887,if ( unlikely ( len == 0 ) ) {,if ( unlikely ( len + ring -> frameoffset == 0 ) ) {,648
888,if ( unlikely ( len > ring -> rx_buffersize ) ) {int cnt = 0 ;,if ( unlikely ( len > ring -> rx_buffersize ) ) {int cnt = 0 ;,648
889,def -> pdu_free_state_ref = usm_free_usmStateReference ;def -> session_setup = usm_session_init ;,def -> pdu_clone = usm_clone ;def -> pdu_free_state_ref = usm_free_usmStateReference ;def -> session_setup = usm_session_init ;,649
890,"show_object ( obj , NULL , name , data ) ;continue ;","show_object ( obj , name , data ) ;continue ;",650
891,"process_blob ( revs , ( struct blob * ) obj , show_object ,  NULL , path , data ) ;continue ;","process_blob ( revs , ( struct blob * ) obj , show_object , NULL , path , data ) ;continue ;",650
892,"return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ;}","return match ( prog -> start , sp , sp , prog -> flags | eflags , sub , 0 ) ;}",651
893,if ( src_end - src < zsize )  return AVERROR_INVALIDDATA ;,if ( src_end - src < zsize + ( sub_type != 2 ) ) return AVERROR_INVALIDDATA ;,652
894,bitbuf = * src ++ ;bits = 8 ;,if ( src >= src_end ) return AVERROR_INVALIDDATA ;bitbuf = * src ++ ;bits = 8 ;,652
895,drop_futex_key_refs ( & q -> key ) ;},},653
896,# ifndef NETSNMP_NO_WRITE_SUPPORT  switch ( action ) {,# if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS switch ( action ) {,654
897,"
",CheckNumberCompactPixels ;,655
898,}continue ;}length ++ ;for ( j = 0 ;j < ( ssize_t ) length ;j ++ ) {switch ( depth )  {case 1 : {CheckNumberPixels ( 8 ) ;* pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ;break ;}case 2 : {CheckNumberPixels ( 4 ) ;* pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ;* pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ;* pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ;* pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ;break ;}case 4 : {CheckNumberPixels ( 2 ) ;* pixels ++ = ( * compact_pixels >> 4 ) & 0xff ;* pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ;break ;}default : {CheckNumberPixels ( 1 ) ;* pixels ++ = ( * compact_pixels ) ;break ;}}CheckNumberCompactPixels ;compact_pixels ++ ;,compact_pixels ++ ;,655
899,"list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head ,  open_list ) {spin_lock_irq ( & slave_active_lock ) ;_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;spin_unlock_irq ( & slave_active_lock ) ;}mutex_unlock ( & register_mutex ) ;","spin_lock_irq ( & slave_active_lock ) ;spin_lock ( & timer -> lock ) ;list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {list_del_init ( & slave -> ack_list ) ;list_del_init ( & slave -> active_list ) ;}spin_unlock ( & timer -> lock ) ;spin_unlock_irq ( & slave_active_lock ) ;mutex_unlock ( & register_mutex ) ;",656
900,"ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ;","ND_TCHECK ( p [ 2 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ;ND_TCHECK ( p [ 3 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ;ND_TCHECK ( p [ 3 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ;",657
901,"const char * arch = info -> arch ;ut16 bits = info -> bits ;if ( info -> cpu && * info -> cpu ) {r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ;}r_core_bin_set_cur ( r , binfile ) ;return true ;","char * arch = info -> arch ;ut16 bits = info -> bits ;if ( cpu && * info -> cpu ) {r_config_set ( r -> config , ""anal.cpu"" , cpu ) ;}r_core_bin_set_cur ( r , binfile ) ;free ( cpu ) ;free ( arch ) ;return true ;",658
902,"static void sas_probe_devices ( struct work_struct * work )  {struct domain_device * dev , * n ;struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ;struct asd_sas_port * port = ev -> port ;clear_bit ( DISCE_PROBE , & port -> disc . pending ) ;","static void sas_probe_devices ( struct asd_sas_port * port ) {struct domain_device * dev , * n ;",659
903,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read )  ps_dec -> u4_bitoffset = ih264d_read_mmco_commands (  ps_dec ) ;,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) {i_temp = ih264d_read_mmco_commands ( ps_dec ) ;if ( i_temp < 0 ) {return ERROR_DBP_MANAGER_T ;}ps_dec -> u4_bitoffset = i_temp ;},660
904,"int pkt_len ;char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int ,   cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) )  return FALSE ;","char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , cap_dst , & wth -> phdr , wth -> frame_buffer , line , err , err_info ) ) return FALSE ;",661
905,"dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) ,   s -> s3 -> rrec . seq_num ) ;}","if ( dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , s -> s3 -> rrec . seq_num ) < 0 ) return - 1 ;}",662
906,int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ;int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ;const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ;if ( newRasterSize > info -> rasterSize || widthOverflow > 0 || heightOverflow > 0 ) {,const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ;if ( newRasterSize == 0 ) {free ( info -> rasterBits ) ;info -> rasterBits = NULL ;info -> rasterSize = newRasterSize ;return ;}const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ;const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ;if ( newRasterSize > info -> rasterSize || widthOverflow > 0 || heightOverflow > 0 ) {,663
907,"if ( ret == 0 ) goto can_read_key ;if ( ret != - EACCES ) goto error ;if ( ! is_key_possessed ( key_ref ) ) {ret = - EACCES ;goto error2 ;}can_read_key :  ret = key_validate ( key ) ;if ( ret == 0 ) {ret = - EOPNOTSUPP ;if ( key -> type -> read ) {down_read ( & key -> sem ) ;ret = key -> type -> read ( key , buffer , buflen ) ;up_read ( & key -> sem ) ;}","if ( ret == 0 ) ret = key -> type -> read ) {down_read ( & key -> sem ) ;ret = key_validate ( key ) ;if ( ret == 0 ) {ret = - EOPNOTSUPP ;if ( key -> type -> read ) {down_read ( & key -> sem ) ;ret = key -> type -> read ( key , buffer , buflen ) ;up_read ( & key -> sem ) ;",664
908,if ( ( conn -> validator == NULL ) ||  cherokee_buffer_is_empty ( & conn -> validator -> user ) )  return ret_error ;,if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ;,665
909,"# define ThrowPICTException ( exception , message ) {}char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;","# define ThrowPICTException ( exception , message ) \\\\\\\\\\char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;",666
910,"( void ) ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;while ( ( c = ReadBlobByte ( image ) ) == 0 ) ;if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;version = ( ssize_t ) ReadBlobByte ( image ) ;if ( version == 2 ) {c = ReadBlobByte ( image ) ;if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;}else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;flags = 0 ;image -> depth = 8 ;image -> columns = ( size_t ) ( frame . right - frame . left ) ;image -> rows = ( size_t ) ( frame . bottom - frame . top ) ;image -> resolution . x = DefaultResolution ;image -> resolution . y = DefaultResolution ;image -> units = UndefinedResolution ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;jpeg = MagickFalse ;for ( code = 0 ;EOFBlob ( image ) == MagickFalse ;) {if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ;if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ;if ( code < 0 ) break ;if ( code == 0 ) continue ;if ( code > 0xa1 ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ;}else {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ;switch ( code ) {case 0x01 : {length = ReadBlobMSBShort ( image ) ;if ( length != 0x000a ) {for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ;image -> columns = ( size_t ) ( frame . right - frame . left ) ;image -> rows = ( size_t ) ( frame . bottom - frame . top ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;break ;}case 0x12 : case 0x13 : case 0x14 : {ssize_t pattern ;size_t height , width ;pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < 8 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;if ( pattern == 2 ) {for ( i = 0 ;i < 5 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ;length = ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = ( size_t ) pixmap . component_size ;image -> resolution . x = 1.0 * pixmap . horizontal_resolution ;image -> resolution . y = 1.0 * pixmap . vertical_resolution ;image -> units = PixelsPerInchResolution ;( void ) ReadBlobMSBLong ( image ) ;flags = ( ssize_t ) ReadBlobMSBShort ( image ) ;length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i <= ( ssize_t ) length ;i ++ ) ( void ) ReadBlobMSBLong ( image ) ;width = ( size_t ) ( frame . bottom - frame . top ) ;height = ( size_t ) ( frame . right - frame . left ) ;if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ;if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ;if ( length == 0 ) length = width ;if ( length < 8 ) {for ( i = 0 ;i < ( ssize_t ) ( length * height ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}else for ( i = 0 ;i < ( ssize_t ) height ;i ++ ) {if ( EOFBlob ( image ) != MagickFalse ) break ;if ( length > 200 ) {for ( j = 0 ;j < ( ssize_t ) ReadBlobMSBShort ( image ) ;j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}else for ( j = 0 ;j < ( ssize_t ) ReadBlobByte ( image ) ;j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}break ;}case 0x1b : {image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;break ;}case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : {length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : {PICTRectangle source , destination ;register unsigned char * p ;size_t j ;ssize_t bytes_per_line ;unsigned char * pixels ;bytes_per_line = 0 ;if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ;else {( void ) ReadBlobMSBShort ( image ) ;( void ) ReadBlobMSBShort ( image ) ;( void ) ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ;if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) {if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;tile_image -> depth = ( size_t ) pixmap . component_size ;tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ;tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ;tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ;tile_image -> units = PixelsPerInchResolution ;if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ;}if ( ( code != 0x9a ) && ( code != 0x9b ) ) {tile_image -> colors = 2 ;if ( ( bytes_per_line & 0x8000 ) != 0 ) {( void ) ReadBlobMSBLong ( image ) ;flags = ( ssize_t ) ReadBlobMSBShort ( image ) ;tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ;}status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ;if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( bytes_per_line & 0x8000 ) != 0 ) {for ( i = 0 ;i < ( ssize_t ) tile_image -> colors ;i ++ ) {j = ReadBlobMSBShort ( image ) % tile_image -> colors ;if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ;tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;}}else {for ( i = 0 ;i < ( ssize_t ) tile_image -> colors ;i ++ ) {tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ;tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ;tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ;}}}if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;( void ) ReadBlobMSBShort ( image ) ;if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) {length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ;else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ;if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ;p = pixels ;for ( y = 0 ;y < ( ssize_t ) tile_image -> rows ;y ++ ) {if ( p > ( pixels + extent + image -> columns ) ) {pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;}q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) tile_image -> columns ;x ++ ) {if ( tile_image -> storage_class == PseudoClass ) {index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ;SetPixelIndex ( tile_image , index , q ) ;SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ;SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ;SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ;}else {if ( pixmap . bits_per_pixel == 16 ) {i = ( ssize_t ) ( * p ++ ) ;j = ( size_t ) ( * p ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ;}else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) {if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ;}else {if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ;}}p ++ ;q += GetPixelChannels ( tile_image ) ;}if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ;if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) {p += ( pixmap . component_count - 1 ) * tile_image -> columns ;if ( p < pixels ) break ;}status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ;if ( status == MagickFalse ) break ;}pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ;tile_image = DestroyImage ( tile_image ) ;break ;}case 0xa1 : {unsigned char * info ;size_t type ;type = ReadBlobMSBShort ( image ) ;length = ReadBlobMSBShort ( image ) ;if ( length == 0 ) break ;( void ) ReadBlobMSBLong ( image ) ;length -= MagickMin ( length , 4 ) ;if ( length == 0 ) break ;info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ;if ( info == ( unsigned char * ) NULL ) break ;count = ReadBlob ( image , length , info ) ;if ( count != ( ssize_t ) length ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ;}switch ( type ) {case 0xe0 : {profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;SetStringInfoDatum ( profile , info ) ;status = SetImageProfile ( image , ""icc"" , profile , exception ) ;profile = DestroyStringInfo ( profile ) ;if ( status == MagickFalse ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case 0x1f2 : {profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;SetStringInfoDatum ( profile , info ) ;status = SetImageProfile ( image , ""iptc"" , profile , exception ) ;if ( status == MagickFalse ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}profile = DestroyStringInfo ( profile ) ;break ;}default : break ;}info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;break ;}default : {if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ;else for ( i = 0 ;i < ( ssize_t ) codes [ code ] . length ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}}}if ( code == 0xc00 ) {for ( i = 0 ;i < 24 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;continue ;}if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ;if ( code == 0x8200 ) {char filename [ MaxTextExtent ] ;FILE * file ;int unique_file ;jpeg = MagickTrue ;read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) {( void ) RelinquishUniqueFileResource ( read_info -> filename ) ;( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ;ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ;}length = ReadBlobMSBLong ( image ) ;if ( length > 154 ) {for ( i = 0 ;i < 6 ;i ++ ) ( void ) ReadBlobMSBLong ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) {( void ) fclose ( file ) ;( void ) RelinquishUniqueFileResource ( read_info -> filename ) ;ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;}for ( i = 0 ;i < 122 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;for ( i = 0 ;i < ( ssize_t ) ( length - 154 ) ;i ++ ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",666
911,"ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;* val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) &   0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ;return 0 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;* val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( jas_longlong , ( ( ( ~ tmp ) & 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( jas_longlong , tmp ) ;return 0 ;",667
912,kfree ( rm -> atomic . op_notifier ) ;return ret ;,rm -> atomic . op_active = 0 ;kfree ( rm -> atomic . op_notifier ) ;return ret ;,668
913,assert ( bi != NULL ) ;si = & bi -> slotinfo [ dev -> slot ] ;,"if ( bi == NULL ) {pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\\return ;}si = & bi -> slotinfo [ dev -> slot ] ;",669
914,"rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\msg -> msg_namelen = 0 ;","rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\",670
915,"if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) )  return - 1 ;","if ( snprintf ( spath , sizeof ( spath ) ) return - 1 ;if ( strstr ( name , "".."" ) || strchr ( name , \'/\' ) , var , iface ) >= sizeof ( spath ) ) return - 1 ;",671
916,for ( s += 9 ;isspace ( * s ) ;if ( * s == \'/\' ) {while ( * t && ! isspace ( * t ) ) t ++ ;free ( font_name ) ;,for ( s += 9 ;isspace ( ( unsigned char ) * s ) ;if ( * s == \'/\' ) {while ( * t && ! isspace ( ( unsigned char ) * t ) ) t ++ ;free ( font_name ) ;,672
917,"mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ;# ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ;","mutt_bcache_del ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) ;# ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ;",673
918,break ;},* objp = NULL ;break ;},674
919,"result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ;if ( result == 0 ) {","result = TEMP_FAILURE_RETRY ( select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ) ;if ( result == 0 ) {",675
920,goto discard ;},consume_skb ( skb ) ;return 0 ;},676
921,assert ( msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES ) ;assert ( barnum >= 0 && barnum <= PCIR_MAX_BAR_0 ) ;,"if ( msgnum > MAX_MSIX_TABLE_ENTRIES ) {pr_err ( ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>entries!\\\return - 1 ;}",677
922,"pci_msix_table_init ( dev , msgnum ) ;pci_populate_msixcap ( & msixcap , msgnum , barnum , tab_size ) ;","if ( pci_msix_table_init ( dev , msgnum ) != 0 ) return - 1 ;pci_populate_msixcap ( & msixcap , msgnum , barnum , tab_size ) ;",677
923,"if ( err ) goto out ;upperdentry = ovl_dentry_upper ( dentry ) ;if ( upperdentry ) {mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;","mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;",678
924,while ( isspace ( * p ) )  p ++ ;,while ( isspace ( ( unsigned char ) * p ) ) p ++ ;,679
925,"if ( ! authctxt -> valid ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;return 0 ;}","
",680
926,"
","if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;}",680
927,"if ( ( b = sshbuf_new ( ) ) == NULL )  fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ;","if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ;",680
928,"static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) {const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ;return data > max ? max : data ;","static int decode_unsigned_max ( struct vpx_read_bit_buffer * rb , int max ) {const int data = vpx_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ;return data > max ? max : data ;",681
929,"for ( i = 0 ;i ++ )  if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ;","if ( strlen ( line ) == 0 ) return - 1 ;for ( i = 0 ;i ++ ) if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ;",682
930,"if ( is == NULL )  goto cleanup ;status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ;cleanup :  X509_NAME_free ( is -> issuer ) ;","if ( is == NULL ) return retval ;status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ;X509_NAME_free ( is -> issuer ) ;",683
931,"
",if ( band -> prec ) {,684
932,Jpeg2000Prec * prec = band -> prec + precno ;av_freep ( & prec -> zerobits ) ;av_freep ( & band -> prec ) ;},Jpeg2000Prec * prec = band -> prec + precno ;av_freep ( & prec -> zerobits ) ;}av_freep ( & band -> prec ) ;},684
933,"if ( xmlPushInput ( ctxt , input ) < 0 )  return ;","if ( xmlPushInput ( ctxt , input ) < 0 ) {xmlFreeInputStream ( input ) ;return ;}",685
934,"
",rcu_read_lock ( ) ;,686
935,"final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;if ( IS_ERR ( dst ) ) {err = PTR_ERR ( dst ) ;dst = NULL ;goto done ;}skb = dccp_make_response ( sk , dst , req ) ;if ( skb != NULL ) {struct dccp_hdr * dh = dccp_hdr ( skb ) ;dh -> dccph_checksum = dccp_v6_csum_finish ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ;fl6 . daddr = ireq -> ir_v6_rmt_addr ;err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;err = net_xmit_eval ( err ) ;","final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ;rcu_read_unlock ( ) ;err = net_xmit_eval ( err ) ;",686
936,static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) {if ( cpi -> oxcf . lossless ) {return ONLY_4X4 ;}else if ( cpi -> common . current_video_frame == 0 ) {return TX_MODE_SELECT ;else {if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) {return ALLOW_32X32 ;}else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) {const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;return cpi -> rd_tx_select_threshes [ frame_type ] [ ALLOW_32X32 ] > cpi -> rd_tx_select_threshes [ frame_type ] [ TX_MODE_SELECT ] ? ALLOW_32X32 : TX_MODE_SELECT ;,"static TX_MODE select_tx_mode ( const VP9_COMP * cpi , MACROBLOCKD * const xd ) {if ( xd -> lossless ) return ONLY_4X4 ;else if ( cpi -> common . frame_type == KEY_FRAME && cpi -> sf . use_nonrd_pick_mode ) return ALLOW_16X16 ;if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) return ALLOW_32X32 ;}else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD || cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return TX_MODE_SELECT ;else return cpi -> rd_tx_select_threshes [ frame_type ] [ ALLOW_32X32 ] > cpi -> rd_tx_select_threshes [ frame_type ] [ TX_MODE_SELECT ] ? ALLOW_32X32 : TX_MODE_SELECT ;",687
937,}}},"
",687
938,void * H264SwDecMalloc ( u32 size )  {return malloc ( size ) ;},"void * H264SwDecMalloc ( u32 size , u32 num ) {if ( size > UINT32_MAX / num ) {return NULL ;}return malloc ( size * num ) ;}",688
939,"else if ( ! im -> gdes [ i ] . strftm && strstr ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) {","else if ( bad_format_print ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) {",689
940,"}rrd_set_error  ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>PRINT<S2SV_blank>in<S2SV_blank>\\\'%s\\\'"" , im -> gdes [ i ] . format ) ;",},689
941,if ( im -> gdes [ i ] . strftm ) {if ( im -> gdes [ vidx ] . vf . never == 1 ) {,if ( bad_format_print ( im -> gdes [ vidx ] . vf . never == 1 ) {,689
942,"if ( bad_format ( im -> gdes [ i ] . format ) ) {rrd_set_error  ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>GPRINT<S2SV_blank>in<S2SV_blank>\\\'%s\\\'"" , im -> gdes [ i ] . format ) ;",if ( bad_format ( im -> gdes [ i ] . format ) ) {,689
943,if ( shdr -> sh_size < 1 ) {return NULL ;,if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return NULL ;,690
944,if ( buf1 -> size < buf2 -> size ) {return 1 ;}else if ( buf1 -> size == buf2 -> size ) {return 0 ;}else {return - 1 ;},return ( int ) ( buf2 -> size - buf1 -> size ) ;,691
945,"# endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn ,  root_storage -> d_storage_uuid ) ) < 0 )  expn = ""Can\\\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ;","# endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn , root_storage ) ) < 0 ) expn = ""Can\\\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ;",692
946,size_t sz = sizeof ( * info ) + size ;if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ;,size_t sz = sizeof ( * info ) + size ;if ( sz < sizeof ( * info ) ) return NULL ;if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ;,693
947,"if ( ! eof ) {memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ;","if ( ! eof && vars -> str . c != vars -> ptr ) {memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ;",694
948,"if ( ! net_eq ( net , & init_net ) )  return - EAFNOSUPPORT ;","if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;",695
949,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;if ( in_atomic ( ) || ! mm ) goto no_context ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;if ( in_atomic ( ) || ! mm ) goto no_context ;",696
950,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , regs , address ) ;",696
951,ctxt -> _eip = ctxt -> src . val ;ctxt -> src . val = old_eip ;case 4 :  ctxt -> _eip = ctxt -> src . val ;break ;,"rc = assign_eip_near ( ctxt , ctxt -> src . val ) ;if ( rc != X86EMUL_CONTINUE ) break ;ctxt -> src . val = old_eip ;case 4 : rc = assign_eip_near ( ctxt , ctxt -> src . val ) ;break ;",697
952,"if ( ! list . name || list . noselect ) return ;imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ;url . path = errstr + 1 ;","if ( ! list . name , true || list . noselect ) return ;imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ;url . path = errstr + 1 ;",698
953,"static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret ,  void * * p , void * end ,  void * dbuf , void * ticket_buf ) {void * dp , * dend ;int dlen ;struct ceph_crypto_key old_key ;void * tp , * tpend ;ceph_decode_need ( p , end , sizeof ( u32 ) + 1 , bad ) ;type = ceph_decode_32 ( p ) ;dout ( ""<S2SV_blank>ticket<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>%s\\\tkt_struct_v = ceph_decode_8 ( p ) ;dlen = ceph_x_decrypt ( secret , p , end , dbuf ,  TEMP_TICKET_BUF_LEN ) ;","static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * * p , void * end ) {void * dbuf = NULL ;void * dp , * dend ;int dlen ;struct ceph_crypto_key old_key ;void * ticket_buf = NULL ;void * tp , * tpend ;ceph_decode_need ( p , end , & dbuf , 0 ) ;dlen = ceph_x_decrypt ( secret , p , end , dbuf , TEMP_TICKET_BUF_LEN ) ;",699
954,"tp = ticket_buf ;if ( is_enc ) {dlen = ceph_x_decrypt ( & old_key , p , end , ticket_buf , TEMP_TICKET_BUF_LEN ) ;}dlen = ceph_decode_32 ( & tp ) ;ceph_decode_need ( p , end , dlen , bad ) ;ceph_decode_copy ( p , ticket_buf , dlen ) ;","if ( is_enc ) {dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 ) ;}tp = ticket_buf ;dlen = ceph_decode_32 ( & tp ) ;ticket_buf = kmalloc ( dlen , GFP_NOFS ) ;if ( ! ticket_buf ) {ret = - ENOMEM ;goto out ;}tp = ticket_buf ;ceph_decode_need ( p , end , dlen , bad ) ;ceph_decode_copy ( p , ticket_buf , dlen ) ;",699
955,out :  return ret ;bad : ret = - EINVAL ;,out : kfree ( ticket_buf ) ;kfree ( dbuf ) ;return ret ;bad : ret = - EINVAL ;,699
956,pairs = palloc ( count * sizeof ( Pairs ) ) ;for ( i = 0 ;,"if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;pairs = palloc ( count * sizeof ( Pairs ) ) ;for ( i = 0 ;",700
957,"rq -> skip_clock_update = 0 ;prev -> sched_class -> put_prev_task ( rq , prev ) ;","prev -> sched_class -> put_prev_task ( rq , prev ) ;",701
958,"n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ;n2s ( p , ticklen ) ;","if ( s -> session -> session_id_length > 0 ) {int i = s -> session_ctx -> session_cache_mode ;SSL_SESSION * new_sess ;if ( i & SSL_SESS_CACHE_CLIENT ) {if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) {if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ;}else {SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ;}}if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) {al = SSL_AD_INTERNAL_ERROR ;SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ;goto f_err ;}SSL_SESSION_free ( s -> session ) ;s -> session = new_sess ;}n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ;n2s ( p , ticklen ) ;",702
959,"
",b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ;,703
960,"r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ;if ( r < 0 ) {","r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ;if ( r < 0 ) {",703
961,"
",errors += test_float_formatting ( ) ;,704
962,if ( errors )  return TEST_ERR_MAJOR_BAD ;,if ( errors ) return TEST_ERR_MAJOR_BAD ;,704
963,"return ( * field_rtrn != NULL ) ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;* field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ;* index_rtrn = NULL ;return true ;case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ;return true ;default : break ;","return ( * elem_rtrn != NULL && * field_rtrn != NULL ) ;case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ;if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ;if ( * field_rtrn == NULL ) return false ;return true ;default : break ;",705
964,if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun )  sas_eh_defer_cmd ( cmd ) ;},if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) sas_eh_finish_cmd ( cmd ) ;},706
965,"REQ ( n , funcdef ) ;name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ;","node * tc ;string type_comment = NULL ;REQ ( n , funcdef ) ;name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ;",707
966,"body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ;if ( ! body ) return NULL ;if ( is_async )   return AsyncFunctionDef ( name , args , body , decorator_seq , returns ,  LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else  return FunctionDef ( name , args , body , decorator_seq , returns ,  LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;","if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) {type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ;if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) {tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ;if ( TYPE ( tc ) == TYPE_COMMENT ) {if ( type_comment != NULL ) {ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ;return NULL ;}type_comment = NEW_TYPE_COMMENT ( tc ) ;if ( ! type_comment ) return NULL ;}}if ( ! type_comment ) return NULL ;name_i += 1 ;}body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ;if ( ! body ) return NULL ;if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;",707
967,int err = 0 ;if ( ! asoc ) return - EINVAL ;,"int err = 0 ;if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL ;if ( ! asoc ) return - EINVAL ;",708
968,"if ( likely ( walk . nbytes == nbytes ) )  {salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ;return blkcipher_walk_done ( desc , & walk , 0 ) ;}","
",709
969,lock_sock ( sk ) ;if ( sk -> sk_state != SS_CONNECTED ) {,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;if ( sk -> sk_state != SS_CONNECTED ) {,710
970,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,711
971,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",711
972,image -> columns = image -> rows = 0 ;image -> colors = 0 ;,image -> columns = image -> rows = 0 ;image -> colors = 0 ;,712
973,if ( BImgBuff )  BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;;break ;,if ( BImgBuff ) ;break ;,712
974,"static int em_loop ( struct x86_emulate_ctxt * ctxt )  {register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ;if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;return X86EMUL_CONTINUE ;}","static int em_loop ( struct x86_emulate_ctxt * ctxt ) {int rc = X86EMUL_CONTINUE ;register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ;if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;return rc ;}",713
975,"freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;if ( ! freq_reg ) return - ENOMEM ;","if ( ! res ) return - EINVAL ;freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;if ( ! freq_reg ) return - ENOMEM ;",714
976,"case SEEK_SET :  if ( position > SIGNED_SIZEOF ( psf -> header ) )  {psf_fseek ( psf , position , whence ) ;return ;};if ( position > psf -> headend )   psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ;psf -> headindex = position ;case SEEK_CUR :  if ( psf -> headindex + position < 0 )  break ;if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) )  {psf_fseek ( psf , position , whence ) ;return ;};if ( psf -> headindex + position <= psf -> headend )  {psf -> headindex += position ;};if ( psf -> headindex + position > SIGNED_SIZEOF ( psf -> header ) )  {psf -> headindex = psf -> headend ;psf_fseek ( psf , position , SEEK_CUR ) ;break ;};psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ;psf -> headindex = psf -> headend ;break ;","case SEEK_SET : if ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ;if ( position > psf -> header . end ) psf -> header . end += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ;psf -> headindex = position ;case SEEK_CUR : if ( psf -> headindex + position < 0 ) break ;if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header . ptr + psf -> header . end , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ;psf -> headindex = psf -> headend ;",715
977,"truncate_pagecache ( inode , ioffset ) ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;goto out_dio ;}","ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;truncate_pagecache ( inode , ioffset ) ;goto out_mmap ;}",716
978,"inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;ext4_mark_inode_dirty ( handle , inode ) ;out_stop : ext4_journal_stop ( handle ) ;out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;",out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;ext4_inode_resume_unlocked_dio ( inode ) ;,716
979,uint32_t track_size ;uint8_t * * tracks ;,uint8_t * * tracks ;uint32_t * track_size ;,717
980,"track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ;if ( midi_size < 8 ) {if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>track<S2SV_blank>header)"" , 0 ) ;midi_data += 4 ;midi_size -= 4 ;track_size = * midi_data ++ << 24 ;track_size |= * midi_data ++ << 16 ;track_size |= * midi_data ++ << 8 ;track_size |= * midi_data ++ ;midi_size -= 4 ;if ( midi_size < track_size ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}if ( track_size < 3 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ;goto _end ;}if ( ( midi_data [ track_size - 3 ] != 0xFF )   || ( midi_data [ track_size - 2 ] != 0x2F )   || ( midi_data [ track_size - 1 ] != 0x00 ) ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ;midi_data += track_size ;midi_size -= track_size ;track_end [ i ] = 0 ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;if ( midi_type == 1 ) {","track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ;if ( midi_size < tmp_val ) {if ( tmp_val < 3 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ;if ( ( midi_data [ track_size - 3 ] != 0xFF ) || ( midi_data [ track_size - 2 ] != 0x2F ) || ( midi_data [ track_size - 1 ] != 0x00 ) ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ;midi_data += track_size ;midi_size -= track_size ;track_end [ i ] = 0 ;track_size [ i ] -- ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;if ( midi_type == 1 ) {",717
981,"setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {","setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {",717
982,goto NEXT_TRACK ;},track_size [ i ] -= 3 ;goto NEXT_TRACK ;},717
983,if ( * tracks [ i ] > 0x7f ) {do {track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;}}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;},"track_size [ i ] -= setup_ret ;if ( * tracks [ i ] > 0x7f ) {do {if ( ! track_size [ i ] ) break ;track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}}if ( ! track_size [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}",717
984,"setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {","setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {",717
985,track_delta [ i ] = 0 ;if ( * tracks [ i ] > 0x7f ) {track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;}}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ;,"track_size [ i ] -= setup_ret ;track_delta [ i ] = 0 ;if ( * tracks [ i ] > 0x7f ) {if ( ! track_size [ i ] ) break ;track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}}if ( ! track_size [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ;",717
986,if ( mdi -> reverb ) return ( mdi ) ;_WM_freeMDI ( mdi ) ;,free ( track_size ) ;if ( mdi -> reverb ) return ( mdi ) ;_WM_freeMDI ( mdi ) ;,717
987,"sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ;sk -> sk_write_space ( sk ) ;","sk -> sk_sndbuf = max_t ( int , val * 2 , SOCK_MIN_SNDBUF ) ;sk -> sk_write_space ( sk ) ;",718
988,"sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ;break ;","sk -> sk_rcvbuf = max_t ( int , val * 2 , SOCK_MIN_RCVBUF ) ;break ;",718
989,"int ret = 0 ;bh = udf_read_tagged ( sb , block , block , & ident ) ;lvd = ( struct logicalVolDesc * ) bh -> b_data ;ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ;i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ;i ++ , offset += gpm -> partitionMapLength ) {","unsigned int table_len ;int ret = 0 ;bh = udf_read_tagged ( sb , block , block , & ident ) ;lvd = ( struct logicalVolDesc * ) bh -> b_data ;table_len = le32_to_cpu ( lvd -> mapTableLength ) ;if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) {udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\\goto out_bh ;}ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ;i < sbi -> s_partitions && offset < table_len ;i ++ , offset += gpm -> partitionMapLength ) {",719
990,"if ( optstr ) {jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\\return 0 ;}","image = 0 ;info = 0 ;if ( optstr ) {jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\\goto error ;}",720
991,"return 0 ;}JAS_DBGLOG ( 1 ,  ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>""  ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>""  ""mincolors<S2SV_blank>%d\\\if ( ! bmp_issupported ( & hdr , info ) ) {bmp_info_destroy ( info ) ;return 0 ;return 0 ;}bmp_info_destroy ( info ) ;return 0 ;","goto error ;}JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\\if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) {jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\\goto error ;}if ( ! bmp_issupported ( & hdr , info ) ) {goto error ;goto error ;}goto error ;",720
992,bmp_info_destroy ( info ) ;return 0 ;,goto error ;,720
993,bmp_info_destroy ( info ) ;jas_image_destroy ( image ) ;return 0 ;}bmp_info_destroy ( info ) ;return image ;,goto error ;}bmp_info_destroy ( info ) ;return image ;error : if ( info ) {bmp_info_destroy ( info ) ;}if ( image ) {jas_image_destroy ( image ) ;}return 0 ;,720
994,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" ,  dev_name ( & qedi -> pdev -> dev ) , nfunc , line ,  qedi -> host_no , & vaf ) ;else  pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",721
995,return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ;},if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) {return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ;}return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ;},722
996,"save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ;if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) {","save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ;problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) {",723
997,"media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ;if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ;","memset ( & pad , 0 , sizeof ( pad ) ) ;media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ;if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ;",724
998,"media_device_kpad_to_upad ( entity -> links [ l ] . source ,  & link . source ) ;","memset ( & link , 0 , sizeof ( link ) ) ;media_device_kpad_to_upad ( entity -> links [ l ] . source , & link . source ) ;",724
999,if ( line -> indent < ctx -> code_indent_offset && pivot_line -> type == MD_LINE_TEXT  && ( CH ( off ) == _T ( \'=\' ) || CH ( off ) == _T ( \'-\' ) )  && ( n_parents == ctx -> n_containers ) ) {,"if ( line -> indent < ctx -> code_indent_offset && pivot_line -> type == MD_LINE_TEXT && off < ctx -> size && ISANYOF2 ( off , _T ( \'=\' ) , _T ( \'-\' ) ) && ( n_parents == ctx -> n_containers ) ) {",725
1000,"if ( line -> indent < ctx -> code_indent_offset && ISANYOF ( off , _T ( ""-_*"" ) ) && off >= hr_killer ) {if ( md_is_hr_line ( ctx , off , & off , & hr_killer ) ) {if ( n_parents < ctx -> n_containers && n_brothers + n_children == 0 ) {","if ( line -> indent < ctx -> code_indent_offset && off < ctx -> size && off >= hr_killer ) {if ( md_is_hr_line ( ctx , off , & off , & hr_killer ) ) {if ( n_parents < ctx -> n_containers && ISANYOF2_ n_brothers + n_children == 0 ) {",725
1001,if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers && ( off >= ctx -> size || ISNEWLINE ( off ) ) && container . ch != _T ( \'>\' ) ) {}else if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers &&  ( container . ch == _T ( \'.\' ) || container . ch == _T ( \')\' ) ) && container . start != 1 )  {,"if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers && ( off >= ctx -> size || ISNEWLINE ( off ) ) && container . ch , _T ( \'.\' ) || container . ch == _T ( \')\' ) ) && container . start != 1 ) {",725
1002,"if ( line -> indent < ctx -> code_indent_offset && CH ( off ) == _T ( \'#\' ) ) {unsigned level ;if ( md_is_atxheader_line ( ctx , off , & line -> beg , & off , & level ) ) {line -> type = MD_LINE_ATXHEADER ;line -> data = level ;break ;}}if ( CH ( off ) == _T ( \'`\' ) || CH ( off ) == _T ( \'~\' ) ) {if ( md_is_opening_code_fence ( ctx , off , & off ) ) {line -> type = MD_LINE_FENCEDCODE ;line -> data = 1 ;break ;}}if ( CH ( off ) == _T ( \'<\' ) && ! ( ctx -> parser . flags & MD_FLAG_NOHTMLBLOCKS ) ) {",if ( line -> indent < ctx -> code_indent_offset && off < ctx -> size && CH ( off ) == _T ( \'<\' ) && ! ( ctx -> parser . flags & MD_FLAG_NOHTMLBLOCKS ) ) {,725
1003,if ( ( ctx -> parser . flags & MD_FLAG_TABLES ) && pivot_line -> type == MD_LINE_TEXT &&   ( CH ( off ) == _T ( \'|\' ) || CH ( off ) == _T ( \'-\' ) || CH ( off ) == _T ( \':\' ) ) &&  n_parents == ctx -> n_containers ) {,if ( ( ctx -> parser . flags & MD_FLAG_TABLES ) && pivot_line -> type == MD_LINE_TEXT && ( CH ( off ) == _T ( \'|\' ) || CH ( off ) == _T ( \'-\' ) || CH ( off ) == _T ( \':\' ) ) && n_parents == ctx -> n_containers ) {,725
1004,"size_t bytes_per_line , extent ,  height ,  length ;","size_t bytes_per_line , extent , height ;",726
1005,"if ( bytes_per_line == 0 )   bytes_per_line = image -> columns ;length = image -> rows * ( image -> columns + image -> columns % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;","
",726
1006,"SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 )  p ++ ;","SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 ) p ++ ;",726
1007,"length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {","
",726
1008,"static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client ,  krb5_principal client_principal ,  hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) {","static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , krb5_principal client_principal , const char * tgt_realm , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) {",727
1009,"# define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) ,  krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ;if ( ret ) goto out ;","# define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , tgt_realm ) ;if ( ret ) goto out ;",727
1010,"if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;","if ( ( MagickSizeType ) image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;",728
1011,"}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ;if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;bmp_info . file_size = ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;bmp_info . offset_bits = ReadBlobLSBLong ( image ) ;bmp_info . size = ReadBlobLSBLong ( image ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ;if ( bmp_info . size == 12 ) {( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ;bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ;bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ;bmp_info . planes = ReadBlobLSBShort ( image ) ;bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ;bmp_info . x_pixels = 0 ;bmp_info . y_pixels = 0 ;bmp_info . number_colors = 0 ;bmp_info . compression = BI_RGB ;bmp_info . image_size = 0 ;bmp_info . alpha_mask = 0 ;if ( image -> debug != MagickFalse ) {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ;}}else {if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ;bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;bmp_info . planes = ReadBlobLSBShort ( image ) ;bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ;bmp_info . compression = ReadBlobLSBLong ( image ) ;bmp_info . image_size = ReadBlobLSBLong ( image ) ;bmp_info . x_pixels = ReadBlobLSBLong ( image ) ;bmp_info . y_pixels = ReadBlobLSBLong ( image ) ;bmp_info . number_colors = ReadBlobLSBLong ( image ) ;if ( bmp_info . number_colors > GetBlobSize ( image ) )  ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;bmp_info . colors_important = ReadBlobLSBLong ( image ) ;if ( image -> debug != MagickFalse ) {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ;switch ( bmp_info . compression ) {case BI_RGB : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ;break ;}case BI_RLE4 : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ;break ;}case BI_RLE8 : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ;break ;}case BI_BITFIELDS : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ;break ;}case BI_PNG : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ;break ;}case BI_JPEG : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ;break ;}default : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ;}}( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ;}bmp_info . red_mask = ReadBlobLSBLong ( image ) ;bmp_info . green_mask = ReadBlobLSBLong ( image ) ;bmp_info . blue_mask = ReadBlobLSBLong ( image ) ;if ( bmp_info . size > 40 ) {double gamma ;bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ;bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ;# define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . red_primary . x *= gamma ;bmp_info . red_primary . y *= gamma ;image -> chromaticity . red_primary . x = bmp_info . red_primary . x ;image -> chromaticity . red_primary . y = bmp_info . red_primary . y ;gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . green_primary . x *= gamma ;bmp_info . green_primary . y *= gamma ;image -> chromaticity . green_primary . x = bmp_info . green_primary . x ;image -> chromaticity . green_primary . y = bmp_info . green_primary . y ;gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . blue_primary . x *= gamma ;bmp_info . blue_primary . y *= gamma ;image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ;image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ;bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ;}else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ;if ( bmp_info . size > 108 ) {size_t intent ;intent = ReadBlobLSBLong ( image ) ;switch ( ( int ) intent ) {case LCS_GM_BUSINESS : {image -> rendering_intent = SaturationIntent ;break ;}case LCS_GM_GRAPHICS : {image -> rendering_intent = RelativeIntent ;break ;}case LCS_GM_IMAGES : {image -> rendering_intent = PerceptualIntent ;break ;}case LCS_GM_ABS_COLORIMETRIC : {image -> rendering_intent = AbsoluteIntent ;break ;}}( void ) ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;}}if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\\\'"" , image -> filename ) ;else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\\\'"" , image -> filename ) ;if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ;if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ;if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ;if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ;if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;switch ( bmp_info . compression ) {case BI_RGB : image -> compression = NoCompression ;break ;case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ;break ;case BI_BITFIELDS : break ;case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ;case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ;default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ;image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ;image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ;image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ;if ( bmp_info . bits_per_pixel < 16 ) {size_t one ;image -> storage_class = PseudoClass ;image -> colors = bmp_info . number_colors ;one = 1 ;if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ;}image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ;image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ;image -> units = PixelsPerCentimeterResolution ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( image -> storage_class == PseudoClass ) {unsigned char * bmp_colormap ;size_t packet_size ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ;if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ;else packet_size = 4 ;offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ;if ( offset < 0 ) {bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ;if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) {bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;}p = bmp_colormap ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) {image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;if ( packet_size == 4 ) p ++ ;}bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;}if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;offset_bits = bmp_info . offset_bits ;offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ;if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ;bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ;length = ( size_t ) bytes_per_line * image -> rows ;if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) {if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ;count = ReadBlob ( image , length , pixels ) ;if ( count != ( ssize_t ) length ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;}}else {pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ;if ( status == MagickFalse ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ;}}if ( bmp_info . compression == BI_RGB ) {if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) {bytes_per_line = 4 * ( image -> columns ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {if ( * ( p + 3 ) != 0 ) {image -> alpha_trait = BlendPixelTrait ;y = - 1 ;break ;}p += 4 ;}}}bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ;bmp_info . red_mask = 0x00ff0000U ;bmp_info . green_mask = 0x0000ff00U ;bmp_info . blue_mask = 0x000000ffU ;if ( bmp_info . bits_per_pixel == 16 ) {bmp_info . red_mask = 0x00007c00U ;bmp_info . green_mask = 0x000003e0U ;bmp_info . blue_mask = 0x0000001fU ;}}( void ) memset ( & shift , 0 , sizeof ( shift ) ) ;( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ;if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) {register unsigned int sample ;if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) {shift . red ++ ;if ( shift . red >= 32U ) break ;}if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) {shift . green ++ ;if ( shift . green >= 32U ) break ;}if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) {shift . blue ++ ;if ( shift . blue >= 32U ) break ;}if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) {shift . alpha ++ ;if ( shift . alpha >= 32U ) break ;}sample = shift . red ;while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ;sample = shift . green ;while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ;sample = shift . blue ;while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ;sample = shift . alpha ;while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ;}switch ( bmp_info . bits_per_pixel ) {case 1 : {for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 7 ) ;x += 8 ) {for ( bit = 0 ;bit < 8 ;bit ++ ) {index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}p ++ ;}if ( ( image -> columns % 8 ) != 0 ) {for ( bit = 0 ;bit < ( image -> columns % 8 ) ;bit ++ ) {index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}p ++ ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 4 : {for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 1 ) ;x += 2 ) {ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;}if ( ( image -> columns % 2 ) != 0 ) {ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;x ++ ;}if ( x < ( ssize_t ) image -> columns ) break ;if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 8 : {if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = ( ssize_t ) image -> columns ;x != 0 ;-- x ) {ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 16 : {unsigned int alpha , pixel ;if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ;image -> storage_class = DirectClass ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {pixel = ( unsigned int ) ( * p ++ ) ;pixel |= ( * p ++ ) << 8 ;red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ;if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ;if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ;green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ;if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ;if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ;if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ;blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ;if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ;if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ;SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ;SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ;SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) {alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ;if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ;SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ;}q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}case 24 : {bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}case 32 : {if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}bytes_per_line = 4 * ( image -> columns ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {unsigned int alpha , pixel ;p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {pixel = ( unsigned int ) ( * p ++ ) ;pixel |= ( ( unsigned int ) * p ++ << 8 ) ;pixel |= ( ( unsigned int ) * p ++ << 16 ) ;pixel |= ( ( unsigned int ) * p ++ << 24 ) ;red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ;if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ;green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ;if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ;blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ;if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ;SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ;SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ;SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) {alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ;if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ;SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ;}q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}default : {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}}pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( y > 0 ) break ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( bmp_info . height < 0 ) {Image * flipped_image ;flipped_image = FlipImage ( image , exception ) ;if ( flipped_image != ( Image * ) NULL ) {DuplicateBlob ( flipped_image , image ) ;ReplaceImageInList ( & image , flipped_image ) ;image = flipped_image ;}}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;* magick = \'\\\\0\' ;if ( bmp_info . ba_offset != 0 )   {offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ;if ( offset < 0 )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}count = ReadBlob ( image , 2 , magick ) ;","offset = ( MagickOffsetType ) bmp_info . ba_offset ;if ( offset != 0 ) {offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ;count = ReadBlob ( image , 2 , magick ) ;",728
1012,newinet -> inet_daddr = ireq -> rmt_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;,newinet -> inet_opt = ireq -> rmt_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;,729
1013,data -> l_head = NULL ;data -> portListing = NULL ;data -> portListingLength = 0 ;,"memset ( data , 0 , sizeof ( struct NameValueParserData ) ) ;",730
1014,"if ( offset != 0 )  csum = csum_sub ( csum ,  csum_partial ( skb_transport_header ( skb ) + tlen ,   offset , 0 ) ) ;put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;","if ( offset != 0 ) {int tend_off = skb_transport_offset ( skb ) + tlen ;csum = csum_sub ( csum , skb_checksum ( skb , tend_off , offset , 0 ) ) ;}put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;",731
1015,"goto unmap_pages ;}unmap_pages :  kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ;return r ;","kvm_unpin_pages ( kvm , pfn , page_size ) ;goto unmap_pages ;}unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ;return r ;",732
1016,"memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ;state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ;","if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ;state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ;",733
1017,"struct perf_event_context * ctx = event -> ctx ;struct task_struct * task = ctx -> task ;if ( ! task ) {cpu_function_call ( event -> cpu , __perf_event_disable , event ) ;return ;retry : if ( ! task_function_call ( task , __perf_event_disable , event ) ) return ;raw_spin_lock_irq ( & ctx -> lock ) ;if ( event -> state == PERF_EVENT_STATE_ACTIVE ) {raw_spin_unlock_irq ( & ctx -> lock ) ;task = ctx -> task ;goto retry ;}if ( event -> state == PERF_EVENT_STATE_INACTIVE ) {update_group_times ( event ) ;event -> state = PERF_EVENT_STATE_OFF ;}",struct perf_event_context * ctx ;ctx = perf_event_ctx_lock ( event ) ;event -> state = PERF_EVENT_STATE_OFF ;,734
1018,value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) |   ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;}value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) |   ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;},value = ( unsigned int ) buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;}value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ;value |= ( unsigned int ) buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;return ( value & 0xffffffff ) ;},735
1019,"struct free_nid * i ;struct nat_entry * ne ;int err ;if ( unlikely ( nid == 0 ) ) return false ;if ( build ) {ne = __lookup_nat_cache ( nm_i , nid ) ;if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) )  return false ;}if ( radix_tree_preload ( GFP_NOFS ) ) {kmem_cache_free ( free_nid_slab , i ) ;return true ;}spin_unlock ( & nm_i -> nid_list_lock ) ;if ( err ) {kmem_cache_free ( free_nid_slab , i ) ;return true ;}return true ;","struct free_nid * i , * e ;struct nat_entry * ne ;int err = - EINVAL ;bool ret = false ;if ( unlikely ( nid == 0 ) ) return false ;if ( radix_tree_preload ( GFP_NOFS ) ) goto err ;if ( build ) {ne = __lookup_nat_cache ( nm_i , nid ) ;if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) goto err_out ;e = __lookup_free_nid_list ( nm_i , nid ) ;if ( e ) {if ( e -> state == NID_NEW ) ret = true ;goto err_out ;}}ret = true ;err_out : spin_unlock ( & nm_i -> nid_list_lock ) ;err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ;return ret ;",736
1020,flags -> post_proc_flag =  # if CONFIG_POSTPROC_VISUALIZER  ( ctx -> dbg_color_ref_frame_flag ? VP9D_DEBUG_CLR_FRM_REF_BLKS : 0 ) | ( ctx -> dbg_color_mb_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_color_b_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_display_mv_flag ? VP9D_DEBUG_DRAW_MV : 0 ) | # endif ctx -> postproc_cfg . post_proc_flag ;# if CONFIG_POSTPROC_VISUALIZER  flags -> display_ref_frame_flag = ctx -> dbg_color_ref_frame_flag ;flags -> display_mb_modes_flag = ctx -> dbg_color_mb_modes_flag ;flags -> display_b_modes_flag = ctx -> dbg_color_b_modes_flag ;flags -> display_mv_flag = ctx -> dbg_display_mv_flag ;# endif },flags -> post_proc_flag = ctx -> postproc_cfg . post_proc_flag ;},737
1021,"netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\\return - EBADR ;netdev_dbg ( vif -> dev ,   ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\\return - EINVAL ;","netdev_err ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\\netbk_fatal_tx_err ( vif ) ;return - EBADR ;netdev_err ( vif -> dev , ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;",738
1022,"
",hdr -> sadb_msg_reserved = 0 ;,739
1023,"pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;","pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;",739
1024,r1 . event = event ;r1 . tstamp = * tstamp ;,"memset ( & r1 , 0 , sizeof ( r1 ) ) ;r1 . event = event ;r1 . tstamp = * tstamp ;",740
1025,"defaultoptions ( & h ) ;lua_settop ( L , 2 ) ;size_t size = optsize ( L , opt , & fmt ) ;pos += gettoalign ( pos , & h , opt , size ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;switch ( opt ) {lua_pushnumber ( L , res ) ;break ;case \'x\' : {case \'f\' : {float f ;memcpy ( & f , data + pos , size ) ;correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ;lua_pushnumber ( L , f ) ;break ;}case \'d\' : {double d ;memcpy ( & d , data + pos , size ) ;correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ;lua_pushnumber ( L , d ) ;break ;}case \'c\' : {if ( size == 0 ) {if ( ! lua_isnumber ( L , - 1 ) )   luaL_error ( L , ""format<S2SV_blank>`c0\\\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ;size = lua_tonumber ( L , - 1 ) ;lua_pop ( L , 1 ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;}lua_pushlstring ( L , data + pos , size ) ;break ;}lua_pushlstring ( L , data + pos , size - 1 ) ;break ;return lua_gettop ( L ) - 2 ;}","int n = 0 ;defaultoptions ( & h ) ;size_t size = optsize ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;switch ( opt ) {lua_pushnumber ( L , ""format<S2SV_blank>\\\'c0\\\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ;size = lua_tonumber ( L , - 1 ) ;n -- ;lua_pop ( L , 1 ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;lua_pushlstring ( L , data + pos , size ) ;n ++ ;lua_pushlstring ( L , data + pos , size - 1 ) ;n ++ ;break ;return n + 1 ;}",741
1026,"if ( length < sizeof ( struct olsr_common ) ) {goto trunc ;}ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ;ptr . common = ( const struct olsr_common * ) tptr ;length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ;ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ;tptr += sizeof ( struct olsr_common ) ;if ( ndo -> ndo_vflag < 1 ) {return ;}while ( tptr < ( pptr + length ) ) {union {const struct olsr_msg4 * v4 ;const struct olsr_msg6 * v6 ;}msgptr ;int msg_len_valid = 0 ;ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;if ( is_ipv6 ) {",if ( length < sizeof ( struct olsr_msg6 ) ) ;,742
1027,else  {msgptr . v4 = ( const struct olsr_msg4 * ) tptr ;,"else {ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;msgptr . v4 = ( const struct olsr_msg4 * ) tptr ;",742
1028,u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;u_int addr_size = 4 ;int name_entries_valid = 0 ;u_int i ;if ( is_ipv6 ) addr_size = 16 ;if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) )  name_entries_valid = 1 ;if ( msg_tlen < 4 ) goto trunc ;,u_int name_entries ;u_int addr_size ;int name_entries_valid ;u_int i ;if ( msg_tlen < 4 ) goto trunc ;name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;addr_size = 4 ;int name_entries_valid = 0 ;if ( is_ipv6 ) addr_size = 16 ;if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) name_entries_valid = 1 ;,742
1029,int n ;if ( ! body -> unit_size )  break ;n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 )  / body -> unit_size ;,unsigned int n ;if ( ! body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 ) ) / body -> unit_size ;,743
1030,"# if HAVE_NEON  int64_t store_reg [ 8 ] ;# if CONFIG_RUNTIME_CPU_DETECT VP8_COMMON * cm = & cpi -> common ;# endif # endif struct vpx_usec_timer timer ;# if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {if ( sd -> y_width != cpi -> oxcf . Width || sd -> y_height != cpi -> oxcf . Height ) {assert ( cpi -> oxcf . lag_in_frames < 2 ) ;dealloc_raw_frame_buffers ( cpi ) ;alloc_raw_frame_buffers ( cpi ) ;}if ( vp8_lookahead_push ( cpi -> lookahead , sd , time_stamp , end_time , frame_flags , cpi -> active_map_enabled ? cpi -> active_map : NULL ) ) res = - 1 ;vpx_usec_timer_mark ( & timer ) ;cpi -> time_receive_data += vpx_usec_timer_elapsed ( & timer ) ;# if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_pop_neon ( store_reg ) ;}# endif return res ;",struct vpx_usec_timer timer ;# if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {return res ;,744
1031,"fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\\exit ( 1 ) ;pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 )  errExit ( ""fchown"" ) ;if ( chmod ( dest , 0600 ) == - 1 ) errExit ( ""fchmod"" ) ;","fprintf ( stderr , ""Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\\return 0 ;copy_file_as_user ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) , 0600 ) ;fs_logger2 ( ""clone"" , dest ) ;",745
1032,idata -> status = IMAP_FATAL ;return ;,"idata -> status = IMAP_FATAL ;return ;}if ( strlen ( idata -> buf ) < litlen ) {mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\\return ;",746
1033,"sas_discover_event ( dev -> port , DISCE_PROBE ) ;return 0 ;",return 0 ;,747
1034,"if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) {EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ;","size_t ext_size = 0 ;if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) {EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ;ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;",748
1035,"ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;","ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;",748
1036,"ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;","ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;",748
1037,"ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;break ;case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ;ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;break ;case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ;ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ;break ;case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ;ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;break ;case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ;default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ;ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;}ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ;memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ;synth_size = 2 * ptr_hbe_txposer -> synth_size ;ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ;memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ;sfb = 0 ;if ( upsamp_4_flag ) {stop_patch = MAX_NUM_PATCHES ;ptr_hbe_txposer -> max_stretch = MAX_STRETCH ;}else {stop_patch = MAX_STRETCH ;}for ( patch = 1 ;patch <= stop_patch ;patch ++ ) {while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ;if ( sfb <= p_num_sfb [ LOW ] ) {if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) {ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ;}else {WORD32 sfb = 0 ;while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ;ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ;else {ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ;ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ;break ;}}}return 0 ;}",ptr_hbe_txposer -> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;}return 0 ;},749
1038,cmap_len = get_ushort ( & tga [ 5 ] ) ;cmap_entry_size = tga [ 7 ] ;# if 0  x_origin = get_ushort ( & tga [ 8 ] ) ;y_origin = get_ushort ( & tga [ 10 ] ) ;# endif  image_w = get_ushort ( & tga [ 12 ] ) ;image_h = get_ushort ( & tga [ 14 ] ) ;pixel_depth = tga [ 16 ] ;,cmap_len = get_tga_ushort ( & tga [ 5 ] ) ;cmap_entry_size = tga [ 7 ] ;# if 0 x_origin = get_tga_ushort ( & tga [ 8 ] ) ;y_origin = get_tga_ushort ( & tga [ 10 ] ) ;# endif image_w = get_tga_ushort ( & tga [ 12 ] ) ;image_h = get_tga_ushort ( & tga [ 14 ] ) ;pixel_depth = tga [ 16 ] ;,750
1039,ssize_t ret ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,ssize_t ret ;if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,751
1040,"if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) {tp -> tv_sec = div_long_long_rem ( cpu . sched ,  NSEC_PER_SEC , & tp -> tv_nsec ) ;else {cputime_to_timespec ( cpu . cpu , tp ) ;}}","if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) * tp = ns_to_timespec ( cpu . sched , NSEC_PER_SEC , & tp -> tv_nsec ) ;",752
1041,uint32 nstrips ;if ( td -> td_nstrips ) return td -> td_nstrips ;,uint32 nstrips ;,753
1042,"rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\msg -> msg_namelen = 0 ;","rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\",754
1043,"const lua_authz_provider_spec * prov_spec = parsed_require_line ;int result ;if ( L == NULL ) {ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02314 ) ""Unable<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>VM<S2SV_blank>for<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s"" , prov_spec -> name ) ;return AUTHZ_GENERAL_ERROR ;}lua_getglobal ( L , prov_spec -> function_name ) ;if ( ! lua_isfunction ( L , - 1 ) ) {ap_log_rerror ( APLOG_MARK , APLOG_CRIT , 0 , r , APLOGNO ( 02319 ) ""Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>entry<S2SV_blank>function<S2SV_blank>\\\'%s\\\'<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>function)"" , prov_spec -> function_name , prov_spec -> file_name ) ;ap_lua_release_state ( L , spec , r ) ;return AUTHZ_GENERAL_ERROR ;}ap_lua_run_lua_request ( L , r ) ;if ( prov_spec -> args ) {int i ;if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) {ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02315 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>arguments"" , prov_spec -> name ) ;for ( i = 0 ;const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ;lua_pushstring ( L , arg ) ;nargs = prov_spec -> args -> nelts ;}","const lua_authz_provider_func * prov_func = parsed_require_line ;const lua_authz_provider_spec * prov_spec = prov_func -> spec ;int result ;if ( prov_func -> args ) {int i ;if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) {ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02315 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>arguments"" , prov_spec -> name ) ;for ( i = 0 ;const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ;lua_pushstring ( L , arg ) ;}nargs = prov_spec -> args -> nelts ;",755
1044,int error ;address &= PAGE_MASK ;error = security_mmap_addr ( address ) ;if ( error ) return error ;,int error = 0 ;address &= PAGE_MASK ;if ( address < mmap_min_addr ) return - EPERM ;,756
1045,"umode_t mode = inode -> i_mode ;error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error <= 0 ) {acl = NULL ;if ( error < 0 ) return error ;}error = xfs_set_mode ( inode , mode ) ;","umode_t mode ;error = posix_acl_equiv_mode ( acl , & mode , & acl ) ;if ( error ) return error ;}error = xfs_set_mode ( inode , mode ) ;",757
1046,"static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags ,  const char * data , int optional )  {# endif  if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) {if ( optional ) {","static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , const char * data , int optional , const char * rootfs ) {# endif if ( safe_mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data , rootfs ) ) {if ( optional ) {",758
1047,"# endif if ( mount ( fsname , target , fstype ,  mountflags | MS_REMOUNT , data ) ) {if ( optional ) {","# endif if ( mount ( fsname , target , fstype , mountflags | MS_REMOUNT , data ) < 0 ) {if ( optional ) {",758
1048,return ( GetFirstImageInList ( image ) ) ;},"return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",759
1049,timr -> it_overrun = - 1 ;++ timr -> it_requeue_pending ;info -> si_overrun += timr -> it_overrun_last ;},"+ timr -> it_requeue_pending ;timr -> it_overrun = - 1LL ;++ timr -> it_requeue_pending ;info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) ;}",760
1050,if ( ! proto_end )  return 0 ;,"if ( ! proto_end ) {if ( ! quiet ) warning ( _ ( ""url<S2SV_blank>has<S2SV_blank>no<S2SV_blank>scheme:<S2SV_blank>%s"" ) , url ) ;return - 1 ;}",761
1051,"bool __net_get_random_once ( void * buf , int nbytes , bool * done ,  struct static_key * done_key )  {","bool __net_get_random_once ( void * buf , int nbytes , bool * done , struct static_key * once_key ) {",762
1052,__net_random_once_disable_jump ( done_key ) ;return true ;,__net_random_once_disable_jump ( once_key ) ;return true ;,762
1053,"if ( io_data -> read && ret > 0 ) {use_mm ( io_data -> mm ) ;ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ;if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ;unuse_mm ( io_data -> mm ) ;}io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ;if ( io_data -> ffs -> ffs_eventfd &&  ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) )  eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ;usb_ep_free_request ( io_data -> ep , io_data -> req ) ;io_data -> kiocb -> private = NULL ;","bool kiocb_has_eventfd = io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ;if ( io_data -> ffs -> ffs_eventfd && ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ;usb_ep_free_request ( io_data -> ep , io_data -> req ) ;io_data -> kiocb -> private = NULL ;",763
1054,"if ( skb -> pkt_type != PACKET_HOST ) goto drop ;if ( skb_warn_if_lro ( skb ) ) goto drop ;if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_FWD , skb ) ) goto drop ;if ( IPCB ( skb ) -> opt . router_alert && ip_call_ra_chain ( skb ) ) return NET_RX_SUCCESS ;skb_forward_csum ( skb ) ;if ( ip_hdr ( skb ) -> ttl <= 1 ) goto too_many_hops ;if ( ! xfrm4_route_forward ( skb ) ) goto drop ;rt = skb_rtable ( skb ) ;if ( opt -> is_strictroute && rt -> rt_uses_gateway ) goto sr_failed ;IPCB ( skb ) -> flags |= IPSKB_FORWARDED ;mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ;if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) {IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ;icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , htonl ( mtu ) ) ;goto drop ;}if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) goto drop ;iph = ip_hdr ( skb ) ;ip_decrease_ttl ( iph ) ;if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) )  ip_rt_send_redirect ( skb ) ;",if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) ip_rt_send_redirect ( skb ) ;,764
1055,passert ( GLOBALS_ARE_RESET ( ) ) ;},},765
1056,struct trusted_key_payload * p = key -> payload . data [ 0 ] ;struct trusted_key_payload * new_p ;struct trusted_key_options * new_o ;,"struct trusted_key_payload * p ;struct trusted_key_payload * new_p ;struct trusted_key_options * new_o ;if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ;p = key -> payload . data [ 0 ] ;",766
1057,v |= ( c << 24 ) ;if ( -- n <= 0 ) {,"v |= ( JAS_CAST ( uint_fast32_t , c ) << 24 ) ;if ( -- n <= 0 ) {",767
1058,while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) {lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ;dest = ( rose_address * ) ( skb -> data + 4 ) ;lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ;,while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) {if ( skb -> len < ROSE_MIN_LEN ) {kfree_skb ( skb ) ;continue ;}lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ;if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) {kfree_skb ( skb ) ;continue ;}dest = ( rose_address * ) ( skb -> data + ROSE_CALL_REQ_DEST_ADDR_OFF ) ;lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ;,768
1059,if ( ! npages && ! old . npages ) goto out_free ;,"if ( npages ) {r = kvm_iommu_map_pages ( kvm , & new ) ;if ( r ) goto out_slots ;}",769
1060,"kvm_arch_flush_shadow_memslot ( kvm , slot ) ;kfree ( old_memslots ) ;if ( r )  goto out_free ;if ( npages ) {","kvm_iommu_unmap_pages ( kvm , & old ) ;kvm_arch_flush_shadow_memslot ( kvm , slot ) ;kfree ( old_memslots ) ;if ( r ) goto out_free ;if ( npages ) {",769
1061,if ( ! npages ) {new . dirty_bitmap = NULL ;,if ( ! npages ) {new . dirty_bitmap = NULL ;,769
1062,"out_free :  kvm_free_physmem_slot ( & new , & old ) ;","out_slots : kfree ( slots ) ;out_free : kvm_free_physmem_slot ( & new , & old ) ;",769
1063,if ( indev != NULL ) {ifa = indev -> ifa_list ;,if ( indev && indev -> ifa_list ) {ifa = indev -> ifa_list ;,770
1064,end = path ;* end = '\\\\0' ;,bool expect_end = false ;end = path ;* end = '\\\\0' ;,771
1065,switch ( tag ) {case FDT_PROP : include = want >= 2 ;,if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ;switch ( tag ) {case FDT_PROP : include = want >= 2 ;,771
1066,"name = fdt_get_name ( fdt , offset , & len ) ;if ( end - path + 2 + len >= path_len ) return - FDT_ERR_NOSPACE ;","name = fdt_get_name ( fdt , offset , & len ) ;if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT ;if ( end - path + 2 + len >= path_len ) return - FDT_ERR_NOSPACE ;",771
1067,break ;case FDT_END : include = 1 ;,if ( depth == - 1 ) expect_end = true ;break ;case FDT_END : include = 1 ;,771
1068,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ;",772
1069,"if ( p7 -> d . ptr == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ;return NULL ;}i = OBJ_obj2nid ( p7 -> type ) ;p7 -> state = PKCS7_S_HEADER ;switch ( i ) {case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ;if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ;goto err ;}md_sk = p7 -> d . sign -> md_algs ;break ;case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ;md_sk = p7 -> d . signed_and_enveloped -> md_algs ;data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ;enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ;evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ;if ( evp_cipher == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ;goto err ;}break ;case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ;enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ;data_body = p7 -> d . enveloped -> enc_data -> enc_data ;evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ;if ( evp_cipher == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ;goto err ;}break ;default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ;goto err ;}if ( md_sk != NULL ) {for ( i = 0 ;i < sk_X509_ALGOR_num ( md_sk ) ;i ++ ) {xa = sk_X509_ALGOR_value ( md_sk , i ) ;if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ;goto err ;}j = OBJ_obj2nid ( xa -> algorithm ) ;evp_md = EVP_get_digestbynid ( j ) ;if ( evp_md == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ;goto err ;}BIO_set_md ( btmp , evp_md ) ;if ( out == NULL ) out = btmp ;else BIO_push ( out , btmp ) ;btmp = NULL ;}}if ( evp_cipher != NULL ) {if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ;goto err ;}if ( pcert ) {for ( i = 0 ;i < sk_PKCS7_RECIP_INFO_num ( rsk ) ;i ++ ) {ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ;if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ;ri = NULL ;}if ( ri == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ;goto err ;}}if ( pcert == NULL ) {for ( i = 0 ;i < sk_PKCS7_RECIP_INFO_num ( rsk ) ;i ++ ) {ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ;if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ;ERR_clear_error ( ) ;}}else {if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ;ERR_clear_error ( ) ;}evp_ctx = NULL ;BIO_get_cipher_ctx ( etmp , & evp_ctx ) ;if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ;if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ;tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ;tkey = OPENSSL_malloc ( tkeylen ) ;if ( ! tkey ) goto err ;if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ;if ( ek == NULL ) {ek = tkey ;eklen = tkeylen ;tkey = NULL ;}if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) {if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) {OPENSSL_clear_free ( ek , eklen ) ;ek = tkey ;eklen = tkeylen ;tkey = NULL ;}}ERR_clear_error ( ) ;if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ;OPENSSL_clear_free ( ek , eklen ) ;ek = NULL ;OPENSSL_clear_free ( tkey , tkeylen ) ;tkey = NULL ;if ( out == NULL ) out = etmp ;else BIO_push ( out , etmp ) ;etmp = NULL ;}if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) {bio = in_bio ;",if ( in_bio != NULL ) ) {bio = in_bio ;,773
1070,"if ( server . shutdown_asap ) {if ( prepareForShutdown ( ) == REDIS_OK ) exit ( 0 ) ;redisLog ( REDIS_WARNING , ""SIGTERM<S2SV_blank>received<S2SV_blank>but<S2SV_blank>errors<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>shut<S2SV_blank>down<S2SV_blank>the<S2SV_blank>server,<S2SV_blank>check<S2SV_blank>the<S2SV_blank>logs<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information"" ) ;}for ( j = 0 ;j < server . dbnum ;j ++ ) {long long size , used , vkeys ;size = dictSlots ( server . db [ j ] . dict ) ;used = dictSize ( server . db [ j ] . dict ) ;vkeys = dictSize ( server . db [ j ] . expires ) ;if ( ! ( loops % 50 ) && ( used || vkeys ) ) {redisLog ( REDIS_VERBOSE , ""DB<S2SV_blank>%d:<S2SV_blank>%lld<S2SV_blank>keys<S2SV_blank>(%lld<S2SV_blank>volatile)<S2SV_blank>in<S2SV_blank>%lld<S2SV_blank>slots<S2SV_blank>HT."" , j , used , vkeys , size ) ;}}if ( server . bgsavechildpid == - 1 && server . bgrewritechildpid == - 1 ) {if ( ! ( loops % 10 ) ) tryResizeHashTables ( ) ;if ( server . activerehashing ) incrementallyRehash ( ) ;}if ( ! ( loops % 50 ) ) {redisLog ( REDIS_VERBOSE , ""%d<S2SV_blank>clients<S2SV_blank>connected<S2SV_blank>(%d<S2SV_blank>slaves),<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>use"" , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , zmalloc_used_memory ( ) ) ;}if ( ( server . maxidletime && ! ( loops % 100 ) ) || server . bpop_blocked_clients ) closeTimedoutClients ( ) ;if ( server . bgsavechildpid != - 1 || server . bgrewritechildpid != - 1 ) {int statloc ;pid_t pid ;if ( ( pid = wait3 ( & statloc , WNOHANG , NULL ) ) != 0 ) {if ( pid == server . bgsavechildpid ) {backgroundSaveDoneHandler ( statloc ) ;}else {backgroundRewriteDoneHandler ( statloc ) ;}updateDictResizePolicy ( ) ;}}else {time_t now = time ( NULL ) ;for ( j = 0 ;j < server . saveparamslen ;j ++ ) {struct saveparam * sp = server . saveparams + j ;if ( server . dirty >= sp -> changes && now - server . lastsave > sp -> seconds ) {redisLog ( REDIS_NOTICE , ""%d<S2SV_blank>changes<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>seconds.<S2SV_blank>Saving..."" , sp -> changes , sp -> seconds ) ;rdbSaveBackground ( server . dbfilename ) ;break ;}}}if ( server . masterhost == NULL ) activeExpireCycle ( ) ;if ( vmCanSwapOut ( ) ) {while ( server . vm_enabled && zmalloc_used_memory ( ) >   server . vm_max_memory )  {",while ( server . vm_enabled && zmalloc_used_memory ( ) > server . vm_max_memory ) {,774
1071,"
","if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) {SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ;}",775
1072,"if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) {uv__write_int ( error_fd , - errno ) ;","if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) {uv__write_int ( error_fd , - errno ) ;",775
1073,"int ret , wo ;if ( 1 + wlen > MAX_XFER_SIZE ) {wo = ( rbuf == NULL || rlen == 0 ) ;mutex_lock ( & d -> data_mutex ) ;if ( wo )  ret = dvb_usb_generic_write ( d , st -> data , 1 + wlen ) ;else ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen ,  rbuf , rlen , 0 ) ;mutex_unlock ( & d -> data_mutex ) ;","int ret ;if ( 1 + wlen > MAX_XFER_SIZE ) {if ( rlen > MAX_XFER_SIZE ) {warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\\return - EOPNOTSUPP ;}mutex_lock ( & d -> data_mutex ) ;ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen , rbuf , rlen , 0 ) ;if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen ) ;mutex_unlock ( & d -> data_mutex ) ;",776
1074,"client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 ,  ( GSourceFunc ) _client_protocol_timeout , client ) ;","
",777
1075,for ( j = 0 ;j < book -> dim ;j ++ )  a [ i ++ ] += v [ j ] ;,for ( j = 0 ;j < book -> dim && i < n ;j ++ ) a [ i ++ ] += v [ j ] ;,778
1076,"void BezierCircle ( double r , char * action )  {outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\\}","void BezierCircle ( double r , char * action ) {char * outpos = outputbuffer ;outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\\sendClean ( outputbuffer ) ;}",779
1077,BUG_ON ( ret == - EEXIST ) ;if ( ret ) {,BUG_ON ( ret == - EEXIST || ret == - EOVERFLOW ) ;if ( ret ) {,780
1078,if ( s ) {struct unix_sock * u = unix_sk ( s ) ;spin_lock ( & unix_gc_lock ) ;spin_unlock ( & unix_gc_lock ) ;}},spin_lock ( & unix_gc_lock ) ;if ( s ) {struct unix_sock * u = unix_sk ( s ) ;}fp -> f_cred -> user -> unix_inflight -- ;spin_unlock ( & unix_gc_lock ) ;},781
1079,if ( map_info -> channel_map != NULL )  {size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ;free ( psf -> channel_map ) ;,"if ( map_info -> channel_map != NULL ) {size_t chanmap_size = SF_MIN ( psf -> sf . channels , layout_tag & 0xffff ) * sizeof ( psf -> channel_map [ 0 ] ) ;free ( psf -> channel_map ) ;",782
1080,"if ( ! check_scale_factors ( other_w , other_h , this_w , this_h ) ) {sf -> x_scale_fp = REF_INVALID_SCALE ;","# endif if ( ! valid_ref_frame_size ( other_w , other_h , this_w , this_h ) ) {sf -> x_scale_fp = REF_INVALID_SCALE ;",783
1081,sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve_copy ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve_avg ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_vert ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_vert ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 1 ] [ 1 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 1 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ;,sf -> predict [ 0 ] [ 0 ] [ 0 ] = vpx_convolve_copy ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vpx_scaled_vert ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ;}}if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) {sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ;}else {sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ;sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ;}# if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) {if ( sf -> x_step_q4 == 16 ) {if ( sf -> y_step_q4 == 16 ) {sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ;sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ;sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ;sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ;sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ;sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ;}else {sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ;sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ;sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ;sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ;sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ;}}else {if ( sf -> y_step_q4 == 16 ) {sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ;sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ;sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ;sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ;sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ;sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ;sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ;sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ;sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ;# endif },783
1082,int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ;if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ;,uint32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ;if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ;,784
1083,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;",785
1084,"if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 &&  unconditional ( & e -> ipv6 ) ) || visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",786
1085,"pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ;ver = 1 ;",pdf -> xrefs = safe_calloc ( sizeof ( xref_t ) * pdf -> n_xrefs ) ;ver = 1 ;,787
1086,if ( ! sock || ( count && ! buf ) )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! sock || ( count && ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,788
1087,"skb = xchg ( & np -> pktoptions , NULL ) ;opt = xchg ( & np -> opt , NULL ) ;if ( opt )   sock_kfree_s ( sk , opt , opt -> tot_len ) ;}","skb = xchg ( ( __force struct ipv6_txoptions * * ) & np -> pktoptions , NULL ) ;opt = xchg ( & np -> opt , NULL ) ;if ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}}",789
1088,"BIO * cmsbio = NULL , * tmpin = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;","BIO * cmsbio = NULL , * tmpin = NULL , * tmpout = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;",790
1089,"cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) )  goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {","if ( ! ( flags & SMIME_BINARY ) && dcont ) {tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ;goto err ;}cmsbio = CMS_dataInit ( cms , tmpout ) ;if ( ! cmsbio ) goto err ;}SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ;if ( flags & CMS_TEXT ) {if ( ! SMIME_text ( tmpout , out ) ) {CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ;goto err ;}}}else {cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) ) goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {",790
1090,"err :  if ( dcont && ( tmpin == dcont ) )  do_free_upto ( cmsbio , dcont ) ;if ( cms_certs )  sk_X509_pop_free ( cms_certs , X509_free ) ;","err : if ( ! ( flags & SMIME_BINARY ) && dcont ) {do_free_upto ( cmsbio , tmpout ) ;if ( tmpin != dcont ) BIO_free ( tmpin ) ;}else {if ( dcont && ( tmpin == dcont ) ) do_free_upto ( cmsbio , dcont ) ;}if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;if ( cms_certs ) sk_X509_pop_free ( cms_certs , X509_free ) ;",790
1091,"if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ;if ( get_user ( len , optlen ) ) return - EFAULT ;switch ( optname ) {case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ;if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ;val = sk -> sk_family ;break ;case MCAST_MSFILTER : {struct group_filter gsf ;int err ;if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ;if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ;if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ;lock_sock ( sk ) ;err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ;release_sock ( sk ) ;return err ;}case IPV6_2292PKTOPTIONS : {struct msghdr msg ;struct sk_buff * skb ;if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ;msg . msg_control = optval ;msg . msg_controllen = len ;msg . msg_flags = flags ;lock_sock ( sk ) ;skb = np -> pktoptions ;if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ;release_sock ( sk ) ;if ( ! skb ) {if ( np -> rxopt . bits . rxinfo ) {struct in6_pktinfo src_info ;src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ;src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ;put_cmsg ( & msg , SOL_IPV6 , IPV6_PKTINFO , sizeof ( src_info ) , & src_info ) ;}if ( np -> rxopt . bits . rxhlim ) {int hlim = np -> mcast_hops ;put_cmsg ( & msg , SOL_IPV6 , IPV6_HOPLIMIT , sizeof ( hlim ) , & hlim ) ;}if ( np -> rxopt . bits . rxtclass ) {int tclass = ( int ) ip6_tclass ( np -> rcv_flowinfo ) ;put_cmsg ( & msg , SOL_IPV6 , IPV6_TCLASS , sizeof ( tclass ) , & tclass ) ;}if ( np -> rxopt . bits . rxoinfo ) {struct in6_pktinfo src_info ;src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ;src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ;put_cmsg ( & msg , SOL_IPV6 , IPV6_2292PKTINFO , sizeof ( src_info ) , & src_info ) ;}if ( np -> rxopt . bits . rxohlim ) {int hlim = np -> mcast_hops ;put_cmsg ( & msg , SOL_IPV6 , IPV6_2292HOPLIMIT , sizeof ( hlim ) , & hlim ) ;}if ( np -> rxopt . bits . rxflow ) {__be32 flowinfo = np -> rcv_flowinfo ;put_cmsg ( & msg , SOL_IPV6 , IPV6_FLOWINFO , sizeof ( flowinfo ) , & flowinfo ) ;}}len -= msg . msg_controllen ;return put_user ( len , optlen ) ;}case IPV6_MTU : {struct dst_entry * dst ;val = 0 ;rcu_read_lock ( ) ;dst = __sk_dst_get ( sk ) ;if ( dst ) val = dst_mtu ( dst ) ;rcu_read_unlock ( ) ;if ( ! val ) return - ENOTCONN ;break ;}case IPV6_V6ONLY : val = sk -> sk_ipv6only ;break ;case IPV6_RECVPKTINFO : val = np -> rxopt . bits . rxinfo ;break ;case IPV6_2292PKTINFO : val = np -> rxopt . bits . rxoinfo ;break ;case IPV6_RECVHOPLIMIT : val = np -> rxopt . bits . rxhlim ;break ;case IPV6_2292HOPLIMIT : val = np -> rxopt . bits . rxohlim ;break ;case IPV6_RECVRTHDR : val = np -> rxopt . bits . srcrt ;break ;case IPV6_2292RTHDR : val = np -> rxopt . bits . osrcrt ;break ;case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : {lock_sock ( sk ) ;len = ipv6_getsockopt_sticky ( sk , np -> opt ,  optname , optval , len ) ;","if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , opt , optname , optval , len ) ;",791
1092,unregister_pernet_subsys ( & sctp_net_ops ) ;sctp_v6_protosw_exit ( ) ;sctp_v4_protosw_exit ( ) ;sctp_v6_pf_exit ( ) ;,unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ;sctp_v6_protosw_exit ( ) ;sctp_v4_protosw_exit ( ) ;unregister_pernet_subsys ( & sctp_defaults_ops ) ;sctp_v6_pf_exit ( ) ;,792
1093,},"add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ;hook_add_event ( ""nick_can_register"" ) ;hook_add_nick_can_register ( check_registration_keywords ) ;hook_add_event ( ""user_can_register"" ) ;hook_add_user_can_register ( check_registration_keywords ) ;}",793
1094,"struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ;struct netdev_notifier_info info ;netdev_notifier_info_init ( & info , dev ) ;return masq_device_event ( this , event , & info ) ;","struct in_device * idev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev ;struct netdev_notifier_info info ;if ( idev -> dead ) return NOTIFY_DONE ;netdev_notifier_info_init ( & info , idev -> dev ) ;return masq_device_event ( this , event , & info ) ;",794
1095,if ( current -> active_mm != mm )   goto out ;if ( ! current -> mm ) {goto out ;},if ( current -> active_mm != mm ) {smp_mb ( ) ;goto out ;}if ( ! current -> mm ) {smp_mb ( ) ;goto out ;},795
1096,"static void show_psnr ( struct stream_state * stream ) {int i ;ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 ,  ( double ) stream -> psnr_sse_total ) ;","static void show_psnr ( struct stream_state * stream , double peak ) {int i ;ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , peak , ( double ) stream -> psnr_sse_total ) ;",796
1097,char temp [ 500 ] ;int i = 0 ;,int temp_size = 500 ;char * temp = malloc ( temp_size ) ;int i = 0 ;,797
1098,temp [ i ] = fgetc ( fp ) ;if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == \'\\\\0\' || temp [ i ] == EOF ) ) {,"if ( i >= temp_size ) {temp_size *= 2 ;temp = realloc ( temp , temp_size ) ;}temp [ i ] = fgetc ( fp ) ;if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == \'\\\\0\' || temp [ i ] == EOF ) ) {",797
1099,if ( ! del_timer ( & task -> slow_task -> timer ) )  return ;,del_timer ( & task -> slow_task -> timer ) ;,798
1100,"dst_name = malloc ( strlen ( name ) * 2 + 16 ) ;sprintf ( dst_name , ""%s/%s"" , name , name ) ;","dst_name = safe_calloc ( strlen ( name ) * 2 + 16 ) ;sprintf ( dst_name , ""%s/%s"" , name , name ) ;",799
1101,"log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>chassis"" ) ;return - 1 ;}TAILQ_INIT ( & chassis -> c_mgmt ) ;if ( ( port = calloc ( 1 , sizeof ( struct lldpd_port ) ) ) == NULL ) {log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>port"" ) ;free ( chassis ) ;return - 1 ;}# ifdef ENABLE_DOT1 TAILQ_INIT ( & port -> p_vlans ) ;TAILQ_INIT ( & port -> p_ppvids ) ;TAILQ_INIT ( & port -> p_pids ) ;# endif # ifdef ENABLE_CUSTOM TAILQ_INIT ( & port -> p_custom_list ) ;# endif length = s ;pos = ( u_int8_t * ) frame ;if ( length < 2 * ETHER_ADDR_LEN + sizeof ( u_int16_t ) ) {log_warnx ( ""lldp"" , ""too<S2SV_blank>short<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( PEEK_CMP ( lldpaddr , ETHER_ADDR_LEN ) != 0 ) {log_info ( ""lldp"" , ""frame<S2SV_blank>not<S2SV_blank>targeted<S2SV_blank>at<S2SV_blank>LLDP<S2SV_blank>multicast<S2SV_blank>address<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_DISCARD ( ETHER_ADDR_LEN ) ;if ( PEEK_UINT16 != ETHERTYPE_LLDP ) {log_info ( ""lldp"" , ""non<S2SV_blank>LLDP<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}while ( length && ( ! gotend ) ) {if ( length < 2 ) {log_warnx ( ""lldp"" , ""tlv<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}tlv_size = PEEK_UINT16 ;tlv_type = tlv_size >> 9 ;tlv_size = tlv_size & 0x1ff ;( void ) PEEK_SAVE ( tlv ) ;if ( length < tlv_size ) {log_warnx ( ""lldp"" , ""frame<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}switch ( tlv_type ) {case LLDP_TLV_END : if ( tlv_size != 0 ) {log_warnx ( ""lldp"" , ""lldp<S2SV_blank>end<S2SV_blank>received<S2SV_blank>with<S2SV_blank>size<S2SV_blank>not<S2SV_blank>null<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( length ) log_debug ( ""lldp"" , ""extra<S2SV_blank>data<S2SV_blank>after<S2SV_blank>lldp<S2SV_blank>end<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;gotend = 1 ;break ;case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 2 , ""Port<S2SV_blank>Id"" ) ;tlv_subtype = PEEK_UINT8 ;if ( ( tlv_subtype == 0 ) || ( tlv_subtype > 7 ) ) {log_warnx ( ""lldp"" , ""unknown<S2SV_blank>subtype<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>id<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size - 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>id<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size - 1 ) ;if ( tlv_type == LLDP_TLV_PORT_ID ) {port -> p_id_subtype = tlv_subtype ;port -> p_id = b ;port -> p_id_len = tlv_size - 1 ;}else {chassis -> c_id_subtype = tlv_subtype ;chassis -> c_id = b ;chassis -> c_id_len = tlv_size - 1 ;}break ;case LLDP_TLV_TTL : CHECK_TLV_SIZE ( 2 , ""TTL"" ) ;chassis -> c_ttl = PEEK_UINT16 ;ttl_received = 1 ;break ;case LLDP_TLV_PORT_DESCR : case LLDP_TLV_SYSTEM_NAME : case LLDP_TLV_SYSTEM_DESCR : if ( tlv_size < 1 ) {log_debug ( ""lldp"" , ""empty<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;break ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size + 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>string<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size ) ;if ( tlv_type == LLDP_TLV_PORT_DESCR ) port -> p_descr = b ;else if ( tlv_type == LLDP_TLV_SYSTEM_NAME ) chassis -> c_name = b ;else chassis -> c_descr = b ;break ;case LLDP_TLV_SYSTEM_CAP : CHECK_TLV_SIZE ( 4 , ""System<S2SV_blank>capabilities"" ) ;chassis -> c_cap_available = PEEK_UINT16 ;chassis -> c_cap_enabled = PEEK_UINT16 ;break ;case LLDP_TLV_MGMT_ADDR : CHECK_TLV_SIZE ( 1 , ""Management<S2SV_blank>address"" ) ;addr_str_length = PEEK_UINT8 ;if ( addr_str_length > sizeof ( addr_str_buffer ) ) {log_warnx ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ;PEEK_BYTES ( addr_str_buffer , addr_str_length ) ;addr_length = addr_str_length - 1 ;addr_family = addr_str_buffer [ 0 ] ;addr_ptr = & addr_str_buffer [ 1 ] ;CHECK_TLV_SIZE ( 1 + addr_str_length + 5 , ""Management<S2SV_blank>address"" ) ;iface_subtype = PEEK_UINT8 ;iface_number = PEEK_UINT32 ;af = lldpd_af_from_lldp_proto ( addr_family ) ;if ( af == LLDPD_AF_UNSPEC ) break ;if ( iface_subtype == LLDP_MGMT_IFACE_IFINDEX ) iface = iface_number ;else iface = 0 ;mgmt = lldpd_alloc_mgmt ( af , addr_ptr , addr_length , iface ) ;if ( mgmt == NULL ) {assert ( errno == ENOMEM ) ;log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>""  ""for<S2SV_blank>management<S2SV_blank>address"" ) ;goto malformed ;}","if ( errno == ENOMEM ) ;log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>management<S2SV_blank>address"" ) ;else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;",800
1102,"case BPLIST_DATA :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_STRING :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_UNICODE : if ( size * 2 < size ) {if ( * object + size * 2 > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_SET : case BPLIST_ARRAY :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\","case BPLIST_DATA : if ( * object + size < * object || * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_STRING : if ( * object + size < * object || * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_UNICODE : if ( size * 2 < * object || * object + size < * object || * object + size * 2 < size ) {if ( * object + size * 2 > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_SET : case BPLIST_ARRAY : if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\",801
1103,"case BPLIST_DICT :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\","case BPLIST_DICT : if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\",801
1104,"TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\\\r\\\if ( ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) != KSZ8851_REV_A3_ID )  {","TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\\\r\\\if ( ksz8851ReadReg ( interface , KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) ) {",802
1105,"ksz8851WriteReg ( interface , KSZ8851_REG_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_REG_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_REG_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_REG_TXCR , TXCR_TXFCE | TXCR_TXPE | TXCR_TXCE ) ;ksz8851WriteReg ( interface , KSZ8851_REG_TXFDPR , TXFDPR_TXFPAI ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXPAFMA | RXCR1_RXFCE | RXCR1_RXBE | RXCR1_RXME | RXCR1_RXUE ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXCR2 , RXCR2_SRDBL2 | RXCR2_IUFFP | RXCR2_RXIUFCEZ ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXQCR , RXQCR_RXFCTE | RXQCR_ADRFE ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXFCTR , 1 ) ;ksz8851ClearBit ( interface , KSZ8851_REG_P1CR , P1CR_FORCE_DUPLEX ) ;ksz8851SetBit ( interface , KSZ8851_REG_P1CR , P1CR_RESTART_AN ) ;ksz8851SetBit ( interface , KSZ8851_REG_ISR , ISR_LCIS | ISR_TXIS |  ISR_RXIS | ISR_RXOIS | ISR_TXPSIS | ISR_RXPSIS | ISR_TXSAIS | ISR_RXWFDIS | ISR_RXMPDIS | ISR_LDIS | ISR_EDIS | ISR_SPIBEIS ) ;ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_TXIE | IER_RXIE ) ;ksz8851SetBit ( interface , KSZ8851_REG_TXCR , TXCR_TXE ) ;ksz8851SetBit ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXE ) ;osSetEvent ( & interface -> nicTxEvent ) ;","ksz8851WriteReg ( interface , KSZ8851_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ;ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ;ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ;ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ;ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ;ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ;ksz8851WriteReg ( interface , KSZ8851_RXFCTR , 1 ) ;ksz8851ClearBit ( interface , KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX ) ;ksz8851SetBit ( interface , KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN ) ;ksz8851SetBit ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS ) ;ksz8851SetBit ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE ) ;ksz8851SetBit ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXE ) ;ksz8851SetBit ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE ) ;osSetEvent ( & interface -> nicTxEvent ) ;",802
1106,pch -> file . dead = 1 ;wake_up_interruptible ( & pch -> file . rwait ) ;,put_net ( pch -> chan_net ) ;pch -> chan_net = NULL ;pch -> file . dead = 1 ;wake_up_interruptible ( & pch -> file . rwait ) ;,803
1107,"struct btrfs_dir_item * di ;struct btrfs_root * root = BTRFS_I ( inode ) -> root ;if ( flags & XATTR_REPLACE ) {di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name ,  name_len , - 1 ) ;if ( IS_ERR ( di ) ) {ret = PTR_ERR ( di ) ;}ret = - ENODATA ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( ret ) goto out ;btrfs_release_path ( path ) ;if ( ! value ) goto out ;}else {di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ;if ( IS_ERR ( di ) ) {ret = PTR_ERR ( di ) ;goto out ;if ( flags & XATTR_CREATE )  goto out ;btrfs_release_path ( path ) ;di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;}else if ( ! di ) {btrfs_release_path ( path ) ;goto again ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( value ) {btrfs_release_path ( path ) ;goto again ;","struct btrfs_dir_item * di = NULL ;struct btrfs_root * root = BTRFS_I ( inode ) -> root ;path -> skip_release_on_error = 1 ;if ( ! value ) {di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;if ( ! di && ( flags & XATTR_REPLACE ) ) ret = - ENODATA ;else if ( di ) ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;}ret = - ENODATA ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( ret ) goto out ;btrfs_release_path ( path ) ;if ( ! value ) goto out ;if ( flags & XATTR_REPLACE ) {ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ;di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ;if ( flags & XATTR_CREATE ) goto out ;btrfs_release_path ( path ) ;di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;btrfs_release_path ( path ) ;di = NULL ;}ret = btrfs_insert_xattr_item ( trans , root , path , di ) ;btrfs_extend_item ( root , path , data_size ) ;item = btrfs_item_nr ( slot ) ;ptr = btrfs_item_ptr ( leaf , slot , char ) ;ptr += btrfs_item_size ( leaf , item ) - data_size ;di = ( struct btrfs_dir_item * ) ptr ;btrfs_set_dir_data_len ( leaf , di , size ) ;data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ;write_extent_buffer ( leaf , value , data_ptr , size ) ;btrfs_mark_buffer_dirty ( leaf ) ;}else {",804
1108,if ( op -> op > 0xbf ) return 1 ;WasmOpDef * opdef = & opcodes [ op -> op ] ;,if ( op -> op > 0xbf ) {return 1 ;}WasmOpDef * opdef = & opcodes [ op -> op ] ;,805
1109,if ( ! ( n > 0 && n < buf_len ) ) goto err ;,if ( ! ( n > 0 && n < buf_len ) ) {goto err ;},805
1110,"if ( ! ( n > 0 && n < buf_len ) ) goto err ;if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ;int i = 0 ;if ( ! ( op -> len + n <= buf_len ) ) goto beach ;op -> len += n ;}if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ;op -> len += n ;for ( i = 0 ;i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ;snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ;}","if ( ! ( n > 0 && n < buf_len ) ) goto err ;if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) {) goto err ;}int i = 0 ;if ( ! ( op -> len + n <= buf_len ) ) {goto beach ;}op -> len += n ;}if ( ! ( n > 0 && n + op -> len < buf_len ) ) {goto beach ;}op -> len += n ;for ( i = 0 ;i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;}",805
1111,"client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ;g_clear_object ( & client -> proxy ) ;g_hash_table_destroy ( client -> rewrite_reply ) ;","client -> proxy ) ;g_byte_array_free ( client -> auth_buffer , TRUE -> clients = g_list_remove ( client -> proxy -> clients , client ) ;g_clear_object ( & client -> proxy ) ;g_hash_table_destroy ( client -> rewrite_reply ) ;",806
1112,"vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra ,  & arg ) ;","vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , vp9_encode_block_intra , & arg ) ;",807
1113,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  return - ENOKEY ;",if ( key_is_negative ( key ) ) return - ENOKEY ;,808
1114,NEED_IP ( 1 ) ;}copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS )  if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) {const unsigned char * ie = ip + t ;,"NEED_IP ( 1 , 0 ) ;}copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( t , 15 ) && HAVE_OP ( t , 15 ) ) ) {const unsigned char * ie = ip + t ;",809
1115,NEED_OP ( t ) ;NEED_IP ( t + 3 ) ;do {,"NEED_OP ( t , 0 ) ;NEED_IP ( t , 3 ) ;do {",809
1116,NEED_OP ( 2 ) ;op [ 0 ] = m_pos [ 0 ] ;,"NEED_OP ( 2 , 0 ) ;op [ 0 ] = m_pos [ 0 ] ;",809
1117,NEED_IP ( 1 ) ;}NEED_IP ( 2 ) ;},"NEED_IP ( 1 , 0 ) ;}NEED_IP ( 2 , 0 ) ;}",809
1118,NEED_IP ( 1 ) ;}NEED_IP ( 2 ) ;},"NEED_IP ( 1 , 0 ) ;}NEED_IP ( 2 , 0 ) ;}",809
1119,if ( likely ( HAVE_OP ( t + 15 ) ) ) {do {,"if ( likely ( HAVE_OP ( t , 15 ) ) ) {do {",809
1120,if ( HAVE_IP ( 6 ) ) {state = next ;,"if ( HAVE_IP ( 6 , 0 ) ) {state = next ;",809
1121,NEED_OP ( t ) ;do {,"NEED_OP ( t , 0 ) ;do {",809
1122,NEED_OP ( t ) ;op [ 0 ] = m_pos [ 0 ] ;,"NEED_OP ( t , 0 ) ;op [ 0 ] = m_pos [ 0 ] ;",809
1123,"# if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS )  if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) {COPY4 ( op , ip ) ;NEED_IP ( t + 3 ) ;NEED_OP ( t ) ;while ( t > 0 ) {","# if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( 6 , 0 ) && HAVE_OP ( 4 , 0 ) ) ) {COPY4 ( op , ip ) ;NEED_IP ( t , 3 ) ;NEED_OP ( t , 0 ) ;while ( t > 0 ) {",809
1124,"if ( fit_check_format ( fit , IMAGE_SIZE_INVAL ) ) {printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!\\\bootstage_error ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ;return - ENOEXEC ;}","ret = fit_check_format ( fit , IMAGE_SIZE_INVAL ) ;if ( ret ) {printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!<S2SV_blank>(err=%d)\\\if ( CONFIG_IS_ENABLED ( FIT_SIGNATURE ) && ret == - EADDRNOTAVAIL ) printf ( ""Signature<S2SV_blank>checking<S2SV_blank>prevents<S2SV_blank>use<S2SV_blank>of<S2SV_blank>unit<S2SV_blank>addresses<S2SV_blank>(@)<S2SV_blank>in<S2SV_blank>nodes\\\bootstage_error ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ;return ret ;}",810
1125,vpn_packet_t outpkt ;outpkt . len = len ;,vpn_packet_t outpkt ;if ( len > sizeof outpkt . data ) return ;outpkt . len = len ;,811
1126,if ( enable_apicv ) {for ( msr = 0x800 ;,for ( msr = 0x800 ;,812
1127,}if ( enable_ept ) {,if ( enable_ept ) {,812
1128,"end = ( char * ) defs + shdr -> sh_size ;sdb_set ( sdb , ""section_name"" , section_name , 0 ) ;sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;",end = ( char * ) defs > i ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;,813
1129,if ( vdaux < 1 ) {sdb_free ( sdb_verdef ) ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {sdb_free ( sdb_verdef ) ;if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) {sdb_free ( sdb_verdef ) ;,813
1130,if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) {sdb_free ( sdb_verdef ) ;,813
1131,"ioctl ( uinput_fd , UI_DEV_DESTROY ) ;close ( uinput_fd ) ;","TEMP_FAILURE_RETRY ( ioctl ( uinput_fd , UI_DEV_DESTROY ) ) ;close ( uinput_fd ) ;",814
1132,"# if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ?  ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) /  ( rc -> baseline_gf_interval + af_ratio - 1 ) :  ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) /  ( rc -> baseline_gf_interval + af_ratio - 1 ) ;# else  target = rc -> av_per_frame_bandwidth ;# endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ;","# if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval ) / ( rc -> baseline_gf_interval + af_ratio - 1 ) ;# else target = rc -> avg_frame_bandwidth ;# endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ;",815
1133,"i ++ )  if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 )  errx ( 1 , ""%s:<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>option"" , ""--allow-untrusted"" ) ;",i ++ ) check_option ( argv [ i ] ) ;,816
1134,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,817
1135,offset = tbl -> indent ;if ( cmd == HTML_DT ) {}if ( tbl -> indent > 0 ) {,if ( tbl -> indent < 0 ) tbl -> indent = 0 ;if ( offset < 0 ) offset = 0 ;offset = tbl -> indent ;if ( cmd == HTML_DT ) {}if ( tbl -> indent > 0 ) {,818
1136,"( void ) & line ;if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len )  return 0 ;DPRINTF ( ( ""%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%"" SIZE_T_FORMAT ""u"" ""<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>[%"" SIZE_T_FORMAT ""u<S2SV_blank>%"" SIZE_T_FORMAT ""u]\\\errno = EFTYPE ;","size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ;( void ) & line ;if ( e >= b && ( size_t ) ( e - b ) <= ss * sst -> sst_len ) return 0 ;DPRINTF ( ( ""%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%"" SIZE_T_FORMAT ""u"" ""<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>[%"" SIZE_T_FORMAT ""u<S2SV_blank>%"" SIZE_T_FORMAT ""u]\\\errno = EFTYPE ;",819
1137,"case 2 :  # line 106 ""hex_grammar.y""  {# line 1330 ""hex_grammar.c""  break ;case 3 :  # line 115 ""hex_grammar.y""  {# line 1338 ""hex_grammar.c""  break ;case 4 :  # line 119 ""hex_grammar.y""  {# line 1351 ""hex_grammar.c""  break ;case 5 :  # line 128 ""hex_grammar.y""  {RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;( yyval . re_node ) = NULL ;","case 2 : # line 113 ""hex_grammar.y"" {# line 1337 ""hex_grammar.c"" break ;case 3 : # line 122 ""hex_grammar.y"" {# line 1345 ""hex_grammar.c"" break ;case 4 : # line 126 ""hex_grammar.y"" {incr_ast_levels ( ) ;# line 1360 ""hex_grammar.c"" break ;case 5 : # line 137 ""hex_grammar.y"" {RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;incr_ast_levels ( ) ;( yyval . re_node ) = NULL ;",820
1138,"# line 1413 ""hex_grammar.c""  break ;case 6 :  # line 190 ""hex_grammar.y""  {# line 1421 ""hex_grammar.c""  break ;case 7 :  # line 194 ""hex_grammar.y""  {# line 1434 ""hex_grammar.c""  break ;case 8 :  # line 207 ""hex_grammar.y""  {# line 1442 ""hex_grammar.c""  break ;case 9 :  # line 211 ""hex_grammar.y""  {# line 1451 ""hex_grammar.c""  break ;case 10 :  # line 220 ""hex_grammar.y""  {","# line 1424 ""hex_grammar.c"" break ;case 6 : # line 201 ""hex_grammar.y"" {# line 1432 ""hex_grammar.c"" break ;case 7 : # line 205 ""hex_grammar.y"" {incr_ast_levels ( ) ;# line 1447 ""hex_grammar.c"" break ;case 8 : # line 220 ""hex_grammar.y"" {# line 1455 ""hex_grammar.c"" break ;case 9 : # line 224 ""hex_grammar.y"" {# line 1464 ""hex_grammar.c"" break ;case 10 : # line 233 ""hex_grammar.y"" {",820
1139,"# line 1468 ""hex_grammar.c""  break ;case 11 :  # line 233 ""hex_grammar.y""  {# line 1476 ""hex_grammar.c""  break ;case 12 :  # line 237 ""hex_grammar.y""  {# line 1485 ""hex_grammar.c""  break ;case 13 :  # line 246 ""hex_grammar.y""  {","# line 1481 ""hex_grammar.c"" break ;case 11 : # line 246 ""hex_grammar.y"" {# line 1489 ""hex_grammar.c"" break ;case 12 : # line 250 ""hex_grammar.y"" {# line 1498 ""hex_grammar.c"" break ;case 13 : # line 259 ""hex_grammar.y"" {",820
1140,"# line 1512 ""hex_grammar.c""  break ;case 14 :  # line 269 ""hex_grammar.y""  {","# line 1525 ""hex_grammar.c"" break ;case 14 : # line 282 ""hex_grammar.y"" {",820
1141,"# line 1548 ""hex_grammar.c""  break ;case 15 :  # line 301 ""hex_grammar.y""  {","# line 1561 ""hex_grammar.c"" break ;case 15 : # line 314 ""hex_grammar.y"" {",820
1142,"# line 1574 ""hex_grammar.c""  break ;case 16 :  # line 323 ""hex_grammar.y""  {","# line 1587 ""hex_grammar.c"" break ;case 16 : # line 336 ""hex_grammar.y"" {",820
1143,"# line 1594 ""hex_grammar.c""  break ;case 17 :  # line 343 ""hex_grammar.y""  {# line 1602 ""hex_grammar.c""  break ;case 18 :  # line 347 ""hex_grammar.y""  {( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1617 ""hex_grammar.c""  break ;case 19 :  # line 361 ""hex_grammar.y""  {# line 1629 ""hex_grammar.c""  break ;case 20 :  # line 369 ""hex_grammar.y""  {","# line 1607 ""hex_grammar.c"" break ;case 17 : # line 356 ""hex_grammar.y"" {# line 1615 ""hex_grammar.c"" break ;case 18 : # line 360 ""hex_grammar.y"" {incr_ast_levels ( ) ;( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1631 ""hex_grammar.c"" break ;case 19 : # line 375 ""hex_grammar.y"" {# line 1643 ""hex_grammar.c"" break ;case 20 : # line 383 ""hex_grammar.y"" {",820
1144,"# line 1653 ""hex_grammar.c""  break ;# line 1657 ""hex_grammar.c""  default : break ;","# line 1667 ""hex_grammar.c"" break ;# line 1657 ""hex_grammar.c"" default : break ;",820
1145,"d = & mb -> e_mbd . block [ ib ] ;# if 0  vp8_strict_quantize_b ( b , d ) ;# endif dequant_ptr = d -> dequant ;",dequant_ptr = d -> dequant ;,821
1146,"strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ;# ifdef __WIN__ strncat ( buff , ""/"" , sizeof ( buff ) - strlen ( buff ) - 1 ) ;","memset ( buff , 0 , sizeof ( buff ) ) ;strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ;# ifdef __WIN__ strncat ( buff , ""/"" , sizeof ( buff ) - strlen ( buff ) - 1 ) ;",822
1147,"if ( ret < 0 ) return ret ;key -> expiry = prep -> expiry ;if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  zap = dereference_key_locked ( key ) ;",if ( key_is_positive ( key ) ) zap = dereference_key_locked ( key ) ;,823
1148,struct hci_filter * f = & hci_pi ( sk ) -> filter ;uf . type_mask = f -> type_mask ;,"struct hci_filter * f = & hci_pi ( sk ) -> filter ;memset ( & uf , 0 , sizeof ( uf ) ) ;uf . type_mask = f -> type_mask ;",824
1149,int n = ( int ) ( data_end - data ) ;if ( n > 10 ) n = 10 ;,"int n = ( int ) MIN ( sizeof ( clear_buffer ) , data_end - data ) ;",825
1150,"clear += 7 ;}vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ;vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ;}","}vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ;memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ;}",825
1151,"pc -> clamp_type = ( CLAMP_TYPE ) vp8_read_bit ( bc ) ;}xd -> segmentation_enabled = ( unsigned char ) vp8_read_bit ( bc ) ;if ( xd -> segmentation_enabled ) {vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;for ( i = 0 ;","memset ( xd -> segmentation_enabled ) {vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;for ( i = 0 ;",825
1152,"vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ;for ( i = 0 ;","memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ;for ( i = 0 ;",825
1153,"vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ;}","memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ;}",825
1154,"vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_decode_mode_mvs ( pbi ) ;# endif  vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ;pbi -> frame_corrupt_residual = 0 ;","memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_decode_mode_mvs ( pbi ) ;# endif memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ;pbi -> frame_corrupt_residual = 0 ;",825
1155,"vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ;pbi -> independent_partitions = prev_independent_partitions ;","memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ;pbi -> independent_partitions = prev_independent_partitions ;",825
1156,"gss_buffer_desc client_name , service_name ;OM_uint32 minor_stat ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;OM_uint32 minor_stat ;,826
1157,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",826
1158,"asoc -> peer . i = new -> peer . i ;sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ;","asoc -> peer . auth_capable = new -> peer . auth_capable ;asoc -> peer . i = new -> peer . i ;sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ;",827
1159,if ( ! capable ( CAP_SYS_ADMIN ) ) {,if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( ! capable ( CAP_SYS_ADMIN ) ) {,828
1160,if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) {rcode = - EINVAL ;,if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) ) {rcode = - EINVAL ;,828
1161,assert ( ( cc0 % rowsize ) == 0 ) ;while ( cc > 0 ) {,"if ( ( cc0 % rowsize ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ;return 0 ;}while ( cc > 0 ) {",829
1162,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_association_put ( asoc ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\out_unlock : bh_unlock_sock ( sk ) ;sctp_association_put ( asoc ) ;",830
1163,"int yr_re_exec ( uint8_t * re_code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {","int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",831
1164,"# define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3  # define prolog if ( bytes_matched >= max_bytes_matched ) {# define fail_if_error ( e ) switch ( e ) {if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ;input -= character_size ;input_incr = - input_incr ;max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ;max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ;","# define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 # define prolog {if ( ( bytes_matched >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) {}# define fail_if_error ( e ) {switch ( e ) {}if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ;max_bytes_matched = ( int ) yr_min ( input_forwards_size , RE_SCAN_LIMIT ) ;}input -= character_size ;input_incr = - input_incr ;else {max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ;max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ;",831
1165,match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ;,"match = _yr_re_is_word_char ( input , character_size ) ;",831
1166,match = IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;match = ! IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;,"match = IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;match = ! _yr_re_is_word_char ( input , character_size ) ;action = match ? ACTION_NONE : ACTION_KILL ;",831
1167,case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 &&  ! ( flags & RE_FLAGS_NOT_AT_START ) &&  ! ( flags & RE_FLAGS_BACKWARDS ) )  match = TRUE ;else if ( bytes_matched >= max_bytes_matched )  match = TRUE ;else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) )  match = TRUE ;else match = FALSE ;case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS )  kill = input_size > ( size_t ) bytes_matched ;else  kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS ||  input_size > ( size_t ) bytes_matched ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;,"case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && input_backwards_size < character_size ) {match = TRUE ;}else if ( bytes_matched >= max_bytes_matched ) {match = TRUE ;}else {assert ( input < input_data + input_forwards_size ) ;assert ( input >= input_data - input_backwards_size ) ;assert ( input - input_incr < input_data + input_forwards_size ) ;assert ( input - input_incr >= input_data - input_backwards_size ) ;match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ;}case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS ) kill = input_backwards_size > ( size_t ) bytes_matched ;else kill = input_backwards_size > 0 || ( bytes_matched != 0 ) ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || input_forwards_size > ( size_t ) bytes_matched ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;",831
1168,"}if ( flags & RE_FLAGS_WIDE && bytes_matched < max_bytes_matched && * ( input + 1 ) != 0 ) {_yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ;","
",831
1169,"void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate ,  int * returndistortion , int * returnintra )  {","void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate , int * returndistortion , int * returnintra , int mb_row , int mb_col ) {",832
1170,"# if CONFIG_TEMPORAL_DENOISING  unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ,   best_rd_sse = INT_MAX ;# endif mode_mv = mode_mv_sb [ sign_bias ] ;best_mode . yrd = INT_MAX ;best_mode . intra_rd = INT_MAX ;vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ;vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ;vpx_memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ;get_reference_search_order ( cpi , ref_frame_map ) ;if ( ref_frame_map [ 1 ] > 0 ) {sign_bias = vp8_find_near_mvs_bias ( & x -> e_mbd , x -> e_mbd . mode_info_context , mode_mv_sb , best_ref_mv_sb , mdcounts , ref_frame_map [ 1 ] , cpi -> common . ref_frame_sign_bias ) ;mode_mv = mode_mv_sb [ sign_bias ] ;best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ;}get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ;* returnintra = INT_MAX ;x -> mbs_tested_so_far ++ ;x -> skip = 0 ;for ( mode_index = 0 ;mode_index < MAX_MODES ;mode_index ++ ) {int this_rd = INT_MAX ;int disable_skip = 0 ;int other_cost = 0 ;int this_ref_frame = ref_frame_map [ vp8_ref_frame_order [ mode_index ] ] ;if ( best_mode . rd <= x -> rd_threshes [ mode_index ] ) continue ;if ( this_ref_frame < 0 ) continue ;rd . rate2 = 0 ;rd . distortion2 = 0 ;this_mode = vp8_mode_order [ mode_index ] ;x -> e_mbd . mode_info_context -> mbmi . mode = this_mode ;x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ;if ( cpi -> is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) {if ( this_mode != ZEROMV || x -> e_mbd . mode_info_context -> mbmi . ref_frame != ALTREF_FRAME ) continue ;}if ( x -> e_mbd . mode_info_context -> mbmi . ref_frame ) {x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ;x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ;x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ;if ( sign_bias != cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ) {sign_bias = cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ;mode_mv = mode_mv_sb [ sign_bias ] ;best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ;}}if ( x -> mode_test_hit_counts [ mode_index ] && ( cpi -> mode_check_freq [ mode_index ] > 1 ) ) {if ( x -> mbs_tested_so_far <= cpi -> mode_check_freq [ mode_index ] * x -> mode_test_hit_counts [ mode_index ] ) {x -> rd_thresh_mult [ mode_index ] += 4 ;if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ;x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ;continue ;}}x -> mode_test_hit_counts [ mode_index ] ++ ;if ( x -> zbin_mode_boost_enabled ) {if ( this_ref_frame == INTRA_FRAME ) x -> zbin_mode_boost = 0 ;else {if ( vp8_mode_order [ mode_index ] == ZEROMV ) {if ( this_ref_frame != LAST_FRAME ) x -> zbin_mode_boost = GF_ZEROMV_ZBIN_BOOST ;else x -> zbin_mode_boost = LF_ZEROMV_ZBIN_BOOST ;}else if ( vp8_mode_order [ mode_index ] == SPLITMV ) x -> zbin_mode_boost = 0 ;else x -> zbin_mode_boost = MV_ZBIN_BOOST ;}vp8_update_zbin_extra ( cpi , x ) ;}if ( ! uv_intra_done && this_ref_frame == INTRA_FRAME ) {rd_pick_intra_mbuv_mode ( x , & uv_intra_rate , & uv_intra_rate_tokenonly , & uv_intra_distortion ) ;uv_intra_mode = x -> e_mbd . mode_info_context -> mbmi . uv_mode ;for ( i = 16 ;i < 24 ;i ++ ) uv_intra_tteob += x -> e_mbd . eobs [ i ] ;uv_intra_done = 1 ;}switch ( this_mode ) {case B_PRED : {int tmp_rd ;int distortion ;tmp_rd = rd_pick_intra4x4mby_modes ( x , & rate , & rd . rate_y , & distortion , best_mode . yrd ) ;rd . rate2 += rate ;rd . distortion2 += distortion ;if ( tmp_rd < best_mode . yrd ) {rd . rate2 += uv_intra_rate ;rd . rate_uv = uv_intra_rate_tokenonly ;rd . distortion2 += uv_intra_distortion ;rd . distortion_uv = uv_intra_distortion ;}else {this_rd = INT_MAX ;disable_skip = 1 ;}}break ;case SPLITMV : {int tmp_rd ;int this_rd_thresh ;int distortion ;this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 1 ) ? x -> rd_threshes [ THR_NEW1 ] : x -> rd_threshes [ THR_NEW3 ] ;this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 2 ) ? x -> rd_threshes [ THR_NEW2 ] : this_rd_thresh ;tmp_rd = vp8_rd_pick_best_mbsegmentation ( cpi , x , & best_ref_mv , best_mode . yrd , mdcounts , & rate , & rd . rate_y , & distortion , this_rd_thresh ) ;rd . rate2 += rate ;rd . distortion2 += distortion ;if ( tmp_rd < best_mode . yrd ) {rd_inter4x4_uv ( cpi , x , & rd . rate_uv , & rd . distortion_uv , cpi -> common . full_pixel ) ;rd . rate2 += rd . rate_uv ;rd . distortion2 += rd . distortion_uv ;}else {this_rd = INT_MAX ;disable_skip = 1 ;}}break ;case DC_PRED : case V_PRED : case H_PRED : case TM_PRED : {int distortion ;x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ;vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ;macro_block_yrd ( x , & rd . rate_y , & distortion ) ;rd . rate2 += rd . rate_y ;rd . distortion2 += distortion ;rd . rate2 += x -> mbmode_cost [ x -> e_mbd . frame_type ] [ x -> e_mbd . mode_info_context -> mbmi . mode ] ;rd . rate2 += uv_intra_rate ;rd . rate_uv = uv_intra_rate_tokenonly ;rd . distortion2 += uv_intra_distortion ;rd . distortion_uv = uv_intra_distortion ;}break ;case NEWMV : {int thissme ;int bestsme = INT_MAX ;int step_param = cpi -> sf . first_step ;int further_steps ;int n ;int do_refine = 1 ;int sadpb = x -> sadperbit16 ;int_mv mvp_full ;int col_min = ( ( best_ref_mv . as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ;int row_min = ( ( best_ref_mv . as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ;int col_max = ( best_ref_mv . as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ;int row_max = ( best_ref_mv . as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ;int tmp_col_min = x -> mv_col_min ;int tmp_col_max = x -> mv_col_max ;int tmp_row_min = x -> mv_row_min ;int tmp_row_max = x -> mv_row_max ;if ( ! saddone ) {vp8_cal_sad ( cpi , xd , x , recon_yoffset , & near_sadidx [ 0 ] ) ;saddone = 1 ;}vp8_mv_pred ( cpi , & x -> e_mbd , x -> e_mbd . mode_info_context , & mvp , x -> e_mbd . mode_info_context -> mbmi . ref_frame , cpi -> common . ref_frame_sign_bias , & sr , & near_sadidx [ 0 ] ) ;mvp_full . as_mv . col = mvp . as_mv . col >> 3 ;mvp_full . as_mv . row = mvp . as_mv . row >> 3 ;if ( x -> mv_col_min < col_min ) x -> mv_col_min = col_min ;if ( x -> mv_col_max > col_max ) x -> mv_col_max = col_max ;if ( x -> mv_row_min < row_min ) x -> mv_row_min = row_min ;if ( x -> mv_row_max > row_max ) x -> mv_row_max = row_max ;if ( sr > step_param ) step_param = sr ;{bestsme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ;mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ;n = 0 ;further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ;n = num00 ;num00 = 0 ;if ( n > further_steps ) do_refine = 0 ;while ( n < further_steps ) {n ++ ;if ( num00 ) num00 -- ;else {thissme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param + n , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ;if ( num00 > ( further_steps - n ) ) do_refine = 0 ;if ( thissme < bestsme ) {bestsme = thissme ;mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ;}else {d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ;}}}}if ( do_refine == 1 ) {int search_range ;search_range = 8 ;thissme = cpi -> refining_search_sad ( x , b , d , & d -> bmi . mv , sadpb , search_range , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ;if ( thissme < bestsme ) {bestsme = thissme ;mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ;}else {d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ;}}x -> mv_col_min = tmp_col_min ;x -> mv_col_max = tmp_col_max ;x -> mv_row_min = tmp_row_min ;x -> mv_row_max = tmp_row_max ;if ( bestsme < INT_MAX ) {int dis ;unsigned int sse ;cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & dis , & sse ) ;}mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ;rd . rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , x -> mvcost , 96 ) ;}case NEARESTMV : case NEARMV : vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ;if ( ( ( this_mode == NEARMV ) || ( this_mode == NEARESTMV ) ) && ( mode_mv [ this_mode ] . as_int == 0 ) ) continue ;case ZEROMV : if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) continue ;vp8_set_mbmode_and_mvs ( x , this_mode , & mode_mv [ this_mode ] ) ;this_rd = evaluate_inter_mode_rd ( mdcounts , & rd , & disable_skip , cpi , x ) ;break ;default : break ;}this_rd = calculate_final_rd_costs ( this_rd , & rd , & other_cost , disable_skip , uv_intra_tteob , intra_rd_penalty , cpi , x ) ;if ( ( x -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) && ( this_rd < best_mode . intra_rd ) ) {best_mode . intra_rd = this_rd ;* returnintra = rd . distortion2 ;}# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) {unsigned int sse ;vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & sse , mode_mv [ this_mode ] ) ;if ( sse < best_rd_sse ) best_rd_sse = sse ;if ( this_mode == ZEROMV && sse < zero_mv_sse ) {zero_mv_sse = sse ;x -> best_zeromv_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ;}if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && sse < best_sse ) {best_sse = sse ;vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & best_sse , mode_mv [ this_mode ] ) ;x -> best_sse_inter_mode = NEWMV ;x -> best_sse_mv = x -> e_mbd . mode_info_context -> mbmi . mv ;x -> need_to_clamp_best_mvs = x -> e_mbd . mode_info_context -> mbmi . need_to_clamp_mvs ;x -> best_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ;}}# endif if ( this_rd < best_mode . rd || x -> skip ) {best_mode_index = mode_index ;* returnrate = rd . rate2 ;* returndistortion = rd . distortion2 ;if ( this_mode <= B_PRED ) {x -> e_mbd . mode_info_context -> mbmi . uv_mode = uv_intra_mode ;x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ;}update_best_mode ( & best_mode , this_rd , & rd , other_cost , x ) ;","# if CONFIG_TEMPORAL_DENOISING unsigned int zero_mv_sse = UINT_MAX , best_sse = INT_MAX , best_rd_sse = UINT_MAX ;# endif mode_mv = mode_mv_sb [ sign_bias ] ;memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ;vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ;memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ;memset ( & best_mode , this_rd , & rd , other_cost , x ) ;",832
1171,"if ( x -> best_sse_inter_mode == DC_PRED )  {vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse ,  recon_yoffset , recon_uvoffset ) ;if ( best_mode . mbmode . ref_frame == INTRA_FRAME && x -> best_zeromv_reference_frame != INTRA_FRAME ) {","int block_index = mb_row * cpi -> common . mb_cols + mb_col ;if ( x -> best_sse_inter_mode == DC_PRED ) {vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , recon_yoffset , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index ) ;if ( best_mode . mbmode . ref_frame == INTRA_FRAME && x -> best_zeromv_reference_frame != INTRA_FRAME ) {",832
1172,best_mode_index = mode_index ;* returnrate = rd . rate2 ;,best_mode_index = mode_index ;* returnrate = rd . rate2 ;,832
1173,"vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ;if ( best_mode . mbmode . mode == B_PRED ) {","vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ;if ( best_mode . mbmode . mode == B_PRED ) {",832
1174,"vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ;x -> e_mbd . mode_info_context -> mbmi . mv . as_int = x -> partition_info -> bmi [ 15 ] . mv . as_int ;","vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ;x -> e_mbd . mode_info_context -> mbmi . mv . as_int = x -> partition_info -> bmi [ 15 ] . mv . as_int ;",832
1175,"set_exception_intercept ( svm , MC_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;","set_exception_intercept ( svm , MC_VECTOR ) ;set_exception_intercept ( svm , AC_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;",833
1176,h -> size = statbuf . st_size ;if ( ! h -> writable ) {,"h -> size = statbuf . st_size ;if ( h -> size < 0x2000 ) {SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ;goto error ;}if ( ! h -> writable ) {",834
1177,"private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h ,  const cdf_stream_t * sst , const uint64_t clsid [ 2 ] )  {","private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , const cdf_stream_t * sst , const cdf_directory_t * root_storage ) {",835
1178,"str = cdf_clsid_to_mime ( clsid , clsid2desc ) ;if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 )  return - 2 ;}m = cdf_file_property_info ( ms , info , count , clsid ) ;free ( info ) ;","if ( root_storage ) {str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid , clsid2desc ) ;if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 ) return - 2 ;}}m = cdf_file_property_info ( ms , info , count , root_storage ) ;free ( info ) ;",835
1179,"UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ;UWORD16 i2_max_frm_num ;","UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 ;UWORD16 i2_max_frm_num ;",836
1180,"if ( ! u1_frm )  {u2_pic_ht <<= 1 ;ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ;","if ( ! u1_frm ) u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) {ps_dec -> u1_res_changed = 1 ;return IVD_RES_CHANGED ;}if ( ! u1_frm ) {u2_pic_ht <<= 1 ;ps_seq -> u1_mb_aff_flag = u1_mb_aff_flag ;COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ;",836
1181,"err |= get_user ( length , & up -> length ) ;up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ;","err |= get_user ( length , & up -> length ) ;if ( err ) return - EFAULT ;up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ;",837
1182,"static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {VP9_COMP * const cpi = ctx -> cpi ;vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ;if ( params == NULL )  return VPX_CODEC_INVALID_PARAM ;cpi -> svc . spatial_layer_id = params -> spatial_layer ;cpi -> svc . temporal_layer_id = params -> temporal_layer ;cpi -> lst_fb_idx = params -> lst_fb_idx ;cpi -> gld_fb_idx = params -> gld_fb_idx ;cpi -> alt_fb_idx = params -> alt_fb_idx ;if ( vp9_set_size_literal ( ctx -> cpi , params -> width , params -> height ) != 0 ) return VPX_CODEC_INVALID_PARAM ;ctx -> cfg . rc_max_quantizer = params -> max_quantizer ;ctx -> cfg . rc_min_quantizer = params -> min_quantizer ;set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;","static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , va_list args ) {VP9_COMP * const cpi = ctx -> cpi ;vpx_svc_extra_cfg_t * const params = va_arg ( args , vpx_svc_extra_cfg_t * ) ;if ( params == NULL ) return VPX_CODEC_INVALID_PARAM ;cpi -> svc . number_spatial_layers ;++ sl ) {for ( tl = 0 ;tl < cpi -> svc . number_temporal_layers ;++ tl ) {const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ;LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ;lc -> max_q = params -> max_quantizers [ sl ] ;lc -> min_q = params -> min_quantizers [ sl ] ;lc -> scaling_factor_num = params -> scaling_factor_num [ sl ] ;lc -> scaling_factor_den = params -> scaling_factor_den [ sl ] ;}}",838
1183,"found :  if ( prev ) {int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ;if ( i > 0 ) {offset += i ;while ( next && FRAG6_CB ( next ) -> offset < end ) {int i = end - FRAG6_CB ( next ) -> offset ;if ( i < next -> len ) {if ( ! pskb_pull ( next , i ) ) goto err ;FRAG6_CB ( next ) -> offset += i ;fq -> q . meat -= i ;if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ;break ;}else {struct sk_buff * free_it = next ;next = next -> next ;if ( prev ) prev -> next = next ;else fq -> q . fragments = next ;fq -> q . meat -= free_it -> len ;frag_kfree_skb ( fq -> q . net , free_it ) ;}}",found : if ( prev && ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset > 0 ) {offset += i ;while ( next && FRAG6_CB ( next ) -> offset < end ) goto discard_fq ;,839
1184,"err :  IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ;","discard_fq : fq_kill ( fq ) ;err : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ;",839
1185,"uint16 bitspersample , samplesperpixel ;uint16 input_compression , input_photometric ;copyFunc cf ;","uint16 bitspersample , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;copyFunc cf ;",840
1186,# if ! defined ( HAVE_LSTAT )  ( void ) a ;return ( ARCHIVE_OK ) ;# else char * pn ;char c ;int r ;struct stat st ;pn = a -> name ;if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) {,struct archive_string error_string ;int error_number ;int rc ;archive_string_init ( & error_string ) ;rc = check_symlinks_fsobj ( a -> path_safe ) ) > 0 ) {,841
1187,"r = lstat ( a -> name , & st ) ;if ( r != 0 ) {if ( errno == ENOENT ) {break ;}else {return ( ARCHIVE_FAILED ) ;}}else if ( S_ISLNK ( st . st_mode ) ) {if ( c == \'\\\\0\' ) {if ( unlink ( a -> name ) ) {archive_set_error ( & a -> archive , errno ,  ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ;}a -> pst = NULL ;if ( ! S_ISLNK ( a -> mode ) ) {archive_set_error ( & a -> archive , 0 , ""Removing<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ;","r = lstat ( a -> name , & error_number , & error_string , a -> flags ) ;if ( rc != ARCHIVE_OK ) {archive_set_error ( & a -> archive , errno , ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ;a -> pst = NULL ;if ( ! S_ISLNK ( a -> mode ) ) {archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ;}archive_string_free ( & error_string ) ;",841
1188,"else {archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>extract<S2SV_blank>through<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ;pn [ 0 ] = c ;return ( ARCHIVE_FAILED ) ;}}pn [ 0 ] = c ;if ( pn [ 0 ] != \'\\\\0\' ) pn ++ ;}pn [ 0 ] = c ;archive_strcpy ( & a -> path_safe , a -> name ) ;return ( ARCHIVE_OK ) ;# endif }",return rc ;,841
1189,"if ( ret < 0 || ret >= MAXPATHLEN ) {ERROR ( ""Error<S2SV_blank>calculating<S2SV_blank>container<S2SV_blank>/dev<S2SV_blank>location"" ) ;return - 1 ;}if ( ! dir_exists ( path ) ) return 0 ;INFO ( ""Populating<S2SV_blank>container<S2SV_blank>/dev"" ) ;cmask = umask ( S_IXUSR | S_IXGRP | S_IXOTH ) ;for ( i = 0 ;i < sizeof ( lxc_devs ) / sizeof ( lxc_devs [ 0 ] ) ;i ++ ) {const struct lxc_devs * d = & lxc_devs [ i ] ;ret = snprintf ( path , MAXPATHLEN , ""%s/dev/%s"" , rootfs -> path ? rootfs -> mount : """" , d -> name ) ;if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ;ret = mknod ( path , d -> mode , makedev ( d -> maj , d -> min ) ) ;if ( ret && errno != EEXIST ) {char hostpath [ MAXPATHLEN ] ;FILE * pathfile ;ret = snprintf ( hostpath , MAXPATHLEN , ""/dev/%s"" , d -> name ) ;if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ;pathfile = fopen ( path , ""wb"" ) ;if ( ! pathfile ) {SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>device<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\\\'%s\\\'"" , path ) ;return - 1 ;}fclose ( pathfile ) ;if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) {SYSERROR ( ""Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container"" , d -> name ) ;","if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : NULL ) != 0 ) {SYSERROR ( ""Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container"" , d -> name ) ;",842
1190,"struct buffer_head * bh = NULL ;struct fileEntry * fe ;struct extendedFileEntry * efe ;uint16_t ident ;struct udf_inode_info * iinfo = UDF_I ( inode ) ;struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ;unsigned int link_count ;bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ;if ( ! bh ) {udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\\make_bad_inode ( inode ) ;return ;}if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) {udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\\brelse ( bh ) ;make_bad_inode ( inode ) ;return ;}fe = ( struct fileEntry * ) bh -> b_data ;efe = ( struct extendedFileEntry * ) bh -> b_data ;if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) {struct buffer_head * ibh ;ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ;if ( ident == TAG_IDENT_IE && ibh ) {struct buffer_head * nbh = NULL ;struct kernel_lb_addr loc ;if ( ie -> indirectICB . extLength &&   ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 ,  & ident ) ) ) {","struct kernel_lb_addr loc ;if ( ie -> indirectICB . extLength && ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , & ident ) ) ) {",843
1191,brelse ( nbh ) ;},brelse ( nbh ) ;},843
1192,"const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ;const int filter_level = get_filter_level ( lfi_n , mbmi ) ;","const TX_SIZE tx_size_uv = get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 ) ;const int filter_level = get_filter_level ( lfi_n , mbmi ) ;",844
1193,"vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ;index += 8 ;","memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ;index += 8 ;",844
1194,* above_y |= ( size_mask [ block_size ] & above_64x64_txform_mask [ tx_size_y ] ) << shift_y ;if ( tx_size_y == TX_4X4 )  * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ;if ( tx_size_uv == TX_4X4 ) * int_4x4_uv |= ( size_mask_uv [ block_size ] & 0xffff ) << shift_uv ;,* above_y |= ( size_mask [ block_size ] & 0xffffffffffffffffULL ) << shift_y ;if ( tx_size_y == TX_4X4 ) * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ;if ( tx_size_uv == TX_4X4 ) * int_4x4_uv |= ( size_mask_uv [ block_size ] & 0xffff ) << shift_uv ;,844
1195,"int namelen = strlen ( name ) ;int len ;while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) {len = ff_amf_tag_size ( data , data_end ) ;if ( len < 0 )  len = data_end - data ;data ++ ;for ( ;if ( ! size )  break ;if ( size < 0 || size >= data_end - data ) return - 1 ;if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) {switch ( * data ++ ) {case AMF_DATA_TYPE_NUMBER :  snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ;break ;case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ;break ;case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ;av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ;break ;default : return - 1 ;}return 0 ;}len = ff_amf_tag_size ( data , data_end ) ;if ( len < 0 || len >= data_end - data ) return - 1 ;data += len ;}return - 1 ;","GetByteContext gb ;if ( len < 0 ) len = data_end - data ;data ++ ;for ( ;if ( data >= data_end ) return - 1 ;if ( size == namelen && ! memcmp ( data - size , name , dst , dst_size ) ;",845
1196,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",846
1197,"spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;flush_rq -> tag = - 1 ;","struct blk_mq_hw_ctx * hctx ;spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ;blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq ) ;flush_rq -> tag = - 1 ;",847
1198,"k -> get_config ( vdev , vdev -> config ) ;if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ;","if ( addr + sizeof ( val ) > vdev -> config_len ) {return ( uint32_t ) - 1 ;}k -> get_config ( vdev , vdev -> config ) ;",848
1199,"return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ;}","return match ( prog -> start , sp , sp , prog -> flags | eflags , sub , 0 ) ;}",849
1200,"static void  swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horDiff16 ( tif , cp0 , cc ) ;TIFFSwabArrayOfShort ( wp , wc ) ;}","static int swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ! horDiff16 ( tif , cp0 , cc ) ) return 0 ;TIFFSwabArrayOfShort ( wp , wc ) ;return 1 ;}",850
1201,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",851
1202,int err ;if ( rt ) return 0 ;daddr = inet -> inet_daddr ;if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;,struct ip_options_rcu * inet_opt ;int err ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;rcu_read_unlock ( ) ;,852
1203,"void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType )  {","static void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {",853
1204,"pid_t pid ;memset ( s_path , 0 , sizeof ( s_path ) ) ;memset ( c_path , 0 , sizeof ( c_path ) ) ;pid = getpid ( ) ;","memset ( s_path , 0 , sizeof ( s_path ) ) ;memset ( c_path , 0 , sizeof ( c_path ) ) ;",854
1205,"sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix ,   hdl -> instance , ( long unsigned ) pid ) ;if ( * mgr_hdl == NULL ) {","sprintf ( c_path , ""%s%s%d_C_XXXXXX"" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ;if ( * mgr_hdl == NULL ) {",854
