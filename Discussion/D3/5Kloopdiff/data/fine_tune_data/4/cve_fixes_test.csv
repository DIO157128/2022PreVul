,source,target,group
0,if ( tlen < 1 ) {,if ( tlen < 1U + 1 ) {,4124
1,if ( tlen < oid_len ) {return 0 ;,if ( tlen < oid_len ) {return 0 ;,4124
2,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",4125
3,dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ;dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ;,dpb_commands_t * ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) ;dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ;,4126
4,"static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id )   {if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\\}","static int iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) {if ( sta_id >= IWLAGN_STATION_COUNT ) {IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ;return - EINVAL ;}if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\\return 0 ;}",4127
5,"if ( rtm -> rtm_flags & RTM_F_FIB_MATCH )  err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid ,  nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ;else err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ;rcu_read_unlock ( ) ;err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ;","if ( rtm -> rtm_flags & RTM_F_FIB_MATCH ) {if ( ! res . fi ) {err = fib_props [ res . type ] . error ;if ( ! err ) err = - EHOSTUNREACH ;goto errout_free ;}err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ;}else {err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ;}rcu_read_unlock ( ) ;err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ;",4128
6,"r = send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ;if ( r == data_size ) {","r = TEMP_FAILURE_RETRY ( send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ) ;if ( r == data_size ) {",4129
7,"if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ;__TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ;if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ;th = ( const struct tcphdr * ) skb -> data ;if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ;if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ;if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ;th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ;if ( ! sk ) goto no_tcp_socket ;process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ;if ( sk -> sk_state == TCP_NEW_SYN_RECV ) {struct request_sock * req = inet_reqsk ( sk ) ;struct sock * nsk ;sk = req -> rsk_listener ;tcp_v6_fill_cb ( skb , hdr , th ) ;if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) {","if ( tcp_filter ( sk , skb ) ) {",4130
8,"if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;skb -> dev = NULL ;","th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;if ( sk_filter ( sk , skb ) ) goto discard_and_relse ;skb -> dev = NULL ;",4130
9,"replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ;encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ;encode_nops ( & hdr ) ;}","replen = hdr . replen + op_decode_hdr_maxsz + 1 ;encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ;xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;encode_nops ( & hdr ) ;}",4131
10,"rcu_read_lock ( ) ;__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;rcu_read_unlock ( ) ;","__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;rcu_read_unlock ( ) ;",4132
11,"ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ;}","ret = TEMP_FAILURE_RETRY ( sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ) ;}",4133
12,"args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return xdr_argsize_check ( rqstp , p ) ;}","if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return 1 ;}",4134
13,"vcpu = kvm_arch_vcpu_create ( kvm , id ) ;if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ;","if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;vcpu = kvm_arch_vcpu_create ( kvm , id ) ;if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ;",4135
14,if ( ! handle )  return NULL ;,if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ;,4136
15,hdl -> client_state = HSM_COM_C_STATE_IN ;* p_hdl = hdl ;,if ( mkstemp ( hdl -> c_path ) == - 1 ) {res = HSM_COM_PATH_ERR ;goto cleanup ;}hdl -> client_state = HSM_COM_C_STATE_IN ;* p_hdl = hdl ;,4137
16,"skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {msg -> msg_namelen = 0 ;copied = skb -> len ;","msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {copied = skb -> len ;",4138
17,"gint reported_length_remaining ;ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ;","gint reported_length_remaining ;struct eth_phdr eth ;void * phdr ;ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ;",4139
18,"dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ;if ( ! info_added ) {","switch ( linktype ) {case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ;phdr = & eth ;break ;default : phdr = NULL ;break ;}dissector_try_uint_new ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree , TRUE , phdr ) ;if ( ! info_added ) {",4139
19,"int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;uint16_t * const eob = & p -> eobs [ block ] ;switch ( tx_size ) {case TX_32X32 :  fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vp9_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round ,   p -> quant , p -> quant_shift , qcoeff , dqcoeff ,   pd -> dequant , p -> zbin_extra , eob , scan_order -> scan ,  scan_order -> iscan ) ;case TX_16X16 :  vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ;vp9_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff ,  pd -> dequant , p -> zbin_extra , eob ,  scan_order -> scan , scan_order -> iscan ) ;case TX_8X8 :  vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ;vp9_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff ,  pd -> dequant , p -> zbin_extra , eob ,  scan_order -> scan , scan_order -> iscan ) ;vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round ,  p -> quant , p -> quant_shift , qcoeff , dqcoeff ,  pd -> dequant , p -> zbin_extra , eob ,  scan_order -> scan , scan_order -> iscan ) ;default :  assert ( 0 ) ;}","tran_low_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;uint16_t * const eob = & p -> eobs [ block ] ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {switch ( tx_size ) {case TX_32X32 : highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , scan_order -> iscan ) ;case TX_16X16 : vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ;vp9_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;case TX_8X8 : vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ;vp9_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;default : assert ( 0 ) ;}return ;}# endif switch ( tx_size ) {case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;break ;case TX_16X16 : vpx_fdct16x16 ( src_diff , coeff , diff_stride ) ;vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;break ;case TX_8X8 : vpx_fdct8x8 ( src_diff , coeff , diff_stride ) ;vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;break ;case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ;vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;break ;default : assert ( 0 ) ;break ;}",4140
20,"struct desc_struct * desc ;short sel ;desc = get_desc ( sel ) ;if ( ! desc )  return - EINVAL ;if ( ! ( desc -> type & BIT ( 3 ) ) )  return - EINVAL ;switch ( ( desc -> l << 1 ) | desc -> d ) {case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ;","struct desc_struct desc ;short sel ;if ( ! desc ) return - EINVAL ;if ( ! ( desc . type & BIT ( 3 ) ) ) return - EINVAL ;switch ( ( desc . l << 1 ) | desc . d ) {case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ;",4141
21,"if ( ! sock ) goto out ;vhost_disable_notify ( & net -> dev , vq ) ;vhost_hlen = nvq -> vhost_hlen ;sock_hlen = nvq -> sock_hlen ;vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? vq -> log : NULL ;mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ;while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) {sock_len += sock_hlen ;vhost_len = sock_len + vhost_hlen ;headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? UIO_MAXIOV : 1 ) ;if ( unlikely ( headcount < 0 ) ) break ;if ( ! headcount ) {if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) {","if ( unlikely ( headcount > UIO_MAXIOV ) ) {msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\\continue ;}if ( ! headcount ) {if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) {",4142
22,"msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg ,  sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;if ( unlikely ( err != sock_len ) ) {pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\\","msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;if ( unlikely ( err != sock_len ) ) {pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\\",4142
23,if ( operand >= MAX_OPERANDS ) {,if ( strlen ( token ) > 4 && operand >= MAX_OPERANDS ) {,4143
24,if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) {op -> operands_count ++ ;,if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) {op -> operands_count ++ ;,4143
25,"size_t wcs_length = len ;size_t mbs_length = len ;# endif  if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) )  return ( - 1 ) ;if ( wcs_length == 0 ) {dest -> length = wcs - dest -> s ;dest -> s [ dest -> length ] = L'\\\\0' ;wcs_length = mbs_length ;if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) return ( - 1 ) ;wcs = dest -> s + dest -> length ;}# if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , wcs_length , & shift_state ) ;# else r = mbtowc ( wcs , mbs , wcs_length ) ;if ( errno == EILSEQ ) {++ mbs ;-- mbs_length ;continue ;}else break ;wcs_length -- ;","size_t mbs_length = len ;# endif if ( NULL == archive_wstring_ensure ( dest , dest -> length + len + 1 ) ) return ( - 1 ) ;# if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , mbs_length , & shift_state ) ;# else r = mbtowc ( wcs , mbs , mbs_length ) ;+ mbs ;break ;",4144
26,"timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer ,  timer -> base -> get_time ( ) , timr -> it_interval ) ;","timr -> it_overrun += hrtimer_forward ( timer , timer -> base -> get_time ( ) , timr -> it_interval ) ;",4145
27,# endif  newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;,# endif newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;,4146
28,newinet -> inet_opt = NULL ;newnp -> ipv6_ac_list = NULL ;,newinet -> inet_opt = NULL ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;,4146
29,"int alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( alt < 0 )  return alt ;return usb_set_interface ( udev ,  intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ;}","struct usb_host_interface * alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( ! alt ) return - ENODEV ;return usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ;}",4147
30,"# line 52 ""dt_test2.pgc""  date date1 ;# line 53 ""dt_test2.pgc""  timestamp ts1 , ts2 ;# line 54 ""dt_test2.pgc""  char * text ;# line 55 ""dt_test2.pgc""  interval * i1 ;# line 56 ""dt_test2.pgc""  date * dc ;# line 57 ""dt_test2.pgc""  int i , j ;","# line 62 ""dt_test2.pgc"" date date1 ;# line 63 ""dt_test2.pgc"" timestamp ts1 , ts2 ;# line 64 ""dt_test2.pgc"" char * text ;# line 65 ""dt_test2.pgc"" interval * i1 ;# line 66 ""dt_test2.pgc"" date * dc ;# line 67 ""dt_test2.pgc"" int i , j ;",4148
31,"ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ;}","ret = TEMP_FAILURE_RETRY ( epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ) ;}",4149
32,"}for ( i = 0 ;ofpact_finish_BUNDLE ( ofpacts , & bundle ) ;if ( ! error ) {","}else {for ( i = 0 ;}ofpact_finish_BUNDLE ( ofpacts , & bundle ) ;if ( ! error ) {",4150
33,"char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;if ( prefix != \'+\' && prefix != \'-\' && prefix != \'=\' ) {yyerror ( ""Logconfig<S2SV_blank>prefix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\\\'+\\\',<S2SV_blank>\\\'-\\\'<S2SV_blank>or<S2SV_blank>\\\'=\\\'\\\}else ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ;}case 216 : # line 1012 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;break ;case 217 : # line 1017 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;case 227 : # line 1048 ""ntp_parser.y""  {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;break ;case 228 : # line 1049 ""ntp_parser.y""  {( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ;break ;case 229 : # line 1054 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ;case 230 : # line 1056 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ;case 231 : # line 1061 ""ntp_parser.y"" {case 233 : # line 1067 ""ntp_parser.y"" {case 234 : # line 1071 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ;case 235 : # line 1072 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;case 236 : # line 1076 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ;case 237 :  # line 1077 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Address_node ) ) ;case 238 :  # line 1082 ""ntp_parser.y""  {","char prefix ;char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ) {case \'+\' : case \'-\' : case \'=\' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;default : prefix = \'=\' ;type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ;( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;case 235 : # line 1082 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;break ;case 236 : # line 1086 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;break ;case 228 : # line 1059 ""ntp_parser.y"" {( yyval . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ;case 237 : # line 1087 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ;case 231 : # line 1071 ""ntp_parser.y"" {case 233 : # line 1077 ""ntp_parser.y"" {case 234 : # line 1081 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ;case 216 : # line 1012 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;case 217 : # line 1017 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;}break ;case 227 : # line 1048 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;case 228 : # line 1049 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ;case 238 : # line 1082 ""ntp_parser.y"" {",4151
34,"case 239 :  # line 1090 ""ntp_parser.y""  {case 240 :  # line 1091 ""ntp_parser.y""  {case 241 :  # line 1095 ""ntp_parser.y""  {case 243 :  # line 1106 ""ntp_parser.y""  {case 244 :  # line 1120 ""ntp_parser.y""  {case 245 :  # line 1124 ""ntp_parser.y""  {case 246 :  # line 1125 ""ntp_parser.y""  {case 247 :  # line 1129 ""ntp_parser.y""  {case 248 :  # line 1130 ""ntp_parser.y""  {case 249 :  # line 1134 ""ntp_parser.y""  {case 250 :  # line 1135 ""ntp_parser.y""  {case 251 :  # line 1140 ""ntp_parser.y""  {case 252 :  # line 1144 ""ntp_parser.y""  {case 253 :  # line 1148 ""ntp_parser.y""  {case 254 :  # line 1152 ""ntp_parser.y""  {case 255 :  # line 1153 ""ntp_parser.y""  {case 256 :  # line 1158 ""ntp_parser.y""  {case 257 :  # line 1162 ""ntp_parser.y""  {case 258 :  # line 1163 ""ntp_parser.y""  {case 259 :  # line 1168 ""ntp_parser.y""  {case 260 :  # line 1170 ""ntp_parser.y""  {case 261 :  # line 1172 ""ntp_parser.y""  {case 262 :  # line 1174 ""ntp_parser.y""  {case 263 :  # line 1176 ""ntp_parser.y""  {# line 3826 ""ntp_parser.c""  default : break ;","case 239 : # line 1090 ""ntp_parser.y"" {case 240 : # line 1091 ""ntp_parser.y"" {case 241 : # line 1095 ""ntp_parser.y"" {case 243 : # line 1106 ""ntp_parser.y"" {case 244 : # line 1120 ""ntp_parser.y"" {case 245 : # line 1124 ""ntp_parser.y"" {case 246 : # line 1125 ""ntp_parser.y"" {case 247 : # line 1129 ""ntp_parser.y"" {case 248 : # line 1100 ""ntp_parser.y"" {case 249 : # line 1101 ""ntp_parser.y"" {case 250 : # line 1105 ""ntp_parser.y"" {case 251 : # line 1134 ""ntp_parser.y"" {case 252 : # line 1135 ""ntp_parser.y"" {case 253 : # line 1139 ""ntp_parser.y"" {case 254 : # line 1140 ""ntp_parser.y"" {case 255 : # line 1144 ""ntp_parser.y"" {case 256 : # line 1145 ""ntp_parser.y"" {case 257 : # line 1150 ""ntp_parser.y"" {case 258 : # line 1154 ""ntp_parser.y"" {case 259 : # line 1158 ""ntp_parser.y"" {case 260 : # line 1162 ""ntp_parser.y"" {case 261 : # line 1163 ""ntp_parser.y"" {case 262 : # line 1168 ""ntp_parser.y"" {case 263 : # line 1172 ""ntp_parser.y"" {# line 3836 ""ntp_parser.c"" default : break ;",4151
35,"blkif -> st_ds_req ++ ;xen_blkif_get ( blkif ) ;if ( err == - EOPNOTSUPP ) {pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\\","struct phys_req preq ;preq . sector_number = req -> u . discard . sector_number ;preq . nr_sects = req -> u . discard . nr_sectors ;err = xen_vbd_translate ( & preq , blkif , WRITE ) ;if ( err ) {pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\\goto fail_response ;}blkif -> st_ds_req ++ ;xen_blkif_get ( blkif ) ;fail_response : if ( err == - EOPNOTSUPP ) {pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\\",4152
36,"blkif -> st_ds_req ++ ;xen_blkif_get ( blkif ) ;if ( err == - EOPNOTSUPP ) {pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\\","struct phys_req preq ;preq . sector_number = req -> u . discard . sector_number ;preq . nr_sects = req -> u . discard . nr_sectors ;err = xen_vbd_translate ( & preq , blkif , WRITE ) ;if ( err ) {pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\\goto fail_response ;}blkif -> st_ds_req ++ ;xen_blkif_get ( blkif ) ;fail_response : if ( err == - EOPNOTSUPP ) {pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\\",4153
37,"int nNew = sizeof ( char * ) * ( iArg + 1 ) ;char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ;if ( ! aNew ) {","sqlite3_int64 nNew = sizeof ( char * ) * ( iArg + 1 ) ;char const * * aNew = ( const char * * ) sqlite3_realloc64 ( ( void * ) aArg , nNew ) ;if ( ! aNew ) {",4154
38,"sprintf ( descriptor -> msg , ""\\\","sprintf ( descriptor -> msg , ""\\\",4155
39,if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  {,if ( field_identifier == SQL_DESC_COUNT && ( intptr_t ) value < 0 ) {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) value != SQL_PARAM_OUTPUT_STREAM ) {,4155
40,"strncpy ( hid -> name , req -> name , 128 ) ;snprintf ( hid -> phys , sizeof ( hid -> phys ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ;","strncpy ( hid -> name , sizeof ( req -> name ) - 1 ) ;snprintf ( hid -> phys , sizeof ( hid -> phys ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ;",4156
41,"handle_t * handle = NULL ;int ret = 0 ;ext4_debug ( ""ext4_get_block_write:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>create<S2SV_blank>flag<S2SV_blank>%d\\\create = EXT4_GET_BLOCKS_IO_CREATE_EXT ;if ( max_blocks > DIO_MAX_BLOCKS ) max_blocks = DIO_MAX_BLOCKS ;ret = ext4_get_blocks ( handle , inode , iblock , max_blocks , bh_result ,  create ) ;}ext4_journal_stop ( handle ) ;","handle_t * handle = ext4_journal_current_handle ( ) ;int ret = 0 ;int started = 0 ;ext4_debug ( ""ext4_get_block_write:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>create<S2SV_blank>flag<S2SV_blank>%d\\\create = EXT4_GET_BLOCKS_IO_CREATE_EXT ;if ( ! handle ) {if ( max_blocks > DIO_MAX_BLOCKS ) max_blocks = DIO_MAX_BLOCKS ;started = 1 ;}ret = ext4_get_blocks ( handle , inode , iblock , max_blocks , bh_result , create ) ;}if ( started ) ext4_journal_stop ( handle ) ;",4157
42,uint32_t backup_handle ;if ( req -> multisample_count != 0 ) return - EINVAL ;,uint32_t backup_handle = 0 ;if ( req -> multisample_count != 0 ) return - EINVAL ;,4158
43,if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE <  res -> backup_size ) {goto out_unlock ;},if ( ret == 0 ) {if ( res -> backup -> base . num_pages * PAGE_SIZE < res -> backup_size ) {goto out_unlock ;}else {backup_handle = req -> buffer_handle ;}},4158
44,"print_int ( ""coded_picture_number"" , frame -> coded_picture_number ) ;print_int ( ""display_picture_number"" , frame -> display_picture_number ) ;print_int ( ""interlaced_frame"" , frame -> interlaced_frame ) ;print_int ( ""top_field_first"" , frame -> top_field_first ) ;print_int ( ""repeat_pict"" , frame -> repeat_pict ) ;if ( frame -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ;else print_str_opt ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ;if ( frame -> colorspace != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ;else print_str_opt ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ;if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED )  print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ;","print_primaries ( w , frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ;",4159
45,"ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ;ret = rtJsonEncStringValue ( pJsonCtxt , utf8str ) ;","ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ;if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ;ret = rtJsonEncStringValue ( pJsonCtxt , utf8str ) ;",4160
46,"
",if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ;,4161
47,"ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num ,  & temp_poc , prev_slice_err ) ;","ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ;",4161
48,proto = EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ndo -> ndo_eflag ) {,"const u_char * bp = p ;if ( length < CHDLC_HDRLEN ) goto trunc ;ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ;proto = EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ndo -> ndo_eflag ) {",4162
49,"case ETHERTYPE_ISO :  if ( * ( p + 1 ) == 0x81 ||  * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;}","case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ;ND_TCHECK_16BITS ( p ) ;if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ;return ndo -> ndo_snapend - bp ;}",4162
50,"if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) return ;}r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ;r_anal_esil_set_pc ( esil , core -> offset ) ;r_anal_esil_parse ( esil , input + 1 ) ;r_anal_esil_dumpstack ( esil ) ;r_anal_esil_stack_free ( esil ) ;break ;case \'s\' : switch ( input [ 1 ] ) {case \'?\' : eprintf ( ""See:<S2SV_blank>ae?~aes\\\break ;case \'l\' : {ut64 pc = r_debug_reg_get ( core -> dbg , ""PC"" ) ;RAnalOp * op = r_core_anal_op ( core , pc ) ;if ( ! op ) {break ;}r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ;r_debug_reg_set ( core -> dbg , ""PC"" , pc + op -> size ) ;r_anal_esil_set_pc ( esil , pc + op -> size ) ;r_core_cmd0 ( core , "".ar*"" ) ;}break ;case \'b\' : if ( ! r_core_esil_step_back ( core ) ) {eprintf ( ""cannnot<S2SV_blank>step<S2SV_blank>back\\\}r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'u\' : if ( input [ 2 ] == \'e\' ) {until_expr = input + 3 ;}else {until_addr = r_num_math ( core -> num , input + 2 ) ;}r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'o\' : op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ;if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) {until_addr = op -> addr + op -> size ;}r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_anal_op_free ( op ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'p\' : n = strchr ( input , \'<S2SV_blank>\' ) ;n1 = n ? strchr ( n + 1 , \'<S2SV_blank>\' ) : NULL ;if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) {eprintf ( ""aesp<S2SV_blank>[offset]<S2SV_blank>[num]\\\break ;}adr = r_num_math ( core -> num , n + 1 ) ;off = r_num_math ( core -> num , n1 + 1 ) ;cmd_aespc ( core , adr , off ) ;break ;case \'<S2SV_blank>\' : n = strchr ( input , \'<S2SV_blank>\' ) ;if ( ! ( n + 1 ) ) {r_core_esil_step ( core , until_addr , until_expr , NULL ) ;break ;}off = r_num_math ( core -> num , n + 1 ) ;cmd_aespc ( core , - 1 , off ) ;break ;default : r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;}break ;case \'c\' : if ( input [ 1 ] == \'?\' ) {r_core_cmd_help ( core , help_msg_aec ) ;}else if ( input [ 1 ] == \'s\' ) {const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ;ut64 newaddr ;int ret ;for ( ;;) {op = r_core_anal_op ( core , addr ) ;if ( ! op ) {break ;}if ( op -> type == R_ANAL_OP_TYPE_SWI ) {eprintf ( ""syscall<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\break ;}if ( op -> type == R_ANAL_OP_TYPE_TRAP ) {eprintf ( ""trap<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\break ;}ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ;r_anal_op_free ( op ) ;op = NULL ;if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) {break ;}if ( ! ret ) break ;r_core_cmd0 ( core , "".ar*"" ) ;newaddr = r_num_get ( core -> num , pc ) ;if ( addr == newaddr ) {addr ++ ;break ;}else {addr = newaddr ;}}if ( op ) {r_anal_op_free ( op ) ;}}else {if ( input [ 1 ] == \'u\' && input [ 2 ] == \'e\' ) until_expr = input + 3 ;else if ( input [ 1 ] == \'u\' ) until_addr = r_num_math ( core -> num , input + 2 ) ;else until_expr = ""0"" ;r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;}break ;case \'i\' : switch ( input [ 1 ] ) {case \'s\' : case \'m\' : cmd_esil_mem ( core , input + 2 ) ;break ;case \'p\' : r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ;break ;case \'?\' : cmd_esil_mem ( core , ""?"" ) ;break ;case \'-\' : if ( esil ) {sdb_reset ( esil -> stats ) ;}r_anal_esil_free ( esil ) ;core -> anal -> esil = NULL ;break ;case 0 : r_anal_esil_free ( esil ) ;{const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ;if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) {r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ;}}if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) {r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ;esil -> verbose = ( int ) r_config_get_i ( core -> config , ""esil.verbose"" ) ;{const char * s = r_config_get ( core -> config , ""cmd.esil.intr"" ) ;if ( s ) {char * my = strdup ( s ) ;if ( my ) {r_config_set ( core -> config , ""cmd.esil.intr"" , my ) ;free ( my ) ;}}}break ;}break ;case \'k\' : switch ( input [ 1 ] ) {case \'\\\\0\' : input = ""123*"" ;case \'<S2SV_blank>\' : if ( esil && esil -> stats ) {char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ;if ( out ) {r_cons_println ( out ) ;free ( out ) ;}}else {eprintf ( ""esil.stats<S2SV_blank>is<S2SV_blank>empty.<S2SV_blank>Run<S2SV_blank>\\\'aei\\\'\\\}break ;case \'-\' : if ( esil ) {sdb_reset ( esil -> stats ) ;}break ;}break ;case \'f\' : {RListIter * iter ;RAnalBlock * bb ;RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ;if ( fcn ) {r_list_foreach ( fcn -> bbs , iter , bb ) {ut64 pc = bb -> addr ;ut64 end = bb -> addr + bb -> size ;RAnalOp op ;ut8 * buf ;int ret , bbs = end - pc ;if ( bbs < 1 || bbs > 0xfffff ) {eprintf ( ""Invalid<S2SV_blank>block<S2SV_blank>size\\\}buf = calloc ( 1 , bbs + 1 ) ;r_io_read_at ( core -> io , pc , buf , bbs ) ;int left ;while ( pc < end ) {left = R_MIN ( end - pc , 32 ) ;r_asm_set_pc ( core -> assembler , pc ) ;ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ;if ( ret ) {r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ;r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ;r_anal_esil_dumpstack ( esil ) ;r_anal_esil_stack_free ( esil ) ;pc += op . size ;}else {pc += 4 ;}}}}else {eprintf ( ""Cannot<S2SV_blank>find<S2SV_blank>function<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\}}break ;case \'t\' : switch ( input [ 1 ] ) {case \'r\' : {RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ;if ( ! esil )  return ;","
",4163
51,struct dentry * res ;if ( nd -> flags & LOOKUP_CREATE ) {,struct dentry * res ;fmode_t fmode = nd -> intent . open . flags & ( FMODE_READ | FMODE_WRITE | FMODE_EXEC ) ;if ( nd -> flags & LOOKUP_CREATE ) {,4164
52,"state = nfs4_do_open ( dir , & path , nd -> intent . open . flags , & attr , cred ) ;put_rpccred ( cred ) ;","state = nfs4_do_open ( dir , & path , fmode , nd -> intent . open . flags , & attr , cred ) ;put_rpccred ( cred ) ;",4164
53,"nfs4_intent_set_file ( nd , & path , state ) ;return res ;","nfs4_intent_set_file ( nd , & path , state , fmode ) ;return res ;",4164
54,"static inline bool unconditional ( const struct arpt_arp * arp )  {return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ;}","static inline bool unconditional ( const struct arpt_entry * e ) {return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> arp , & uncond , sizeof ( uncond ) ) == 0 ;}",4165
55,"if ( clone_flags & CLONE_SETTLS )  thread -> tp_value = childregs -> ARM_r3 ;thread_notify ( THREAD_NOTIFY_COPY , thread ) ;","if ( clone_flags & CLONE_SETTLS ) thread -> tp_value [ 0 ] = childregs -> ARM_r3 ;thread -> tp_value [ 1 ] = get_tpuser ( ) ;thread_notify ( THREAD_NOTIFY_COPY , thread ) ;",4166
56,"if ( options_file ( configuration_file , type , & section ) )  return 1 ;if ( init_section ( 1 , & section ) )   return 1 ;s_log ( LOG_NOTICE , ""Configuration<S2SV_blank>successful"" ) ;","if ( options_file ( configuration_file , type , & section ) || init_section ( 1 , & section ) ) {s_log ( LOG_ERR , ""Configuration<S2SV_blank>failed"" ) ;options_free ( 0 ) ;return 1 ;}s_log ( LOG_NOTICE , ""Configuration<S2SV_blank>successful"" ) ;",4167
57,"int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy )  {if ( policy -> version != 0 ) return - EINVAL ;","int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy ) {if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;if ( policy -> version != 0 ) return - EINVAL ;",4168
58,nName ++ ;if ( zName == 0 ) {}},if ( zName == 0 ) {}nName = ( int ) strlen ( zName ) ;},4169
59,"_sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) ;if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {_sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\\\'t<S2SV_blank>offer"" , mech ) ;","_sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK ;if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {_sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\\\'t<S2SV_blank>offer"" , mech ) ;",4170
60,"
",if ( shm_file == NULL ) {err = - EIDRM ;goto out_unlock0 ;},4171
61,if ( is_file_hugepages ( shm_file ) )  goto out_unlock0 ;,if ( is_file_hugepages ( shm_file ) ) goto out_unlock0 ;,4171
62,"if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) {log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ;","if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS ) {log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ;",4172
63,"if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) )  {","if ( g_settings_privatereports ) {struct stat statbuf ;if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) {error_msg ( ""Path<S2SV_blank>\\\'%s\\\'<S2SV_blank>isn\\\'t<S2SV_blank>directory"" , dirname ) ;return 404 ;}struct group * gr = getgrnam ( ""abrt"" ) ;if ( ! gr ) {error_msg ( ""Group<S2SV_blank>\\\'abrt\\\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ;return 500 ;}if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) {error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\\\'%s\\\'<S2SV_blank>isn\\\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access"" , dirname ) ;return 403 ;}struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ;const bool complete = dd && problem_dump_dir_is_complete ( dd ) ;dd_close ( dd ) ;if ( complete ) {error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\\\'%s\\\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed"" , dirname ) ;return 403 ;}}else if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) ) {",4173
64,"if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) )   return psf_fread ( ptr , 1 , bytes , psf ) ;if ( psf -> headindex + bytes > SIGNED_SIZEOF ( psf -> header ) )  {most = SIGNED_SIZEOF ( psf -> header ) - psf -> headend ;psf_fread ( psf -> header + psf -> headend , 1 , most , psf ) ;memcpy ( ptr , psf -> header + psf -> headend , most ) ;psf -> headend = psf -> headindex += most ;psf_fread ( ( char * ) ptr + most , bytes - most , 1 , psf ) ;return bytes ;};if ( psf -> headindex + bytes > psf -> headend )   {count = psf_fread ( psf -> header + psf -> headend , 1 , bytes - ( psf -> headend - psf -> headindex ) , psf ) ;if ( count != bytes - ( int ) ( psf -> headend - psf -> headindex ) )  {psf -> headend += count ;}memcpy ( ptr , psf -> header + psf -> headindex , bytes ) ;psf -> headindex += bytes ;return bytes ;","if ( psf -> header . indx + bytes >= psf -> header . len && psf_bump_header_allocation ( psf , bytes ) ) return count ;if ( psf -> headindex + bytes > SIGNED_SIZEOF ( psf -> header ) ) {most = SIGNED_SIZEOF ( psf -> header . indx + bytes > psf -> headend ) {count = psf_fread ( psf -> header . ptr + psf -> headend , 1 , bytes - ( psf -> headend - psf -> headindex ) , psf ) ;if ( count != bytes - ( int ) ( psf -> headend - psf -> headindex ) ) {psf -> headend += count ;}memcpy ( ptr , psf -> header + psf -> header . indx , bytes ) ;psf -> header . indx += bytes ;return bytes ;",4174
65,"or_circuit_t * or_circ = NULL ;const or_options_t * options = get_options ( ) ;if ( ! CIRCUIT_IS_ORIGIN ( circ ) )   or_circ = TO_OR_CIRCUIT ( circ ) ;relay_header_unpack ( & rh , cell -> payload ) ;","or_circuit_t * or_circ = NULL ;origin_circuit_t * origin_circ = NULL ;crypt_path_t * layer_hint = NULL ;const or_options_t * options = get_options ( ) ;if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) {or_circ = TO_OR_CIRCUIT ( circ ) ;}else {tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ;origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ;layer_hint = origin_circ -> cpath -> prev ;}relay_header_unpack ( & rh , cell -> payload ) ;",4175
66,"relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , layer_hint ) ;return 0 ;",4175
67,"relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_NOTDIRECTORY , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_NOTDIRECTORY , layer_hint ) ;return 0 ;",4175
68,"relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_INTERNAL , NULL ) ;return 0 ;relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_EXITPOLICY , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_INTERNAL , layer_hint ) ;return 0 ;relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , layer_hint ) ;return 0 ;",4175
69,"origin_circuit_t * origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ;log_info ( LD_REND , ""begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream."" ) ;","tor_assert ( origin_circ ) ;log_info ( LD_REND , ""begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream."" ) ;",4175
70,"relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_DONE ,  origin_circ -> cpath -> prev ) ;connection_free ( TO_CONN ( n_stream ) ) ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_DONE , layer_hint ) ;connection_free ( TO_CONN ( n_stream ) ) ;",4175
71,"for ( i = 0 ;data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ;assert ( data [ i ] ) ;","assert ( jas_image_numcmpts ( image ) ;++ i ) {data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) <= 3 ) ;for ( i = 0 ;i < 3 ;++ i ) {data [ i ] = 0 ;}for ( i = 0 ;if ( ! ( data [ i ] ) ;",4176
72,return - 1 ;}z = ( z << 8 ) | c ;nz += 8 ;,goto error ;}z = ( z << 8 ) | c ;nz += 8 ;,4176
73,return - 1 ;return - 1 ;,goto error ;goto error ;,4176
74,"
",data [ i ] = 0 ;error : for ( i = 0 ;i < 3 ;++ i ) {if ( data [ i ] ) {jas_matrix_destroy ( data [ i ] ) ;}}return - 1 ;,4176
75,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",4177
76,struct cpuinfo_x86 * c ;cpu = iminor ( file -> f_path . dentry -> d_inode ) ;,struct cpuinfo_x86 * c ;if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ;cpu = iminor ( file -> f_path . dentry -> d_inode ) ;,4178
77,"ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ;if ( credssp -> server ) {","SecInvalidateHandle ( & credssp -> context ) ;ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ;if ( credssp -> server ) {",4179
78,"rc = fuse_dev_release ( inode , file ) ;return rc ;","fuse_conn_put ( & cc -> fc ) ;rc = fuse_dev_release ( inode , file ) ;return rc ;",4180
79,return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;},"scat = & rm -> data . op_sg [ sg ] ;ret = sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ;return ret ;}",4181
80,"static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) {char buf [ 512 ] ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;if ( level > svc_ctx -> log_level ) {","static int svc_log ( SvcContext * svc_ctx , SVC_LOG_LEVEL level , const char * fmt , ... ) {char buf [ 512 ] ;SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;if ( level > svc_ctx -> log_level ) {",4182
81,new_timer -> it_overrun = - 1 ;if ( event ) {,new_timer -> it_overrun = - 1LL ;if ( event ) {,4183
82,int  c ;,MagickBooleanType status ;int c ;,4184
83,"for ( i = 2 ;# if 0 fprintf ( stderr , ""DEBUG:<S2SV_blank>Concatenate<S2SV_blank>Image:<S2SV_blank>\\\\""%s\\\\""\\\# endif input = fopen_utf8 ( argv [ i ] , ""rb"" ) ;c = fgetc ( input ) )  ( void ) fputc ( ( char ) c , output ) ;( void ) fclose ( input ) ;( void ) remove_utf8 ( argv [ i ] ) ;return ( MagickTrue ) ;}","status = MagickTrue ;for ( i = 2 ;input = fopen_utf8 ( argv [ i ] , ""rb"" ) ;c = fgetc ( input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ;( void ) fclose ( input ) ;( void ) fclose ( input ) ;( void ) remove_utf8 ( argv [ i ] ) ;return ( MagickTrue ) ;}",4184
84,assert ( 0 ) ;return NULL ;,return NULL ;,4185
85,"priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ;if ( ! priv -> base ) {","if ( ! r ) return - EINVAL ;priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ;if ( ! priv -> base ) {",4186
86,"ret = poll ( & pfd , 1 , 1 ) ;BTIF_TRACE_VERBOSE ( ""%s()<S2SV_blank>-<S2SV_blank>polling<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>revents:<S2SV_blank>0x%x,<S2SV_blank>ret<S2SV_blank>%d"" , __FUNCTION__ , pfd . fd , pfd . revents , ret ) ;if ( ret <= 0 ) {read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ;}","ret = TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 1 ) ) ;BTIF_TRACE_VERBOSE ( ""%s()<S2SV_blank>-<S2SV_blank>polling<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>revents:<S2SV_blank>0x%x,<S2SV_blank>ret<S2SV_blank>%d"" , __FUNCTION__ , pfd . fd , pfd . revents , ret ) ;TEMP_FAILURE_RETRY ( if ( ret <= 0 ) {read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ) ;}",4187
87,int i ;int j ;,jas_matind_t i ;jas_matind_t j ;,4188
88,"void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {","static void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {",4189
89,"if ( report -> id == REPORT_KEY_STATE ) {if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ;","if ( size > 64 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\\return 0 ;}if ( report -> id == REPORT_KEY_STATE ) {if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ;",4190
90,"vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;find_next_key_frame ( cpi , & this_frame_copy ) ;","memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;find_next_key_frame ( cpi , & this_frame_copy ) ;",4191
91,"vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;define_gf_group ( cpi , & this_frame_copy ) ;vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;","memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;define_gf_group ( cpi , & this_frame_copy ) ;memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;",4191
92,"vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;","memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;",4191
93,"Stream_Read_UINT16 ( s , iconInfo -> cbBitsMask ) ;Stream_Read_UINT16 ( s , iconInfo -> cbBitsColor ) ;if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsMask + iconInfo -> cbBitsColor )  return FALSE ;newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsMask , iconInfo -> cbBitsMask ) ;if ( ! newBitMask ) {free ( iconInfo -> bitsMask ) ;iconInfo -> bitsMask = NULL ;return FALSE ;}iconInfo -> bitsMask = newBitMask ;if ( ! iconInfo -> colorTable ) return FALSE ;","Stream_Read_UINT16 ( s , iconInfo -> cbBitsMask ) return FALSE ;if ( ! iconInfo -> colorTable ) {if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbColorTable ) return FALSE ;return FALSE ;}",4192
94,"if ( iconInfo -> colorTable )  Stream_Read ( s , iconInfo -> colorTable , iconInfo -> cbColorTable ) ;newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ;if ( ! newBitMask ) {Stream_Read ( s , iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ;return TRUE ;","if ( iconInfo -> colorTable ) Stream_Read ( s , iconInfo -> colorTable , iconInfo -> cbColorTable ) ;newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ;if ( ! newBitMask ) {if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsColor ) return FALSE ;Stream_Read ( s , iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ;return TRUE ;",4192
95,meshdrlen = extract_mesh_header_length ( p + hdrlen ) ;hdrlen += meshdrlen ;,"if ( caplen < hdrlen + 1 ) {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return hdrlen ;}meshdrlen = extract_mesh_header_length ( p + hdrlen ) ;hdrlen += meshdrlen ;",4193
96,"return - EACCES ;err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;}else if ( opcode == BPF_MOV ) {if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( insn -> imm != 0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ;if ( err ) return err ;}else {if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}}err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ;regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ;}else {if ( is_pointer_value ( env , insn -> src_reg ) ) {verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\return - EACCES ;}mark_reg_unknown ( env , regs , insn -> dst_reg ) ;regs [ insn -> dst_reg ] . var_off = tnum_cast (  regs [ insn -> dst_reg ] . var_off , 4 ) ;__update_reg_bounds ( & regs [ insn -> dst_reg ] ) ;}","coerce_reg_to_size ( & regs [ insn -> dst_reg ] , 4 ) ;",4194
97,skcipher -> setkey = alg -> setkey ;skcipher -> encrypt = alg -> encrypt ;,skcipher -> setkey = skcipher_setkey ;skcipher -> encrypt = alg -> encrypt ;,4195
98,"void vp9_fwht4x4_c ( const int16_t * input , int16_t * output , int stride ) {int i ;int a1 , b1 , c1 , d1 , e1 ;const int16_t * ip = input ;int16_t * op = output ;for ( i = 0 ;a1 = ip [ 0 * stride ] ;b1 = ip [ 1 * stride ] ;c1 = ip [ 2 * stride ] ;d1 = ip [ 3 * stride ] ;a1 += b1 ;op [ 0 ] = a1 ;op [ 4 ] = c1 ;op [ 8 ] = d1 ;op [ 12 ] = b1 ;ip ++ ;","void vp9_fwht4x4_c ( const int16_t * input , tran_low_t * output , int stride ) {int i ;tran_high_t a1 , b1 , c1 , d1 , e1 ;const int16_t * ip_pass0 = input ;int16_t * op = output ;for ( i = 0 ;a1 = ip_pass0 [ 0 * stride ] ;b1 = ip_pass0 [ 1 * stride ] ;c1 = ip_pass0 [ 2 * stride ] ;d1 = ip_pass0 [ 3 * stride ] ;a1 += b1 ;op [ 0 ] = ( tran_low_t ) a1 ;op [ 4 ] = ( tran_low_t ) c1 ;op [ 8 ] = ( tran_low_t ) d1 ;op [ 12 ] = ( tran_low_t ) b1 ;ip_pass0 ++ ;",4196
99,op [ 0 ] = a1 * UNIT_QUANT_FACTOR ;op [ 1 ] = c1 * UNIT_QUANT_FACTOR ;op [ 2 ] = d1 * UNIT_QUANT_FACTOR ;op [ 3 ] = b1 * UNIT_QUANT_FACTOR ;ip += 4 ;,op [ 0 ] = ( tran_low_t ) ( a1 * UNIT_QUANT_FACTOR ) ;op [ 1 ] = ( tran_low_t ) ( c1 * UNIT_QUANT_FACTOR ) ;op [ 2 ] = ( tran_low_t ) ( d1 * UNIT_QUANT_FACTOR ) ;op [ 3 ] = ( tran_low_t ) ( b1 * UNIT_QUANT_FACTOR ) ;ip += 4 ;,4196
100,"struct sock * sk ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;","struct sock * sk ;if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;",4197
101,"if ( keyring ) {if ( keyring -> restrict_link ) return - EPERM ;link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ;}mutex_lock ( & key_construction_mutex ) ;if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {atomic_inc ( & key -> user -> nikeys ) ;key -> reject_error = - error ;smp_wmb ( ) ;",if ( key -> state == KEY_IS_UNINSTANTIATED ) {atomic_inc ( & key -> user -> nikeys ) ;key -> reject_error = - error ;smp_wmb ( ) ;,4198
102,"
","if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ;",4199
103,"if ( current_entry + n > ( int ) c -> entries ) {memset ( lengths + current_entry , current_length , n ) ;","if ( current_entry + n > ( int ) c -> entries ) {memset ( lengths + current_entry , current_length , n ) ;",4199
104,"c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ;}","int values = lookup1_values ( c -> entries , c -> dimensions ) ;if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ;c -> lookup_values = ( uint32 ) values ;}",4199
105,g -> values = 2 ;,"g -> values - 1 ;++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ;for ( j = 0 ;j < g -> values = 2 ;",4199
106,for ( j = 0 ;++ j )  g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;,for ( j = 0 ;+ j )  g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;++ j ) g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;,4199
107,"
","if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup ) ;",4199
108,"m -> coupling_steps = get_bits ( f , 8 ) + 1 ;for ( k = 0 ;","m -> coupling_steps = get_bits ( f , 8 ) + 1 ;for ( k = 0 ;",4199
109,"for ( i = 0 ;i ++ )  av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;return 0 ;}","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;}return 0 ;}",4200
110,"int kb ;kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ;if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ;","int kb , r ;kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ;r = vt_verify_kbmode ( fd ) ;if ( r == - EBUSY ) {log_debug_errno ( r , ""Keyboard<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>XLATE<S2SV_blank>or<S2SV_blank>UNICODE<S2SV_blank>mode,<S2SV_blank>not<S2SV_blank>resetting:<S2SV_blank>%m"" ) ;return 0 ;}else if ( r < 0 ) return r ;if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ;",4201
111,"ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;","struct floppy_raw_cmd cmd = * ptr ;cmd . next = NULL ;cmd . kernel_data = NULL ;ret = copy_to_user ( param , & cmd , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;",4202
112,if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] )  return - EINVAL ;,if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) return - EINVAL ;,4203
113,"if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) )  return 0 ;if ( ! ( mask & MAY_WRITE ) )  if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) )  return 0 ;if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) )  if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) )  return 0 ;if ( mask == MAY_READ )  if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) )  return 0 ;","if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_OVERRIDE ) ) return 0 ;if ( ! ( mask & MAY_WRITE ) ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ;if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_OVERRIDE ) ) return 0 ;if ( mask == MAY_READ ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ;",4204
114,"if ( token == NULL ) return ERROR_INVALID_SYNTAX ;if ( osIsdigit ( token [ 0 ] ) ) {if ( osStrlen ( token ) == 8 && token [ 2 ] == \'-\' && token [ 5 ] == \'-\' ) {dirEntry -> modified . month = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ;","if ( osStrstr ( token , NULL , 10 ) ;",4205
115,"if ( strstr ( token , ""PM"" ) != NULL )  dirEntry -> modified . hours += 12 ;else  {","if ( strstr ( token , ""PM"" ) != NULL ) {dirEntry -> modified . hours += 12 ;}else {",4205
116,"if ( strchr ( token , \'d\' ) != NULL )  dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ;if ( strchr ( token , \'w\' ) == NULL )  dirEntry -> attributes |= FTP_FILE_ATTR_READ_ONLY ;token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ;if ( token == NULL ) return ERROR_INVALID_SYNTAX ;","if ( osStrchr ( token , \'d\' ) != NULL ) {dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ;}if ( osStrchr ( token , \'w\' ) == NULL ) {dirEntry -> attributes |= FTP_FILE_ATTR_READ_ONLY ;}token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ;if ( token == NULL ) return ERROR_INVALID_SYNTAX ;",4205
117,"while ( tmp && alen < tmp ) {ND_PRINT ( ( ndo , ""\\\","while ( tmp && alen < tmp ) {ND_TCHECK2 ( * tptr , alen ) ;ND_PRINT ( ( ndo , ""\\\",4206
118,"char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ;char * mask_decoded5 ;mask_decoded = NULL ;mask_decoded2 = NULL ;mask2 = weechat_string_replace ( mask , dir_separator , ""\\\\01"" ) ;if ( ! mask2 ) goto end ;mask_decoded = weechat_buffer_string_replace_local_var ( buffer , mask2 ) ;if ( ! mask_decoded ) goto end ;mask_decoded2 = weechat_string_replace ( mask_decoded , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ;if ( ! mask_decoded2 ) goto end ;# ifdef __CYGWIN__ mask_decoded3 = weechat_string_replace ( mask_decoded2 , ""\\\\\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ;# else mask_decoded3 = strdup ( mask_decoded2 ) ;# endif if ( ! mask_decoded3 ) goto end ;mask_decoded4 = weechat_string_replace ( mask_decoded3 , ""\\\\01"" , dir_separator ) ;if ( ! mask_decoded4 ) goto end ;length = strlen ( mask_decoded4 ) + 256 + 1 ;mask_decoded5 = malloc ( length ) ;if ( ! mask_decoded5 )  goto end ;mask_decoded5 [ 0 ] = \'\\\\0\' ;strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ;if ( weechat_config_boolean ( logger_config_file_name_lower_case ) )  weechat_string_tolower ( mask_decoded5 ) ;if ( weechat_logger_plugin -> debug ) {weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) ,  mask , mask_decoded5 ) ;}if ( mask_decoded )   free ( mask_decoded ) ;if ( mask_decoded2 )  free ( mask_decoded2 ) ;if ( mask_decoded3 )  free ( mask_decoded3 ) ;if ( mask_decoded4 )  free ( mask_decoded4 ) ;return mask_decoded5 ;}","char * mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 ;mask3 = NULL ;mask4 = NULL ;mask5 = NULL ;mask6 = NULL ;mask7 = NULL ;mask_decoded2 = NULL ;length = strlen ( mask ) + 256 + 1 ;mask_decoded5 = malloc ( length ) ;if ( ! mask_decoded5 ) goto end ;mask_decoded5 [ 0 ] = \'\\\\0\' ;strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) == 0 ) mask2 [ 0 ] = \'\\\\0\' ;mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\\\01"" ) ;if ( ! mask3 ) goto end ;mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ;if ( ! mask4 ) goto end ;mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ;if ( ! mask5 ) goto end ;# ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ;# else mask6 = strdup ( mask5 ) ;# endif if ( ! mask6 ) goto end ;mask7 = weechat_string_replace ( mask6 , ""\\\\01"" , dir_separator ) ;if ( ! mask7 ) goto end ;if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) weechat_string_tolower ( mask7 ) ;if ( weechat_logger_plugin -> debug ) {weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) , mask , mask7 ) ;}if ( mask3 ) free ( mask_decoded ) ;if ( mask_decoded2 ) free ( mask3 ) ;if ( mask4 ) free ( mask_decoded3 ) ;if ( mask_decoded4 ) free ( mask6 ) ;return mask7 ;}",4207
119,"r_set_size ( op , size ) ;push ( 2 ) ;r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ;op1 -> value . bytes = ptr + size ;r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ;make_true ( op ) ;",op -> tas . rsize = size ;push ( 2 ) ;op [ - 3 ] . value . bytes ) ;op1 -> value . bytes = ptr + size ;if ( forward ) {op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ;op [ - 3 ] . tas . rsize = count ;}else {op [ - 1 ] . tas . rsize = count ;op [ - 3 ] . tas . rsize -= count + size ;}make_true ( op ) ;,4208
120,"char * method = manager -> method ;int i ;build_config ( working_dir , server ) ;if ( server -> method ) method = server -> method ;snprintf ( cmd , BUF_SIZE ,  ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" ,   executable , method , manager -> manager_address ,   working_dir , server -> port , working_dir , server -> port ) ;if ( manager -> acl != NULL ) {","int i ;int port ;port = atoi ( server -> port ) ;build_config ( working_dir , manager , server ) ;snprintf ( cmd , BUF_SIZE , ""%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf"" , executable , method , manager -> manager_address , working_dir , port , working_dir , server -> port ) ;if ( manager -> acl != NULL ) {",4209
121,"struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ;struct sock * sk = sock -> sk ;int chan = sa -> rc_channel ;int err = 0 ;BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa -> rc_bdaddr ) ;lock_sock ( sk ) ;if ( sk -> sk_state != BT_OPEN ) {err = - EBADFD ;goto done ;}if ( sk -> sk_type != SOCK_STREAM ) {err = - EINVAL ;goto done ;}write_lock ( & rfcomm_sk_list . lock ) ;if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) {err = - EADDRINUSE ;bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ;rfcomm_pi ( sk ) -> channel = chan ;sk -> sk_state = BT_BOUND ;","struct sockaddr_rc sa ;struct sock * sk = sock -> sk ;int chan = sa -> rc_channel ;int err = 0 ;memset ( & sa , 0 , sizeof ( sa ) ) ;len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ;memcpy ( & sa , addr , len ) ;BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa . rc_bdaddr ) ;lock_sock ( sk ) ;if ( sa . rc_channel && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) {err = - EADDRINUSE ;bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ;rfcomm_pi ( sk ) -> channel = chan ;sk -> sk_state = BT_BOUND ;",4210
122,"int open_debug_log ( void ) {if ( verify_config || test_scheduling == TRUE ) return OK ;if ( ( debug_file_fp = fopen ( debug_file , ""a+"" ) ) == NULL )  return ERROR ;( void ) fcntl ( fileno ( debug_file_fp ) , F_SETFD , FD_CLOEXEC ) ;return OK ;","int open_debug_log ( void ) {int fh ;struct stat st ;if ( verify_config || test_scheduling == TRUE ) return OK ;if ( ( fh = open ( debug_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) return ERROR ;if ( ( fstat ( fh , & st ) ) == - 1 ) {debug_file_fp = NULL ;close ( fh ) ;return ERROR ;}if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) {debug_file_fp = NULL ;close ( fh ) ;return ERROR ;}if ( ( debug_file_fp = fdopen ( fh , ""a+"" ) ) == NULL ) return ERROR ;( void ) fcntl ( fh , F_SETFD , FD_CLOEXEC ) ;return OK ;",4211
123,if ( gf -> file && gf -> file -> device )   free ( gf -> file -> device -> disk ) ;free ( gf -> file ) ;,if ( gf -> file && gf -> file -> device ) {free ( gf -> file -> device -> disk ) ;}free ( gf -> file ) ;,4212
124,"unsigned char * data = packet -> data + packet -> size ;unsigned short type = attrtype ;unsigned short len = data_len ;if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) {fprintf ( stderr , _ ( ""mndp_add_attribute:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\","unsigned char * data = packet -> data + packet -> size ) {fprintf ( stderr , _ ( ""mndp_add_attribute:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\",4213
125,if ( data -> instance_id_fd != - 1 )  drop_cloexec ( data -> instance_id_fd ) ;sigemptyset ( & set ) ;,if ( data -> instance_id_fd ) ;if ( data -> env_fd != - 1 ) drop_cloexec ( data -> env_fd != - 1 ) drop_cloexec ( data -> instance_id_fd ) ;sigemptyset ( & set ) ;,4214
126,"cifs_small_buf_release ( req ) ;rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ;free_rsp_buf ( resp_buftype , rsp ) ;return rc ;","rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ;cifs_small_buf_release ( req ) ;free_rsp_buf ( resp_buftype , rsp ) ;return rc ;",4215
127,return ms ;free : free ( ms ) ;,ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;return ms ;free : free ( ms ) ;,4216
128,"if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) {absolute_filename = g_strdup ( filename ) ;",if ( g_path_is_absolute ( filename ) ) {absolute_filename = g_strdup ( filename ) ;,4217
129,return error ;},return error < 0 ? error : 0 ;},4218
130,}else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) )   ses -> server -> ops = & smb311_operations ;},ses -> server -> vals = & smb21_values ;}else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) {ses -> server -> ops = & smb311_operations ;ses -> server -> vals = & smb311_values ;}},4219
131,"static vpx_codec_err_t ctrl_update_entropy ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {const int update = va_arg ( args , int ) ;","static vpx_codec_err_t ctrl_update_entropy ( vpx_codec_alg_priv_t * ctx , va_list args ) {const int update = va_arg ( args , int ) ;",4220
132,int is_udplite = IS_UDPLITE ( sk ) ;int is_udp4 ;,bool checksum_valid = false ;int is_udplite = IS_UDPLITE ( sk ) ;int is_udp4 ;,4221
133,"if ( udp_lib_checksum_complete ( skb ) )  goto csum_copy_err ;if ( skb_csum_unnecessary ( skb ) )  err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;","checksum_valid = ! udp_lib_checksum_complete ( skb ) ;if ( ! checksum_valid ) goto csum_copy_err ;if ( checksum_valid || skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;",4221
134,"if ( ! pflag ) ( void ) umask ( mask ) ;if ( argc != 1 ) {run_err ( ""ambiguous<S2SV_blank>target"" ) ;exit ( 1 ) ;}targ = * argv ;if ( targetshouldbedirectory ) verifydir ( targ ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ;for ( first = 1 ;;first = 0 ) {cp = buf ;if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ;if ( * cp ++ == \'\\\do {if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ;* cp ++ = ch ;}while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != \'\\\* cp = 0 ;if ( verbose_mode ) fprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ;if ( buf [ 0 ] == \'\\\\01\' || buf [ 0 ] == \'\\\\02\' ) {if ( iamremote == 0 ) ( void ) atomicio ( vwrite , STDERR_FILENO , buf + 1 , strlen ( buf + 1 ) ) ;if ( buf [ 0 ] == \'\\\\02\' ) exit ( 1 ) ;++ errs ;continue ;}if ( buf [ 0 ] == \'E\' ) {( void ) atomicio ( vwrite , remout , """" , 1 ) ;return ;}if ( ch == \'\\\cp = buf ;if ( * cp == \'T\' ) {setimes ++ ;cp ++ ;mtime . tv_sec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;mtime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;atime . tv_sec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;atime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'\\\\0\' ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;continue ;}if ( * cp != \'C\' && * cp != \'D\' ) {if ( first ) {run_err ( ""%s"" , cp ) ;exit ( 1 ) ;}SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ;}mode = 0 ;for ( ++ cp ;cp < buf + 5 ;cp ++ ) {if ( * cp < \'0\' || * cp > \'7\' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ;mode = ( mode << 3 ) | ( * cp - \'0\' ) ;}if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ;for ( size = 0 ;isdigit ( * cp ) ;) size = size * 10 + ( * cp ++ - \'0\' ) ;if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ( strchr ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;","+ errs ;if ( * cp == \'\\\\0\' || strchr ( cp , ""."" ) == 0 || strcmp ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;",4222
135,uint32_t len ;uint32_t n ;,uint32_t n ;,4223
136,"n = r -> iov . iov_len / 512 ;r -> sector += n ;len = r -> sector_count * 512 ;if ( len > SCSI_DMA_BUF_SIZE ) {len = SCSI_DMA_BUF_SIZE ;r -> iov . iov_len = len ;DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\\scsi_req_data ( & r -> req , len ) ;}","n = r -> qiov . size / 512 ;r -> sector += n ;scsi_init_iovec ( r ) ;DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\\scsi_req_data ( & r -> req , len ) ;",4223
137,"data = malloc ( blk_sz * n_blks ) ;memset ( data , 0 , blk_sz * n_blks ) ;","data = safe_calloc ( blk_sz * n_blks ) ;memset ( data , 0 , blk_sz * n_blks ) ;",4224
138,if ( current -> mm )  __flush_tlb_one ( start ) ;else   leave_mm ( smp_processor_id ( ) ) ;},if ( current -> mm ) {__flush_tlb_one ( start ) ;}else {leave_mm ( smp_processor_id ( ) ) ;smp_mb ( ) ;}},4225
139,"if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete )  return ERROR_INVALID_PARAMETER ;file = drive_get_file_by_id ( drive , irp -> FileId ) ;if ( ! file ) {else if ( ! drive_file_seek ( file , Offset ) ) {irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ;Length = 0 ;}else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) )  {","void * ptr ;if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) return ERROR_INVALID_PARAMETER ;ptr = Stream_Pointer ( irp -> input ) ;if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ;file = drive_get_file_by_id ( drive , irp -> FileId ) ;if ( ! file ) {else if ( ! drive_file_seek ( file , ptr , Length ) ) {",4226
140,if ( border < 0 ) {return ;,if ( border < 0 || color < 0 ) {return ;,4227
141,uint8_t * result ;new_raw_len = RAW_DATA_LEN ( header ) + nbytes ;,uint8_t * result ;if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) {return NULL ;}new_raw_len = RAW_DATA_LEN ( header ) + nbytes ;,4228
142,"return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ;}","struct dm_dev * dev = lc -> dev ;int r = 0 ;if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ;}",4229
143,"return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ;}","return segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ;}",4230
144,"savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds | prev -> ds ) )  loadsegment ( ds , next -> ds ) ;savesegment ( fs , fsindex ) ;","savesegment ( fs , fsindex ) ;savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds ) ;",4231
145,if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) )  return - ENXIO ;,"if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ;",4232
146,goto fail ;},ret = - EINVAL ;goto fail ;},4233
147,"pipe_buf_get ( ipipe , ibuf ) ;* obuf = * ibuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}* obuf = * ibuf ;",4234
148,"struct sas_task * task = TO_SAS_TASK ( cmd ) ;sas_end_task ( cmd , task ) ;scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ;}","struct domain_device * dev = cmd_to_domain_dev ( cmd ) ;struct sas_task * task = TO_SAS_TASK ( cmd ) ;sas_end_task ( cmd , task ) ;if ( dev_is_sata ( dev ) ) {list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ;return ;}scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ;}",4235
149,int pkt_len ;char line [ COSINE_LINE_LENGTH ] ;,char line [ COSINE_LINE_LENGTH ] ;,4236
150,"pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err ,  err_info ) ;","return parse_cosine_packet ( wth -> random_fh , phdr , pkt_len , buf , err , err_info ) ;",4236
151,"args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return xdr_argsize_check ( rqstp , p ) ;}","if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return 1 ;}",4237
152,rx_drop :  kfree_skb ( skb ) ;rcv_stats -> rx_dropped ++ ;,rx_drop : rcv_stats -> rx_dropped ++ ;,4238
153,int lineno ;int col_offset ;,string type_comment ;int lineno ;int col_offset ;,4239
154,"res = obj2ast_expr ( tmp , & annotation , arena ) ;if ( res != 0 ) goto failed ;","res = obj2ast_expr ( tmp , & annotation , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;",4239
155,"* out = arg ( arg , annotation , lineno , col_offset , end_lineno , end_col_offset ,  arena ) ;","* out = arg ( arg , annotation , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4239
156,"
","memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;",4240
157,"cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ;memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ;","cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ;memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ;",4240
158,"static vpx_codec_err_t decoder_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) {const uint8_t * data_end = data + data_sz ;vpx_codec_err_t res = VPX_CODEC_OK ;uint32_t sizes [ 8 ] ;int frames_this_pts , frame_count = 0 ;if ( data == NULL || data_sz == 0 )   return VPX_CODEC_INVALID_PARAM ;parse_superframe_index ( data , data_sz , sizes , & frames_this_pts ) ;do {if ( data_sz && ( * data_start & 0xe0 ) == 0xc0 ) {const uint8_t marker = * data_start ;const uint32_t frames = ( marker & 0x7 ) + 1 ;const uint32_t mag = ( ( marker >> 3 ) & 0x3 ) + 1 ;const uint32_t index_sz = 2 + mag * frames ;if ( data_sz >= index_sz && data_start [ index_sz - 1 ] == marker ) {data_start += index_sz ;data_sz -= index_sz ;if ( data_start < data_end ) continue ;else break ;}}if ( frames_this_pts ) {uint32_t this_sz = sizes [ frame_count ] ;if ( data_sz < this_sz ) {ctx -> base . err_detail = ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ;data_sz = this_sz ;frame_count ++ ;res = decode_one ( ctx , & data_start , data_sz , user_priv , deadline ) ;assert ( data_start >= data ) ;assert ( data_start <= data_end ) ;if ( res ) break ;while ( data_start < data_end && * data_start == 0 ) data_start ++ ;data_sz = ( unsigned int ) ( data_end - data_start ) ;while ( data_start < data_end ) ;","static vpx_codec_err_t decoder_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * const data , unsigned int data_sz , void * user_priv , long deadline ) {const uint8_t * data_end = data + data_sz ;vpx_codec_err_t res ;uint32_t frame_sizes [ 8 ] ;int frames_this_pts , frame_count = 0 ;if ( data == NULL && data_sz == 0 ) return VPX_CODEC_INVALID_PARAM ;parse_superframe_index ( data , data_sz , frame_sizes , & frame_count , ctx -> decrypt_cb , ctx -> decrypt_state ) ;if ( res != VPX_CODEC_OK ) return res ;if ( ctx -> frame_parallel_decode ) {if ( frame_count > 0 ) {int i ;for ( i = 0 ;i < frame_count ;++ i ) {const uint8_t * data_start_copy = data_start ;const uint32_t frame_size = frame_sizes [ i ] ;if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) {set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ;if ( ctx -> available_threads == 0 ) {if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) {wait_worker_and_cache_frame ( ctx ) ;}else {set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ;return VPX_CODEC_ERROR ;}}res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ;if ( res != VPX_CODEC_OK ) return res ;data_start += frame_size ;}}else {if ( ctx -> available_threads == 0 ) {if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) {wait_worker_and_cache_frame ( ctx ) ;}else {set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ;return VPX_CODEC_ERROR ;}}res = decode_one ( ctx , & data , data_sz , user_priv , deadline ) ;if ( res != VPX_CODEC_OK ) return res ;}}else {if ( frame_count > 0 ) {int i ;for ( i = 0 ;i < frame_count ;++ i ) {const uint8_t * data_start_copy = data_start ;const uint32_t frame_size = frame_sizes [ i ] ;vpx_codec_err_t res ;if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) {set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ;return VPX_CODEC_CORRUPT_FRAME ;}res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ;if ( res != VPX_CODEC_OK ) return res ;data_start += frame_size ;}}else {while ( data_start < data_end ) {const uint32_t frame_size = ( uint32_t ) ( data_end - data_start ) ;const vpx_codec_err_t res = decode_one ( ctx , & data_start , frame_size , user_priv , deadline ) ;if ( res != VPX_CODEC_OK ) return res ;while ( data_start < data_end ) {const uint8_t marker = read_marker ( ctx -> decrypt_cb , ctx -> decrypt_state , data_start ) ;if ( marker ) break ;++ data_start ;}}",4241
159,"opts = fcntl ( s , F_GETFL ) ;if ( opts < 0 ) APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ;if ( fcntl ( s , F_SETFL , opts ) < 0 )  APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ;","opts = TEMP_FAILURE_RETRY ( fcntl ( s , F_GETFL ) ) ;if ( TEMP_FAILURE_RETRY ( opts < 0 ) APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ;if ( fcntl ( s , F_SETFL , opts ) ) < 0 ) APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ;",4242
160,"if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) >  ( Rec2 . RecordLength - 2 - 2 ) / 3 )  ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;","if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;",4243
161,unsigned int i ;bpcc -> numcmpts = box -> datalen ;,unsigned int i ;bpcc -> bpcs = 0 ;bpcc -> numcmpts = box -> datalen ;,4244
162,"
","assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;assert ( 0 == archive_write_header ( a , ae ) ) ;assert ( 0 == archive_write_finish_entry ( a ) ) ;assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ;assert ( archive_entry_clear ( ae ) != NULL ) ;archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ;failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ;assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ;archive_entry_free ( ae ) ;assert ( 0 == archive_write_finish_entry ( a ) ) ;assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;",4245
163,"assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;assert ( 0 == lstat ( ""dir"" , & st ) ) ;","assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;assert ( 0 == lstat ( ""dir"" , & st ) ) ;",4245
164,struct resv_map * reservations = vma_resv_map ( vma ) ;unsigned long reserve ;,struct resv_map * reservations = vma_resv_map ( vma ) ;struct hugepage_subpool * spool = subpool_vma ( vma ) ;unsigned long reserve ;,4246
165,"hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ;}","hugepage_subpool_put_pages ( spool , reserve ) ;}",4246
166,"szLineConv [ i ] = 0 ;strcpy ( szLine , szLineConv ) ;","if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;szLineConv [ i ] = 0 ;strcpy ( szLine , szLineConv ) ;",4247
167,"if ( skb -> pkt_type != PACKET_HOST ) goto drop ;if ( skb_warn_if_lro ( skb ) ) goto drop ;if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_FWD , skb ) ) goto drop ;if ( IPCB ( skb ) -> opt . router_alert && ip_call_ra_chain ( skb ) ) return NET_RX_SUCCESS ;skb_forward_csum ( skb ) ;if ( ip_hdr ( skb ) -> ttl <= 1 ) goto too_many_hops ;if ( ! xfrm4_route_forward ( skb ) ) goto drop ;rt = skb_rtable ( skb ) ;if ( opt -> is_strictroute && rt -> rt_uses_gateway ) goto sr_failed ;IPCB ( skb ) -> flags |= IPSKB_FORWARDED ;mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ;if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) {IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ;icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , htonl ( mtu ) ) ;goto drop ;}if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) goto drop ;iph = ip_hdr ( skb ) ;ip_decrease_ttl ( iph ) ;if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) )  ip_rt_send_redirect ( skb ) ;",if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) ip_rt_send_redirect ( skb ) ;,4248
168,"long length , offset , size , at ;int encoding ;","size_t length , offset , size , at ;int encoding ;",4249
169,"
","if ( hdr . toc_length_decompressed != strm . total_out ) {cli_dbgmsg ( ""TOC<S2SV_blank>decompress<S2SV_blank>length<S2SV_blank>%"" PRIu64 ""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>amount<S2SV_blank>decompressed<S2SV_blank>%lu\\\toc [ strm . total_out ] = \'\\\\0\' ;hdr . toc_length_decompressed = strm . total_out ;}",4249
170,"goto exit_toc ;}cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>scanning<S2SV_blank>xar<S2SV_blank>TOC<S2SV_blank>xml<S2SV_blank>in<S2SV_blank>memory.\\\rc = cli_mem_scandesc ( toc , hdr . toc_length_decompressed , ctx ) ;if ( rc != CL_SUCCESS ) {if ( rc != CL_VIRUS || ! SCAN_ALL ) goto exit_toc ;}if ( ctx -> engine -> keeptmp ) {if ( ( rc = cli_gentempfd ( ctx -> engine -> tmpdir , & tmpname , & fd ) ) != CL_SUCCESS ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>file<S2SV_blank>for<S2SV_blank>TOC.\\\goto exit_toc ;}if ( cli_writen ( fd , toc , hdr . toc_length_decompressed ) < 0 ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>TOC.\\\rc = CL_EWRITE ;xar_cleanup_temp_file ( ctx , fd , tmpname ) ;rc = xar_cleanup_temp_file ( ctx , fd , tmpname ) ;if ( rc != CL_SUCCESS ) goto exit_toc ;}reader = xmlReaderForMemory ( toc , hdr . toc_length_decompressed , ""noname.xml"" , NULL , CLAMAV_MIN_XMLREADER_FLAGS ) ;if ( reader == NULL ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>xmlReaderForMemory<S2SV_blank>error<S2SV_blank>for<S2SV_blank>TOC\\\goto exit_toc ;}rc = xar_scan_subdocuments ( reader , ctx ) ;if ( rc != CL_SUCCESS ) {cli_dbgmsg ( ""xar_scan_subdocuments<S2SV_blank>returns<S2SV_blank>%i.\\\goto exit_reader ;}fd = - 1 ;tmpname = NULL ;while ( CL_SUCCESS == ( rc = xar_get_toc_data_values ( reader , & length , & offset , & size , & encoding , & a_cksum , & a_hash , & e_cksum , & e_hash ) ) ) {int do_extract_cksum = 1 ;unsigned char * blockp ;void * a_sc , * e_sc ;void * a_mc , * e_mc ;char * expected ;if ( fd > - 1 && tmpname ) {rc = xar_cleanup_temp_file ( ctx , fd , tmpname ) ;if ( rc != CL_SUCCESS ) goto exit_reader ;}at = offset + hdr . toc_length_compressed + hdr . size ;if ( ( rc = cli_gentempfd ( ctx -> engine -> tmpdir , & tmpname , & fd ) ) != CL_SUCCESS ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>generate<S2SV_blank>temporary<S2SV_blank>file.\\\goto exit_reader ;}cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\\","cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\\",4249
171,"unsigned long in_remaining = length ;unsigned long out_size = 0 ;int lret ;memset ( & lz , 0 , sizeof ( lz ) ) ;","unsigned long in_remaining = MIN ( length , map -> len - at ) ;unsigned long out_size = 0 ;int lret ;if ( length > in_remaining ) length = in_remaining ;memset ( & lz , 0 , sizeof ( lz ) ) ;",4249
172,"cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\\","cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\\",4249
173,"cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\\rc = CL_EREAD ;","cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\\rc = CL_EREAD ;",4249
174,"unsigned long write_len ;if ( ctx -> engine -> maxfilesize )  write_len = MIN ( ( size_t ) ( ctx -> engine -> maxfilesize ) , ( size_t ) length ) ;else write_len = length ;if ( ! ( blockp = ( void * ) fmap_need_off_once ( map , at , length ) ) ) {char errbuff [ 128 ] ;cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\\if ( a_hash_ctx != NULL )  xar_hash_update ( a_hash_ctx , blockp , length , a_hash ) ;if ( cli_writen ( fd , blockp , write_len ) < 0 ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\\rc = CL_EWRITE ;","size_t writelen = MIN ( map -> len - at , length ) ;if ( ctx -> engine -> maxfilesize ) writelen = MIN ( ( size_t ) ( ctx -> engine -> maxfilesize ) , writelen ) ;if ( ! ( blockp = ( void * ) fmap_need_off_once ( map , at , writelen ) ) ) {char errbuff [ 128 ] ;cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%zu,<S2SV_blank>errno:%s.\\\if ( a_hash_ctx != NULL ) xar_hash_update ( a_hash_ctx , blockp , writelen , a_hash ) ;if ( cli_writen ( fd , blockp , writelen ) < 0 ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\\rc = CL_EWRITE ;",4249
175,"cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>mismatch.\\\cksum_fails ++ ;}else {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>matched.\\\}free ( expected ) ;}if ( e_hash_ctx != NULL ) {xar_hash_final ( e_hash_ctx , result , e_hash ) ;e_hash_ctx = NULL ;}else {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum(unarchived-checksum)<S2SV_blank>missing.\\\cksum_fails ++ ;}if ( e_cksum != NULL ) {if ( do_extract_cksum ) {expected = cli_hex2str ( ( char * ) e_cksum ) ;if ( xar_hash_check ( e_hash , result , expected ) != 0 ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum<S2SV_blank>mismatch.\\\cksum_fails ++ ;}else {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum<S2SV_blank>matched.\\\}free ( expected ) ;}}rc = cli_magic_scandesc ( fd , ctx ) ;if ( rc != CL_SUCCESS ) {if ( rc == CL_VIRUS ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Infected<S2SV_blank>with<S2SV_blank>%s\\\if ( ! SCAN_ALL ) goto exit_tmpfile ;}else if ( rc != CL_BREAK ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_magic_scandesc<S2SV_blank>error<S2SV_blank>%i\\\goto exit_tmpfile ;}}}if ( a_cksum != NULL ) {xmlFree ( a_cksum ) ;a_cksum = NULL ;}if ( e_cksum != NULL ) {xmlFree ( e_cksum ) ;e_cksum = NULL ;}}exit_tmpfile : xar_cleanup_temp_file ( ctx , fd , tmpname ) ;if ( a_hash_ctx != NULL ) xar_hash_final ( a_hash_ctx , result , a_hash ) ;if ( e_hash_ctx != NULL ) xar_hash_final ( e_hash_ctx , result , e_hash ) ;exit_reader : if ( a_cksum != NULL ) xmlFree ( a_cksum ) ;if ( e_cksum != NULL ) xmlFree ( e_cksum ) ;xmlTextReaderClose ( reader ) ;xmlFreeTextReader ( reader ) ;exit_toc : free ( toc ) ;if ( rc == CL_BREAK ) rc = CL_SUCCESS ;# else cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>can\\\'t<S2SV_blank>scan<S2SV_blank>xar<S2SV_blank>files,<S2SV_blank>need<S2SV_blank>libxml2.\\\# endif if ( cksum_fails + extract_errors != 0 ) {cli_warnmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors,<S2SV_blank>use<S2SV_blank>--debug<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info.\\\","cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors.\\\",4249
176,"
","if ( ! ND_TTEST2 ( * bp , 2 ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ;return ;}",4250
177,opt_type = * bp ++ ;opt_len = * bp ++ ;,opt_type = * bp ++ ;opt_len = * bp ++ ;,4250
178,"spin_unlock_irqrestore ( & slave_active_lock , flags ) ;}","list_del_init ( & timeri -> ack_list ) ;list_del_init ( & timeri -> active_list ) ;spin_unlock_irqrestore ( & slave_active_lock , flags ) ;}",4251
179,uchar buf [ PGX_MAGICLEN ] ;uint_fast32_t magic ;,jas_uchar buf [ PGX_MAGICLEN ] ;uint_fast32_t magic ;,4252
180,for ( depth = 1 ;depth ++ )   if ( depth >= 64 )  break ;,"if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;for ( depth = 1 ;depth ++ ) ;",4253
181,"static int set_vt_partitioning ( VP9_COMP * cpi ,  void * data ,   const TileInfo * const tile ,  BLOCK_SIZE bsize , int mi_row , int mi_col ,  int mi_size ) {VP9_COMMON * const cm = & cpi -> common ;const int block_height = num_8x8_blocks_high_lookup [ bsize ] ;const int64_t threshold_multiplier = 25 ;int64_t threshold = threshold_multiplier * cpi -> common . base_qindex ;if ( mi_col + block_width / 2 < cm -> mi_cols &&  mi_row + block_height / 2 < cm -> mi_rows && vt . part_variances -> none . variance < threshold ) {set_block_size ( cpi , tile , mi_row , mi_col , bsize ) ;return 1 ;if ( mi_row + block_height / 2 < cm -> mi_rows &&  vt . part_variances -> vert [ 0 ] . variance < threshold &&  vt . part_variances -> vert [ 1 ] . variance < threshold ) {set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ;set_block_size ( cpi , tile , mi_row , mi_col + block_width / 2 , subsize ) ;return 1 ;if ( mi_col + block_width / 2 < cm -> mi_cols &&  vt . part_variances -> horz [ 0 ] . variance < threshold && vt . part_variances -> horz [ 1 ] . variance < threshold ) {set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ;set_block_size ( cpi , tile , mi_row + block_height / 2 , mi_col , subsize ) ;return 1 ;return 0 ;}","static int set_vt_partitioning ( VP9_COMP * cpi , MACROBLOCK * const x , MACROBLOCKD * const xd , void * data , BLOCK_SIZE bsize , int mi_row , int mi_col , int mi_size ) {VP9_COMMON * const cm = & cpi -> common ;const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ;if ( force_split == 1 ) return 0 ;if ( bsize == bsize_min ) {if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ;if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows && vt . part_variances -> none . variance < threshold ) {set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ;return 1 ;return 0 ;}else if ( bsize > bsize_min ) {if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none . variance < threshold && vt . part_variances -> vert [ 1 ] . variance < threshold ) {set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ;set_block_size ( cpi , tile , mi_row , mi_col + block_width / 2 , subsize ) ;return 1 ;}if ( mi_col + block_width / 2 < cm -> mi_cols && vt . part_variances -> horz [ 0 ] . variance < threshold ) {set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ;return 1 ;if ( mi_row + block_height / 2 < cm -> mi_rows ) {set_block_size ( cpi , x , xd , mi_row , mi_col , subsize ) ;set_block_size ( cpi , x , xd , mi_row + block_height / 2 , mi_col , subsize ) ;return 1 ;}}return 0 ;}}return 0 ;",4254
182,"static void perf_event_output ( struct perf_event * event , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {if ( perf_output_begin ( & handle , event , header . size , nmi , 1 ) )  goto exit ;","static void perf_event_output ( struct perf_event * event , struct perf_sample_data * data , struct pt_regs * regs ) {if ( perf_output_begin ( & handle , event , header . size , 1 ) ) goto exit ;",4255
183,"
","if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) {f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ;return 1 ;}",4256
184,"if ( sanity_check_area_boundary ( sbi , bh ) )  return 1 ;","if ( sanity_check_area_boundary ( sbi , bh ) ) return 1 ;",4256
185,ret = fscrypt_get_crypt_info ( dir ) ;if ( ret && ret != - EOPNOTSUPP ) return ret ;,ret = fscrypt_get_encryption_info ( dir ) ;if ( ret && ret != - EOPNOTSUPP ) return ret ;,4257
186,"opts -> max_size = 0 ;if ( ! ( tvp = jas_tvparser_create ( optstr ? optstr : """" ) ) ) {case OPT_MAXSIZE :  opts -> max_size = atoi ( jas_tvparser_getval ( tvp ) ) ;break ;","opts -> max_samples = 64 * JAS_MEBI ;if ( ! ( tvp = jas_tvparser_create ( optstr ? optstr : """" ) ) ) {case OPT_MAXSIZE : opts -> max_samples = atoi ( jas_tvparser_getval ( tvp ) ) ;break ;",4258
187,"# ifdef _WITH_VRRP_  fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\\","fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\\# ifdef _WITH_VRRP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\\",4259
188,},"if ( cpu_has_secondary_exec_ctrls ( ) ) {if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ;else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ;}if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;}",4260
189,"const VP9_CONFIG * oxcf = & cpi -> oxcf ;const RATE_CONTROL * rc = & cpi -> rc ;const int64_t diff = oxcf -> optimal_buffer_level - rc -> buffer_level ;const int64_t one_pct_bits = 1 + oxcf -> optimal_buffer_level / 100 ;int min_frame_target = MAX ( rc -> av_per_frame_bandwidth >> 4 ,  FRAME_OVERHEAD_BITS ) ;int target = rc -> av_per_frame_bandwidth ;if ( svc -> number_temporal_layers > 1 &&  oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) {int current_temporal_layer = svc -> temporal_layer_id ;const LAYER_CONTEXT * lc = & svc -> layer_context [ current_temporal_layer ] ;target = lc -> avg_frame_size ;return MAX ( min_frame_target , target ) ;}","const VP9EncoderConfig * oxcf = & cpi -> oxcf ;const RATE_CONTROL * rc = & cpi -> rc ;const int64_t diff = rc -> optimal_buffer_level - rc -> buffer_level ;const int64_t one_pct_bits = 1 + rc -> optimal_buffer_level / 100 ;int min_frame_target = MAX ( rc -> avg_frame_bandwidth >> 4 , FRAME_OVERHEAD_BITS ) ;int target ;if ( oxcf -> gf_cbr_boost_pct ) {const int af_ratio_pct = oxcf -> gf_cbr_boost_pct + 100 ;target = cpi -> refresh_golden_frame ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio_pct ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) : ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * 100 ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) ;}else {target = rc -> avg_frame_bandwidth ;}if ( is_one_pass_cbr_svc ( cpi ) ) {int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ;const LAYER_CONTEXT * lc = & svc -> layer_context [ current_temporal_layer ] ;target = lc -> avg_frame_size ;if ( oxcf -> rc_max_inter_bitrate_pct ) {const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ;target = MIN ( target , max_rate ) ;}return MAX ( min_frame_target , target ) ;}",4261
190,". dump = link -> dump ,  . done = link -> done , }",". start = link -> start , . dump = link -> dump , . done = link -> done , }",4262
191,if ( ! ( mask & KADM5_ATTRIBUTES ) ||  ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;,if ( password == NULL || ! ( mask & KADM5_ATTRIBUTES ) || ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;,4263
192,struct address_space * mapping = page -> mapping ;if ( mapping ) {,struct address_space * mapping = page_file_mapping ( page ) ;if ( mapping ) {,4264
193,return ( 0 ) ;,if ( rdata -> rbuf . buf != NULL ) return ( 0 ) ;,4265
194,OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( 0 ) ;}OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( 0 ) ;},OPENSSL_free ( rdata -> rbuf . buf ) ;OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( - 1 ) ;}if ( rdata -> rbuf . buf != NULL ) OPENSSL_free ( rdata -> rbuf . buf ) ;OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( - 1 ) ;},4265
195,"rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ;","rc = fsmMkfile ( fi , fpath , files , psm , 0 , nodigest , & setmeta , & firsthardlink ) ;",4266
196,"rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ;firsthardlink = - 1 ;","rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ;firsthardlink = - 1 ;",4266
197,"err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ;if ( err ) return err ;if ( is_pointer_value ( env , insn -> dst_reg ) ) {verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\\return - EACCES ;}err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;}else if ( opcode == BPF_MOV ) {if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( insn -> imm != 0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ;if ( err ) return err ;if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ;regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ;}else {if ( is_pointer_value ( env , insn -> src_reg ) ) {verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\return - EACCES ;}mark_reg_unknown ( env , regs , insn -> dst_reg ) ;regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ;__update_reg_bounds ( & regs [ insn -> dst_reg ] ) ;}__mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ;}","err = check_reg_arg ( env , insn -> dst_reg , insn -> imm ) ;__mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ;if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {__mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ;}",4267
198,if ( ! * ptrptr && ! ( nmemb && size ) )  return AVERROR ( ENOMEM ) ;,if ( ! * ptrptr && nmemb && size ) ) return AVERROR ( ENOMEM ) ;,4268
199,"rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\if ( msg_flags & MSG_OOB ) goto out ;","rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\msg -> msg_namelen = 0 ;if ( msg_flags & MSG_OOB ) goto out ;",4269
200,"
",msg -> msg_namelen = sizeof ( * sin ) ;,4269
201,}break ;,}break ;,4269
202,"
",rcu_read_lock ( ) ;,4270
203,"opt = flowlabel ? flowlabel -> opt : np -> opt ;final_p = fl6_update_dst ( & fl6 , opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","opt = flowlabel ? flowlabel -> opt : rcu_dereference ( np -> opt ) ;final_p = fl6_update_dst ( & fl6 , opt , & final ) ;rcu_read_unlock ( ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",4270
204,"u8 obuf [ ] = {0xde , 0 };info ( ""%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d"" , __func__ , i , state -> initialized ) ;state -> initialized = 1 ;return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ;}return 0 ;","int ret = 0 ;info ( ""%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d"" , __func__ , i , state -> initialized ) ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xde ;state -> data [ 1 ] = 0 ;state -> initialized = 1 ;ret = dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ;mutex_unlock ( & d -> data_mutex ) ;}return ret ;",4271
205,"const char * arch = info -> arch ;ut16 bits = info -> bits ;if ( info -> cpu && * info -> cpu ) {r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ;}r_core_bin_set_cur ( r , binfile ) ;return true ;","char * arch = info -> arch ;ut16 bits = info -> bits ;if ( cpu && * info -> cpu ) {r_config_set ( r -> config , ""anal.cpu"" , cpu ) ;}r_core_bin_set_cur ( r , binfile ) ;free ( cpu ) ;free ( arch ) ;return true ;",4272
206,"int ip_options_get ( struct net * net , struct ip_options * * optp ,  unsigned char * data , int optlen ) {struct ip_options * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen )  memcpy ( opt -> __data , data , optlen ) ;return ip_options_get_finish ( net , optp , opt , optlen ) ;","int ip_options_get ( struct net * net , struct ip_options_rcu * * optp , unsigned char * data , int optlen ) {struct ip_options_rcu * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen ) memcpy ( opt -> opt . __data , data , optlen ) ;return ip_options_get_finish ( net , optp , opt , optlen ) ;",4273
207,"change = ue -> tlv_data_size != size ;if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ;kfree ( ue -> tlv_data ) ;ue -> tlv_data = new_data ;ue -> tlv_data_size = size ;}else {if ( ! ue -> tlv_data_size || ! ue -> tlv_data )  return - ENXIO ;if ( size < ue -> tlv_data_size )   return - ENOSPC ;if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) )   return - EFAULT ;}return change ;","mutex_lock ( & ue -> card -> user_ctl_lock ) ;change = ue -> tlv_data_size != size ;if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ;kfree ( ue -> tlv_data ) {ret = - ENXIO ;goto err_unlock ;}if ( size < ue -> tlv_data_size ) return - ENOSPC ;goto err_unlock ;}if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) return - EFAULT ;err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ;if ( ret ) return ret ;}return change ;",4274
208,"if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ;if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ;map -> m_flags &= ~ EXT4_MAP_FLAGS ;down_write ( & EXT4_I ( inode ) -> i_data_sem ) ;if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) {retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ;}else {retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ;if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) {ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ;}if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ;}if ( retval > 0 ) {unsigned int status ;if ( unlikely ( retval != map -> m_len ) ) {ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ;WARN_ON ( 1 ) ;if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) {ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ;if ( ret ) {retval = ret ;goto out_sem ;}}if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) {if ( ext4_es_is_written ( & es ) ) goto out_sem ;}status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ;if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ;ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ;if ( ret < 0 ) {retval = ret ;goto out_sem ;}}out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ;if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) {ret = check_block_validity ( inode , map ) ;if ( ret != 0 ) return ret ;}return retval ;","if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) {ret = ext4_jbd2_file_inode ( handle , inode ) ;if ( ret ) return ret ;return retval ;",4275
209,cifs_small_buf_release ( req ) ;rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ;,rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ;,4276
210,* nbytes = le32_to_cpu ( rsp -> DataLength ) ;if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) {,cifs_small_buf_release ( req ) ;* nbytes = le32_to_cpu ( rsp -> DataLength ) ;if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) {,4276
211,"struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ;struct netdev_notifier_info info ;netdev_notifier_info_init ( & info , dev ) ;return masq_device_event ( this , event , & info ) ;","struct in_device * idev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev ;struct netdev_notifier_info info ;if ( idev -> dead ) return NOTIFY_DONE ;netdev_notifier_info_init ( & info , idev -> dev ) ;return masq_device_event ( this , event , & info ) ;",4277
212,v |= ( c << 24 ) ;if ( -- n <= 0 ) {,"v |= ( JAS_CAST ( uint_fast32_t , c ) << 24 ) ;if ( -- n <= 0 ) {",4278
213,"sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ;sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ;","sctp_add_cmd_sf ( commands , SCTP_CMD_SET_ASOC , SCTP_ASOC ( new_asoc ) ) ;sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ;",4279
214,"FILE * file ;file = fopen ( stats_file , ""w"" ) ;if ( ! file ) {for ( e = LIST_HEAD ( l ) ;e ;ELEMENT_NEXT ( e ) ) {vrrp = ELEMENT_DATA ( e ) ;","FILE * file = fopen_safe ( stats_file , ""w"" ) ;if ( ! file ) {if ( ! file ) {log_message ( LOG_INFO , ""Can\\\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ;return ;}LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) {",4280
215,"int  run_cmd ( int fd , ... )  {","int run_cmd ( int fd , const char * cmd , const char * args_extra ) {",4281
216,"char cmd [ 512 ] ;term_remove ( STI ) ;dup2 ( fd , STI ) ;dup2 ( fd , STO ) ;{char * c , * ce ;const char * s ;int n ;va_list vls ;strcpy ( cmd , EXEC ) ;c = & cmd [ sizeof ( EXEC ) - 1 ] ;","int argc ;char * argv [ RUNCMD_ARGS_MAX + 1 ] ;int r ;term_remove ( STI ) ;argc = 0 ;r = split_quoted ( cmd , EXEC ) ;c = & cmd [ sizeof ( EXEC ) - 1 ] ;",4281
217,"fd_printf ( STDERR_FILENO , ""%s\\\establish_child_signal_handlers ( ) ;sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ;execl ( ""/bin/sh"" , ""sh"" , ""-c"" , cmd , NULL ) ;exit ( 42 ) ;}","fd_printf ( STDERR_FILENO , ""exec:<S2SV_blank>%s\\\exit ( 42 ) ;}",4281
218,"static void  build_config ( char * prefix , struct server * server )  {int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;path = ss_malloc ( path_size ) ;snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ;FILE * f = fopen ( path , ""w+"" ) ;if ( f == NULL ) {if ( verbose ) {LOGE ( ""unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file"" ) ;}ss_free ( path ) ;return ;}fprintf ( f , ""{\\\fprintf ( f , ""\\\\""server_port\\\\"":%d,\\\fprintf ( f , ""\\\\""password\\\\"":\\\\""%s\\\\"""" , server -> password ) ;if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\\\if ( server -> mode ) fprintf ( f , "",\\\if ( server -> method ) fprintf ( f , "",\\\if ( server -> plugin ) fprintf ( f , "",\\\","static void build_config ( char * prefix , struct manager_ctx * manager , struct server * server ) {int path_size = strlen ( prefix ) + strlen ( server -> plugin ) fprintf ( f , "",\\\",4282
219,"if ( ! dir_emit_dots ( file , ctx ) )  return 0 ;pos = 2 ;","if ( ! dir_emit_dots ( file , ctx ) ) goto out ;pos = 2 ;",4283
220,sysctl_head_finish ( head ) ;return 0 ;,out : sysctl_head_finish ( head ) ;return 0 ;,4283
221,"char * dest , * src ;char separator = \'\\\\0\' ;dest = src = a -> name ;if ( * src == \'\\\\0\' ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC ,  ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ;return ( ARCHIVE_FAILED ) ;}# if defined ( __CYGWIN__ )  cleanup_pathname_win ( a ) ;return ( ARCHIVE_FAILED ) ;}separator = * src ++ ;}for ( ;;) {if ( src [ 0 ] == \'\\\\0\' ) {break ;}else if ( src [ 0 ] == \'/\' ) {src ++ ;continue ;}else if ( src [ 0 ] == \'.\' ) {if ( src [ 1 ] == \'\\\\0\' ) {break ;}else if ( src [ 1 ] == \'/\' ) {src += 2 ;continue ;}else if ( src [ 1 ] == \'.\' ) {if ( src [ 2 ] == \'/\' || src [ 2 ] == \'\\\\0\' ) {if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\\\'..\\\'"" ) ;}}}if ( separator ) * dest ++ = \'/\' ;while ( * src != \'\\\\0\' && * src != \'/\' ) {* dest ++ = * src ++ ;}if ( * src == \'\\\\0\' ) break ;separator = * src ++ ;}if ( dest == a -> name ) {if ( separator ) * dest ++ = \'/\' ;else * dest ++ = \'.\' ;}* dest = \'\\\\0\' ;return ( ARCHIVE_OK ) ;","struct archive_string error_string ;int error_number ;int rc ;archive_string_init ( & error_string ) ;rc = cleanup_pathname_fsobj ( a -> name , & error_number , & error_string , a -> flags ) ;if ( rc != ARCHIVE_OK ) {archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ;}# if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ;archive_string_free ( & error_string ) ;return rc ;",4284
222,"ps_dec -> i1_prev_mb_qp_delta = 0 ;ps_dec -> i1_next_ctxt_idx = 0 ;ps_dec -> u4_nmb_deblk = 0 ;if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ;if ( ps_seq -> u1_mb_aff_flag == 1 ) {ps_dec -> u4_nmb_deblk = 0 ;if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ;}ps_dec -> u4_use_intrapred_line_copy = 0 ;if ( ps_seq -> u1_mb_aff_flag == 0 ) {ps_dec -> u4_use_intrapred_line_copy = 1 ;}ps_dec -> u4_app_disable_deblk_frm = 0 ;if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) {WORD32 degrade_pic ;ps_dec -> i4_degrade_pic_cnt ++ ;degrade_pic = 0 ;switch ( ps_dec -> i4_degrade_pics ) {case 4 : {degrade_pic = 1 ;break ;}case 3 : {if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ;break ;}case 2 : {if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ;break ;}case 1 : {if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) {degrade_pic = 1 ;}break ;}}if ( degrade_pic ) {if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ;if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) {if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ;if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ;}}else ps_dec -> i4_degrade_pic_cnt = 0 ;}{dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ;if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ;else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ;if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) {ps_err -> u1_cur_pic_type = PIC_TYPE_I ;ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ;}if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) {if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ;ps_err -> u1_err_flag = ACCEPT_ALL_PICS ;}}if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) {WORD32 j ;for ( j = 0 ;j < MAX_DISP_BUFS_NEW ;j ++ ) {ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ;}ps_dec -> u1_second_field = 0 ;ps_dec -> i4_cur_display_seq = 0 ;ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ;}ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ;if ( ret != OK ) return ret ;ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ;ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ;ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ;if ( ps_dec -> u1_separate_parse ) {UWORD16 pic_wd ;UWORD16 pic_ht ;UWORD32 num_mbs ;pic_wd = ps_dec -> u2_pic_wd ;pic_ht = ps_dec -> u2_pic_ht ;num_mbs = ( pic_wd * pic_ht ) >> 8 ;if ( ps_dec -> pu1_dec_mb_map ) {memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ;}if ( ps_dec -> pu1_recon_mb_map ) {memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ;}if ( ps_dec -> pu2_slice_num_map ) {memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ;}}ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ;ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ;ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ;ps_dec -> s_high_profile . u1_scaling_present = 0 ;ps_dec -> s_high_profile . u1_transform8x8_present = 0 ;if ( 1 == ps_dec -> u4_share_disp_buf ) {UWORD32 i ;for ( i = 0 ;i < MAX_DISP_BUFS_NEW ;i ++ ) {if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ;ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ;ps_dec -> u4_disp_buf_mapping [ i ] = 0 ;}}if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) {pic_buffer_t * ps_cur_pic ;WORD32 cur_pic_buf_id , cur_mv_buf_id ;col_mv_buf_t * ps_col_mv ;while ( 1 ) {ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ;if ( ps_cur_pic == NULL ) {ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ;return ERROR_UNAVAIL_PICBUF_T ;}if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) {break ;}}ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ;if ( ps_col_mv == NULL ) {ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ;return ERROR_UNAVAIL_MVBUF_T ;}ps_dec -> ps_cur_pic = ps_cur_pic ;ps_dec -> u1_pic_buf_id = cur_pic_buf_id ;ps_cur_pic -> u4_ts = ps_dec -> u4_ts ;ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ;ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ;ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ;ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ;ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ;if ( ps_dec -> u1_first_slice_in_stream ) {ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ;* ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ;}if ( ! ps_dec -> ps_cur_pic ) {WORD32 j ;H264_DEC_DEBUG_PRINT ( ""-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\\for ( j = 0 ;j < MAX_DISP_BUFS_NEW ;j ++ ) {ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ;}ps_dec -> i4_cur_display_seq = 0 ;ps_dec -> i4_prev_max_display_seq = 0 ;ps_dec -> i4_max_poc = 0 ;ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ;if ( ps_cur_pic == NULL ) {ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ;return ERROR_UNAVAIL_PICBUF_T ;}ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ;if ( ps_col_mv == NULL ) {ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ;return ERROR_UNAVAIL_MVBUF_T ;}ps_dec -> ps_cur_pic = ps_cur_pic ;ps_dec -> u1_pic_buf_id = cur_pic_buf_id ;ps_cur_pic -> u4_ts = ps_dec -> u4_ts ;ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ;ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ;ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ;ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ;ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ;ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ;}ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ;ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ;H264_DEC_DEBUG_PRINT ( ""got<S2SV_blank>a<S2SV_blank>buffer\\\}else {H264_DEC_DEBUG_PRINT ( ""did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\\}ps_dec -> u4_pic_buf_got = 1 ;ps_dec -> ps_cur_pic -> i4_poc = i4_poc ;ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ;ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ;ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ;ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ;ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ;if ( u1_field_pic_flag && u1_bottom_field_flag ) {WORD32 i4_temp_poc ;WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ;ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ;ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ;ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ;ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ;ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ;ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ;i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ;ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ;}ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ;ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ;ps_dec -> ps_cur_mb_row += 2 ;ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row ;ps_dec -> ps_top_mb_row += ( ( ps_dec -> u2_frm_wd_in_mbs + 2 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ;ps_dec -> ps_top_mb_row += 2 ;ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ;ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ;ps_dec -> u1_mv_top_p = 0 ;ps_dec -> u1_mb_idx = 0 ;ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ;ps_dec -> u2_total_mbs_coded = 0 ;ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ;ps_dec -> u4_pred_info_idx = 0 ;ps_dec -> u4_pred_info_pkd_idx = 0 ;ps_dec -> u4_dma_buf_idx = 0 ;ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ;ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ;ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ;ps_dec -> ps_part = ps_dec -> ps_parse_part_params ;ps_dec -> i2_prev_slice_mbx = - 1 ;ps_dec -> i2_prev_slice_mby = 0 ;ps_dec -> u2_mv_2mb [ 0 ] = 0 ;ps_dec -> u2_mv_2mb [ 1 ] = 0 ;ps_dec -> u1_last_pic_not_decoded = 0 ;ps_dec -> u2_cur_slice_num = 0 ;ps_dec -> u2_cur_slice_num_dec_thread = 0 ;",ps_dec -> u2_cur_slice_num_dec_thread = 0 ;,4285
223,"struct mb_cache *   ext4_xattr_create_cache ( char * name )  {return mb_cache_create ( name , HASH_BUCKET_BITS ) ;}",struct mb2_cache * ext4_xattr_create_cache ( char * name ) {return mb2_cache_create ( HASH_BUCKET_BITS ) ;},4286
224,"DEFiRet ;CHKiRet ( batchInit ( & snglRuleBatch , pBatch -> nElem ) ) ;snglRuleBatch . pbShutdownImmediate = pBatch -> pbShutdownImmediate ;while ( 1 ) {for ( iStart = 0 ;if ( iStart == pBatch -> nElem ) FINALIZE ;batchCopyElem ( & ( snglRuleBatch . pElem [ iNew ++ ] ) , & ( pBatch -> pElem [ i ] ) ) ;}","int bHaveUnprocessed ;DEFiRet ;do {bHaveUnprocessed = 0 ;for ( iStart = 0 ;if ( iStart == pBatch -> nElem ) break ;CHKiRet ( batchInit ( & snglRuleBatch , pBatch -> nElem ) ) ;snglRuleBatch . pbShutdownImmediate = pBatch -> pbShutdownImmediate ;snglRuleBatch . pElem [ iNew ] . pUsrp = pBatch -> pElem [ i ] . pUsrp ;snglRuleBatch . pElem [ iNew ] . state = pBatch -> pElem [ i ] . state ;++ iNew ;else {bHaveUnprocessed = 1 ;}}while ( bHaveUnprocessed == 1 ) ;",4287
225,"case kEmptyStream :  h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles ,  sizeof ( * h -> emptyStreamBools ) ) ;","case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ;h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , sizeof ( * h -> emptyStreamBools ) ) ;",4288
226,"h -> emptyFileBools = calloc ( empty_streams ,  sizeof ( * h -> emptyFileBools ) ) ;","if ( h -> emptyFileBools != NULL ) return ( - 1 ) ;h -> emptyFileBools = calloc ( empty_streams , sizeof ( * h -> emptyFileBools ) ) ;",4288
227,"h -> antiBools = calloc ( empty_streams ,  sizeof ( * h -> antiBools ) ) ;","if ( h -> antiBools != NULL ) return ( - 1 ) ;h -> antiBools = calloc ( empty_streams , sizeof ( * h -> antiBools ) ) ;",4288
228,if ( ( ll & 1 ) || ll < zip -> numFiles * 4 )  return ( - 1 ) ;,if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) return ( - 1 ) ;if ( zip -> entry_names != NULL ) return ( - 1 ) ;,4288
229,"h -> attrBools = calloc ( ( size_t ) zip -> numFiles ,  sizeof ( * h -> attrBools ) ) ;","if ( h -> attrBools != NULL ) return ( - 1 ) ;h -> attrBools = calloc ( ( size_t ) zip -> numFiles , sizeof ( * h -> attrBools ) ) ;",4288
230,"char buf [ L_BUF_SIZE ] ;char * rootname , * title , * xlabel , * ylabel , * ignores ;ret = fscanf ( fp , ""Gplot<S2SV_blank>Version<S2SV_blank>%d\\\if ( ret != 1 ) {fclose ( fp ) ;return ( GPLOT * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>gplot<S2SV_blank>file"" , procName , NULL ) ;}if ( version != GPLOT_VERSION_NUMBER ) {fclose ( fp ) ;return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>gplot<S2SV_blank>version"" , procName , NULL ) ;}ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\\rootname = stringNew ( buf ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;title = stringNew ( buf + 7 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;xlabel = stringNew ( buf + 14 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;ylabel = stringNew ( buf + 14 ) ;","char buf [ L_BUFSIZE ] ;char * rootname , * title , * xlabel , * ylabel , * ignores ;ret = fscanf ( fp , ""Rootname:<S2SV_blank>%511s\\\rootname = stringNew ( buf ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;title = stringNew ( buf + 7 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;xlabel = stringNew ( buf + 14 ) ;ignores = fgets ( buf , L_BUFSIZE , fp ) ;ylabel = stringNew ( buf + 14 ) ;",4289
231,"ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\\stringReplace ( & gplot -> cmdname , buf ) ;ignore = fscanf ( fp , ""\\\gplot -> cmddata = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> datanames = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plotdata = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plottitles = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plotstyles = numaReadStream ( fp ) ;ignore = fscanf ( fp , ""Number<S2SV_blank>of<S2SV_blank>plots:<S2SV_blank>%d\\\ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\\stringReplace ( & gplot -> outname , buf ) ;","ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\\stringReplace ( & gplot -> cmdname , buf ) ;ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\\stringReplace ( & gplot -> outname , buf ) ;",4289
232,"ngx_uint_t n , sec , min , hour , mday , mon , year , wday , days , leap ;n = ( ngx_uint_t ) t ;days = n / 86400 ;wday = ( 4 + days ) % 7 ;n %= 86400 ;hour = n / 3600 ;n %= 3600 ;min = n / 60 ;sec = n % 60 ;days = days - ( 31 + 28 ) + 719527 ;","ngx_uint_t sec , min , hour , mday , mon , year , wday , days , leap ;if ( t < 0 ) {t = 0 ;}days = t / 86400 ;sec = t % 86400 ;wday = ( 4 + days ) % 7 ;hour = sec / 3600 ;n %= 3600 ;min = n / 60 ;sec %= 60 ;days = days - ( 31 + 28 ) + 719527 ;",4290
233,"if ( tpgt > TL_TPGS_PER_HBA ) {printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\\","if ( tpgt >= TL_TPGS_PER_HBA ) {printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\\",4291
234,"int len ;if ( config . eval_ldb ) return ;if ( config . hostsocket != NULL )   len = snprintf ( config . prompt , sizeof ( config . prompt ) , ""redis<S2SV_blank>%s"" ,  config . hostsocket ) ;else len = anetFormatAddr ( config . prompt , sizeof ( config . prompt ) , config . hostip , config . hostport ) ;if ( config . dbnum != 0 ) len += snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , ""[%d]"" , config . dbnum ) ;snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , ""><S2SV_blank>"" ) ;","if ( config . eval_ldb ) return ;sds prompt = sdsempty ( ) ;if ( config . hostsocket != NULL ) {prompt = sdscatfmt ( prompt , ""redis<S2SV_blank>%s"" , config . hostsocket ) ;}else {char addr [ 256 ] ;anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ;prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ;}if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , ""[%i]"" , config . dbnum ) ;prompt = sdscatlen ( prompt , ""><S2SV_blank>"" , 2 ) ;snprintf ( config . prompt , sizeof ( config . prompt ) , ""%s"" , prompt ) ;sdsfree ( prompt ) ;",4292
235,total = le32_to_cpu ( raw_super -> segment_count ) ;fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ;,"unsigned int main_segs , blocks_per_seg ;int i ;total = le32_to_cpu ( raw_super -> segment_count ) ;fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ;",4293
236,"if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ;","main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ;blocks_per_seg = sbi -> blocks_per_seg ;for ( i = 0 ;i < NR_CURSEG_NODE_TYPE ;i ++ ) {if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ;}for ( i = 0 ;i < NR_CURSEG_DATA_TYPE ;i ++ ) {if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ;}if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ;",4293
237,__be16 type ;off = skb_gro_offset ( skb ) ;,__be16 type ;if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ;NAPI_GRO_CB ( skb ) -> encap_mark = 1 ;off = skb_gro_offset ( skb ) ;,4294
238,". dump = link -> dump ,  . done = link -> done , }",". start = link -> start , . dump = link -> dump , . done = link -> done , }",4295
239,"rcu_read_lock ( ) ;dev = dev_get_by_name_rcu ( net , name ) ;rcu_read_unlock ( ) ;if ( ! dev && capable ( CAP_NET_ADMIN ) )   request_module ( ""%s"" , name ) ;}","int no_module ;rcu_read_lock ( ) ;no_module = ! dev ;if ( no_module && capable ( CAP_NET_ADMIN ) ) no_module = request_module ( ""netdev-%s"" , name ) ) pr_err ( ""Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>"" ""with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>"" ""instead\\\}}",4296
240,cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;,cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;,4297
241,cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;break ;,cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;break ;,4297
242,"
",const uid_t dduid = g_settings_privatereports ? 0 : fsuid ;,4298
243,"sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ;proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ;uid_t fsuid = uid ;uid_t tmp_fsuid = get_fsuid ( ) ;int suid_policy = dump_suid_policy ( ) ;if ( tmp_fsuid != uid ) {fsuid = 0 ;if ( suid_policy == DUMP_SUID_UNSAFE ) fsuid = tmp_fsuid ;else {g_user_core_flags = O_EXCL ;g_need_nonrelative = 1 ;}}if ( setting_MakeCompatCore && ulimit_c != 0 )  user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ;if ( executable == NULL ) {error_msg ( ""Can\\\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ;goto create_user_core ;}const char * signame = NULL ;switch ( signal_no ) {case SIGILL : signame = ""ILL"" ;break ;case SIGFPE : signame = ""FPE"" ;break ;case SIGSEGV : signame = ""SEGV"" ;break ;case SIGBUS : signame = ""BUS"" ;break ;case SIGABRT : signame = ""ABRT"" ;break ;case SIGTRAP : signame = ""TRAP"" ;break ;default : goto create_user_core ;}if ( ! daemon_is_ok ( ) ) {log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'core\\\'"" ) ;goto create_user_core ;}if ( g_settings_nMaxCrashReportsSize > 0 ) {if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ;}snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ;if ( check_recent_crash_file ( path , executable ) ) {goto create_user_core ;}const char * last_slash = strrchr ( executable , \'/\' ) ;if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) {if ( snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\\\'%s\\\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path"" , path ) ;int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) {unlink ( path ) ;error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\\\'%s\\\'"" , path ) ;}log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ;if ( proc_cwd != NULL ) closedir ( proc_cwd ) ;return 0 ;}unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ;if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) {goto create_user_core ;}dd = dd_create_skeleton ( path , fsuid , DEFAULT_DUMP_DIR_MODE , 0 ) ;if ( dd ) {","sprintf ( path , dduid , DEFAULT_DUMP_DIR_MODE , 0 ) ;if ( dd ) {",4298
244,"logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ;image = AcquireImage ( image_info ) ;","logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ;quantum_info = ( QuantumInfo * ) NULL ;image = AcquireImage ( image_info ) ;",4299
245,"InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ;","if ( quantum_info != ( QuantumInfo * ) NULL ) InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ;",4299
246,quantum_info = DestroyQuantumInfo ( quantum_info ) ;END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ;,quantum_info = DestroyQuantumInfo ( quantum_info ) ;END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ;,4299
247,"static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags )  {switch ( open_flags ) {case FMODE_WRITE : state -> n_wronly ++ ;nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ;}","static void update_open_stateflags ( struct nfs4_state * state , fmode_t fmode ) {switch ( open_flags ) {case FMODE_WRITE : state -> n_wronly ++ ;nfs4_state_set_mode_locked ( state , state -> state | fmode ) ;}",4300
248,"static krb5_error_code get_tag ( const uint8_t * asn1 , size_t len , taginfo * tag_out , const uint8_t * * contents_out , size_t * clen_out ,  const uint8_t * * remainder_out , size_t * rlen_out )  {","static krb5_error_code get_tag ( const uint8_t * asn1 , size_t len , taginfo * tag_out , const uint8_t * * contents_out , size_t * clen_out , const uint8_t * * remainder_out , size_t * rlen_out , int recursion ) {",4301
249,"p = asn1 ;while ( ! ( len >= 2 && p [ 0 ] == 0 && p [ 1 ] == 0 ) ) {ret = get_tag ( p , len , & t , & c , & clen , & p , & len ) ;if ( ret ) return ret ;","if ( recursion >= 32 ) return ASN1_OVERFLOW ;p = asn1 ;while ( ! ( len >= 2 && p [ 0 ] == 0 && p [ 1 ] == 0 ) ) {ret = get_tag ( p , len , & t , & c , & clen , & p , & len , recursion + 1 ) ;if ( ret ) return ret ;",4301
250,"# define ThrowCUTReaderException ( severity , tag ) {}Image * image , * palette ;","# define ThrowCUTReaderException ( severity , tag ) \\\\\\\\\\Image * image , * palette ;",4302
251,"
","( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;",4302
252,"offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {","offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {",4302
253,if ( code == gcode )  return & wordlist [ key ] ;,if ( code == gcode && wordlist [ key ] . index >= 0 ) return & wordlist [ key ] ;,4303
254,"static void  _copy_from_pages ( char * p , struct page * * pages , size_t pgbase , size_t len ) {","void _copy_from_pages ( char * p , struct page * * pages , size_t pgbase , size_t len ) {",4304
255,"int copied , err ;struct sockaddr_ll * sll ;","int copied , err ;",4305
256,"sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;if ( sock -> type == SOCK_PACKET )  msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;else  msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name )  memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa ,  msg -> msg_namelen ) ;if ( pkt_sk ( sk ) -> auxdata ) {","copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name ) {if ( sock -> type == SOCK_PACKET ) {msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;}else {struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;}memcpy ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ;}if ( pkt_sk ( sk ) -> auxdata ) {",4305
257,"if ( uid_eq ( uid , current_fsuid ( ) ) )  return true ;if ( gid_eq ( gid , current_fsgid ( ) ) )  return true ;","if ( uid_eq ( uid , file -> f_cred -> fsuid ) ) return true ;if ( gid_eq ( gid , file -> f_cred -> fsgid ) ) return true ;",4306
258,"char * ret ;ret = fgets ( ptr , PATH_MAX , VFile ) ;if ( ptr [ strlen ( ptr ) - 1 ] == '\\\return ret ;","char * ret ;size_t len ;ret = fgets ( ptr , PATH_MAX , VFile ) ;len = strlen ( ptr ) ;if ( len > 0 && ptr [ len - 1 ] == '\\\return ret ;",4307
259,fid -> udf . generation = inode -> i_generation ;if ( parent ) {,fid -> udf . parent_partref = 0 ;fid -> udf . generation = inode -> i_generation ;if ( parent ) {,4308
260,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) {,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) # define GIFOutputCode ( code ) \\\\\,4309
261,}Quantum index ;,\\\\\Quantum index ;,4309
262,"
",next_pixel = MagickFalse ;displacement = 1 ;,4309
263,"index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;p += GetPixelChannels ( image ) ;next_pixel = MagickFalse ;displacement = 1 ;","index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;p += GetPixelChannels ( image ) ;if ( k < 0 ) continue ;",4309
264,"SEPARATE_ZVAL ( ( var ) ) ;convert_to_long ( * var ) ;points [ i ] . x = Z_LVAL_PP ( var ) ;}SEPARATE_ZVAL ( var ) ;convert_to_long ( * var ) ;points [ i ] . y = Z_LVAL_PP ( var ) ;}if ( filled ) {gdImageFilledPolygon ( im , points , npoints , col ) ;","if ( Z_TYPE_PP ( var ) != IS_LONG ) {zval lval ;lval = * * var ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;points [ i ] . x = Z_LVAL ( lval ) ;}else {points [ i ] . x = Z_LVAL_PP ( var ) ;}}if ( Z_TYPE_PP ( var ) != IS_LONG ) {zval lval ;lval = * * var ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;points [ i ] . y = Z_LVAL ( lval ) ;}else {points [ i ] . y = Z_LVAL_PP ( var ) ;}}if ( filled ) {gdImageFilledPolygon ( im , points , npoints , col ) ;",4310
265,"gdImageGifCtx ( im , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;","if ( ! _gdImageGifCtx ( im , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",4311
266,"static void decode_mb_mode_mvs ( VP8D_COMP * pbi , MODE_INFO * mi , MB_MODE_INFO * mbmi )  {if ( pbi -> mb . update_mb_segmentation_map ) read_mb_features ( & pbi -> mbc [ 8 ] , & mi -> mbmi , & pbi -> mb ) ;","static void decode_mb_mode_mvs ( VP8D_COMP * pbi , MODE_INFO * mi , MB_MODE_INFO * mbmi ) {( void ) mbmi ;if ( pbi -> mb . update_mb_segmentation_map ) read_mb_features ( & pbi -> mbc [ 8 ] , & mi -> mbmi , & pbi -> mb ) ;",4312
267,"static inline bool unconditional ( const struct ipt_ip * ip )  {return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ;# undef FWINV }","static inline bool unconditional ( const struct ipt_entry * e ) {return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> ip , & uncond , sizeof ( uncond ) ) == 0 ;# undef FWINV }",4313
268,"err = bnep_add_connection ( & ca , nsock ) ;if ( ! err ) {","ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;err = bnep_add_connection ( & ca , nsock ) ;if ( ! err ) {",4314
269,"vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ;for ( mb_row = 0 ;","memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ;for ( mb_row = 0 ;",4315
270,const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ;struct search_domain * dom ;for ( dom = state -> head ;,char need_to_append_dot ;struct search_domain * dom ;if ( ! base_len ) return NULL ;need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ;for ( dom = state -> head ;,4316
271,goto chpwfail ;},goto bailout ;},4317
272,goto chpwfail ;}goto chpwfail ;}goto chpwfail ;},goto bailout ;}goto bailout ;}goto bailout ;},4317
273,if ( iter > CIPSO_V4_TAG_MAXCNT )  return - EINVAL ;if ( iter < CIPSO_V4_TAG_MAXCNT )   doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ;return 0 ;,if ( iter >= CIPSO_V4_TAG_MAXCNT ) return - EINVAL ;while ( iter < CIPSO_V4_TAG_MAXCNT ) doi_def -> tags [ iter ++ ] = CIPSO_V4_TAG_INVALID ;return 0 ;,4318
274,"if ( ! osStrcmp ( path , ""."" ) )  ftpClientFormatCommand ( context , ""LIST"" , NULL ) ;else   ftpClientFormatCommand ( context , ""LIST"" , path ) ;if ( ! error ) {","if ( ! osStrcmp ( path , ""."" ) ) {ftpClientFormatCommand ( context , ""LIST"" , NULL ) ;}else {ftpClientFormatCommand ( context , ""LIST"" , path ) ;}if ( ! error ) {",4319
275,"if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) {vfy |= RPMVERIFY_LSTATFAIL ;goto exit ;","if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) ) {struct stat dsb ;if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) {uid_t fuid ;if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) {sb = dsb ;}}",4320
276,"req -> started = false ;list_del ( & req -> list ) ;req -> remaining = 0 ;if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ;if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ;req -> trb = NULL ;trace_dwc3_gadget_giveback ( req ) ;usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ;spin_lock ( & dwc -> lock ) ;if ( dep -> number > 1 )  pm_runtime_put ( dwc -> dev ) ;","dwc3_gadget_del_and_unmap_request ( dep , req , status ) ;",4321
277,"ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;",4322
278,"if ( fop == NULL )  return - E_NOTHANDLED ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;","if ( fop == NULL ) return - E_NOTHANDLED ;if ( ninst == 0 ) return - E_INVALID ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;",4323
279,return new_ns ;},new_ns -> mounts = 0 ;new_ns -> pending_mounts = 0 ;return new_ns ;},4324
280,"# ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}# endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;","SSL_SET_OPTIONS ( & mysql ) ;if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",4325
281,struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ;struct extent_tree * et ;struct extent_node * en ;struct extent_info ei ;if ( ! f2fs_may_extent_tree ( inode ) ) {if ( i_ext && i_ext -> len ) {i_ext -> len = 0 ;return true ;}return false ;}et = __grab_extent_tree ( inode ) ;if ( ! i_ext || ! i_ext -> len )  return false ;,"bool ret = __f2fs_init_extent_tree ( inode , i_ext ) ;if ( ! i_ext || ! i_ext -> len ) return false ;",4326
282,return false ;},return ret ;},4326
283,"size_t buf_size = 0 ;oe_errno = 0 ;if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_sendmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , flags ) != OE_OK ) {done :  if ( buf ) oe_free ( buf ) ;","size_t buf_size = 0 ;size_t data_size = 0 ;oe_errno = 0 ;if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_sendmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , flags ) != OE_OK ) {if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : if ( buf ) oe_free ( buf ) ;",4327
284,"static stmt_ty  ast_for_for_stmt ( struct compiling * c , const node * n , int is_async )   {asdl_seq * _target , * seq = NULL , * suite_seq ;","static stmt_ty ast_for_for_stmt ( struct compiling * c , const node * n0 , bool is_async ) {const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ;asdl_seq * _target , * seq = NULL , * suite_seq ;",4328
285,"if ( is_async ) return AsyncFor ( target , expression , suite_seq , seq ,  type_comment , LINENO ( n ) , n -> n_col_offset ,  c -> c_arena ) ;","if ( is_async ) return AsyncFor ( target , expression , suite_seq , seq , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , c -> c_arena ) ;",4328
286,while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) &&  ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error )  {,while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) {,4329
287,"if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox )  {","size_t len = 0 ;if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) {",4330
288,"snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>\\\\""%s\\\\"""" , subscribe ? """" : ""un"" , path ) ;if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\\","len = snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>"" , subscribe ? """" : ""un"" ) ;imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true ) ;if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\\",4330
289,dsize += svbranch . len ;},dsize += svbranch . len + 1 ;},4331
290,icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ;,"icon_file . directory [ i ] . size ;if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) = ReadBlobLSBLong ( image ) ;",4332
291,"length = icon_file . directory [ i ] . size ;png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ;","length = icon_file . directory [ i ] . size ;png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ;",4332
292,if ( old -> curframe != cur -> curframe )  return false ;,if ( old -> curframe != cur -> curframe ) return false ;if ( old -> speculative && ! cur -> speculative ) return false ;,4333
293,"Image  * image ;MagickBooleanType status ;unsigned int bit , byte , bytes_per_line , height , length , padding ,  value ,  version , width ;","Image * image ;int c ;MagickBooleanType status ;unsigned int bit , byte , bytes_per_line , height , length , padding , version , width ;",4334
294,image -> colormap [ 0 ] . red = QuantumRange ;image -> colormap [ 0 ] . green = QuantumRange ;image -> colormap [ 0 ] . blue = QuantumRange ;image -> colormap [ 1 ] . red = ( Quantum ) 0 ;image -> colormap [ 1 ] . green = ( Quantum ) 0 ;image -> colormap [ 1 ] . blue = ( Quantum ) 0 ;if ( image_info -> ping != MagickFalse ) {,image -> colormap [ 0 ] . red = 0.0 ;image -> colormap [ 0 ] . green = 0.0 ;image -> colormap [ 0 ] . blue = 0.0 ;if ( image_info -> ping != MagickFalse ) {,4334
295,"value = XBMInteger ( image , hex_digits ) ;* p ++ = ( unsigned char ) value ;if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) )  * p ++ = ( unsigned char ) ( value >> 8 ) ;}value = XBMInteger ( image , hex_digits ) ;* p ++ = ( unsigned char ) value ;}","c = XBMInteger ( image , hex_digits ) ;if ( c < 0 ) break ;* p ++ = ( unsigned char ) c ;if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) * p ++ = ( unsigned char ) ( c >> 8 ) ;}c = XBMInteger ( image , hex_digits ) ;if ( c < 0 ) break ;* p ++ = ( unsigned char ) c ;}if ( EOFBlob ( image ) != MagickFalse ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}",4334
296,"if ( bit == 0 )  byte = ( size_t ) ( * p ++ ) ;SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ;","if ( bit == 0 ) byte = ( unsigned int ) ( * p ++ ) ;SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ;",4334
297,"rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ;}","rc = expandRegular ( fi , dest , psm , 1 , nodigest , 1 ) ;}",4335
298,"if ( ! rc )  rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ;}if ( ! rc )  rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ;* firsthardlink = - 1 ;","if ( ! rc ) rc = expandRegular ( fi , dest , psm , 1 , nodigest , 0 ) ;}if ( ! rc ) rc = expandRegular ( fi , dest , psm , 0 , nodigest , 0 ) ;* firsthardlink = - 1 ;",4335
299,"int rv ;clear_bit ( WDM_RESETTING , & desc -> flags ) ;","int rv ;clear_bit ( WDM_OVERFLOW , & desc -> flags ) ;clear_bit ( WDM_RESETTING , & desc -> flags ) ;",4336
300,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_association_put ( asoc ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\out_unlock : bh_unlock_sock ( sk ) ;sctp_association_put ( asoc ) ;",4337
301,"unsigned int len ;unsigned long start = 0 , off ;fbdev = to_au1100fb_device ( fbi ) ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {",fbdev = to_au1100fb_device ( fbi ) ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {,4338
302,"if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) {return - EAGAIN ;}return 0 ;","return vm_iomap_memory ( vma , fbdev -> fb_phys , fbdev -> fb_len ) ;",4338
303,"ND_PRINT ( ( ndo , ""\\\switch ( opt ) {case IPCPOPT_2ADDR : if ( len != 10 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 6 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ;break ;case IPCPOPT_IPCOMP : if ( len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;",ND_TCHECK_16BITS ( p + 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;,4339
304,"enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ;status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ;if ( ( status & EIR_LINKIF ) != 0 )  {enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE ) ;interface -> nicEvent = TRUE ;if ( ( status & EIR_PKTIF ) != 0 )  {enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_PKTIE ) ;interface -> nicEvent = TRUE ;if ( ( status & ( EIR_TXIF | EIE_TXERIE ) ) != 0 )  {enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIE_TXERIE ) ;flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ;enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ;return flag ;","enc28j60ClearBit ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE ) ;status = enc28j60ReadReg ( interface , ENC28J60_EIR ) ;if ( ( status & ENC28J60_EIR_LINKIF ) != 0 ) {enc28j60ClearBit ( interface , ENC28J60_EIE , ENC28J60_EIE_LINKIE ) ;interface -> nicEvent = TRUE ;if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT ) != 0 ) {enc28j60ClearBit ( interface , ENC28J60_EIE , ENC28J60_EIE_PKTIE ) ;interface -> nicEvent = TRUE ;if ( ( status & ( ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE ) ) != 0 ) {enc28j60ClearBit ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE ) ;flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ;enc28j60SetBit ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE ) ;return flag ;",4340
305,"
",if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;,4341
306,"
",if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;,4341
307,"temp = ( struct sackhole * )  pool_get ( & sackhl_pool , PR_NOWAIT ) ;","temp = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ;",4341
308,"temp = ( struct sackhole * )  pool_get ( & sackhl_pool , PR_NOWAIT ) ;","temp = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ;",4341
309,"# if ENABLE_BGP_VNC  case BGP_ATTR_VNC : attrname = ""VNC"" ;","# if ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC : attrname = ""VNC"" ;",4342
310,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;flags = FAULT_FLAG_ALLOW_RETRY ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;flags = FAULT_FLAG_ALLOW_RETRY ;",4343
311,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , regs , address ) ;",4343
312,"static int t220_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ 3 ] = {0xe , 0x87 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x86 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x80 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 50 ) ;obuf [ 0 ] = 0xe ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config ,   & d -> dev -> i2c_adap , NULL ) ;if ( d -> fe_adap [ 0 ] . fe != NULL ) {if ( dvb_attach ( tda18271_attach , d -> fe_adap [ 0 ] . fe , 0x60 ,   & d -> dev -> i2c_adap , & tda18271_config ) ) {info ( ""Attached<S2SV_blank>TDA18271HD/CXD2820R!"" ) ;","static int t220_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x87 ;state -> data [ 2 ] = 0x0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x86 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 50 ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config , & d -> i2c_adap , NULL ) ;if ( d -> fe_adap [ 0 ] . fe != NULL ) {if ( dvb_attach ( tda18271_attach , adap -> fe_adap [ 0 ] . fe , 0x60 , & d -> i2c_adap , & tda18271_config ) ) {info ( ""Attached<S2SV_blank>TDA18271HD/CXD2820R!"" ) ;",4344
313,"if ( ! validate_event ( & fake_pmu , leader ) )  return - EINVAL ;if ( ! validate_event ( & fake_pmu , sibling ) )  return - EINVAL ;if ( ! validate_event ( & fake_pmu , event ) )  return - EINVAL ;","if ( ! validate_event ( event -> pmu , & fake_pmu , leader ) ) return - EINVAL ;if ( ! validate_event ( event -> pmu , & fake_pmu , sibling ) ) return - EINVAL ;if ( ! validate_event ( event -> pmu , & fake_pmu , event ) ) return - EINVAL ;",4345
314,"fd = open ( authfile , O_RDONLY , 0 ) ;if ( fd < 0 ) {","fd = open ( authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY ) ;if ( fd < 0 ) {else {fd = - 1 ;}",4346
315,goto err ;},goto err ;},4346
316,else if ( fd >= 0 )  close ( fd ) ;,if ( fd >= 0 ) close ( fd ) ;,4346
317,ether_setup ( dev ) ;if ( iface ) {,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;ether_setup ( dev ) ;if ( iface ) {,4347
318,"if ( ACTION ( RUN ) )  handle_run ( req , res ) ;else if ( ACTION ( DOACTION ) )  handle_do_action ( req , res ) ;else  handle_action ( req , res ) ;}","if ( ACTION ( RUNTIME ) ) handle_runtime_action ( req , res ) ;else if ( ACTION ( VIEWLOG ) ) do_viewlog ( req , res ) ;else if ( ACTION ( DOACTION ) ) handle_doaction ( req , res ) ;else handle_service_action ( req , res ) ;}",4348
319,"list_add ( & dev -> vm_node , & kvm -> devices ) ;mutex_unlock ( & kvm -> lock ) ;if ( ops -> init ) ops -> init ( dev ) ;ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ;if ( ret < 0 ) {mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;ops -> destroy ( dev ) ;return ret ;}kvm_get_kvm ( kvm ) ;cd -> fd = ret ;",kvm_get_kvm ( kvm ) ;cd -> fd = ret ;,4349
320,"Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ;","if ( len > INT_MAX ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ;RETURN_FALSE ;}Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ;",4350
321,"
",char * txt = op -> txt ;int txtLen = strlen ( op -> txt ) ;int txtLeft = R_ASM_BUFSIZE - txtLen ;txt += txtLen ;,4351
322,"for ( i = 0 ;i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;}snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ;free ( table ) ;","for ( i = 0 ;i < count && txtLen + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;txtLen = strlen ( txt ) ;txt += txtLen ;txtLeft -= txtLen ;}snprintf ( txt , txtLeft - 1 , ""%d"" , def ) ;free ( table ) ;",4351
323,addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;addr . sin_port = htons ( port ) ;,addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;addr . sin_port = htons ( port ) ;,4352
324,while ( ! EOFBlob ( image ) )  {if ( filepos != ( unsigned int ) filepos )  break ;if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) )  goto MATLAB_KO ;,while ( filepos < GetBlobSize ( image ) && ! EOFBlob ( image ) ) {if ( filepos > GetBlobSize ( image ) || filepos < 0 ) break ;if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) >= GetBlobSize ( image ) ) goto MATLAB_KO ;,4353
325,"if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) ,  ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ;goto ExitLoop ;","ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ;goto ExitLoop ;",4353
326,"static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize )  {","static UINT32 nsc_rle_encode ( const BYTE * in , BYTE * out , UINT32 originalSize ) {",4354
327,"static void vp8_init_ctx ( vpx_codec_ctx_t * ctx , const vpx_codec_mmap_t * mmap )  {int i ;ctx -> priv = mmap -> base ;ctx -> priv -> sz = sizeof ( * ctx -> priv ) ;","static void vp8_init_ctx ( vpx_codec_ctx_t * ctx ) {vpx_codec_alg_priv_t * priv = ( vpx_codec_alg_priv_t * ) vpx_calloc ( 1 , sizeof ( * priv ) ) ;ctx -> priv = ( vpx_codec_priv_t * ) priv ;ctx -> priv -> sz = sizeof ( * ctx -> priv ) ;",4355
328,if ( ctx -> config . dec )  {ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ;ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ;},priv -> si . sz = sizeof ( priv -> si ) ;priv -> decrypt_cb = NULL ;priv -> decrypt_state = NULL ;if ( ctx -> config . dec ) {priv -> cfg = * ctx -> config . dec ;ctx -> config . dec = & priv -> cfg ;},4355
329,"int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ;int32 bytes_read = 0 ;uint16 bps , nstrips , planar , strips_per_sample ;uint32 src_rowsize , dst_rowsize , rows_processed , rps ;","int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ;uint32 j ;int32 bytes_read = 0 ;uint16 bps , planar ;uint32 nstrips ;uint32 strips_per_sample ;uint32 src_rowsize , dst_rowsize , rows_processed , rps ;",4356
330,"static int override_release ( char __user * release , int len )  {int ret = 0 ;char buf [ 65 ] ;char * rest = UTS_RELEASE ;int ndots = 0 ;unsigned v ;while ( * rest ) {snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ;ret = copy_to_user ( release , buf , len ) ;}","static int override_release ( char __user * release , size_t len ) {int ret = 0 ;const char * rest = UTS_RELEASE ;char buf [ 65 ] = {0 };int ndots = 0 ;unsigned v ;size_t copy ;while ( * rest ) {copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ;copy = scnprintf ( buf , copy , ""2.6.%u%s"" , v , rest ) ;ret = copy_to_user ( release , buf , copy + 1 ) ;}",4357
331,"pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ;void * memory ;","pgprot_t prot = __get_dma_pgprot ( attrs , PAGE_KERNEL ) ;void * memory ;",4358
332,"rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb ,  plinux_opts ) ;","rc = foreach_shareopt ( shareopts , get_linux_shareopts_cb , plinux_opts ) ;",4359
333,"
","if ( s -> image_offset_x || s -> image_offset_y ) {avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ;return AVERROR_PATCHWELCOME ;}",4360
334,ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,4360
335,"return ;}ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\\switch ( pt ) {case PT_IPV4 : ip_print ( ndo , p , length ) ;case PT_OSI :  isoclns_print ( ndo , p , length , length ) ;break ;","case PT_OSI : isoclns_print ( ndo , p , length , length ) ;break ;",4361
336,for ( i = num_excl_chan ;i ++ )  {,if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;for ( i = num_excl_chan ;i ++ ) {,4362
337,if ( esd ) {streamType = esd -> decoderConfig -> streamType ;,if ( esd && esd -> decoderConfig ) {streamType = esd -> decoderConfig -> streamType ;,4363
338,"mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ;# ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ;","mutt_bcache_del ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) ;# ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ;",4364
339,if ( val == 0 && sp -> do_auto_asconf ) {list_del ( & sp -> auto_asconf_list ) ;return 0 ;},spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;if ( val == 0 && sp -> do_auto_asconf ) {list_del ( & sp -> auto_asconf_list ) ;spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;return 0 ;},4365
340,"
",oidc_scrub_headers ( r ) ;,4366
341,char * authn_header = oidc_cfg_dir_authn_header ( r ) ;int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ;,char * authn_header = oidc_cfg_dir_authn_header ( r ) ;int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ;,4366
342,char fnam [ PROCLEN ] ;FILE * f ;char * line = NULL ;size_t len = 0 ;,char * line = NULL ;size_t len = 0 ;,4367
343,"if ( ! c2 )  goto out ;* c2 = \'\\\\0\' ;if ( strcmp ( c1 , contrl ) != 0 ) continue ;c2 ++ ;stripnewline ( c2 ) ;if ( nextcg )  * nextcg = get_next_cgroup_dir ( linecmp , cg ) ;goto out ;}goto out ;}out : fclose ( f ) ;free ( line ) ;","if ( ! c2 ) return false ;if ( nextcg ) {* nextcg = get_next_cgroup_dir ( linecmp , cg ) ;}goto out ;}out : free ( c2 ) ;",4367
344,"if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) {error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name ,  slurm_strerror ( errno ) ) ;","if ( ( fd = _open_as_other ( path_name , req ) ) == - 1 ) {error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , slurm_strerror ( errno ) ) ;",4368
345,"
","size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;",4369
346,params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,4369
347,"static char *  base64_decode_string ( const char * enc ) {if ( enc == NULL )  return NULL ;char * dec = g_strdup ( enc ) ;gsize len ;g_base64_decode_inplace ( dec , & len ) ;dec [ len ] = '\\\\0' ;","static gchar * base64_decode_string ( const char * enc ) {gchar * dec ;gsize len ;if ( enc == NULL ) return NULL ;dec = ( gchar * ) g_base64_decode ( enc , & len ) ;if ( dec ) dec [ len ] = '\\\\0' ;",4370
348,if ( socket -> interface != NULL )  {,if ( message -> interface != NULL ) {interface = message -> interface ;}else if ( socket -> interface != NULL ) {,4371
349,stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ;stripinplane = ( strip % stripsperplane ) ;,stripsperplane = TIFFhowmany_32_maxuint_compat ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ;stripinplane = ( strip % stripsperplane ) ;,4372
350,if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) )  return - EINVAL ;,if ( validate_core_offset ( reg ) ) return - EINVAL ;if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ;,4373
351,"safe_print ( value , valsz , NULL ) ;fputs ( ""\\\safe_print ( value , valsz , ""\\\\"""" ) ;fputs ( ""\\\\"""" , stdout ) ;","safe_print ( value , valsz , ""<S2SV_blank>\\\\\\\\\\\\""\\\'$`<>"" ) ;fputs ( ""\\\safe_print ( value , valsz , ""\\\\""\\\\\\\\"" ) ;fputs ( ""\\\\"""" , stdout ) ;",4374
352,"if ( s -> rlayer . numwpipes < numpipes ) if ( ! ssl3_setup_write_buffer ( s , numpipes , 0 ) ) return - 1 ;if ( totlen == 0 && ! create_empty_fragment ) return 0 ;sess = s -> session ;if ( ( sess == NULL ) || ( s -> enc_write_ctx == NULL ) || ( EVP_MD_CTX_md ( s -> write_hash ) == NULL ) ) {clear = s -> enc_write_ctx ? 0 : 1 ;mac_size = 0 ;}else {mac_size = EVP_MD_CTX_size ( s -> write_hash ) ;if ( mac_size < 0 ) goto err ;}if ( ! clear && ! create_empty_fragment && ! s -> s3 -> empty_fragment_done ) {if ( s -> s3 -> need_empty_fragments && type == SSL3_RT_APPLICATION_DATA ) {unsigned int tmppipelen = 0 ;prefix_len = do_ssl3_write ( s , type , buf , & tmppipelen , 1 , 1 ) ;if ( prefix_len <= 0 ) goto err ;if ( prefix_len > ( SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD ) ) {SSLerr ( SSL_F_DO_SSL3_WRITE , ERR_R_INTERNAL_ERROR ) ;goto err ;}}s -> s3 -> empty_fragment_done = 1 ;}if ( create_empty_fragment ) {wb = & s -> rlayer . wbuf [ 0 ] ;# if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( size_t ) SSL3_BUFFER_get_buf ( wb ) + 2 * SSL3_RT_HEADER_LENGTH ;align = SSL3_ALIGN_PAYLOAD - 1 - ( ( align - 1 ) % SSL3_ALIGN_PAYLOAD ) ;# endif outbuf [ 0 ] = SSL3_BUFFER_get_buf ( wb ) + align ;SSL3_BUFFER_set_offset ( wb , align ) ;}else if ( prefix_len ) {wb = & s -> rlayer . wbuf [ 0 ] ;outbuf [ 0 ] = SSL3_BUFFER_get_buf ( wb ) + SSL3_BUFFER_get_offset ( wb ) + prefix_len ;}else {for ( j = 0 ;j < numpipes ;j ++ ) {wb = & s -> rlayer . wbuf [ j ] ;# if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( size_t ) SSL3_BUFFER_get_buf ( wb ) + SSL3_RT_HEADER_LENGTH ;align = SSL3_ALIGN_PAYLOAD - 1 - ( ( align - 1 ) % SSL3_ALIGN_PAYLOAD ) ;# endif outbuf [ j ] = SSL3_BUFFER_get_buf ( wb ) + align ;SSL3_BUFFER_set_offset ( wb , align ) ;}}if ( s -> enc_write_ctx && SSL_USE_EXPLICIT_IV ( s ) ) {",if ( s -> rlayer . numwpipes < numpipes ) if ( ! SSL_WRITE_ETM ( s ) ) {,4375
353,"if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) {if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , 1 ) < 0 ) goto err ;","if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) {if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , 1 ) < 0 ) goto err ;",4375
354,"if ( SSL_USE_ETM ( s ) && mac_size != 0 ) {if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) goto err ;","if ( SSL_WRITE_ETM ( s ) && mac_size != 0 ) {if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) goto err ;",4375
355,"static int read_frame_stats ( const struct twopass_rc * p ,  FIRSTPASS_STATS * frame_stats , int offset ) {const FIRSTPASS_STATS * fps_ptr = p -> stats_in ;if ( offset >= 0 ) {if ( & fps_ptr [ offset ] >= p -> stats_in_end )  return EOF ;}else if ( offset < 0 ) {if ( & fps_ptr [ offset ] < p -> stats_in_start )  return EOF ;* frame_stats = fps_ptr [ offset ] ;return 1 ;}","static const FIRSTPASS_STATS * read_frame_stats ( const struct twopass_rc * p , FIRSTPASS_STATS * frame_stats , int offset ) {if ( ( offset >= 0 ) {if ( & fps_ptr [ offset ] >= p -> stats_in_end ) || ( offset < 0 ) {if ( & fps_ptr [ offset ] < p -> stats_in_start ) ) {return NULL ;}return & p -> stats_in [ offset ] ;",4376
356,"goto err_free_mem ;}buf [ BUF_SIZE - 1 ] = \'\\\\0\' ;dev_info ( s -> dev , ""Board<S2SV_blank>ID:<S2SV_blank>%02x\\\dev_info ( s -> dev , ""Firmware<S2SV_blank>version:<S2SV_blank>%s\\\s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ;s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ;s -> vb_queue . drv_priv = s ;s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ;s -> vb_queue . ops = & airspy_vb2_ops ;s -> vb_queue . mem_ops = & vb2_vmalloc_memops ;s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ;ret = vb2_queue_init ( & s -> vb_queue ) ;if ( ret ) {dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\\goto err_free_mem ;}s -> vdev = airspy_template ;s -> vdev . queue = & s -> vb_queue ;s -> vdev . queue -> lock = & s -> vb_queue_lock ;video_set_drvdata ( & s -> vdev , s ) ;s -> v4l2_dev . release = airspy_video_release ;ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ;if ( ret ) {dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\\goto err_free_mem ;}v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ;s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ;s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ;v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ;s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ;s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ;v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ;s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ;if ( s -> hdl . error ) {ret = s -> hdl . error ;dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\\v4l2_ctrl_handler_setup ( & s -> hdl ) ;s -> v4l2_dev . ctrl_handler = & s -> hdl ;s -> vdev . v4l2_dev = & s -> v4l2_dev ;s -> vdev . lock = & s -> v4l2_lock ;ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ;if ( ret ) {dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\\goto err_unregister_v4l2_dev ;}err_unregister_v4l2_dev :  v4l2_device_unregister ( & s -> v4l2_dev ) ;",err_unregister_v4l2_dev : v4l2_device_unregister ( & s -> v4l2_dev ) ;,4377
357,"static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",4378
358,if ( noblock )  return - EAGAIN ;,cond_resched ( ) ;,4379
359,"if ( ret < 0 ) return ret ;key -> expiry = prep -> expiry ;if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  zap = dereference_key_locked ( key ) ;",if ( key_is_positive ( key ) ) zap = dereference_key_locked ( key ) ;,4380
360,"for ( j = 0 ;j ++ )   av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ;av_log ( s , AV_LOG_DEBUG , ""\\\'\\\","for ( j = 0 ;j ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ;}av_log ( s , AV_LOG_DEBUG , ""\\\'\\\",4381
361,if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {ret = - ENOTCONN ;goto out ;}if ( payload_len > rds_sk_sndbuf ( rs ) ) {,lock_sock ( sk ) ;if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {release_sock ( sk ) ;ret = - ENOTCONN ;goto out ;}release_sock ( sk ) ;if ( payload_len > rds_sk_sndbuf ( rs ) ) {,4382
362,case IS_STRING :  convert_to_double_ex ( tmp ) ;m1 [ i ] = Z_DVAL_PP ( tmp ) ;break ;,case IS_STRING : {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;m1 [ i ] = Z_DVAL ( dval ) ;}break ;,4383
363,case IS_STRING :  convert_to_double_ex ( tmp ) ;m2 [ i ] = Z_DVAL_PP ( tmp ) ;break ;,case IS_STRING : {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;m2 [ i ] = Z_DVAL ( dval ) ;}break ;,4383
364,"jas_stream_t * stream ;jas_stream_memobj_t * obj ;if ( ! ( stream = jas_stream_create ( ) ) ) {return 0 ;}stream -> openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY ;jas_stream_initbuf ( stream , JAS_STREAM_FULLBUF , 0 , 0 ) ;stream -> ops_ = & jas_stream_memops ;if ( ! ( obj = jas_malloc ( sizeof ( jas_stream_memobj_t ) ) ) ) {jas_stream_destroy ( stream ) ;return 0 ;stream -> obj_ = ( void * ) obj ;obj -> myalloc_ = 0 ;obj -> buf_ = 0 ;obj -> bufsize_ = 1024 ;obj -> growable_ = 1 ;obj -> bufsize_ = bufsize ;obj -> growable_ = 0 ;}","char * new_buf ;size_t new_bufsize ;if ( bufsize < 0 ) {jas_deprecated ( ""negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen"" ) ;}if ( buf && bufsize <= 0 ) {jas_eprintf ( ""Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\\jas_deprecated ( ""A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>"" ""jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\\obj -> bufsize_ = 1024 ;obj -> growable_ = 1 ;obj -> bufsize_ = bufsize ;obj -> growable_ = 0 ;}",4384
365,"case SO_KEEPALIVE : # ifdef CONFIG_INET  if ( sk -> sk_protocol == IPPROTO_TCP )  tcp_set_keepalive ( sk , valbool ) ;","case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) tcp_set_keepalive ( sk , valbool ) ;",4385
366,net -> dev_base_seq = 1 ;net -> user_ns = user_ns ;,"get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;net -> dev_base_seq = 1 ;net -> user_ns = user_ns ;",4386
367,"overrun = timr -> it_overrun_last ;unlock_timer ( timr , flags ) ;","overrun = timer_overrun_to_int ( timr , 0 ) ;unlock_timer ( timr , flags ) ;",4387
368,"if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;","if ( map && nmap ) cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;else cp = ikev1_attr_print ( ndo , cp , ep2 ) ;if ( cp == NULL ) goto trunc ;",4388
369,"int length ;ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;in_uint8s ( s , length ) ;","uint32 length ;struct stream packet = * s ;ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , length ) ;",4389
370,"int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ;bool grab_newname = false ;fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , getpid ( ) ) ;return - 1 ;}fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , pid ) ;return - 1 ;}if ( setns ( fd , 0 ) < 0 ) {fprintf ( stderr , ""setns<S2SV_blank>to<S2SV_blank>container<S2SV_blank>network<S2SV_blank>namespace\\\goto out_err ;}close ( fd ) ;if ( ! * newnamep ) {if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) {fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index\\\goto out_err ;if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) {fprintf ( stderr , ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container\\\goto out_err ;char ifname [ IFNAMSIZ ] , * namep = ifname ;if ( ! if_indextoname ( ifindex , namep ) ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\\goto out_err ;if ( ! * newnamep )  goto out_err ;}if ( setns ( ofd , 0 ) < 0 ) {fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>netns\\\close ( ofd ) ;return - 1 ;}return 0 ;out_err : if ( ofd >= 0 ) close ( ofd ) ;if ( setns ( ofd , 0 ) < 0 ) fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace\\\if ( fd >= 0 ) close ( fd ) ;return - 1 ;","uid_t ruid , suid , euid ;int fret = - 1 ;int fd = - 1 , ifindex = - 1 , ofd = - 1 , ret ;bool grab_newname = false ;usernic_error ( ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , getpid ( ) ) ;return fret ;}usernic_error ( ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , pid ) ;return - 1 ;}if ( setns ( fd , CLONE_NEWNET ) ;close ( fd ) ;if ( ! * newnamep ) {if ( ! ifindex ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\\goto do_full_cleanup ;ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ;if ( ret < 0 ) {usernic_error ( ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\\goto do_full_cleanup ;char ifname [ IFNAMSIZ ] , * namep = ifname ;if ( ! if_indextoname ( ifindex , namep ) ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\\goto do_full_cleanup ;if ( ! * newnamep ) goto do_full_cleanup ;}fret = 0 ;do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ;if ( ret < 0 ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\\fret = - 1 ;}ret = setns ( ofd , CLONE_NEWNET ) ;if ( ret < 0 ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>"" ""of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\\fret = - 1 ;}do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ;return fret ;",4390
371,for ( i = 0 ;i ++ )  {for ( i = 0 ;i ++ )  {}},"for ( i = 0 ;++ i ) {for ( i = 0 ;++ i ) {vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ;}}",4391
372,if ( strlen ( parv [ 1 ] ) > 400 )  {,"if ( ( parv [ 1 ] [ 0 ] == \':\' ) || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) {sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , ""*"" , ""AUTHENTICATE"" , ""Invalid<S2SV_blank>parameter"" ) ;return 0 ;}if ( strlen ( parv [ 1 ] ) > 400 ) {",4392
373,"if ( timeCompare ( time , context -> startTime + context -> timeout ) >= 0 ) {context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTING ;error = ERROR_TIMEOUT ;}else if ( timeCompare ( time , context -> retransmitStartTime + MQTT_SN_CLIENT_RETRY_TIMEOUT ) >= 0 ) {error = mqttSnClientSendSubscribe ( context , topicName , qos ) ;}else {error = mqttSnClientProcessEvents ( context , MQTT_SN_CLIENT_TICK_INTERVAL ) ;}}else if ( context -> state == MQTT_SN_CLIENT_STATE_RESP_RECEIVED ) {context -> state = MQTT_SN_CLIENT_STATE_ACTIVE ;if ( context -> msgType == MQTT_SN_MSG_TYPE_SUBACK ) {if ( context -> returnCode == MQTT_SN_RETURN_CODE_ACCEPTED ) {if ( strchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL )  {","if ( osStrchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL ) {",4393
374,"struct dentry * dentry = path -> dentry ;struct inode * inode = dentry -> d_inode ;file -> f_path = * path ;}return do_dentry_open ( file , inode , NULL , cred ) ;","struct inode * inode = dentry -> d_inode ;file -> f_path = * path ;file -> f_path = * path ;return do_dentry_open ( file , inode , NULL , cred ) ;",4394
375,"char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}switch ( data [ 0 ] ) {return - EIO ;}return snprintf ( buf , PAGE_SIZE , ""%s\\\","char * data ;data = kmalloc ( 2 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}switch ( data [ 0 ] ) {ret = - EIO ;goto out ;}ret = snprintf ( buf , PAGE_SIZE , ""%s\\\out : kfree ( data ) ;return ret ;",4395
376,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 )  return 0 ;if ( error == 0 ) acl = NULL ;","error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ;if ( error ) return error ;",4396
377,retval = xfs_attr_shortform_lookup ( args ) ;if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) {return retval ;else if ( retval == - EEXIST ) {if ( args -> flags & ATTR_CREATE ) return retval ;retval = xfs_attr_shortform_remove ( args ) ;ASSERT ( retval == 0 ) ;},if ( retval ) return retval ;args -> flags &= ~ ATTR_REPLACE ;,4397
378,"status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( image == ( Image * ) NULL )  image = screen ;","if ( image == ( Image * ) NULL ) image = screen ;status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;",4398
379,"static void  pci_msix_table_init ( struct pci_vdev * dev , int table_entries ) {int i , table_size ;assert ( table_entries > 0 ) ;assert ( table_entries <= MAX_MSIX_TABLE_ENTRIES ) ;assert ( dev -> msix . table != NULL ) ;for ( i = 0 ;}","static int pci_msix_table_init ( struct pci_vdev * dev , int table_entries ) {int i , table_size ;if ( ! dev -> msix . table ) {pr_err ( ""%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>memory!\\\return - 1 ;}for ( i = 0 ;return 0 ;}",4399
380,"int err ;err = crypto_ahash_export ( req , state ) ;if ( err ) return err ;ctx2 -> more = 1 ;err = crypto_ahash_import ( & ctx2 -> req , state ) ;","bool more ;int err ;lock_sock ( sk ) ;more = ctx -> more ;err = more ? crypto_ahash_export ( req , state ) : 0 ;release_sock ( sk ) ;if ( err ) return err ;ctx2 -> more = more ;if ( ! more ) return err ;err = crypto_ahash_import ( & ctx2 -> req , state ) ;",4400
381,case DB_VECTOR :  dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ;,"case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ;return 1 ;case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ;",4401
382,if ( x & ( 1 << i ) ) return i ;},if ( x & ( 1U << ( unsigned int ) i ) ) return i ;},4402
383,"if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\","if ( q < p ) {DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\\goto out ;}if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\",4403
384,"struct completion * vfork_done = tsk -> vfork_done ;deactivate_mm ( tsk , mm ) ;","struct completion * vfork_done = tsk -> vfork_done ;# ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ;# ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ;# endif # endif deactivate_mm ( tsk , mm ) ;",4404
385,"rrd_graph_options ( argc , argv , & im ) ;if ( rrd_test_error ( ) ) {rrd_info_free ( im . grinfo ) ;im_free ( & im ) ;","
",4405
386,"rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ;return NULL ;","rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ;return NULL ;",4405
387,void * zmalloc ( size_t size ) {void * ptr = malloc ( size + PREFIX_SIZE ) ;,void * zmalloc ( size_t size ) {ASSERT_NO_SIZE_OVERFLOW ( size ) ;void * ptr = malloc ( size + PREFIX_SIZE ) ;,4406
388,ret = 0 ;goto error2 ;,key_put ( keyring ) ;ret = 0 ;goto error2 ;,4407
389,pWTIntFrame -> numSamples = 0 ;},"android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;pWTIntFrame -> numSamples = 0 ;}",4408
390,return ;}return ;},}}return ;ND_TCHECK_16BITS ( bp ) ;,4409
391,"switch ( EXTRACT_16BITS ( bp ) ) {case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;","switch ( EXTRACT_16BITS ( bp ) ) {case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;",4409
392,"int fourcc_is_ivf ( const char detect [ 4 ] ) {if ( memcmp ( detect , ""DKIF"" , 4 ) == 0 ) {","static int fourcc_is_ivf ( const char detect [ 4 ] ) {if ( memcmp ( detect , ""DKIF"" , 4 ) == 0 ) {",4410
393,OPJ_UNUSED ( p_manager ) ;if ( p_total_data_size < 12 ) {,if ( p_total_data_size < 12 ) {,4411
394,"int ret ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;","int ret ;if ( current_chrooted ( ) ) return - EPERM ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;",4412
395,"
",GTextFieldSaved ( gt ) ;,4413
396,},},4413
397,"
",buflen ++ ;,4414
398,continue ;},continue ;},4414
399,"while ( len -- )  ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ;","while ( len -- > 0 ) ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ;",4415
400,"while ( len -- )  ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ;","while ( len -- > 0 ) ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ;",4415
401,"if ( length < 2 ) return 0 ;elementlen = * ( p + offset + 1 ) ;if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ;if ( length < elementlen + 2 ) return 0 ;switch ( * ( p + offset ) ) {case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) )  return 0 ;","memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;",4416
402,"if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) )  return 0 ;if ( length < challenge . length ) return 0 ;","
",4416
403,"case E_RATES : memcpy ( & rates , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( rates . length != 0 ) {if ( rates . length > sizeof rates . rate ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) )  return 0 ;if ( length < rates . length ) return 0 ;memcpy ( & rates . rate , p + offset , rates . length ) ;offset += rates . length ;length -= rates . length ;}if ( ! pbody -> rates_present && rates . length != 0 ) {pbody -> rates = rates ;pbody -> rates_present = 1 ;}break ;case E_DS : memcpy ( & ds , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ds . length != 1 ) {offset += ds . length ;length -= ds . length ;break ;}ds . channel = * ( p + offset ) ;offset += 1 ;length -= 1 ;if ( ! pbody -> ds_present ) {pbody -> ds = ds ;pbody -> ds_present = 1 ;}break ;case E_CF : memcpy ( & cf , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( cf . length != 6 ) {offset += cf . length ;length -= cf . length ;break ;}memcpy ( & cf . count , p + offset , 6 ) ;offset += 6 ;length -= 6 ;if ( ! pbody -> cf_present ) {pbody -> cf = cf ;pbody -> cf_present = 1 ;}break ;case E_TIM : memcpy ( & tim , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( tim . length <= 3 ) {offset += tim . length ;length -= tim . length ;break ;}if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ;memcpy ( & tim . count , p + offset , 3 ) ;offset += 3 ;length -= 3 ;memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ;offset += tim . length - 3 ;","case E_RATES : memcpy ( & rates , p + offset , tim . length - 3 ) ;offset += tim . length - 3 ;",4416
404,"ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ;tptr += sizeof ( const struct eap_frame_t ) ;tlen -= sizeof ( const struct eap_frame_t ) ;switch ( eap -> type ) {case EAP_FRAME_TYPE_PACKET :  type = * ( tptr ) ;len = EXTRACT_16BITS ( tptr + 2 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\","ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , subtype ) , subtype ) ) ;ND_TCHECK_8BITS ( tptr + 4 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\",4417
405,"ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST :  ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM :  ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" ,  tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;","ND_TCHECK_8BITS ( tptr + count ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ;if ( subtype == EAP_TYPE_TTLS ) ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS : ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;",4417
406,"int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) {int labelfd = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 )  goto out ;if ( strcmp ( name , ""none"" ) == 0 )  goto out ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;if ( on_exec ) {labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ;}else {labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ;}if ( labelfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}ret = - 1 ;goto out ;ret = - 1 ;goto out ;}if ( write ( labelfd , command , size + 1 ) < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}else if ( strcmp ( name , ""SELinux"" ) == 0 ) {if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) {ret = - 1 ;ret = - 1 ;goto out ;if ( labelfd != - 1 )   close ( labelfd ) ;return ret ;}","static int lsm_set_label_at ( int lsm_labelfd , int on_exec , char * lsm_label ) {int fret = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 ) return 0 ;if ( strcmp ( name , ""none"" ) == 0 ) return 0 ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;ret = - 1 ;goto out ;goto out ;if ( write ( labelfd , command , size + 1 ) < 0 ) {INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ;ret = - 1 ;goto out ;if ( labelfd != - 1 ) close ( labelfd ) ;return fret ;}",4418
407,"void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {","static void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {",4419
408,"if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 )  return 0 ;","if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 || apic -> lapic_timer . period == 0 ) return 0 ;",4420
409,"__clear_bit ( * old_keycode , dev -> keybit ) ;__set_bit ( ke -> keycode , dev -> keybit ) ;for ( i = 0 ;if ( input_fetch_keycode ( dev , i ) == * old_keycode ) {","if ( * old_keycode <= KEY_MAX ) {__clear_bit ( * old_keycode , dev -> keybit ) ;for ( i = 0 ;if ( input_fetch_keycode ( dev , i ) == * old_keycode ) {}__set_bit ( ke -> keycode , dev -> keybit ) ;",4421
410,"static void  l2tp_accm_print ( netdissect_options * ndo , const u_char * dat )  {ptr ++ ;val_h = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;","static void l2tp_accm_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}return ;}length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;ptr ++ ;length -= 2 ;length -= 2 ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;",4422
411,"if ( handle && ! ext4_handle_valid ( handle ) )  return 0 ;if ( list_empty ( & ei -> i_orphan ) ) goto out ;ino_next = NEXT_ORPHAN ( inode ) ;prev = ei -> i_orphan . prev ;sbi = EXT4_SB ( inode -> i_sb ) ;jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\\list_del_init ( & ei -> i_orphan ) ;if ( sbi -> s_journal && ! handle )  goto out ;",if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) return 0 ;if ( ! handle ) goto out ;,4423
412,"case L2CAP_CONF_UNACCEPT :  if ( ++ l2cap_pi ( sk ) -> conf_retry < L2CAP_CONF_MAX_RETRIES ) {char req [ 128 ] ;l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ ,  l2cap_build_conf_req ( sk , req ) , req ) ;goto done ;}","case L2CAP_CONF_UNACCEPT : if ( l2cap_pi ( sk ) -> num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP ) {int len = cmd -> len - sizeof ( * rsp ) ;char req [ 64 ] ;result = L2CAP_CONF_SUCCESS ;len = l2cap_parse_conf_rsp ( sk , rsp -> data , len , req , & result ) ;if ( len < 0 ) {struct l2cap_disconn_req req ;req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ;req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ;l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ;goto done ;}l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , len , req ) ;l2cap_pi ( sk ) -> num_conf_req ++ ;if ( result != L2CAP_CONF_SUCCESS ) goto done ;break ;}",4424
413,}audio_conv_info -> ver_major = ver_major ;,usb_conv_info -> class_data_type = USB_CONV_AUDIO ;}else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) {return 0 ;}audio_conv_info -> ver_major = ver_major ;,4425
414,"Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ;if ( ! ( ( message -> NegotiateFlags & NTLMSSP_REQUEST_TARGET ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) ) ) {","if ( Stream_GetRemainingLength ( s ) < 4 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ;if ( ! ( ( message -> NegotiateFlags & NTLMSSP_REQUEST_TARGET ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) ) ) {",4426
415,"if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) {bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ;","if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ( ICANON | EXTPROC ) ) {bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ;",4427
416,"f = fopen ( filepath , ""rb"" ) ;if ( f ) {","f = fopen ( filepath , ""r"" ) ;if ( f ) {",4428
417,len = b - a ;str = ( char * ) PyObject_MALLOC ( len + 1 ) ;,len = ( a != NULL && b != NULL ) ? b - a : 0 ;str = ( char * ) PyObject_MALLOC ( len + 1 ) ;,4429
418,"else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""<>"" ) ) {PyObject_FREE ( str ) ;err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\\\'<>\\\'<S2SV_blank>""  ""instead<S2SV_blank>of<S2SV_blank>\\\'!=\\\'"" ;err_ret -> error = E_SYNTAX ;break ;# endif  if ( a >= tok -> line_start )  col_offset = Py_SAFE_DOWNCAST ( a - tok -> line_start , intptr_t , int ) ;else   col_offset = - 1 ;if ( type == TYPE_IGNORE ) {","err_ret -> expected = NOTEQUAL ;err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\\\'<>\\\'<S2SV_blank>"" ""instead<S2SV_blank>of<S2SV_blank>\\\'!=\\\'"" ;# endif if ( a != NULL && a >= tok -> line_start ) {col_offset = Py_SAFE_DOWNCAST ( a - tok -> line_start , intptr_t , int ) ;}else {col_offset = - 1 ;if ( type == TYPE_IGNORE ) {",4429
419,"snapend_save = ndo -> ndo_snapend ;ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ;","snapend_save = ndo -> ndo_snapend ;ND_TCHECK_16BITS ( & ip -> ip_len ) ;ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ;",4430
420,"pid_t pid ;memset ( s_path , 0 , sizeof ( s_path ) ) ;memset ( c_path , 0 , sizeof ( c_path ) ) ;pid = getpid ( ) ;","memset ( s_path , 0 , sizeof ( s_path ) ) ;memset ( c_path , 0 , sizeof ( c_path ) ) ;",4431
421,"sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix ,   hdl -> instance , ( long unsigned ) pid ) ;if ( * mgr_hdl == NULL ) {","sprintf ( c_path , ""%s%s%d_C_XXXXXX"" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ;if ( * mgr_hdl == NULL ) {",4431
422,"static const u_char * ikev1_attrmap_print ( netdissect_options * ndo ,  const u_char * p , const u_char * ep ,  const struct attrmap * map , size_t nmap ) {if ( p [ 0 ] & 0x80 )  totlen = 4 ;else  totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ep < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;ND_PRINT ( ( ndo , ""value="" ) ) ;v = EXTRACT_16BITS ( & p [ 2 ] ) ;else  rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ;}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ;}return p + totlen ;}","static const u_char * ep2 , const struct attrmap * map , size_t nmap ) {ND_TCHECK ( p [ 0 ] ) ;}if ( ep2 < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;ND_PRINT ( ( ndo , ""value="" ) ) ;v = EXTRACT_16BITS ( & p [ 2 ] ) ;else rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , totlen - 4 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}return p + totlen ;trunc : return NULL ;}",4432
423,"if ( cid <= 0 )  continue ;dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( dctx -> remaining <= 0 ) {dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( dctx -> remaining <= 0 )   return dctx -> remaining ;}","int remaining ;if ( cid <= 0 ) continue ;remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( remaining <= 0 ) {dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( remaining <= 0 ) return dctx -> remaining ;}",4433
424,"domount :  if ( mount ( ""proc"" , path , ""proc"" , 0 , NULL ) )  return - 1 ;","domount : if ( safe_mount ( ""proc"" , path , ""proc"" , 0 , NULL , rootfs ) < 0 ) return - 1 ;",4434
425,"if ( readonly &&  ( ( flags & O_ACCMODE ) == O_WRONLY ||   ( flags & O_ACCMODE ) == O_RDWR ) ) {verbose ( ""Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode"" ) ;","if ( readonly && ( ( flags & O_ACCMODE ) != O_RDONLY || ( flags & O_ACCMODE ) == O_RDWR ) ) {verbose ( ""Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode"" ) ;",4435
426,"if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) {giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data"" ) ;return - 1 ;}if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) {giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data"" ) ;return - 1 ;}GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ;res_dp = git__malloc ( alloc_sz ) ;GITERR_CHECK_ALLOC ( res_dp ) ;res_dp [ res_sz ] = \'\\\\0\' ;* out = res_dp ;* out_len = res_sz ;while ( delta < delta_end ) {unsigned char cmd = * delta ++ ;if ( cmd & 0x01 ) off = * delta ++ ;if ( cmd & 0x02 ) off |= * delta ++ << 8UL ;if ( cmd & 0x04 ) off |= * delta ++ << 16UL ;if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) ;if ( cmd & 0x10 ) len = * delta ++ ;if ( cmd & 0x20 ) len |= * delta ++ << 8UL ;if ( cmd & 0x40 ) len |= * delta ++ << 16UL ;if ( ! len ) len = 0x10000 ;if ( base_len < off + len || res_sz < len ) goto fail ;","# define ADD_DELTA ( o , shift ) {if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ ;if ( cmd & 0x01 ) off = * delta ++ ;if ( cmd & 0x02 ) off |= * delta ++ << 8UL ;if ( cmd & 0x04 ) off |= * delta ++ << 16UL ;if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) ;if ( cmd & 0x10 ) len = * delta ++ ;if ( cmd & 0x20 ) len |= * delta ++ << shift ) ;else goto fail ;}if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ;if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) ;if ( cmd & 0x40 ) ADD_DELTA ( len , 16UL ) ;if ( ! len ) len = 0x10000 ;# undef ADD_DELTA if ( base_len < off + len || res_sz < len ) goto fail ;",4436
427,"ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) ) ) ;if ( length > 2 ) {ND_PRINT ( ( ndo , ""/%u"" , EXTRACT_16BITS ( ptr ) ) ) ;}if ( length > 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length - 4 ) ;}}","if ( length == 0 ) return ;if ( length < 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) ) ) ;length -= 2 ;if ( length > 2 ) {ND_PRINT ( ( ndo , ""/%u"" , EXTRACT_16BITS ( ptr ) ) ) ;}if ( length == 0 ) return ;ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length ) ;}",4437
428,"uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm ,  KEY_ALLOC_IN_QUOTA ,  NULL , NULL ) ;","uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING | KEY_ALLOC_IN_QUOTA , NULL , NULL ) ;",4438
429,"session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm ,  KEY_ALLOC_IN_QUOTA ,  NULL , NULL ) ;","session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING | KEY_ALLOC_IN_QUOTA , NULL , NULL ) ;",4438
430,"outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>G"" , grayscale ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>g"" , grayscale ) ;}}","sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>G"" , grayscale ) ;}sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>g"" , grayscale ) ;}sendClean ( outputbuffer ) ;}",4439
431,"if ( par == STROKING ) {outpos += sprintf ( outpos , ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K"" ) ;else {}","if ( par == STROKING ) {send ( ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K"" ) ;else {}",4440
432,if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;,"struct ip_options_rcu * inet_opt ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;",4441
433,"sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ;size = 8 ;sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ;size = 4 ;","snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ;size = 8 ;snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ;size = 4 ;",4442
434,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ;strasm = r_str_concat ( strasm , str ) ;","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i"" , vA ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ;strasm = r_str_concat ( strasm , str ) ;",4442
435,"# undef llint  sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;","# undef llint snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;",4442
436,"case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{break ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default :  sprintf ( str , ""<S2SV_blank>{}sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>{strasm = r_str_concat ( strasm , str ) ;case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default :  sprintf ( str , ""<S2SV_blank>{break ;sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}","case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , "",<S2SV_blank>[%04x]"" , vB ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{strasm = r_str_concat ( strasm , str ) ;case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;snprintf ( str , sizeof ( str ) , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}",4442
437,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}",4442
438,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ;}",4442
439,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}",4442
440,"sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;case 5 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ;default :  sprintf ( str , ""<S2SV_blank>{}sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;}sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ;}sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;}sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;case 5 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>%s<S2SV_blank>;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>class+%i"" , vB ) ;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>%s<S2SV_blank>;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>method+%i"" , vB ) ;}",4442
441,"skb_dst_force ( skb ) ;skb_queue_tail ( & sk -> sk_error_queue , skb ) ;","skb_set_err_queue ( skb ) ;skb_dst_force ( skb ) ;skb_queue_tail ( & sk -> sk_error_queue , skb ) ;",4443
442,"vpx_memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ;}","memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ;}",4444
443,"umode_t mode = inode -> i_mode ;rc = posix_acl_equiv_mode ( acl , & mode ) ;if ( rc < 0 ) return rc ;","umode_t mode ;rc = posix_acl_update_mode ( inode , & mode ) ;if ( rc < 0 ) return rc ;",4445
444,if ( rc == 0 )  acl = NULL ;,"
",4445
445,u32 data ;void * vapic ;vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ;kunmap_atomic ( vapic ) ;,"u32 data ;kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ;",4446
446,"lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ;lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ;cpuctx -> ctx . type = cpu_context ;cpuctx -> ctx . pmu = pmu ;",lockdep_set_class ( & cpuctx -> ctx . pmu = pmu ;,4447
447,"args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return xdr_argsize_check ( rqstp , p ) ;}","if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return 1 ;}",4448
448,}return 0 ;,return - ENOMEM ;}return 0 ;,4449
449,"sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length ,  sizeof ( * sun_pixels ) ) ;","sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length + image -> rows , sizeof ( * sun_pixels ) ) ;",4450
450,"status = dm9000ReadReg ( DM9000_REG_ISR ) ;if ( ( status & ISR_LNKCHG ) != 0 ) {dm9000WriteReg ( DM9000_REG_ISR , ISR_LNKCHG ) ;status = dm9000ReadReg ( DM9000_REG_NSR ) ;if ( ( status & NSR_LINKST ) != 0 ) {status = dm9000ReadReg ( DM9000_REG_NCR ) ;if ( ( status & NCR_FDX ) != 0 ) {","status = dm9000ReadReg ( DM9000_ISR ) ;if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) {dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG ) ;status = dm9000ReadReg ( DM9000_NSR ) ;if ( ( status & DM9000_NSR_LINKST ) != 0 ) {if ( ( status & DM9000_NSR_SPEED ) != 0 ) {status = dm9000ReadReg ( DM9000_NCR ) ;if ( ( status & DM9000_NCR_FDX ) != 0 ) {",4451
451,"if ( ( status & ISR_PR ) != 0 )  {dm9000WriteReg ( DM9000_REG_ISR , ISR_PR ) ;do {dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR | IMR_LNKCHGI | IMR_PTI | IMR_PRI ) ;}","if ( ( status & DM9000_ISR_PR ) != 0 ) {dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PR ) ;do {dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI ) ;}",4451
452,"int index , count , i ;if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ;","unsigned int index , count , i ;if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ;",4452
453,"int index , count , i ;u8 red , green , blue ;","unsigned int index , count , i ;u8 red , green , blue ;",4452
454,"u32 hash , id ;net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ;hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ;id = ip_idents_reserve ( hash , 1 ) ;fhdr -> identification = htonl ( id ) ;","static u32 ip6_idents_hashrnd_extra __read_mostly ;u32 hash , id ;net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ;net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra ) ) ;hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ;hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ;id = ip_idents_reserve ( hash , 1 ) ;fhdr -> identification = htonl ( id ) ;",4453
455,if ( p -> question -> n_keys != 1 )  return 0 ;,if ( ! p -> question ) return 0 ;if ( p -> question -> n_keys != 1 ) return 0 ;,4454
456,retval = xfs_attr_shortform_lookup ( args ) ;if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) {return retval ;else if ( retval == - EEXIST ) {if ( args -> flags & ATTR_CREATE ) return retval ;retval = xfs_attr_shortform_remove ( args ) ;ASSERT ( retval == 0 ) ;},if ( retval ) return retval ;args -> flags &= ~ ATTR_REPLACE ;,4455
457,"static void encode_b_rt ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row , int mi_col ,  int output_enabled , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index > 0 ) return ;set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;update_state_rt ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ) ;encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ;update_stats ( cpi ) ;( * tp ) -> token = EOSB_TOKEN ;","static void encode_b_rt ( VP9_COMP * cpi , ThreadData * td , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {MACROBLOCK * const x = & td -> mb ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index > 0 ) return ;set_offsets ( cpi , td , ctx , mi_row , mi_col , bsize ) ;# if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && output_enabled && cpi -> common . frame_type != KEY_FRAME ) {vp9_denoiser_denoise ( & cpi -> denoiser , x , mi_row , mi_col , MAX ( BLOCK_8X8 , bsize ) , ctx ) ;}# endif update_state_rt ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ) ;encode_superblock ( cpi , td , tp , output_enabled , mi_row , mi_col , bsize , ctx ) ;update_stats ( & cpi -> common , td ) ;( * tp ) -> token = EOSB_TOKEN ;",4456
458,"u32 i , j , page_count = 0 , sg_per_table ;struct rd_dev_sg_table * sg_table ;struct page * pg ;struct scatterlist * sg ;sg_table = rd_dev -> sg_table_array ;for ( i = 0 ;sg = sg_table [ i ] . sg_table ;",u32 page_count ;sg_table = rd_dev -> sg_table_array ;for ( i = 0 ;sg = sg_table [ i ] . sg_table ;,4457
459,kfree ( sg_table ) ;rd_dev -> sg_table_array = NULL ;rd_dev -> sg_table_count = 0 ;,"kfree ( sg_table ) ;rd_dev -> sg_table_array , rd_dev -> sg_table_count = 0 ;",4457
460,"if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {dptr = & xargs -> tktpolicydn ;","arg = ( arg != NULL ) ? arg : """" ;if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {dptr = & xargs -> tktpolicydn ;",4458
461,auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;,"if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) {kfree_skb ( chunk -> auth_chunk ) ;sctp_association_free ( new_asoc ) ;return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ;}auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;",4459
462,"static int64_t rd_pick_intra4x4block ( VP9_COMP * cpi , MACROBLOCK * x , int ib ,  MB_PREDICTION_MODE * best_mode , const int * bmode_costs , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , int * bestrate , int * bestratey , int64_t * bestdistortion , BLOCK_SIZE bsize , int64_t rd_thresh ) {MB_PREDICTION_MODE mode ;MACROBLOCKD * const xd = & x -> e_mbd ;const uint8_t * src_init = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , ib ,  src_stride ) ] ;uint8_t * dst_init = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , ib ,  dst_stride ) ] ;assert ( ib < 4 ) ;vpx_memcpy ( ta , a , sizeof ( ta ) ) ;vpx_memcpy ( tl , l , sizeof ( tl ) ) ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;for ( mode = DC_PRED ;","static int64_t rd_pick_intra4x4block ( VP9_COMP * cpi , MACROBLOCK * x , int row , int col , PREDICTION_MODE * best_mode , const int * bmode_costs , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , int * bestrate , int * bestratey , int64_t * bestdistortion , BLOCK_SIZE bsize , int64_t rd_thresh ) {PREDICTION_MODE mode ;MACROBLOCKD * const xd = & x -> e_mbd ;const uint8_t * src_init = & p -> src . buf [ row * 4 * src_stride + col * 4 ] ;uint8_t * dst_init = & pd -> dst . buf [ row * 4 * src_stride + col * 4 ] ;# if CONFIG_VP9_HIGHBITDEPTH uint16_t best_dst16 [ 8 * 8 ] ;# endif memcpy ( ta , a , sizeof ( ta ) ) ;memcpy ( tl , l , sizeof ( tl ) ) ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {for ( mode = DC_PRED ;",4460
463,"vpx_memcpy ( tempa , ta , sizeof ( ta ) ) ;vpx_memcpy ( templ , tl , sizeof ( tl ) ) ;for ( idy = 0 ;const int block = ib + idy * 2 + idx ;const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ;int16_t * const src_diff = raster_block_offset_int16 ( BLOCK_8X8 , block ,  p -> src_diff ) ;int16_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ;xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ;vp9_predict_intra_block ( xd , block , 1 ,  TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride ,  dst , dst_stride , idx , idy , 0 ) ;vp9_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ;if ( xd -> lossless ) {vp9_fwht4x4 ( src_diff , coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd )  goto next ;vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride ,  p -> eobs [ block ] ) ;}vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) ,   16 , & unused ) >> 2 ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd )  goto next ;vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) ,  dst , dst_stride , p -> eobs [ block ] ) ;}","memcpy ( tempa , ta , sizeof ( ta ) ) ;memcpy ( templ , tl , sizeof ( tl ) ) ;for ( idy = 0 ;const int block = ( row + idy ) * 2 + idx ;const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ;int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ;tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ;xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ;vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ;vpx_highbd_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride , xd -> bd ) ;if ( xd -> lossless ) {vp9_highbd_fwht4x4 ( src_diff , coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next_highbd ;vp9_highbd_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] , xd -> bd ) ;}if ( tx_type == DCT_DCT ) vpx_highbd_fdct4x4 ( src_diff , coeff , 8 ) ;else vp9_highbd_fht4x4 ( src_diff , coeff , 8 , tx_type ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;distortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused , xd -> bd ) >> 2 ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next_highbd ;vp9_highbd_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] , xd -> bd ) ;}",4460
464,"vpx_memcpy ( a , tempa , sizeof ( tempa ) ) ;vpx_memcpy ( l , templ , sizeof ( templ ) ) ;for ( idy = 0 ;++ idy )  vpx_memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride ,   num_4x4_blocks_wide * 4 ) ;}next :  {++ idy )  vpx_memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 ,   num_4x4_blocks_wide * 4 ) ;return best_rd ;}","memcpy ( a , tempa , sizeof ( tempa ) ) ;memcpy ( l , templ , sizeof ( templ ) ) ;for ( idy = 0 ;+ idy )  vpx_memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride ,   num_4x4_blocks_wide * 4 ) ;++ idy ) {memcpy ( best_dst16 + idy * 8 , CONVERT_TO_SHORTPTR ( dst_init + idy * dst_stride ) , num_4x4_blocks_wide * 4 * sizeof ( uint16_t ) ) ;}}next_highbd : {+ idy )  vpx_memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 ,   num_4x4_blocks_wide * 4 ) ;++ idy ) {memcpy ( CONVERT_TO_SHORTPTR ( dst_init + idy * dst_stride ) , best_dst16 + idy * 8 , num_4x4_blocks_wide * 4 * sizeof ( uint16_t ) ) ;}return best_rd ;}# endif for ( mode = DC_PRED ;mode <= TM_PRED ;++ mode ) {int64_t this_rd ;int ratey = 0 ;int64_t distortion = 0 ;int rate = bmode_costs [ mode ] ;if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) continue ;if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) {if ( conditional_skipintra ( mode , * best_mode ) ) continue ;}memcpy ( tempa , ta , sizeof ( ta ) ) ;memcpy ( templ , tl , sizeof ( tl ) ) ;for ( idy = 0 ;idy < num_4x4_blocks_high ;++ idy ) {for ( idx = 0 ;idx < num_4x4_blocks_wide ;++ idx ) {const int block = ( row + idy ) * 2 + ( col + idx ) ;const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ;uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ;int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ;tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ;xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ;vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ;vpx_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ;if ( xd -> lossless ) {const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ;vp9_fwht4x4 ( src_diff , coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ;vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ;}else {int64_t unused ;const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ;const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ;vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused ) >> 2 ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ;vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ;}}}rate += ratey ;this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ;if ( this_rd < best_rd ) {* bestrate = rate ;* bestratey = ratey ;* bestdistortion = distortion ;best_rd = this_rd ;* best_mode = mode ;memcpy ( a , tempa , sizeof ( tempa ) ) ;memcpy ( l , templ , sizeof ( templ ) ) ;for ( idy = 0 ;idy < num_4x4_blocks_high * 4 ;++ idy ) memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , num_4x4_blocks_wide * 4 ) ;}next : {}}if ( best_rd >= rd_thresh || x -> skip_encode ) return best_rd ;for ( idy = 0 ;idy < num_4x4_blocks_high * 4 ;++ idy ) memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , num_4x4_blocks_wide * 4 ) ;return best_rd ;}",4460
465,"static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb )  {if ( get_bits1 ( gb ) ) {for ( i = 0 ;","static int read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) {if ( get_bits1 ( gb ) ) {if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ;for ( i = 0 ;",4461
466,"for ( i = 0 ;get_bits ( gb , 8 ) ;if ( get_bits1 ( gb ) ) {for ( i = 0 ;","if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ;for ( i = 0 ;get_bits ( gb , 8 ) ;if ( get_bits1 ( gb ) ) {if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ;for ( i = 0 ;",4461
467,"for ( i = 0 ;get_bits ( gb , 8 ) ;}","if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ;for ( i = 0 ;get_bits ( gb , 8 ) ;return 0 ;}",4461
468,vp9_free_frame_buffers ( cm ) ;vp9_free_internal_frame_buffers ( & cm -> int_frame_buffers ) ;},vp9_free_context_buffers ( cm ) ;vpx_free ( cm -> fc ) ;cm -> fc = NULL ;vpx_free ( cm -> frame_contexts ) ;cm -> frame_contexts = NULL ;},4462
469,if ( po -> fanout )   return - EINVAL ;lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;,lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;rcu_read_lock ( ) ;if ( po -> fanout ) {ret = - EINVAL ;lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;,4463
470,"sum = icmp6_cksum ( ndo , ip , dp , length ) ;if ( sum != 0 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>icmp6<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>-><S2SV_blank>0x%04x!]<S2SV_blank>"" , udp_sum , in_cksum_shouldbe ( udp_sum , sum ) ) ) ;","sum = icmp6_cksum ( ndo , ""%s"" , icmp6_tstr ) ) ;",4464
471,"trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}","trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}",4464
472,"int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) {FILE * f = input_ctx -> file ;","static int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) {FILE * f = input_ctx -> file ;",4465
473,BUG_ON ( ! io ) ;iput ( io -> inode ) ;,BUG_ON ( ! io ) ;if ( io -> page ) put_page ( io -> page ) ;iput ( io -> inode ) ;,4466
474,"struct kvm_arch * ka = & v -> kvm -> arch ;void * shared_kaddr ;s64 kernel_ns , max_kernel_ns ;struct pvclock_vcpu_time_info * guest_hv_clock ;u8 pvclock_flags ;","s64 kernel_ns , max_kernel_ns ;struct pvclock_vcpu_time_info * guest_hv_clock ;u8 pvclock_flags ;",4467
475,if ( ! vcpu -> time_page )  return 0 ;,if ( ! vcpu -> pv_time_enabled ) return 0 ;,4467
476,"shared_kaddr = kmap_atomic ( vcpu -> time_page ) ;guest_hv_clock = shared_kaddr + vcpu -> time_offset ;pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ;if ( vcpu -> pvclock_set_guest_stopped_request ) {memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock ,  sizeof ( vcpu -> hv_clock ) ) ;kunmap_atomic ( shared_kaddr ) ;mark_page_dirty ( v -> kvm , vcpu -> time >> PAGE_SHIFT ) ;","if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 ;pvclock_flags = ( guest_hv_clock . flags & PVCLOCK_GUEST_STOPPED ) ;if ( vcpu -> pvclock_set_guest_stopped_request ) {kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , & vcpu -> hv_clock , sizeof ( vcpu -> hv_clock ) ) ;",4467
477,"case 2 :  # line 105 ""re_grammar.y""  {# line 1340 ""re_grammar.c""  break ;case 4 :  # line 114 ""re_grammar.y""  {# line 1348 ""re_grammar.c""  break ;case 5 :  # line 118 ""re_grammar.y""  {( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1363 ""re_grammar.c""  break ;case 6 :  # line 129 ""re_grammar.y""  {node = yr_re_node_create ( RE_NODE_EMPTY , NULL , NULL ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ;# line 1382 ""re_grammar.c""  break ;case 7 :  # line 147 ""re_grammar.y""  {# line 1390 ""re_grammar.c""  break ;case 8 :  # line 151 ""re_grammar.y""  {# line 1402 ""re_grammar.c""  break ;case 9 :  # line 162 ""re_grammar.y""  {","case 2 : # line 113 ""re_grammar.y"" {# line 1348 ""re_grammar.c"" break ;case 4 : # line 122 ""re_grammar.y"" {# line 1356 ""re_grammar.c"" break ;case 5 : # line 126 ""re_grammar.y"" {incr_ast_levels ( ) ;( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1372 ""re_grammar.c"" break ;case 6 : # line 138 ""re_grammar.y"" {incr_ast_levels ( ) ;node = yr_re_node_create ( RE_NODE_EMPTY , NULL , NULL ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ;# line 1392 ""re_grammar.c"" break ;case 7 : # line 157 ""re_grammar.y"" {# line 1400 ""re_grammar.c"" break ;case 8 : # line 161 ""re_grammar.y"" {incr_ast_levels ( ) ;# line 1414 ""re_grammar.c"" break ;case 9 : # line 174 ""re_grammar.y"" {",4468
478,"# line 1420 ""re_grammar.c""  break ;case 10 :  # line 176 ""re_grammar.y""  {","# line 1432 ""re_grammar.c"" break ;case 10 : # line 188 ""re_grammar.y"" {",4468
479,"# line 1440 ""re_grammar.c""  break ;case 11 :  # line 192 ""re_grammar.y""  {","# line 1452 ""re_grammar.c"" break ;case 11 : # line 204 ""re_grammar.y"" {",4468
480,"# line 1458 ""re_grammar.c""  break ;case 12 :  # line 206 ""re_grammar.y""  {","# line 1470 ""re_grammar.c"" break ;case 12 : # line 218 ""re_grammar.y"" {",4468
481,"# line 1478 ""re_grammar.c""  break ;case 13 :  # line 222 ""re_grammar.y""  {","# line 1490 ""re_grammar.c"" break ;case 13 : # line 234 ""re_grammar.y"" {",4468
482,"# line 1505 ""re_grammar.c""  break ;case 14 :  # line 245 ""re_grammar.y""  {","# line 1517 ""re_grammar.c"" break ;case 14 : # line 257 ""re_grammar.y"" {",4468
483,"# line 1533 ""re_grammar.c""  break ;case 15 :  # line 269 ""re_grammar.y""  {","# line 1545 ""re_grammar.c"" break ;case 15 : # line 281 ""re_grammar.y"" {",4468
484,"# line 1559 ""re_grammar.c""  break ;case 16 :  # line 291 ""re_grammar.y""  {","# line 1571 ""re_grammar.c"" break ;case 16 : # line 303 ""re_grammar.y"" {",4468
485,"# line 1586 ""re_grammar.c""  break ;case 17 :  # line 314 ""re_grammar.y""  {# line 1594 ""re_grammar.c""  break ;case 18 :  # line 318 ""re_grammar.y""  {# line 1604 ""re_grammar.c""  break ;case 19 :  # line 324 ""re_grammar.y""  {# line 1614 ""re_grammar.c""  break ;case 20 :  # line 330 ""re_grammar.y""  {# line 1624 ""re_grammar.c""  break ;case 21 :  # line 336 ""re_grammar.y""  {# line 1634 ""re_grammar.c""  break ;case 22 :  # line 345 ""re_grammar.y""  {# line 1642 ""re_grammar.c""  break ;case 23 :  # line 349 ""re_grammar.y""  {# line 1652 ""re_grammar.c""  break ;case 24 :  # line 355 ""re_grammar.y""  {# line 1664 ""re_grammar.c""  break ;case 25 :  # line 363 ""re_grammar.y""  {# line 1674 ""re_grammar.c""  break ;case 26 :  # line 369 ""re_grammar.y""  {# line 1684 ""re_grammar.c""  break ;case 27 :  # line 375 ""re_grammar.y""  {# line 1694 ""re_grammar.c""  break ;case 28 :  # line 381 ""re_grammar.y""  {# line 1704 ""re_grammar.c""  break ;case 29 :  # line 387 ""re_grammar.y""  {# line 1714 ""re_grammar.c""  break ;case 30 :  # line 393 ""re_grammar.y""  {# line 1724 ""re_grammar.c""  break ;case 31 :  # line 399 ""re_grammar.y""  {# line 1736 ""re_grammar.c""  break ;# line 1740 ""re_grammar.c""  default : break ;","# line 1598 ""re_grammar.c"" break ;case 17 : # line 326 ""re_grammar.y"" {# line 1606 ""re_grammar.c"" break ;case 18 : # line 330 ""re_grammar.y"" {# line 1616 ""re_grammar.c"" break ;case 19 : # line 336 ""re_grammar.y"" {# line 1626 ""re_grammar.c"" break ;case 20 : # line 342 ""re_grammar.y"" {# line 1636 ""re_grammar.c"" break ;case 21 : # line 348 ""re_grammar.y"" {# line 1646 ""re_grammar.c"" break ;case 22 : # line 357 ""re_grammar.y"" {incr_ast_levels ( ) ;# line 1656 ""re_grammar.c"" break ;case 23 : # line 363 ""re_grammar.y"" {# line 1666 ""re_grammar.c"" break ;case 24 : # line 369 ""re_grammar.y"" {# line 1678 ""re_grammar.c"" break ;case 25 : # line 377 ""re_grammar.y"" {# line 1688 ""re_grammar.c"" break ;case 26 : # line 383 ""re_grammar.y"" {# line 1698 ""re_grammar.c"" break ;case 27 : # line 389 ""re_grammar.y"" {# line 1708 ""re_grammar.c"" break ;case 28 : # line 395 ""re_grammar.y"" {# line 1718 ""re_grammar.c"" break ;case 29 : # line 401 ""re_grammar.y"" {# line 1728 ""re_grammar.c"" break ;case 30 : # line 407 ""re_grammar.y"" {# line 1738 ""re_grammar.c"" break ;case 31 : # line 413 ""re_grammar.y"" {# line 1750 ""re_grammar.c"" break ;# line 1740 ""re_grammar.c"" default : break ;",4468
486,"u32 now ;if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ;challenge_timestamp = now ;challenge_count = 0 ;}if ( ++ challenge_count <= sysctl_tcp_challenge_ack_limit ) {","u32 count , now ;if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ;u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ;challenge_timestamp = now ;WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ;}count = READ_ONCE ( challenge_count ) ;if ( count > 0 ) {WRITE_ONCE ( challenge_count , count - 1 ) ;",4469
487,"err = tfm -> seed ( tfm , seed , slen ) ;kfree ( buf ) ;","err = crypto_rng_alg ( tfm ) -> seed ( tfm , seed , slen ) ;kfree ( buf ) ;",4470
488,update_db_bp_intercept ( & svm -> vcpu ) ;},},4471
489,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,4472
490,"static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk ,  int tstype )  {int err ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {","static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , int tstype , bool opt_stats ) {int err ;BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;serr -> opt_stats = opt_stats ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {",4473
491,switch ( c = ( * dis_getc ) ( stream ) )  {,"if ( count >= dis_umaxd ) {if ( count > dis_umaxd ) goto overflow ;if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ;}switch ( c = ( * dis_getc ) ( stream ) ) {",4474
492,},dc -> vmsd = & vmstate_stellaris_enet ;},4475
493,"void vp9_first_pass ( VP9_COMP * cpi ) {int mb_row , mb_col ;MACROBLOCK * const x = & cpi -> mb ;VP9_COMMON * const cm = & cpi -> common ;const PICK_MODE_CONTEXT * ctx = & x -> sb64_context ;int i ;YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ;int recon_y_stride = lst_yv12 -> y_stride ;int recon_uv_stride = lst_yv12 -> uv_stride ;int uv_mb_height = 16 >> ( lst_yv12 -> y_height > lst_yv12 -> uv_height ) ;int64_t coded_error = 0 ;","void vp9_first_pass ( VP9_COMP * cpi , const struct lookahead_entry * source ) {int mb_row , mb_col ;MACROBLOCK * const x = & cpi -> td . mb ;VP9_COMMON * const cm = & cpi -> common ;const PICK_MODE_CONTEXT * ctx = & cpi -> td . pc_root -> none ;int i ;const int64_t coded_error = 0 ;",4476
494,"int intrapenalty = 256 ;int neutral_count = 0 ;int new_mv_count = 0 ;int sum_in_vectors = 0 ;uint32_t lastmv_as_int = 0 ;struct twopass_rc * twopass = & cpi -> twopass ;const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ;vp9_clear_system_state ( ) ;if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) {MV_REFERENCE_FRAME ref_frame = LAST_FRAME ;twopass = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . twopass ;scaled_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ;ref_frame = LAST_FRAME ;else if ( cpi -> ref_frame_flags & VP9_ALT_FLAG ) {scaled_ref_buf = vp9_get_scaled_ref_frame ( cpi , ALTREF_FRAME ) ;ref_frame = ALTREF_FRAME ;if ( scaled_ref_buf != NULL ) {first_ref_buf = scaled_ref_buf ;recon_y_stride = first_ref_buf -> y_stride ;recon_uv_stride = first_ref_buf -> uv_stride ;uv_mb_height = 16 >> ( first_ref_buf -> y_height > first_ref_buf -> uv_height ) ;set_ref_ptrs ( cm , xd , ref_frame , NONE ) ;vp9_setup_dst_planes ( xd , new_yv12 , 0 , 0 ) ;vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ;","int intrapenalty = 256 ;int neutral_count = 0 ;MV lastmv = {0 , 0 };int recon_y_stride , recon_uv_stride , uv_mb_height ;YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ;TWO_PASS * twopass = & cpi -> twopass ;const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ;LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . number_temporal_layers == 1 ) {MV_REFERENCE_FRAME ref_frame = LAST_FRAME ;twopass = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : NULL ;double intra_factor ;double brightness_factor ;BufferPool * const pool = cm -> buffer_pool ;assert ( new_yv12 != NULL ) ;assert ( ( lc != NULL ) || frame_is_intra_only ( cm ) || ( lst_yv12 != NULL ) ) ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {vp9_zero_array ( cpi -> twopass . frame_mb_stats_buf , cm -> initial_mbs ) ;}# endif vpx_clear_system_state ( ) ;intra_factor = 0.0 ;brightness_factor = 0.0 ;neutral_count = 0.0 ;set_first_pass_params ( cpi ) ;vp9_set_quantizer ( cm , find_fp_qindex ( cm -> bit_depth ) ) ;if ( lc != NULL ) {twopass = & lc -> twopass ;cpi -> lst_fb_idx = cpi -> svc . spatial_layer_id ;cpi -> ref_frame_flags = VP9_LAST_FLAG ;if ( cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id < REF_FRAMES ) {cpi -> gld_fb_idx = cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id ;cpi -> ref_frame_flags |= VP9_GOLD_FLAG ;cpi -> refresh_golden_frame = ( lc -> current_video_frame_in_layer == 0 ) ;}else {cpi -> refresh_golden_frame = 0 ;}if ( lc -> current_video_frame_in_layer == 0 ) cpi -> ref_frame_flags = 0 ;first_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ;if ( first_ref_buf == NULL ) first_ref_buf = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;if ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) {gld_yv12 = vp9_get_scaled_ref_frame ( cpi , GOLDEN_FRAME ) ;if ( gld_yv12 == NULL ) {gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;else {set_ref_ptrs ( cm , xd , ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ? LAST_FRAME : NONE , ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ? GOLDEN_FRAME : NONE ) ;cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , & cpi -> scaled_source ) ;}vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ;recon_y_stride = new_yv12 -> y_stride ;recon_uv_stride = new_yv12 -> uv_stride ;uv_mb_height = 16 >> ( new_yv12 -> y_height > new_yv12 -> uv_height ) ;vp9_setup_dst_planes ( xd -> plane , new_yv12 , 0 , 0 ) ;if ( ! frame_is_intra_only ( cm ) ) {}",4476
495,for ( mb_row = 0 ;int_mv best_ref_mv ;best_ref_mv . as_int = 0 ;,"for ( mb_row = 0 ;MV best_ref_mv = {0 , 0 };",4476
496,"double error_weight = 1.0 ;const BLOCK_SIZE bsize = get_bsize ( cm , mb_row , mb_col ) ;vp9_clear_system_state ( ) ;xd -> plane [ 0 ] . dst . buf = new_yv12 -> y_buffer + recon_yoffset ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {const int energy = vp9_block_energy ( cpi , x , bsize ) ;error_weight = vp9_vaq_inv_q_ratio ( energy ) ;this_error = vp9_encode_intra ( x , use_dc_pred ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;this_error = ( int ) ( this_error * error_weight ) ;intra_error += ( int64_t ) this_error ;x -> mv_col_min = - ( ( mb_col * 16 ) + BORDER_MV_PIXELS_B16 ) ;if ( cm -> current_video_frame > 0 ) {int tmp_err , motion_error ;int_mv mv , tmp_mv ;motion_error = zz_motion_search ( x ) ;mv . as_int = tmp_mv . as_int = 0 ;first_pass_motion_search ( cpi , x , & best_ref_mv . as_mv , & mv . as_mv , & motion_error ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;motion_error = ( int ) ( motion_error * error_weight ) ;if ( best_ref_mv . as_int ) {tmp_err = INT_MAX ;first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv , & tmp_err ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;tmp_err = ( int ) ( tmp_err * error_weight ) ;mv . as_int = tmp_mv . as_int ;}if ( cm -> current_video_frame > 1 && gld_yv12 != NULL ) {int gf_motion_error ;gf_motion_error = zz_motion_search ( x ) ;first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv ,  & gf_motion_error ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;","const BLOCK_SIZE bsize = get_bsize ( cm , mb_row , mb_col ) ;double log_intra ;int level_sample ;# if CONFIG_FP_MB_STATS const int mb_index = mb_row * cm -> mb_cols + mb_col ;# endif vpx_clear_system_state ( ) ;xd -> plane [ 0 ] . dst . buf = new_yv12 -> y_buffer + recon_yoffset ;x -> skip_encode = 0 ;xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ;xd -> mi [ 0 ] -> mbmi . tx_size = use_dc_pred ? ( bsize >= BLOCK_16X16 ? TX_16X16 : TX_8X8 ) : TX_4X4 ;vp9_encode_intra_block_plane ( x , bsize , 0 ) ;this_error = vpx_get_mb_ss ( x -> plane [ 0 ] . src_diff ) ;if ( this_error < UL_INTRA_THRESH ) {++ intra_skip_count ;else if ( ( mb_col > 0 ) && ( image_data_start_row == INVALID_ROW ) ) {image_data_start_row = mb_row ;}# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) {switch ( cm -> bit_depth ) {case VPX_BITS_8 : break ;case VPX_BITS_10 : this_error >>= 4 ;break ;case VPX_BITS_12 : this_error >>= 8 ;break ;default : assert ( 0 && ""cm->bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>"" ""VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ;return ;}# endif vpx_clear_system_state ( ) ;log_intra = log ( this_error + 1.0 ) ;if ( log_intra < 10.0 ) intra_factor += 1.0 + ( ( 10.0 - log_intra ) * 0.05 ) ;else intra_factor += 1.0 ;# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) level_sample = CONVERT_TO_SHORTPTR ( x -> plane [ 0 ] . src . buf ) [ 0 ] ;else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ;# else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ;# endif if ( ( level_sample < DARK_THRESH ) && ( log_intra < 9.0 ) ) brightness_factor += 1.0 + ( 0.01 * ( DARK_THRESH - level_sample ) ) ;else brightness_factor += 1.0 ;intra_error += ( int64_t ) this_error ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ;}# endif x -> mv_col_min = - ( ( mb_col * 16 ) + BORDER_MV_PIXELS_B16 ) ;if ( ( lc == NULL && cm -> current_video_frame > 0 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 0 ) ) {int tmp_err , motion_error , raw_motion_error ;MV mv = {0 , 0 }, tmp_mv = {0 , 0 };struct buf_2d unscaled_last_source_buf_2d ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ;else {motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ;}# else motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ;# endif unscaled_last_source_buf_2d . buf = cpi -> unscaled_last_source -> y_buffer + recon_yoffset ;unscaled_last_source_buf_2d . stride = cpi -> unscaled_last_source -> y_stride ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {raw_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d , xd -> bd ) ;}else {raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ;# else raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ;# endif if ( raw_motion_error > 25 || lc != NULL ) {first_pass_motion_search ( cpi , x , & best_ref_mv , & mv , & motion_error ) ;if ( ! is_zero_mv ( & best_ref_mv ) ) {tmp_err = INT_MAX ;first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & tmp_err ) ;mv = tmp_mv ;}if ( ( ( lc == NULL && cm -> current_video_frame > 1 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 1 ) ) && gld_yv12 != NULL ) {int gf_motion_error ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {gf_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ;}else {gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ;}# else gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ;# endif first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & gf_motion_error ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;",4476
497,best_ref_mv . as_int = 0 ;if ( motion_error <= this_error ) {if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) &&   this_error < 2 * intrapenalty )   ++ neutral_count ;mv . as_mv . row *= 8 ;mv . as_mv . col *= 8 ;this_error = motion_error ;xd -> mi [ 0 ] -> mbmi . mode = NEWMV ;xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = mv ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;sum_mvr += mv . as_mv . row ;sum_mvr_abs += abs ( mv . as_mv . row ) ;sum_mvc += mv . as_mv . col ;sum_mvc_abs += abs ( mv . as_mv . col ) ;sum_mvrs += mv . as_mv . row * mv . as_mv . row ;sum_mvcs += mv . as_mv . col * mv . as_mv . col ;++ intercount ;best_ref_mv . as_int = mv . as_int ;if ( mv . as_int ) {++ mvcount ;if ( mv . as_int != lastmv_as_int )  ++ new_mv_count ;lastmv_as_int = mv . as_int ;if ( mb_row < cm -> mb_rows / 2 ) {if ( mv . as_mv . row > 0 )  -- sum_in_vectors ;else if ( mv . as_mv . row < 0 )  ++ sum_in_vectors ;if ( mv . as_mv . row > 0 )  ++ sum_in_vectors ;else if ( mv . as_mv . row < 0 )  -- sum_in_vectors ;if ( mv . as_mv . col > 0 )  -- sum_in_vectors ;else if ( mv . as_mv . col < 0 )  ++ sum_in_vectors ;if ( mv . as_mv . col > 0 )  ++ sum_in_vectors ;else if ( mv . as_mv . col < 0 )  -- sum_in_vectors ;,"}else {sr_coded_error += motion_error ;}best_ref_mv . row = 0 ;best_ref_mv . col = 0 ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ;cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_DCINTRA_MASK ;cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ;if ( this_error > FPMB_ERROR_LARGE_TH ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ;}else if ( this_error < FPMB_ERROR_SMALL_TH ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ;}}# endif if ( motion_error <= this_error ) {vpx_clear_system_state ( ) ;if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) && ( this_error < ( 2 * intrapenalty ) ) ) {neutral_count += 1.0 ;}else if ( ( this_error > NCOUNT_INTRA_THRESH ) && ( this_error < ( NCOUNT_INTRA_FACTOR * motion_error ) ) ) {neutral_count += ( double ) motion_error / DOUBLE_DIVIDE_CHECK ( ( double ) this_error ) ;}mv . row *= 8 ;mv . col *= 8 ;this_error = motion_error ;xd -> mi [ 0 ] . as_mv -> mbmi . mode = NEWMV ;xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = mv ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;+ intercount ;+ mvcount ;sum_mvr += mv . row ;sum_mvr_abs += abs ( mv . row ) ;sum_mvc += mv . as_mv . col ;sum_mvc_abs += abs ( mv . col ) ;sum_mvrs += mv . as_mv . row * mv . row ;sum_mvcs += mv . as_mv . col * mv . col ;++ intercount ;best_ref_mv . as_int = mv . as_int ;if ( mv . as_mv . col > 0 && mv . as_mv . col >= abs ( mv . as_mv . row ) ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_RIGHT_MASK ;}else if ( mv . as_mv . row < 0 && abs ( mv . as_mv . row ) >= abs ( mv . as_mv . col ) ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_UP_MASK ;}else if ( mv . as_mv . col < 0 && abs ( mv . as_mv . col ) >= abs ( mv . as_mv . row ) ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_LEFT_MASK ;}else {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_DOWN_MASK ;}}# endif if ( ! is_equal_mv ( & mv , & lastmv ) ) ++ new_mv_count ;lastmv = mv ;if ( mb_row < cm -> mb_rows / 2 ) {if ( mv . row > 0 ) -- sum_in_vectors ;else if ( mv . row < 0 ) ++ sum_in_vectors ;if ( mv . row > 0 ) ++ sum_in_vectors ;else if ( mv . row < 0 ) -- sum_in_vectors ;if ( mv . col > 0 ) -- sum_in_vectors ;else if ( mv . col < 0 ) ++ sum_in_vectors ;if ( mv . col > 0 ) ++ sum_in_vectors ;else if ( mv . col < 0 ) -- sum_in_vectors ;",4476
498,x -> plane [ 1 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - uv_mb_height * cm -> mb_cols ;x -> plane [ 2 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - uv_mb_height * cm -> mb_cols ;vp9_clear_system_state ( ) ;}vp9_clear_system_state ( ) ;fps . frame = cm -> current_video_frame ;fps . spatial_layer_id = cpi -> svc . spatial_layer_id ;fps . intra_error = ( double ) ( intra_error >> 8 ) ;fps . coded_error = ( double ) ( coded_error >> 8 ) ;fps . pcnt_inter = ( double ) intercount / cm -> MBs ;fps . pcnt_second_ref = ( double ) second_ref_count / cm -> MBs ;fps . pcnt_neutral = ( double ) neutral_count / cm -> MBs ;if ( mvcount > 0 ) {fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / mvcount ) ) / mvcount ;fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / mvcount ) ) / mvcount ;fps . mv_in_out_count = ( double ) sum_in_vectors / ( mvcount * 2 ) ;fps . pcnt_motion = ( double ) mvcount / cm -> MBs ;},"vpx_clear_system_state ( ) ;}if ( ( image_data_start_row > cm -> mb_rows / 2 ) || ( image_data_start_row == INVALID_ROW ) ) {image_data_start_row = cm -> mb_rows / 2 ;}if ( image_data_start_row > 0 ) {intra_skip_count = MAX ( 0 , intra_skip_count - ( image_data_start_row * cm -> mb_cols * 2 ) ) ;}fps . frame = cm -> current_video_frame ;fps . spatial_layer_id = cpi -> svc . spatial_layer_id ;fps . coded_error = ( double ) ( coded_error >> 8 ) + min_err ;fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) + min_err ;fps . intra_error = ( double ) ( intra_error >> 8 ) ;fps . coded_error = ( double ) ( coded_error >> 8 ) ;fps . pcnt_inter = ( double ) intercount / num_mbs ;fps . pcnt_second_ref = ( double ) second_ref_count / num_mbs ;fps . pcnt_neutral = ( double ) neutral_count / num_mbs ;fps . intra_skip_pct = ( double ) intra_skip_count / num_mbs ;fps . inactive_zone_rows = ( double ) image_data_start_row ;fps . inactive_zone_cols = ( double ) 0 ;if ( mvcount > 0 ) {fps . MVrv = ( ( double ) sum_mvrs - ( ( double ) sum_mvr * sum_mvr / mvcount ) ) / mvcount ;fps . MVcv = ( ( double ) sum_mvcs - ( ( double ) sum_mvc * sum_mvc / mvcount ) ) / mvcount ;fps . mv_in_out_count = ( double ) sum_in_vectors / ( mvcount * 2 ) ;fps . pcnt_motion = ( double ) mvcount / num_mbs ;}",4476
499,"fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ;twopass -> this_frame_stats = fps ;accumulate_stats ( & twopass -> total_stats , & fps ) ;}vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ;}if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) {vp9_update_reference_frames ( cpi ) ;swap_yv12 ( lst_yv12 , new_yv12 ) ;}vp9_extend_frame_borders ( lst_yv12 ) ;if ( cm -> current_video_frame == 0 && gld_yv12 != NULL ) {vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ;}","fps . duration = ( double ) ( source -> ts_end - cpi -> source -> ts_start ) ;twopass -> this_frame_stats = fps ;accumulate_stats ( & twopass -> total_stats , & fps ) ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {output_fpmb_stats ( twopass -> frame_mb_stats_buf , cm , cpi -> output_pkt_list ) ;}# endif }ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] ) ;}vpx_extend_frame_borders ( new_yv12 ) ;if ( lc != NULL ) {vp9_update_reference_frames ( cpi ) ;ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> lst_fb_idx ] , cm -> new_fb_idx ) ;}if ( cm -> current_video_frame == 0 && cpi -> gld_fb_idx != INVALID_IDX && lc == NULL ) {ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] ) ;}",4476
500,},if ( cpi -> use_svc ) vp9_inc_frame_in_layer ( cpi ) ;},4476
501,static const int16_t * filter = vp9_down2_symeven_half_filter ;const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) / 2 ;,const int16_t * filter = vp9_down2_symeven_half_filter ;const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) / 2 ;,4477
502,break ;case L2CAP_CR_PEND : l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_CONNECT_PEND ;,l2cap_pi ( sk ) -> num_conf_req ++ ;break ;case L2CAP_CR_PEND : l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_CONNECT_PEND ;,4478
503,"if ( user -> uid_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;","if ( user -> uid_keyring && user -> session_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;",4479
504,"int bson_check_string ( bson * b , const char * string ,  const int length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 0 , 0 ) ;","int bson_check_string ( bson * b , const char * string , const size_t length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 0 , 0 ) ;",4480
505,"efx -> mac_op -> update_stats ( efx ) ;memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ;","net_dev -> gso_max_segs = EFX_TSO_MAX_SEGS ;efx -> mac_op -> update_stats ( efx ) ;memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ;",4481
506,"static void encode_frame ( vpx_codec_ctx_t * codec ,  vpx_image_t * img , int frame_index ,  VpxVideoWriter * writer ) {vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {","static int encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img , int frame_index , VpxVideoWriter * writer ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {",4482
507,},return got_pkts ;},4482
508,if ( default_IsEncrypted ) * default_IsEncrypted = GF_FALSE ;,if ( seig_entry && default_IsEncrypted ) * default_IsEncrypted = GF_FALSE ;,4483
509,if ( ! seig_entry -> key_info [ 0 ] )  seig_entry = NULL ;,if ( ! seig_entry -> key_info [ 0 ] ) seig_entry = NULL ;,4483
510,# endif  msg -> msg_namelen = 0 ;copied = data_skb -> len ;,# endif copied = data_skb -> len ;,4484
511,"for ( cnt = 0 , i = 0 ;cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;","for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;",4485
512,"
","if ( ( st32 ) verdef -> vd_next < 1 ) {eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\break ;}",4485
513,i += verdef -> vd_next ;},i += verdef -> vd_next ;},4485
514,int size ;int depth = 0 ;,int size ;int base_size ;int depth = 0 ;,4486
515,"size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ;path = ( PATH * ) palloc ( size ) ;SET_VARSIZE ( path , size ) ;path -> npts = npts ;if ( ( ! path_decode ( TRUE , npts , s , & isopen , & s , & ( path -> p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == \'\\\\0\' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\\\""%s\\\\"""" , str ) ) ) ;","base_size = sizeof ( path -> p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ;size = offsetof ( PATH , p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == \'\\\\0\' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\\\""%s\\\\"""" , str ) ) ) ;",4486
516,"if ( size > INT_MAX )  size = INT_MAX ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;","if ( size > INT_MAX ) size = INT_MAX ;if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;",4487
517,static int  mptctl_gettargetinfo ( unsigned long arg )  {MPT_ADAPTER * ioc ;VirtDevice * vdevice ;int * pdata ;int iocnum ;,"static int mptctl_gettargetinfo ( MPT_ADAPTER * ioc , unsigned long arg ) {VirtDevice * vdevice ;int * pdata ;",4488
518,"return - EFAULT ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_gettargetinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;",return - EFAULT ;,4488
519,return in ;},return NULL ;},4489
520,"# ifdef HAVE_SECCOMP  if ( arg_seccomp_block_secondary )  copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ;","# ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;if ( arg_seccomp_block_secondary ) copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ;",4490
521,"static void prefetch_dec ( void )  {prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;","static void prefetch_dec ( void ) {dec_tables . counter_head ++ ;dec_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;",4491
522,"hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset ,  src_fd . entrylength ) ;","if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) {err = - EIO ;goto out ;}hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , src_fd . entrylength ) ;",4492
523,"
",if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) {,4493
524,flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ;stream_id = flags & 0x7F ;,}flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ;stream_id = flags & 0x7F ;,4493
525,}if ( end - p >= 88 ) {,}if ( end - p >= 88 ) {,4493
526,}p += chunksize ;,"if ( chunksize > end - p ) {av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\\return AVERROR_INVALIDDATA ;}}p += chunksize ;",4493
527,"if ( ! authctxt -> valid ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;return 0 ;}","
",4494
528,"
","if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;}",4494
529,"if ( ( b = sshbuf_new ( ) ) == NULL )  fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ;","if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ;",4494
530,"SEPARATE_ZVAL ( var2 ) ;convert_to_double ( * var2 ) ;matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ;RETURN_FALSE ;}}","if ( Z_TYPE_PP ( var2 ) != IS_DOUBLE ) {zval dval ;dval = * * var ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ;}else {matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ;}}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ;RETURN_FALSE ;}}",4495
531,"static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type ,  u32 * mask ) {if ( IS_ERR ( algt ) )  return ;if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) )  * type |= CRYPTO_ALG_INTERNAL ;if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) )  * mask |= CRYPTO_ALG_INTERNAL ;","static inline bool mcryptd_check_internal ( struct rtattr * * tb , u32 * type , u32 * mask ) {if ( IS_ERR ( algt ) ) return false ;* type |= algt -> type & CRYPTO_ALG_INTERNAL ;* mask |= algt -> mask & CRYPTO_ALG_INTERNAL ;if ( * type & * mask & CRYPTO_ALG_INTERNAL ) return true ;else return false ;",4496
532,"MACROBLOCK * const x = & cpi -> mb ;VP9_COMMON * const cm = & cpi -> common ;xd -> mi = cm -> mi_grid_visible ;xd -> mi [ 0 ] = cm -> mi ;vp9_zero ( cm -> counts ) ;vp9_zero ( cpi -> coef_counts ) ;vp9_zero ( cpi -> tx_stepdown_count ) ;vp9_zero ( cpi -> rd_comp_pred_diff ) ;vp9_zero ( cpi -> rd_filter_diff ) ;vp9_zero ( cpi -> rd_tx_select_diff ) ;vp9_zero ( cpi -> rd_tx_select_threshes ) ;cm -> tx_mode = select_tx_mode ( cpi ) ;cpi -> mb . e_mbd . lossless = cm -> base_qindex == 0 && cm -> y_dc_delta_q == 0 && cm -> uv_dc_delta_q == 0 && cm -> uv_ac_delta_q == 0 ;switch_lossless_mode ( cpi , cpi -> mb . e_mbd . lossless ) ;vp9_frame_init_quantizer ( cpi ) ;vp9_initialize_rd_consts ( cpi ) ;vp9_initialize_me_consts ( cpi , cm -> base_qindex ) ;init_encode_frame_mb_context ( cpi ) ;if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM )  build_activity_map ( cpi ) ;cm -> prev_mi = get_prev_mi ( cm ) ;if ( sf -> use_nonrd_pick_mode ) {PICK_MODE_CONTEXT * ctx = & cpi -> mb . sb64_context ;for ( i = 0 ;","ThreadData * const td = & cpi -> td ;MACROBLOCK * const x = & td -> mb ;VP9_COMMON * const cm = & cpi -> common ;RD_COUNTS * const rdc = & cpi -> td . rd_counts ;xd -> mi = cm -> mi_grid_visible ;xd -> mi [ 0 ] = cm -> mi ;vp9_zero ( * td -> counts ) ;vp9_zero ( rdc -> coef_counts ) ;vp9_zero ( rdc -> comp_pred_diff ) ;vp9_zero ( cpi -> rd_comp_pred_diff ) ;vp9_zero ( rdc -> filter_diff ) ;xd -> lossless = cm -> base_qindex == 0 && cm -> y_dc_delta_q == 0 && cm -> uv_dc_delta_q == 0 && cm -> uv_ac_delta_q == 0 ;switch_lossless_mode ( cpi , cpi -> mb . e_mbd . lossless ) ;vp9_frame_init_quantizer ( cpi ) ;cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> intra_only && cm -> last_show_frame ;cm -> prev_mi = get_prev_mi ( cm ) ;if ( sf -> use_nonrd_pick_mode ) {PICK_MODE_CONTEXT * ctx = & cpi -> td . pc_root -> none ;for ( i = 0 ;",4497
533,"if ( cpi -> sf . partition_search_type == SOURCE_VAR_BASED_PARTITION &&  cm -> current_video_frame > 0 ) {int check_freq = cpi -> sf . search_type_check_frequency ;if ( ( cm -> current_video_frame - 1 ) % check_freq == 0 ) {cpi -> use_large_partition_rate = 0 ;}if ( ( cm -> current_video_frame - 1 ) % check_freq == 1 ) {const int mbs_in_b32x32 = 1 << ( ( b_width_log2_lookup [ BLOCK_32X32 ] - b_width_log2_lookup [ BLOCK_16X16 ] ) + ( b_height_log2_lookup [ BLOCK_32X32 ] - b_height_log2_lookup [ BLOCK_16X16 ] ) ) ;cpi -> use_large_partition_rate = cpi -> use_large_partition_rate * 100 * mbs_in_b32x32 / cm -> MBs ;}if ( ( cm -> current_video_frame - 1 ) % check_freq >= 1 ) {if ( cpi -> use_large_partition_rate < 15 ) cpi -> sf . partition_search_type = FIXED_PARTITION ;}}{int tile_col , tile_row ;const int tile_cols = 1 << cm -> log2_tile_cols ;const int tile_rows = 1 << cm -> log2_tile_rows ;","if ( cm -> frame_type != KEY_FRAME && cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) cpi -> ref_frame_flags &= ( ~ VP9_GOLD_FLAG ) ;if ( sf -> partition_search_type == SOURCE_VAR_BASED_PARTITION ) source_var_based_partition_search_method ( cpi ) ;{int tile_col , tile_row ;const int tile_cols = 1 << cm -> log2_tile_cols ;const int tile_rows = 1 << cm -> log2_tile_rows ;",4497
534,"if ( sf -> use_nonrd_pick_mode && cm -> frame_type != KEY_FRAME ) encode_nonrd_sb_row ( cpi , & tile , mi_row , & tp ) ;else  encode_rd_sb_row ( cpi , & tile , mi_row , & tp ) ;}cpi -> tok_count [ tile_row ] [ tile_col ] = ( unsigned int ) ( tp - tp_old ) ;assert ( tp - cpi -> tok <= get_token_alloc ( cm -> mb_rows , cm -> mb_cols ) ) ;}}}if ( sf -> skip_encode_sb ) {int j ;","if ( sf -> use_nonrd_pick_mode && cm -> frame_type != KEY_FRAME ) encode_nonrd_sb_row ( cpi , x , & tile , mi_row , & tp ) ;else encode_tiles ( cpi ) ;if ( sf -> skip_encode_sb ) {int j ;",4497
535,"int yr_re_exec ( uint8_t * re_code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {","int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",4498
536,"# define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3  # define prolog if ( bytes_matched >= max_bytes_matched ) {# define fail_if_error ( e ) switch ( e ) {if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ;input -= character_size ;input_incr = - input_incr ;max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ;max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ;","# define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 # define prolog {if ( ( bytes_matched >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) {}# define fail_if_error ( e ) {switch ( e ) {}if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ;max_bytes_matched = ( int ) yr_min ( input_forwards_size , RE_SCAN_LIMIT ) ;}input -= character_size ;input_incr = - input_incr ;else {max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ;max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ;",4498
537,match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ;,"match = _yr_re_is_word_char ( input , character_size ) ;",4498
538,match = IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;match = ! IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;,"match = IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;match = ! _yr_re_is_word_char ( input , character_size ) ;action = match ? ACTION_NONE : ACTION_KILL ;",4498
539,case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 &&  ! ( flags & RE_FLAGS_NOT_AT_START ) &&  ! ( flags & RE_FLAGS_BACKWARDS ) )  match = TRUE ;else if ( bytes_matched >= max_bytes_matched )  match = TRUE ;else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) )  match = TRUE ;else match = FALSE ;case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS )  kill = input_size > ( size_t ) bytes_matched ;else  kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS ||  input_size > ( size_t ) bytes_matched ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;,"case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && input_backwards_size < character_size ) {match = TRUE ;}else if ( bytes_matched >= max_bytes_matched ) {match = TRUE ;}else {assert ( input < input_data + input_forwards_size ) ;assert ( input >= input_data - input_backwards_size ) ;assert ( input - input_incr < input_data + input_forwards_size ) ;assert ( input - input_incr >= input_data - input_backwards_size ) ;match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ;}case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS ) kill = input_backwards_size > ( size_t ) bytes_matched ;else kill = input_backwards_size > 0 || ( bytes_matched != 0 ) ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || input_forwards_size > ( size_t ) bytes_matched ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;",4498
540,"}if ( flags & RE_FLAGS_WIDE && bytes_matched < max_bytes_matched && * ( input + 1 ) != 0 ) {_yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ;","
",4498
541,"ALOGE ( ""b/26366256"" ) ;return ;","ALOGE ( ""b/26366256"" ) ;android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;return ;",4499
542,"r = - ENOMEM ;if ( ! u . lapic ) goto out ;r = kvm_vcpu_ioctl_get_lapic ( vcpu , u . lapic ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( argp , u . lapic , sizeof ( struct kvm_lapic_state ) ) ) goto out ;r = 0 ;break ;}case KVM_SET_LAPIC : {r = - EINVAL ;if ( ! vcpu -> arch . apic ) goto out ;u . lapic = memdup_user ( argp , sizeof ( * u . lapic ) ) ;if ( IS_ERR ( u . lapic ) ) return PTR_ERR ( u . lapic ) ;r = kvm_vcpu_ioctl_set_lapic ( vcpu , u . lapic ) ;break ;}case KVM_INTERRUPT : {struct kvm_interrupt irq ;r = - EFAULT ;if ( copy_from_user ( & irq , argp , sizeof irq ) ) goto out ;r = kvm_vcpu_ioctl_interrupt ( vcpu , & irq ) ;break ;}case KVM_NMI : {r = kvm_vcpu_ioctl_nmi ( vcpu ) ;break ;}case KVM_SET_CPUID : {struct kvm_cpuid __user * cpuid_arg = argp ;struct kvm_cpuid cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_set_cpuid ( vcpu , & cpuid , cpuid_arg -> entries ) ;break ;}case KVM_SET_CPUID2 : {struct kvm_cpuid2 __user * cpuid_arg = argp ;struct kvm_cpuid2 cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_set_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ;break ;}case KVM_GET_CPUID2 : {struct kvm_cpuid2 __user * cpuid_arg = argp ;struct kvm_cpuid2 cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_get_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( cpuid_arg , & cpuid , sizeof cpuid ) ) goto out ;r = 0 ;break ;}case KVM_GET_MSRS : r = msr_io ( vcpu , argp , kvm_get_msr , 1 ) ;break ;case KVM_SET_MSRS : r = msr_io ( vcpu , argp , do_set_msr , 0 ) ;break ;case KVM_TPR_ACCESS_REPORTING : {struct kvm_tpr_access_ctl tac ;r = - EFAULT ;if ( copy_from_user ( & tac , argp , sizeof tac ) ) goto out ;r = vcpu_ioctl_tpr_access_reporting ( vcpu , & tac ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( argp , & tac , sizeof tac ) ) goto out ;r = 0 ;break ;};case KVM_SET_VAPIC_ADDR : {struct kvm_vapic_addr va ;r = - EINVAL ;if ( ! irqchip_in_kernel ( vcpu -> kvm ) ) goto out ;r = - EFAULT ;if ( copy_from_user ( & va , argp , sizeof va ) ) goto out ;r = 0 ;kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ;","r = kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ;",4500
543,"int ip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk ,  __be32 saddr , __be32 daddr , struct ip_options * opt )  {skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ;skb_reset_network_header ( skb ) ;","int ip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk , __be32 saddr , __be32 daddr , struct ip_options_rcu * opt ) {skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> opt . optlen : 0 ) ) ;skb_reset_network_header ( skb ) ;",4501
544,"if ( opt && opt -> optlen ) {iph -> ihl += opt -> optlen >> 2 ;ip_options_build ( skb , opt , daddr , rt , 0 ) ;}","if ( opt && opt -> opt . optlen ) {iph -> ihl += opt -> opt . optlen >> 2 ;ip_options_build ( skb , & opt -> opt , daddr , rt , 0 ) ;}",4501
545,BUG_ON ( direction != ITER_PIPE ) ;i -> type = direction ;,BUG_ON ( direction != ITER_PIPE ) ;WARN_ON ( pipe -> nrbufs == pipe -> buffers ) ;i -> type = direction ;,4502
546,"log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\\continue ;","if ( file -> file_type == FILE_TYPE_GEOMETRY ) {log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\\}else {log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\\}continue ;",4503
547,"# define ThrowPICTException ( exception , message ) {}char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;","# define ThrowPICTException ( exception , message ) \\\\\\\\\\char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;",4504
548,if ( length != 0x000a )  {,"if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length != 0x000a ) {",4504
549,"
","if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",4504
550,"if ( ReadRectangle ( image , & frame ) == MagickFalse )  ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;",4504
551,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,"if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;length = ReadBlobMSBShort ( image ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;for ( i = 0 ;",4504
552,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,4504
553,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,4504
554,if ( length == 0 )  break ;,if ( length == 0 ) break ;,4504
555,if ( length > 154 )  {,if ( length > 154 ) {,4504
556,for ( i = 0 ;i ++ )  if ( ReadBlobByte ( image ) == EOF ) break ;for ( i = 0 ;i ++ )  if ( ReadBlobByte ( image ) == EOF ) break ;,"for ( i = 0 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;for ( i = 0 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;",4504
557,# ifdef CONFIG_SMP  free_percpu ( s -> s_files ) ;# endif for ( i = 0 ;,for ( i = 0 ;,4505
558,get_page ( * page ) ;out : ret = 0 ;,if ( unlikely ( ! try_get_page ( * page ) ) ) {ret = - ENOMEM ;goto unmap ;}out : ret = 0 ;,4506
559,"ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ;if ( ret ) goto error ;","ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len , 0 ) ;if ( ret ) goto error ;",4507
560,"while ( nr > 0 ) {c = tty -> ops -> write ( tty , b , nr ) ;if ( c < 0 ) {","struct n_tty_data * ldata = tty -> disc_data ;while ( nr > 0 ) {mutex_lock ( & ldata -> output_lock ) ;c = tty -> ops -> write ( tty , b , nr ) ;mutex_unlock ( & ldata -> output_lock ) ;if ( c < 0 ) {",4508
561,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;# ifdef DEBUG_MATHEMU printk ( ""In<S2SV_blank>do_mathemu()...<S2SV_blank>pc<S2SV_blank>is<S2SV_blank>%08lx\\\","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;# ifdef DEBUG_MATHEMU printk ( ""In<S2SV_blank>do_mathemu()...<S2SV_blank>pc<S2SV_blank>is<S2SV_blank>%08lx\\\",4509
562,"flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |  EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ;if ( mode & FALLOC_FL_KEEP_SIZE )  flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;mutex_lock ( & inode -> i_mutex ) ;if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) {","mutex_lock ( & inode -> i_mutex ) ;if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) {",4510
563,"if ( max_blocks > 0 ) {truncate_pagecache_range ( inode , start , end - 1 ) ;","}flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ;if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;if ( partial_begin || partial_end ) {ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ;if ( ret ) goto out_mutex ;}if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) {new_size = offset + len ;ret = inode_newsize_ok ( inode , new_size ) ;if ( ret ) goto out_mutex ;if ( max_blocks > 0 ) {flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;truncate_pagecache_range ( inode , start , end - 1 ) ;",4510
564,"prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ;}","enc_tables . counter_head ++ ;enc_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & enc_tables , sizeof ( encT ) ) ;}",4511
565,"memcpy ( buf + x , data + 2 , i ) ;data += 2 + i ;x += i ;}}if ( p < packets ) break ;}if ( l < lines ) {state -> errcode = IMAGING_CODEC_OVERRUN ;return - 1 ;}break ;case 12 : y = I16 ( data ) ;ymax = y + I16 ( data + 2 ) ;data += 4 ;for ( ;y < ymax && y < state -> ysize ;y ++ ) {UINT8 * out = ( UINT8 * ) im -> image [ y ] ;int p , packets = * data ++ ;for ( p = x = 0 ;p < packets ;p ++ , x += i ) {x += data [ 0 ] ;if ( data [ 1 ] & 0x80 ) {i = 256 - data [ 1 ] ;if ( x + i > state -> xsize ) break ;memset ( out + x , data [ 2 ] , i ) ;data += 3 ;}else {i = data [ 1 ] ;if ( x + i > state -> xsize ) break ;memcpy ( out + x , data + 2 , i ) ;data += i + 2 ;}}if ( p < packets ) break ;}if ( y < ymax ) {state -> errcode = IMAGING_CODEC_OVERRUN ;return - 1 ;}break ;case 13 : for ( y = 0 ;y < state -> ysize ;y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;break ;case 15 : for ( y = 0 ;y < state -> ysize ;y ++ ) {UINT8 * out = ( UINT8 * ) im -> image [ y ] ;data += 1 ;for ( x = 0 ;x < state -> xsize ;x += i ) {if ( data [ 0 ] & 0x80 ) {i = 256 - data [ 0 ] ;if ( x + i > state -> xsize ) break ;memcpy ( out + x , data + 1 , i ) ;data += i + 1 ;}else {i = data [ 0 ] ;if ( x + i > state -> xsize ) break ;memset ( out + x , data [ 1 ] , i ) ;data += 2 ;}}if ( x != state -> xsize ) {state -> errcode = IMAGING_CODEC_OVERRUN ;return - 1 ;}}break ;case 16 : for ( y = 0 ;y < state -> ysize ;y ++ ) {UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;memcpy ( buf + x , data , state -> xsize ) ;data += state -> xsize ;","memcpy ( buf , data , state -> xsize ) ;data += state -> xsize ;",4512
566,gfp_mask = sk -> sk_allocation ;if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ;,int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;err = - EMSGSIZE ;if ( npages > MAX_SKB_FRAGS ) goto failure ;gfp_mask = sk -> sk_allocation ;if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ;,4513
567,int npages ;int i ;if ( ! data_len )  break ;npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;,int i ;if ( ! data_len ) break ;npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;,4513
568,"if ( settings . num_threads > 64 ) {fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\\}break ;case \'D\' : if ( ! optarg || ! optarg [ 0 ] ) {fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\\return 1 ;}settings . prefix_delimiter = optarg [ 0 ] ;settings . detail_enabled = 1 ;break ;case \'L\' : if ( enable_large_pages ( ) == 0 ) {preallocate = true ;}else {fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\\return 1 ;}break ;case \'C\' : settings . use_cas = false ;break ;case \'b\' : settings . backlog = atoi ( optarg ) ;break ;case \'B\' : protocol_specified = true ;if ( strcmp ( optarg , ""auto"" ) == 0 ) {settings . binding_protocol = negotiating_prot ;}else if ( strcmp ( optarg , ""binary"" ) == 0 ) {settings . binding_protocol = binary_prot ;}else if ( strcmp ( optarg , ""ascii"" ) == 0 ) {settings . binding_protocol = ascii_prot ;}else {fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\\exit ( EX_USAGE ) ;}break ;case \'I\' : buf = strdup ( optarg ) ;unit = buf [ strlen ( buf ) - 1 ] ;if ( unit == \'k\' || unit == \'m\' || unit == \'K\' || unit == \'M\' ) {buf [ strlen ( buf ) - 1 ] = \'\\\\0\' ;size_max = atoi ( buf ) ;if ( unit == \'k\' || unit == \'K\' ) size_max *= 1024 ;if ( unit == \'m\' || unit == \'M\' ) size_max *= 1024 * 1024 ;settings . item_size_max = size_max ;}else {settings . item_size_max = atoi ( buf ) ;}free ( buf ) ;break ;case \'S\' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\\exit ( EX_USAGE ) ;# endif settings . sasl = true ;break ;case \'F\' : settings . flush_enabled = false ;break ;case \'X\' : settings . dump_enabled = false ;break ;case \'o\' : subopts_orig = subopts = strdup ( optarg ) ;while ( * subopts != \'\\\\0\' ) {switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) {case MAXCONNS_FAST : settings . maxconns_fast = true ;break ;case HASHPOWER_INIT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\\return 1 ;}settings . hashpower_init = atoi ( subopts_value ) ;if ( settings . hashpower_init < 12 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\\return 1 ;}else if ( settings . hashpower_init > 32 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\\return 1 ;}break ;case NO_HASHEXPAND : start_assoc_maint = false ;break ;case SLAB_REASSIGN : settings . slab_reassign = true ;break ;case SLAB_AUTOMOVE : if ( subopts_value == NULL ) {settings . slab_automove = 1 ;break ;}settings . slab_automove = atoi ( subopts_value ) ;if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) {fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\\return 1 ;}break ;case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_ratio = atof ( subopts_value ) ;if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) {fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\\return 1 ;}break ;case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_window = atoi ( subopts_value ) ;if ( settings . slab_automove_window < 3 ) {fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\\return 1 ;}break ;case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\\return 1 ;}settings . tail_repair_time = atoi ( subopts_value ) ;if ( settings . tail_repair_time < 10 ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\\return 1 ;}break ;case HASH_ALGORITHM : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\\return 1 ;};if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) {hash_type = JENKINS_HASH ;}else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) {hash_type = MURMUR3_HASH ;}else {fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\\return 1 ;}break ;case LRU_CRAWLER : start_lru_crawler = true ;break ;case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_sleep = atoi ( subopts_value ) ;if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) {fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\\return 1 ;}break ;case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) {fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_tocrawl = tocrawl ;break ;case LRU_MAINTAINER : start_lru_maintainer = true ;settings . lru_segmented = true ;break ;case HOT_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . hot_lru_pct = atoi ( subopts_value ) ;if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case WARM_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . warm_lru_pct = atoi ( subopts_value ) ;if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) {fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case HOT_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\\return 1 ;}settings . hot_max_factor = atof ( subopts_value ) ;if ( settings . hot_max_factor <= 0 ) {fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case WARM_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\\return 1 ;}settings . warm_max_factor = atof ( subopts_value ) ;if ( settings . warm_max_factor <= 0 ) {fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case TEMPORARY_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\\return 1 ;}settings . temp_lru = true ;settings . temporary_ttl = atoi ( subopts_value ) ;break ;case IDLE_TIMEOUT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\\return 1 ;}settings . idle_timeout = atoi ( subopts_value ) ;break ;case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\\return 1 ;}settings . logger_watcher_buf_size *= 1024 ;break ;case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\\return 1 ;}settings . logger_buf_size *= 1024 ;case SLAB_SIZES : slab_sizes_unparsed = subopts_value ;break ;case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\\}if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\\}slab_chunk_size_changed = true ;break ;case TRACK_SIZES : item_stats_sizes_init ( ) ;break ;case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ;break ;case INLINE_ASCII_RESP : settings . inline_ascii_response = true ;break ;case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ;break ;case NO_SLAB_REASSIGN : settings . slab_reassign = false ;break ;case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ;break ;case NO_MAXCONNS_FAST : settings . maxconns_fast = false ;break ;case NO_LRU_CRAWLER : settings . lru_crawler = false ;start_lru_crawler = false ;break ;case NO_LRU_MAINTAINER : start_lru_maintainer = false ;settings . lru_segmented = false ;break ;# ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\\return 1 ;}ext_cf . page_size *= 1024 * 1024 ;break ;case EXT_PAGE_COUNT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\\return 1 ;}break ;case EXT_WBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\\return 1 ;}ext_cf . wbuf_size *= 1024 * 1024 ;settings . ext_wbuf_size = ext_cf . wbuf_size ;break ;case EXT_THREADS : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\\return 1 ;}break ;case EXT_IO_DEPTH : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\\return 1 ;}break ;case EXT_ITEM_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\\return 1 ;}break ;case EXT_ITEM_AGE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\\return 1 ;}break ;case EXT_LOW_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\\return 1 ;}break ;case EXT_RECACHE_RATE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\\return 1 ;}break ;case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\\return 1 ;}break ;case EXT_DROP_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\\return 1 ;}break ;case EXT_MAX_FRAG : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\\return 1 ;}break ;case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\\return 1 ;}break ;case EXT_DROP_UNREAD : settings . ext_drop_unread = true ;break ;case EXT_PATH : storage_file = strdup ( subopts_value ) ;break ;# endif case MODERN : break ;case NO_MODERN : if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size ;}settings . slab_reassign = false ;settings . slab_automove = 0 ;settings . maxconns_fast = false ;settings . inline_ascii_response = true ;settings . lru_segmented = false ;hash_type = JENKINS_HASH ;start_lru_crawler = false ;start_lru_maintainer = false ;break ;case NO_DROP_PRIVILEGES : settings . drop_privileges = false ;break ;# ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ;break ;# endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\\\""%s\\\\""\\\return 1 ;}}free ( subopts_orig ) ;break ;default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\\\""%c\\\\""\\\return 1 ;}}if ( settings . item_size_max < 1024 ) {fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > 1024 * 1024 ) {if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size / 2 ;}}if ( settings . slab_chunk_size_max > settings . item_size_max ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\\exit ( EX_USAGE ) ;}# ifdef EXTSTORE if ( storage_file ) {if ( settings . item_size_max > ext_cf . wbuf_size ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\\exit ( EX_USAGE ) ;}if ( settings . inline_ascii_response ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( settings . udpport ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\\exit ( EX_USAGE ) ;}}# endif if ( slab_sizes_unparsed != NULL ) {if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) {use_slab_sizes = true ;}else {exit ( EX_USAGE ) ;}}if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\\exit ( EX_USAGE ) ;}if ( settings . temp_lru && ! start_lru_maintainer ) {fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( hash_init ( hash_type ) != 0 ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\\exit ( EX_USAGE ) ;}if ( settings . inter != NULL && strchr ( settings . inter , \',\' ) ) {settings . num_threads_per_udp = 1 ;}else {settings . num_threads_per_udp = settings . num_threads ;}if ( settings . sasl ) {if ( ! protocol_specified ) {settings . binding_protocol = binary_prot ;}else {if ( settings . binding_protocol != binary_prot ) {fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\\exit ( EX_USAGE ) ;}}}if ( tcp_specified && settings . port != 0 && ! udp_specified ) {settings . udpport = settings . port ;}else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {",if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {,4514
569,"char * prime_arg1 ,  * prime_arg2 ;gss_buffer_desc client_name ,  service_name ;","char * prime_arg1 = NULL , * prime_arg2 = NULL ;gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;",4515
570,"else {ret . code = kadm5_rename_principal ( ( void * ) handle , arg -> src , arg -> dest ) ;if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ;krb5_klog_syslog ( LOG_NOTICE , _ ( ""Request:<S2SV_blank>kadm5_rename_principal,<S2SV_blank>"" ""%.*s%s<S2SV_blank>to<S2SV_blank>%.*s%s,<S2SV_blank>%s,<S2SV_blank>"" ""client=%.*s%s,<S2SV_blank>service=%.*s%s,<S2SV_blank>addr=%s"" ) , ( int ) tlen1 , prime_arg1 , tdots1 , ( int ) tlen2 , prime_arg2 , tdots2 , errmsg ? errmsg : _ ( ""success"" ) , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) ) ;if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ;}free ( prime_arg1 ) ;free ( prime_arg2 ) ;exit_func : free_server_handle ( handle ) ;",exit_func : free ( prime_arg1 ) ;free ( prime_arg2 ) ;free_server_handle ( handle ) ;,4515
571,if ( param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;break ;}if ( param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;break ;}if ( param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;break ;,"if ( param2 < 0 || param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;if ( param2 < 0 ) {android_errorWriteLog ( 0x534e4554 , ""32438598"" ) ;ALOGW ( ""\\\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ;}break ;}if ( param2 < 0 || param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;if ( param2 < 0 ) {android_errorWriteLog ( 0x534e4554 , ""32436341"" ) ;ALOGW ( ""\\\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ;}break ;}if ( param2 < 0 || param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;if ( param2 < 0 ) {android_errorWriteLog ( 0x534e4554 , ""32247948"" ) ;ALOGW ( ""\\\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ;}break ;",4516
572,"resend : if ( ! setup_stratum_socket ( pool ) ) {sockd = false ;goto out ;}sockd = true ;if ( recvd ) {clear_sock ( pool ) ;sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;}else {if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\"",<S2SV_blank>\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\""]}"" , swork_id ++ ) ;}if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) {",resend : if ( ! valid_hex ( nonce1 ) ) {,4517
573,"applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ;if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;nonce1 = json_array_string ( res_val , 1 ) ;if ( ! nonce1 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;","applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;if ( n2size < 2 || n2size > 16 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;",4517
574,"if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) {error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name ,  slurm_strerror ( errno ) ) ;","if ( ( fd = _open_as_other ( path_name , req ) ) == - 1 ) {error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , slurm_strerror ( errno ) ) ;",4518
575,"walk -> private += __mincore_unmapped_range ( addr , end ,  walk -> vma , walk -> private ) ;","unsigned char * vec = walk -> private ;unsigned long nr = ( end - addr ) >> PAGE_SHIFT ;memset ( vec , 0 , nr ) ;walk -> private += nr ;",4519
576,"if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) ||  ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) {for ( i = 0 ;segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ;","if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ;if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) {for ( i = 0 ;if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ;",4520
577,"void * zrealloc ( void * ptr , size_t size ) {# ifndef HAVE_MALLOC_SIZE void * realptr ;","void * zrealloc ( void * ptr , size_t size ) {ASSERT_NO_SIZE_OVERFLOW ( size ) ;# ifndef HAVE_MALLOC_SIZE void * realptr ;",4521
578,"FRAME_CONTEXT * const fc = & cm -> fc ;vp9_reader r ;if ( vp9_reader_init ( & r , data , partition_size ) )  vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ;","FRAME_CONTEXT * const fc = cm -> fc ;vpx_reader r ;if ( vpx_reader_init ( & r , data , partition_size , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ;",4522
579,return vp9_reader_has_error ( & r ) ;},return vpx_reader_has_error ( & r ) ;},4522
580,"if ( numrows < 0 || numcols < 0 ) {return 0 ;}return 0 ;}matrix -> datasize_ = numrows * numcols ;if ( matrix -> maxrows_ > 0 ) {if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) {jas_matrix_destroy ( matrix ) ;return 0 ;jas_matrix_destroy ( matrix ) ;return 0 ;","size_t size ;matrix = 0 ;if ( numrows < 0 || numcols < 0 ) {goto error ;}goto error ;}matrix -> datasize_ = 0 ;if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) {goto error ;jas_matrix_destroy ( matrix ) ;return 0 ;",4523
581,},error : if ( matrix ) {jas_matrix_destroy ( matrix ) ;}return 0 ;},4523
582,"
",else {matvar -> name [ tmp - 1 ] = \'\\\\0\' ;},4524
583,}matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ;,}matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ;,4524
584,* dst = * src ;clear_task_ebb ( dst ) ;,__switch_to_tm ( src ) ;tm_recheckpoint_new_task ( src ) ;* dst = * src ;clear_task_ebb ( dst ) ;,4525
585,"int flags = fcntl ( semaphore -> fd , F_GETFL ) ;if ( flags == - 1 ) {if ( fcntl ( semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) == - 1 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>O_NONBLOCK<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ;if ( eventfd_read ( semaphore -> fd , & value ) == - 1 ) return false ;if ( fcntl ( semaphore -> fd , F_SETFL , flags ) == - 1 )  LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>resetore<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ;","int flags = TEMP_FAILURE_RETRY ( fcntl ( semaphore -> fd , F_GETFL ) ) ;if ( flags == - 1 ) {if ( TEMP_FAILURE_RETRY ( fcntl ( semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) ) == - 1 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>O_NONBLOCK<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ;if ( TEMP_FAILURE_RETRY ( eventfd_read ( semaphore -> fd , & value ) == - 1 ) return false ;if ( fcntl ( semaphore -> fd , F_SETFL , flags ) ) == - 1 ) LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>resetore<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ;",4526
586,"
",ND_TCHECK ( bp -> bp_flags ) ;,4527
587,"ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" ,  bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ;","ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ;",4527
588,"int idx , ret = - EINVAL ;if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ;BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ;hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ;","int idx , ret = 0 ;if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;if ( guest_irq >= irq_rt -> nr_rt_entries ) ;hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] ) ) {pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\\goto out ;}hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ;",4528
589,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",4529
590,"if ( ! CDROM_CAN ( CDC_MEDIA_CHANGED ) ) return - ENOSYS ;if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ;if ( ( unsigned int ) arg >= cdi -> capacity )  return - EINVAL ;",if ( arg >= cdi -> capacity ) return - EINVAL ;,4530
591,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,4531
592,struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ;if ( mnt != parent ) {,struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ;if ( dentry != vfsmnt -> mnt_root ) {bptr = * buffer ;blen = * buflen ;error = 3 ;break ;}if ( mnt != parent ) {,4532
593,"vcpu = kvm_arch_vcpu_create ( kvm , id ) ;if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ;","if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;vcpu = kvm_arch_vcpu_create ( kvm , id ) ;if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ;",4533
594,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><frame>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><frame>\\\",4534
595,ld -> bytes_left = ld -> buffer_size - words * 4 ;if ( ld -> bytes_left >= 4 ) {,if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ;else ld -> bytes_left = ld -> buffer_size - words * 4 ;if ( ld -> bytes_left >= 4 ) {,4535
596,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",4536
597,"SetImageColorspace ( image , GRAYColorspace ) ;quantum_type = IndexQuantum ;","SetImageColorspace ( image , GRAYColorspace ) ;quantum_type = IndexQuantum ;",4536
598,"# if ( IPV6_SUPPORT == ENABLED )  if ( strchr ( str , ':' ) )  {else # endif # if ( IPV4_SUPPORT == ENABLED )  if ( strchr ( str , '.' ) )  {","# if ( IPV6_SUPPORT == ENABLED ) if ( osStrchr ( str , ':' ) != NULL ) {else # endif # if ( IPV4_SUPPORT == ENABLED ) if ( osStrchr ( str , '.' ) != NULL ) {",4537
599,"pfn = kvm_pin_pages ( slot , gfn , page_size ) ;if ( is_error_noslot_pfn ( pfn ) ) {kvm_unpin_pages ( kvm , pfn , page_size ) ;goto unmap_pages ;","pfn = kvm_pin_pages ( slot , gfn , page_size >> PAGE_SHIFT ) ;if ( is_error_noslot_pfn ( pfn ) ) {kvm_unpin_pages ( kvm , pfn , page_size >> PAGE_SHIFT ) ;goto unmap_pages ;",4538
600,"switch ( bank )  {case BANK_0 :  enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ;break ;case BANK_1 :  enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ;enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ;break ;case BANK_2 :  enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ;enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ;break ;case BANK_3 :  enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ;break ;default : break ;","if ( bank == BANK_0 ) {enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ;break ;case BANK_1 : enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ;}else if ( bank == BANK_1 ) {enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ;break ;case BANK_3 : enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ;",4539
601,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;",4540
602,"c -> c_normalize = PyObject_GetAttrString ( m , ""normalize"" ) ;Py_DECREF ( m ) ;if ( ! c -> c_normalize ) return 0 ;c -> c_normalize_args = Py_BuildValue ( ""(sN)"" , ""NFKC"" , Py_None ) ;if ( ! c -> c_normalize_args ) {Py_CLEAR ( c -> c_normalize ) ;return 0 ;}PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , NULL ) ;","
",4541
603,if ( upid == - 1 )  type = PIDTYPE_MAX ;,if ( upid == INT_MIN ) return - ESRCH ;if ( upid == - 1 ) type = PIDTYPE_MAX ;,4542
604,"SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;","if ( SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;",4543
605,"dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ;rr -> length = 0 ;","dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) < 0 ) {SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;return - 1 ;}rr -> length = 0 ;",4543
606,"
",hdr -> sadb_msg_reserved = 0 ;,4544
607,"pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;","pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;",4544
608,"case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;break ;","case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;break ;",4545
609,"case 0xe9 : case 0xeb :  jmp_rel ( ctxt , ctxt -> src . val ) ;ctxt -> dst . type = OP_NONE ;","case 0xe9 : case 0xeb : rc = jmp_rel ( ctxt , ctxt -> src . val ) ;ctxt -> dst . type = OP_NONE ;",4545
610,"case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) ctxt -> dst . val = ctxt -> src . val ;case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;break ;","case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) rc = ctxt -> dst . val = ctxt -> src . val ;case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) jmp_rel ( ctxt , ctxt -> src . val ) ;break ;",4545
611,if ( current -> mm )  __flush_tlb_one ( start ) ;else   leave_mm ( smp_processor_id ( ) ) ;},if ( current -> mm ) {__flush_tlb_one ( start ) ;}else {leave_mm ( smp_processor_id ( ) ) ;smp_mb ( ) ;}},4546
612,"static int conditional_skipintra ( MB_PREDICTION_MODE mode ,  MB_PREDICTION_MODE best_intra_mode ) {","static int conditional_skipintra ( PREDICTION_MODE mode , PREDICTION_MODE best_intra_mode ) {",4547
613,struct channel_info * info =  & synth_devs [ dev ] -> chn_info [ chn ] ;,struct channel_info * info ;if ( voice < 0 || voice >= devc -> nr_voice ) return ;if ( chn < 0 || chn > 15 ) return ;info = & synth_devs [ dev ] -> chn_info [ chn ] ;,4548
614,}ZVAL_NULL ( * rval ) ;,zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;}ZVAL_NULL ( * rval ) ;,4549
615,"size_t copied , len , cur_len ;ssize_t total_written = 0 ;","size_t bytes , copied , len , cur_len ;ssize_t total_written = 0 ;",4550
616,"copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it ,  0 , copied ) ;cur_len -= copied ;}cur_len = save_len - cur_len ;wdata -> sync_mode = WB_SYNC_ALL ;","bytes = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , bytes ) ;cur_len -= copied ;if ( copied < bytes ) break ;}cur_len = save_len - cur_len ;if ( ! cur_len ) {for ( i = 0 ;i < nr_pages ;i ++ ) put_page ( wdata -> pages [ i ] ) ;kfree ( wdata ) ;rc = - EFAULT ;break ;}for ( ;nr_pages > i + 1 ;nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) ;wdata -> sync_mode = WB_SYNC_ALL ;",4550
617,break ;case XDR_ENCODE : tl = * tl_data_head ;,* tl_data_head = NULL ;break ;case XDR_ENCODE : tl = * tl_data_head ;,4551
618,"static void write_inter_mode ( vp9_writer * w , MB_PREDICTION_MODE mode ,   const vp9_prob * probs ) {assert ( is_inter_mode ( mode ) ) ;","static void write_inter_mode ( vpx_writer * w , MB_PREDICTION_MODE mode , const vpx_prob * probs ) {assert ( is_inter_mode ( mode ) ) ;",4552
619,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",4553
620,"int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ;int32 bytes_read = 0 ;uint16 bps , nstrips , planar , strips_per_sample ;uint32 src_rowsize , dst_rowsize , rows_processed , rps ;","int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ;uint32 j ;int32 bytes_read = 0 ;uint16 bps , planar ;uint32 nstrips ;uint32 strips_per_sample ;uint32 src_rowsize , dst_rowsize , rows_processed , rps ;",4554
621,int i ;int j ;,jas_matind_t i ;jas_matind_t j ;,4555
622,"private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info ,  size_t count , const uint64_t clsid [ 2 ] )  {","private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , size_t count , const cdf_directory_t * root_storage ) {",4556
623,"if ( ! NOTMIME ( ms ) )   str = cdf_clsid_to_mime ( clsid , clsid2mime ) ;for ( i = 0 ;","if ( ! NOTMIME ( ms ) && root_storage ) str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid , clsid2mime ) ;for ( i = 0 ;",4556
624,"numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;if ( argc > MAX_PACK_ARGS ) {archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ;return ARCHIVE_WARN ;}","if ( argc >= MAX_PACK_ARGS ) {archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ;return ARCHIVE_WARN ;}numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;",4557
625,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,4558
626,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",4558
627,if ( ( msr -> msc_reqbody_spilltodisk )  && ( msr -> msc_reqbody_length + length > ( apr_size_t ) msr -> txcfg -> reqbody_inmemory_limit ) ) {,if ( ( msr -> msc_reqbody_spilltodisk ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON ) && ( msr -> msc_reqbody_length + length > ( apr_size_t ) msr -> txcfg -> reqbody_inmemory_limit ) ) {,4559
628,"SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;","if ( SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;",4560
629,"dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ;rr -> length = 0 ;","dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) < 0 ) {SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;return - 1 ;}rr -> length = 0 ;",4560
630,"parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ;service = & new_service_options ;","parse_global_option ( CMD_SET_DEFAULTS , & new_global_options , NULL , NULL ) ;service = & new_service_options ;",4561
631,char fnam [ PROCLEN ] ;FILE * f ;char * line = NULL ;size_t len = 0 ;,char * line = NULL ;size_t len = 0 ;,4562
632,"if ( ! c2 )  goto out ;* c2 = \'\\\\0\' ;if ( strcmp ( c1 , contrl ) != 0 ) continue ;c2 ++ ;stripnewline ( c2 ) ;if ( nextcg )  * nextcg = get_next_cgroup_dir ( linecmp , cg ) ;goto out ;}goto out ;}out : fclose ( f ) ;free ( line ) ;","if ( ! c2 ) return false ;if ( nextcg ) {* nextcg = get_next_cgroup_dir ( linecmp , cg ) ;}goto out ;}out : free ( c2 ) ;",4562
633,"sy = data -> ds . dimension_size [ 1 ] ;sz = data -> ds . dimension_size [ 2 ] ;dzy = dz * dy ;szy = sz * sy ;size = data -> datalayout_chunk [ data -> ds . dimensionality ] ;log ( ""elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\\if ( ! ( output = malloc ( elements * size ) ) ) {return MYSOFA_NO_MEMORY ;}for ( e = 0 ;e < entries_used * 2 ;e ++ ) {if ( node_type == 0 ) {key = readValue ( reader , reader -> superblock . size_of_lengths ) ;}else {size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ;filter_mask = ( uint32_t ) readValue ( reader , 4 ) ;if ( filter_mask ) {log ( ""TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\\free ( output ) ;return MYSOFA_INVALID_FORMAT ;}for ( j = 0 ;j < data -> ds . dimensionality ;j ++ ) {start [ j ] = readValue ( reader , 8 ) ;log ( ""start<S2SV_blank>%d<S2SV_blank>%lu\\\}if ( readValue ( reader , 8 ) ) {break ;}child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ;log ( ""<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\\store = ftell ( reader -> fhd ) ;if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) {free ( output ) ;return errno ;}if ( ! ( input = malloc ( size_of_chunk ) ) ) {free ( output ) ;return MYSOFA_NO_MEMORY ;}if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) {free ( output ) ;free ( input ) ;return MYSOFA_INVALID_FORMAT ;}olen = elements * size ;err = gunzip ( size_of_chunk , input , & olen , output ) ;free ( input ) ;log ( ""<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\\if ( err || olen != elements * size ) {free ( output ) ;return MYSOFA_INVALID_FORMAT ;}switch ( data -> ds . dimensionality ) {case 1 : for ( i = 0 ;i < olen ;i ++ ) {b = i / elements ;x = i % elements + start [ 0 ] ;if ( x < sx ) {j = x * size + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;",j = x * size + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;,4563
634,if ( y < sy && x < sx ) {j = ( ( x * sy + y ) * size ) + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;,if ( y < sy && x < sx ) {j = ( ( x * sy + y ) * size ) + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;,4563
635,if ( z < sz && y < sy && x < sx ) {j = ( x * szy + y * sz + z ) * size + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;},if ( z < sz && y < sy && x < sx ) {j = ( x * szy + y * sz + z ) * size + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;},4563
636,"uint32_t off = offset , tmp , finish ;struct ipmi_rs * rsp ;finish = fru -> size ;lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" ,  offset + length , finish - offset ) ;}do {tmp = fru -> access ? off >> 1 : off ;","uint32_t off = offset ;uint32_t tmp , finish ;uint32_t size_left_in_buffer ;struct ipmi_rs * rsp ;memset ( frubuf + fru -> size , 0 , length - fru -> size ) ;finish = fru -> size ;lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" , offset + length , finish - offset ) ;length = finish - offset ;}size_left_in_buffer = length ;do {tmp = fru -> access ? off >> 1 : off ;",4564
637,"memcpy ( ( frubuf + off ) - offset , rsp -> data + 1 , tmp ) ;off += tmp ;if ( tmp == 0 && off < finish )  return 0 ;","if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) {printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ;return - 1 ;}memcpy ( ( frubuf + off ) - offset , rsp -> data + 1 , tmp ) ;off += tmp ;size_left_in_buffer -= tmp ;if ( tmp == 0 && off < finish ) return 0 ;",4564
638,if ( g -> sect <= 0 ||  g -> head <= 0 ||  g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,if ( g -> sect <= 0 || g -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,4565
639,if ( ret )   return - EFAULT ;ptr -> next = NULL ;i < 16 ;i ++ ) ptr -> reply [ i ] = 0 ;ptr -> resultcode = 0 ;ptr -> kernel_data = NULL ;if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) {,ptr -> next = NULL ;ptr -> kernel_data = NULL ;if ( ret ) return - EFAULT ;if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) {,4566
640,"int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ;if ( ( ! s -> willclose || s -> chunksize < 0 ) &&  target_end >= 0 && s -> off >= target_end ) return AVERROR_EOF ;if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) &&  target_end >= 0 && s -> off < target_end ) {av_log ( h , AV_LOG_ERROR ,  ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\\","uint64_t target_end = s -> end_off ? s -> end_off : s -> filesize ;if ( ( ! s -> willclose || s -> chunksize == UINT64_MAX ) && s -> off >= target_end ) return AVERROR_EOF ;if ( ! len && ( ! s -> willclose || s -> chunksize == UINT64_MAX ) && s -> off < target_end ) {av_log ( h , AV_LOG_ERROR , ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 ""\\\",4567
641,"error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ;if ( error ) return ( error ) ;leaf = bp -> b_addr ;entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ;ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ;# ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ;ASSERT ( args -> index < ichdr . count ) ;ASSERT ( args -> index >= 0 ) ;if ( entry -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ;namelen = name_loc -> namelen ;name = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ;namelen = name_rmt -> namelen ;name = ( char * ) name_rmt -> name ;}ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ;ASSERT ( namelen == args -> namelen ) ;ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ;# endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ;if ( args -> rmtblkno ) {ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ;name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ;name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ;name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ;","error = xfs_attr3_leaf_read ( args -> rmtvaluelen ) ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ;",4568
642,"
",if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;,4569
643,"bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ;if ( bh ) {","bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ;if ( bh ) {",4569
644,"vp8_mse16x16 ( orig + col , orig_stride ,  recon + col , recon_stride , & sse ) ;","vpx_mse16x16 ( orig + col , orig_stride , recon + col , recon_stride , & sse ) ;",4570
645,case USB_DEVICE_ID_KYE_ERGO_525V :  if ( * rsize >= 74 &&   rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 &&  rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) {,case USB_DEVICE_ID_KYE_ERGO_525V : if ( * rsize >= 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) {,4571
646,attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ;if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;attrs = malloc ( alloc_size ) ;if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ;",4572
647,char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ;rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ;uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ;int len = 0 ;,union {char bytes [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ;rfbSetEncodingsMsg msg ;}buf ;rfbSetEncodingsMsg * se = & buf . msg ;uint32_t * encs = ( uint32_t * ) ( & buf . bytes [ sz_rfbSetEncodingsMsg ] ) ;int len = 0 ;,4573
648,"if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ;return TRUE ;","if ( ! WriteToRFBServer ( client , buf . bytes , len ) ) return FALSE ;return TRUE ;",4573
649,"return MSPACK_ERR_SIGNATURE ;}hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ;hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ;hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ;hdr -> length = 0 ;hdr -> filename = NULL ;hdr -> extra = NULL ;hdr -> extra_length = 0 ;if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) {if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;hdr -> length = EndGetI32 ( & buf [ 0 ] ) ;}if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) {if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ;}if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) {if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ;i = EndGetI16 ( & buf [ 0 ] ) ;if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ;}if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) {off_t pos = sys -> tell ( fh ) ;char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ;if ( ! fn ) return MSPACK_ERR_NOMEMORY ;hdr -> filename = fn ;if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) {if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 9 ) ? i + 1 : 9 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) )  return MSPACK_ERR_SEEK ;}if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 4 ) ? i + 1 : 4 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) )  return MSPACK_ERR_SEEK ;}if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ;","int len ;char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ;if ( ! fn ) return MSPACK_ERR_NOMEMORY ;hdr -> filename = fn ;if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) {if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 9 ) ? i + 1 : 9 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) return MSPACK_ERR_SEEK ;}if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 4 ) ? i + 1 : 4 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) return MSPACK_ERR_SEEK ;}if ( ! ( hdr -> filename = fn ) ) return MSPACK_ERR_NOMEMORY ;",4574
650,case NPPVpluginNameString : case NPPVpluginDescriptionString :  case NPPVformValue :  type = RPC_TYPE_STRING ;case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory :  type = RPC_TYPE_BOOLEAN ;break ;,case NPPVpluginNameString : case NPPVpluginDescriptionString : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId : type = RPC_TYPE_STRING ;case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ;break ;,4575
651,unsigned int i ;bpcc -> numcmpts = box -> datalen ;,unsigned int i ;bpcc -> bpcs = 0 ;bpcc -> numcmpts = box -> datalen ;,4576
652,"return print_value ( item , 0 , 1 ) ;}","return print_value ( item , 0 , 1 , 0 ) ;}",4577
653,"int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) ,  top = p -> top ;",int i ;int ubits = BN_num_bits ( u ) ;int vbits = BN_num_bits ( v ) ;int top = p -> top ;,4578
654,if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 )   break ;if ( ubits < vbits ) {,if ( ubits <= BN_BITS2 ) {if ( udp [ 0 ] == 0 ) goto err ;if ( udp [ 0 ] == 1 ) break ;}if ( ubits < vbits ) {,4578
655,"if ( setpwnam ( pw ) < 0 )  err ( EXIT_FAILURE , _ ( ""setpwnam<S2SV_blank>failed\\\","if ( setpwnam ( pw , "".chsh"" ) < 0 ) err ( EXIT_FAILURE , _ ( ""setpwnam<S2SV_blank>failed\\\",4579
656,"int namelen = strlen ( name ) ;int len ;while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) {len = ff_amf_tag_size ( data , data_end ) ;if ( len < 0 )  len = data_end - data ;data ++ ;for ( ;if ( ! size )  break ;if ( size < 0 || size >= data_end - data ) return - 1 ;if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) {switch ( * data ++ ) {case AMF_DATA_TYPE_NUMBER :  snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ;break ;case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ;break ;case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ;av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ;break ;default : return - 1 ;}return 0 ;}len = ff_amf_tag_size ( data , data_end ) ;if ( len < 0 || len >= data_end - data ) return - 1 ;data += len ;}return - 1 ;","GetByteContext gb ;if ( len < 0 ) len = data_end - data ;data ++ ;for ( ;if ( data >= data_end ) return - 1 ;if ( size == namelen && ! memcmp ( data - size , name , dst , dst_size ) ;",4580
657,"size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;size += rw_tlv_length ;skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ;","if ( ! miux_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;if ( ! rw_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += rw_tlv_length ;skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ;",4581
658,const uint8_t * src = in -> data [ 0 ] ;,const uint8_t * src = in -> data [ plane ] && in -> linesize [ 0 ] ;,4582
659,for ( plane = 0 ;uint8_t * dst = out -> data [ plane ] ;,for ( plane = 0 ;uint8_t * dst = out -> data [ plane ] ;,4582
660,"int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ;","int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ;",4583
661,",  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL }LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL },  {","LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/tty"" , NULL , MS_BIND , NULL }, {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/tty"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL }, {",4584
662,"r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ;saved_errno = errno ;","r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL ) ;saved_errno = errno ;",4584
663,"if ( ! empty_tuple ||  PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 ||   PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) {Py_XDECREF ( empty_tuple ) ;","if ( ! empty_tuple || _PyDict_SetItemId ( d , ""_fields"" , empty_tuple ) < 0 || PyDict_SetItemString ( d , & PyId__fields , empty_tuple ) < 0 ) {Py_XDECREF ( empty_tuple ) ;",4585
664,if (  # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) {,p -> replacement_session_keyring = NULL ;if ( # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) {,4586
665,if ( * length < 2 ) return ( ( unsigned short ) ~ 0 ) ;for ( i = 0 ;i < 2 ;i ++ ) {c = ( int ) ( * ( * p ) ++ ) ;( * length ) -- ;buffer [ i ] = ( unsigned char ) c ;}value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ;value |= buffer [ 1 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,if ( * length < 2 ) return ( ( unsigned short ) buffer [ 0 ] << 8 ) ;value |= ( unsigned short ) buffer [ 1 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,4587
666,dsize += svbranch . len ;},dsize += svbranch . len + 1 ;},4588
667,"
",atomic_dec ( & chip -> active ) ;,4589
668,"if ( err < 0 ) goto __error ;usb_chip [ chip -> index ] = chip ;chip -> num_interfaces ++ ;usb_set_intfdata ( intf , chip ) ;atomic_dec ( & chip -> active ) ;mutex_unlock ( & register_mutex ) ;return 0 ;__error : if ( chip ) {if ( ! chip -> num_interfaces )  snd_card_free ( chip -> card ) ;atomic_dec ( & chip -> active ) ;}",},4589
669,"separator = strchr ( line , \':\' ) ;if ( separator != NULL ) {","separator = osStrchr ( line , \':\' ) ;if ( separator != NULL ) {",4590
670,"memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ;up -> family = kp -> encap_family ;","memset ( up , 0 , sizeof ( * up ) ) ;memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ;up -> family = kp -> encap_family ;",4591
671,"static void encode_share_access ( struct xdr_stream * xdr , int open_flags )  {switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) {case FMODE_READ : WRITE32 ( NFS4_SHARE_ACCESS_READ ) ;default :  BUG ( ) ;}","static void encode_share_access ( struct xdr_stream * xdr , fmode_t fmode ) {switch ( fmode & ( FMODE_READ | FMODE_WRITE ) ) {case FMODE_READ : WRITE32 ( NFS4_SHARE_ACCESS_READ ) ;default : WRITE32 ( 0 ) ;}",4592
672,"if ( ! sock ) goto out ;vhost_disable_notify ( & net -> dev , vq ) ;vhost_hlen = nvq -> vhost_hlen ;sock_hlen = nvq -> sock_hlen ;vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? vq -> log : NULL ;mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ;while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) {sock_len += sock_hlen ;vhost_len = sock_len + vhost_hlen ;headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? UIO_MAXIOV : 1 ) ;if ( unlikely ( headcount < 0 ) ) break ;if ( ! headcount ) {if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) {","if ( unlikely ( headcount > UIO_MAXIOV ) ) {msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\\continue ;}if ( ! headcount ) {if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) {",4593
673,"msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg ,  sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;if ( unlikely ( err != sock_len ) ) {pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\\","msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;if ( unlikely ( err != sock_len ) ) {pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\\",4593
674,"if ( size < sizeof ( outarg ) ) goto err ;err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ;err = - ENAMETOOLONG ;if ( outarg . namelen > FUSE_NAME_MAX ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ;if ( err ) goto err ;","if ( size != sizeof ( outarg ) + outarg . namelen > FUSE_NAME_MAX ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ;",4594
675,trust_data . dwUIChoice = WTD_UI_ALL ;trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ;return r ;},"trust_data . dwUIChoice = WTD_UI_NONE ;trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ;switch ( r ) {case ERROR_SUCCESS : break ;case TRUST_E_NOSIGNATURE : uprintf ( ""PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ;MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ;break ;default : uprintf ( ""PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ;MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ;break ;}return r ;}",4595
676,"if ( level >= ms -> c . len ) {len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ;ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ;","if ( level >= ms -> c . len = 20 + level ) * sizeof ( * ms -> c . li ) ;ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ;",4596
677,"pid_t child ;char template [ ] = ""virtiofsd-XXXXXX"" ;char * tmpdir ;child = fork ( ) ;if ( child < 0 ) {fuse_log ( FUSE_LOG_ERR , ""fork()<S2SV_blank>failed:<S2SV_blank>%m\\\exit ( 1 ) ;}if ( child > 0 ) {pid_t waited ;int wstatus ;setup_wait_parent_capabilities ( ) ;do {waited = waitpid ( child , & wstatus , 0 ) ;}while ( waited < 0 && errno == EINTR && ! se -> exited ) ;if ( se -> exited ) {exit ( 0 ) ;}if ( WIFEXITED ( wstatus ) ) {exit ( WEXITSTATUS ( wstatus ) ) ;}exit ( 1 ) ;}prctl ( PR_SET_PDEATHSIG , SIGTERM ) ;",pid_t child ;,4597
678,"tmpdir = mkdtemp ( template ) ;if ( ! tmpdir ) {if ( mount ( ""/proc/self/fd"" , tmpdir , NULL , MS_BIND , NULL ) < 0 ) {fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>%s,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\\lo -> proc_self_fd = open ( tmpdir , O_PATH ) ;if ( lo -> proc_self_fd == - 1 ) {fuse_log ( FUSE_LOG_ERR , ""open(%s,<S2SV_blank>O_PATH):<S2SV_blank>%m\\\exit ( 1 ) ;fuse_log ( FUSE_LOG_ERR , ""umount2(%s,<S2SV_blank>MNT_DETACH):<S2SV_blank>%m\\\","tmpdir = mkdtemp ( template ) ;if ( ! tmpdir ) {if ( mount ( ""/proc/self/fd"" , tmpdir , NULL , MS_BIND , NULL ) < 0 ) {fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>%s,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\\lo -> proc_self_fd = open ( tmpdir , O_PATH ) ;if ( lo -> proc_self_fd == - 1 ) {fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\\exit ( 1 ) ;fuse_log ( FUSE_LOG_ERR , ""open(/proc,<S2SV_blank>O_PATH):<S2SV_blank>%m\\\",4597
679,"int c_sz ;if ( ! file_read ( frame , 6 , _fin ) ) return 0 ;if ( memcmp ( frame , ""FRAME"" , 5 ) ) {fprintf ( stderr , ""Loss<S2SV_blank>of<S2SV_blank>framing<S2SV_blank>in<S2SV_blank>Y4M<S2SV_blank>input<S2SV_blank>data\\\return - 1 ;}if ( frame [ 5 ] != \'\\\char c ;int j ;for ( j = 0 ;j < 79 && file_read ( & c , 1 , _fin ) && c != \'\\\j ++ ) {}if ( j == 79 ) {fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>header\\\return - 1 ;}}if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) {fprintf ( stderr , ""Error<S2SV_blank>reading<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>data.\\\return - 1 ;}if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {fprintf ( stderr , ""Error<S2SV_blank>reading<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>data.\\\return - 1 ;}( * _y4m -> convert ) ( _y4m , _y4m -> dst_buf , _y4m -> aux_buf ) ;memset ( _img , 0 , sizeof ( * _img ) ) ;_img -> fmt = _y4m -> vpx_fmt ;_img -> w = _img -> d_w = _y4m -> pic_w ;_img -> h = _img -> d_h = _y4m -> pic_h ;_img -> x_chroma_shift = _y4m -> dst_c_dec_h >> 1 ;_img -> y_chroma_shift = _y4m -> dst_c_dec_v >> 1 ;_img -> bps = _y4m -> vpx_bps ;pic_sz = _y4m -> pic_w * _y4m -> pic_h ;c_w = ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ;c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ;c_sz = c_w * c_h ;_img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w ;_img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ;_img -> planes [ PLANE_Y ] = _y4m -> dst_buf ;_img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ;_img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ;_img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ;return 1 ;",int c_sz ;int bytes_per_sample = _y4m -> bps ;pic_sz = _y4m -> pic_w * _y4m -> pic_h * bytes_per_sample ;c_w = ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ;c_w *= bytes_per_sample ;c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ;c_sz = c_w * c_h ;_img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w * bytes_per_sample ;_img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ;_img -> planes [ PLANE_Y ] = _y4m -> dst_buf ;_img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ;_img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ;_img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ;return 1 ;,4598
680,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;",4599
681,"exit :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret <= 0 ? ret : - EIO ;","exit : mutex_unlock ( & dev -> lock , flags ) ;return ret <= 0 ? ret : - EIO ;",4599
682,"( void ) AcquireUniqueFilename ( postscript_file ) ;ps_file = fopen_utf8 ( postscript_file , ""wb"" ) ;if ( ps_file == ( FILE * ) NULL ) goto FINISH ;( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ;( void ) ReadBlob ( image , 2 * MaxTextExtent , magick ) ;( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ;while ( PS_Size -- > 0 ) {( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ;}( void ) fclose ( ps_file ) ;magic_info = GetMagicInfo ( magick , 2 * MaxTextExtent , exception ) ;if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ;if ( exception -> severity != UndefinedException ) goto FINISH_UNL ;if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ;( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ;FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ;","( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ;FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ;",4600
683,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;",4601
684,"exit :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret <= 0 ? ret : - EIO ;","exit : mutex_unlock ( & dev -> lock , flags ) ;return ret <= 0 ? ret : - EIO ;",4601
685,WORD32 i ;WORD32 sps_id ;,"WORD32 i , j ;WORD32 sps_id ;",4602
686,for ( i = 0 ;i < ps_pps -> i1_num_extra_slice_header_bits ;i ++ ) {,for ( j = 0 ;j < ps_codec -> i4_max_dpb_size ;j ++ ) {,4602
687,"for ( i = 0 ;i ++ )  {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ;break ;","for ( i = 0 ;i ++ ) {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , j , BUF_MGR_REF ) ;break ;",4602
688,static void  sraSpanRemove ( sraSpan * span ) {span -> _prev -> _next = span -> _next ;},static void sraSpanRemove ( sraSpan * span ) {if ( span ) {span -> _prev -> _next = span -> _next ;}},4603
689,"
","if ( ! N ) {ret = - EINVAL ;parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ;goto out_free ;}",4604
690,prog [ N ] . pred = NULL ;prog [ N ] . target = 1 ;,prog [ N ] . pred = NULL ;prog [ N ] . target = 1 ;,4604
691,"switch ( s -> nal_unit_type ) {case HEVC_NAL_VPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_vps ( gb , s -> avctx , & s -> ps ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_SPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_sps ( gb , s -> avctx , & s -> ps , s -> apply_defdispwin ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_PPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_pps ( gb , s -> avctx , & s -> ps ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_SEI_PREFIX : case HEVC_NAL_SEI_SUFFIX : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_sei ( gb , s -> avctx , & s -> sei , & s -> ps , s -> nal_unit_type ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_TRAIL_R : case HEVC_NAL_TRAIL_N : case HEVC_NAL_TSA_N : case HEVC_NAL_TSA_R : case HEVC_NAL_STSA_N : case HEVC_NAL_STSA_R : case HEVC_NAL_BLA_W_LP : case HEVC_NAL_BLA_W_RADL : case HEVC_NAL_BLA_N_LP : case HEVC_NAL_IDR_W_RADL : case HEVC_NAL_IDR_N_LP : case HEVC_NAL_CRA_NUT : case HEVC_NAL_RADL_N : case HEVC_NAL_RADL_R : case HEVC_NAL_RASL_N : case HEVC_NAL_RASL_R : ret = hls_slice_header ( s ) ;if ( ret < 0 )  return ret ;if ( ( s -> avctx -> skip_frame >= AVDISCARD_BIDIR && s -> sh . slice_type == HEVC_SLICE_B ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONINTRA && s -> sh . slice_type != HEVC_SLICE_I ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONKEY && ! IS_IRAP ( s ) ) ) {break ;}if ( s -> sh . first_slice_in_pic_flag ) {if ( s -> ref ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\\goto fail ;}if ( s -> max_ra == INT_MAX ) {",switch ( s -> max_ra == INT_MAX ) {,4605
692,if ( ! chan ) {err = - EINVAL ;goto out_free ;}if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ;request -> channels [ i ] = chan ;,request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;,4606
693,"nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) {if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;","nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) {if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;",4606
694,static inline __u32 dccp_v6_init_sequence ( struct sk_buff * skb )  {,static inline __u64 dccp_v6_init_sequence ( struct sk_buff * skb ) {,4607
695,task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ;task -> tk_owner = current -> tgid ;,task -> tk_rebind_retry = 2 ;task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ;task -> tk_owner = current -> tgid ;,4608
696,"expr_ty returns ;if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) {","expr_ty returns ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) {",4609
697,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
698,"* out = FunctionDef ( name , args , body , decorator_list , returns , lineno ,  col_offset , end_lineno , end_col_offset , arena ) ;","* out = FunctionDef ( name , args , body , decorator_list , returns , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
699,"expr_ty returns ;if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) {","expr_ty returns ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) {",4609
700,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
701,"* out = AsyncFunctionDef ( name , args , body , decorator_list , returns ,   lineno , col_offset , end_lineno , end_col_offset ,  arena ) ;","* out = AsyncFunctionDef ( name , args , body , decorator_list , returns , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
702,"
",string type_comment ;,4609
703,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
704,"if ( _PyObject_LookupAttrId ( obj , & PyId_targets , & tmp ) < 0 ) {return 1 ;","if ( _PyObject_LookupAttrId ( obj , & PyId_targets , & tmp ) < 0 ) {return 1 ;",4609
705,"* out = Assign ( targets , value , lineno , col_offset , end_lineno ,  end_col_offset , arena ) ;","* out = Assign ( targets , value , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
706,"asdl_seq * orelse ;if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) {","asdl_seq * orelse ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) {",4609
707,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
708,"* out = For ( target , iter , body , orelse , lineno , col_offset , end_lineno ,  end_col_offset , arena ) ;","* out = For ( target , iter , body , orelse , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
709,"asdl_seq * orelse ;if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) {","asdl_seq * orelse ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) {",4609
710,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
711,"* out = AsyncFor ( target , iter , body , orelse , lineno , col_offset ,  end_lineno , end_col_offset , arena ) ;","* out = AsyncFor ( target , iter , body , orelse , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
712,"
",string type_comment ;,4609
713,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
714,"if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) {return 1 ;","if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) {return 1 ;",4609
715,"* out = With ( items , body , lineno , col_offset , end_lineno ,  end_col_offset , arena ) ;","* out = With ( items , body , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
716,"asdl_seq * body ;if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) {","asdl_seq * body ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) {",4609
717,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
718,"* out = AsyncWith ( items , body , lineno , col_offset , end_lineno ,  end_col_offset , arena ) ;","* out = AsyncWith ( items , body , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
719,"if ( s -> width != avctx -> width && s -> height != avctx -> height ) {ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ;","if ( s -> width != avctx -> width || s -> height != avctx -> height ) {ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ;",4610
720,"struct list_head tmplist ;newsk -> sk_sndbuf = oldsk -> sk_sndbuf ;if ( oldsp -> do_auto_asconf ) {memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ;inet_sk_copy_descendant ( newsk , oldsk ) ;","newsk -> sk_sndbuf = oldsk -> sk_sndbuf ;sctp_copy_descendant ( newsk , oldsk ) ;",4611
721,struct snd_ctl_elem_id id ;unsigned int idx ;,struct snd_ctl_elem_id id ;unsigned int count ;unsigned int idx ;,4612
722,"up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",4612
723,"DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\\","DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>%"" SIZE_T_FORMAT ""u\\\",4613
724,"if ( nelements == 0 ) {DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\goto out ;","if ( nelements > CDF_ELEMENT_LIMIT || nelements == 0 ) {DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\goto out ;",4613
725,"DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\\","
",4613
726,"disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;","disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || IS_MNT_LOCKED_AND_LAZY ( p ) ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;",4614
727,"uint16_t numChannels , chansSpecified , chanMask = 0 ;uint32_t sampleRate ;","uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ;uint32_t sampleRate ;",4615
728,"if ( numChannels < chansSpecified || numChannels < 1 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;","if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;",4615
729,"
","if ( ! config -> num_channels ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}",4615
730,total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;break ;,total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;break ;,4615
731,"BIGNUM a , c , d , e ;int i ;BN_init ( & a ) ;BN_init ( & c ) ;BN_init ( & d ) ;BN_init ( & e ) ;BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ;a . neg = rand_neg ( ) ;BN_sqr ( & c , & a , ctx ) ;if ( bp != NULL ) {BN_print ( bp , & a ) ;BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ;BN_print ( bp , & a ) ;BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ;}BN_print ( bp , & c ) ;BIO_puts ( bp , ""\\\}BN_div ( & d , & e , & c , & a , ctx ) ;BN_sub ( & d , & d , & a ) ;if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) )  {fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\\return 0 ;}}BN_free ( & a ) ;BN_free ( & c ) ;BN_free ( & d ) ;BN_free ( & e ) ;return ( 1 ) ;","BIGNUM * a , * c , * d , * e ;int i , ret = 0 ;a = BN_new ( ) ;c = BN_new ( ) ;d = BN_new ( ) ;e = BN_new ( ) ;if ( a == NULL || c == NULL || d == NULL || e == NULL ) {goto err ;}BN_bntest_rand ( a , 40 + i * 10 , 0 , 0 ) ;a -> neg = rand_neg ( ) ;BN_sqr ( c , a , ctx ) ;if ( bp != NULL ) {if ( ! results ) {BN_print ( bp , a ) ;BIO_puts ( bp , a ) ;BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ;}BN_print ( bp , c ) ;BIO_puts ( bp , ""\\\}BN_div ( d , e , c , a , ctx ) ;BN_sub ( & d , & d , & a ) ;if ( ! BN_is_zero ( d ) || ! BN_is_zero ( & e ) ) {fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\\goto err ;}BN_hex2bn ( & a , ""80000000000000000000000080000001FFFFFFFE000000000000000000000000"" ) ;BN_sqr ( c , a , ctx ) ;if ( bp != NULL ) {BN_print ( bp , a ) ;BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ;BN_print ( bp , a ) ;BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ;}BN_print ( bp , c ) ;BIO_puts ( bp , ""\\\}BN_mul ( d , a , a , ctx ) ;if ( BN_cmp ( c , d ) ) {fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\\goto err ;}ret = 1 ;err : if ( a != NULL ) BN_free ( a ) ;if ( c != NULL ) BN_free ( c ) ;if ( d != NULL ) BN_free ( d ) ;if ( e != NULL ) BN_free ( e ) ;return ret ;",4616
732,"wsprintf ( time_buf , TEXT ( ""%d<S2SV_blank>%S<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ) ,  ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] ,  ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;png_snprintf6 ( near_time_buf , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ,  ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] ,  ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;# else png_snprintf6 ( png_ptr -> time_buffer , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ,  ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] ,  ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;","wsprintf ( time_buf , TEXT ( ""%d<S2SV_blank>%S<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ) , ptime -> day % 32 , short_months [ ( ptime -> month - 1U ) % 12 ] , ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;png_snprintf6 ( near_time_buf , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" , ptime -> day % 32 , short_months [ ( ptime -> month - 1U ) % 12 ] , ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;# else png_snprintf6 ( png_ptr -> time_buffer , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" , ptime -> day % 32 , short_months [ ( ptime -> month - 1U ) % 12 ] , ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;",4617
733,"if ( cfo . op != KD_FONT_OP_SET ) log_warning ( ""Fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>remaining<S2SV_blank>consoles"" ) ;for ( i = 1 ;i <= 63 ;i ++ ) {char ttyname [ sizeof ( ""/dev/tty63"" ) ] ;_cleanup_close_ int fd_d = - 1 ;if ( i == src_idx || verify_vc_allocation ( i ) < 0 ) continue ;xsprintf ( ttyname , ""/dev/tty%u"" , i ) ;fd_d = open_terminal ( ttyname , O_RDWR | O_CLOEXEC | O_NOCTTY ) ;if ( fd_d < 0 ) {log_warning_errno ( fd_d , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>tty%u,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied:<S2SV_blank>%m"" , i ) ;continue ;}if ( verify_vc_kbmode ( fd_d ) < 0 )  continue ;",if ( vt_verify_kbmode ( fd_d ) < 0 ) continue ;,4618
734,"if ( rdf_parser -> uri_filter )  raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;","raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;if ( rdf_parser -> uri_filter ) raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;",4619
735,fpm_globals . max_requests = wp -> config -> pm_max_requests ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,fpm_globals . max_requests = wp -> config -> pm_max_requests ;fpm_globals . listening_socket = dup ( wp -> listening_socket ) ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,4620
736,goto retry ;},"err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ;if ( err ) goto out ;err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ;if ( err ) goto out ;goto retry ;}",4621
737,"fprintf ( file , ""<S2SV_blank>%s=\\\\""%s\\\\"""" , tag -> bit_name , tag -> bit_val ) ;}","fputc ( \'<S2SV_blank>\' , file ) ;fputs ( tag -> bit_name , file ) ;fputc ( \'=\' , file ) ;save_quoted ( tag -> bit_val , file ) ;}",4622
738,"end = ( char * ) defs + shdr -> sh_size ;sdb_set ( sdb , ""section_name"" , section_name , 0 ) ;sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;",end = ( char * ) defs > i ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;,4623
739,if ( vdaux < 1 ) {sdb_free ( sdb_verdef ) ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {sdb_free ( sdb_verdef ) ;if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) {sdb_free ( sdb_verdef ) ;,4623
740,if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) {sdb_free ( sdb_verdef ) ;,4623
741,next_input = input + i * input_incr ;if ( bytes_matched + i >= max_bytes_matched )  break ;if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) {,if ( bytes_matched + i >= max_bytes_matched ) break ;next_input = input + i * input_incr ;if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) {,4624
742,ip = next_opcode ;break ;,"bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;ip = next_opcode ;break ;",4624
743,"
",dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;,4625
744,random_ether_addr ( dev -> dev_addr ) ;dev -> tx_queue_len = TUN_READQ_SIZE ;,random_ether_addr ( dev -> dev_addr ) ;dev -> tx_queue_len = TUN_READQ_SIZE ;,4625
745,"near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ;}near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ;}near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ;near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ;near_sad [ 2 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 - 16 , xd -> dst . y_stride , UINT_MAX ) ;}","near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride ) ;}near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride ) ;}near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride ) ;near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride ) ;near_sad [ 2 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride ) ;}",4626
746,"if ( near_sad [ 4 ] != INT_MAX )  near_sad [ 4 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ;if ( near_sad [ 5 ] != INT_MAX )  near_sad [ 5 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - 16 , pre_y_stride , UINT_MAX ) ;near_sad [ 3 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer , pre_y_stride , UINT_MAX ) ;if ( near_sad [ 6 ] != INT_MAX )  near_sad [ 6 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + 16 , pre_y_stride , UINT_MAX ) ;if ( near_sad [ 7 ] != INT_MAX )  near_sad [ 7 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ;}","if ( near_sad [ 4 ] != INT_MAX ) near_sad [ 4 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - pre_y_stride * 16 , pre_y_stride ) ;if ( near_sad [ 5 ] != INT_MAX ) near_sad [ 5 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - 16 , pre_y_stride ) ;near_sad [ 3 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer , pre_y_stride ) ;if ( near_sad [ 6 ] != INT_MAX ) near_sad [ 6 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + 16 , pre_y_stride ) ;if ( near_sad [ 7 ] != INT_MAX ) near_sad [ 7 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + pre_y_stride * 16 , pre_y_stride ) ;}",4626
747,"
","xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;",4627
748,out_dqrele :  xfs_qm_dqrele ( udqp ) ;,out_dqrele : xfs_qm_dqrele ( udqp ) ;,4627
749,static void parse_input ( h2o_http2_conn_t * conn )  {,static int parse_input ( h2o_http2_conn_t * conn ) {,4628
750,close_connection ( conn ) ;return ;return ;EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ;},return close_connection ( conn ) ;return 0 ;EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ;return 0 ;},4628
751,"forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  NULL , NULL ) ;forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  NULL , NULL ) ;","forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , offset , flags , NULL , NULL ) ;forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , offset , flags , NULL , NULL ) ;",4629
752,"backward_matches = exec ( ac_match -> backward_code ,  data + offset ,  offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ;","backward_matches = exec ( ac_match -> backward_code , data + offset , data_size - offset , offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ;",4629
753,"if ( av_strstart ( url , ""crypto"" , NULL ) ) {if ( url [ 6 ] == \'+\' || url [ 6 ] == \':\' ) proto_name = avio_find_protocol_name ( url + 7 ) ;if ( ! proto_name ) proto_name = avio_find_protocol_name ( url ) ;if ( ! proto_name ) return AVERROR_INVALIDDATA ;if ( ! av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) )  return AVERROR_INVALIDDATA ;","if ( av_strstart ( proto_name , ""file"" , NULL ) ) {if ( strcmp ( c -> allowed_extensions , ""ALL"" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) {av_log ( s , AV_LOG_ERROR , ""Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\\\\\'%s\\\\\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\\return AVERROR_INVALIDDATA ;}else if ( av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) ) {;}else return AVERROR_INVALIDDATA ;",4630
754,while ( buflen > 0 ) {union_desc = ( struct usb_cdc_union_desc * ) buf ;return union_desc ;},"while ( buflen >= sizeof ( * union_desc ) ) {union_desc = ( struct usb_cdc_union_desc * ) buf ;if ( union_desc -> bLength > buflen ) {dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\\return NULL ;}if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ;dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\\return NULL ;}",4631
755,"i += 2 ;found_default = 1 ;}else if ( found_default ) {ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ;return NULL ;}arg = ast_for_arg ( c , ch ) ;if ( ! arg ) return NULL ;asdl_seq_SET ( posargs , k ++ , arg ) ;i += 2 ;break ;case STAR : if ( i + 1 >= NCH ( n ) ||  ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) {ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ;res = handle_keywordonly_args ( c , n , i ,  kwonlyargs , kwdefaults ) ;if ( res == - 1 ) return NULL ;i = res ;}else {vararg = ast_for_arg ( c , ch ) ;if ( ! vararg ) return NULL ;i += 3 ;if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) {int res = 0 ;res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ;if ( res == - 1 ) return NULL ;i = res ;}}case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ;assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ;kwarg = ast_for_arg ( c , ch ) ;if ( ! kwarg ) return NULL ;i += 3 ;break ;","i += 1 ;if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) i += 1 ;break ;case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) {ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) {vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ;if ( ! vararg -> type_comment ) return NULL ;i += 2 ;if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;break ;case TYPE_COMMENT : assert ( i ) ;if ( kwarg ) arg = kwarg ;arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ;if ( ! arg -> type_comment ) return NULL ;i += 1 ;",4632
756,"if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) )  return ( 0 ) ;tif -> tif_rawcc = 0 ;","if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) ) {tif -> tif_rawcc = 0 ;tif -> tif_rawcp = tif -> tif_rawdata ;return ( 0 ) ;}tif -> tif_rawcc = 0 ;",4633
757,ASSERT ( redir_index < IOAPIC_NUM_PINS ) ;redir_content = ioapic -> redirtbl [ redir_index ] . bits ;result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ;,if ( redir_index < IOAPIC_NUM_PINS ) ;redir_content = ioapic -> redirtbl [ redir_index ] . bits ;else redir_content = ~ 0ULL ;result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ;,4634
758,"vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;","memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;",4635
759,"if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;if ( error )  goto out_errno ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;","error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;",4636
760,pvc . sap_family = AF_ATMPVC ;pvc . sap_addr . itf = vcc -> dev -> number ;,"memset ( & pvc , 0 , sizeof ( pvc ) ) ;pvc . sap_family = AF_ATMPVC ;pvc . sap_addr . itf = vcc -> dev -> number ;",4637
761,cancel_delayed_work_sync ( & ln -> grace_period_end ) ;locks_end_grace ( & ln -> lockd_manager ) ;,"
",4638
762,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;exit :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;exit : mutex_unlock ( & dev -> lock , flags ) ;return ret ;",4639
763,out :  kfree ( resp ) ;return res ;,out : kfree ( req ) ;kfree ( resp ) ;return res ;,4640
764,"umode_t mode = inode -> i_mode ;error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error <= 0 ) {acl = NULL ;if ( error < 0 ) return error ;}error = xfs_set_mode ( inode , mode ) ;","umode_t mode ;error = posix_acl_equiv_mode ( acl , & mode , & acl ) ;if ( error ) return error ;}error = xfs_set_mode ( inode , mode ) ;",4641
765,"RING_IDX cons = vif -> tx . req_cons ;int frags = 0 ;if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ;do {if ( frags >= work_to_do ) {netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\\return - frags ;netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\\return - frags ;","netdev_err ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\\netbk_fatal_tx_err ( vif ) ;return - frags ;netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\\return - frags ;netdev_err ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\\netbk_fatal_tx_err ( vif ) ;return - frags ;",4642
766,"const struct aodv_hello * ah ;switch ( ep -> type ) {if ( length < sizeof ( struct aodv_hello ) )  goto trunc ;ND_PRINT ( ( ndo , ""\\\","const struct aodv_hello * ah ;ND_TCHECK ( * ep ) ;switch ( ep -> type ) {if ( length < sizeof ( struct aodv_hello ) ) goto trunc ;if ( ep -> length < 4 ) {ND_PRINT ( ( ndo , ""\\\break ;}ND_PRINT ( ( ndo , ""\\\",4643
767,"down_write ( & mm -> mmap_sem ) ;vma = find_vma_prev ( mm , start , & prev ) ;","down_write ( & mm -> mmap_sem ) ;if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;vma = find_vma_prev ( mm , start , & prev ) ;",4644
768,},DeleteCriticalSection ( & reference_queue_mutex ) ;},4645
769,"char * ksep , * vsep , * val ;size_t klen , vlen ;vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {return 0 ;","char * start , * ksep , * vsep , * val ;size_t klen , vlen ;start = var -> ptr + var -> already_scanned ;vsep = memchr ( start , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {var -> already_scanned = var -> end - var -> ptr ;return 0 ;",4646
770,return 1 ;},var -> already_scanned = 0 ;return 1 ;},4646
771,"strncpy ( szSec , opt_string , sepIdx ) ;szSec [ sepIdx ] = 0 ;sep ++ ;sep2 = strchr ( sep , \'=\' ) ;if ( ! sep2 ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\\{const size_t sepIdx = sep2 - sep ;strncpy ( szKey , sep , sepIdx ) ;szKey [ sepIdx ] = 0 ;strcpy ( szVal , sep2 + 1 ) ;}","if ( sepIdx >= sizeof ( szSec ) ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\\return ;strncpy ( szSec , opt_string , sepIdx ) ;szSec [ sepIdx ] = 0 ;if ( strlen ( sep2 + 1 ) >= sizeof ( szVal ) ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\\strcpy ( szVal , sep2 + 1 ) ;}",4647
772,"out_put :  fput_light ( sock -> file , fput_needed ) ;if ( err == 0 )  return datagrams ;if ( datagrams != 0 ) {return datagrams ;}return err ;}","if ( err == 0 ) goto out_put ;if ( datagrams == 0 ) return datagrams ;if ( datagrams != 0 ) {out_put : fput_light ( sock -> file , fput_needed ) ;return datagrams ;}",4648
773,message -> srcIpAddr = queueItem -> srcIpAddr ;message -> srcPort = queueItem -> srcPort ;,message -> interface = queueItem -> interface ;message -> srcIpAddr = queueItem -> srcIpAddr ;message -> srcPort = queueItem -> srcPort ;,4649
774,"int hns_nic_net_xmit_hw ( struct net_device * ndev ,  struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) {","netdev_tx_t hns_nic_net_xmit_hw ( struct net_device * ndev , struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) {",4650
775,wmb ( ) ;assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ;,netif_trans_update ( ndev ) ;ndev -> stats . tx_bytes += skb -> len ;ndev -> stats . tx_packets ++ ;wmb ( ) ;assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ;,4650
776,"static void  horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % stride ) == 0 ) ;if ( cc > stride ) {","static int horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%stride)!=0"" ) ;return 0 ;}if ( cc > stride ) {",4651
777,},return 1 ;},4651
778,"vma_stop ( priv , vma ) ;if ( priv -> task ) put_task_struct ( priv -> task ) ;","if ( ! IS_ERR ( vma ) ) vma_stop ( priv , vma ) ;if ( priv -> task ) put_task_struct ( priv -> task ) ;",4652
779,"if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_recvv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > 0 )  {","size_t data_size = 0 ;if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_recvv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > ( ssize_t ) ( data_size ) ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}if ( ret > 0 ) {",4653
780,"slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & bind_method ) ;slapi_pblock_get ( pb , SLAPI_OPERATION , & operation ) ;slapi_pblock_get ( pb , SLAPI_CONNECTION , & conn ) ;if ( text ) {pbtext = text ;else {slapi_pblock_get ( pb , SLAPI_PB_RESULT_TEXT , & pbtext ) ;}","slapi_pblock_get ( pb , SLAPI_RESULT_TEXT , & pbtext ) ;",4654
781,if ( jas_init ( ) ) {abort ( ) ;infile = 0 ;verbose = 0 ;,"size_t max_samples ;char optstr [ 32 ] ;if ( jas_init ( ) ) {abort ( ) ;max_samples = 64 * JAS_MEBI ;infile = 0 ;verbose = 0 ;case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ;break ;",4655
782,"case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ;","case OPT_MAXMEM : max_mem = strtoull ( jas_optarg , 0 , 10 ) ;",4655
783,"
","snprintf ( optstr , sizeof ( optstr ) , ""max_samples=%-zu"" , max_samples ) ;",4655
784,"if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {jas_stream_close ( instream ) ;if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\\","if ( ! ( image = jas_image_decode ( instream , fmtid , optstr ) ) ) {jas_stream_close ( instream ) ;if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {jas_eprintf ( ""format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\\return EXIT_FAILURE ;}if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\\",4655
785,"if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {abort ( ) ;}printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\\jas_image_destroy ( image ) ;","printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\\jas_image_destroy ( image ) ;",4655
786,"static void update_state ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx ,  int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const struct segmentation * const seg = & cm -> seg ;const int mis = cm -> mi_stride ;if ( seg -> enabled && output_enabled ) {if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) {mi_addr -> mbmi . segment_id =  vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}else if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) {vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi ,  mi_row , mi_col , bsize , 1 ) ;vp9_init_plane_quantizers ( cpi , x ) ;","static void update_state ( VP9_COMP * cpi , ThreadData * td , PICK_MODE_CONTEXT * ctx , int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ) {RD_COUNTS * const rdc = & td -> rd_counts ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const struct segmentation * const seg = & cm -> seg ;const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ;const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ;const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ;const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ;MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ;int w , h ;const int mis = cm -> mi_stride ;* x -> mbmi_ext = ctx -> mbmi_ext ;if ( seg -> enabled ) {if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) {mi_addr -> mbmi . segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) {vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , mi_row , mi_col , bsize , ctx -> rate , ctx -> dist , x -> skip ) ;",4656
787,"if ( bsize < BLOCK_32X32 ) {if ( bsize < BLOCK_16X16 ) ctx -> tx_rd_diff [ ALLOW_16X16 ] = ctx -> tx_rd_diff [ ALLOW_8X8 ] ;ctx -> tx_rd_diff [ ALLOW_32X32 ] = ctx -> tx_rd_diff [ ALLOW_16X16 ] ;}vpx_memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk ,   sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ;if ( ! output_enabled ) return ;if ( ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) {for ( i = 0 ;i < TX_MODES ;i ++ ) cpi -> rd_tx_select_diff [ i ] += ctx -> tx_rd_diff [ i ] ;}","memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk , sizeof ( ctx -> zcoeff_blk [ 0 ] ) * ctx -> num_4x4_blk ) ;if ( ! output_enabled ) return ;",4656
788,"vp9_update_mv_count ( cm , xd ) ;if ( cm -> interp_filter == SWITCHABLE ) {++ cm -> counts . switchable_interp [ ctx ] [ mbmi -> interp_filter ] ;}cpi -> rd_comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ;cpi -> rd_comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ;cpi -> rd_comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ;for ( i = 0 ;++ i )  cpi -> rd_filter_diff [ i ] += ctx -> best_filter_diff [ i ] ;}}",vp9_update_mv_count ( td ) ;if ( cm -> interp_filter == SWITCHABLE ) {+ cm -> counts . switchable_interp [ ctx ] [ mbmi -> interp_filter ] ;++ td -> counts -> switchable_interp [ ctx ] [ mbmi -> interp_filter ] ;}rdc -> comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ;rdc -> comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ;rdc -> comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ;for ( i = 0 ;+ i )  cpi -> rd_filter_diff [ i ] += ctx -> best_filter_diff [ i ] ;++ i ) rdc -> filter_diff [ i ] += ctx -> best_filter_diff [ i ] ;}for ( h = 0 ;h < y_mis ;++ h ) {MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ;for ( w = 0 ;w < x_mis ;++ w ) {MV_REF * const mv = frame_mv + w ;mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ;mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ;mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ;mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ;}}},4656
789,"int x , y , pos ;Wbmp * wbmp ;if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) {gd_error ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP"" ) ;return ;}pos = 0 ;for ( y = 0 ;y < gdImageSY ( image ) ;y ++ ) {for ( x = 0 ;x < gdImageSX ( image ) ;x ++ ) {if ( gdImageGetPixel ( image , x , y ) == fg ) {wbmp -> bitmap [ pos ] = WBMP_BLACK ;","_gdImageWBMPCtx ( image , x , y ) == fg ) {wbmp -> bitmap [ pos ] = WBMP_BLACK ;",4657
790,"oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ;oidc_debug ( r , ""enter<S2SV_blank>(url=%s)"" , url ) ;","char * error_str = NULL ;char * error_description = NULL ;oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ;oidc_debug ( r , ""enter<S2SV_blank>(url=%s)"" , url ) ;",4658
791,"const char * error_description = NULL ;apr_uri_t uri ;if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) {const char * error_description = apr_psprintf ( r -> pool , ""Logout<S2SV_blank>URL<S2SV_blank>malformed:<S2SV_blank>%s"" , url ) ;oidc_error ( r , ""%s"" , error_description ) ;return oidc_util_html_send_error ( r , c -> error_template ,  ""Malformed<S2SV_blank>URL"" , error_description ,  HTTP_INTERNAL_SERVER_ERROR ) ;return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , error_description , HTTP_INTERNAL_SERVER_ERROR ) ;","if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) {return oidc_util_html_send_error ( r , c -> error_template , ""Malformed<S2SV_blank>URL"" , error_description , HTTP_INTERNAL_SERVER_ERROR ) ;return oidc_util_html_send_error ( r , c -> error_template , error_str , error_description , HTTP_BAD_REQUEST ) ;",4658
792,"uint16 bitspersample , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;","uint16 bitspersample = 1 , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;",4659
793,"int error ;struct pci_emul_dummy * dummy ;error = pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ;assert ( error == 0 ) ;error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) ;assert ( error == 0 ) ;error = pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ;assert ( error == 0 ) ;assert ( error == 0 ) ;return 0 ;","struct pci_emul_dummy * dummy ;return pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ;assert ( error == 0 ) ;error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) || pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ;assert ( error == 0 ) ;assert ( error == 0 ) ;return 0 ;",4660
794,"ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ;if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;return - 1 ;}","ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;",4661
795,"static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags )  {if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {}else if ( ctx -> might_cancel ) {timerfd_remove_cancel ( ctx ) ;}","static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) {spin_lock ( & ctx -> cancel_lock ) ;if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {else {__timerfd_remove_cancel ( ctx ) ;}spin_unlock ( & ctx -> cancel_lock ) ;}",4662
796,"case TUNNEL_PASS : if ( length < 3 )  {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ;}",case TUNNEL_PASS : if ( length < 3 ) goto trunc ;,4663
797,"if ( length < 1 )  {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ;}case EGRESS_VLAN_NAME :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , tok2str ( rfc4675_tagged , ""Unknown<S2SV_blank>tag"" , * data ) , * data ) ) ;for ( i = 0 ;* data && i < length ;i ++ , data ++ )  ND_PRINT ( ( ndo , ""%c"" , ( * data < 32 || * data > 126 ) ? \'.\' : * data ) ) ;","if ( length < 1 ) goto trunc ;case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , tok2str ( rfc4675_tagged , ""Unknown<S2SV_blank>tag"" , * data ) , * data ) ) ;for ( i = 0 ;i < length && * data ;i ++ , data ++ ) ND_PRINT ( ( ndo , ""%c"" , ( * data < 32 || * data > 126 ) ? \'.\' : * data ) ) ;",4663
798,"if ( archive_string_ensure ( as , as -> length + len + 1 ) == NULL ) return ( - 1 ) ;","if ( archive_string_ensure ( as , as -> length + max ( len + 1 ) == NULL ) return ( - 1 ) ;",4664
799,"if ( archive_string_ensure ( as ,  as -> length + len * 2 + 1 ) == NULL )  return ( - 1 ) ;","if ( archive_string_ensure ( as , as -> length + len * 2 , ( size_t ) MB_CUR_MAX ) + 1 ) == NULL ) return ( - 1 ) ;",4664
800,"if ( strlen ( str ) >= sizeof ( lowstr ) )  {return NULL ;}return NULL ;}result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ;if ( ! result ) return NULL ;if ( dtype != DTK_DELTA ) {if ( tm2interval ( tm , fsec , result ) != 0 )  {","if ( strlen ( str ) > MAXDATELEN ) {return NULL ;}free ( result ) ;return NULL ;}if ( tm2interval ( tm , fsec , result ) != 0 ) {errno = PGTYPES_INTVL_BAD_INTERVAL ;return NULL ;}if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) {if ( tm2interval ( tm , fsec , result ) != 0 ) {",4665
801,if ( phy -> port -> num_phys == 0 )  sas_port_delete ( phy -> port ) ;phy -> port = NULL ;,"if ( phy -> port -> num_phys == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list ) ;phy -> port = NULL ;",4666
802,"log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\\continue ;","if ( file -> file_type == FILE_TYPE_GEOMETRY ) {log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\\}else {log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\\}continue ;",4667
803,vpx_scale_rtcd ( ) ;once ( setup_rtcd_internal ) ;,once ( setup_rtcd_internal ) ;,4668
804,"static VALUE from_document ( VALUE klass , VALUE document )  {Data_Get_Struct ( document , xmlDoc , doc ) ;doc = doc -> doc ;if ( has_blank_nodes_p ( DOC_NODE_CACHE ( doc ) ) ) {","static VALUE from_document ( int argc , VALUE * argv , VALUE klass ) {VALUE document ;VALUE parse_options ;int parse_options_int ;int scanned_args = 0 ;scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ;Data_Get_Struct ( document , xmlDoc , doc ) ;doc = doc -> doc ;if ( scanned_args == 1 ) {parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ;}parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) ;if ( has_blank_nodes_p ( DOC_NODE_CACHE ( doc ) ) ) {rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;",4669
805,return rb_schema ;return Qnil ;,return rb_schema ;return Qnil ;,4669
806,usb_unanchor_urb ( urb ) ;break ;,usb_unanchor_urb ( urb ) ;usb_free_urb ( urb ) ;break ;,4670
807,"int fd = accept ( socket -> fd , NULL , NULL ) ;if ( fd == INVALID_FD ) {","int fd = TEMP_FAILURE_RETRY ( accept ( socket -> fd , NULL , NULL ) ) ;if ( fd == INVALID_FD ) {",4671
808,"int perf_event_task_enable ( void )  {struct perf_event * event ;list_for_each_entry ( event , & current -> perf_event_list , owner_entry )   perf_event_for_each_child ( event , perf_event_enable ) ;mutex_unlock ( & current -> perf_event_mutex ) ;","int perf_event_task_enable ( void ) {struct perf_event_context * ctx ;struct perf_event * event ;list_for_each_entry ( event , _perf_event_enable ) ;perf_event_ctx_unlock ( event , ctx ) ;}mutex_unlock ( & current -> perf_event_mutex ) ;",4672
809,"struct desc_struct * desc ;short sel ;if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ;if ( user_64bit_mode ( regs ) ) {unsigned long base ;if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ;else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ;else base = 0 ;return base ;}desc = get_desc ( sel ) ;if ( ! desc )  return - 1L ;return get_desc_base ( desc ) ;}",struct desc_struct desc ;short sel ;desc = get_desc ( sel ) ;if ( ! desc ) return - 1L ;return get_desc_base ( & desc ) ;},4673
810,"if ( ! pflag ) ( void ) umask ( mask ) ;if ( argc != 1 ) {run_err ( ""ambiguous<S2SV_blank>target"" ) ;exit ( 1 ) ;}targ = * argv ;if ( targetshouldbedirectory ) verifydir ( targ ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ;for ( first = 1 ;;first = 0 ) {cp = buf ;if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ;if ( * cp ++ == \'\\\do {if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ;* cp ++ = ch ;}while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != \'\\\* cp = 0 ;if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ;if ( buf [ 0 ] == \'\\\\01\' || buf [ 0 ] == \'\\\\02\' ) {if ( iamremote == 0 ) {( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ;( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ;}if ( buf [ 0 ] == \'\\\\02\' ) exit ( 1 ) ;++ errs ;continue ;}if ( buf [ 0 ] == \'E\' ) {( void ) atomicio ( vwrite , remout , """" , 1 ) ;return ;}if ( ch == \'\\\cp = buf ;if ( * cp == \'T\' ) {setimes ++ ;cp ++ ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;mtime . tv_sec = ull ;mtime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;atime . tv_sec = ull ;atime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'\\\\0\' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;continue ;}if ( * cp != \'C\' && * cp != \'D\' ) {if ( first ) {run_err ( ""%s"" , cp ) ;exit ( 1 ) ;}SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ;}mode = 0 ;for ( ++ cp ;cp < buf + 5 ;cp ++ ) {if ( * cp < \'0\' || * cp > \'7\' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ;mode = ( mode << 3 ) | ( * cp - \'0\' ) ;}if ( ! pflag ) mode &= ~ mask ;if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ;size = ( off_t ) ull ;if ( ( strchr ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;","+ errs ;if ( * cp == \'\\\\0\' || strchr ( cp , ""."" ) == 0 || strcmp ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;",4674
811,"len = netlink_send ( fd , message ) ;syslog ( LOG_ERR , ""netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ;pfd . events = POLLIN ;pfd . revents = 0 ;len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ;if ( len < 0 ) {syslog ( LOG_ERR , ""recv<S2SV_blank>failed;close ( fd ) ;","len = recvfrom ( fd , message ) ;syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) ) ;struct sockaddr * addr_p = ( struct sockaddr * ) & addr ;socklen_t addr_l = sizeof ( addr ) ;pfd . events = POLLIN ;pfd . revents = 0 ;len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ) ;if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recv<S2SV_blank>failed;close ( fd ) ;",4675
812,"gss_buffer_desc client_name , service_name ;OM_uint32 minor_stat ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;OM_uint32 minor_stat ;,4676
813,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",4676
814,int data_len = elt -> length -   sizeof ( struct oz_get_desc_rsp ) + 1 ;u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;,"u16 offs , total_size ;u8 data_len ;if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ;data_len = elt -> length - ( sizeof ( struct oz_get_desc_rsp ) - 1 ) ;offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;",4677
815,"
","case OZ_SET_CONFIG_RSP : {struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_SET_INTERFACE_RSP : {struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_VENDOR_CLASS_RSP : {struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ;}break ;",4677
816,"static struct nfs4_opendata * nfs4_opendata_alloc ( struct path * path ,  struct nfs4_state_owner * sp , int flags ,  const struct iattr * attrs ) {","static struct nfs4_opendata * nfs4_opendata_alloc ( struct path * path , struct nfs4_state_owner * sp , fmode_t fmode , int flags , const struct iattr * attrs ) {",4678
817,"p -> o_arg . open_flags = flags ,  p -> o_arg . clientid = server -> nfs_client -> cl_clientid ;",p -> o_arg . open_flags = flags ;p -> o_arg . fmode = fmode & ( FMODE_READ | FMODE_WRITE ) ;p -> o_arg . clientid = server -> nfs_client -> cl_clientid ;,4678
818,int err = 0 ;if ( ! asoc ) return - EINVAL ;,"int err = 0 ;if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL ;if ( ! asoc ) return - EINVAL ;",4679
819,"struct page * pages [ NFS4ACL_MAXPAGES ] ;struct nfs_getaclargs args = {. fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , }struct nfs_getaclres res = {. acl_len = buflen , };void * resp_buf ;struct rpc_message msg = {. rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , };struct page * localpage = NULL ;int ret ;if ( buflen < PAGE_SIZE ) {localpage = alloc_page ( GFP_KERNEL ) ;resp_buf = page_address ( localpage ) ;if ( localpage == NULL )  return - ENOMEM ;args . acl_pages [ 0 ] = localpage ;args . acl_pgbase = 0 ;args . acl_len = PAGE_SIZE ;else {resp_buf = buf ;buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ;if ( res . acl_len > args . acl_len )   nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ;else  nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ;if ( buf ) {ret = - ERANGE ;if ( res . acl_len > buflen )  goto out_free ;if ( localpage )   memcpy ( buf , resp_buf , res . acl_len ) ;}out_free :  if ( localpage )   __free_page ( localpage ) ;return ret ;","struct page * pages [ NFS4ACL_MAXPAGES ] = {NULL , }int ret = - ENOMEM , npages , i , acl_len = 0 ;npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ;if ( npages == 0 ) npages = 1 ;for ( i = 0 ;i < npages ;i ++ ) {pages [ i ] = alloc_page ( GFP_KERNEL ) ;if ( ! pages [ i ] ) goto out_free ;if ( npages > 1 ) {args . acl_scratch = alloc_page ( GFP_KERNEL ) ;if ( ! args . acl_scratch ) goto out_free ;args . acl_len = npages * PAGE_SIZE ;args . acl_pgbase = 0 ;if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ;resp_buf = page_address ( pages [ 0 ] ) ;dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\\acl_len = res . acl_len - res . acl_data_offset ;if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ;else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ;if ( acl_len > buflen ) goto out_free ;if ( localpage ) memcpy ( buf , resp_buf , res . acl_len ) ;}out_free : for ( i = 0 ;i < npages ;i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ;if ( args . acl_scratch ) __free_page ( args . acl_scratch ) ;return ret ;",4680
820,"struct ip_options * opt ;opt = inet_sk ( sk ) -> opt ;if ( opt == NULL || opt -> cipso == 0 )  return - ENOMSG ;return cipso_v4_getattr ( opt -> __data + opt -> cipso - sizeof ( struct iphdr ) ,  secattr ) ;}","struct ip_options_rcu * opt ;opt = inet_sk ( sk ) -> inet_opt ) ;if ( opt == NULL || opt -> cipso == 0 ) return - ENOMSG ;return cipso_v4_getattr ( opt -> opt . __data + opt -> opt . cipso - sizeof ( struct iphdr ) , secattr ) ;rcu_read_unlock ( ) ;return res ;}",4681
821,"replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ;encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ;encode_nops ( & hdr ) ;}","replen = hdr . replen + op_decode_hdr_maxsz + 1 ;encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ;xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;encode_nops ( & hdr ) ;}",4682
822,"# else  char common_name [ FIELD_SIZE + 1 ] ;if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host ,  FIELD_SIZE ) == 0 )  cert_valid = 1 ;","# else if ( validate_hostname ( tunnel -> config -> gateway_host , FIELD_SIZE ) == 0 ) cert_valid = 1 ;",4683
823,task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ;task -> tk_owner = current -> tgid ;,task -> tk_rebind_retry = 2 ;task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ;task -> tk_owner = current -> tgid ;,4684
824,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |  NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ;if ( ses -> server -> sign ) {flags |= NTLMSSP_NEGOTIATE_SIGN ;}sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ;,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL ;if ( ses -> server -> sign ) flags |= NTLMSSP_NEGOTIATE_SIGN ;sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ;,4685
825,"vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ;bsi . segment_rd = best_rd ;","memset ( & bsi , 0 , sizeof ( bsi ) ) ;bsi . segment_rd = best_rd ;",4686
826,"if ( n < 0 ) {if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ;syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ;goto error ;}if ( n == 0 ) {syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ;goto error ;}t = time ( NULL ) ;type = buf [ 0 ] ;p = buf + 1 ;DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ;","if ( l > ( unsigned ) ( buf + n - p ) ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ;",4687
827,"if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) {syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ;goto error ;}break ;case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ;while ( d && ( nrep < 255 ) ) {if ( d -> t < t ) {syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ;}else {if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ;if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) {m = d -> headers [ HEADER_LOCATION ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ;rp += d -> headers [ HEADER_LOCATION ] . l ;m = d -> headers [ HEADER_NT ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ;rp += d -> headers [ HEADER_NT ] . l ;m = d -> headers [ HEADER_USN ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ;rp += d -> headers [ HEADER_USN ] . l ;nrep ++ ;}}d = d -> next ;}for ( serv = servicelisthead . lh_first ;serv && ( nrep < 255 ) ;serv = serv -> entries . le_next ) {if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ;if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) {m = strlen ( serv -> location ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> location , m ) ;rp += m ;m = strlen ( serv -> st ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> st , m ) ;rp += m ;m = strlen ( serv -> usn ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> usn , m ) ;rp += m ;nrep ++ ;}}rbuf [ 0 ] = nrep ;syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ;if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) {syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ;goto error ;}break ;case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ;if ( ! newserv ) {syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ;goto error ;}memset ( newserv , 0 , sizeof ( struct service ) ) ;if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;goto error ;}newserv -> st = malloc ( l + 1 ) ;if ( ! newserv -> st ) {syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ;goto error ;}memcpy ( newserv -> st , p , l ) ;newserv -> st [ l ] = \'\\\\0\' ;p += l ;if ( p >= buf + n ) {DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( l > ( unsigned ) ( buf + n - p ) ) {DECODELENGTH_CHECKLIMIT ( l , p , buf + n - p ) ) ;if ( p + l > buf + n - p ) ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",4687
828,"if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",4687
829,"if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",4687
830,vhost_net_ubuf_put_and_wait ( oldubufs ) ;mutex_lock ( & vq -> mutex ) ;,vhost_net_ubuf_put_wait_and_free ( oldubufs ) ;mutex_lock ( & vq -> mutex ) ;,4688
831,if ( ubufs )  vhost_net_ubuf_put_and_wait ( ubufs ) ;err_ubufs : fput ( sock -> file ) ;,if ( ubufs ) vhost_net_ubuf_put_wait_and_free ( ubufs ) ;err_ubufs : fput ( sock -> file ) ;,4688
832,}cpi -> zeromv_count = 0 ;vpx_free ( cpi -> gf_active_flags ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;,"memset ( cpi -> gf_active_flags ) ;# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {vp8_denoiser_free ( & cpi -> denoiser ) ;vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ;}# endif cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;",4689
833,"vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;# if CONFIG_MULTITHREAD if ( width < 640 ) cpi -> mt_sync_range = 1 ;","vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;# if CONFIG_MULTITHREAD if ( width < 640 ) cpi -> mt_sync_range = 1 ;",4689
834,},},4689
835,"jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\\return - 1 ;","jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\\return - 1 ;}if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) {jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\\return - 1 ;}if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) {jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\\return - 1 ;",4690
836,"jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data ,  tile -> tcomps [ 2 ] . data ) ;","jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , tile -> tcomps [ 2 ] . data ) ;",4690
837,"outpos +=  sprintf ( outpos , ""\\\}","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",4691
838,"if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) {err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;","if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 || class == CLIENT_TYPE_MASTER ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\\\'master\\\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" ;",4692
839,"if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;","if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;",4692
840,"while ( * end_ptr != \\\'\\\\""\\\' && * end_ptr && ++ len ) if ( * end_ptr ++ == \'\\\\\\\\\' ) end_ptr ++ ;out = ( char * ) cJSON_malloc ( len + 1 ) ;","while ( * end_ptr != \\\'\\\\""\\\' && * end_ptr && ++ len ) {if ( * end_ptr ++ == \'\\\\\\\\\' ) {if ( * end_ptr == \'\\\\0\' ) {return 0 ;}end_ptr ++ ;}}out = ( char * ) cJSON_malloc ( len + 1 ) ;",4693
841,"
",if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;,4694
842,"sk_wait_data ( sk , & timeo , NULL ) ;if ( signal_pending ( current ) ) {","sk_wait_data ( sk , & timeo , NULL ) ;if ( signal_pending ( current ) ) {",4694
843,"bool inode_owner_or_capable ( const struct inode * inode )  {if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ;if ( inode_capable ( inode , CAP_FOWNER ) )  return true ;","bool inode_owner_or_capable ( const struct inode * inode ) {struct user_namespace * ns ;if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ;ns = current_user_ns ( ) ;if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid ) ) return true ;",4695
844,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",4696
845,"static void write_profile ( BITSTREAM_PROFILE profile ,  struct vp9_write_bit_buffer * wb ) {assert ( profile < MAX_PROFILES ) ;vp9_wb_write_bit ( wb , profile & 1 ) ;vp9_wb_write_bit ( wb , profile >> 1 ) ;}","static void write_profile ( BITSTREAM_PROFILE profile , struct vpx_write_bit_buffer * wb ) {assert ( profile < MAX_PROFILES ) ;vp9_wb_write_bit ( wb , 2 , 2 ) ;break ;case PROFILE_2 : vpx_wb_write_literal ( wb , 1 , 2 ) ;break ;case PROFILE_3 : vpx_wb_write_literal ( wb , 6 , 3 ) ;break ;default : assert ( 0 ) ;}}",4697
846,if ( ! unconditional ( & e -> arp ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,4698
847,"struct IGDdatas * datas = ( struct IGDdatas * ) d ;memcpy ( datas -> cureltname , name , l ) ;","struct IGDdatas * datas = ( struct IGDdatas * ) d ;if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1 ;memcpy ( datas -> cureltname , name , l ) ;",4699
848,"if ( PyDict_SetItemString ( d , ""mod"" , ( PyObject * ) mod_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""Module"" , ( PyObject * ) Module_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""Suite"" , ( PyObject * ) Suite_type ) < 0 ) return  NULL ;","if ( PyModule_AddIntMacro ( m , PyCF_TYPE_COMMENTS ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""FunctionType"" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""mod"" , ( PyObject * ) mod_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""Module"" , ( PyObject * ) Module_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""Suite"" , ( PyObject * ) Suite_type ) < 0 ) return NULL ;",4700
849,"if ( PyDict_SetItemString ( d , ""withitem"" , ( PyObject * ) withitem_type ) < 0 )  return NULL ;","if ( PyDict_SetItemString ( d , ""withitem"" , ( PyObject * ) withitem_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""type_ignore"" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""TypeIgnore"" , ( PyObject * ) TypeIgnore_type ) < 0 ) return NULL ;",4700
850,l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;l_mco_size = 5 + l_tcp -> m_nb_mcc_records ;,l_mco_size = 5 + l_tcp -> m_nb_mcc_records ;,4701
851,"opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ;l_current_data += 2 ;","l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ;l_current_data += 2 ;",4701
852,"L3 = emitjump ( J , F , OP_JUMP ) ;}","emit ( J , F , OP_ENDTRY ) ;L3 = emitjump ( J , F , OP_JUMP ) ;}",4702
853,"struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , unsigned int height , unsigned int subsampling_x , unsigned int subsampling_y ,  unsigned int depth ) {struct lookahead_ctx * ctx = NULL ;unsigned int i ;ctx -> max_sz = depth ;i ++ )  if ( vp9_alloc_frame_buffer ( & ctx -> buf [ i ] . img ,  width , height , subsampling_x , subsampling_y ,  VP9_ENC_BORDER_IN_PIXELS ) )  goto bail ;","struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , unsigned int height , unsigned int subsampling_x , unsigned int subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif unsigned int depth ) {struct lookahead_ctx * ctx = NULL ;const int legacy_byte_alignment = 0 ;unsigned int i ;ctx -> max_sz = depth ;i ++ ) if ( vpx_alloc_frame_buffer ( & ctx -> buf [ i ] . img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment ) ) goto bail ;",4703
854,if ( err ) return err ;,if ( err ) {kvfree ( in ) ;return err ;,4704
855,"if ( err )   goto err_cqwq ;cqc = MLX5_ADDR_OF ( create_cq_in , in , cq_context ) ;","}if ( err ) goto err_cqwq ;cqc = MLX5_ADDR_OF ( create_cq_in , in , cq_context ) ;",4704
856,"if ( ! mp -> ports && ! mp -> mglist &&  netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;","if ( ! mp -> ports && ! mp -> mglist && mp -> timer_armed && netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;",4705
857,"static ext4_io_end_t * ext4_init_io_end ( struct inode * inode )  {io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ;if ( io ) {io -> inode = inode ;io -> flag = 0 ;io -> offset = 0 ;io -> size = 0 ;io -> error = 0 ;INIT_WORK ( & io -> work , ext4_end_io_work ) ;","static ext4_io_end_t * ext4_init_io_end ( struct inode * inode , gfp_t flags ) {io = kmalloc ( sizeof ( * io ) , flags ) ;if ( io ) {io -> page = NULL ;INIT_WORK ( & io -> work , ext4_end_io_work ) ;",4706
858,"row += nrow )  {rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ;if ( _TIFFReadEncodedStripAndAllocBuffer ( tif ,  TIFFComputeStrip ( tif , row + img -> row_offset , 0 ) , ( void * * ) ( & buf ) , maxstripsize ,  ( ( row + img -> row_offset ) % rowsperstrip + nrowsub ) * scanline ) == ( tmsize_t ) ( - 1 )  && ( buf == NULL || img -> stoponerr ) ) {","row += nrow ) {uint32 temp ;rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ;temp = ( row + img -> row_offset ) % rowsperstrip + nrowsub ;if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) {TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripContig"" ) ;return 0 ;}if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , TIFFComputeStrip ( tif , row + img -> row_offset , 0 ) , ( void * * ) ( & buf ) , maxstripsize , temp * scanline ) == ( tmsize_t ) ( - 1 ) && ( buf == NULL || img -> stoponerr ) ) {",4707
859,passert ( GLOBALS_ARE_RESET ( ) ) ;},},4708
860,"int copied , error = - EINVAL ;msg -> msg_namelen = 0 ;","int copied , error = - EINVAL ;",4709
861,if ( count >= 4 ) {int retTIFFReadRawTile ;,if ( count > 4 ) {int retTIFFReadRawTile ;,4710
862,const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ;const int ph = 4 * num_4x4_blocks_high_lookup [ bsize ] ;,const VP9_COMMON * const cm = & cpi -> common ;const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ;const int ph = 4 * num_4x4_blocks_high_lookup [ bsize ] ;,4711
863,"uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ;const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ;struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ;struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ;int last_besterr [ 2 ] = {for ( ref = 0 ;ref_mv [ ref ] = mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] ;if ( scaled_ref_frame [ ref ] ) {","const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ;struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ;struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ;int last_besterr [ 2 ] = {# if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ;uint8_t * second_pred ;# else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ;# endif for ( ref = 0 ;ref_mv [ ref ] = x -> mbmi_ext -> ref_mvs [ refs [ ref ] ] [ 0 ] ;if ( scaled_ref_frame [ ref ] ) {",4711
864,for ( ite = 0 ;struct buf_2d ref_yv12 [ 2 ] ;int_mv tmp_mv ;int search_range = 3 ;,"# if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ;# else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ;# endif for ( ite = 0 ;struct buf_2d ref_yv12 [ 2 ] ;MV tmp_mv ;int search_range = 3 ;",4711
865,"vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf ,  ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv ,  & xd -> block_refs [ ! id ] -> sf ,  pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ;if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = ref_yv12 [ id ] ;tmp_mv . as_int = frame_mv [ refs [ id ] ] . as_int ;tmp_mv . as_mv . col >>= 3 ;tmp_mv . as_mv . row >>= 3 ;bestsme = vp9_refining_search_8p_c ( x , & tmp_mv . as_mv , sadpb ,  search_range , & cpi -> fn_ptr [ bsize ] , x -> nmvjointcost , x -> mvcost , & ref_mv [ id ] . as_mv , second_pred , pw , ph ) ;if ( bestsme < INT_MAX )  bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv ,  second_pred , & cpi -> fn_ptr [ bsize ] , 1 ) ;","# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ;vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ;}# else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ;# endif if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = ref_yv12 [ id ] ;tmp_mv = frame_mv [ refs [ id ] ] . as_mv ;tmp_mv . col >>= 3 ;tmp_mv . as_mv . row >>= 3 ;bestsme = vp9_refining_search_8p_c ( x , & tmp_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] . as_mv , second_pred ) ;if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv , second_pred , & cpi -> fn_ptr [ bsize ] , 1 ) ;",4711
866,"bestsme = cpi -> find_fractional_mv_step_comp (   x , & tmp_mv . as_mv ,   & ref_mv [ id ] . as_mv ,  cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] ,  0 , cpi -> sf . subpel_iters_per_step ,  x -> nmvjointcost , x -> mvcost , & dis , & sse , second_pred , pw , ph ) ;if ( id )  xd -> plane [ 0 ] . pre [ 0 ] = scaled_first_yv12 ;if ( bestsme < last_besterr [ id ] ) {frame_mv [ refs [ id ] ] . as_int = tmp_mv . as_int ;last_besterr [ id ] = bestsme ;","bestsme = cpi -> find_fractional_mv_step_comp ( x , & tmp_mv , & ref_mv [ id ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , 0 , cpi -> sf . mv . subpel_iters_per_step , NULL , x -> nmvjointcost , x -> mvcost , & dis , & sse , second_pred , pw , ph ) ;if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = ref_yv12 [ 0 ] ;if ( bestsme < last_besterr [ id ] ) {frame_mv [ refs [ id ] ] . as_mv = tmp_mv ;last_besterr [ id ] = bestsme ;",4711
867,"* rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ ref ] ] . as_mv ,  & mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv ,  x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;vpx_free ( second_pred ) ;}","* rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ ref ] ] . as_mv , & x -> mbmi_ext -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;}",4711
868,"if ( ( tot_len - offset - 4 ) < bodyLength ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;","if ( ( ( tot_len - offset - 4 ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;",4712
869,v -> sum_error = s ;v -> count = c ;if ( c > 0 )  v -> variance = ( int ) ( 256 * ( v -> sum_square_error - v -> sum_error * v -> sum_error / v -> count ) / v -> count ) ;else v -> variance = 0 ;,v -> log2_count = c ;,4713
870,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",4714
871,"if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) {","if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , p_total_data_size , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) {",4714
872,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",4714
873,"void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name )  {","static void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) {",4715
874,dst [ dst_byte_offset ] = 0 ;current_bit_offset = 0 ;,current_bit_offset = 0 ;,4716
875,"ret = copy_to_user ( uattr , attr , usize ) ;if ( ret ) return - EFAULT ;","ret = copy_to_user ( uattr , attr , attr -> size ) ;if ( ret ) return - EFAULT ;",4717
876,ulong tmp ;assert ( ( ! sgnd && prec >= 1 ) || ( sgnd && prec >= 2 ) ) ;,jas_ulong tmp ;assert ( ( ! sgnd && prec >= 1 ) || ( sgnd && prec >= 2 ) ) ;,4718
877,"assert ( ops != NULL ) ;pr_notice ( ""pci<S2SV_blank>init<S2SV_blank>%s\\\\r\\\","if ( ! ops ) {pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\\continue ;}pr_notice ( ""pci<S2SV_blank>init<S2SV_blank>%s\\\\r\\\",4719
878,"assert ( error == 0 ) ;bzero ( & mr , sizeof ( struct mem_range ) ) ;assert ( error == 0 ) ;bzero ( & mr , sizeof ( struct mem_range ) ) ;assert ( error == 0 ) ;return 0 ;","if ( error != 0 ) goto pci_emul_init_fail ;bzero ( & mr , sizeof ( struct mem_range ) ) ;if ( error != 0 ) goto pci_emul_init_fail ;bzero ( & mr , sizeof ( struct mem_range ) ) ;if ( error != 0 ) goto pci_emul_init_fail ;return 0 ;",4719
879,"assert ( ops != NULL ) ;pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ;","if ( ! ops ) {pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\\continue ;}pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ;",4719
880,"BN_ULONG t1 , t2 ;BN_ULONG c1 , c2 , c3 ;","BN_ULONG c1 , c2 , c3 ;",4720
881,"for ( j = 0 ;j ++ )   av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ;av_log ( s , AV_LOG_DEBUG , ""\\\'\\\","for ( j = 0 ;j ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ;}av_log ( s , AV_LOG_DEBUG , ""\\\'\\\",4721
882,"
","if ( strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ;",4722
883,if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) )  goto error ;,if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) goto error ;,4722
884,"unsigned char * const seg_map = cpi -> segmentation_map ;const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ;if ( ! apply_cyclic_refresh || ( cm -> frame_type == KEY_FRAME ) ||  ( cpi -> svc . temporal_layer_id > 0 ) ) {vpx_memset ( seg_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;if ( cm -> frame_type == KEY_FRAME )   cr -> sb_index = 0 ;return ;int i , block_count , bl_index , sb_rows , sb_cols , sbs_in_frame ;int xmis , ymis , x , y , qindex2 ;const float rate_ratio_qdelta = 2.0 ;vp9_clear_system_state ( ) ;","const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ;if ( cm -> current_video_frame == 0 ) cr -> low_content_avg = 0.0 ;if ( ! apply_cyclic_refresh || ( cm -> frame_type == KEY_FRAME ) || ( cpi -> svc . temporal_layer_id > 0 ) || ( cpi -> svc . spatial_layer_id > 0 ) ) {unsigned char * const seg_map = cpi -> segmentation_map ;memset ( seg_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;if ( cm -> frame_type == KEY_FRAME ) {memset ( cr -> last_coded_q_map , MAXQ , cm -> mi_rows * cm -> mi_cols * sizeof ( * cr -> last_coded_q_map ) ) ;cr -> sb_index = 0 ;}return ;int qindex2 ;const float rate_ratio_qdelta = 2.0 ;vp9_clear_system_state ( ) ;",4723
885,"vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ;vp9_enable_segfeature ( seg , 1 , SEG_LVL_ALT_Q ) ;qindex_delta = vp9_compute_qdelta_by_rate ( rc , cm -> frame_type , cm -> base_qindex , rate_ratio_qdelta ) ;if ( - qindex_delta > cr -> max_qdelta_perc * cm -> base_qindex / 100 ) qindex_delta = - cr -> max_qdelta_perc * cm -> base_qindex / 100 ;qindex2 = clamp ( cm -> base_qindex + cm -> y_dc_delta_q + qindex_delta , 0 , MAXQ ) ;cr -> rdmult = vp9_compute_rd_mult ( cpi , qindex2 ) ;vp9_set_segdata ( seg , 1 , SEG_LVL_ALT_Q , qindex_delta ) ;sb_cols = ( cm -> mi_cols + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ;sb_rows = ( cm -> mi_rows + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ;","vp9_disable_segfeature ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q , qindex_delta ) ;sb_cols = ( cm -> mi_cols + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ;sb_rows = ( cm -> mi_rows + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ;",4723
886,"bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ;}","bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPU_ID ) ;}",4724
887,"( void ) SeekBlob ( image , 0 , SEEK_SET ) ;while ( EOFBlob ( image ) != MagickFalse ) {","quantum_info = ( QuantumInfo * ) NULL ;( void ) SeekBlob ( image , 0 , SEEK_SET ) ;while ( EOFBlob ( image ) != MagickFalse ) {",4725
888,"status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;","if ( quantum_info != ( QuantumInfo * ) NULL ) status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;",4725
889,"quantum_info = DestroyQuantumInfo ( quantum_info ) ;rotate_image = RotateImage ( image , 90.0 , exception ) ;","quantum_info = DestroyQuantumInfo ( quantum_info ) ;rotate_image = RotateImage ( image , 90.0 , exception ) ;",4725
890,interface = intf -> cur_altsetting ;endpoint = & interface -> endpoint [ 0 ] . desc ;,interface = intf -> cur_altsetting ;if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL ;endpoint = & interface -> endpoint [ 0 ] . desc ;,4726
891,"register u_int length = h -> len ;register u_int caplen = h -> caplen ;if ( caplen < CHDLC_HDRLEN ) {ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ;return ( caplen ) ;return ( chdlc_print ( ndo , p , length ) ) ;}","return chdlc_print ( ndo , p , length ) ) ;",4727
892,if ( ! ( block = nlmsvc_find_block ( cookie ) ) ) return ;if ( block ) {if ( status == nlm_lck_denied_grace_period ) {}nlmsvc_release_block ( block ) ;,if ( status == nlm_lck_denied_grace_period ) {}nlmsvc_release_block ( block ) ;,4728
893,"case 1 :  hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset ,  fd . entrylength ) ;","case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) {err = - EIO ;goto out ;}if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) {err = - EIO ;goto out ;}hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , fd . entrylength ) ;",4729
894,"hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset ,  fd . entrylength ) ;","hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , fd . entrylength ) ;",4729
895,dec -> xstart = siz -> xoff ;dec -> ystart = siz -> yoff ;,size_t size ;dec -> xstart = siz -> xoff ;dec -> ystart = siz -> yoff ;,4730
896,"dec -> numtiles = dec -> numhtiles * dec -> numvtiles ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;for ( tileno = 0 , tile = dec -> tiles ;++ tileno ,  ++ tile ) {","if ( ! jas_safe_size_mul ( dec -> numhtiles * dec -> numvtiles ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;dec -> numtiles = size ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\\if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) {return - 1 ;}for ( tileno = 0 , tile = dec -> tiles ;+ tileno ,  ++ tile ) {++ tileno , ++ tile ) {",4730
897,tfrc . tfrctx_x = hc -> tx_x ;tfrc . tfrctx_x_recv = hc -> tx_x_recv ;,"memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;tfrc . tfrctx_x = hc -> tx_x ;tfrc . tfrctx_x_recv = hc -> tx_x_recv ;",4731
898,"assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ;memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ;","memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ;",4732
899,"if ( jp2_getuint16 ( in , & pclr -> numlutents ) ||  jp2_getuint8 ( in , & pclr -> numchans ) ) {","pclr -> bpc = 0 ;if ( jp2_getuint16 ( in , & pclr -> numlutents ) || jp2_getuint8 ( in , & pclr -> numchans ) ) {",4733
900,"if ( item_num > 65536 ) {av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\","if ( item_num > 65536 || item_num < 0 ) {av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\",4734
901,"char buf [ L_BUF_SIZE ] ;char * cmdname ;# ifndef _WIN32  snprintf ( buf , L_BUF_SIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ;# else  snprintf ( buf , L_BUF_SIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ;# endif # ifndef OS_IOS ignore = system ( buf ) ;","char buf [ L_BUFSIZE ] ;char * cmdname ;# ifndef _WIN32 snprintf ( buf , L_BUFSIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ;# else snprintf ( buf , L_BUFSIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ;# endif # ifndef OS_IOS ignore = system ( buf ) ;",4735
902,"dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\\","dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\\",4736
903,"int  run_cmd ( int fd , ... )  {","int run_cmd ( int fd , const char * cmd , const char * args_extra ) {",4737
904,"char cmd [ 512 ] ;term_remove ( STI ) ;dup2 ( fd , STI ) ;dup2 ( fd , STO ) ;{char * c , * ce ;const char * s ;int n ;va_list vls ;strcpy ( cmd , EXEC ) ;c = & cmd [ sizeof ( EXEC ) - 1 ] ;","int argc ;char * argv [ RUNCMD_ARGS_MAX + 1 ] ;int r ;term_remove ( STI ) ;argc = 0 ;r = split_quoted ( cmd , EXEC ) ;c = & cmd [ sizeof ( EXEC ) - 1 ] ;",4737
905,"fd_printf ( STDERR_FILENO , ""%s\\\establish_child_signal_handlers ( ) ;sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ;execl ( ""/bin/sh"" , ""sh"" , ""-c"" , cmd , NULL ) ;exit ( 42 ) ;}","fd_printf ( STDERR_FILENO , ""exec:<S2SV_blank>%s\\\exit ( 42 ) ;}",4737
906,err :  aio_free_ring ( ctx ) ;free_percpu ( ctx -> cpu ) ;,err : free_percpu ( ctx -> cpu ) ;,4738
907,"if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) {return - 1 ;","if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) {jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\return - 1 ;}if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) {return - 1 ;",4739
908,"char * driver_override , * old = pdev -> driver_override , * cp ;if ( count > PATH_MAX ) return - EINVAL ;if ( strlen ( driver_override ) ) {pdev -> driver_override = driver_override ;kfree ( old ) ;return count ;","char * driver_override , * old , * cp ;if ( count > PATH_MAX ) return - EINVAL ;device_lock ( dev ) ;old = pdev -> driver_override ;if ( strlen ( driver_override ) ) {pdev -> driver_override = driver_override ;device_unlock ( dev ) ;kfree ( old ) ;return count ;",4740
909,"if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK )  save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;gtk_widget_destroy ( textview ) ;","if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK ) {save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;}gtk_widget_destroy ( textview ) ;",4741
910,"# endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn ,  root_storage -> d_storage_uuid ) ) < 0 )  expn = ""Can\\\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ;","# endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn , root_storage ) ) < 0 ) expn = ""Can\\\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ;",4742
911,"err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 ,  & msg -> addrto , & msg -> ifindex ) ;if ( err ) {err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message"" ) ;goto free_msg ;}dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" ,   str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ;if ( len < sizeof ( * msg -> icmp6_hdr ) ) {","err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 , & msg -> addrto , & msg -> ifindex , & msg -> hoplimit ) ;if ( err ) {err ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" , str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ;if ( len < sizeof ( * msg -> icmp6_hdr ) ) {",4743
912,"int i ;int ret ;ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ;if ( ! pci_is_enabled ( dev ) ) return ret ;if ( dev -> resource [ i ] . flags & IORESOURCE_IO )  * value |= PCI_COMMAND_IO ;if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ;}","int ret = pci_read_config_word ( dev , offset , value , data ) ;if ( ! pci_is_enabled ( dev ) ) return ret ;if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) * value |= cmd -> val & ~ PCI_COMMAND_GUEST ;",4744
913,"static MB_PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) {return ( MB_PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ;}","static PREDICTION_MODE read_intra_mode ( vpx_reader * r , const vp9_prob * p ) {return ( PREDICTION_MODE ) vpx_read_tree ( r , vp9_intra_mode_tree , p ) ;}",4745
914,struct mlx5_ib_create_qp_resp resp ;struct mlx5_ib_cq * send_cq ;,struct mlx5_ib_create_qp_resp resp = {};struct mlx5_ib_cq * send_cq ;,4746
915,"vpx_memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ;vpx_memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ;vpx_memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ;}","memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ;memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ;memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ;}",4747
916,"hlist_add_head ( & mp -> mglist , & br -> mglist ) ;mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ;","if ( hlist_unhashed ( & mp -> mglist ) ) hlist_add_head ( & mp -> mglist , & br -> mglist ) ;mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ;",4748
917,"if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) {s -> width = s -> height = 0 ;","if ( ( ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ) < 0 ) {s -> width = s -> height = 0 ;",4749
918,"DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\","if ( NULL == filegen ) {msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ;continue ;}DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\",4750
919,filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;,"if ( NULL == filegen ) {msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\\\'%s\\\'<S2SV_blank>unrecognized"" , filegen_file ) ;continue ;}filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;",4750
920,"if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) {pte_unmap_unlock ( ptep , ptl ) ;","if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) {pte_unmap_unlock ( ptep , ptl ) ;",4751
921,kfree ( ubufs ) ;},},4752
922,"static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd ,  int mi_row , int mi_col , vp9_reader * r ) {struct segmentation * const seg = & cm -> seg ;const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;if ( ! seg -> update_map )   return 0 ;segment_id = read_segment_id ( r , seg ) ;set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;return segment_id ;","static int read_intra_segment_id ( VP9_COMMON * const cm , int mi_offset , int x_mis , int y_mis , vpx_reader * r ) {struct segmentation * const seg = & cm -> seg ;if ( ! seg -> update_map ) {copy_segment_id ( cm , mi_offset , x_mis , y_mis , segment_id ) ;return segment_id ;",4753
923,"static int  ext2_xattr_cache_insert ( struct buffer_head * bh )  {struct mb_cache_entry * ce ;int error ;ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ;if ( ! ce ) return - ENOMEM ;error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {}else {ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash ,  atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ;mb_cache_entry_release ( ce ) ;","static int ext2_xattr_cache_insert ( struct mb2_cache * cache , struct buffer_head * bh ) {int error ;ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ;if ( ! ce ) return - ENOMEM ;error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {else ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash ) ;",4754
924,"# define COPY_PORT ( dest , src ) do {","if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) {dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\\return - ENODEV ;}# define COPY_PORT ( dest , src ) do {",4755
925,"swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ;","swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ;",4755
926,"VP9_COMMON * const cm = & pbi -> common ;int i ;vp9_remove_common ( cm ) ;vp9_worker_end ( & pbi -> lf_worker ) ;vpx_free ( pbi -> lf_worker . data1 ) ;for ( i = 0 ;VP9Worker * const worker = & pbi -> tile_workers [ i ] ;vp9_worker_end ( worker ) ;vpx_free ( worker -> data1 ) ;vpx_free ( worker -> data2 ) ;}if ( pbi -> num_tile_workers ) {const int sb_rows = mi_cols_aligned_to_sb ( cm -> mi_rows ) >> MI_BLOCK_SIZE_LOG2 ;vp9_loop_filter_dealloc ( & pbi -> lf_row_sync , sb_rows ) ;}","int i ;vp9_remove_common ( cm ) ;vp9_worker_end ( & pbi -> lf_worker ) ;vpx_free ( pbi -> lf_worker . data1 ) ;vpx_free ( pbi -> tile_data ) ;for ( i = 0 ;VPxWorker * const worker = & pbi -> tile_workers [ i ] ;vpx_get_worker_interface ( ) -> end ( worker ) ;}vpx_free ( pbi -> tile_worker_data ) ;vpx_free ( worker -> data2 ) ;}if ( pbi -> num_tile_workers > 0 ) {vp9_loop_filter_dealloc ( & pbi -> lf_row_sync , sb_rows ) ;}",4756
927,"char * fpath = NULL , * cgdir = NULL , * controller ;const char * cgroup ;","char * fpath = NULL , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;",4757
928,"fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\\if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;return ret ;}","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , & next ) ) {if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;goto out ;}if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ;else ret = - ENOENT ;if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) {ret = - EACCES ;goto out ;}if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;free ( next ) ;return ret ;}",4757
929,"if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint ,  jas_image_numcmpts ( dec -> image ) ) ) {","if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) {",4758
930,"for ( i = 1 ;i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ;if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) {","for ( i = 1 ;i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) {",4758
931,"if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts (  dec -> image ) ) ) {for ( i = 0 ;i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ;++ i ) {","if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) {+ i ) {for ( i = 0 ;i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;++ i ) {",4758
932,"dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans :  JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ;if ( dec -> cmap ) {if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint ,  jas_image_numcmpts ( dec -> image ) ) ) {","dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;if ( dec -> cmap ) {if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) {",4758
933,"for ( i = 0 ;i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ;jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ;","for ( i = 0 ;i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ;",4758
934,"return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb ,  jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ;","return ( tsfb -> numlvls > 0 && jas_seq2d_size ( a ) ) ? jpc_tsfb_synthesize2 ( tsfb , jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ;",4759
935,spin_lock_init ( & port -> phy_list_lock ) ;INIT_LIST_HEAD ( & port -> phy_list ) ;,INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;spin_lock_init ( & port -> phy_list_lock ) ;INIT_LIST_HEAD ( & port -> phy_list ) ;,4760
936,if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA )  ret = - EADDRNOTAVAIL ;,if ( ret || ! cm_id -> device || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) ret = - EADDRNOTAVAIL ;,4761
937,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;if ( dh == NULL ) {","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;if ( dh == NULL ) {",4762
938,"lua_pushvalue ( L , i ) ;mp_encode_lua_type ( L , buf , 0 ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ;lua_pushvalue ( L , i ) ;mp_encode_lua_type ( L , buf , 0 ) ;",4763
939,if ( pmd_none_or_clear_bad ( pmd ) )  continue ;,if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) continue ;,4764
940,"r = vapic_enter ( vcpu ) ;if ( r ) {srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;return r ;}kvm_vcpu_block ( vcpu ) ;vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ;if ( kvm_check_request ( KVM_REQ_UNHALT , vcpu ) ) {kvm_apic_accept_events ( vcpu ) ;switch ( vcpu -> arch . mp_state ) {case KVM_MP_STATE_HALTED : vcpu -> arch . pv . pv_unhalted = false ;vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ;case KVM_MP_STATE_RUNNABLE : vcpu -> arch . apf . halted = false ;break ;case KVM_MP_STATE_INIT_RECEIVED : break ;default : r = - EINTR ;break ;}}}if ( r <= 0 ) break ;clear_bit ( KVM_REQ_PENDING_TIMER , & vcpu -> requests ) ;if ( kvm_cpu_has_pending_timer ( vcpu ) ) kvm_inject_pending_timer_irqs ( vcpu ) ;if ( dm_request_for_irq_injection ( vcpu ) ) {r = - EINTR ;vcpu -> run -> exit_reason = KVM_EXIT_INTR ;++ vcpu -> stat . request_irq_exits ;}kvm_check_async_pf_completion ( vcpu ) ;if ( signal_pending ( current ) ) {r = - EINTR ;vcpu -> run -> exit_reason = KVM_EXIT_INTR ;++ vcpu -> stat . signal_exits ;}if ( need_resched ( ) ) {srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;kvm_resched ( vcpu ) ;vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ;}}srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;vapic_exit ( vcpu ) ;return r ;",+ vcpu -> stat . request_irq_exits ;+ vcpu -> stat . signal_exits ;return r ;,4765
941,"guint pkt_len ;int pktnum , hr , min , sec , csec ;","int pkt_len , pktnum , hr , min , sec , csec ;",4766
942,"num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {* err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\\\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ;return FALSE ;","num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {* err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\\\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ;return FALSE ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;",4766
943,struct llc_pktinfo info ;info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ;,"struct llc_pktinfo info ;memset ( & info , 0 , sizeof ( info ) ) ;info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ;",4767
944,"unsigned int len ;unsigned long start = 0 , off ;struct au1200fb_device * fbdev = info -> par ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {",struct au1200fb_device * fbdev = info -> par ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {,4768
945,"return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;","return vm_iomap_memory ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;",4768
946,"rpc_delay ( task , 3 * HZ ) ;goto retry_timeout ;","if ( task -> tk_rebind_retry == 0 ) break ;task -> tk_rebind_retry -- ;rpc_delay ( task , 3 * HZ ) ;goto retry_timeout ;",4769
947,"__mincore_unmapped_range ( addr , end , vma , vec ) ;goto out ;if ( pte_none ( pte ) )  __mincore_unmapped_range ( addr , addr + PAGE_SIZE ,  vma , vec ) ;if ( non_swap_entry ( entry ) ) {* vec = 1 ;}else {# ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ;# else WARN_ON ( 1 ) ;* vec = 1 ;# endif }","memset ( vec , 1 , nr ) ;goto out ;if ( pte_none ( pte ) ) * vec = 0 ;* vec = ! ! non_swap_entry ( entry ) ;",4770
948,}else {,rdp -> nego -> transport -> credssp = NULL ;}else {,4771
949,"if ( memcmp ( ef -> sb -> oem_name , ""EXFAT<S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) != 0 ) {exfat_close ( ef -> dev ) ;free ( ef -> sb ) ;exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ;return - EIO ;}ef -> zero_cluster = malloc ( CLUSTER_SIZE ( * ef -> sb ) ) ;if ( ef -> zero_cluster == NULL ) {exfat_close ( ef -> dev ) ;free ( ef -> sb ) ;exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>zero<S2SV_blank>sector"" ) ;return - ENOMEM ;}if ( ! verify_vbr_checksum ( ef -> dev , ef -> zero_cluster , SECTOR_SIZE ( * ef -> sb ) ) ) {free ( ef -> zero_cluster ) ;exfat_close ( ef -> dev ) ;free ( ef -> sb ) ;return - EIO ;}memset ( ef -> zero_cluster , 0 , CLUSTER_SIZE ( * ef -> sb ) ) ;if ( ef -> sb -> version . major != 1 || ef -> sb -> version . minor != 0 ) {free ( ef -> zero_cluster ) ;exfat_close ( ef -> dev ) ;exfat_error ( ""unsupported<S2SV_blank>exFAT<S2SV_blank>version:<S2SV_blank>%hhu.%hhu"" , ef -> sb -> version . major , ef -> sb -> version . minor ) ;free ( ef -> sb ) ;return - EIO ;}if ( ef -> sb -> fat_count != 1 ) {free ( ef -> zero_cluster ) ;exfat_close ( ef -> dev ) ;exfat_error ( ""unsupported<S2SV_blank>FAT<S2SV_blank>count:<S2SV_blank>%hhu"" , ef -> sb -> fat_count ) ;free ( ef -> sb ) ;return - EIO ;}if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 )  {free ( ef -> zero_cluster ) ;exfat_close ( ef -> dev ) ;exfat_error ( ""too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^%d"" , ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits ) ;free ( ef -> sb ) ;return - EIO ;}","
",4772
950,"exo_job_info_message ( EXO_JOB ( job ) , g_file_info_get_display_name ( info ) ) ;retry_copy : real_target_file = thunar_transfer_job_copy_file ( job , node -> source_file , target_file , & err ) ;","exo_job_info_message ( EXO_JOB ( job ) , ""%s"" , g_file_info_get_display_name ( info ) ) ;retry_copy : real_target_file = thunar_transfer_job_copy_file ( job , node -> source_file , target_file , & err ) ;",4773
951,"
",if ( shm_file == NULL ) {err = - EIDRM ;goto out_unlock0 ;},4774
952,if ( is_file_hugepages ( shm_file ) )  goto out_unlock0 ;,if ( is_file_hugepages ( shm_file ) ) goto out_unlock0 ;,4774
953,dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;dev -> netdev_ops = & macvlan_netdev_ops ;,dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;dev -> netdev_ops = & macvlan_netdev_ops ;,4775
954,}line . clock_type = get_status ( port ) -> clocking ;,"}memset ( & line , 0 , sizeof ( line ) ) ;line . clock_type = get_status ( port ) -> clocking ;",4776
955,if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) &&  ! ( opt_len == 24 && flags & TH_ACK ) )  return 0 ;,if ( ! ( opt_len == 12 && ( flags & TH_SYN ) ) && ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) && ! ( opt_len == 24 && ( flags & TH_ACK ) ) ) return 0 ;,4777
956,if ( packet -> tcp != NULL ) {if ( ( dport == 1521 || sport == 1521 )  && ( ( ( packet -> payload [ 0 ] == 0x07 ) && ( packet -> payload [ 1 ] == 0xff ) && ( packet -> payload [ 2 ] == 0x00 ) )  || ( ( packet -> payload_packet_len >= 232 ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( packet -> payload [ 0 ] == 0x01 ) ) && ( packet -> payload [ 1 ] != 0x00 ) && ( packet -> payload [ 2 ] == 0x00 ) && ( packet -> payload [ 3 ] == 0x00 ) ) ) ) {,if ( packet -> payload_packet_len >= 3 && packet -> tcp != NULL ) {if ( ( dport == 1521 || sport == 1521 ) && ( ( ( packet -> payload [ 0 ] == 0x07 ) && ( packet -> payload [ 1 ] == 0xff ) && ( packet -> payload [ 2 ] == 0x00 ) ) || ( ( packet -> payload_packet_len >= 232 ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( packet -> payload [ 0 ] == 0x01 ) ) && ( packet -> payload [ 1 ] != 0x00 ) && ( packet -> payload [ 2 ] == 0x00 ) && ( packet -> payload [ 3 ] == 0x00 ) ) ) ) {,4778
957,"strcpy ( the_url , url_arg ) ;ext = strrchr ( the_url , \'.\' ) ;","if ( strlen ( url_arg ) >= sizeof ( the_url ) ) {fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\\strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ;the_url [ sizeof ( the_url ) - 1 ] = 0 ;}else {strcpy ( the_url , url_arg ) ;}ext = strrchr ( the_url , \'.\' ) ;",4779
958,"if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ;gf_dm_sess_del ( sess ) ;","if ( ! e ) {strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ;the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;}gf_dm_sess_del ( sess ) ;",4779
959,"strcpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ;gf_term_connect ( term , str ) ;","strncpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ;gf_term_connect ( term , str ) ;",4779
960,"int X509_verify ( X509 * a , EVP_PKEY * r )  {return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;","int X509_verify ( X509 * a , EVP_PKEY * r ) {if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;",4780
961,"int res ;const void * data ;int len ;u_int32_t vendor ;if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) {return ;res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ;if ( res == - 1 ) {add_assoc_long ( return_value , ""attr"" , res ) ;add_assoc_long ( return_value , ""vendor"" , vendor ) ;add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ;return ;","const void * data , * raw ;int len ;u_int32_t vendor ;unsigned char type ;size_t data_len ;if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & raw , & len ) == FAILURE ) {return ;if ( rad_get_vendor_attr ( & vendor , & type , & data , & data_len , raw , len ) == - 1 ) {add_assoc_long ( return_value , ""attr"" , type ) ;add_assoc_long ( return_value , ""vendor"" , vendor ) ;add_assoc_stringl ( return_value , ""data"" , ( char * ) data , data_len , 1 ) ;return ;",4781
962,"sas_unregister_dev ( port , dev ) ;continue ;","sas_unregister_dev ( port , dev ) ;sas_destruct_devices ( port ) ;continue ;",4782
963,"if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;up_write ( & key -> sem ) ;","if ( ret == 0 ) mark_key_instantiated ( key , 0 ) ;up_write ( & key -> sem ) ;",4783
964,"static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,  int64_t * dist , int do_recon , int64_t best_rd ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;int i , pl ;int this_rate , sum_rate = 0 , best_rate = INT_MAX ;int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ;int64_t sum_rd = 0 ;int partition_none_allowed = ! force_horz_split && ! force_vert_split ;int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index != 0 ) {* rate = 0 ;* dist = 0 ;return ;}}assert ( num_8x8_blocks_wide_lookup [ bsize ] ==  num_8x8_blocks_high_lookup [ bsize ] ) ;if ( bsize == BLOCK_16X16 ) {set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ;}else {x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;}if ( cpi -> sf . auto_min_max_partition_size ) {partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&  bsize >= cpi -> sf . min_partition_size ) ;partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&  bsize > cpi -> sf . min_partition_size ) || force_horz_split ) ;partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&  bsize > cpi -> sf . min_partition_size ) || force_vert_split ) ;do_split &= bsize > cpi -> sf . min_partition_size ;}if ( cpi -> sf . use_square_partition_only ) {partition_horz_allowed &= force_horz_split ;partition_vert_allowed &= force_vert_split ;}save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;if ( cpi -> sf . disable_split_var_thresh && partition_none_allowed ) {unsigned int source_variancey ;vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ;source_variancey = get_sby_perpixel_variance ( cpi , x , bsize ) ;if ( source_variancey < cpi -> sf . disable_split_var_thresh ) {do_split = 0 ;if ( source_variancey < cpi -> sf . disable_split_var_thresh / 2 )  do_rect = 0 ;}}if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) do_split = 0 ;if ( partition_none_allowed ) {rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize ,  ctx , best_rd ) ;if ( this_rate != INT_MAX ) {if ( bsize >= BLOCK_8X8 ) {pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;}sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;if ( sum_rd < best_rd ) {int64_t stop_thresh = 4096 ;int64_t stop_thresh_rd ;best_rate = this_rate ;best_dist = this_dist ;best_rd = sum_rd ;if ( bsize >= BLOCK_8X8 )  * ( get_sb_partitioning ( x , bsize ) ) = bsize ;stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {do_split = 0 ;do_rect = 0 ;}}if ( ! x -> in_active_map ) {do_split = 0 ;do_rect = 0 ;}restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * mi_step ;* get_sb_index ( x , subsize ) = i ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize ,   & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd ) {","static void rd_pick_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int * rate , int64_t * dist , int do_recon , int64_t best_rd ) {TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;int i , pl ;RD_COST this_rdc , sum_rdc , best_rdc ;BLOCK_SIZE min_size = x -> min_partition_size ;BLOCK_SIZE max_size = x -> max_partition_size ;# if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ;int none_complexity = 0 ;# endif int partition_none_allowed = ! force_horz_split && ! force_vert_split ;int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ;assert ( num_8x8_blocks_wide_lookup [ bsize ] ) ;vp9_rd_cost_init ( & this_rdc ) ;vp9_rd_cost_init ( & sum_rdc ) ;vp9_rd_cost_reset ( & best_rdc ) ;best_rdc . rdcost = best_rd ;set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize == num_8x8_blocks_high_lookup [ bsize ] ) ;if ( bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ;else {x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) {int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ;if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * mi_step ;* get_sb_index ( x , subsize ) = i ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd ) {",4784
965,"restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;}if ( partition_horz_allowed && do_rect ) {subsize = get_subsize ( bsize , PARTITION_HORZ ) ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed )  get_block_context ( x , subsize ) -> pred_interp_filter =  ctx -> mic . mbmi . interp_filter ;if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) {update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col ,  subsize , 0 ) ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed )  get_block_context ( x , subsize ) -> pred_interp_filter =  ctx -> mic . mbmi . interp_filter ;rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate ,  & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}else {sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}if ( sum_rd < best_rd ) {pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;if ( sum_rd < best_rd ) {best_rd = sum_rd ;best_rate = sum_rate ;best_dist = sum_dist ;* ( get_sb_partitioning ( x , bsize ) ) = subsize ;restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;}if ( partition_vert_allowed && do_rect ) {subsize = get_subsize ( bsize , PARTITION_VERT ) ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed )  get_block_context ( x , subsize ) -> pred_interp_filter =  ctx -> mic . mbmi . interp_filter ;if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) {update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col ,  subsize , 0 ) ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed )  get_block_context ( x , subsize ) -> pred_interp_filter =  ctx -> mic . mbmi . interp_filter ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate ,  & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}sum_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;","restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;}if ( partition_horz_allowed && do_rect ) {subsize = get_subsize ( bsize , PARTITION_HORZ ) ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) {update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , subsize , 0 ) ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;else {sum_rate += this_rate ;sum_dist += this_dist ;if ( sum_rd < best_rd ) {pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ;src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ;}# endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) {int mb_row = mi_row >> 1 ;int mb_col = mi_col >> 1 ;int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ;int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ;int r , c ;for ( r = mb_row ;r < mb_row_end ;r ++ ) {for ( c = mb_col ;c < mb_col_end ;c ++ ) {const int mb_index = r * cm -> mb_cols + c ;MOTION_DIRECTION this_mv ;MOTION_DIRECTION right_mv ;MOTION_DIRECTION bottom_mv ;this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ;if ( c != mb_col_end - 1 ) {right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ;none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ;}if ( r != mb_row_end - 1 ) {bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ;none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ;}}}if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) {partition_none_allowed = 0 ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) {update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , subsize , 0 ) ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}this_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ;",4784
966,"restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;}( void ) best_rd ;* rate = best_rate ;* dist = best_dist ;if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {int output_enabled = ( bsize == BLOCK_64X64 ) ;if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ;encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;}","restore_context ( cpi , td , tile_data , tp , mi_row , mi_col , output_enabled , bsize ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;}",4784
967,"
",cpu = cpumask_first ( mask ) ;,4785
968,"event_data -> snk_config =  sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ;","event_data -> snk_config = sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ;",4785
969,"daddy = malloc ( sizeof ( creator_template ) ) ;memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ;","daddy = safe_calloc ( sizeof ( creator_template ) ) ;memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ;",4786
970,# ifndef _MSC_VER   char fpath [ grub_strlen ( currpath ) + 1 ] ;# else char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ;# endif  char * name = fpath ;,char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ;char * name = fpath ;,4787
971,* currfound = currnode ;return 0 ;,* currfound = currnode ;free ( fpath ) ;return 0 ;,4787
972,"return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ;}if ( grub_errno )   return grub_errno ;break ;return grub_error ( GRUB_ERR_SYMLINK_LOOP ,  ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ;free_node ( oldnode , c ) ;return grub_errno ;","free ( fpath ) ;return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ;}if ( grub_errno ) {free ( fpath ) ;return grub_errno ;}break ;free ( fpath ) ;free ( fpath ) ;return grub_error ( GRUB_ERR_SYMLINK_LOOP , ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ;free ( fpath ) ;free_node ( oldnode , c ) ;return grub_errno ;",4787
973,"return grub_errno ;}return 0 ;}return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ;}","return grub_errno ;}free ( fpath ) ;return 0 ;}free ( fpath ) ;return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ;}",4787
974,int error ;raw_inode = ext4_raw_inode ( iloc ) ;,"unsigned int inode_size = EXT4_INODE_SIZE ( inode -> i_sb ) ;struct ext4_inode_info * ei = EXT4_I ( inode ) ;int error ;if ( ( EXT4_GOOD_OLD_INODE_SIZE + ei -> i_extra_isize > inode_size ) || ( ei -> i_extra_isize & 3 ) ) {EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>extra_isize<S2SV_blank>%u<S2SV_blank>(inode<S2SV_blank>size<S2SV_blank>%u)"" , ei -> i_extra_isize , EXT4_INODE_SIZE ( inode -> i_sb ) ) ;return - EFSCORRUPTED ;}if ( ( new_extra_isize < ei -> i_extra_isize ) || ( new_extra_isize < 4 ) || ( new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE ) ) return - EINVAL ;raw_inode = ext4_raw_inode ( iloc ) ;",4788
975,"if ( track -> timescale > UINT16_MAX ) {if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( ""lpcm"" ) ;","if ( track -> timescale > UINT16_MAX || ! track -> par -> channels ) {if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( ""lpcm"" ) ;",4789
976,"if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}ret = oe_open ( pathname , flags , mode ) ;if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ;goto done ;}case OE_SYS_lseek : {int fd = ( int ) arg1 ;ssize_t off = ( ssize_t ) arg2 ;int whence = ( int ) arg3 ;ret = oe_lseek ( fd , off , whence ) ;goto done ;}case OE_SYS_pread64 : {const int fd = ( int ) arg1 ;void * const buf = ( void * ) arg2 ;const size_t count = ( size_t ) arg3 ;const oe_off_t offset = ( oe_off_t ) arg4 ;ret = oe_pread ( fd , buf , count , offset ) ;goto done ;}case OE_SYS_pwrite64 : {const int fd = ( int ) arg1 ;const void * const buf = ( void * ) arg2 ;const size_t count = ( size_t ) arg3 ;const oe_off_t offset = ( oe_off_t ) arg4 ;ret = oe_pwrite ( fd , buf , count , offset ) ;goto done ;}case OE_SYS_readv : {int fd = ( int ) arg1 ;const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ;int iovcnt = ( int ) arg3 ;ret = oe_readv ( fd , iov , iovcnt ) ;goto done ;}case OE_SYS_writev : {int fd = ( int ) arg1 ;const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ;int iovcnt = ( int ) arg3 ;ret = oe_writev ( fd , iov , iovcnt ) ;goto done ;}case OE_SYS_read : {int fd = ( int ) arg1 ;void * buf = ( void * ) arg2 ;size_t count = ( size_t ) arg3 ;ret = oe_read ( fd , buf , count ) ;goto done ;}case OE_SYS_write : {int fd = ( int ) arg1 ;const void * buf = ( void * ) arg2 ;size_t count = ( size_t ) arg3 ;ret = oe_write ( fd , buf , count ) ;goto done ;}case OE_SYS_close : {int fd = ( int ) arg1 ;ret = oe_close ( fd ) ;goto done ;}case OE_SYS_dup : {int fd = ( int ) arg1 ;ret = oe_dup ( fd ) ;goto done ;}case OE_SYS_flock : {int fd = ( int ) arg1 ;int operation = ( int ) arg2 ;ret = oe_flock ( fd , operation ) ;goto done ;}case OE_SYS_fsync : {const int fd = ( int ) arg1 ;ret = oe_fsync ( fd ) ;goto done ;}case OE_SYS_fdatasync : {const int fd = ( int ) arg1 ;ret = oe_fdatasync ( fd ) ;goto done ;}# if defined ( OE_SYS_dup2 ) case OE_SYS_dup2 : {int oldfd = ( int ) arg1 ;int newfd = ( int ) arg2 ;ret = oe_dup2 ( oldfd , newfd ) ;goto done ;}# endif case OE_SYS_dup3 : {int oldfd = ( int ) arg1 ;int newfd = ( int ) arg2 ;int flags = ( int ) arg3 ;if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_dup2 ( oldfd , newfd ) ;goto done ;}# if defined ( OE_SYS_stat ) case OE_SYS_stat : {const char * pathname = ( const char * ) arg1 ;struct oe_stat_t * buf = ( struct oe_stat_t * ) arg2 ;ret = oe_stat ( pathname , buf ) ;goto done ;}# endif case OE_SYS_newfstatat : {int dirfd = ( int ) arg1 ;const char * pathname = ( const char * ) arg2 ;struct oe_stat_t * buf = ( struct oe_stat_t * ) arg3 ;int flags = ( int ) arg4 ;if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_stat ( pathname , buf ) ;goto done ;}case OE_SYS_fstat : {const int fd = ( int ) arg1 ;struct oe_stat_t * const buf = ( struct oe_stat_t * ) arg2 ;ret = oe_fstat ( fd , buf ) ;goto done ;}# if defined ( OE_SYS_link ) case OE_SYS_link : {const char * oldpath = ( const char * ) arg1 ;const char * newpath = ( const char * ) arg2 ;ret = oe_link ( oldpath , newpath ) ;goto done ;}# endif case OE_SYS_linkat : {int olddirfd = ( int ) arg1 ;const char * oldpath = ( const char * ) arg2 ;int newdirfd = ( int ) arg3 ;const char * newpath = ( const char * ) arg4 ;int flags = ( int ) arg5 ;if ( olddirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( newdirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_link ( oldpath , newpath ) ;goto done ;}# if defined ( OE_SYS_unlink ) case OE_SYS_unlink : {const char * pathname = ( const char * ) arg1 ;ret = oe_unlink ( pathname ) ;goto done ;}# endif case OE_SYS_unlinkat : {int dirfd = ( int ) arg1 ;const char * pathname = ( const char * ) arg2 ;int flags = ( int ) arg3 ;if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != OE_AT_REMOVEDIR && flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}if ( flags == OE_AT_REMOVEDIR ) ret = oe_rmdir ( pathname ) ;else ret = oe_unlink ( pathname ) ;goto done ;}# if defined ( OE_SYS_rename ) case OE_SYS_rename : {const char * oldpath = ( const char * ) arg1 ;const char * newpath = ( const char * ) arg2 ;ret = oe_rename ( oldpath , newpath ) ;goto done ;}# endif case OE_SYS_renameat : {int olddirfd = ( int ) arg1 ;const char * oldpath = ( const char * ) arg2 ;int newdirfd = ( int ) arg3 ;const char * newpath = ( const char * ) arg4 ;int flags = ( int ) arg5 ;if ( olddirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( newdirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_rename ( oldpath , newpath ) ;goto done ;}case OE_SYS_truncate : {const char * path = ( const char * ) arg1 ;ssize_t length = ( ssize_t ) arg2 ;ret = oe_truncate ( path , length ) ;goto done ;}# if defined ( OE_SYS_mkdir ) case OE_SYS_mkdir : {const char * pathname = ( const char * ) arg1 ;uint32_t mode = ( uint32_t ) arg2 ;ret = oe_mkdir ( pathname , mode ) ;goto done ;}# endif case OE_SYS_mkdirat : {int dirfd = ( int ) arg1 ;const char * pathname = ( const char * ) arg2 ;uint32_t mode = ( uint32_t ) arg3 ;if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}ret = oe_mkdir ( pathname , mode ) ;goto done ;}# if defined ( OE_SYS_rmdir ) case OE_SYS_rmdir : {const char * pathname = ( const char * ) arg1 ;ret = oe_rmdir ( pathname ) ;goto done ;}# endif # if defined ( OE_SYS_access ) case OE_SYS_access : {const char * pathname = ( const char * ) arg1 ;int mode = ( int ) arg2 ;ret = oe_access ( pathname , mode ) ;goto done ;}# endif case OE_SYS_faccessat : {int dirfd = ( int ) arg1 ;const char * pathname = ( const char * ) arg2 ;int mode = ( int ) arg3 ;int flags = ( int ) arg4 ;if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_access ( pathname , mode ) ;goto done ;}case OE_SYS_getdents64 : {unsigned int fd = ( unsigned int ) arg1 ;struct oe_dirent * ent = ( struct oe_dirent * ) arg2 ;unsigned int count = ( unsigned int ) arg3 ;ret = oe_getdents64 ( fd , ent , count ) ;goto done ;}case OE_SYS_ioctl : {int fd = ( int ) arg1 ;unsigned long request = ( unsigned long ) arg2 ;long p1 = arg3 ;long p2 = arg4 ;long p3 = arg5 ;long p4 = arg6 ;ret = oe_ioctl ( fd , request , p1 , p2 , p3 , p4 ) ;goto done ;}case OE_SYS_fcntl : {int fd = ( int ) arg1 ;int cmd = ( int ) arg2 ;uint64_t arg = ( uint64_t ) arg3 ;ret = oe_fcntl ( fd , cmd , arg ) ;goto done ;}case OE_SYS_mount : {const char * source = ( const char * ) arg1 ;const char * target = ( const char * ) arg2 ;const char * fstype = ( const char * ) arg3 ;unsigned long flags = ( unsigned long ) arg4 ;void * data = ( void * ) arg5 ;ret = oe_mount ( source , target , fstype , flags , data ) ;goto done ;}case OE_SYS_umount2 : {const char * target = ( const char * ) arg1 ;int flags = ( int ) arg2 ;( void ) flags ;ret = oe_umount ( target ) ;goto done ;}case OE_SYS_getcwd : {char * buf = ( char * ) arg1 ;size_t size = ( size_t ) arg2 ;if ( ! oe_getcwd ( buf , size ) ) {ret = - 1 ;}else {ret = ( long ) size ;}goto done ;}case OE_SYS_chdir : {char * path = ( char * ) arg1 ;ret = oe_chdir ( path ) ;goto done ;}case OE_SYS_socket : {int domain = ( int ) arg1 ;int type = ( int ) arg2 ;int protocol = ( int ) arg3 ;ret = oe_socket ( domain , type , protocol ) ;goto done ;}case OE_SYS_connect : {int sd = ( int ) arg1 ;const struct oe_sockaddr * addr = ( const struct oe_sockaddr * ) arg2 ;",struct oe_sockaddr * addr = ( const struct oe_sockaddr * ) arg2 ;,4790
977,const struct oe_sockaddr * dest_add =   ( const struct oe_sockaddr * ) arg5 ;oe_socklen_t * addrlen = ( oe_socklen_t * ) arg6 ;,const struct oe_sockaddr * dest_add = ( const struct oe_sockaddr * ) arg5 ;oe_socklen_t * addrlen = ( oe_socklen_t * ) arg6 ;,4790
978,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,4791
979,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",4791
980,reset_globals ( ) ;passert ( GLOBALS_ARE_RESET ( ) ) ;},},4792
981,"fail :  ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" ,  __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ;","fail : ext3_msg ( sb , KERN_ERR , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ;",4793
982,sr -> bytes_to_send = finfo . size ;sr -> headers . content_length = finfo . size ;,sr -> fd_is_fdt = MK_FALSE ;sr -> bytes_to_send = finfo . size ;sr -> headers . content_length = finfo . size ;,4794
983,"hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;","hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ;hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;",4795
984,void uwbd_stop ( struct uwb_rc * rc )  {kthread_stop ( rc -> uwbd . task ) ;,void uwbd_stop ( struct uwb_rc * rc ) {if ( rc -> uwbd . task ) kthread_stop ( rc -> uwbd . task ) ;,4796
985,"u64 rem ;nsec = rtc_time ( ) * sgi_clock_period ;sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ;","u32 rem ;nsec = rtc_time ( ) * sgi_clock_period ;sgi_clock_offset . tv_sec = tp -> tv_sec - div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ;",4797
986,"static int check_best_zero_mv ( const VP9_COMP * cpi , const uint8_t mode_context [ MAX_REF_FRAMES ] , int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ,  int disable_inter_mode_mask , int this_mode , int ref_frame ,  int second_ref_frame ) {if ( ! ( disable_inter_mode_mask & ( 1 << INTER_OFFSET ( ZEROMV ) ) ) && ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frame ] . as_int == 0 && ( second_ref_frame == NONE ||  frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) {int rfc = mode_context [ ref_frame ] ;int c1 = cost_mv_ref ( cpi , NEARMV , rfc ) ;if ( this_mode == NEARMV ) {if ( c1 > c3 ) return 0 ;}else if ( this_mode == NEARESTMV ) {if ( c2 > c3 ) return 0 ;}else {assert ( this_mode == ZEROMV ) ;if ( second_ref_frame == NONE ) {if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) ||   ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) )  return 0 ;if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 &&  frame_mv [ NEARESTMV ] [ second_ref_frame ] . as_int == 0 ) ||  ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 &&  frame_mv [ NEARMV ] [ second_ref_frame ] . as_int == 0 ) ) return 0 ;","static int check_best_zero_mv ( const VP9_COMP * cpi , const uint8_t mode_context [ MAX_REF_FRAMES ] , int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) {if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] == NONE || frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) {int rfc = mode_context [ ref_frame ] ;int c1 = cost_mv_ref ( cpi , NEARMV , rfc ) ;if ( ref_frames [ 1 ] == NONE ) {if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) || ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) ) return 0 ;if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ second_ref_frame ] . as_int == 0 ) || ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] ] . as_int == 0 ) ) return 0 ;",4798
987,value = 0 ;if ( bits < 0 ) {if ( msg -> oob ) {if ( bits == 8 ) {,if ( msg -> readcount > msg -> cursize ) {return 0 ;}value = 0 ;if ( bits < 0 ) {if ( msg -> oob ) {if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}if ( bits == 8 ) {,4799
988,nbits = bits & 7 ;for ( i = 0 ;,"nbits = bits & 7 ;if ( msg -> bit , msg -> cursize << 3 + nbits > msg -> cursize << 3 ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}for ( i = 0 ;",4799
989,"Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;value |= ( get << ( i + nbits ) ) ;}","Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;value |= ( get << ( i + nbits ) ) ;if ( msg -> bit > msg -> cursize << 3 ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}}",4799
990,dictionary * iniparser_load ( const char * ininame )  {,"dictionary * iniparser_load ( const char * ininame , load_options options ) {",4800
991,"case LINE_ERROR :  fprintf ( stderr , ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d):\\\fprintf ( stderr , ""-><S2SV_blank>%s\\\errs ++ ;","case LINE_ERROR : if ( options & HIDE_ERRORED_LINE_CONTENT ) {fprintf ( stderr , ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d)\\\}else {fprintf ( stderr , ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d):\\\fprintf ( stderr , ""-><S2SV_blank>%s\\\}errs ++ ;",4800
992,"static void finish_object ( struct object * obj ,  struct strbuf * path , const char * name ,  void * cb_data ) {","static void finish_object ( struct object * obj , const char * name , void * cb_data ) {",4801
993,"
",ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;,4802
994,"ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ;break ;","ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ;break ;",4802
995,"memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ;up -> family = kp -> encap_family ;","memset ( up , 0 , sizeof ( * up ) ) ;memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ;up -> family = kp -> encap_family ;",4803
996,"fprintf ( fp , ""%s=%s\\\}","if ( strchr ( value , \'\\\fprintf ( fp , ""%s=%s\\\}",4804
997,"end = strchr ( * value + 1 , \\\'""\\\' ) ;if ( ! end ) {end ++ ;}","char * p = end = * value + 1 ;while ( * p ) {if ( * p == \'\\\\\\\\\' ) {p ++ ;* end = * p ;}else {* end = * p ;if ( * p == \\\'""\\\' ) break ;}p ++ ;end ++ ;}if ( * end != \\\'""\\\' ) {end = ++ p ;}",4805
998,"static const char * parse_string ( cJSON * item , const char * str )  {const char * ptr = str + 1 ;char * ptr2 ;ep = str ;return 0 ;}while ( * ptr != \\\'\\\\""\\\' && * ptr && ++ len )   if ( * ptr ++ == \'\\\\\\\\\' )   ptr ++ ;if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) )  return 0 ;while ( * ptr != \\\'\\\\""\\\' && * ptr ) {if ( * ptr != \'\\\\\\\\\' ) * ptr2 ++ = * ptr ++ ;","static const char * parse_string ( cJSON * item , const char * str , const char * ptr = str + 1 ;char * ptr2 ;* ep = str ;return 0 ;}while ( * ptr != \\\'\\\\""\\\' && * ptr && ++ len ) if ( * ptr ++ == \'\\\\\\\\\' ) ptr ++ ;if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) ) return 0 ;while ( * end_ptr != \\\'\\\\""\\\' && * ptr ) {if ( * ptr != \'\\\\\\\\\' ) * ptr2 ++ = * ptr ++ ;",4806
999,"case \'u\' :  sscanf ( ptr + 1 , ""%4x"" , & uc ) ;ptr += 4 ;if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 )  break ;if ( uc >= 0xD800 && uc <= 0xDBFF ) {if ( ptr [ 1 ] != \'\\\\\\\\\' || ptr [ 2 ] != \'u\' )  break ;sscanf ( ptr + 3 , ""%4x"" , & uc2 ) ;ptr += 6 ;if ( uc2 < 0xDC00 || uc2 > 0xDFFF )  break ;uc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ;}if ( uc < 0x80 )  len = 1 ;else if ( uc < 0x800 ) len = 2 ;",case \'u\' : uc = parse_hex4 ( ptr + 1 ) ;ptr += 4 ;if ( ptr >= end_ptr ) {* ep = str ;return 0 ;}if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) {* ep = str ;return 0 ;}if ( uc >= 0xD800 && uc <= 0xDBFF ) {if ( ptr + 6 > end_ptr ) {* ep = str ;return 0 ;}if ( ptr [ 1 ] != \'\\\\\\\\\' || ptr [ 2 ] != \'u\' ) {* ep = str ;return 0 ;}uc2 = parse_hex4 ( ptr + 3 ) ;ptr += 6 ;if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) {* ep = str ;return 0 ;}uc = 0x10000 + ( ( ( uc & 0x3FF ) ) << 10 ) | ( uc2 & 0x3FF ) ;}if ( uc < 0x80 ) len = 1 ;else if ( uc < 0x800 ) len = 2 ;,4806
1000,"++ ptr ;}if ( * ptr == \\\'\\\\""\\\' )  ++ ptr ;item -> valuestring = out ;item -> type = cJSON_String ;","+ ptr ;ptr ++ ;}if ( * ptr == \\\'\\\\""\\\' ) ptr ++ ;",4806
1001,"bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",4807
1002,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ;if ( thissad < bestsad ) {",4807
1003,u8 opcode = BPF_OP ( insn -> code ) ;dst_reg = & regs [ dst ] ;,u8 opcode = BPF_OP ( insn -> code ) ;int ret ;dst_reg = & regs [ dst ] ;,4808
1004,case BPF_ADD :  if ( known && ( ptr_reg -> off + smin_val ==  ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) {,"case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\\return ret ;}if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) {",4808
1005,"case BPF_SUB :  if ( dst_reg == off_reg ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\\","case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\\return ret ;}if ( dst_reg == off_reg ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\\",4808
1006,"psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ;sweepgen ( L , g , psurvival , g -> reallyold ) ;","g -> gcstate = GCSswpallgc ;psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ;sweepgen ( L , g , psurvival , g -> reallyold ) ;",4809
1007,static unsigned int stack_maxrandom_size ( void )  {unsigned int max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ;},static unsigned long stack_maxrandom_size ( void ) {unsigned long max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1UL ) & STACK_RND_MASK ) << PAGE_SHIFT ;},4810
1008,"# endif  for ( row = 0 ;vpx_memcpy ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;","# endif # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) {assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ;for ( row = 0 ;memcpy_short_addr ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;",4811
1009,"vpx_memcpy ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;","memcpy_short_addr ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;",4811
1010,"vpx_memcpy ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;}","memcpy_short_addr ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;return ;}else {assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ;}# endif for ( row = 0 ;row < src_ybc -> y_height ;++ row ) {memcpy ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;dst += dst_ybc -> y_stride ;}src = src_ybc -> u_buffer ;dst = dst_ybc -> u_buffer ;for ( row = 0 ;row < src_ybc -> uv_height ;++ row ) {memcpy ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;dst += dst_ybc -> uv_stride ;}src = src_ybc -> v_buffer ;dst = dst_ybc -> v_buffer ;for ( row = 0 ;row < src_ybc -> uv_height ;++ row ) {memcpy ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;dst += dst_ybc -> uv_stride ;}vp8_yv12_extend_frame_borders_c ( dst_ybc ) ;}",4811
1011,s -> chunksize = - 1 ;for ( ;,s -> chunksize = UINT64_MAX ;for ( ;,4812
1012,"static vpx_codec_err_t ctrl_set_roi_map ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {return VPX_CODEC_INVALID_PARAM ;","static vpx_codec_err_t ctrl_set_roi_map ( vpx_codec_alg_priv_t * ctx , va_list args ) {( void ) ctx ;( void ) args ;return VPX_CODEC_INVALID_PARAM ;",4813
1013,while ( lp -> s != NULL ) {if ( lp -> pictype == l2info -> pictype ) {case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ;,"ND_TCHECK ( p [ 0 ] ) ;while ( lp -> s != NULL ) {if ( lp -> pictype == l2info -> pictype ) {case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;l2info -> cookie_type = LS_COOKIE_ID ;",4814
1014,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;,"case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;l2info -> bundle = l2info -> cookie [ 1 ] ;",4814
1015,case LS_COOKIE_ID :  l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,4814
1016,case LS_COOKIE_ID :  l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,4814
1017,"if ( first_mb_in_slice == 0 ) {if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) {field_end ( h , 1 ) ;}h0 -> current_slice = 0 ;if ( ! h0 -> first_field ) {if ( h -> cur_pic_ptr && ! h -> droppable ) {ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ;}h -> cur_pic_ptr = NULL ;}}slice_type = get_ue_golomb_31 ( & h -> gb ) ;if ( slice_type > 9 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\\return AVERROR_INVALIDDATA ;}if ( slice_type > 4 ) {slice_type -= 5 ;h -> slice_type_fixed = 1 ;}else h -> slice_type_fixed = 0 ;slice_type = golomb_to_pict_type [ slice_type ] ;h -> slice_type = slice_type ;h -> slice_type_nos = slice_type & 3 ;h -> pict_type = h -> slice_type ;pps_id = get_ue_golomb ( & h -> gb ) ;if ( pps_id >= MAX_PPS_COUNT ) {av_log ( h -> avctx , AV_LOG_ERROR , ""pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\return AVERROR_INVALIDDATA ;}if ( ! h0 -> pps_buffers [ pps_id ] ) {av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\\return AVERROR_INVALIDDATA ;}h -> pps = * h0 -> pps_buffers [ pps_id ] ;if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) {av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\\return AVERROR_INVALIDDATA ;}if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) {h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ;h -> current_sps_id = h -> pps . sps_id ;h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ;if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ;if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) {h -> bit_depth_luma = h -> sps . bit_depth_luma ;h -> chroma_format_idc = h -> sps . chroma_format_idc ;needs_reinit = 1 ;}if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ;}h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ;h -> avctx -> level = h -> sps . level_idc ;h -> avctx -> refs = h -> sps . ref_frame_count ;must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ;if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ;h -> mb_width = h -> sps . mb_width ;h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ;h -> mb_num = h -> mb_width * h -> mb_height ;h -> mb_stride = h -> mb_width + 1 ;h -> b_stride = h -> mb_width * 4 ;h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ;h -> width = 16 * h -> mb_width ;h -> height = 16 * h -> mb_height ;ret = init_dimensions ( h ) ;if ( ret < 0 ) return ret ;if ( h -> sps . video_signal_type_present_flag ) {h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ;if ( h -> sps . colour_description_present_flag ) {if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ;h -> avctx -> color_primaries = h -> sps . color_primaries ;h -> avctx -> color_trc = h -> sps . color_trc ;h -> avctx -> colorspace = h -> sps . colorspace ;}}if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) {if ( h != h0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>"" ""slice<S2SV_blank>%d\\\return AVERROR_INVALIDDATA ;}flush_change ( h ) ;if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ;h -> avctx -> pix_fmt = ret ;av_log ( h -> avctx , AV_LOG_INFO , ""Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>"" ""pix_fmt:<S2SV_blank>%s\\\if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\\return ret ;}}if ( ! h -> context_initialized ) {if ( h != h0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\\return AVERROR_PATCHWELCOME ;}if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ;h -> avctx -> pix_fmt = ret ;if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\\return ret ;}}if ( h == h0 && h -> dequant_coeff_pps != pps_id ) {h -> dequant_coeff_pps = pps_id ;init_dequant_tables ( h ) ;}h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ;h -> mb_mbaff = 0 ;h -> mb_aff_frame = 0 ;last_pic_structure = h0 -> picture_structure ;last_pic_droppable = h0 -> droppable ;h -> droppable = h -> nal_ref_idc == 0 ;if ( h -> sps . frame_mbs_only_flag ) {h -> picture_structure = PICT_FRAME ;}else {if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) {av_log ( h -> avctx , AV_LOG_ERROR , ""This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\\return - 1 ;}field_pic_flag = get_bits1 ( & h -> gb ) ;if ( field_pic_flag ) {bottom_field_flag = get_bits1 ( & h -> gb ) ;h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ;}else {h -> picture_structure = PICT_FRAME ;h -> mb_aff_frame = h -> sps . mb_aff ;}}h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ;if ( h0 -> current_slice != 0 ) {if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) {av_log ( h -> avctx , AV_LOG_ERROR , ""Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\\h -> picture_structure = last_pic_structure ;h -> droppable = last_pic_droppable ;return AVERROR_INVALIDDATA ;}else if ( ! h0 -> cur_pic_ptr ) {",if ( h0 -> cur_pic_ptr ) {,4815
1018,"if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;","if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;",4815
1019,"case \'l\' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;case \'L\' : {","case \'l\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;}case \'L\' : {",4816
1020,"case \'i\' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;","case \'i\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;}case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;",4816
1021,"static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd ,  int mi_row , int mi_col , vp9_reader * r ) {struct segmentation * const seg = & cm -> seg ;const BLOCK_SIZE bsize = mbmi -> sb_type ;int predicted_segment_id , segment_id ;predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map ,  bsize , mi_row , mi_col ) ;if ( ! seg -> update_map )  return predicted_segment_id ;if ( seg -> temporal_update ) {const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ;mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ;segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ;set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;return segment_id ;","static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vpx_reader * r ) {struct segmentation * const seg = & cm -> seg ;int predicted_segment_id , segment_id ;const int mi_offset = mi_row * cm -> mi_cols + mi_col ;const int bw = xd -> plane [ 0 ] . n4_w >> 1 ;const int bh = xd -> plane [ 0 ] . n4_h >> 1 ;const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ;const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ;predicted_segment_id = cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;if ( ! seg -> update_map ) {copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ;return predicted_segment_id ;}if ( seg -> temporal_update ) {const vpx_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ;mbmi -> seg_id_predicted = vpx_read ( r , pred_prob ) ;segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ;set_segment_id ( cm , mi_offset , x_mis , y_mis , segment_id ) ;return segment_id ;",4817
1022,"int i , len ;size_t len_sent = 0 ;const char __user * p ;char * buf ;p = ( const char __user * ) current -> mm -> arg_start ;audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;if ( ! buf ) {audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ;for ( i = 0 ;i < context -> execve . argc ;i ++ ) {len = audit_log_single_execve_arg ( context , ab , i , & len_sent , p , buf ) ;if ( len <= 0 ) break ;p += len ;kfree ( buf ) ;","long len_max ;long len_rem ;long len_full ;long len_buf ;long len_abuf ;long len_tmp ;bool require_data ;bool encode ;unsigned int iter ;unsigned int arg ;char * buf_head ;char * buf ;const char __user * p = ( const char __user * ) current -> mm -> arg_start ;char abuf [ 96 ] ;WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ;len_max = MAX_EXECVE_AUDIT_LEN ;buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;if ( ! buf_head ) {audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ;buf = buf_head ;audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;len_rem = len_max ;len_buf = 0 ;len_full = 0 ;require_data = true ;encode = false ;iter = 0 ;arg = 0 ;do {if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ;if ( require_data ) {if ( buf != buf_head ) {memmove ( buf_head , buf , len_buf ) ;buf = buf_head ;len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ;if ( len_tmp == - EFAULT ) {send_sig ( SIGKILL , current , 0 ) ;goto out ;}else if ( len_tmp == ( len_max - len_buf ) ) {require_data = true ;encode = true ;len_full = len_full * 2 ;p += len_tmp ;}else {require_data = false ;if ( ! * ab ) goto out ;}len_tmp = 0 ;if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) {if ( iter == 0 ) {len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d_len=%lu"" , arg , len_full ) ;}len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d[%d]="" , arg , iter ++ ) ;}else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d="" , arg ) ;WARN_ON ( len_tmp >= sizeof ( abuf ) ) ;abuf [ sizeof ( abuf ) - 1 ] = \'\\\\0\' ;audit_log_format ( * ab , ""%s"" , abuf ) ;len_rem -= len_tmp ;len_tmp = len_buf ;if ( encode ) {if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ;audit_log_n_hex ( * ab , buf , len_tmp ) ;len_rem -= len_tmp * 2 ;len_abuf -= len_tmp * 2 ;}else {if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ;audit_log_n_string ( * ab , buf , len_tmp ) ;len_rem -= len_tmp + 2 ;len_abuf -= len_tmp ;}len_buf -= len_tmp ;buf += len_tmp ;}if ( ( len_buf == 0 ) && ! require_data ) {arg ++ ;iter = 0 ;len_full = 0 ;require_data = true ;encode = false ;}}while ( arg < context -> execve . argc ) ;out : kfree ( buf_head ) ;",4818
1023,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;exit :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;exit : mutex_unlock ( & dev -> lock , flags ) ;return ret ;",4819
1024,"if ( JAS_CAST ( ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) {jas_eprintf ( ""warning:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>in<S2SV_blank>marker<S2SV_blank>segment<S2SV_blank>(%ld<S2SV_blank>bytes)\\\","if ( JAS_CAST ( jas_ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) {jas_eprintf ( ""warning:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>in<S2SV_blank>marker<S2SV_blank>segment<S2SV_blank>(%ld<S2SV_blank>bytes)\\\",4820
1025,int i ;for ( i = 0 ;,"int i ;account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ;free_uid ( pipe -> user ) ;for ( i = 0 ;",4821
1026,"if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ;if ( executable == NULL ) {error_msg ( ""Can\\\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ;goto create_user_core ;}const char * signame = NULL ;switch ( signal_no ) {case SIGILL : signame = ""ILL"" ;break ;case SIGFPE : signame = ""FPE"" ;break ;case SIGSEGV : signame = ""SEGV"" ;break ;case SIGBUS : signame = ""BUS"" ;break ;case SIGABRT : signame = ""ABRT"" ;break ;case SIGTRAP : signame = ""TRAP"" ;break ;default : goto create_user_core ;}if ( ! daemon_is_ok ( ) ) {log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'core\\\'"" ) ;goto create_user_core ;}if ( g_settings_nMaxCrashReportsSize > 0 ) {if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ;}snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ;if ( check_recent_crash_file ( path , executable ) ) {goto create_user_core ;}const char * last_slash = strrchr ( executable , \'/\' ) ;if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) {snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ;int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) {unlink ( path ) ;error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\\\'%s\\\'"" , path ) ;}log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ;return 0 ;}unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ;if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) {goto create_user_core ;}dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ;if ( dd ) {char * rootdir = get_rootdir ( pid ) ;dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ;char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ;","if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , NULL ) ;char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ;",4822
1027,"double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags )  {GPMF_stream metadata_stream , * ms = & metadata_stream ;uint32_t teststart = 0 ;uint32_t testend = mp4 -> indexcount ;double rate = 0.0 ;if ( mp4 -> indexcount < 1 ) return 0.0 ;if ( mp4 -> indexcount > 3 )  {teststart ++ ;testend -- ;}uint32_t * payload = GetPayload ( handle , NULL , teststart ) ;uint32_t payloadsize = GetPayloadSize ( handle , teststart ) ;int32_t ret = GPMF_Init ( ms , payload , payloadsize ) ;if ( ret != GPMF_OK )  goto cleanup ;uint32_t missing_samples = 0 ;while ( ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) )  {missing_samples = 1 ;payload = GetPayload ( handle , payload , teststart ) ;payloadsize = GetPayloadSize ( handle , teststart ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;}","double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags , double * firstsampletime , double * lastsampletime ) {payload = GetPayload ( handle , NULL , teststart ) ;payloadsize = GetPayloadSize ( handle , teststart ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;if ( ret != GPMF_OK ) goto cleanup ;uint64_t minimumtimestamp = 0 ;uint64_t starttimestamp = 0 ;uint64_t endtimestamp = 0 ;double intercept = 0.0 ;while ( teststart < mp4 -> indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) {payload = GetPayload ( handle , payload , teststart ) ;payloadsize = GetPayloadSize ( handle , teststart ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;}if ( ret == GPMF_OK && payload ) {uint32_t samples = GPMF_PayloadSampleCount ( ms ) ;GPMF_stream find_stream ;GPMF_CopyState ( ms , & find_stream ) ;if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) startsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) - samples ;GPMF_CopyState ( ms , & find_stream ) ;if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) starttimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & find_stream ) ) ;if ( starttimestamp ) {GPMF_stream any_stream ;GPMF_Init ( & any_stream , payload , payloadsize ) ;minimumtimestamp = starttimestamp ;while ( GPMF_OK == GPMF_FindNext ( & any_stream , GPMF_KEY_TIME_STAMP , GPMF_RECURSE_LEVELS ) ) {uint64_t timestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & any_stream ) ) ;if ( timestamp < minimumtimestamp ) minimumtimestamp = timestamp ;}}testend = mp4 -> indexcount ;do {testend -- ;payload = GetPayload ( handle , NULL , teststart ) ;uint32_t payloadsize = GetPayloadSize ( handle , payload , testend ) ;payloadsize = GetPayloadSize ( handle , teststart ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;}",4823
1028,"uint32_t samples = GPMF_Repeat ( ms ) ;GPMF_stream find_stream ;if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) && GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) )  {payload = GetPayload ( handle , payload , testend ) ;payloadsize = GetPayloadSize ( handle , testend ) ;if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) {if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) {endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ;rate = ( double ) ( endsamples - startsamples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ;goto cleanup ;}}rate = ( double ) ( samples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ;}else {uint32_t payloadpos = 0 , payloadcount = 0 ;double slope , top = 0.0 , bot = 0.0 , meanX = 0 , meanY = 0 ;uint32_t * repeatarray = malloc ( mp4 -> indexcount * 4 + 4 ) ;memset ( repeatarray , 0 , mp4 -> indexcount * 4 + 4 ) ;samples = 0 ;for ( payloadpos = teststart ;payloadpos < testend ;payloadcount ++ , payloadpos ++ )  {if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) )  {float in , out ;do {GetPayloadTime ( handle , payloadpos , & in , & out ) ;meanX += out ;uint32_t repeat = GPMF_Repeat ( ms ) ;samples += repeat ;float in , out ;repeatarray [ payloadpos ] = samples ;GetPayloadTime ( handle , payloadpos , & in , & out ) ;meanX += out ;}if ( repeatarray ) {meanY /= ( double ) payloadcount ;meanX /= ( double ) payloadcount ;for ( payloadpos = teststart ;payloadpos < testend ;payloadpos ++ ) {float in , out ;top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] - meanY ) ;bot += ( ( double ) out - meanX ) * ( ( double ) out - meanX ) ;}# if 0   {double intercept ;intercept = meanY - slope * meanX ;printf ( ""%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)\\\}goto cleanup ;}cleanup : if ( payload )  {FreePayload ( payload ) ;}return rate ;","uint32_t samples = GPMF_Repeat ( ms ) ;GPMF_stream find_stream ;if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) && GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) {payload = GetPayload ( handle , testend ) ;if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ;if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ;else {uint32_t i ;for ( i = teststart ;i <= testend ;i ++ ) {if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) {float in , out ;do {GetPayloadTime ( handle , payloadpos , & in , & out ) ;meanX += out ;uint32_t repeat = GPMF_Repeat ( ms ) ;samples += repeat ;double in , out ;repeatarray [ payloadpos ] = samples ;if ( GPMF_OK == GetPayloadTime ( handle , payloadpos , & in , & out ) ) meanX += out ;}if ( repeatarray ) {double in , out ;top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] - meanY ) ;bot += ( ( double ) out - meanX ) * ( ( double ) out - meanX ) ;}# if 0 printf ( ""%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f\\\}if ( firstsampletime && lastsampletime ) {uint32_t endpayload = mp4 -> indexcount ;do {endpayload -- ;payload = GetPayload ( handle , payload , endpayload ) ;payloadsize = GetPayloadSize ( handle , endpayload ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;}while ( endpayload > 0 && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ;if ( endpayload > 0 && ret == GPMF_OK ) {uint32_t totalsamples = endsamples - startsamples ;float timo = 0.0 ;GPMF_CopyState ( ms , & find_stream ) ;if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_OFFSET , GPMF_CURRENT_LEVEL ) ) GPMF_FormattedData ( & find_stream , & timo , 4 , 0 , 1 ) ;double first , last ;first = - intercept / rate - timo ;last = first + ( double ) totalsamples / rate ;if ( firstsampletime ) * firstsampletime = first ;if ( lastsampletime ) * lastsampletime = last ;}}}}cleanup : if ( payload ) FreePayload ( payload ) ;return rate ;",4823
1029,r1 . event = event ;r1 . tstamp = * tstamp ;,"memset ( & r1 , 0 , sizeof ( r1 ) ) ;r1 . event = event ;r1 . tstamp = * tstamp ;",4824
1030,"if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",4825
1031,"int old_bin_num , bin_num ;old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ;bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ;if ( old_bin_num == bin_num ) {# endif  return ptr ;}",int old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ;if ( size <= ZEND_MM_MAX_SMALL_SIZE ) {int bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ;if ( old_bin_num == bin_num ) {# endif return ptr ;}},4826
1032,int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;,int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;,4827
1033,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,4827
1034,"unsigned long cs ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE )  return rc ;if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ;if ( ctxt -> mode >= X86EMUL_MODE_PROT16 && ( cs & 3 ) > cpl ) return X86EMUL_UNHANDLEABLE ;rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ;return rc ;","unsigned long eip , cs ;u16 old_cs ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & eip , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ;rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ;return rc ;",4828
1035,lock_sock ( sk ) ;opt -> src_addr = sp -> sa_addr . pptp ;,if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;lock_sock ( sk ) ;opt -> src_addr = sp -> sa_addr . pptp ;,4829
1036,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,4830
1037,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",4830
1038,psf_close_rsrc ( psf ) ;free ( psf -> container_data ) ;,psf_close_rsrc ( psf ) ;free ( psf -> header . ptr ) ;free ( psf -> container_data ) ;,4831
1039,"int is_valid ;if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;giterr_clear ( ) ;is_valid = error != GIT_ECERTIFICATE ;","int is_valid = ( error == GIT_OK ) ;if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;giterr_clear ( ) ;",4832
1040,hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ;hmp_chunk [ i ] += chunk_ofs [ i ] ++ ;,hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ;chunk_length [ i ] -= chunk_ofs [ i ] ;hmp_chunk [ i ] += chunk_ofs [ i ] ++ ;,4833
1041,"}uint32_t setup_ret = 0 ;if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , 0 ) ) == 0 ) {goto _hmp_end ;chunk_end [ i ] = 1 ;hmp_chunk [ i ] += 3 ;","chunk_length [ i ] -= 3 ;}uint32_t setup_ret = 0 ;if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , chunk_length [ i ] , 0 ) ) == 0 ) {goto _hmp_end ;chunk_end [ i ] = 1 ;chunk_length [ i ] -= 3 ;hmp_chunk [ i ] += 3 ;",4833
1042,}var_len_shift = 0 ;if ( * hmp_chunk [ i ] < 0x80 ) {do {chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;var_len_shift += 7 ;}}chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;hmp_chunk [ i ] ++ ;},"chunk_length [ i ] -= setup_ret ;}var_len_shift = 0 ;if ( chunk_length [ i ] && * hmp_chunk [ i ] < 0x80 ) {do {if ( ! chunk_length [ i ] ) break ;chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;var_len_shift += 7 ;chunk_length [ i ] -- ;}}if ( ! chunk_length [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmp_end ;}chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;hmp_chunk [ i ] ++ ;chunk_length [ i ] -- ;}",4833
1043,"c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ;macinf -> lchid [ j + chan ] = c_t + 1 ;macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ;rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ;}","c_t = ( tvb_get_bits8 ( tvb , tb_bit_off , 4 ) + 1 ) % 0xf ;macinf -> lchid [ j + chan ] = c_t ;macinf -> content [ j + chan ] = lchId_type_table [ c_t ] ;rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t ] ;}",4834
1044,struct sctp_sockaddr_entry * laddr ;union sctp_addr * baddr = NULL ;__u8 matchlen = 0 ;__u8 bmatchlen ;,"struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct sctp_sockaddr_entry * laddr ;union sctp_addr * baddr = NULL ;struct in6_addr * final_p , final ;__u8 matchlen = 0 ;__u8 bmatchlen ;",4835
1045,"dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ;if ( ! asoc || saddr ) goto out ;","final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , fl6 , final_p , false ) ;if ( ! asoc || saddr ) goto out ;",4835
1046,"dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ;}","final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , fl6 , final_p , false ) ;}",4835
1047,"r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end ,  & cpat , & cpat_end ) ;if ( r != 0 ) return r ;",return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION ;,4836
1048,"long start ;char * header ;header = calloc ( 1 , 1024 ) ;start = ftell ( fp ) ;fseek ( fp , 0 , SEEK_SET ) ;","char * header ;header = calloc ( 1 , 1024 ) ;long start = ftell ( fp ) ;fseek ( fp , 0 , SEEK_SET ) ;",4837
1049,"pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows *  number_planes_filled * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * number_planes_filled ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;","pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;",4838
1050,"case IPSECDOI_ID_IPV4_ADDR : if ( len < 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]"" , len ) ) ;","case IPSECDOI_ID_IPV4_ADDR : if ( len < 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" , len ) ) ;",4839
1051,"if ( len < 20 )  ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ;","if ( len < 20 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ;",4839
1052,"if ( data -> multi_easy )   curl_multi_cleanup ( data -> multi_easy ) ;Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ;","if ( data -> multi_easy ) {curl_multi_cleanup ( data -> multi_easy ) ;data -> multi_easy = NULL ;}Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ;",4840
1053,"res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;rcu_read_unlock ( ) ;","res = ip6_xmit ( sk , skb , & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ;rcu_read_unlock ( ) ;",4841
1054,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,4842
1055,"uleft_col [ i ] = uleft [ i * left_stride ] ;vleft_col [ i ] = vleft [ i * left_stride ] ;}switch ( x -> mode_info_context -> mbmi . uv_mode ) {case DC_PRED : {int expected_udc ;int expected_vdc ;int shift ;int Uaverage = 0 ;int Vaverage = 0 ;if ( x -> up_available ) {for ( i = 0 ;i < 8 ;i ++ ) {Uaverage += uabove_row [ i ] ;Vaverage += vabove_row [ i ] ;}}if ( x -> left_available ) {for ( i = 0 ;i < 8 ;i ++ ) {Uaverage += uleft_col [ i ] ;Vaverage += vleft_col [ i ] ;}}if ( ! x -> up_available && ! x -> left_available ) {expected_udc = 128 ;expected_vdc = 128 ;}else {shift = 2 + x -> up_available + x -> left_available ;expected_udc = ( Uaverage + ( 1 << ( shift - 1 ) ) ) >> shift ;expected_vdc = ( Vaverage + ( 1 << ( shift - 1 ) ) ) >> shift ;}for ( i = 0 ;i < 8 ;i ++ ) {vpx_memset ( upred_ptr , expected_udc , 8 ) ;vpx_memset ( vpred_ptr , expected_vdc , 8 ) ;upred_ptr += pred_stride ;","memset ( upred_ptr , expected_udc , 8 ) ;vpx_memset ( vpred_ptr , expected_vdc , 8 ) ;upred_ptr += pred_stride ;",4843
1056,"vpx_memcpy ( upred_ptr , uabove_row , 8 ) ;vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ;upred_ptr += pred_stride ;","vpx_memcpy ( upred_ptr , uabove_row , 8 ) ;vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ;upred_ptr += pred_stride ;",4843
1057,"vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ;vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ;upred_ptr += pred_stride ;","vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ;vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ;upred_ptr += pred_stride ;",4843
1058,"if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;","if ( ctxt -> rip_relative && likely ( ctxt -> memopp ) ) ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;",4844
1059,"security_decrypt ( s -> p , length , rdp ) ;if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ;","if ( ! security_decrypt ( s -> p , length , rdp ) ) return FALSE ;if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ;",4845
1060,"control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;goto skip_normal_probe ;","control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;if ( ! data_interface || ! control_interface ) return - ENODEV ;goto skip_normal_probe ;",4846
1061,"
","if ( nelements == 0 ) {DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\goto out ;}",4847
1062,o = 2 ;},o = 2 ;},4847
1063,"for ( j = 0 ;j < nelements ;uint32_t l = CDF_GETUINT32 ( q , o ) ;","for ( j = 0 ;j < nelements && i < sh . sh_properties ;uint32_t l = CDF_GETUINT32 ( q , o ) ;",4847
1064,"static int   rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent )  {pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) ,  pdu_type , pdu_len ) ) ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU :  case RPKI_RTR_END_OF_DATA_PDU :  msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU :  break ;case RPKI_RTR_CACHE_RESPONSE_PDU :  ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ;tlen = pdu_len ;tptr += sizeof ( * pdu ) ;tlen -= sizeof ( * pdu ) ;if ( encapsulated_pdu_length &&  ( encapsulated_pdu_length <= tlen ) ) {if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) )  goto trunc ;tptr += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = 0 ;if ( tlen > 4 ) {text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;}ND_TCHECK2 ( * tptr , text_length ) ;if ( text_length && ( text_length <= tlen ) ) {ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ;if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ;}break ;default : hexdump = TRUE ;return 0 ;trunc :  return 1 ;}","static u_int rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , const u_int len , const u_char recurse , const u_int indent ) {ND_TCHECK_8BITS ( tptr ) ;if ( * tptr != 0 ) {ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ;return len ;}if ( len < sizeof ( rpki_rtr_pdu ) ) {ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ;goto invalid ;}ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , pdu_type , pdu_len ) ) ;if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;break ;case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;tlen = sizeof ( rpki_rtr_pdu ) ;if ( pdu_len < tlen + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , tlen + 4 ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;tlen += 4 ;if ( encapsulated_pdu_length && ( encapsulated_pdu_length <= tlen ) ) {rpki_rtr_pdu_print ( ndo , tptr + tlen , encapsulated_pdu_length , 0 , indent + 2 ) ;tlen += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = TRUE ;return 0 ;trunc : ND_PRINT ( ( ndo , ""\\\return len ;}",4848
1065,xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn +  picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn +  picomp -> numrlvls - rlvlno - 1 ) ) ;,"if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",4849
1066,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) )   || ! ( pi -> x % ( 1 << rpx ) ) ) &&   ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) )   || ! ( pi -> y % ( 1 << rpy ) ) ) ) {prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;","if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) ) {prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;",4849
1067,"if ( pack -> hdr . ver == 2 ) {print ( ""[L2TP<S2SV_blank>tid=%u<S2SV_blank>sid=%u"" , ntohs ( pack -> hdr . tid ) , ntohs ( pack -> hdr . sid ) ) ;}else {print ( ""[L2TP<S2SV_blank>cid=%u"" , pack -> hdr . cid ) ;log_ppp_debug ( ""<S2SV_blank>Ns=%u<S2SV_blank>Nr=%u"" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ;}","switch ( pack -> hdr . flags & L2TP_VER_MASK ) {case 2 : print ( ""[L2TP<S2SV_blank>tid=%u<S2SV_blank>sid=%u"" , ntohs ( pack -> hdr . tid ) , ntohs ( pack -> hdr . sid ) ) ;break ;case 3 : print ( ""[L2TP<S2SV_blank>cid=%u"" , pack -> hdr . cid ) ;break ;default : print ( ""[L2TP<S2SV_blank>unknown<S2SV_blank>version]\\\return ;}",4850
1068,"if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ;GET_HANDLE ( ) ;if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) {st = EINVAL ;k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ;goto cleanup ;}if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ;filtuser = ldap_filter_correct ( user ) ;if ( filtuser == NULL ) {st = ENOMEM ;goto cleanup ;}if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ;else optype = MODIFY_PRINCIPAL ;if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ;if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ;if ( entry -> mask & KADM5_LOAD ) {unsigned int tree = 0 ;int numlentries = 0 ;char * filter = NULL ;if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) {filter = NULL ;if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ;found_entry = FALSE ;for ( tree = 0 ;found_entry == FALSE && tree < ntrees ;++ tree ) {if ( principal_dn == NULL ) {LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ;}else {LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ;}if ( st == LDAP_SUCCESS ) {numlentries = ldap_count_entries ( ld , result ) ;if ( numlentries > 1 ) {free ( filter ) ;st = EINVAL ;k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>found"" ) , user ) ;goto cleanup ;}else if ( numlentries == 1 ) {found_entry = TRUE ;if ( principal_dn == NULL ) {ent = ldap_first_entry ( ld , result ) ;if ( ent != NULL ) {if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) {ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ;st = set_ldap_error ( context , st , 0 ) ;free ( filter ) ;goto cleanup ;}}}}}else if ( st != LDAP_NO_SUCH_OBJECT ) {st = set_ldap_error ( context , st , 0 ) ;free ( filter ) ;goto cleanup ;}ldap_msgfree ( result ) ;result = NULL ;}free ( filter ) ;if ( found_entry == FALSE && principal_dn != NULL ) {create_standalone_prinicipal = TRUE ;standalone_principal_dn = strdup ( principal_dn ) ;CHECK_NULL ( standalone_principal_dn ) ;}}if ( principal_dn == NULL && xargs . dn == NULL ) {if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) {subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;}else if ( xargs . containerdn ) {if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) {if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) {int ost = st ;st = EINVAL ;k5_prependmsg ( context , ost , st , _ ( ""\\\'%s\\\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ;}goto cleanup ;}subtree = strdup ( xargs . containerdn ) ;}else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) {subtree = strdup ( ldap_context -> lrparams -> containerref ) ;}else {subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;}CHECK_NULL ( subtree ) ;if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ;CHECK_NULL ( standalone_principal_dn ) ;create_standalone_prinicipal = TRUE ;free ( subtree ) ;subtree = NULL ;}if ( xargs . dn_from_kbd == TRUE ) {int dnlen = 0 , subtreelen = 0 ;char * dn = NULL ;krb5_boolean outofsubtree = TRUE ;if ( xargs . dn != NULL ) {dn = xargs . dn ;}else if ( xargs . linkdn != NULL ) {dn = xargs . linkdn ;}else if ( standalone_principal_dn != NULL ) {dn = standalone_principal_dn ;}if ( subtreelist == NULL ) {st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ;if ( st ) goto cleanup ;}for ( tre = 0 ;tre < ntrees ;++ tre ) {if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) {outofsubtree = FALSE ;break ;}else {dnlen = strlen ( dn ) ;subtreelen = strlen ( subtreelist [ tre ] ) ;if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) {outofsubtree = FALSE ;break ;}}}if ( outofsubtree == TRUE ) {st = EINVAL ;k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ;goto cleanup ;}if ( standalone_principal_dn == NULL ) {char * attributes [ ] = {""krbticketpolicyreference"" , ""krbprincipalname"" , NULL };ldap_msgfree ( result ) ;result = NULL ;LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ;if ( st == LDAP_SUCCESS ) {ent = ldap_first_entry ( ld , result ) ;if ( ent != NULL ) {if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) {ldap_value_free ( values ) ;}if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) {krb_identity_exists = TRUE ;ldap_value_free ( values ) ;}}}else {st = set_ldap_error ( context , st , OP_SEARCH ) ;goto cleanup ;}}}if ( xargs . dn != NULL && krb_identity_exists == TRUE ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}if ( xargs . linkdn != NULL ) {if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}{char * * linkdns = NULL ;int j = 0 ;if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) {snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}if ( linkdns != NULL ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;for ( j = 0 ;linkdns [ j ] != NULL ;++ j ) free ( linkdns [ j ] ) ;free ( linkdns ) ;goto cleanup ;}}establish_links = TRUE ;}if ( entry -> mask & KADM5_LAST_SUCCESS ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_LAST_FAILED ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) {krb5_kvno fail_auth_count ;fail_auth_count = entry -> fail_auth_count ;if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ;st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ;if ( st != 0 ) goto cleanup ;}else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) {int attr_mask = 0 ;krb5_boolean has_fail_count ;st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ;if ( st != 0 ) goto cleanup ;has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ;# ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ;if ( st != 0 ) goto cleanup ;}else {# endif if ( has_fail_count ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ;if ( st != 0 ) goto cleanup ;}st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ;if ( st != 0 ) goto cleanup ;# ifdef LDAP_MOD_INCREMENT }# endif }else if ( optype == ADD_PRINCIPAL ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ;}if ( entry -> mask & KADM5_MAX_LIFE ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_MAX_RLIFE ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_ATTRIBUTES ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_PRINCIPAL ) {memset ( strval , 0 , sizeof ( strval ) ) ;strval [ 0 ] = user ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_PW_EXPIRATION ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_POLICY ) {memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ;for ( tl_data = entry -> tl_data ;tl_data ;tl_data = tl_data -> tl_data_next ) {if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) {if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) {goto cleanup ;}break ;}}if ( princ_ent . aux_attributes & KADM5_POLICY ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ;strval [ 0 ] = polname ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;}else {st = EINVAL ;k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ;goto cleanup ;}}else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) {if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_POLICY_CLR ) {if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) {krb5_kvno mkvno ;if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ;bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ;if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" ,   LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 )  goto cleanup ;","if ( bersecretkey == NULL ) {+ tree ) {+ tre ) {+ j ) free ( linkdns [ j ] ) ;if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) {st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) goto cleanup ;",4851
1069,"puts ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>""  ""All<S2SV_blank>rights<S2SV_blank>reserved.\\\","puts ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>2015,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>"" ""All<S2SV_blank>rights<S2SV_blank>reserved.\\\",4852
1070,"char * r = pool_alloc ( strlen ( s ) + 1 ) ;strcpy ( r , s ) ;return r ;","size_t len = strlen ( s ) + 1 ;char * r = pool_alloc ( len ) ;memcpy ( r , s , len ) ;return r ;",4853
1071,"if ( size_left && size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;","if ( size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;",4854
1072,"static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data ,  OPJ_UINT32 * p_data_written ,  const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) {opj_write_bytes ( p_data , J2K_MS_SOT ,  2 ) ;","static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) {if ( p_total_data_size < 12 ) {opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\\return OPJ_FALSE ;}opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ;",4855
1073,"static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps )  {mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ;kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;","static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps ) {int i ;mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , ps -> channels [ 0 ] . count , 0 ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",4856
1074,"struct timeval tv [ 2 ] ;# define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) {why = str ;goto screwup ;}if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size"" ) ;setimes = targisdir = 0 ;mask = umask ( 0 ) ;if ( ! pflag ) ( void ) umask ( mask ) ;if ( argc != 1 ) {run_err ( ""ambiguous<S2SV_blank>target"" ) ;exit ( 1 ) ;}targ = * argv ;if ( targetshouldbedirectory ) verifydir ( targ ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ;if ( src != NULL && ! iamrecursive && ! Tflag ) {if ( brace_expand ( src , & patterns , & npatterns ) != 0 ) fatal ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>expand<S2SV_blank>pattern"" , __func__ ) ;}for ( first = 1 ;;first = 0 ) {cp = buf ;if ( atomicio ( read , remin , cp , 1 ) != 1 ) goto done ;if ( * cp ++ == \'\\\do {if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ;* cp ++ = ch ;}while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != \'\\\* cp = 0 ;if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ;if ( buf [ 0 ] == \'\\\\01\' || buf [ 0 ] == \'\\\\02\' ) {if ( iamremote == 0 ) {( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ;( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ;}if ( buf [ 0 ] == \'\\\\02\' ) exit ( 1 ) ;++ errs ;continue ;}if ( buf [ 0 ] == \'E\' ) {( void ) atomicio ( vwrite , remout , """" , 1 ) ;goto done ;}if ( ch == \'\\\cp = buf ;if ( * cp == \'T\' ) {setimes ++ ;cp ++ ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;mtime . tv_sec = ull ;mtime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;atime . tv_sec = ull ;atime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'\\\\0\' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;continue ;}if ( * cp != \'C\' && * cp != \'D\' ) {if ( first ) {run_err ( ""%s"" , cp ) ;exit ( 1 ) ;}SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ;}mode = 0 ;for ( ++ cp ;cp < buf + 5 ;cp ++ ) {if ( * cp < \'0\' || * cp > \'7\' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ;mode = ( mode << 3 ) | ( * cp - \'0\' ) ;}if ( ! pflag ) mode &= ~ mask ;if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ;size = ( off_t ) ull ;if ( * cp == \'\\\\0\' || strchr ( cp , \'/\' ) != NULL || strcmp ( cp , ""."" ) == 0 || strcmp ( cp , "".."" ) == 0 ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;exit ( 1 ) ;}if ( npatterns > 0 ) {for ( n = 0 ;n < npatterns ;n ++ ) {if ( fnmatch ( patterns [ n ] , cp , 0 ) == 0 ) break ;}if ( n >= npatterns ) SCREWUP ( ""filename<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>request"" ) ;}if ( targisdir ) {static char * namebuf ;static size_t cursize ;size_t need ;need = strlen ( targ ) + strlen ( cp ) + 250 ;if ( need > cursize ) {free ( namebuf ) ;namebuf = xmalloc ( need ) ;cursize = need ;}( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ;np = namebuf ;}else np = targ ;curfile = cp ;exists = stat ( np , & stb ) == 0 ;if ( buf [ 0 ] == \'D\' ) {int mod_flag = pflag ;if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ;if ( exists ) {if ( ! S_ISDIR ( stb . st_mode ) ) {errno = ENOTDIR ;goto bad ;}if ( pflag ) ( void ) chmod ( np , mode ) ;}else {mod_flag = 1 ;if ( mkdir ( np , mode | S_IRWXU ) == - 1 ) goto bad ;}vect [ 0 ] = xstrdup ( np ) ;sink ( 1 , vect , src ) ;if ( setimes ) {setimes = 0 ;if ( utimes ( vect [ 0 ] , tv ) == - 1 )  run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ;","+ errs ;( void ) utimes ( vect [ 0 ] , tv ) == - 1 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ;",4857
1075,"timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) {","m -> msg_namelen = 0 ;timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) {",4858
1076,"inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;rc = PTR_ERR ( inode ) ;","s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ;rc = - EINVAL ;if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) {pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\\goto out_free ;}inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;rc = PTR_ERR ( inode ) ;",4859
1077,"}else if ( options . compression == COMP_DELAYED ) {myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = ""none,zlib@openssh.com"" ;","}if ( options . compression == COMP_DELAYED ) {myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = ""none,zlib@openssh.com"" ;",4860
1078,"struct flowi4 fl4 ;struct rtable * rt ;if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) )  return ;if ( ! IS_ERR ( rt ) )   __sk_dst_set ( sk , & rt -> dst ) ;rcu_read_unlock ( ) ;","struct dst_entry * dst ;struct flowi4 fl4 ;struct rtable * rt ;dst = __sk_dst_get ( sk ) ;if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst , 0 ) ) {rcu_read_unlock ( ) ;return ;}dst = ! IS_ERR ( rt ) ) __sk_dst_set ( sk , & rt -> dst : NULL ;sk_dst_set ( sk , dst ) ;rcu_read_unlock ( ) ;",4861
1079,"num = port >= 0 ? port : 0 ;mutex_lock ( & client -> ports_mutex ) ;write_lock_irqsave ( & client -> ports_lock , flags ) ;list_for_each_entry ( p , & client -> ports_list_head , list ) {if ( p -> addr . port > num ) break ;if ( port < 0 ) num = p -> addr . port + 1 ;}list_add_tail ( & new_port -> list , & p -> list ) ;client -> num_ports ++ ;new_port -> addr . port = num ;write_unlock_irqrestore ( & client -> ports_lock , flags ) ;mutex_unlock ( & client -> ports_mutex ) ;sprintf ( new_port -> name , ""port-%d"" , num ) ;",snd_use_lock_use ( & new_port -> use_lock ) ;num = port >= 0 ? port : 0 ;mutex_lock ( & client -> ports_mutex ) ;,4862
1080,"return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) ,  RTL8150_REQ_GET_REGS , RTL8150_REQT_READ ,  indx , 0 , data , size , 500 ) ;}","void * buf ;int ret ;buf = kmalloc ( size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , RTL8150_REQ_GET_REGS , RTL8150_REQT_READ , indx , 0 , buf , size , 500 ) ;if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ;kfree ( buf ) ;return ret ;}",4863
1081,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,4864
1082,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",4864
1083,"
",LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;,4864
1084,l_row -- ;l_column -- ;,l_row -- ;l_column -- ;,4864
1085,"struct ip_options * opt = NULL ;struct inet_sock * sk_inet ;if ( sk == NULL ) return 0 ;buf_len = CIPSO_V4_OPT_LEN_MAX ;buf = kmalloc ( buf_len , GFP_ATOMIC ) ;if ( buf == NULL ) {ret_val = - ENOMEM ;goto socket_setattr_failure ;ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ;if ( ret_val < 0 ) goto socket_setattr_failure ;buf_len = ret_val ;opt_len = ( buf_len + 3 ) & ~ 3 ;opt = kzalloc ( sizeof ( * opt ) + opt_len , GFP_ATOMIC ) ;if ( opt == NULL ) {ret_val = - ENOMEM ;goto socket_setattr_failure ;}memcpy ( opt -> __data , buf , buf_len ) ;opt -> optlen = opt_len ;opt -> cipso = sizeof ( struct iphdr ) ;kfree ( buf ) ;buf = NULL ;sk_inet = inet_sk ( sk ) ;if ( sk_inet -> is_icsk ) {sk_conn = inet_csk ( sk ) ;if ( sk_inet -> opt )   sk_conn -> icsk_ext_hdr_len -= sk_inet -> opt -> optlen ;sk_conn -> icsk_ext_hdr_len += opt -> optlen ;sk_conn -> icsk_sync_mss ( sk , sk_conn -> icsk_pmtu_cookie ) ;}opt = xchg ( & sk_inet -> opt , opt ) ;kfree ( opt ) ;","struct ip_options_rcu * old , * opt = NULL ;struct inet_sock * sk_inet ;if ( old ) sk_conn -> icsk_ext_hdr_len -= sk_inet -> opt -> optlen ;sk_conn -> icsk_ext_hdr_len += opt -> opt . optlen ;sk_conn -> icsk_sync_mss ( sk , sk_conn -> icsk_pmtu_cookie ) ;opt = xchg ( & sk_inet -> opt , opt ) ;kfree ( opt ) ;",4865
1086,"int zero_bits = * in & 0x07 ;size_t octets_left = inlen - 1 ;int i , count = 0 ;memset ( outbuf , 0 , outlen ) ;","int i , count = 0 ;int zero_bits ;size_t octets_left ;if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ;if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ;zero_bits = * in & 0x07 ;octets_left = inlen - 1 ;int i , count = 0 ;memset ( outbuf , 0 , outlen ) ;",4866
1087,"if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs ,  & len , & iovec , compat ) ;else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs ,  len , iovec ) ;if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ;","if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , & len , & iovec , compat , & iter ) ;else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , len , iovec , & iter ) ;if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ;",4867
1088,"iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ;ret = iter_op ( req , & iter ) ;ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ;","ret = iter_op ( req , & iter ) ;ret = rw_op ( req , iter . iov , iter . nr_segs , req -> ki_pos ) ;",4867
1089,"unsigned char challenge [ 30 ] ;unsigned char signature [ 256 ] ;unsigned int siglen = sizeof signature ;const EVP_MD * md = EVP_sha1 ( ) ;if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) {goto err ;","unsigned char * signature = NULL ;unsigned int siglen = sizeof signature ;const EVP_MD * md = EVP_sha1 ( ) ;if ( NULL == privkey ) goto err ;siglen = EVP_PKEY_size ( privkey ) ;if ( siglen <= 0 ) goto err ;signature = malloc ( siglen ) ;if ( NULL == signature ) goto err ;if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) {goto err ;",4868
1090,err :  if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ;,err : free ( signature ) ;if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ;,4868
1091,out_err :  kfree ( init_name ) ;return rv ;,out_err : if ( rv && new_smi -> io . io_cleanup ) {new_smi -> io . io_cleanup ( & new_smi -> io ) ;new_smi -> io . io_cleanup = NULL ;}kfree ( init_name ) ;return rv ;,4869
1092,"static void encode_loopfilter ( struct loopfilter * lf ,  struct vp9_write_bit_buffer * wb ) {int i ;vp9_wb_write_literal ( wb , lf -> filter_level , 6 ) ;vp9_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ;vp9_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ;if ( lf -> mode_ref_delta_enabled ) {vp9_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ;if ( lf -> mode_ref_delta_update ) {const int changed = delta != lf -> last_ref_deltas [ i ] ;vp9_wb_write_bit ( wb , changed ) ;if ( changed ) {vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ;vp9_wb_write_bit ( wb , delta < 0 ) ;}const int changed = delta != lf -> last_mode_deltas [ i ] ;vp9_wb_write_bit ( wb , changed ) ;if ( changed ) {vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ;vp9_wb_write_bit ( wb , delta < 0 ) ;}","static void encode_loopfilter ( struct loopfilter * lf , struct vpx_write_bit_buffer * wb ) {int i ;vpx_wb_write_literal ( wb , lf -> filter_level , 6 ) ;vpx_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ;vpx_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ;if ( lf -> mode_ref_delta_enabled ) {vpx_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ;if ( lf -> mode_ref_delta_update ) {vpx_wb_write_bit ( wb , changed ) ;if ( changed ) {vpx_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ;vpx_wb_write_bit ( wb , delta < 0 ) ;}vpx_wb_write_bit ( wb , changed ) ;if ( changed ) {vpx_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ;vpx_wb_write_bit ( wb , delta < 0 ) ;}",4870
1093,"char * header , * c ;header = get_header ( fp ) ;if ( ( c = strstr ( header , ""%PDF-"" ) ) &&  ( c + strlen ( ""%PDF-M.m"" ) + 2 ) )  {","char * header = get_header ( fp ) ;const char * c ;if ( ( c = strstr ( header , ""%PDF-"" ) ) && ( ( c + 6 ) [ 0 ] == \'.\' ) && isdigit ( ( c + 5 ) [ 0 ] ) && isdigit ( ( c + 7 ) [ 0 ] ) ) {",4871
1094,"struct in6_addr * saddr = NULL , * final_p , final ;struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;if ( np -> sndflow ) {fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ;IP6_ECN_flow_init ( fl6 . flowlabel ) ;if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) {struct ip6_flowlabel * flowlabel ;flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ;if ( flowlabel == NULL ) return - EINVAL ;fl6_sock_release ( flowlabel ) ;}}if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ;addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ;if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ;if ( addr_type & IPV6_ADDR_LINKLOCAL ) {if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) {if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ;sk -> sk_bound_dev_if = usin -> sin6_scope_id ;}if ( ! sk -> sk_bound_dev_if ) return - EINVAL ;}sk -> sk_v6_daddr = usin -> sin6_addr ;np -> flow_label = fl6 . flowlabel ;if ( addr_type == IPV6_ADDR_MAPPED ) {u32 exthdrlen = icsk -> icsk_ext_hdr_len ;struct sockaddr_in sin ;SOCK_DEBUG ( sk , ""connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\\if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ;sin . sin_family = AF_INET ;sin . sin_port = usin -> sin6_port ;sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ;icsk -> icsk_af_ops = & dccp_ipv6_mapped ;sk -> sk_backlog_rcv = dccp_v4_do_rcv ;err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ;if ( err ) {icsk -> icsk_ext_hdr_len = exthdrlen ;icsk -> icsk_af_ops = & dccp_ipv6_af_ops ;sk -> sk_backlog_rcv = dccp_v6_do_rcv ;goto failure ;}np -> saddr = sk -> sk_v6_rcv_saddr ;return err ;}if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ;fl6 . flowi6_proto = IPPROTO_DCCP ;fl6 . daddr = sk -> sk_v6_daddr ;fl6 . saddr = saddr ? * saddr : np -> saddr ;fl6 . flowi6_oif = sk -> sk_bound_dev_if ;fl6 . fl6_dport = usin -> sin6_port ;fl6 . fl6_sport = inet -> inet_sport ;security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","struct in6_addr * saddr = NULL , * final_p , final ;struct ipv6_txoptions * opt ;struct flowi6 fl6 ;memset ( & fl6 , opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",4872
1095,if ( np -> opt != NULL )   icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen +   np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,if ( np -> opt != NULL ) icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,4872
1096,"return ;}ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\\switch ( pt ) {case PT_IPV4 : ip_print ( ndo , p , length ) ;case PT_OSI :  isoclns_print ( ndo , p , length , length ) ;break ;","case PT_OSI : isoclns_print ( ndo , p , length , length ) ;break ;",4873
1097,"strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ;}","strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 ) ;}",4874
1098,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",4875
1099,"u_char * b , * s , * t , c ;int i , proto ;b = ( uint8_t * ) malloc ( length ) ;if ( b == NULL ) return ;for ( s = ( u_char * ) p , t = b , i = length ;i > 0 ;c = * s ++ ;if ( i > 1 ) {i -- ;c = * s ++ ^ 0x20 ;}else continue ;","u_char * b , * t , c ;const u_char * s ;int i , proto ;b = ( u_char * ) malloc ( length ) ;if ( b == NULL ) return ;for ( s = p , t = b , i = length ;i > 0 && ND_TTEST ( * s ) ;c = * s ++ ;if ( i <= 1 || ! ND_TTEST ( * s ) ) break ;i -- ;c = * s ++ ^ 0x20 ;",4876
1100,WORD16 i2_level_arr [ 4 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,WORD16 ai2_level_arr [ 7 ] ;WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,4877
1101,"dst_ctx = & per_cpu_ptr ( pmu -> pmu_cpu_context , dst_cpu ) -> ctx ;mutex_lock ( & src_ctx -> mutex ) ;list_for_each_entry_safe ( event , tmp , & src_ctx -> event_list , event_entry ) {mutex_unlock ( & src_ctx -> mutex ) ;synchronize_rcu ( ) ;mutex_lock ( & dst_ctx -> mutex ) ;","mutex_lock_double ( & src_ctx -> mutex , & dst_ctx -> mutex ) ;list_for_each_entry_safe ( event , tmp , & src_ctx -> event_list , event_entry ) {synchronize_rcu ( ) ;",4878
1102,},mutex_unlock ( & src_ctx -> mutex ) ;},4878
1103,atomic_inc ( & prog -> aux -> refcnt ) ;fdput ( f ) ;,prog = bpf_prog_inc ( prog ) ;fdput ( f ) ;,4879
1104,"static INLINE void write_buffer_8x8 ( int16_t * output , __m128i * res , int stride ) {_mm_store_si128 ( ( __m128i * ) ( output + 0 * stride ) , res [ 0 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 1 * stride ) , res [ 1 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 2 * stride ) , res [ 2 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 3 * stride ) , res [ 3 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 4 * stride ) , res [ 4 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 5 * stride ) , res [ 5 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 6 * stride ) , res [ 6 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 7 * stride ) , res [ 7 ] ) ;}","static INLINE void write_buffer_8x8 ( tran_low_t * output , __m128i * res , int stride ) {store_output ( & res [ 0 ] , ( output + 0 * stride ) ) ;store_output ( & res [ 1 ] , ( output + 1 * stride ) , res [ 1 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 2 * stride ) ) ;store_output ( & res [ 2 ] , ( output + 3 * stride ) , res [ 3 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 4 * stride ) ) ;store_output ( & res [ 3 ] , ( output + 5 * stride ) , res [ 5 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 6 * stride ) ) ;store_output ( & res [ 4 ] , ( output + 7 * stride ) , res [ 7 ] ) ;}",4880
1105,"
",if ( unlikely ( page_count ( page ) <= 0 ) ) {if ( pages ) {spin_unlock ( ptl ) ;remainder = 0 ;err = - ENOMEM ;break ;}},4881
1106,same_page :  if ( pages ) {,same_page : if ( pages ) {,4881
1107,if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) {continue ;,if ( bin -> methods [ i ] . class_id > bin -> header . types_size ) {continue ;,4882
1108,uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ;if ( send_buf_size < pkg_size ) {assert ( send_buf != NULL ) ;},uint32_t pkg_size ;if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) {return - 1 ;}pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ;if ( send_buf_size < pkg_size ) {if ( send_buf == NULL ) {return - 1 ;}},4883
1109,"case UPDATE_TYPE_SYNCHRONIZE :  update_read_synchronize ( update , s ) ;rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ;","case UPDATE_TYPE_SYNCHRONIZE : if ( ! update_read_synchronize ( update , s ) ) goto fail ;rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ;",4884
1110,"# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE &&  * p == SSL3_MT_CLIENT_HELLO ) &&  ! dtls1_record_replay_check ( s , bitmap ) ) {","# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) {",4885
1111,"ND_TCHECK ( pptr [ 0 ] ) ;plen = pptr [ 0 ] ;if ( 0 == plen ) {snprintf ( buf , buflen , ""default<S2SV_blank>route<S2SV_blank>target"" ) ;return 1 ;}if ( 32 > plen ) return - 1 ;plen -= 32 ;if ( 64 < plen ) return - 1 ;memset ( & route_target , 0 , sizeof ( route_target ) ) ;ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ;memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ;if ( plen % 8 ) {snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" ,  as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) ,  bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ;","char asbuf [ sizeof ( astostr ) ] ;ND_TCHECK ( pptr [ 5 ] , ( plen + 7 ) / 8 ) ;memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ;if ( plen % 8 ) {snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ;",4886
1112,"static void consume_one_event ( unsigned cpu ,  struct evtchn_fifo_control_block * control_block ,  unsigned priority , unsigned long * ready ,  bool drop ) {","static void consume_one_event ( unsigned cpu , struct evtchn_loop_ctrl * ctrl , struct evtchn_fifo_control_block * control_block , unsigned priority , unsigned long * ready ) {",4887
1113,"if ( unlikely ( drop ) )  pr_warn ( ""Dropping<S2SV_blank>pending<S2SV_blank>event<S2SV_blank>for<S2SV_blank>port<S2SV_blank>%u\\\else  handle_irq_for_port ( port ) ;}","if ( unlikely ( ! ctrl ) ) pr_warn ( ""Dropping<S2SV_blank>pending<S2SV_blank>event<S2SV_blank>for<S2SV_blank>port<S2SV_blank>%u\\\else handle_irq_for_port ( port , ctrl ) ;}",4887
1114,"cstate = 0 ;if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {return - 1 ;}if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth ||  ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) {return - 1 ;if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) {jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\return - 1 ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;if ( jas_stream_eof ( in ) ) {jas_free ( siz -> comps ) ;return - 1 ;}return 0 ;}","siz -> comps = 0 ;cstate = 0 ;if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {goto error ;if ( ! siz -> width || ! siz -> height ) {jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\goto error ;}if ( ! siz -> tilewidth || ! siz -> tileheight ) {jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\goto error ;}if ( ! siz -> numcomps || siz -> numcomps > 16384 ) {jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> xoff >= siz -> width ) {jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> yoff >= siz -> height ) {jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) {jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) {jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;goto error ;goto error ;goto error ;goto error ;",4888
1115,if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;},"
",4889
1116,"chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;}skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ;chunk -> subh . v = NULL ;if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) {chunk -> singleton = 0 ;}else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;return NULL ;",chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;chunk -> pdiscard = 1 ;chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;,4889
1117,last_id = ntohs ( * pid ) ;if ( last_id > 20000 ) wrap = 1 ;,if ( plen < 0 ) return 0 ;last_id = ntohs ( * pid ) ;if ( last_id > 20000 ) wrap = 1 ;,4890
1118,"
",char * rbuff = NULL ;,4891
1119,"ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Sending<S2SV_blank>request<S2SV_blank>to<S2SV_blank>chained<S2SV_blank>program:<S2SV_blank>%s\\\ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Request:<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\\fprintf ( sgfpw , ""%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\\fflush ( sgfpw ) ;chain_ret = ( char * ) malloc ( sizeof ( char ) * MAX_URL_SIZE ) ;","ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Sending<S2SV_blank>request<S2SV_blank>to<S2SV_blank>chained<S2SV_blank>program:<S2SV_blank>%s\\\ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Request:<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\\rbuff = replace ( httpinf . url , ""%"" , ""%25"" ) ;fprintf ( sgfpw , ""%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\\fflush ( sgfpw ) ;xfree ( rbuff ) ;chain_ret = ( char * ) malloc ( sizeof ( char ) * MAX_URL_SIZE ) ;",4891
1120,if ( ! values [ k ] . name )  continue ;,if ( ! values [ k ] . name ) {continue ;},4892
1121,msg -> msg_namelen = 0 ;do {,do {,4893
1122,"# ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds ,  encT ) ;# elif defined ( USE_ARM_ASM )  return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ;# else return do_encrypt_fn ( ctx , bx , ax ) ;","# ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , enc_tables . T ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , enc_tables . T ) ;# else return do_encrypt_fn ( ctx , bx , ax ) ;",4894
1123,rect . x = Z_LVAL_PP ( tmp ) ;}rect . y = Z_LVAL_PP ( tmp ) ;}rect . width = Z_LVAL_PP ( tmp ) ;}rect . height = Z_LVAL_PP ( tmp ) ;},if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . x = Z_LVAL ( lval ) ;}else {rect . x = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . y = Z_LVAL ( lval ) ;}else {rect . y = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . width = Z_LVAL ( lval ) ;}else {rect . width = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . height = Z_LVAL ( lval ) ;}else {rect . height = Z_LVAL_PP ( tmp ) ;}},4895
1124,"if ( s -> width != avctx -> width && s -> height != avctx -> height ) {ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ;","if ( s -> width != avctx -> width || s -> height != avctx -> height ) {ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ;",4896
1125,"if ( length == 1 && bp [ 0 ] == 0xff ) {ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ;}if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) {","ND_TCHECK ( bp [ 0 ] ) ;if ( length == 1 && bp [ 0 ] == 0xff ) {ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ;}ND_TCHECK ( bp [ 3 ] ) ;if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) {",4897
1126,"if ( sizeof ( content_type ) - 1 == klen && 0 == strncasecmp ( key , content_type , sizeof ( content_type ) - 1 ) ) {rb_hash_aset ( hh , content_type_val , rb_str_new ( val , vlen ) ) ;}else if ( sizeof ( content_length ) - 1 == klen && 0 == strncasecmp ( key , content_length , sizeof ( content_length ) - 1 ) ) {rb_hash_aset ( hh , content_length_val , rb_str_new ( val , vlen ) ) ;}char hkey [ 1024 ] ;char * k = hkey ;volatile VALUE sval = rb_str_new ( val , vlen ) ;strcpy ( hkey , ""HTTP_"" ) ;k = hkey + 5 ;if ( ( int ) ( sizeof ( hkey ) - 5 ) <= klen ) {klen = sizeof ( hkey ) - 6 ;strncpy ( k , key , klen ) ;hkey [ klen + 5 ] = \'\\\\0\' ;for ( k = hkey + 5 ;\'\\\\0\' != * k ;k ++ ) {if ( \'-\' == * k ) {* k = \'_\' ;* k = toupper ( * k ) ;rb_hash_aset ( hh , rb_str_new ( hkey , klen + 5 ) , sval ) ;}}","VALUE v ;if ( sizeof ( content_type ) - 1 == klen && 0 == strncasecmp ( key , content_type , sizeof ( content_type ) - 1 ) ) {if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_type_val , Qnil ) ) ) {rb_hash_aset ( hh , content_type_val , rb_str_new ( val , vlen ) ) ;}volatile VALUE a = rb_ary_new ( ) ;rb_ary_push ( a , v ) ;rb_ary_push ( a , rb_str_new ( val , vlen ) ) ;rb_hash_aset ( hh , content_type_val , a ) ;}kval = rb_str_new ( hkey , klen + 5 ) ;if ( Qnil == ( v = rb_hash_lookup2 ( hh , kval , Qnil ) ) ) {rb_hash_aset ( hh , kval , sval ) ;volatile VALUE a = rb_ary_new ( ) ;rb_ary_push ( a , v ) ;rb_ary_push ( a , sval ) ;rb_hash_aset ( hh , kval , a ) ;}",4898
1127,"# define ThrowCUTReaderException ( severity , tag ) {}Image * image , * palette ;","# define ThrowCUTReaderException ( severity , tag ) \\\\\\\\\\Image * image , * palette ;",4899
1128,"
","( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;",4899
1129,"offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {","offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {",4899
1130,"archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC ,   ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;archive_clear_error ( & a -> archive ) ;","const size_t max_write = INT_MAX ;archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;if ( s > max_write ) s = max_write ;archive_clear_error ( & a -> archive ) ;",4900
1131,if ( 0 == ps_dec -> u2_header_done ) {ps_dec -> u2_horizontal_size = u2_width ;ps_dec -> u2_vertical_size = u2_height ;if ( 0 == ps_dec -> u4_frm_buf_stride )  {,if ( 0 == ps_dec -> i4_pic_count ) {return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ;}else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) {IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ;ps_dec -> u2_reinit_max_height = u2_height ;ps_dec -> u2_reinit_max_width = u2_width ;return e_error ;}else {if ( 0 == ps_dec -> u4_frm_buf_stride ) {,4901
1132,else if ( ( u2_width > ps_dec -> u2_create_max_width )   || ( u2_height > ps_dec -> u2_create_max_height ) )  {,else if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( u2_height > ps_dec -> u2_create_max_height ) ) {,4901
1133,return e_error ;},return e_error ;}if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) {return IMPEG2D_UNSUPPORTED_DIMENSIONS ;},4901
1134,xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn +  picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn +  picomp -> numrlvls - rlvlno - 1 ) ) ;,"if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",4902
1135,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) )   || ! ( pi -> x % ( 1 << rpx ) ) ) &&   ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) )   || ! ( pi -> y % ( 1 << rpy ) ) ) ) {prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;","if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) ) {prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;",4902
1136,"if ( p -> tcph -> th_flags & TH_RST ) {if ( ! StreamTcpValidateRst ( ssn , p ) ) return - 1 ;","if ( StateSynSentValidateTimestamp ( ssn , p ) == false ) return - 1 ;if ( p -> tcph -> th_flags & TH_RST ) {if ( ! StreamTcpValidateRst ( ssn , p ) ) return - 1 ;",4903
1137,int result = RLC_OK ;bn_t t ;,int result = RLC_ERR ;bn_t t ;,4904
1138,if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;},result = RLC_OK ;if ( bn_is_zero ( t ) ) {result = RLC_ERR ;},4904
1139,if ( pad != RSA_PAD ) {result = RLC_ERR ;}break ;},if ( pad == RSA_PAD ) {result = RLC_ERR ;}break ;},4904
1140,if ( ! unconditional ( & e -> arp ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,4905
1141,"char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ;rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ;uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ;int i , len ;","union {char bytes [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ;rfbSetColourMapEntriesMsg msg ;}buf ;rfbSetColourMapEntriesMsg * scme = & buf . msg ;uint16_t * rgb = ( uint16_t * ) ( & buf . bytes [ sz_rfbSetColourMapEntriesMsg ] ) ;int i , len ;",4906
1142,"if ( rfbWriteExact ( cl , buf , len ) < 0 ) {rfbLogPerror ( ""rfbSetClientColourMapBGR233:<S2SV_blank>write"" ) ;","if ( rfbWriteExact ( cl , buf . bytes , len ) < 0 ) {rfbLogPerror ( ""rfbSetClientColourMapBGR233:<S2SV_blank>write"" ) ;",4906
1143,char key [ 32 ] = {Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;,size_t vstart_off = i ;char key [ 32 ] = {Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;,4907
1144,if ( vdaux < 1 || vstart + vdaux < vstart ) {sdb_free ( sdb_verdef ) ;vstart += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {,if ( vdaux < 1 || shdr -> sh_size - vstart_off < vdaux ) {sdb_free ( sdb_verdef ) ;vstart += vdaux ;vstart_off += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {,4907
1145,if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,vstart_off += aux . vda_next ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,4907
1146,if ( current -> active_mm != mm )   goto out ;if ( ! current -> mm ) {goto out ;},if ( current -> active_mm != mm ) {smp_mb ( ) ;goto out ;}if ( ! current -> mm ) {smp_mb ( ) ;goto out ;},4908
1147,spin_lock_bh ( & g_cdev . lock ) ;pd = g_cdev . active_pd ;,if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;spin_lock_bh ( & g_cdev . lock ) ;pd = g_cdev . active_pd ;,4909
1148,"free_ep_req ( midi -> out_ep , req ) ;return err ;","if ( req -> buf != NULL ) free_ep_req ( midi -> out_ep , req ) ;return err ;",4910
1149,"handle = server -> connrec -> use_ssl ?  net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey ,  server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ;","handle = server -> connrec -> use_ssl ? net_connect_ip_ssl ( ip , port , server -> connrec -> address , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ;",4911
1150,"if ( frame_is_intra_only ( cm ) ) {active_best_quality = rc -> best_quality ;double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q ,  ( last_boosted_q * 0.75 ) ) ;active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;}else if ( cm -> current_video_frame > 0 ) {double q_adj_factor = 1.0 ;double q_val ;active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] ,   rc -> kf_boost ,  kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val ,  q_val * q_adj_factor ) ;}","int * rtc_minq ;ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ;if ( frame_is_intra_only ( cm ) ) {active_best_quality = rc -> best_quality ;double last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , ( last_boosted_q * 0.75 ) , cm -> bit_depth ) ;active_best_quality = get_kf_active_quality ( rc , rc -> avg_frame_qindex [ KEY_FRAME ] , rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor , cm -> bit_depth ) ;}",4912
1151,"active_best_quality = get_active_quality (  q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ;if ( rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality )  active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ;else  active_best_quality = inter_minq [ active_worst_quality ] ;}if ( rc -> avg_frame_qindex [ KEY_FRAME ] < active_worst_quality )  active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ;else  active_best_quality = inter_minq [ active_worst_quality ] ;}# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY  if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) {if ( ! ( cm -> current_video_frame == 0 ) )  * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ;}","active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ;if ( rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) active_best_quality = rtc_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ;else active_best_quality = rtc_minq [ active_worst_quality ] ;}if ( rc -> avg_frame_qindex [ KEY_FRAME ] < active_worst_quality ) active_best_quality = rtc_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ;else active_best_quality = rtc_minq [ active_worst_quality ] ;}# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced && ! ( cm -> current_video_frame == 0 ) ) {int qdelta = 0 ;vpx_clear_system_state ( ) ;qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ;* top_index = active_worst_quality + qdelta ;* top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index ;}",4912
1152,"size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE ,  CORE_MMU_USER_PARAM_SIZE ) ;if ( ADD_OVERFLOW ( uaddr , len , & a ) )  return TEE_ERROR_ACCESS_DENIED ;for ( a = uaddr ;a < ( uaddr + len ) ;uint32_t attr ;","uaddr_t end_addr = 0 ;size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , CORE_MMU_USER_PARAM_SIZE ) ;if ( ADD_OVERFLOW ( uaddr , len , & end_addr ) ) return TEE_ERROR_ACCESS_DENIED ;for ( a = ROUNDDOWN ( uaddr , addr_incr ) ;a < end_addr ;uint32_t attr ;",4913
1153,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,4914
1154,"old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ;old_eip = ctxt -> _eip ;if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) )  return X86EMUL_CONTINUE ;ctxt -> _eip = 0 ;memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;return em_push ( ctxt ) ;","struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;old_eip = ctxt -> _eip ;ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ;rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ;if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ;rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;if ( rc != X86EMUL_CONTINUE ) goto fail ;rc = em_push ( ctxt ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;return rc ;fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ;return rc ;",4915
1155,"UINT16 count ;BITMAP_DATA * newdata ;count = bitmapUpdate -> number * 2 ;newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles ,  sizeof ( BITMAP_DATA ) * count ) ;","UINT32 count = bitmapUpdate -> number * 2 ;BITMAP_DATA * newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , sizeof ( BITMAP_DATA ) * count ) ;",4916
1156,"if ( buf )   grub_memcpy ( buf , data + pos + real_offset , len ) ;grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ;","if ( buf ) {if ( pos + real_offset + len >= size ) {grub_errno = GRUB_ERR_BAD_FS ;return grub_errno ;}grub_memcpy ( buf , data + pos + real_offset , len ) ;}grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ;",4917
1157,"void * dllhandle ;if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\","void * dllhandle ;if ( COM_CompareExtension ( name , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , name ) ;return NULL ;}if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\",4918
1158,if ( chunk_num > chm -> num_chunks ) return NULL ;if ( ! chm -> chunk_cache ) {,if ( chunk_num >= chm -> num_chunks ) return NULL ;if ( ! chm -> chunk_cache ) {,4919
1159,if ( ! el )  return 0 ;,"if ( ! el ) {if ( c -> rbytes > 1024 ) {char * ptr = c -> rcurr ;while ( * ptr == \'<S2SV_blank>\' ) {++ ptr ;}if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) {conn_set_state ( c , conn_closing ) ;return 1 ;}}return 0 ;}",4920
1160,"rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ;if ( rc -> uwbd . task == NULL )  printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;else  rc -> uwbd . pid = rc -> uwbd . task -> pid ;}","struct task_struct * task = kthread_run ( uwbd , rc , ""uwbd"" ) ;if ( IS_ERR ( task ) ) {rc -> uwbd . task = NULL ;printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;}else {rc -> uwbd . task = task ;rc -> uwbd . pid = rc -> uwbd . task -> pid ;}}",4921
1161,"start = vma -> vm_start ;if ( expand_stack ( vma , addr ) ) return NULL ;","if ( ! mmget_still_valid ( mm ) ) return NULL ;start = vma -> vm_start ;if ( expand_stack ( vma , addr ) ) return NULL ;",4922
1162,for ( i = scm -> fp -> count - 1 ;,"for ( i = scm -> fp -> user , scm -> fp -> count - 1 ;",4923
1163,i -- )  unix_inflight ( scm -> fp -> fp [ i ] ) ;return max_level ;,i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ;return max_level ;,4923
1164,"if ( _PyObject_HasAttrId ( obj , & PyId_arg ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_identifier ( tmp , & arg , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""arg\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ;if ( exists_not_none ( obj , & PyId_annotation ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_annotation ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & annotation , arena ) ;if ( res != 0 ) goto failed ;}else {annotation = NULL ;if ( exists_not_none ( obj , & PyId_type_comment ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & lineno , arena ) ;else {if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_col_offset ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & col_offset , arena ) ;else {","if ( lookup_attr_id ( obj , & PyId_arg ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_arg , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""arg\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ;else {res = obj2ast_identifier ( tmp , & arg , arena ) ;if ( res != 0 ) goto failed ;if ( lookup_attr_id ( obj , & PyId_annotation , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {annotation = NULL ;int res ;res = obj2ast_expr ( tmp , & annotation , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;else {res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( lookup_attr_id ( obj , & PyId_lineno , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {else {res = obj2ast_int ( tmp , & lineno , arena ) ;if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {else {int res ;res = obj2ast_int ( tmp , & col_offset , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4924
1165,"int count , i ;count = be32_to_cpu ( aclp -> acl_cnt ) ;","unsigned int count , i ;count = be32_to_cpu ( aclp -> acl_cnt ) ;",4925
1166,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",4926
1167,"stat ( options -> in_file , & filestats ) ;plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ;","stat ( options -> in_file , & filestats ) ;if ( filestats . st_size < 8 ) {printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\\return - 1 ;}plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ;",4927
1168,if ( client -> priv -> protocol_timeout ) {g_source_remove ( client -> priv -> protocol_timeout ) ;client -> priv -> protocol_timeout = 0 ;},"
",4928
1169,"checkstackp ( L , nextra , where ) ;L -> top = where + nextra ;","checkstackGCp ( L , nextra , where ) ;L -> top = where + nextra ;",4929
1170,MODE_INFO * const mic = xd -> mi [ 0 ] ;const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ;const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;,MODE_INFO * const mic = xd -> above_mi ;const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ;const MODE_INFO * left_mi = xd -> left_mi ;const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;,4930
1171,"const int * bmode_costs = mb -> mbmode_cost ;vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ;vpx_memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ;for ( idy = 0 ;MB_PREDICTION_MODE best_mode = DC_PRED ;int r = INT_MAX , ry = INT_MAX ;const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , i ) ;const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , i ) ;bmode_costs = mb -> y_mode_costs [ A ] [ L ] ;}this_rd = rd_pick_intra4x4block ( cpi , mb , i , & best_mode , bmode_costs , t_above + idx , t_left + idy , & r , & ry , & d , bsize , best_rd - total_rd ) ;","const int * bmode_costs = cpi -> mbmode_cost ;vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ;memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ;for ( idy = 0 ;PREDICTION_MODE best_mode = DC_PRED ;int r = INT_MAX , ry = INT_MAX ;const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , i ) ;const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , i ) ;bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ;}this_rd = rd_pick_intra4x4block ( cpi , mb , idy , idx , & best_mode , bmode_costs , t_above + idx , t_left + idy , & r , & ry , & d , bsize , best_rd - total_rd ) ;",4930
1172,"if ( settings . verbose > 1 ) {fprintf ( stderr , ""%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\\}}if ( c -> protocol == binary_prot ) {if ( c -> rbytes < sizeof ( c -> binary_header ) ) {return 0 ;}else {# ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) {memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ;c -> rcurr = c -> rbuf ;if ( settings . verbose > 1 ) {fprintf ( stderr , ""%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\\}}# endif protocol_binary_request_header * req ;req = ( protocol_binary_request_header * ) c -> rcurr ;if ( settings . verbose > 1 ) {int ii ;fprintf ( stderr , ""<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:"" , c -> sfd ) ;for ( ii = 0 ;ii < sizeof ( req -> bytes ) ;++ ii ) {if ( ii % 4 == 0 ) {fprintf ( stderr , ""\\\}fprintf ( stderr , ""<S2SV_blank>0x%02x"" , req -> bytes [ ii ] ) ;}fprintf ( stderr , ""\\\}c -> binary_header = * req ;c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ;c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ;c -> binary_header . request . cas = ntohll ( req -> request . cas ) ;if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) {if ( settings . verbose ) {fprintf ( stderr , ""Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\\}return - 1 ;}c -> msgcurr = 0 ;c -> msgused = 0 ;c -> iovused = 0 ;if ( add_msghdr ( c ) != 0 ) {out_string ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ;return 0 ;}c -> cmd = c -> binary_header . request . opcode ;c -> keylen = c -> binary_header . request . keylen ;c -> opaque = c -> binary_header . request . opaque ;c -> cas = 0 ;dispatch_bin_command ( c ) ;c -> rbytes -= sizeof ( c -> binary_header ) ;c -> rcurr += sizeof ( c -> binary_header ) ;}}else {char * el , * cont ;if ( c -> rbytes == 0 ) return 0 ;el = memchr ( c -> rcurr , \'\\\if ( ! el ) {if ( c -> rbytes > 1024 ) {char * ptr = c -> rcurr ;while ( * ptr == \'<S2SV_blank>\' ) {++ ptr ;}if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) {conn_set_state ( c , conn_closing ) ;","+ ii ) {if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr , ""get<S2SV_blank>"" , 4 ) && strncmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" , 5 ) ) ) {+ ptr ;",4931
1173,"int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( pos != last_pos ) {","int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( avio_feof ( s -> pb ) ) {ret = AVERROR_INVALIDDATA ;goto end ;}if ( pos != last_pos ) {",4932
1174,static int udp_push_pending_frames ( struct sock * sk )  {,int udp_push_pending_frames ( struct sock * sk ) {,4933
1175,"for ( pass = 0 ;pass < 10 ;proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ;","for ( pass = 0 ;pass < 10 || image ;proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ;",4934
1176,if ( source == target )  return 0 ;,"if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) ) return 0 ;",4935
1177,"bool tsonly ;if ( ! sk ) return ;# ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP &&  sk -> sk_type == SOCK_STREAM )  skb = tcp_get_timestamping_opt_stats ( sk ) ;else  # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ;","bool tsonly , opt_stats = false ;if ( ! sk ) return ;# ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) {skb = tcp_get_timestamping_opt_stats ( sk ) ;opt_stats = true ;}else # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ;",4936
1178,"__skb_complete_tx_timestamp ( skb , sk , tstype ) ;}","__skb_complete_tx_timestamp ( skb , sk , tstype , opt_stats ) ;}",4936
1179,return 0 ;},_TIFFfree ( working_copy ) ;return 0 ;},4937
1180,struct loop_device * lo = disk -> private_data ;int err ;if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ;mutex_lock ( & lo -> lo_ctl_mutex ) ;if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) {err = loop_clr_fd ( lo ) ;if ( ! err ) return ;else if ( lo -> lo_state == Lo_bound ) {blk_mq_freeze_queue ( lo -> lo_queue ) ;blk_mq_unfreeze_queue ( lo -> lo_queue ) ;}mutex_unlock ( & lo -> lo_ctl_mutex ) ;},mutex_lock ( & loop_index_mutex ) ;__lo_release ( disk -> private_data ) ;mutex_unlock ( & lo -> lo_ctl_mutex ) ;,4938
1181,"# if ENABLE_BGP_VNC  case BGP_ATTR_VNC : # endif case BGP_ATTR_ENCAP : ret = bgp_attr_encap ( type , peer , length , attr , flag , startp ) ;","# if ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC : # endif case BGP_ATTR_ENCAP : ret = bgp_attr_encap ( type , peer , length , attr , flag , startp ) ;",4939
1182,"for ( plane = 0 ;inpic -> data [ plane ] && plane < 4 ;h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ;","plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ] ;h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ;",4940
1183,"return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) ,  re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) ;","return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) , 0 , re -> flags | RE_FLAGS_SCAN , NULL , NULL ) ;",4941
1184,"static const u_char *  ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep )  {if ( p [ 0 ] & 0x80 )  totlen = 4 ;else  totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ep < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ;}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ;}return p + totlen ;}","static const u_char * ep2 ) {ND_TCHECK ( p [ 0 ] ) ;if ( p [ 0 ] & 0x80 ) totlen = 4 ;else {ND_TCHECK_16BITS ( & p [ 2 ] ) ;}if ( ep2 < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , totlen - 4 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}return p + totlen ;trunc : return NULL ;}",4942
1185,"( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ;return 1 ;}","return ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ;}",4943
1186,"inl = i2d ( data , NULL ) ;buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ;","if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;goto err ;}inl = i2d ( data , NULL ) ;buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ;",4944
1187,". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = type -> match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , }int ret ;if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ;",". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , }int ret ;if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ;",4945
1188,"if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) {bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ;struct bpf_insn mask_and_div [ ] = {BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , };struct bpf_insn mask_and_mod [ ] = {BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , };struct bpf_insn * patchlet ;if ( insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) {patchlet = mask_and_div + ( is64 ? 1 : 0 ) ;cnt = ARRAY_SIZE ( mask_and_div ) - ( is64 ? 1 : 0 ) ;}else {patchlet = mask_and_mod + ( is64 ? 1 : 0 ) ;cnt = ARRAY_SIZE ( mask_and_mod ) - ( is64 ? 1 : 0 ) ;}new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ;if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) {cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\\return - EINVAL ;}new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ;if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( insn -> code != ( BPF_JMP | BPF_CALL ) )  continue ;if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ;if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ;if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ;if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ;if ( insn -> imm == BPF_FUNC_tail_call ) {prog -> cb_access = 1 ;env -> prog -> aux -> stack_depth = MAX_BPF_STACK ;env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ;insn -> imm = 0 ;insn -> code = BPF_JMP | BPF_TAIL_CALL ;if ( ! bpf_map_ptr_unpriv ( aux ) )  continue ;if ( bpf_map_ptr_poisoned ( aux ) ) {verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\\","if ( insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) {const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ;const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ;struct bpf_insn insn_buf [ 16 ] ;struct bpf_insn * patch = & insn_buf [ 0 ] ;bool issrc , isneg ;u32 off_reg ;if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ;if ( bpf_map_ptr_poisoned ( aux ) ) {verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\\",4946
1189,"if ( prog -> jit_requested && BITS_PER_LONG == 64 &&  ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) {if ( bpf_map_ptr_poisoned ( aux ) )   goto patch_call_imm ;map_ptr = BPF_MAP_PTR ( aux -> map_state ) ;ops = map_ptr -> ops ;if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) {cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {","if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) {if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ;map_ptr = BPF_MAP_PTR ( aux -> map_state ) ;ops = map_ptr -> ops ;if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) {cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {",4946
1190,"BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem ,  ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ;","BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ;",4946
1191,iterator = rfbGetClientIterator ( rfbScreen ) ;while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) {,"memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ;iterator = rfbGetClientIterator ( rfbScreen ) ;while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) {",4947
1192,"if ( Stream_GetRemainingLength ( s ) < 2 )  return FALSE ;Stream_Read_UINT16 ( s , * length ) ;if ( * length == 0x8000 )  {rdp_read_flow_control_pdu ( s , type ) ;* channel_id = 0 ;if ( ( ( size_t ) * length - 2 ) > Stream_GetRemainingLength ( s ) )  return FALSE ;if ( * length > 4 )  Stream_Read_UINT16 ( s , * channel_id ) ;","UINT16 len ;if ( Stream_GetRemainingLength ( s ) < 2 ) return FALSE ;Stream_Read_UINT16 ( s , len ) ;* length = len ;if ( len == 0x8000 ) {if ( ! rdp_read_flow_control_pdu ( s , type ) ) return FALSE ;* channel_id = 0 ;if ( ( len < 4 ) || ( ( len - 2 ) > Stream_GetRemainingLength ( s ) ) ) return FALSE ;if ( len > 4 ) Stream_Read_UINT16 ( s , * channel_id ) ;",4948
1193,"err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ;if ( err < 0 ) {","err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCGIFHWADDR , & ifr ) ) ;if ( err < 0 ) {",4949
1194,"err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ;if ( err < 0 ) {","err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ) ;if ( err < 0 ) {",4949
1195,"err = ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ;if ( err < 0 ) {","err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ) ;if ( err < 0 ) {",4949
1196,"int get_down2_steps ( int in_length , int out_length ) {int steps = 0 ;","static int get_down2_steps ( int in_length , int out_length ) {int steps = 0 ;",4950
1197,"if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Cherry<S2SV_blank>Cymotion<S2SV_blank>report<S2SV_blank>descriptor\\\","if ( * rsize >= 18 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Cherry<S2SV_blank>Cymotion<S2SV_blank>report<S2SV_blank>descriptor\\\",4951
1198,prefix = report [ i ] ;i ++ ;size = PREF_SIZE ( prefix ) ;case 2 : data16 = get_unaligned_le16 ( & report [ i ] ) ;break ;case 3 :  size = 4 ;data32 = get_unaligned_le32 ( & report [ i ] ) ;,"prefix = report [ i ++ ] ;size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ;if ( i + size > length ) {dev_err ( ddev , ""Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\\break ;}case 4 : data32 = get_unaligned_le32 ( & report [ i ] ) ;",4952
1199,# ifndef PGEN  Py_INCREF ( err_ret -> filename ) ;,if ( * flags & PyPARSE_TYPE_COMMENTS ) {tok -> type_comments = 1 ;}# ifndef PGEN Py_INCREF ( err_ret -> filename ) ;,4953
1200,"static void set_segment_id ( VP9_COMMON * cm , BLOCK_SIZE bsize ,  int mi_row , int mi_col , int segment_id ) {const int mi_offset = mi_row * cm -> mi_cols + mi_col ;const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;for ( y = 0 ;y < ymis ;y ++ )   for ( x = 0 ;x < xmis ;x ++ )   cm -> last_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ;}","static void set_segment_id ( VP9_COMMON * cm , int mi_offset , int x_mis , int y_mis , int segment_id ) {const int mi_offset = mi_row * cm -> mi_cols + mi_col ;const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;for ( y = 0 ;y < y_mis ;y ++ ) for ( x = 0 ;x < x_mis ;x ++ ) cm -> current_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ;}",4954
1201,"if ( keyring ) {if ( keyring -> restrict_link ) return - EPERM ;link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ;}mutex_lock ( & key_construction_mutex ) ;if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {atomic_inc ( & key -> user -> nikeys ) ;key -> reject_error = - error ;smp_wmb ( ) ;",if ( key -> state == KEY_IS_UNINSTANTIATED ) {atomic_inc ( & key -> user -> nikeys ) ;key -> reject_error = - error ;smp_wmb ( ) ;,4955
1202,"size_t i , maxcount ;const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ;","size_t maxcount ;const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ;",4956
1203,"ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ;* count = 0 ;for ( i = 0 ;i < CDF_TOLE4 ( si -> si_count ) ;i ++ ) {if ( i >= CDF_LOOP_LIMIT ) {DPRINTF ( ( ""Unpack<S2SV_blank>summary<S2SV_blank>info<S2SV_blank>loop<S2SV_blank>limit"" ) ) ;errno = EFTYPE ;if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) ,  info , count , & maxcount ) == - 1 ) {return - 1 ;}}","ssi -> si_count = CDF_TOLE4 ( si -> si_count ) ;* count = 0 ;if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) , info , count , & maxcount ) == - 1 ) {}",4956
1204,"static inline void header_put_byte ( SF_PRIVATE * psf , char x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 1 )   psf -> header [ psf -> headindex ++ ] = x ;}","static inline void header_put_byte ( SF_PRIVATE * psf , char x ) {psf -> header ) - 1 ) psf -> header [ psf -> headindex ++ ] = x ;}",4957
1205,"Total += vp8_mse16x16 ( src + j , source -> y_stride ,  dst + j , dest -> y_stride , & sse ) ;","Total += vpx_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ;",4958
1206,calldata -> arg . fh = NFS_FH ( state -> inode ) ;calldata -> arg . stateid = & state -> open_stateid ;calldata -> arg . seqid = nfs_alloc_seqid ( & state -> owner -> so_seqid ) ;if ( calldata -> arg . seqid == NULL ) goto out_free_calldata ;calldata -> arg . open_flags = 0 ;calldata -> arg . bitmask = server -> attr_bitmask ;,calldata -> arg . fmode = 0 ;calldata -> arg . bitmask = server -> attr_bitmask ;,4959
1207,"ext4_io_end_t * io ;int ret = 0 ;if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) )  return ret ;while ( ! list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) {io = list_entry ( EXT4_I ( inode ) -> i_completed_io_list . next ,  ext4_io_end_t , list ) ;ret = ext4_end_io_nolock ( io ) ;if ( ret < 0 ) ret2 = ret ;return ( ret2 < 0 ) ? ret2 : 0 ;}","ext4_io_end_t * io ;struct ext4_inode_info * ei = EXT4_I ( inode ) ;unsigned long flags ;int ret = 0 ;if ( list_empty ( & ei -> i_completed_io_list ) ) return ret ;spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ;while ( ! list_empty ( & ei -> i_completed_io_list ) ) {io = list_entry ( ei -> i_completed_io_list . next , ext4_io_end_t , list ) ;spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;ret = ext4_end_io_nolock ( io ) ;spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ;if ( ret < 0 ) ret2 = ret ;spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;return ( ret2 < 0 ) ? ret2 : 0 ;}",4960
1208,"int __usb_get_extra_descriptor ( char * buffer , unsigned size ,  unsigned char type , void * * ptr )  {if ( header -> bLength < 2 ) {printk ( KERN_ERR ""%s:<S2SV_blank>bogus<S2SV_blank>descriptor,<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\\if ( header -> bDescriptorType == type ) {* ptr = header ;","int __usb_get_extra_descriptor ( char * buffer , unsigned size , unsigned char type , void * * ptr , size_t minsize ) {if ( header -> bLength < 2 || header -> bLength > size ) {printk ( KERN_ERR ""%s:<S2SV_blank>bogus<S2SV_blank>descriptor,<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\\if ( header -> bDescriptorType == type && header -> bLength >= minsize ) {* ptr = header ;",4961
1209,"sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ;outfile = fopen ( outfilename , ""wb"" ) ;fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\\return 1 ;","{int num = snprintf ( outfilename , sizeof ( outfilename ) , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ;if ( num >= sizeof ( outfilename ) ) {fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\\free ( frame_codestream ) ;return 1 ;}}outfile = fopen ( outfilename , ""wb"" ) ;fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\\free ( frame_codestream ) ;return 1 ;",4962
1210,if ( j >= length ) return - 1 ;GET8 ( label_len ) ;,GET8 ( label_len ) ;,4963
1211,"
",if ( j + label_len > length ) return - 1 ;,4963
1212,"memcpy ( cp , packet + j , label_len ) ;cp += label_len ;","memcpy ( cp , packet + j , label_len ) ;cp += label_len ;",4963
1213,"if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>MSG"" ) ) ;else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>RPY"" ) ) ;else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ERR"" ) ) ;else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ANS"" ) ) ;else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>NUL"" ) ) ;else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>SEQ"" ) ) ;else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>END"" ) ) ;","if ( l_strnstart ( ndo , ""MSG"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>MSG"" ) ) ;else if ( l_strnstart ( ndo , ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>RPY"" ) ) ;else if ( l_strnstart ( ndo , ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ERR"" ) ) ;else if ( l_strnstart ( ndo , ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ANS"" ) ) ;else if ( l_strnstart ( ndo , ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>NUL"" ) ) ;else if ( l_strnstart ( ndo , ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>SEQ"" ) ) ;else if ( l_strnstart ( ndo , ""END"" , 4 , ( const char * ) bp , length ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>END"" ) ) ;",4964
1214,subsampling_dx = parameters -> subsampling_dx ;subsampling_dy = parameters -> subsampling_dy ;,"if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) {char ch ;OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ;long curpos = ftell ( f ) ;if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) {expected_file_size = ( OPJ_UINT64 ) INT_MAX ;}fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ;if ( fread ( & ch , 1 , 1 , f ) != 1 ) {fclose ( f ) ;return NULL ;}fseek ( f , curpos , SEEK_SET ) ;}subsampling_dx = parameters -> subsampling_dx ;subsampling_dy = parameters -> subsampling_dy ;",4965
1215,"snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;","strncpy ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;",4966
1216,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;buf [ 0 ] = CP2112_GPIO_SET ;spin_unlock_irqrestore ( & dev -> lock , flags ) ;}","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;buf [ 0 ] = CP2112_GPIO_SET ;mutex_unlock ( & dev -> lock , flags ) ;}",4967
1217,"var = vp8_variance16x16  ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ;","var = vpx_variance16x16 ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ;",4968
1218,"int mongo_env_read_socket ( mongo * conn , void * buf , int len ) {char * cbuf = buf ;int sent = recv ( conn -> sock , cbuf , len , 0 ) ;if ( sent == 0 || sent == - 1 ) {","int mongo_env_read_socket ( mongo * conn , void * buf , size_t len ) {char * cbuf = buf ;size_t sent = recv ( conn -> sock , cbuf , len , 0 ) ;if ( sent == 0 || sent == - 1 ) {",4969
1219,char added ;},},4970
1220,pair -> added = 0 ;for ( it = tmp_subnodes -> first ;,for ( it = tmp_subnodes -> first ;,4970
1221,vpx_free ( cr ) ;},vpx_free ( cr -> last_coded_q_map ) ;vpx_free ( cr ) ;},4971
1222,return in ;},return NULL ;},4972
1223,if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) &&  value [ n ] >= min && value [ n ] <= max &&  field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ;,if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && value [ n ] >= min && value [ n ] <= max && value [ n ] - min < field -> maxusage && field -> value [ n ] - min < field -> maxusage && field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ;,4973
1224,"if ( field -> value [ n ] >= min && field -> value [ n ] <= max  && field -> usage [ field -> value [ n ] - min ] . hid  && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ;if ( value [ n ] >= min && value [ n ] <= max  && field -> usage [ value [ n ] - min ] . hid  && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ;","if ( field -> value [ n ] >= min && field -> value [ n ] <= max && value [ n ] - min < field -> maxusage && field -> usage [ field -> value [ n ] - min ] . hid && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ;if ( value [ n ] >= min && value [ n ] <= max && field -> usage [ value [ n ] - min ] . hid && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ;",4973
1225,x += 8 ) {for ( bit = 0 ;bit < 8 ;bit ++ ) {,x += 4 ) {,4974
1226,for ( x = 0 ;x += 2 )  {,for ( x = 0 ;x += 2 ) {,4974
1227,"case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ;w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ;if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ;return 1 ;case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ;cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ;w = cpu -> type ;if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ;return 1 ;case GSI_GET_HWRPB :  if ( nbytes < sizeof ( * hwrpb ) )  return - EINVAL ;",case GSI_UACPROC : if ( nbytes > sizeof ( * hwrpb ) ) return - EINVAL ;,4975
1228,"list_del ( & key -> graveyard_link ) ;kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) &&  ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ;","short state = key -> state ;list_del ( & key -> graveyard_link ) ;kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ;if ( state == KEY_IS_POSITIVE && key -> type -> destroy ) key -> type -> destroy ( key ) ;",4976
1229,"if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) )  atomic_dec ( & key -> user -> nikeys ) ;",if ( state != KEY_IS_UNINSTANTIATED ) atomic_dec ( & key -> user -> nikeys ) ;,4976
1230,"if ( mwifiex_map_pci_memory ( adapter , skb , MWIFIEX_UPLD_SIZE ,  PCI_DMA_FROMDEVICE ) )   return - 1 ;card -> cmdrsp_buf = skb ;","if ( mwifiex_map_pci_memory ( adapter , skb , MWIFIEX_UPLD_SIZE , PCI_DMA_FROMDEVICE ) ) {kfree_skb ( skb ) ;return - 1 ;}card -> cmdrsp_buf = skb ;",4977
1231,assert ( bi != NULL ) ;si = & bi -> slotinfo [ dev -> slot ] ;,"if ( bi == NULL ) {pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\\return ;}si = & bi -> slotinfo [ dev -> slot ] ;",4978
1232,"if ( access ( path , F_OK ) ) {","if ( safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount ) ) {",4979
1233,"if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) {ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\\\'%s\\\'<S2SV_blank>on<S2SV_blank>\\\'%s\\\'"" , console -> name , path ) ;","if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) {ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\\\'%s\\\'<S2SV_blank>on<S2SV_blank>\\\'%s\\\'"" , console -> name , path ) ;",4979
1234,"if ( wp -> listening_socket != STDIN_FILENO ) {if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) {zlog ( ZLOG_SYSERROR , ""failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>child<S2SV_blank>stdio:<S2SV_blank>dup2()"" ) ;return - 1 ;}}","
",4980
1235,scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ;if ( ! newscratch ) {}eob_sent = smtp -> eob ;,scratch = newscratch = malloc ( 2 * UPLOAD_BUFSIZE ) ;if ( ! newscratch ) {}DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;eob_sent = smtp -> eob ;,4981
1236,"struct vp9_ref_frame ref ;ref . idx = 0 ;vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref ) ;enc_img = ref . img ;vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref ) ;dec_img = ref . img ;find_mismatch ( & enc_img , & dec_img , y , u , v ) ;stream -> decoder . err = 1 ;","struct vp9_ref_frame ref_enc , ref_dec ;ref_enc . idx = 0 ;ref_dec . idx = 0 ;vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref_enc ) ;enc_img = ref_enc . img ;vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref_dec ) ;dec_img = ref_dec . img ;# if CONFIG_VP9_HIGHBITDEPTH if ( ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) != ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ) {if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) {vpx_img_alloc ( & enc_img , enc_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , enc_img . d_w , enc_img . d_h , 16 ) ;vpx_img_truncate_16_to_8 ( & enc_img , & ref_enc . img ) ;}if ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) {vpx_img_alloc ( & dec_img , dec_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , dec_img . d_w , dec_img . d_h , 16 ) ;vpx_img_truncate_16_to_8 ( & dec_img , & ref_dec . img ) ;}# endif }# if CONFIG_VP9_HIGHBITDEPTH if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) {find_mismatch_high ( & enc_img , & dec_img , y , u , v ) ;}# else find_mismatch ( & enc_img , & dec_img , y , u , v ) ;# endif }else {find_mismatch ( & enc_img , & dec_img , y , u , v ) ;stream -> decoder . err = 1 ;",4982
1237,"static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image )  {size_t  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ;( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;for ( i = 0 ;i ++ )  {pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns ,  sizeof ( * * pixels ) ) ;for ( j = 0 ;j < ( ssize_t ) image -> columns ;j ++ )   GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ;}","static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) {const Image * next ;size_t columns , number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;columns = images -> columns ;for ( next = images ;next != ( Image * ) NULL ;next = next -> next ) columns = MagickMax ( next -> columns , columns ) ;for ( i = 0 ;i ++ ) {pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ;for ( j = 0 ;j < ( ssize_t ) columns ;j ++ ) GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ;}",4983
1238,"static void  swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horDiff16 ( tif , cp0 , cc ) ;TIFFSwabArrayOfShort ( wp , wc ) ;}","static int swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ! horDiff16 ( tif , cp0 , cc ) ) return 0 ;TIFFSwabArrayOfShort ( wp , wc ) ;return 1 ;}",4984
1239,return 0 ;},hrtimer_try_to_cancel ( & stime -> hrt ) ;return 0 ;},4985
1240,"found :  if ( f -> map & ( 1 << rec ) ) {ldm_error ( ""Duplicate<S2SV_blank>VBLK,<S2SV_blank>part<S2SV_blank>%d."" , rec ) ;","found : if ( rec >= f -> num ) {ldm_error ( ""REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)"" , rec , f -> num ) ;return false ;}if ( f -> map & ( 1 << rec ) ) {ldm_error ( ""Duplicate<S2SV_blank>VBLK,<S2SV_blank>part<S2SV_blank>%d."" , rec ) ;",4986
1241,"static void estimate_ref_frame_costs ( VP9_COMP * cpi , int segment_id ,  unsigned int * ref_costs_single , unsigned int * ref_costs_comp ,  vp9_prob * comp_mode_p ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;vpx_memset ( ref_costs_comp , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_comp ) ) ;* comp_mode_p = 128 ;vp9_prob intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ;vp9_prob comp_inter_p = 128 ;if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {","static void estimate_ref_frame_costs ( const VP9_COMMON * cm , const MACROBLOCKD * xd , int segment_id , unsigned int * ref_costs_single , unsigned int * ref_costs_comp , vpx_prob * comp_mode_p ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;memset ( ref_costs_comp , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_comp ) ) ;* comp_mode_p = 128 ;vpx_prob intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ;vpx_prob comp_inter_p = 128 ;if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {",4987
1242,"vp9_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ;vp9_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ;unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ;","vpx_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ;vpx_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ;unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ;",4987
1243,"vp9_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ;unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ;","vpx_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ;unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ;",4987
1244,"int i , j ;* x ++ = marker ;","int i , j ;# ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ;int mag_test = 2 ;int frames_test = 4 ;int index_sz_test = 2 + mag_test * frames_test ;marker_test |= frames_test - 1 ;marker_test |= ( mag_test - 1 ) << 3 ;* x ++ = marker_test ;for ( i = 0 ;i < mag_test * frames_test ;++ i ) * x ++ = 0 ;* x ++ = marker_test ;ctx -> pending_cx_data_sz += index_sz_test ;printf ( ""Added<S2SV_blank>supplemental<S2SV_blank>superframe<S2SV_blank>data\\\# endif * x ++ = marker ;",4988
1245,}return index_sz ;,# ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ;# endif }return index_sz ;,4988
1246,while ( c -> chunked_encoding && ! c -> chunk_size && c -> buffer_end > c -> buffer_ptr ) {,while ( c -> chunked_encoding && ! c -> chunk_size <= 0 ) {c -> chunk_size = 0 ;goto fail ;}c -> buffer_ptr ) {,4989
1247,if ( c -> chunk_size == 0 )  goto fail ;,if ( c -> chunk_size == 0 ) goto fail ;,4989
1248,else {c -> chunk_size -= len ;,else {av_assert0 ( len <= c -> chunk_size ) ;c -> chunk_size -= len ;,4989
1249,"if ( ! er )  ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ;return ;",if ( ! er ) {ND_TCHECK ( dp [ 0 ] ) ) ) ;return ;,4990
1250,struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ;struct extent_tree * et ;struct extent_node * en ;struct extent_info ei ;if ( ! f2fs_may_extent_tree ( inode ) ) {if ( i_ext && i_ext -> len ) {i_ext -> len = 0 ;return true ;}return false ;}et = __grab_extent_tree ( inode ) ;if ( ! i_ext || ! i_ext -> len )  return false ;,"bool ret = __f2fs_init_extent_tree ( inode , i_ext ) ;if ( ! i_ext || ! i_ext -> len ) return false ;",4991
1251,return false ;},return ret ;},4991
1252,# define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL )  # define PCDGetBits ( n ) {,# define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) # define PCDGetBits ( n ) \\\\\,4992
1253,}typedef struct PCDTable {,\\\\\typedef struct PCDTable {,4992
1254,"ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" ,  image -> filename ) ;","for ( j = 0 ;j < i ;j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ;ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;",4992
1255,buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;return ( MagickFalse ) ;,buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;for ( j = 0 ;j <= i ;j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ;return ( MagickFalse ) ;,4992
1256,"int i , y ;for ( i = 0 ;","int i , y ;# if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ;# else const int bytes_per_sample = 1 ;# endif for ( i = 0 ;",4993
1257,"fwrite ( buf , 1 , w , file ) ;buf += stride ;","fwrite ( buf , bytes_per_sample , w , file ) ;buf += stride ;",4993
1258,"uint8_t clear_buffer [ 9 ] ;if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ;if ( decrypt_cb ) {data_sz = VPXMIN ( sizeof ( clear_buffer ) , data_sz ) ;decrypt_cb ( decrypt_state , data , clear_buffer , data_sz ) ;data = clear_buffer ;}{int show_frame ;int error_resilient ;struct vpx_read_bit_buffer rb = {data , data + data_sz , 0 , NULL , NULL };const int frame_marker = vpx_rb_read_literal ( & rb , 2 ) ;const BITSTREAM_PROFILE profile = vp9_read_profile ( & rb ) ;if ( frame_marker != VP9_FRAME_MARKER ) return VPX_CODEC_UNSUP_BITSTREAM ;if ( profile >= MAX_PROFILES ) return VPX_CODEC_UNSUP_BITSTREAM ;if ( ( profile >= 2 && data_sz <= 1 ) || data_sz < 1 )  return VPX_CODEC_UNSUP_BITSTREAM ;if ( data_sz <= 8 )  return VPX_CODEC_UNSUP_BITSTREAM ;",uint8_t clear_buffer [ 10 ] ;if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ;if ( vpx_rb_read_bit ( & rb ) ) {if ( profile > 2 && data_sz <= 1 ) || data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ;if ( data_sz <= 8 ) return VPX_CODEC_UNSUP_BITSTREAM ;,4994
1259,"# endif # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ;# endif  openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ;","# endif umask ( 022 ) ;# ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ;# endif openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ;",4995
1260,"}if ( ! os_major ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>%s"" , uname_buf . release ) ;if ( ! config_id ) {end = strchrnul ( uname_buf . nodename , \'.\' ) ;config_id = MALLOC ( ( size_t ) ( end - uname_buf . nodename ) + 1 ) ;strncpy ( config_id , uname_buf . nodename , ( size_t ) ( end - uname_buf . nodename ) ) ;config_id [ end - uname_buf . nodename ] = \'\\\\0\' ;}}if ( parse_cmdline ( argc , argv ) ) {closelog ( ) ;if ( ! __test_bit ( NO_SYSLOG_BIT , & debug ) ) openlog ( PACKAGE_NAME , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ;}if ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) enable_console_log ( ) ;# ifdef GIT_COMMIT log_message ( LOG_INFO , ""Starting<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s"" , version_string , GIT_COMMIT ) ;# else log_message ( LOG_INFO , ""Starting<S2SV_blank>%s"" , version_string ) ;# endif core_dump_init ( ) ;if ( os_major ) {if ( KERNEL_VERSION ( os_major , os_minor , os_release ) < LINUX_VERSION_CODE ) {log_message ( LOG_INFO , ""WARNING<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>was<S2SV_blank>build<S2SV_blank>for<S2SV_blank>newer<S2SV_blank>Linux<S2SV_blank>%d.%d.%d,<S2SV_blank>running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff , uname_buf . sysname , uname_buf . release , uname_buf . version ) ;}else {log_message ( LOG_INFO , ""Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>(built<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d)"" , uname_buf . sysname , uname_buf . release , uname_buf . version , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ;}}# ifndef _DEBUG_ log_command_line ( 0 ) ;# endif if ( ! check_conf_file ( conf_file ) ) {if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) config_test_exit ( ) ;goto end ;}global_data = alloc_global_data ( ) ;read_config_file ( ) ;init_global_data ( global_data , NULL ) ;# if HAVE_DECL_CLONE_NEWNET if ( override_namespace ) {if ( global_data -> network_namespace ) {log_message ( LOG_INFO , ""Overriding<S2SV_blank>config<S2SV_blank>net_namespace<S2SV_blank>\\\'%s\\\'<S2SV_blank>with<S2SV_blank>command<S2SV_blank>line<S2SV_blank>namespace<S2SV_blank>\\\'%s\\\'"" , global_data -> network_namespace , override_namespace ) ;FREE ( global_data -> network_namespace ) ;}global_data -> network_namespace = override_namespace ;override_namespace = NULL ;}# endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) && ( global_data -> instance_name # if HAVE_DECL_CLONE_NEWNET || global_data -> network_namespace # endif ) ) {if ( ( syslog_ident = make_syslog_ident ( PACKAGE_NAME ) ) ) {log_message ( LOG_INFO , ""Changing<S2SV_blank>syslog<S2SV_blank>ident<S2SV_blank>to<S2SV_blank>%s"" , syslog_ident ) ;closelog ( ) ;openlog ( syslog_ident , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ;}else log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>syslog<S2SV_blank>ident"" ) ;use_pid_dir = true ;open_log_file ( log_file_name , NULL , # if HAVE_DECL_CLONE_NEWNET global_data -> network_namespace , # else NULL , # endif global_data -> instance_name ) ;}set_child_finder_name ( find_keepalived_child_name ) ;if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) {if ( use_pid_dir ) {create_pid_dir ( ) ;}}# if HAVE_DECL_CLONE_NEWNET if ( global_data -> network_namespace ) {if ( global_data -> network_namespace && ! set_namespaces ( global_data -> network_namespace ) ) {log_message ( LOG_ERR , ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>exiting"" , global_data -> network_namespace ) ;goto end ;}}# endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) {if ( global_data -> instance_name ) {if ( ! main_pidfile && ( main_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_main_pidfile = true ;# ifdef _WITH_LVS_ if ( ! checkers_pidfile && ( checkers_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR CHECKERS_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_checkers_pidfile = true ;# endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile && ( vrrp_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_vrrp_pidfile = true ;# endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile && ( bfd_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_bfd_pidfile = true ;# endif }if ( use_pid_dir ) {if ( ! main_pidfile ) main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ;# ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION ;# endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION ;# endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION ;# endif }else {if ( ! main_pidfile ) main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ;# ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION ;# endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION ;# endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION ;# endif }if ( keepalived_running ( daemon_mode ) ) {log_message ( LOG_INFO , ""daemon<S2SV_blank>is<S2SV_blank>already<S2SV_blank>running"" ) ;report_stopped = false ;goto end ;}}if ( ! __test_bit ( DONT_FORK_BIT , & debug ) && xdaemon ( false , false , true ) > 0 ) {closelog ( ) ;FREE_PTR ( config_id ) ;FREE_PTR ( orig_core_dump_pattern ) ;close_std_fd ( ) ;exit ( 0 ) ;}umask ( 0 ) ;# ifdef _MEM_CHECK_ enable_mem_log_termination ( ) ;",# ifdef _MEM_CHECK_ enable_mem_log_termination ( ) ;,4995
1261,"ut8 * directory_base ;struct minidump_directory * entry ;directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ;for ( i = 0 ;entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ;r_bin_mdmp_init_directory_entry ( obj , entry ) ;}","struct minidump_directory entry ;ut64 rvadir = obj -> hdr -> stream_directory_rva ;for ( i = 0 ;ut32 delta = i * sizeof ( struct minidump_directory ) ;int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory ) ) ;if ( r ) {r_bin_mdmp_init_directory_entry ( obj , & entry ) ;}}",4996
1262,"Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",4997
1263,"if ( ! lp || ! timestring || ! timefield )  return MS_FALSE ;if ( strstr ( timestring , "","" ) == NULL && strstr ( timestring , ""/"" ) == NULL ) {","if ( ! lp || ! timestring || ! timefield ) return MS_FALSE ;if ( strchr ( timestring , \'\\\\\'\' ) || strchr ( timestring , \'\\\\\\\\\' ) ) {msSetError ( MS_MISCERR , ""Invalid<S2SV_blank>time<S2SV_blank>filter."" , ""msPostGISLayerSetTimeFilter()"" ) ;return MS_FALSE ;}if ( strstr ( timestring , "","" ) == NULL && strstr ( timestring , ""/"" ) == NULL ) {",4998
1264,struct kvm_lapic * apic = vcpu -> arch . apic ;void * vapic ;,struct kvm_lapic * apic = vcpu -> arch . apic ;,4999
1265,vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;* ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ;kunmap_atomic ( vapic ) ;,"kvm_write_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ;",4999
1266,"gint * ac ;ac = g_new0 ( gint , bpp ) ;","gint * ac ;g_assert ( box_width > 0 ) ;ac = g_new0 ( gint , bpp ) ;",5000
1267,struct tcp_sock_t * tcp_socket ;while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL &&   g_options . only_desired_port == 0 ) {desired_port ++ ;}if ( tcp_socket == NULL ) goto cleanup_tcp ;uint16_t real_port = tcp_port_number_get ( tcp_socket ) ;if ( desired_port != 0 && g_options . only_desired_port == 1 && desired_port != real_port ) {uint16_t pid ;if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) {,"struct tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ;for ( ;;) {tcp_socket = tcp_open ( desired_port ) ;tcp6_socket = tcp6_open ( desired_port ) ;if ( tcp_socket || tcp6_socket || g_options . only_desired_port ) break ;desired_port ++ ;NOTE ( ""Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d"" , desired_port ) ;}if ( tcp_socket == NULL && tcp6_socket == NULL ) goto cleanup_tcp ;uint16_t real_port ;if ( tcp_socket ) real_port = tcp_port_number_get ( tcp_socket ) ;else real_port = tcp_port_number_get ( tcp6_socket ) ;if ( desired_port != 0 && g_options . only_desired_port == 1 && desired_port != real_port ) {NOTE ( ""Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable"" , real_port , tcp_socket ? """" : ""not<S2SV_blank>"" , tcp6_socket ? """" : ""not<S2SV_blank>"" ) ;uint16_t pid ;if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) {",5001
1268,args -> tcp = tcp_conn_accept ( tcp_socket ) ;if ( args -> tcp == NULL ) {,"args -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket ) ;if ( args -> tcp == NULL ) {",5001
1269,cleanup_usb :  if ( usb_sock != NULL ) usb_close ( usb_sock ) ;,if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;cleanup_usb : if ( usb_sock != NULL ) usb_close ( usb_sock ) ;,5001
1270,static int done ;if ( done ) return ;for ( c = 'a' ;c <= 'z' ;c ++ )  re_syntax_table [ c ] = Sword ;,static int done = 0 ;if ( done ) return ;for ( c = 0 ;c < CHAR_SET_SIZE ;++ c ) if ( ISALNUM ( c ) ) re_syntax_table [ c ] = Sword ;,5002
1271,"YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ;vpx_memset ( frame_stats -> mb_stats , 0 ,  cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ;for ( i = 0 ;i < n_frames ;i ++ ) {MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ;struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ;assert ( q_cur != NULL ) ;update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , golden_ref , cpi -> Source ) ;}vp9_clear_system_state ( ) ;separate_arf_mbs ( cpi ) ;","YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;assert ( golden_ref != NULL ) ;if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ;memset ( frame_stats -> mb_stats , 0 , cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ;vpx_clear_system_state ( ) ;separate_arf_mbs ( cpi ) ;",5003
1272,dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ;for ( i = 0 ;,"dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ;if ( iface_desc -> desc . bNumEndpoints < 1 ) {dev_err ( & interface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\\retval = - EINVAL ;goto error ;}for ( i = 0 ;",5004
1273,"exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ;return 0 ;","exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ;return 0 ;}if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) {exit_client ( client_p , client_p , client_p , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;return 0 ;",5005
1274,"bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;switch ( rsvp_obj_ctype ) {case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ;ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" ,  ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ;","switch ( rsvp_obj_ctype ) {case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ;bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ;",5006
1275,struct sock * sk = sock -> sk ;struct sockaddr_mISDN * maddr ;if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) {msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ;maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ;,struct sock * sk = sock -> sk ;if ( msg -> msg_name ) {struct sockaddr_mISDN * maddr = msg -> msg_name ;,5007
1276,"}else {if ( msg -> msg_namelen )  printk ( KERN_WARNING ""%s:<S2SV_blank>too<S2SV_blank>small<S2SV_blank>namelen<S2SV_blank>%d\\\msg -> msg_namelen = 0 ;","msg -> msg_namelen ) printk ( KERN_WARNING ""%s:<S2SV_blank>too<S2SV_blank>small<S2SV_blank>namelen<S2SV_blank>%d\\\",5007
1277,"if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;up_write ( & key -> sem ) ;","if ( ret == 0 ) mark_key_instantiated ( key , 0 ) ;up_write ( & key -> sem ) ;",5008
1278,"
",rcu_read_lock ( ) ;,5009
1279,"final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",5009
1280,struct sock * sk = sock -> sk ;struct sockaddr_mISDN * maddr ;if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) {msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ;maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ;,struct sock * sk = sock -> sk ;if ( msg -> msg_name ) {struct sockaddr_mISDN * maddr = msg -> msg_name ;,5010
1281,"}else {if ( msg -> msg_namelen )  printk ( KERN_WARNING ""%s:<S2SV_blank>too<S2SV_blank>small<S2SV_blank>namelen<S2SV_blank>%d\\\msg -> msg_namelen = 0 ;","msg -> msg_namelen ) printk ( KERN_WARNING ""%s:<S2SV_blank>too<S2SV_blank>small<S2SV_blank>namelen<S2SV_blank>%d\\\",5010
1282,bool slow ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,bool slow ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,5011
1283,"}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",5011
1284,"register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ;ND_PRINT ( ( ndo , ""\\\","register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ;ND_TCHECK_32BITS ( & hellop -> hello_options ) ;ND_PRINT ( ( ndo , ""\\\",5012
1285,"case 0 :  # ifdef HAVE_ZLIB_H case 8 : # endif break ;archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" ,  ( intmax_t ) rsrc -> uncompressed_size ) ;return ( ARCHIVE_WARN ) ;","case 0 : if ( rsrc -> uncompressed_size ) ;return ( ARCHIVE_WARN ) ;}if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> compressed_size != rsrc -> compressed_size ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size"" ) ;return ( ARCHIVE_FATAL ) ;}# ifdef HAVE_ZLIB_H case 8 : # endif break ;archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> uncompressed_size ) ;return ( ARCHIVE_WARN ) ;",5013
1286,"case 0 :  memcpy ( mp , p , bytes_avail ) ;bytes_used = ( size_t ) bytes_avail ;","case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;memcpy ( mp , p , bytes_avail ) ;bytes_used = ( size_t ) bytes_avail ;",5013
1287,if ( oxcf -> number_of_layers > 1 ) {unsigned int i ;double prev_layer_framerate = 0 ;assert ( oxcf -> number_of_layers <= VPX_TS_MAX_LAYERS ) ;for ( i = 0 ;i < oxcf -> number_of_layers ;i ++ )  {,if ( oxcf -> number_of_layers && i < VPX_TS_MAX_LAYERS ;++ i ) {,5014
1288,"return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL ,  & sa , NULL ) ;","return aa_audit ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL ) ;",5015
1289,"case LLDP_PRIVATE_8023_SUBTYPE_MTU :  ND_PRINT ( ( ndo , ""\\\break ;","case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;",5016
1290,"res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release ,  cb_priv ) ;","res = ctx -> iface -> dec . set_fb_fn ( get_alg_priv ( ctx ) , cb_get , cb_release , cb_priv ) ;",5017
1291,"int res , ret ;if ( ! bitset ) return - EINVAL ;","int res , ret ;if ( uaddr == uaddr2 ) return - EINVAL ;if ( ! bitset ) return - EINVAL ;",5018
1292,},tty -> disc_data = NULL ;tty -> receive_room = 0 ;},5019
1293,"if ( n <= 0 ) return ( n ) ;if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) {s -> packet_length = 0 ;goto again ;}s -> rstate = SSL_ST_READ_BODY ;p = s -> packet ;if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ;rr -> type = * ( p ++ ) ;ssl_major = * ( p ++ ) ;ssl_minor = * ( p ++ ) ;version = ( ssl_major << 8 ) | ssl_minor ;n2s ( p , rr -> epoch ) ;memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ;p += 6 ;n2s ( p , rr -> length ) ;if ( ! s -> first_packet ) {if ( version != s -> version ) {rr -> length = 0 ;s -> packet_length = 0 ;goto again ;}}if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) {rr -> length = 0 ;s -> packet_length = 0 ;goto again ;}if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) {rr -> length = 0 ;s -> packet_length = 0 ;goto again ;}}if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) {i = rr -> length ;n = ssl3_read_n ( s , i , i , 1 ) ;if ( n <= 0 ) return ( n ) ;if ( n != i ) {",if ( n != i ) {,5020
1294,"newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ;atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ;","inet_sk ( newsk ) -> mc_list = NULL ;newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ;atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ;",5021
1295,BUG_ON ( sk != asoc -> base . sk ) ;lock_sock ( sk ) ;,if ( sk != asoc -> base . sk ) goto do_error ;lock_sock ( sk ) ;,5022
1296,dlen -= 2 ;for ( ;,dlen -= 3 ;for ( ;,5023
1297,"cp = ikev1_attrmap_print ( ndo , cp ,  ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;}","cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;if ( cp == NULL ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}",5024
1298,"static void fdct8 ( const int16_t * input , int16_t * output ) {int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;int t0 , t1 , t2 , t3 ;int x0 , x1 , x2 , x3 ;","static void fdct8 ( const tran_low_t * input , tran_low_t * output ) {int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;tran_high_t t0 , t1 , t2 , t3 ;tran_high_t x0 , x1 , x2 , x3 ;",5025
1299,t2 = x2 * cospi_24_64 + x3 * cospi_8_64 ;t3 = - x2 * cospi_8_64 + x3 * cospi_24_64 ;output [ 0 ] = fdct_round_shift ( t0 ) ;output [ 2 ] = fdct_round_shift ( t2 ) ;output [ 4 ] = fdct_round_shift ( t1 ) ;output [ 6 ] = fdct_round_shift ( t3 ) ;t0 = ( s6 - s5 ) * cospi_16_64 ;t2 = fdct_round_shift ( t0 ) ;t3 = fdct_round_shift ( t1 ) ;,t2 = ( tran_low_t ) fdct_round_shift ( t0 ) ;t3 = ( tran_low_t ) fdct_round_shift ( t1 ) ;output [ 6 ] = ( tran_low_t ) fdct_round_shift ( t3 ) ;t0 = ( s6 - s5 ) * cospi_16_64 ;t2 = fdct_round_shift ( t0 ) ;t3 = fdct_round_shift ( t1 ) ;,5025
1300,output [ 1 ] = fdct_round_shift ( t0 ) ;output [ 3 ] = fdct_round_shift ( t2 ) ;output [ 5 ] = fdct_round_shift ( t1 ) ;output [ 7 ] = fdct_round_shift ( t3 ) ;},output [ 1 ] = ( tran_low_t ) fdct_round_shift ( t0 ) ;output [ 3 ] = ( tran_low_t ) fdct_round_shift ( t2 ) ;output [ 5 ] = ( tran_low_t ) fdct_round_shift ( t1 ) ;output [ 7 ] = ( tran_low_t ) fdct_round_shift ( t3 ) ;},5025
1301,"ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data ,  size2 , mime ) ;if ( ret < 0 ) return ret ;","ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , size2 , NULL ) ;if ( ret < 0 ) return ret ;",5026
1302,"error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp1 ) ;if ( error ) return error ;if ( args -> blkno2 != args -> blkno ) {error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno2 , - 1 , & bp2 ) ;if ( error ) return error ;}else {bp2 = bp1 ;}leaf1 = bp1 -> b_addr ;entry1 = & xfs_attr3_leaf_entryp ( leaf1 ) [ args -> index ] ;leaf2 = bp2 -> b_addr ;entry2 = & xfs_attr3_leaf_entryp ( leaf2 ) [ args -> index2 ] ;# ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr1 , leaf1 ) ;ASSERT ( args -> index < ichdr1 . count ) ;ASSERT ( args -> index >= 0 ) ;xfs_attr3_leaf_hdr_from_disk ( & ichdr2 , leaf2 ) ;ASSERT ( args -> index2 < ichdr2 . count ) ;ASSERT ( args -> index2 >= 0 ) ;if ( entry1 -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf1 , args -> index ) ;namelen1 = name_loc -> namelen ;name1 = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ;namelen1 = name_rmt -> namelen ;name1 = ( char * ) name_rmt -> name ;}if ( entry2 -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf2 , args -> index2 ) ;namelen2 = name_loc -> namelen ;name2 = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf2 , args -> index2 ) ;namelen2 = name_rmt -> namelen ;name2 = ( char * ) name_rmt -> name ;}ASSERT ( be32_to_cpu ( entry1 -> hashval ) == be32_to_cpu ( entry2 -> hashval ) ) ;ASSERT ( namelen1 == namelen2 ) ;ASSERT ( memcmp ( name1 , name2 , namelen1 ) == 0 ) ;# endif ASSERT ( entry1 -> flags & XFS_ATTR_INCOMPLETE ) ;ASSERT ( ( entry2 -> flags & XFS_ATTR_INCOMPLETE ) == 0 ) ;entry1 -> flags &= ~ XFS_ATTR_INCOMPLETE ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , entry1 , sizeof ( * entry1 ) ) ) ;if ( args -> rmtblkno ) {ASSERT ( ( entry1 -> flags & XFS_ATTR_LOCAL ) == 0 ) ;name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ;name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ;name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ;","error = xfs_attr3_leaf_read ( args -> rmtvaluelen ) ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ;",5027
1303,"static void read_intra_frame_mode_info ( VP9_COMMON * const cm , MACROBLOCKD * const xd ,  int mi_row , int mi_col , vp9_reader * r ) {MODE_INFO * const mi = xd -> mi [ 0 ] ;MB_MODE_INFO * const mbmi = & mi -> mbmi ;const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ;const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;const BLOCK_SIZE bsize = mbmi -> sb_type ;mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ;mbmi -> skip = read_skip ( cm , xd , mbmi -> segment_id , r ) ;mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ;mbmi -> ref_frame [ 0 ] = INTRA_FRAME ;","static void read_intra_frame_mode_info ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vpx_reader * r ) {MODE_INFO * const mi = xd -> above_mi ;const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ;const MODE_INFO * left_mi = xd -> left_mi ;const BLOCK_SIZE bsize = mbmi -> sb_type ;const int mi_offset = mi_row * cm -> mi_cols + mi_col ;const int bw = xd -> plane [ 0 ] . n4_w >> 1 ;const int bh = xd -> plane [ 0 ] . n4_h >> 1 ;const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ;const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ;mbmi -> segment_id = read_intra_segment_id ( cm , mi_offset , x_mis , y_mis , r ) ;mbmi -> skip = read_skip ( cm , xd , 1 , r ) ;mbmi -> ref_frame [ 0 ] = INTRA_FRAME ;",5028
1304,if ( len <= 0 )  break ;len -= bytes ;offset = 0 ;,unsigned short prev_bi_vcnt = bio -> bi_vcnt ;if ( len <= 0 ) break ;if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;len -= bytes ;offset = 0 ;,5029
1305,"size_t bytes_per_line , extent ,  length ;ssize_t count , y ;","size_t bytes_per_line , extent , height , length ;ssize_t count , y ;",5030
1306,"sun_pixels = sun_data ;bytes_per_line = 0 ;if ( sun_info . type == RT_ENCODED ) {size_t height ;bytes_per_line += 15 ;( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;}p = sun_pixels ;","if ( sun_info . type == RT_ENCODED ) bytes_per_line += 15 ;( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ;p = sun_pixels ;",5030
1307,"if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) ||  ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ;set_tls_desc ( target ,  GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ;","int i ;if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ;for ( i = 0 ;i < count / sizeof ( struct user_desc ) ;i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;set_tls_desc ( target , GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ;",5031
1308,"blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ;error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ;","blkcnt = xfs_attr3_rmt_blocks ( mp , args -> rmtvaluelen ) ;error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ;",5032
1309,lblkno = args -> rmtblkno ;blkcnt = args -> rmtblkcnt ;valuelen = args -> valuelen ;while ( valuelen > 0 ) {,lblkno = args -> rmtvaluelen ;while ( valuelen > 0 ) {,5032
1310,"set_exception_intercept ( svm , AC_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;","set_exception_intercept ( svm , AC_VECTOR ) ;set_exception_intercept ( svm , DB_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;",5033
1311,"
",ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;,5034
1312,H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ;return OK ;,H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ;return OK ;,5034
1313,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",5035
1314,int strindex = 0 ;size_t length ;,size_t strindex = 0 ;size_t length ;,5036
1315,if ( old -> curframe != cur -> curframe )  return false ;,if ( old -> curframe != cur -> curframe ) return false ;if ( old -> speculative && ! cur -> speculative ) return false ;,5037
1316,"set_exception_intercept ( svm , AC_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;","set_exception_intercept ( svm , AC_VECTOR ) ;set_exception_intercept ( svm , DB_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;",5038
1317,"if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) {bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ;struct bpf_insn mask_and_div [ ] = {BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , };struct bpf_insn mask_and_mod [ ] = {BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , };struct bpf_insn * patchlet ;if ( insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) {patchlet = mask_and_div + ( is64 ? 1 : 0 ) ;cnt = ARRAY_SIZE ( mask_and_div ) - ( is64 ? 1 : 0 ) ;}else {patchlet = mask_and_mod + ( is64 ? 1 : 0 ) ;cnt = ARRAY_SIZE ( mask_and_mod ) - ( is64 ? 1 : 0 ) ;}new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ;if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) {cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\\return - EINVAL ;}new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ;if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( insn -> code != ( BPF_JMP | BPF_CALL ) )  continue ;if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ;if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ;if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ;if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ;if ( insn -> imm == BPF_FUNC_tail_call ) {prog -> cb_access = 1 ;env -> prog -> aux -> stack_depth = MAX_BPF_STACK ;env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ;insn -> imm = 0 ;insn -> code = BPF_JMP | BPF_TAIL_CALL ;if ( ! bpf_map_ptr_unpriv ( aux ) )  continue ;if ( bpf_map_ptr_poisoned ( aux ) ) {verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\\","if ( insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) {const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ;const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ;struct bpf_insn insn_buf [ 16 ] ;struct bpf_insn * patch = & insn_buf [ 0 ] ;bool issrc , isneg ;u32 off_reg ;if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ;if ( bpf_map_ptr_poisoned ( aux ) ) {verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\\",5039
1318,"if ( prog -> jit_requested && BITS_PER_LONG == 64 &&  ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) {if ( bpf_map_ptr_poisoned ( aux ) )   goto patch_call_imm ;map_ptr = BPF_MAP_PTR ( aux -> map_state ) ;ops = map_ptr -> ops ;if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) {cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {","if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) {if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ;map_ptr = BPF_MAP_PTR ( aux -> map_state ) ;ops = map_ptr -> ops ;if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) {cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {",5039
1319,"BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem ,  ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ;","BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ;",5039
1320,context . Xtogo = i -> width ;context . curY = i -> posY ;,"if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\\# endif return - 1 ;}if ( ( i -> posX + i -> width ) > i -> parent -> width ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\\# endif i -> posX = i -> parent -> width - i -> width ;}if ( ( i -> posY + i -> height ) > i -> parent -> height ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\\# endif i -> posY = i -> parent -> height - i -> height ;}context . Xtogo = i -> width ;context . curY = i -> posY ;",5040
1321,"# if CONFIG_MEM_MANAGER  hmm_free ( & hmm_d , addr ) ;# else VPX_FREE_L ( addr ) ;# endif  }",free ( addr ) ;},5041
1322,"
","attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ;if ( attr && ! ippValidateAttribute ( attr ) ) {send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ;if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ;return ( NULL ) ;}",5042
1323,"if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  {","if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL ) {",5042
1324,"apply_printer_defaults ( printer , job ) ;attr = ippFindAttribute ( job -> attrs , ""requesting-user-name"" , IPP_TAG_NAME ) ;","apply_printer_defaults ( printer , job ) ;",5042
1325,client -> desktopName = malloc ( ( uint64_t ) client -> si . nameLength + 1 ) ;if ( ! client -> desktopName ) {,"if ( client -> si . nameLength > 1 << 20 ) {rfbClientErr ( ""Too<S2SV_blank>big<S2SV_blank>desktop<S2SV_blank>name<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\\return FALSE ;}client -> desktopName = malloc ( client -> si . nameLength + 1 ) ;if ( ! client -> desktopName ) {",5043
1326,size_t  value ;,unsigned int value ;,5044
1327,value = ( size_t ) ( buffer [ 0 ] << 24 ) ;value |= buffer [ 1 ] << 16 ;value |= buffer [ 2 ] << 8 ;value |= buffer [ 3 ] ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;,value = ( unsigned int ) buffer [ 0 ] << 24 ;value |= ( unsigned int ) buffer [ 1 ] << 16 ;value |= ( unsigned int ) buffer [ 2 ] << 8 ;value |= ( unsigned int ) buffer [ 3 ] ;quantum . unsigned_value = value & 0xffffffff ) ;return ( quantum . signed_value ) ;,5044
1328,"
",ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;,5045
1329,"ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" ,  EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ;","ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ;",5045
1330,char added ;},},5046
1331,pair -> added = 0 ;for ( it = tmp_subnodes -> first ;,for ( it = tmp_subnodes -> first ;,5046
1332,flush_dcache_page ( page ) ;if ( ! tmp ) {,"iov_iter_advance ( ii , tmp ) ;flush_dcache_page ( page ) ;if ( ! tmp ) {",5047
1333,"iov_iter_advance ( ii , tmp ) ;count += tmp ;",count += tmp ;,5047
1334,"if ( ! access_ok ( VERIFY_WRITE , name , namelen ) ) return - EFAULT ;len = namelen ;if ( namelen > 32 )  len = 32 ;",if ( len > 32 ) len = 32 ;,5048
1335,"return mount_entry_on_generic ( mntent , path ) ;}","return mount_entry_on_generic ( mntent , path , rootfs -> mount ) ;}",5049
1336,if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) {case EFFECT_CMD_INIT :  if ( pReplyData == NULL || * replySize != sizeof ( int ) ) {return - EINVAL ;case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t )  || pReplyData == NULL || * replySize != sizeof ( int ) ) {return - EINVAL ;if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ||  pReplyData == NULL ||  * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) {,if ( pDwmModule == NULL || replySize == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) {case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) {return - EINVAL ;case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) {return - EINVAL ;if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || pReplyData == NULL || replySize == NULL || replySize == NULL || replySize == NULL || * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) {,5050
1337,if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) )  || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) {return - EINVAL ;,if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) {return - EINVAL ;,5050
1338,case EFFECT_CMD_ENABLE :  if ( pReplyData == NULL || * replySize != sizeof ( int ) ) {return - EINVAL ;,case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) {return - EINVAL ;,5050
1339,case EFFECT_CMD_DISABLE :  if ( pReplyData == NULL || * replySize != sizeof ( int ) ) {return - EINVAL ;,case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) {return - EINVAL ;,5050
1340,"msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ;","skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ;",5051
1341,"if ( debug ) {printk ( KERN_INFO ""cx24116:<S2SV_blank>%s("" , __func__ ) ;printk ( "")<S2SV_blank>toneburst=%d\\\}if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) )  return - EINVAL ;","if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ;if ( debug ) {printk ( KERN_INFO ""cx24116:<S2SV_blank>%s("" , __func__ ) ;",5052
1342,"tlen = len - sizeof ( struct eigrp_common_header ) ;ND_PRINT ( ( ndo , ""\\\","if ( len < sizeof ( struct eigrp_common_header ) ) {ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ;if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ;break ;}return ;}tlen = len - sizeof ( struct eigrp_common_header ) ;ND_PRINT ( ( ndo , ""\\\",5053
1343,"tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;if ( bit_length > 32 ) {","tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ;if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ;break ;}bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;if ( bit_length > 32 ) {",5053
1344,bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;if ( bit_length > 32 ) {,"if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ;break ;}bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;if ( bit_length > 32 ) {",5053
1345,"ND_PRINT ( ( ndo , ""\\\case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\","if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case EIGRP_TLV_AT_INT : tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\",5053
1346,"strncpy ( szSec , opt_string , sepIdx ) ;szSec [ sepIdx ] = 0 ;sep ++ ;sep2 = strchr ( sep , \'=\' ) ;if ( ! sep2 ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\\{const size_t sepIdx = sep2 - sep ;strncpy ( szKey , sep , sepIdx ) ;szKey [ sepIdx ] = 0 ;strcpy ( szVal , sep2 + 1 ) ;}","if ( sepIdx >= sizeof ( szSec ) ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\\return ;strncpy ( szSec , opt_string , sepIdx ) ;szSec [ sepIdx ] = 0 ;if ( strlen ( sep2 + 1 ) >= sizeof ( szVal ) ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\\strcpy ( szVal , sep2 + 1 ) ;}",5054
1347,if ( size_bmp > BMP_HEADER_SIZE ) {int ret ;,if ( size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE ) {int ret ;,5055
1348,"switch ( pc -> componentType ) {case 1 : if ( pc -> lengthComponentIdent > 0 )  break ;case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ;p = to ;* p ++ = \'/\' ;tolen -- ;break ;case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ;memcpy ( p , ""../"" , 3 ) ;p += 3 ;tolen -= 3 ;break ;case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ;memcpy ( p , ""./"" , 2 ) ;p += 2 ;tolen -= 2 ;break ;case 5 :  comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ;p += comp_len ;tolen -= comp_len ;if ( tolen == 0 ) return - ENAMETOOLONG ;* p ++ = \'/\' ;tolen -- ;elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ;}",elen += sizeof ( struct pathComponent ) ;switch ( pc -> componentType ) {case 1 : if ( pc -> lengthComponentIdent > 0 ) {elen += pc -> lengthComponentIdent ;},5056
1349,if ( refill_pi_state_cache ( ) )  return - ENOMEM ;,if ( uaddr1 == uaddr2 ) return - EINVAL ;if ( refill_pi_state_cache ( ) ) return - ENOMEM ;,5057
1350,if ( unlikely ( ret != 0 ) )  goto out_put_key1 ;hb1 = hash_futex ( & key1 ) ;,"if ( unlikely ( ret != 0 ) ) goto out_put_key1 ;if ( requeue_pi && match_futex ( & key1 , & key2 ) ) {ret = - EINVAL ;goto out_put_keys ;}hb1 = hash_futex ( & key1 ) ;",5057
1351,"if ( key_is_instantiated ( keyring ) ) {if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , "":<S2SV_blank>%lu"" , keyring -> keys . nr_leaves_on_tree ) ;","if ( key_is_positive ( keyring ) ) {if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , "":<S2SV_blank>%lu"" , keyring -> keys . nr_leaves_on_tree ) ;",5058
1352,pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ;if ( rec ) {,Assert ( ncolumns <= MaxTupleAttributeNumber ) ;pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ;if ( rec ) {,5059
1353,"uint16_t n ;uint16_t status ;Enc28j60Context * context ;context = ( Enc28j60Context * ) interface -> nicContext ;if ( enc28j60ReadReg ( interface , ENC28J60_REG_EPKTCNT ) )  {enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTL , LSB ( context -> nextPacket ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTH , MSB ( context -> nextPacket ) ) ;enc28j60ReadBuffer ( interface , ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ;enc28j60ReadBuffer ( interface , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ;enc28j60ReadBuffer ( interface , ( uint8_t * ) & status , sizeof ( uint16_t ) ) ;if ( ( status & RSV_RECEIVED_OK ) != 0 )  {n = MIN ( n , ETH_MAX_FRAME_SIZE ) ;enc28j60ReadBuffer ( interface , context -> rxBuffer , n ) ;error = NO_ERROR ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;}enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( context -> nextPacket - 1 ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( context -> nextPacket - 1 ) ) ;}enc28j60SetBit ( interface , ENC28J60_REG_ECON2 , ECON2_PKTDEC ) ;}nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ;}","uint16_t length ;uint16_t status ;uint8_t header [ 6 ] ;Enc28j60Context * context ;context = ( Enc28j60Context * ) interface -> nicContext ;if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT ) != 0 ) {enc28j60WriteReg ( interface , ENC28J60_ERDPTL , LSB ( context -> nextPacket ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERDPTH , MSB ( context -> nextPacket ) ) ;enc28j60ReadBuffer ( interface , header , sizeof ( uint16_t ) ) ;enc28j60ReadBuffer ( interface , ( uint8_t * ) & n , sizeof ( header ) ) ;context -> nextPacket = LOAD16LE ( header ) ;length = LOAD16LE ( header + 2 ) ;status = LOAD16LE ( header + 4 ) ;if ( ( status & ENC28J60_RSV_RECEIVED_OK ) != 0 ) {n = MIN ( length , ETH_MAX_FRAME_SIZE ) ;enc28j60ReadBuffer ( interface , context -> rxBuffer , length ) ;error = NO_ERROR ;enc28j60WriteReg ( interface , ENC28J60_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;}enc28j60WriteReg ( interface , ENC28J60_ERXRDPTL , LSB ( context -> nextPacket - 1 ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERXRDPTH , MSB ( context -> nextPacket - 1 ) ) ;}enc28j60SetBit ( interface , ENC28J60_ECON2 , ENC28J60_ECON2_PKTDEC ) ;}nicProcessPacket ( interface , context -> rxBuffer , length , & ancillary ) ;}",5060
1354,cleanup_free char * base_path = NULL ;int clone_flags ;,const char * base_path = NULL ;int clone_flags ;,5061
1355,"base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ;if ( ensure_dir ( base_path , 0755 ) ) {free ( base_path ) ;base_path = xasprintf ( ""/tmp/.bubblewrap-%d"" , real_uid ) ;if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed"" ) ;}","base_path = ""/tmp"" ;",5061
1356,if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) {static uint64_t next_id = 0 ;,if ( rh . command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) {static uint64_t next_id = 0 ;,5062
1357,avio_rl64 ( pb ) ;count = avio_rl32 ( pb ) ;avio_rl16 ( pb ) ;name_len = avio_rl16 ( pb ) ;for ( i = 0 ;i ++ )  avio_r8 ( pb ) ;int name_len ;avio_rl64 ( pb ) ;,"avio_skip ( pb , name_len ) ;for ( i = 0 ;i ++ ) avio_r8 ( pb ) ;int name_len ;if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;avio_rl64 ( pb ) ;",5063
1358,* head = NULL ;* out = line ;return 0 ;,"giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ;return GIT_ERROR ;",5064
1359,"int xmkstemp ( char * * tmpname , char * dir )  {char * tmpenv ;mode_t old_mode ;if ( dir != NULL )   tmpenv = dir ;else tmpenv = getenv ( ""TMPDIR"" ) ;if ( tmpenv )  rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , tmpenv ,  program_invocation_short_name ) ;else rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , _PATH_TMP , program_invocation_short_name ) ;","int xmkstemp ( char * * tmpname , const char * dir , const char * prefix ) {const char * tmpenv ;mode_t old_mode ;tmpenv = dir ;else tmpenv = getenv ( ""TMPDIR"" ) ;if ( ! tmpenv ) tmpenv = _PATH_TMP ;rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , tmpenv , prefix ) ;",5065
1360,if ( length < sizeof ( DhcpMessage ) )  return ;if ( length > DHCP_MAX_MSG_SIZE ) return ;,if ( length < sizeof ( DhcpMessage ) || length > DHCP_MAX_MSG_SIZE ) return ;,5066
1361,"if ( ! revs -> blob_objects )  return ;show ( obj , path , name , cb_data ) ;}","size_t pathlen ;if ( ! revs -> blob_objects ) return ;pathlen = path -> len ;strbuf_addstr ( path , name ) ;show ( obj , path -> buf , cb_data ) ;strbuf_setlen ( path , pathlen ) ;}",5067
1362,"if ( len > BUFSIZE + sizeof ( struct nbd_reply ) )  err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ;","if ( len > BUFSIZE - sizeof ( struct nbd_reply ) ) err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ;",5068
1363,"static void __nfs4_close ( struct path * path , struct nfs4_state * state , mode_t mode , int wait )  {int newstate ;atomic_inc ( & owner -> so_count ) ;switch ( mode & ( FMODE_READ | FMODE_WRITE ) ) {case FMODE_READ : state -> n_rdonly -- ;","static void __nfs4_close ( struct path * path , struct nfs4_state * state , fmode_t fmode , int wait ) {fmode_t newstate ;atomic_inc ( & owner -> so_count ) ;switch ( fmode & ( FMODE_READ | FMODE_WRITE ) ) {case FMODE_READ : state -> n_rdonly -- ;",5069
1364,tread . event = SNDRV_TIMER_EVENT_EARLY ;tread . tstamp . tv_sec = 0 ;,"memset ( & tread , 0 , sizeof ( tread ) ) ;tread . event = SNDRV_TIMER_EVENT_EARLY ;tread . tstamp . tv_sec = 0 ;",5070
1365,"
",if ( sk != rcvr -> sk ) {sctp_bh_unlock_sock ( sk ) ;sk = rcvr -> sk ;sctp_bh_lock_sock ( sk ) ;},5071
1366,if ( sock_owned_by_user ( sk ) ) {SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ;,if ( sock_owned_by_user ( sk ) ) {SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ;,5071
1367,"
",ND_TCHECK ( tptr [ 1 ] ) ;,5072
1368,"ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values ,  ""?"" , tptr [ 0 ] ) ) ) ;for ( i = 0 ;","ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ;for ( i = 0 ;",5072
1369,"if ( chg < 0 )  return chg ;if ( hugepage_subpool_get_pages ( spool , chg ) )  return - ENOSPC ;ret = hugetlb_acct_memory ( h , chg ) ;if ( ret < 0 ) {hugepage_subpool_put_pages ( spool , chg ) ;return ret ;}}","if ( chg < 0 ) {ret = chg ;goto out_err ;}if ( hugepage_subpool_get_pages ( spool , chg ) ) {ret = - ENOSPC ;goto out_err ;}ret = hugetlb_acct_memory ( h , chg ) ;goto out_err ;}out_err : resv_map_put ( vma ) ;return ret ;}",5073
1370,CLEANUP_FREE char * * lines = NULL ;int64_t size ;,char * * lines = NULL ;int64_t size ;,5074
1371,return ret ;},free ( lines ) ;return ret ;},5074
1372,if ( ftrace_event_is_function ( tp_event ) &&  perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) )  return - EPERM ;,if ( ftrace_event_is_function ( tp_event ) && perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ;,5075
1373,"case \'c\' : return getnum ( L , fmt , 1 ) ;case \'i\' : case \'I\' : {int sz = getnum ( L , fmt , sizeof ( int ) ) ;if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ;","case \'c\' : return getnum ( fmt , 1 ) ;case \'i\' : case \'I\' : {int sz = getnum ( fmt , sizeof ( int ) ) ;if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ;",5076
1374,return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ;},return READ_ONCE ( evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] ) [ EVTCHN_COL ( evtchn ) ] ;},5077
1375,"static int do_16x16_motion_search ( VP9_COMP * cpi , const int_mv * ref_mv ,  int_mv * dst_mv , int mb_row , int mb_col ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;int_mv tmp_mv ;err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,  xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ,  INT_MAX ) ;tmp_err = do_16x16_motion_iteration ( cpi , & ref_mv -> as_mv , & tmp_mv . as_mv ,  mb_row , mb_col ) ;dst_mv -> as_int = tmp_mv . as_int ;if ( ref_mv -> as_int ) {int_mv zero_ref_mv , tmp_mv ;zero_ref_mv . as_int = 0 ;tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv . as_mv , & tmp_mv . as_mv , mb_row , mb_col ) ;dst_mv -> as_int = tmp_mv . as_int ;","static int do_16x16_motion_search ( VP9_COMP * cpi , const MV * ref_mv , int_mv * dst_mv , int mb_row , int mb_col ) {MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;MV tmp_mv ;err = vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ) ;tmp_err = do_16x16_motion_iteration ( cpi , ref_mv , & tmp_mv , mb_row , mb_col ) ;dst_mv -> as_mv = tmp_mv ;if ( ref_mv -> row != 0 || ref_mv -> col != 0 ) {MV zero_ref_mv = {0 , 0 }, tmp_mv ;tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv , & tmp_mv , mb_row , mb_col ) ;dst_mv -> as_mv = tmp_mv ;",5078
1376,if ( segment -> flags & TCP_FLAG_SYN )  ackNum ++ ;if ( segment -> flags & TCP_FLAG_FIN )   ackNum ++ ;},if ( segment -> flags & TCP_FLAG_SYN ) {ackNum ++ ;}if ( segment -> flags & TCP_FLAG_FIN ) {ackNum ++ ;}},5079
1377,"struct snd_timer_user * tu ;void __user * argp = ( void __user * ) arg ;int __user * p = argp ;tu = file -> private_data ;switch ( cmd ) {case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ;mutex_lock ( & tu -> tread_sem ) ;if ( tu -> timeri ) {return - EBUSY ;}if ( get_user ( xarg , p ) ) {mutex_unlock ( & tu -> tread_sem ) ;return - EFAULT ;}tu -> tread = xarg ? 1 : 0 ;mutex_unlock ( & tu -> tread_sem ) ;return 0 ;}case SNDRV_TIMER_IOCTL_GINFO : return snd_timer_user_ginfo ( file , argp ) ;case SNDRV_TIMER_IOCTL_GPARAMS : return snd_timer_user_gparams ( file , argp ) ;case SNDRV_TIMER_IOCTL_GSTATUS : return snd_timer_user_gstatus ( file , argp ) ;case SNDRV_TIMER_IOCTL_SELECT : return snd_timer_user_tselect ( file , argp ) ;case SNDRV_TIMER_IOCTL_INFO : return snd_timer_user_info ( file , argp ) ;case SNDRV_TIMER_IOCTL_PARAMS : return snd_timer_user_params ( file , argp ) ;case SNDRV_TIMER_IOCTL_STATUS : return snd_timer_user_status ( file , argp ) ;case SNDRV_TIMER_IOCTL_START : case SNDRV_TIMER_IOCTL_START_OLD : return snd_timer_user_start ( file ) ;case SNDRV_TIMER_IOCTL_STOP : case SNDRV_TIMER_IOCTL_STOP_OLD : return snd_timer_user_stop ( file ) ;case SNDRV_TIMER_IOCTL_CONTINUE : case SNDRV_TIMER_IOCTL_CONTINUE_OLD : return snd_timer_user_continue ( file ) ;case SNDRV_TIMER_IOCTL_PAUSE : case SNDRV_TIMER_IOCTL_PAUSE_OLD : return snd_timer_user_pause ( file ) ;}return - ENOTTY ;","struct snd_timer_user * tu = file -> private_data ;switch ( cmd ) {case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ;mutex_lock ( & tu -> ioctl_lock ) ;ret = __snd_timer_user_ioctl ( file , cmd , arg ) ;return ret ;",5080
1378,"}if ( options . compression ) {ssh_packet_set_compress_hooks ( ssh , pmonitor -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ;","
",5081
1379,"in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) ;}skip_defrtr : if ( in6_dev -> nd_parms ) {unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ;if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ ) {rtime = ( rtime * HZ ) / 1000 ;if ( rtime < HZ / 10 ) rtime = HZ / 10 ;NEIGH_VAR_SET ( in6_dev -> nd_parms , RETRANS_TIME , rtime ) ;in6_dev -> tstamp = jiffies ;inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ;}rtime = ntohl ( ra_msg -> reachable_time ) ;if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) ) {rtime = ( rtime * HZ ) / 1000 ;if ( rtime < HZ / 10 ) rtime = HZ / 10 ;if ( rtime != NEIGH_VAR ( in6_dev -> nd_parms , BASE_REACHABLE_TIME ) ) {NEIGH_VAR_SET ( in6_dev -> nd_parms , BASE_REACHABLE_TIME , rtime ) ;NEIGH_VAR_SET ( in6_dev -> nd_parms , GC_STALETIME , 3 * rtime ) ;in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ) ;in6_dev -> tstamp = jiffies ;inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ;}}}skip_linkparms : if ( ! neigh ) neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ) ;if ( neigh ) {u8 * lladdr = NULL ;if ( ndopts . nd_opts_src_lladdr ) {lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ) ;if ( ! lladdr ) {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>link-layer<S2SV_blank>address<S2SV_blank>length\\\goto out ;}}neigh_update ( neigh , lladdr , NUD_STALE , NEIGH_UPDATE_F_WEAK_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE_ISROUTER | NEIGH_UPDATE_F_ISROUTER ) ;if ( ! ipv6_accept_ra ( in6_dev ) ) {ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>accept_ra<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\\goto out ;}# ifdef CONFIG_IPV6_ROUTE_INFO if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) {ND_PRINTK ( 2 , info , ""RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>router<S2SV_blank>info<S2SV_blank>ignored.\\\goto skip_routeinfo ;}if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri ) {struct nd_opt_hdr * p ;for ( p = ndopts . nd_opts_ri ;p ;p = ndisc_next_option ( p , ndopts . nd_opts_ri_end ) ) {struct route_info * ri = ( struct route_info * ) p ;# ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT && ri -> prefix_len == 0 ) continue ;# endif if ( ri -> prefix_len == 0 && ! in6_dev -> cnf . accept_ra_defrtr ) continue ;if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen ) continue ;rt6_route_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , & ipv6_hdr ( skb ) -> saddr ) ;}}skip_routeinfo : # endif # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) {ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT<S2SV_blank>(interior<S2SV_blank>routes),<S2SV_blank>dev:<S2SV_blank>%s\\\goto out ;}# endif if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi ) {struct nd_opt_hdr * p ;for ( p = ndopts . nd_opts_pi ;p ;p = ndisc_next_option ( p , ndopts . nd_opts_pi_end ) ) {addrconf_prefix_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , ndopts . nd_opts_src_lladdr != NULL ) ;}}if ( ndopts . nd_opts_mtu && in6_dev -> cnf . accept_ra_mtu ) {__be32 n ;u32 mtu ;memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ) ;mtu = ntohl ( n ) ;if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu ) {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>mtu:<S2SV_blank>%d\\\else if ( in6_dev -> cnf . mtu6 != mtu ) {in6_dev -> cnf . mtu6 = mtu ;","if ( in6_dev -> cnf . hop_limit < ra_msg -> icmph . icmp6_hop_limit ;if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) {in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;else {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\\",5082
1380,"case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ;","case SO_DEBUG : v . val = ! ! sock_flag ( sk , SOCK_DBG ) ;",5083
1381,"case SO_PASSCRED :  v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ;break ;","case SO_PASSCRED : v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ;break ;",5083
1382,"case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ;case SO_PASSSEC :  v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ;break ;","case SO_ACCEPTCONN : v . val = ! ! sk -> sk_state == TCP_LISTEN ;break ;case SO_PASSSEC : v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ;",5083
1383,if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] )  return - EINVAL ;,if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) return - EINVAL ;,5084
1384,"struct net * net = sock_net ( asoc -> base . sk ) ;int error = 0 ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_association_put ( asoc ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;int error = 0 ;bh_lock_sock ( sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_association_put ( asoc ) ;",5085
1385,void *  xmalloc ( size_t size )   {void * ptr = malloc ( size ) ;if ( ! ptr && ( size != 0 ) ) {,"void * xmalloc ( size_t num , size_t size ) {size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;void * ptr = malloc ( res ) ;if ( ! ptr && ( size != 0 ) ) {",5086
1386,sys -> free ( lzx -> inbuf ) ;sys -> free ( lzx -> window ) ;,if ( lzx -> inbuf ) sys -> free ( lzx -> inbuf ) ;if ( lzx -> window ) sys -> free ( lzx -> window ) ;,5087
1387,if ( NAPI_GRO_CB ( skb ) -> udp_mark ||  ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> csum_cnt == 0 && ! NAPI_GRO_CB ( skb ) -> csum_valid ) ) goto out ;NAPI_GRO_CB ( skb ) -> udp_mark = 1 ;rcu_read_lock ( ) ;,if ( NAPI_GRO_CB ( skb ) -> encap_mark || ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> encap_mark = 1 ;rcu_read_lock ( ) ;,5088
1388,"MB_PREDICTION_MODE mode ;MB_PREDICTION_MODE mode_selected = DC_PRED ;int64_t this_distortion , this_sse ;for ( mode = DC_PRED ;super_block_uvrd ( cpi , x , & this_rate_tokenonly ,   & this_distortion , & s , & this_sse , bsize , best_rd ) ;if ( this_rate_tokenonly == INT_MAX ) continue ;this_rate = this_rate_tokenonly +  x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ;this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ;","PREDICTION_MODE mode ;PREDICTION_MODE mode_selected = DC_PRED ;int64_t this_distortion , this_sse ;memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ;for ( mode = DC_PRED ;if ( ! super_block_uvrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , & this_sse , bsize , best_rd ) ) continue ;this_rate = this_rate_tokenonly + x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ;this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ;",5089
1389,if ( ! x -> select_txfm_size ) {int i ;struct macroblock_plane * const p = x -> plane ;struct macroblockd_plane * const pd = xd -> plane ;for ( i = 1 ;i < MAX_MB_PLANE ;++ i ) {p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 2 ] ;p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 2 ] ;pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 2 ] ;p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 2 ] ;ctx -> coeff_pbuf [ i ] [ 2 ] = ctx -> coeff_pbuf [ i ] [ 0 ] ;ctx -> qcoeff_pbuf [ i ] [ 2 ] = ctx -> qcoeff_pbuf [ i ] [ 0 ] ;ctx -> dqcoeff_pbuf [ i ] [ 2 ] = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ;ctx -> eobs_pbuf [ i ] [ 2 ] = ctx -> eobs_pbuf [ i ] [ 0 ] ;ctx -> coeff_pbuf [ i ] [ 0 ] = p [ i ] . coeff ;ctx -> qcoeff_pbuf [ i ] [ 0 ] = p [ i ] . qcoeff ;ctx -> dqcoeff_pbuf [ i ] [ 0 ] = pd [ i ] . dqcoeff ;ctx -> eobs_pbuf [ i ] [ 0 ] = p [ i ] . eobs ;}},"+ i ) {if ( ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ;",5089
1390,"if ( exists_not_none ( obj , & PyId_arg ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_identifier ( tmp , & arg , arena ) ;if ( res != 0 ) goto failed ;}else {arg = NULL ;if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {","if ( lookup_attr_id ( obj , & PyId_arg ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_arg , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {arg = NULL ;else {",5090
1391,"else {* out = keyword ( arg , value , arena ) ;","if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {else {int res ;res = obj2ast_expr ( tmp , & value , arena ) ;",5090
1392,},if ( ! enable ) {wake_up_interruptible ( & sunkbd -> wait ) ;cancel_work_sync ( & sunkbd -> tq ) ;}},5091
1393,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;BUG_ON ( dh == NULL ) ;","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;BUG_ON ( dh == NULL ) ;",5092
1394,"static int read_fragment_table ( long long * directory_table_end )  {int bytes = SQUASHFS_FRAGMENT_BYTES ( sBlk . s . fragments ) ;int indexes = SQUASHFS_FRAGMENT_INDEXES ( sBlk . s . fragments ) ;long long fragment_table_index [ indexes ] ;TRACE ( ""read_fragment_table:<S2SV_blank>%d<S2SV_blank>fragments,<S2SV_blank>reading<S2SV_blank>%d<S2SV_blank>fragment<S2SV_blank>indexes<S2SV_blank>"" ""from<S2SV_blank>0x%llx\\\if ( sBlk . s . fragments == 0 ) {* directory_table_end = sBlk . s . fragment_table_start ;return TRUE ;res = read_fs_bytes ( fd , sBlk . s . fragment_table_start ,  SQUASHFS_FRAGMENT_INDEX_BYTES ( sBlk . s . fragments ) ,  fragment_table_index ) ;","static int read_fragment_table ( long long * table_start ) {long long bytes = SQUASHFS_FRAGMENT_BYTES ( ( long long ) sBlk . s . fragments ) ;int indexes = SQUASHFS_FRAGMENT_INDEXES ( ( long long ) sBlk . s . fragments ) ;int length = SQUASHFS_FRAGMENT_INDEX_BYTES ( ( long long ) sBlk . s . fragments ) ;long long * fragment_table_index ;if ( length != ( * table_start - sBlk . s . fragment_table_start ) ) {ERROR ( ""read_fragment_table:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\return FALSE ;TRACE ( ""read_fragment_table:<S2SV_blank>%d<S2SV_blank>fragments,<S2SV_blank>reading<S2SV_blank>%d<S2SV_blank>fragment<S2SV_blank>indexes<S2SV_blank>"" ""from<S2SV_blank>0x%llx\\\fragment_table_index = alloc_index_table ( indexes ) ;res = read_fs_bytes ( fd , sBlk . s . fragment_table_start , length , fragment_table_index ) ;",5093
1395,* directory_table_end = fragment_table_index [ 0 ] ;return TRUE ;,* table_start = fragment_table_index [ 0 ] ;return TRUE ;,5093
1396,assert ( numcolors <= RAS_CMAP_MAXSIZ ) ;actualnumcolors = hdr -> maplength / 3 ;,if ( numcolors > RAS_CMAP_MAXSIZ ) {return - 1 ;}actualnumcolors = hdr -> maplength / 3 ;,5094
1397,"sprintf ( efbuf , ""REG_%s"" , name ) ;assert ( strlen ( efbuf ) < sizeof ( efbuf ) ) ;","snprintf ( efbuf , sizeof ( efbuf ) , ""REG_%s"" , name ) ;assert ( strlen ( efbuf ) < sizeof ( efbuf ) ) ;",5095
1398,"for ( ;* s && dlen ;s ++ ) {if ( strchr ( quote , * s ) ) {dlen -= 2 ;if ( dlen == 0 ) break ;","
",5096
1399,"nfcb_poll -> sensb_res_len = * data ++ ;pr_debug ( ""sensb_res_len<S2SV_blank>%d\\\","nfcb_poll -> sensb_res_len = min_t ( __u8 , * data ++ , NFC_SENSB_RES_MAXSIZE ) ;pr_debug ( ""sensb_res_len<S2SV_blank>%d\\\",5097
1400,"unsigned int maxfraglen , fragheaderlen ;int exthdrlen ;int hh_len ;int mtu ;","unsigned int maxfraglen , fragheaderlen , mtu ;int exthdrlen ;int hh_len ;",5098
1401,"if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen ,  fragheaderlen , skb , rt ) ;skb_prev = skb ;","if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE ) ;skb_prev = skb ;",5098
1402,"uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ;unsigned char * channel_identities = NULL ;","uint32_t chan_chunk = 0 , desc_chunk = 0 , channel_layout = 0 , bcount ;unsigned char * channel_identities = NULL ;",5099
1403,"WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;if ( debug_logging_mode ) {","WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;desc_chunk = 1 ;if ( debug_logging_mode ) {",5099
1404,else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ;,else if ( ! desc_chunk || ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ;,5099
1405,"if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) ||  bcount != sizeof ( mEditCount ) ) {","if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) {",5099
1406,"static int cost_segmap ( int * segcounts , vp9_prob * probs ) {const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;","static int cost_segmap ( int * segcounts , vpx_prob * probs ) {const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;",5100
1407,motion_pct = this_frame -> pcnt_motion ;* this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ;,( void ) cpi ;motion_pct = this_frame -> pcnt_motion ;* this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ;,5101
1408,"char extbuf [ sizeof ( c -> binary_header ) + BIN_MAX_EXTLEN ] ;memcpy ( extbuf + sizeof ( c -> binary_header ) , c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ;c -> rbytes -= sizeof ( c -> binary_header ) + extlen + keylen ;","char extbuf [ sizeof ( c -> binary_header ) + BIN_MAX_EXTLEN + 1 ] ;memcpy ( extbuf + sizeof ( c -> binary_header ) , extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN : c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ;c -> rbytes -= sizeof ( c -> binary_header ) + extlen + keylen ;",5102
1409,for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src + i ) ;,for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src + i ) ;,5103
1410,void * H264SwDecMalloc ( u32 size )  {return malloc ( size ) ;},"void * H264SwDecMalloc ( u32 size , u32 num ) {if ( size > UINT32_MAX / num ) {return NULL ;}return malloc ( size * num ) ;}",5104
1411,offset = tbl -> indent ;if ( cmd == HTML_DT ) {}if ( tbl -> indent > 0 ) {,if ( tbl -> indent < 0 ) tbl -> indent = 0 ;if ( offset < 0 ) offset = 0 ;offset = tbl -> indent ;if ( cmd == HTML_DT ) {}if ( tbl -> indent > 0 ) {,5105
1412,"return NULL ;}ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ;ut32 len = sec -> payload_len ;ut32 count = sec -> count ;ut32 i = 0 , r = 0 ;while ( i < len && r < count ) {if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) {return ret ;free ( ptr ) ;return ret ;free ( ptr ) ;return ret ;free ( ptr ) ;return ret ;",goto beach ;free ( ptr ) ;return ret ;free ( ptr ) ;return ret ;goto beach ;,5106
1413,},beach : free ( ptr ) ;return ret ;},5106
1414,default :  errno = EINVAL ;,case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ;return 0 ;default : errno = EINVAL ;,5107
1415,"tr_variantInitDict ( & node -> sorted , n ) ;for ( size_t i = 0 ;i < n ;++ i ) {node -> sorted . val . l . vals [ i ] = * tmp [ i ] . val ;}node -> sorted . val . l . count = n ;tr_free ( tmp ) ;node -> v = & node -> sorted ;}node -> v = v ;}","+ i ) {node -> sorted = tr_new ( tr_variant , 1 ) ;tr_variantInitDict ( node -> sorted -> val . l . vals [ i ] = * tmp [ i ] . val ;}node -> sorted . val . l . count = n ;tr_free ( tmp ) ;v = node -> sorted ;}node -> sorted = NULL ;}node -> v = v ;",5108
1416,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,5109
1417,"if ( global_colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) {","if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap ) ) ;if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) {",5110
1418,"dl = kmalloc ( size , GFP_KERNEL ) ;if ( ! dl ) return - ENOMEM ;","dl = kzalloc ( size , GFP_KERNEL ) ;if ( ! dl ) return - ENOMEM ;",5111
1419,"enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;armor_key = cb -> fast_armor ( context , rock ) ;","armor_key = cb -> fast_armor ( context , rock ) ;",5112
1420,"rs -> respond = respond ;retval = cb -> get_string ( context , rock , ""otp"" , & config ) ;","rs -> respond = respond ;rs -> enc_tkt_reply = enc_tkt_reply ;retval = cb -> get_string ( context , rock , ""otp"" , & config ) ;",5112
1421,"void  byteSwap ( UWORD32 * buf , unsigned words ) {","static void byteSwap ( UWORD32 * buf , unsigned words ) {",5113
1422,"if ( msg -> has_data_length && len > 0 ) {memcpy ( buffer , msg -> data_initial_chunk . bytes + offset , len ) ;return len < 256 ? ( uint8_t ) len : 0 ;}","if ( msg -> has_data_length && len > 0 && len < 256 ) {memcpy ( buffer , msg -> data_initial_chunk . bytes + offset , len ) ;return ( uint8_t ) len : 0 ;}",5114
1423,"# ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}mysql_options ( mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;# endif if ( opt_protocol ) mysql_options ( mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;","SSL_SET_OPTIONS ( mysql ) ;if ( opt_protocol ) mysql_options ( mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",5115
1424,"int ffmax , parent_len ;static const struct archive_rb_tree_ops rb_ops = {r = idr_start ( a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ;if ( r < 0 ) return ( r ) ;","size_t ffmax , parent_len ;static const struct archive_rb_tree_ops rb_ops = {r = idr_start ( a , idr , isoent -> children . cnt , ( int ) ffmax , 6 , 2 , & rb_ops ) ;if ( r < 0 ) return ( r ) ;",5116
1425,"if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax )  l = ffmax ;if ( p == NULL ) {archive_set_error ( & a -> archive , ENOMEM , ""Can\\\'t<S2SV_blank>allocate<S2SV_blank>memory"" ) ;return ( ARCHIVE_FATAL ) ;}memcpy ( p , np -> file -> basename_utf16 . s , l ) ;","if ( ( l = np -> file -> basename_utf16 . length ) > ffmax ) l = ffmax ;if ( np -> file -> basename_utf16 . s , l ) ;",5116
1426,"if ( ( int ) np -> file -> basename_utf16 . length > ffmax ) {if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) {","if ( ( int ) np -> file -> basename_utf16 . length > ffmax ) {if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) {",5116
1427,"if ( parent_len + np -> mb_len > 240 ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""The<S2SV_blank>regulation<S2SV_blank>of<S2SV_blank>Joliet<S2SV_blank>extensions;if ( ( int ) l == ffmax )  noff = ext_off - 6 ;else if ( ( int ) l == ffmax - 2 )  noff = ext_off - 4 ;else if ( ( int ) l == ffmax - 4 )  noff = ext_off - 2 ;","if ( parent_len > 240 || np -> mb_len > 240 || parent_len + np -> mb_len > 240 ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""The<S2SV_blank>regulation<S2SV_blank>of<S2SV_blank>Joliet<S2SV_blank>extensions;if ( l == ffmax ) noff = ext_off - 6 ;else if ( l == ffmax - 2 ) noff = ext_off - 4 ;else if ( l == ffmax - 4 ) noff = ext_off - 2 ;",5116
1428,"vpx_memcpy ( cpi -> active_map , map , rows * cols ) ;cpi -> active_map_enabled = 1 ;","memcpy ( cpi -> active_map , map , rows * cols ) ;cpi -> active_map_enabled = 1 ;",5117
1429,"
",struct mnt_namespace * ns ;,5118
1430,"bool disconnect ;p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;list_del_init ( & p -> mnt_expire ) ;list_del_init ( & p -> mnt_list ) ;__touch_mnt_namespace ( p -> mnt_ns ) ;p -> mnt_ns = NULL ;","bool disconnect ;p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;ns = p -> mnt_ns ;if ( ns ) {ns -> mounts -- ;__touch_mnt_namespace ( ns ) ;}p -> mnt_ns ) ;p -> mnt_ns = NULL ;",5118
1431,"static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  {","static void show_object ( struct object * object , const char * last , void * data ) {",5119
1432,switch ( bsize ) {case BLOCK_64X64 : {i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ;,node -> part_variances = NULL ;switch ( bsize ) {case BLOCK_64X64 : {i ++ ) node -> split [ i ] . part_variances . none ;break ;}case BLOCK_4X4 : {v4x4 * vt = ( v4x4 * ) data ;node -> part_variances = & vt -> part_variances ;for ( i = 0 ;i < 4 ;i ++ ) node -> split [ i ] = & vt -> split [ i ] = & vt -> split [ i ] . part_variances . none ;,5120
1433,i ++ )  node -> split [ i ] = & vt -> split [ i ] ;break ;}},i ++ ) node -> split [ i ] = & vt -> split [ i ] ;break ;break ;}},5120
1434,case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool :  case NPNVSupportsWindowless :  type = RPC_TYPE_BOOLEAN ;,case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ;,5121
1435,"vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ;vpx_memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ;vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ;","memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ;memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ;memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ;",5122
1436,"vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ;dst_ptr1 += dst_pitch ;vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ;dst_ptr2 += dst_pitch ;","memcpy ( dst_ptr1 , src_ptr1 , linesize ) ;dst_ptr1 += dst_pitch ;memcpy ( dst_ptr2 , src_ptr2 , linesize ) ;dst_ptr2 += dst_pitch ;",5122
1437,if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) {r_asn1_free_object ( object ) ;,if ( ! object || object -> list . length != 2 || ! object -> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || object -> list . objects [ 1 ] -> list . length != 1 ) {r_asn1_free_object ( object ) ;,5123
1438,if ( flags & MSG_OOB )  return - EOPNOTSUPP ;if ( addr_len ) * addr_len = sizeof ( * sin6 ) ;,if ( flags & MSG_OOB ) return - EOPNOTSUPP ;if ( addr_len ) * addr_len = sizeof ( * sin6 ) ;,5124
1439,"sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;}","sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ;* addr_len = sizeof ( * sin6 ) ;}",5124
1440,data = dm9000ReadReg ( DM9000_REG_MRCMDX ) ;DM9000_INDEX_REG = DM9000_REG_MRCMDX1 ;status = LSB ( DM9000_DATA_REG ) ;DM9000_INDEX_REG = DM9000_REG_MRCMD ;status = MSB ( DM9000_DATA_REG ) ;if ( ( status & ( RSR_LCS | RSR_RWTO | RSR_PLE | RSR_AE | RSR_CE | RSR_FOE ) ) == 0 )  {,data = dm9000ReadReg ( DM9000_MRCMDX ) ;DM9000_INDEX_REG = DM9000_REG_MRCMDX1 ;status = LSB ( DM9000_DATA_REG ) ;DM9000_INDEX_REG = DM9000_MRCMD ;status = MSB ( DM9000_DATA_REG ) ;if ( ( status & ( DM9000_RSR_LCS | DM9000_RSR_RWTO | DM9000_RSR_PLE | DM9000_RSR_AE | DM9000_RSR_CE | DM9000_RSR_FOE ) ) == 0 ) {,5125
1441,"kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ;if ( ! kwonlyargs && nkwonlyargs ) return NULL ;posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ;if ( ! posdefaults && nposdefaults ) return NULL ;kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ;if ( ! kwdefaults && nkwonlyargs ) return NULL ;if ( nposargs + nkwonlyargs > 255 ) {ast_error ( c , n , ""more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments"" ) ;return NULL ;}","
",5126
1442,"if ( ! arg ) return NULL ;asdl_seq_SET ( posargs , k ++ , arg ) ;i += 1 ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;if ( TYPE ( ch ) == COMMA ) {int res = 0 ;i += 2 ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) {ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ;if ( res == - 1 ) return NULL ;i = res ;}else {vararg = ast_for_arg ( c , ch ) ;if ( ! vararg ) return NULL ;i += 2 ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) {vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ;if ( res == - 1 ) return NULL ;i = res ;}}break ;case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ;assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ;kwarg = ast_for_arg ( c , ch ) ;if ( ! kwarg ) return NULL ;i += 2 ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;","if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;if ( TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) {ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ;if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) {vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ;if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",5126
1443,return SECURE_ELEMENT_ERROR_NPE ;},return SECURE_ELEMENT_ERROR_NPE ;}if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) {return SECURE_ELEMENT_ERROR_BUF_SIZE ;},5127
1444,"if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ;","if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ;",5128
1445,if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) ||  skb -> len < nlh -> nlmsg_len ) {err = - EINVAL ;goto ack ;,if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) ) {nfnl_err_reset ( & err_list ) ;status |= NFNL_BATCH_FAILURE ;goto done ;,5128
1446,"ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ;if ( ret < total_len ) {dev_err ( ddev , ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor<S2SV_blank>set\\\if ( ret >= 0 ) ret = - ENOMSG ;goto err ;}total_len -= length ;for ( i = 0 ;i < num ;i ++ ) {buffer += length ;cap = ( struct usb_dev_cap_header * ) buffer ;length = cap -> bLength ;if ( total_len < length ) break ;",if ( total_len < sizeof ( * cap ) || total_len < cap -> bLength ;if ( total_len < length ) break ;,5129
1447,"
","if ( ! ape -> totalframes ) {av_log ( s , AV_LOG_ERROR , ""No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\\return AVERROR ( EINVAL ) ;}",5130
1448,"if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) {av_log ( s , AV_LOG_ERROR , ""Too<S2SV_blank>many<S2SV_blank>frames:<S2SV_blank>%d\\\","if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) {av_log ( s , AV_LOG_ERROR , ""Too<S2SV_blank>many<S2SV_blank>frames:<S2SV_blank>%d\\\",5130
1449,"static int prob_diff_update_cost ( vp9_prob newp , vp9_prob oldp ) {int delp = remap_prob ( newp , oldp ) ;","static int prob_diff_update_cost ( vpx_prob newp , vpx_prob oldp ) {int delp = remap_prob ( newp , oldp ) ;",5131
1450,for ( i = 0 ;i ++ )   chunk_size [ i ] = avio_rl32 ( pb ) ;for ( i = 0 ;i ++ )   chunk_offset [ i ] = avio_rl32 ( pb ) ;for ( i = 0 ;i ++ )  audio_size [ i ] = avio_rl32 ( pb ) & 0xFFFF ;for ( i = 0 ;if ( chunk_size [ i ] < 0 || audio_size [ i ] > chunk_size [ i ] ) {,for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;chunk_size [ i ] = avio_rl32 ( pb ) ;}for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;chunk_offset [ i ] = avio_rl32 ( pb ) ;}for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;audio_size [ i ] = avio_rl32 ( pb ) & 0xFFFF ;}for ( i = 0 ;if ( chunk_size [ i ] < 0 || audio_size [ i ] > chunk_size [ i ] ) {,5132
1451,"key = getDirective ( line , & value ) ;if ( ! state -> enabled ) {","if ( ( key = getDirective ( line , & value ) ) == 0 ) {continue ;}if ( ! state -> enabled ) {",5133
1452,}else if ( ctx -> pbi == NULL ) {ctx -> get_ext_fb_cb = cb_get ;,}else if ( ctx -> frame_workers == NULL ) {ctx -> get_ext_fb_cb = cb_get ;,5134
1453,"env -> used_maps [ env -> used_map_cnt ++ ] = map ;bpf_map_inc ( map , false ) ;fdput ( f ) ;","map = bpf_map_inc ( map , false ) ;if ( IS_ERR ( map ) ) {fdput ( f ) ;return PTR_ERR ( map ) ;}env -> used_maps [ env -> used_map_cnt ++ ] = map ;fdput ( f ) ;",5135
1454,if ( IS_ERR ( index_key . type ) ) {key_ref = ERR_PTR ( - ENODEV ) ;goto error ;}key_ref = ERR_PTR ( - EINVAL ) ;if ( ! index_key . type -> match || ! index_key . type -> instantiate ||  ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ;,if ( ! index_key . type -> match || ! index_key . type -> instantiate || ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ;,5136
1455,if ( * p != IAC )  goto pktend ;,ND_TCHECK ( * p ) ;if ( * p != IAC ) goto pktend ;,5137
1456,"daddy = malloc ( sizeof ( creator_template ) ) ;memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ;","daddy = safe_calloc ( sizeof ( creator_template ) ) ;memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ;",5138
1457,"int start [ ] = {Py_file_input , Py_eval_input , Py_single_input }PyObject * result ;if ( flags &  ~ ( PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST ) )  {PyErr_SetString ( PyExc_ValueError , ""compile():<S2SV_blank>unrecognised<S2SV_blank>flags"" ) ;","int start [ ] = {Py_file_input , Py_eval_input , Py_single_input , Py_func_type_input }PyObject * result ;if ( flags & ~ ( PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST | PyCF_TYPE_COMMENTS ) ) {PyErr_SetString ( PyExc_ValueError , ""compile()<S2SV_blank>mode<S2SV_blank>\\\'func_type\\\'<S2SV_blank>requires<S2SV_blank>flag<S2SV_blank>PyCF_ONLY_AST"" ) ;goto error ;}compile_mode = 3 ;}else {const char * msg ;if ( flags & PyCF_ONLY_AST ) msg = ""compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'exec\\\',<S2SV_blank>\\\'eval\\\',<S2SV_blank>\\\'single\\\'<S2SV_blank>or<S2SV_blank>\\\'func_type\\\'"" ;else msg = ""compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'exec\\\',<S2SV_blank>\\\'eval\\\'<S2SV_blank>or<S2SV_blank>\\\'single\\\'"" ;PyErr_SetString ( PyExc_ValueError , msg ) ;",5139
1458,"else {PyErr_SetString ( PyExc_ValueError ,  ""compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'exec\\\',<S2SV_blank>\\\'eval\\\'<S2SV_blank>or<S2SV_blank>\\\'single\\\'"" ) ;goto error ;","else if ( strcmp ( mode , ""func_type"" ) == 0 ) {if ( ! ( flags & PyCF_ONLY_AST ) ) {PyErr_SetString ( PyExc_ValueError , ""compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'exec\\\',<S2SV_blank>\\\'eval\\\'<S2SV_blank>or<S2SV_blank>\\\'single\\\'"" ) ;goto error ;",5139
1459,"char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ;printf ( ""Extracting<S2SV_blank>%s\\\","char * outname = create_output_name ( f [ i ] -> filename , NULL , 0 , 1 , 0 ) ;printf ( ""Extracting<S2SV_blank>%s\\\",5140
1460,if ( size < 6 )  ASSERT ( result != buf ) ;},"if ( size < 5 + 1 ) ASSERT ( result != buf ) ;for ( size = 0 ;size <= 8 ;size ++ ) {size_t length ;char * result ;memcpy ( buf , ""DEADBEEF"" , 8 ) ;length = size ;result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ;ASSERT ( result != NULL ) ;ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ;ASSERT ( length == 126 ) ;if ( size < 126 + 1 ) ASSERT ( result != buf ) ;ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ;if ( result != buf ) free ( result ) ;}}",5141
1461,"char combname [ L_BUF_SIZE ] ;l_int32 i , nsels , sx , sy , found ;if ( direction == L_HORIZ )  snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ;else  snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ;found = FALSE ;","char combname [ L_BUFSIZE ] ;l_int32 i , nsels , sx , sy , found ;if ( direction == L_HORIZ ) snprintf ( combname , L_BUFSIZE , ""sel_comb_%dh"" , size ) ;else snprintf ( combname , L_BUFSIZE , ""sel_comb_%dv"" , size ) ;found = FALSE ;",5142
1462,"static void update_switchable_interp_probs ( VP9_COMMON * cm , vp9_writer * w ) {int j ;++ j ) prob_diff_update ( vp9_switchable_interp_tree ,  cm -> fc . switchable_interp_prob [ j ] ,   cm -> counts . switchable_interp [ j ] , SWITCHABLE_FILTERS , w ) ;}","static void update_switchable_interp_probs ( VP9_COMMON * cm , vpx_writer * w , FRAME_COUNTS * counts ) {int j ;+ j ) prob_diff_update ( vp9_switchable_interp_tree ,  cm -> fc . switchable_interp_prob [ j ] ,   cm -> counts . switchable_interp [ j ] , SWITCHABLE_FILTERS , w ) ;++ j ) prob_diff_update ( vp9_switchable_interp_tree , cm -> fc -> switchable_interp_prob [ j ] , cm -> counts . switchable_interp [ j ] , SWITCHABLE_FILTERS , w ) ;}",5143
1463,"err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX ,   attrs [ TIPC_NLA_SOCK ] ,  tipc_nl_sock_policy ) ;tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ;}lock_sock ( & tsk -> sk ) ;err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ;","if ( ! attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ;err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ;if ( err ) return err ;if ( ! sock [ TIPC_NLA_SOCK_REF ] ) return - EINVAL ;tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ;}lock_sock ( & tsk -> sk ) ;err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ;",5144
1464,"
",ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;,5145
1465,"truncate_pagecache ( inode , ioffset ) ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;goto out_dio ;}","truncate_pagecache ( inode , ioffset ) ;goto out_mmap ;}",5145
1466,out_stop : ext4_journal_stop ( handle ) ;out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;,out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;ext4_inode_resume_unlocked_dio ( inode ) ;,5145
1467,"if ( size < sizeof ( outarg ) ) goto err ;err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ;err = - ENAMETOOLONG ;if ( outarg . namelen > FUSE_NAME_MAX ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ;if ( err ) goto err ;","if ( size != sizeof ( outarg ) + outarg . namelen > FUSE_NAME_MAX ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ;",5146
1468,if ( ( int ) arg >= cdi -> capacity )  return - EINVAL ;,if ( arg >= cdi -> capacity ) return - EINVAL ;,5147
1469,"nfca_poll -> rats_res_len = * data ++ ;pr_debug ( ""rats_res_len<S2SV_blank>%d\\\nfcb_poll -> attrib_res_len = * data ++ ;pr_debug ( ""attrib_res_len<S2SV_blank>%d\\\","nfca_poll -> rats_res_len = min_t ( __u8 , * data ++ , 20 ) ;pr_debug ( ""rats_res_len<S2SV_blank>%d\\\nfcb_poll -> attrib_res_len = min_t ( __u8 , * data ++ , 50 ) ;pr_debug ( ""attrib_res_len<S2SV_blank>%d\\\",5148
1470,r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ;r1 . tstamp = tstamp ;,"memset ( & r1 , 0 , sizeof ( r1 ) ) ;r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ;r1 . tstamp = tstamp ;",5149
1471,"set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ;err = hci_uart_register_dev ( hu ) ;clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ;return err ;}","err = hci_uart_register_dev ( hu ) ;clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ;",5150
1472,"vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;xd -> left_available = 0 ;","memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;xd -> left_available = 0 ;",5151
1473,"vpx_memcpy ( ( pbi -> mt_yabove_row [ mb_row + 1 ] + 32 + mb_col * 16 ) , ( xd -> dst . y_buffer + 15 * recon_y_stride ) , 16 ) ;vpx_memcpy ( ( pbi -> mt_uabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . u_buffer + 7 * recon_uv_stride ) , 8 ) ;vpx_memcpy ( ( pbi -> mt_vabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . v_buffer + 7 * recon_uv_stride ) , 8 ) ;}","memcpy ( ( pbi -> mt_yabove_row [ mb_row + 1 ] + 32 + mb_col * 16 ) , ( xd -> dst . y_buffer + 15 * recon_y_stride ) , 16 ) ;memcpy ( ( pbi -> mt_uabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . u_buffer + 7 * recon_uv_stride ) , 8 ) ;memcpy ( ( pbi -> mt_vabove_row [ mb_row + 1 ] + 16 + mb_col * 8 ) , ( xd -> dst . v_buffer + 7 * recon_uv_stride ) , 8 ) ;}",5151
1474,"static PyTypeObject * make_type ( char * type , PyTypeObject * base , char * * fields , int num_fields )  {PyObject * fnames , * result ;","static PyTypeObject * make_type ( char * type , PyTypeObject * base , char * * fields , int num_fields ) {_Py_IDENTIFIER ( __module__ ) ;_Py_IDENTIFIER ( _ast3 ) ;PyObject * fnames , * result ;",5152
1475,"result = PyObject_CallFunction ( ( PyObject * ) & PyType_Type , ""s(O){sOss}"" ,   type , base , ""_fields"" , fnames , ""__module__"" , ""_ast3"" ) ;Py_DECREF ( fnames ) ;","result = PyObject_CallFunction ( ( PyObject * ) & PyType_Type , ""s(O){OOOO}"" , type , base , ""_fields"" , fnames , _PyUnicode_FromId ( & PyId___module__ ) , _PyUnicode_FromId ( & PyId__ast3 ) ) ;Py_DECREF ( fnames ) ;",5152
1476,"count = be32_to_cpu ( aclp -> acl_cnt ) ;acl = posix_acl_alloc ( count , GFP_KERNEL ) ;","count = be32_to_cpu ( aclp -> acl_cnt ) ;if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ;acl = posix_acl_alloc ( count , GFP_KERNEL ) ;",5153
1477,sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ;if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) {,"sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ;if ( s -> ref && sh -> first_slice_in_pic_flag ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\\return 1 ;}if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) {",5154
1478,"* outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ;if ( * outlen < 0 ) return * outlen ;","* outlen = utf8s_to_utf16s ( name , len , UTF16_HOST_ENDIAN , ( wchar_t * ) outname , FAT_LFN_LEN + 2 ) ;if ( * outlen < 0 ) return * outlen ;",5155
1479,"else if ( rc == - ENODATA )  rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ;return rc ;}","else if ( rc == - ENODATA && inode -> i_op -> removexattr ) {rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ;}return rc ;}",5156
1480,"static inline int mount_entry_on_generic ( struct mntent * mntent ,  const char * path )  {","static inline int mount_entry_on_generic ( struct mntent * mntent , const char * path , const char * rootfs ) {",5157
1481,"ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type ,  mntflags , mntdata , optional ) ;free ( mntdata ) ;","ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , mntflags , mntdata , optional , rootfs ) ;free ( mntdata ) ;",5157
1482,"static int tile_worker_hook ( void * arg1 , void * arg2 ) {TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ;const TileInfo * const tile = ( TileInfo * ) arg2 ;int mi_row , mi_col ;for ( mi_row = tile -> mi_row_start ;mi_row < tile -> mi_row_end ;mi_row += MI_BLOCK_SIZE ) {vp9_zero ( tile_data -> xd . left_context ) ;vp9_zero ( tile_data -> xd . left_seg_context ) ;for ( mi_col = tile -> mi_col_start ;mi_col < tile -> mi_col_end ;mi_col += MI_BLOCK_SIZE ) {decode_partition ( tile_data -> cm , & tile_data -> xd , tile ,   mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 ) ;}","static int tile_worker_hook ( TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ;const TileInfo * const tile ) {int mi_row , mi_col ;if ( setjmp ( tile_data -> pbi , & tile_data -> xd , tile , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ;}",5158
1483,section -> intra_error -= frame -> intra_error ;section -> coded_error -= frame -> coded_error ;section -> sr_coded_error -= frame -> sr_coded_error ;section -> ssim_weighted_pred_err -= frame -> ssim_weighted_pred_err ;section -> pcnt_inter -= frame -> pcnt_inter ;section -> pcnt_neutral -= frame -> pcnt_neutral ;section -> MVr -= frame -> MVr ;,section -> pcnt_inter -= frame -> pcnt_inter ;section -> pcnt_neutral -= frame -> pcnt_neutral ;section -> intra_skip_pct -= frame -> intra_skip_pct ;section -> inactive_zone_rows -= frame -> inactive_zone_rows ;section -> inactive_zone_cols -= frame -> inactive_zone_cols ;section -> MVr -= frame -> MVr ;,5159
1484,}off = regs [ regno ] . off + regs [ regno ] . var_off . value ;,return - EACCES ;}off = regs [ regno ] . off + regs [ regno ] . var_off . value ;,5160
1485,"if ( ret < 0 || ret >= MAXPATHLEN ) {ERROR ( ""Error<S2SV_blank>calculating<S2SV_blank>container<S2SV_blank>/dev<S2SV_blank>location"" ) ;return - 1 ;}if ( ! dir_exists ( path ) ) return 0 ;INFO ( ""Populating<S2SV_blank>container<S2SV_blank>/dev"" ) ;cmask = umask ( S_IXUSR | S_IXGRP | S_IXOTH ) ;for ( i = 0 ;i < sizeof ( lxc_devs ) / sizeof ( lxc_devs [ 0 ] ) ;i ++ ) {const struct lxc_devs * d = & lxc_devs [ i ] ;ret = snprintf ( path , MAXPATHLEN , ""%s/dev/%s"" , rootfs -> path ? rootfs -> mount : """" , d -> name ) ;if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ;ret = mknod ( path , d -> mode , makedev ( d -> maj , d -> min ) ) ;if ( ret && errno != EEXIST ) {char hostpath [ MAXPATHLEN ] ;FILE * pathfile ;ret = snprintf ( hostpath , MAXPATHLEN , ""/dev/%s"" , d -> name ) ;if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ;pathfile = fopen ( path , ""wb"" ) ;if ( ! pathfile ) {SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>device<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\\\'%s\\\'"" , path ) ;return - 1 ;}fclose ( pathfile ) ;if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) {SYSERROR ( ""Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container"" , d -> name ) ;","if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : NULL ) != 0 ) {SYSERROR ( ""Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container"" , d -> name ) ;",5161
1486,"
",shp -> shm_cprid = task_tgid_vnr ( current ) ;shp -> shm_lprid = 0 ;shp -> shm_atim = shp -> shm_dtim = 0 ;shp -> shm_ctim = get_seconds ( ) ;shp -> shm_segsz = size ;shp -> shm_nattch = 0 ;shp -> shm_file = file ;shp -> shm_creator = current ;,5162
1487,"id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ;if ( id < 0 ) {shp -> shm_cprid = task_tgid_vnr ( current ) ;shp -> shm_lprid = 0 ;shp -> shm_atim = shp -> shm_dtim = 0 ;shp -> shm_ctim = get_seconds ( ) ;shp -> shm_segsz = size ;shp -> shm_nattch = 0 ;shp -> shm_file = file ;shp -> shm_creator = current ;","id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ;if ( id < 0 ) {",5162
1488,"
",if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;,5163
1489,"uint32_t vsize = avio_rb32 ( pb ) ;avio_skip ( pb , 8 ) ;","uint32_t vsize = avio_rb32 ( pb ) ;avio_skip ( pb , 8 ) ;",5163
1490,"status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ;out : return status ;","status = decode_getacl ( xdr , rqstp , res ) ;out : return status ;",5164
1491,assert ( bus >= 0 && bus < MAXBUSES ) ;return ( pci_businfo [ bus ] != NULL ) ;,return ( pci_businfo [ bus ] != NULL ) ;,5165
1492,if ( ( plen == 0 ) || ( offset + plen > length ) )  break ;,if ( ( plen < sizeof ( struct sctp_paramhdr ) ) || ( offset + plen > length ) ) break ;,5166
1493,"mem_free ( gr . gr_ctx . value ,  sizeof ( gss_union_ctx_id_desc ) ) ;gss_release_buffer ( & min_stat , & gd -> checksum ) ;mem_free ( gr . gr_ctx . value , sizeof ( gss_union_ctx_id_desc ) ) ;","gss_release_buffer ( & min_stat , & gd -> checksum ) ;",5167
1494,"int v , i ;if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) {","int v , i ;if ( ! ( s -> state & PNG_IHDR ) ) {av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>before<S2SV_blank>IHDR\\\return AVERROR_INVALIDDATA ;}if ( s -> state & PNG_IDAT ) {av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>after<S2SV_blank>IDAT\\\return AVERROR_INVALIDDATA ;}if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) {",5168
1495,if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) ||  ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) )  return AVERROR_INVALIDDATA ;,if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) || s -> bit_depth == 1 ) return AVERROR_INVALIDDATA ;,5168
1496,"struct mb_cache *   ext4_xattr_create_cache ( char * name )  {return mb_cache_create ( name , HASH_BUCKET_BITS ) ;}",struct mb2_cache * ext4_xattr_create_cache ( char * name ) {return mb2_cache_create ( HASH_BUCKET_BITS ) ;},5169
1497,"u64 rem ;nsec = rtc_time ( ) * sgi_clock_period ;sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ;","u32 rem ;nsec = rtc_time ( ) * sgi_clock_period ;sgi_clock_offset . tv_sec = tp -> tv_sec - div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ;",5170
1498,p_fm_config_conx_hdlt hdl ;int instance = 0 ;,p_fm_config_conx_hdlt hdl = NULL ;int instance = 0 ;,5171
1499,"goto die_clean ;}goto die_clean ;}return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;}}die_clean :  if ( hdl ) free ( hdl ) ;return res ;}","goto cleanup ;}goto cleanup ;}res = commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;goto cleanup ;}}cleanup : if ( hdl ) {if ( hdl -> sm_hdl ) {if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ;}if ( hdl -> pm_hdl ) {if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ;}if ( hdl -> fe_hdl ) {if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ;}free ( hdl ) ;}return res ;}",5171
1500,next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ;if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ;,loff_t max_chunk_size = UINT_MAX & bsize_mask ;next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ;if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ;,5172
1501,"if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ;while ( len > 0 ) {if ( len < bytes ) bytes = len ;al = gfs2_alloc_get ( ip ) ;if ( ! al ) {error = - ENOMEM ;goto out_unlock ;}error = gfs2_quota_lock_check ( ip ) ;if ( error ) goto out_alloc_put ;retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ;error = gfs2_inplace_reserve ( ip ) ;if ( error ) {if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) {bytes >>= 1 ;bytes &= bsize_mask ;if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ;goto retry ;}goto out_qunlock ;}max_bytes = bytes ;calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ;al -> al_requested = data_blocks + ind_blocks ;","if ( ! gfs2_write_alloc_required ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , & max_bytes , & data_blocks , & ind_blocks ) ;",5172
1502,"case 41 :  if ( optlen == 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ;else  ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ;break ;case 42 :  if ( optlen == 4 )   ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ;else  ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ;break ;","case 41 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6]"" ) ) ;else ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ;break ;case 42 : switch ( optlen ) {case 6 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_16BITS ( option + 2 ) ) ) ;break ;case 8 : ND_PRINT ( ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6]"" ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)"" , EXTRACT_16BITS ( option + 6 ) ) ) ;break ;case 10 : ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)"" , EXTRACT_32BITS ( option + 6 ) ) ) ;break ;default : ND_PRINT ( ( ndo , ""<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6<S2SV_blank>or<S2SV_blank>8<S2SV_blank>or<S2SV_blank>10]"" ) ) ;break ;}break ;case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ;else if ( optlen == 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( option + 2 ) ) ) ;else ND_PRINT ( ( ndo , ""<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4"" ) ) ;break ;",5173
1503,"if ( opt_len != 4 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ;","if ( opt_len != PGM_OPT_LENGTH_LEN ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ;return ;}bp += 2 ;seq = EXTRACT_32BITS ( bp ) ;bp += 4 ;offset = EXTRACT_32BITS ( bp ) ;bp += 4 ;len = EXTRACT_32BITS ( bp ) ;bp += 4 ;ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ;opts_len -= PGM_OPT_FRAGMENT_LEN ;break ;case PGM_OPT_NAK_LIST : bp += 2 ;opt_len -= 4 ;}break ;case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) if ( opt_len < 4 ) {ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ;return ;}ND_TCHECK2 ( * bp , 4 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ;bp += 4 ;opt_len -= 4 ;opts_len -= PGM_OPT_LENGTH_LEN ;break ;case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_JOIN_LEN ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN ) ) ;",5174
1504,"case PGM_OPT_LENGTH :  if ( opt_len != 4 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ;bp += sizeof ( uint16_t ) ;opts_len -= 4 ;break ;case PGM_OPT_FRAGMENT :  if ( opt_len != 16 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>16]"" , opt_len ) ) ;bp += sizeof ( uint32_t ) ;offset = EXTRACT_32BITS ( bp ) ;opts_len -= 16 ;break ;case PGM_OPT_NAK_LIST : bp += 2 ;opt_len -= sizeof ( uint32_t ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ;while ( opt_len ) {if ( opt_len < sizeof ( uint32_t ) ) {ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ;ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ;bp += sizeof ( uint32_t ) ;opts_len -= sizeof ( uint32_t ) ;}case PGM_OPT_JOIN :  if ( opt_len != 8 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ;seq = EXTRACT_32BITS ( bp ) ;bp += sizeof ( uint32_t ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ;opts_len -= 8 ;break ;case PGM_OPT_NAK_BO_IVL :  if ( opt_len != 12 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]"" , opt_len ) ) ;bp += 2 ;offset = EXTRACT_32BITS ( bp ) ;bp += sizeof ( uint32_t ) ;bp += sizeof ( uint32_t ) ;opts_len -= 12 ;break ;case PGM_OPT_NAK_BO_RNG :  if ( opt_len != 12 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]"" , opt_len ) ) ;bp += 2 ;offset = EXTRACT_32BITS ( bp ) ;opts_len -= 12 ;break ;case PGM_OPT_REDIRECT : bp += 2 ;nla_afnum = EXTRACT_16BITS ( bp ) ;bp += ( 2 * sizeof ( uint16_t ) ) ;switch ( nla_afnum ) {case AFNUM_INET :  if ( opt_len != 4 + sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ;opts_len -= 4 + sizeof ( struct in_addr ) ;break ;case AFNUM_INET6 :  if ( opt_len != 4 + sizeof ( struct in6_addr ) ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ;bp += sizeof ( struct in6_addr ) ;opts_len -= 4 + sizeof ( struct in6_addr ) ;break ;default : goto trunc ;}ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ;break ;case PGM_OPT_PARITY_PRM :   if ( opt_len != 8 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ;return ;}bp += 2 ;len = EXTRACT_32BITS ( bp ) ;bp += sizeof ( uint32_t ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) ) ;opts_len -= 8 ;break ;case PGM_OPT_PARITY_GRP :  if ( opt_len != 8 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]"" , opt_len ) ) ;return ;}bp += 2 ;seq = EXTRACT_32BITS ( bp ) ;bp += sizeof ( uint32_t ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) ) ;opts_len -= 8 ;break ;","case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) if ( opt_len != 4 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ;bp += 4 ;ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ;bp += sizeof ( uint32_t ) ;offset = EXTRACT_32BITS ( bp ) ;opts_len -= PGM_OPT_JOIN_LEN ;break ;case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len < sizeof ( uint32_t ) ) {ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ;ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ;bp += sizeof ( uint32_t ) ;opts_len -= sizeof ( uint32_t ) ;}case PGM_OPT_JOIN : if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN ) ) ;offset = EXTRACT_32BITS ( bp ) ;bp += sizeof ( uint32_t ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ;opts_len -= 8 ;break ;case PGM_OPT_NAK_BO_IVL : if ( opt_len != 12 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]"" , opt_len ) ) ;bp += 2 ;offset = EXTRACT_32BITS ( bp ) ;bp += 4 ;bp += 4 ;opts_len -= 12 ;break ;case PGM_OPT_NAK_BO_RNG : if ( opt_len != 12 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]"" , opt_len ) ) ;bp += 2 ;offset = EXTRACT_32BITS ( bp ) ;opts_len -= PGM_OPT_NAK_BO_IVL_LEN ;break ;case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != 4 + sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ;opts_len -= 4 + sizeof ( struct in_addr ) ;break ;case AFNUM_INET6 : if ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN ) ) ;bp += 4 ;ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset , seq ) ) ;opts_len -= 8 ;",5174
1505,"opts_len -= 4 ;case PGM_OPT_FIN : if ( opt_len != 4 ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ;bp += 2 ;ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ;","opts_len -= PGM_OPT_NAK_BO_RNG_LEN ;case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ;ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ;bp += sizeof ( struct in_addr ) ;",5174
1506,"opts_len -= 4 ;case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ;bp += opt_len ;opts_len -= opt_len ;break ;case PGM_OPT_CRQST : if ( opt_len != 4 ) {",opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ;case AFNUM_INET6 : if ( opt_len != 4 ) {,5174
1507,"case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ;ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ;bp += sizeof ( struct in_addr ) ;","case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN , opt_len ) ) ;ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ;addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ;bp += sizeof ( struct in6_addr ) ;",5174
1508,"opts_len -= 12 + sizeof ( struct in6_addr ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ;case PGM_OPT_PGMCC_FEEDBACK : bp += 2 ;offset = EXTRACT_32BITS ( bp ) ;bp += sizeof ( uint32_t ) ;nla_afnum = EXTRACT_16BITS ( bp ) ;bp += ( 2 * sizeof ( uint16_t ) ) ;switch ( nla_afnum ) {case AFNUM_INET : if ( opt_len != 12 + sizeof ( struct in_addr ) ) {","opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ;case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) if ( opt_len != 12 + sizeof ( struct in_addr ) ) {",5174
1509,"case AFNUM_INET6 : if ( opt_len != 12 + sizeof ( struct in6_addr ) ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len ) ) ;ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ;addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ;bp += sizeof ( struct in6_addr ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ;","case AFNUM_INET6 : if ( opt_len != PGM_OPT_PARITY_PRM_LEN ) {ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ;bp += 2 ;len = EXTRACT_32BITS ( bp ) ;bp += 4 ;ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ;",5174
1510,static void cancel_att_send_op ( struct att_send_op * op )  {,static void cancel_att_send_op ( void * data ) {struct att_send_op * op = data ;,5175
1511,for ( i = 0 ;i < sec -> size ;ut32 addr32 = r_read_le32 ( buf + i ) ;,for ( i = 0 ;( i + 3 ) < sec -> size ;ut32 addr32 = r_read_le32 ( buf + i ) ;,5176
1512,for ( i = 0 ;i < sec -> size ;ut64 addr64 = r_read_le64 ( buf + i ) ;,for ( i = 0 ;( i + 7 ) < sec -> size ;ut64 addr64 = r_read_le64 ( buf + i ) ;,5176
1513,}else {uint32_t new_free_total = cache -> free_total * 2 ;,}else if ( cache -> free_total < NW_CACHE_MAX_SIZE ) {uint32_t new_free_total = cache -> free_total * 2 ;,5177
1514,}},}else {free ( obj ) ;}},5177
1515,jpc_tsfb_band_t bnds [ 64 ] ;jpc_pchg_t * pchg ;,jpc_tsfb_band_t bnds [ JPC_MAXBANDS ] ;jpc_pchg_t * pchg ;,5178
1516,"page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}","page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",5179
1517,"client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ;g_clear_object ( & client -> proxy ) ;g_hash_table_destroy ( client -> rewrite_reply ) ;","client -> proxy ) ;g_byte_array_free ( client -> auth_buffer , TRUE -> clients = g_list_remove ( client -> proxy -> clients , client ) ;g_clear_object ( & client -> proxy ) ;g_hash_table_destroy ( client -> rewrite_reply ) ;",5180
1518,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,5181
1519,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",5181
1520,"
","jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\",5182
1521,"if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) {goto error ;","if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) {goto error ;",5182
1522,# if HAVE_NEON  int64_t dx_store_reg [ 8 ] ;# endif VP8_COMMON * cm = & pbi -> common ;pbi -> common . error . error_code = VPX_CODEC_OK ;retcode = check_fragments_for_errors ( pbi ) ;# if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_push_neon ( dx_store_reg ) ;}# endif cm -> new_fb_idx = get_free_fb ( cm ) ;,VP8_COMMON * cm = & pbi -> common ;( void ) size ;( void ) source ;pbi -> common . error . error_code = VPX_CODEC_OK ;retcode = check_fragments_for_errors ( pbi ) ;cm -> new_fb_idx = get_free_fb ( cm ) ;,5183
1523,decode_exit :  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_pop_neon ( dx_store_reg ) ;# endif pbi -> common . error . setjmp = 0 ;return retcode ;},decode_exit : pbi -> common . error . setjmp = 0 ;vp8_clear_system_state ( ) ;return retcode ;,5183
1524,"
",ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;,5184
1525,"truncate_pagecache ( inode , ioffset ) ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;goto out_dio ;}","truncate_pagecache ( inode , ioffset ) ;goto out_mmap ;}",5184
1526,out_stop : ext4_journal_stop ( handle ) ;out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;,out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;ext4_inode_resume_unlocked_dio ( inode ) ;,5184
1527,ACPI_FUNCTION_TRACE ( NsTerminate ) ;# ifdef ACPI_EXEC_APP {ACPI_OPERAND_OBJECT * Next ;Next = AcpiGbl_ModuleCodeList ;}# endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ;,ACPI_OPERAND_OBJECT * Next ;ACPI_FUNCTION_TRACE ( NsTerminate ) ;Next = AcpiGbl_ModuleCodeList ;AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ;,5185
1528,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,5186
1529,"outpos +=  sprintf ( outpos , ""\\\}","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",5187
1530,"dm9000WriteReg ( DM9000_REG_MAR0 + i , hashTable [ i ] ) ;}TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAR<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>"" ""%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""\\\\r\\\","dm9000WriteReg ( DM9000_MAR0 + i , hashTable [ i ] ) ;}TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAR<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>"" ""%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""<S2SV_blank>%02"" PRIX8 ""\\\\r\\\",5188
1531,"}retval = xfs_attr3_leaf_add ( bp , args ) ;","args -> rmtvaluelen2 = args -> rmtvaluelen ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;args -> rmtvaluelen = 0 ;}retval = xfs_attr3_leaf_add ( bp , args ) ;",5189
1532,if ( args -> rmtblkno ) {error = xfs_attr_rmtval_remove ( args ) ;,args -> rmtvaluelen = args -> rmtvaluelen2 ;if ( args -> rmtblkno ) {error = xfs_attr_rmtval_remove ( args ) ;,5189
1533,"static const char *  parse_field ( netdissect_options * ndo , const char * * pptr , int * len )  {if ( * len <= 0 || ! pptr || ! * pptr )  return NULL ;if ( * pptr > ( const char * ) ndo -> ndo_snapend ) return NULL ;while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) {( * pptr ) ++ ;( * len ) -- ;}if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend )  return NULL ;","static const char * parse_field ( netdissect_options * ndo , const char * * pptr , int * len , int * truncated ) {while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) {",5190
1534,"size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE ,  CORE_MMU_USER_PARAM_SIZE ) ;if ( ADD_OVERFLOW ( uaddr , len , & a ) )  return TEE_ERROR_ACCESS_DENIED ;for ( a = uaddr ;a < ( uaddr + len ) ;uint32_t attr ;","uaddr_t end_addr = 0 ;size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , CORE_MMU_USER_PARAM_SIZE ) ;if ( ADD_OVERFLOW ( uaddr , len , & end_addr ) ) return TEE_ERROR_ACCESS_DENIED ;for ( a = ROUNDDOWN ( uaddr , addr_incr ) ;a < end_addr ;uint32_t attr ;",5191
1535,"size_t data_size =  calculate_camera_metadata_entry_data_size ( entry . type ,  entry . count ) ;if ( data_size != 0 ) {","size_t data_size ;if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , entry . type , entry . count ) != OK ) {ALOGE ( ""%s:<S2SV_blank>Entry<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>invalid.<S2SV_blank>type:<S2SV_blank>%u<S2SV_blank>count:<S2SV_blank>%u"" , __FUNCTION__ , entry . type , entry . count ) ;return ERROR ;}if ( data_size != 0 ) {",5192
1536,"
",ND_TCHECK_32BITS ( bp ) ;,5193
1537,temp = EXTRACT_32BITS ( bp ) ;bp += sizeof ( int32_t ) ;,temp = EXTRACT_32BITS ( bp ) ;bp += sizeof ( int32_t ) ;,5193
1538,"static char * mongo_data_append ( char * start , const void * data , int len ) {memcpy ( start , data , len ) ;","static char * mongo_data_append ( char * start , const void * data , size_t len ) {memcpy ( start , data , len ) ;",5194
1539,mmu_notifier_mm_init ( mm ) ;init_tlb_flush_pending ( mm ) ;,"RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;mmu_notifier_mm_init ( mm ) ;init_tlb_flush_pending ( mm ) ;",5195
1540,"* outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ;if ( * outlen < 0 ) return * outlen ;","* outlen = utf8s_to_utf16s ( name , len , UTF16_HOST_ENDIAN , ( wchar_t * ) outname , FAT_LFN_LEN + 2 ) ;if ( * outlen < 0 ) return * outlen ;",5196
1541,"int max_intra_size_pct ;vpx_codec_err_t res ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || codec_ctx == NULL || iface == NULL || enc_cfg == NULL ) {if ( si == NULL ) return VPX_CODEC_MEM_ERROR ;si -> codec_ctx = codec_ctx ;si -> width = enc_cfg -> g_w ;si -> height = enc_cfg -> g_h ;if ( enc_cfg -> kf_max_dist < 2 ) {svc_log ( svc_ctx , SVC_LOG_ERROR , ""key<S2SV_blank>frame<S2SV_blank>distance<S2SV_blank>too<S2SV_blank>small:<S2SV_blank>%d\\\return VPX_CODEC_INVALID_PARAM ;si -> kf_dist = enc_cfg -> kf_max_dist ;if ( svc_ctx -> spatial_layers == 0 ) svc_ctx -> spatial_layers = VPX_SS_DEFAULT_LAYERS ;if ( svc_ctx -> spatial_layers < 1 || svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) {svc_log ( svc_ctx , SVC_LOG_ERROR , ""spatial<S2SV_blank>layers:<S2SV_blank>invalid<S2SV_blank>value:<S2SV_blank>%d\\\return VPX_CODEC_INVALID_PARAM ;res = parse_quantizer_values ( svc_ctx , si -> quantizers , 0 ) ;if ( res != VPX_CODEC_OK ) return res ;res = parse_quantizer_values ( svc_ctx , si -> quantizers_keyframe , 1 ) ;if ( res != VPX_CODEC_OK )  memcpy ( si -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ;res = parse_scale_factors ( svc_ctx , si -> scale_factors ) ;if ( res != VPX_CODEC_OK ) return res ;res = parse_options ( svc_ctx , si -> options ) ;if ( res != VPX_CODEC_OK ) return res ;si -> layers = svc_ctx -> spatial_layers ;if ( si -> layers > 1 ) {int i ;float total = 0 ;float alloc_ratio [ VPX_SS_MAX_LAYERS ] = {0 };assert ( si -> layers <= VPX_SS_MAX_LAYERS ) ;i < si -> layers ;int pos = i + VPX_SS_MAX_LAYERS - svc_ctx -> spatial_layers ;if ( pos < VPX_SS_MAX_LAYERS && si -> scaling_factor_den [ pos ] > 0 ) {alloc_ratio [ i ] = ( float ) ( si -> scaling_factor_num [ pos ] * 1.0 / si -> scaling_factor_den [ pos ] ) ;alloc_ratio [ i ] *= alloc_ratio [ i ] ;total += alloc_ratio [ i ] ;i < si -> layers ;if ( total > 0 ) {enc_cfg -> ss_target_bitrate [ i ] = ( unsigned int ) ( enc_cfg -> rc_target_bitrate * alloc_ratio [ i ] / total ) ;}enc_cfg -> ss_number_layers = si -> layers ;enc_cfg -> ts_number_layers = 1 ;enc_cfg -> kf_mode = VPX_KF_DISABLED ;enc_cfg -> g_lag_in_frames = 0 ;enc_cfg -> rc_dropframe_thresh = 0 ;enc_cfg -> rc_end_usage = VPX_CBR ;if ( enc_cfg -> g_pass == VPX_RC_ONE_PASS ) {enc_cfg -> rc_min_quantizer = 33 ;enc_cfg -> rc_max_quantizer = 33 ;}enc_cfg -> rc_undershoot_pct = 100 ;enc_cfg -> rc_overshoot_pct = 15 ;enc_cfg -> rc_buf_initial_sz = 500 ;enc_cfg -> g_error_resilient = 1 ;res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR ) ;if ( res != VPX_CODEC_OK ) {vpx_codec_control ( codec_ctx , VP9E_SET_SVC , 1 ) ;vpx_codec_control ( codec_ctx , VP8E_SET_CPUUSED , 1 ) ;","vpx_codec_err_t res ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || codec_ctx == NULL || iface == NULL || enc_cfg == NULL ) {if ( svc_ctx -> temporal_layering_mode == 3 ) {svc_ctx -> temporal_layers = 3 ;else if ( svc_ctx -> temporal_layering_mode == 2 ) {svc_ctx -> temporal_layers = 2 ;i < VPX_SS_MAX_LAYERS ;si -> svc_params . max_quantizers [ i ] = MAX_QUANTIZER ;si -> svc_params . min_quantizers [ i ] = 0 ;si -> svc_params . scaling_factor_num [ i ] = DEFAULT_SCALE_FACTORS_NUM [ i ] ;si -> svc_params . scaling_factor_den [ i ] = DEFAULT_SCALE_FACTORS_DEN [ i ] ;res = parse_options ( svc_ctx , si -> options ) ;if ( res != VPX_CODEC_OK ) return res ;res = parse_quantizer_values ( svc_ctx , si -> quantizers_keyframe , 1 ) ;if ( res != VPX_CODEC_OK ) memcpy ( si -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ;res = parse_scale_factors ( svc_ctx , si -> scale_factors ) ;if ( res != VPX_CODEC_OK ) return res ;if ( svc_ctx -> spatial_layers < 1 ) svc_ctx -> spatial_layers = 1 ;if ( svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) svc_ctx -> spatial_layers = VPX_SS_MAX_LAYERS ;if ( svc_ctx -> temporal_layers < 1 ) svc_ctx -> temporal_layers = 1 ;if ( svc_ctx -> temporal_layers > VPX_TS_MAX_LAYERS ) svc_ctx -> temporal_layers = VPX_TS_MAX_LAYERS ;if ( svc_ctx -> temporal_layers * svc_ctx -> spatial_layers > VPX_MAX_LAYERS ) {svc_log ( svc_ctx , SVC_LOG_ERROR , ""spatial<S2SV_blank>layers<S2SV_blank>*<S2SV_blank>temporal<S2SV_blank>layers<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>"" ""allowed<S2SV_blank>layers<S2SV_blank>of<S2SV_blank>%d\\\return VPX_CODEC_INVALID_PARAM ;assign_layer_bitrates ( svc_ctx , enc_cfg ) ;# if CONFIG_SPATIAL_SVC for ( i = 0 ;i < svc_ctx -> spatial_layers ;++ i ) enc_cfg -> ss_enable_auto_alt_ref [ i ] = si -> enable_auto_alt_ref [ i ] ;# endif if ( svc_ctx -> temporal_layers > 1 ) {int i ;i < svc_ctx -> temporal_layers ;enc_cfg -> ts_target_bitrate [ i ] = enc_cfg -> rc_target_bitrate / svc_ctx -> temporal_layers ;enc_cfg -> ts_rate_decimator [ i ] = 1 << ( svc_ctx -> temporal_layers - 1 - i ) ;if ( svc_ctx -> threads ) enc_cfg -> g_threads = svc_ctx -> threads ;enc_cfg -> ss_number_layers = svc_ctx -> spatial_layers ;enc_cfg -> ts_number_layers = svc_ctx -> temporal_layers ;if ( enc_cfg -> rc_end_usage == VPX_CBR ) {enc_cfg -> rc_min_quantizer = 2 ;enc_cfg -> rc_max_quantizer = 63 ;enc_cfg -> rc_undershoot_pct = 50 ;enc_cfg -> rc_overshoot_pct = 50 ;enc_cfg -> rc_buf_initial_sz = 20 ;}if ( enc_cfg -> g_error_resilient == 0 && si -> use_multiple_frame_contexts == 0 ) enc_cfg -> g_error_resilient = 1 ;res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR ) ;if ( res != VPX_CODEC_OK ) {svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc_enc_init<S2SV_blank>error\\\return res ;}vpx_codec_control ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR ) ;if ( res != VPX_CODEC_OK ) {vpx_codec_control ( codec_ctx , VP9E_SET_SVC , 1 ) ;vpx_codec_control ( codec_ctx , VP8E_SET_CPUUSED , 1 ) ;",5197
1542,"BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t )  ldblk , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;","BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;",5198
1543,"if ( mk_security_check_url ( sr -> uri ) < 0 ) {PLUGIN_TRACE ( ""[FD<S2SV_blank>%i]<S2SV_blank>Close<S2SV_blank>connection,<S2SV_blank>blocked<S2SV_blank>URL"" , cs -> socket ) ;","if ( mk_security_check_url ( sr -> uri_processed ) < 0 ) {PLUGIN_TRACE ( ""[FD<S2SV_blank>%i]<S2SV_blank>Close<S2SV_blank>connection,<S2SV_blank>blocked<S2SV_blank>URL"" , cs -> socket ) ;",5199
1544,"char * ksep , * vsep , * val ;size_t klen , vlen ;vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {return 0 ;","char * start , * ksep , * vsep , * val ;size_t klen , vlen ;start = var -> ptr + var -> already_scanned ;vsep = memchr ( start , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {var -> already_scanned = var -> end - var -> ptr ;return 0 ;",5200
1545,return 1 ;},var -> already_scanned = 0 ;return 1 ;},5200
1546,"if ( ! strcmp ( page , ""/styles.css"" ) ) {",if ( ! page_name_is_good ( page ) ) {,5201
1547,"if ( strchr ( page , \'/\' ) )  {","if ( strchr ( page , \'/\' ) ) {",5201
1548,"entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ;if ( ! entries ) return - ENOMEM ;","entries = kmalloc_array ( cmap -> len , sizeof ( * entries ) , GFP_KERNEL ) ;if ( ! entries ) return - ENOMEM ;",5202
1549,const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || si == NULL ) return NULL ;,const SvcInternal_t * const si = get_const_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || si == NULL ) return NULL ;,5203
1550,int procfd = payload -> procfd ;lxc_attach_options_t * options = payload -> options ;,lxc_attach_options_t * options = payload -> options ;,5204
1551,"uid_t new_uid ;gid_t new_gid ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;","int lsm_labelfd ;uid_t new_uid ;gid_t new_gid ;ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;",5204
1552,"ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ;ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}new_uid = 0 ;new_gid = 0 ;if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ;if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ;if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ;if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) {if ( setsid ( ) < 0 ) {SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ;if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) {SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}}","ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s."" , strerror ( errno ) ) ;ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>"" ""that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s"" , strerror ( errno ) ) ;",5204
1553,"ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;","ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;",5204
1554,"rexit ( - 1 ) ;}INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;}on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {rexit ( - 1 ) ;}rexit ( - 1 ) ;}lxc_proc_put_context_info ( init_ctx ) ;if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ;if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ;if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ;if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ;if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ;if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ;for ( fd = 0 ;fd <= 2 ;fd ++ ) {flags = fcntl ( fd , F_GETFL ) ;if ( flags < 0 ) continue ;if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ;}close ( procfd ) ;rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;","shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>"" ""gainable<S2SV_blank>privileges."" ) ;}status = 3 ;ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ;if ( ret <= 0 ) {ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ;if ( ret <= 0 ) {ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( lsm_labelfd , on_exec , init_ctx -> lsm_label ) < 0 ) {SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label."" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;close ( lsm_labelfd ) ;rexit ( - 1 ) ;}close ( lsm_labelfd ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;",5204
1555,"int64_t vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x ,   const TileInfo * const tile ,  int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize ) {MACROBLOCKD * xd = & x -> e_mbd ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;struct macroblock_plane * const p = & x -> plane [ 0 ] ;MB_PREDICTION_MODE this_mode , best_mode = ZEROMV ;MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ;INTERP_FILTER best_pred_filter = EIGHTTAP ;int64_t best_rd = INT64_MAX ;int64_t this_rd = INT64_MAX ;int rate = INT_MAX ;int64_t dist = INT64_MAX ;VP9_COMMON * cm = & cpi -> common ;int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ;const int64_t inter_mode_thresh = RDCOST ( x -> rdmult , x -> rddiv ,  intra_cost_penalty , 0 ) ;const int64_t intra_mode_cost = 50 ;unsigned char segment_id = mbmi -> segment_id ;const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ;const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [ bsize ] ;int mode_idx [ MB_MODE_COUNT ] = {INTERP_FILTER filter_ref = SWITCHABLE ;x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;x -> skip = 0 ;if ( ! x -> in_active_map ) x -> skip = 1 ;* returnrate = INT_MAX ;* returndistortion = INT64_MAX ;vpx_memset ( mbmi , 0 , sizeof ( MB_MODE_INFO ) ) ;mbmi -> sb_type = bsize ;mbmi -> ref_frame [ 0 ] = NONE ;mbmi -> ref_frame [ 1 ] = NONE ;mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ;mbmi -> interp_filter = cpi -> common . interp_filter == SWITCHABLE ?  EIGHTTAP : cpi -> common . interp_filter ;mbmi -> skip = 0 ;mbmi -> segment_id = segment_id ;for ( ref_frame = LAST_FRAME ;","void vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , TileDataEnc * tile_data , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {VP9_COMMON * const cm = & cpi -> common ;SPEED_FEATURES * const sf = & cpi -> sf ;TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;MB_PREDICTION_MODE this_mode , best_mode = ZEROMV ;MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ;INTERP_FILTER best_pred_filter = EIGHTTAP ;RD_COST this_rdc , best_rdc ;uint8_t skip_txfm = SKIP_TXFM_NONE , best_mode_skip_txfm = SKIP_TXFM_NONE ;unsigned int var_y = UINT_MAX ;unsigned int sse_y = UINT_MAX ;const int reduction_fac = ( bsize <= BLOCK_16X16 ) ? ( ( bsize <= BLOCK_8X8 ) ? 4 : 2 ) : 0 ;const int intra_cost_penalty = vp9_get_intra_cost_penalty ( cm -> base_qindex , cm -> y_dc_delta_q ) ;const int64_t inter_mode_thresh = RDCOST ( x -> rdmult , x -> rddiv , intra_cost_penalty , 0 ) ;const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ;const int * const rd_thresh_freq_fact = tile_data -> thresh_freq_fact [ bsize ] ;int mode_idx [ MB_MODE_COUNT ] = {INTERP_FILTER filter_ref ;const int bsl = mi_width_log2_lookup [ bsize ] ;const int pred_filter_search = cm -> interp_filter == SWITCHABLE ? EIGHTTAP : cpi -> common . interp_filter ;mbmi -> skip = 0 ;mbmi -> segment_id = segment_id ;for ( ref_frame = LAST_FRAME ;",5205
1556,"}for ( ref_frame = LAST_FRAME ;ref_frame <= LAST_FRAME ;if ( ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) )  continue ;xd -> plane [ 0 ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ 0 ] ;clamp_mv2 ( & frame_mv [ NEARESTMV ] [ ref_frame ] . as_mv , xd ) ;clamp_mv2 ( & frame_mv [ NEARMV ] [ ref_frame ] . as_mv , xd ) ;mbmi -> ref_frame [ 0 ] = ref_frame ;if ( ref_frame == LAST_FRAME ) {mode_idx [ NEARESTMV ] = THR_NEARESTMV ;","else filter_ref = cm -> interp_filter ;vp9_rd_cost_reset ( & best_rdc ) ;vp9_rd_cost_reset ( rd_cost ) ;mbmi -> sb_type = bsize ;mbmi -> ref_frame [ 0 ] = NONE ;mbmi -> ref_frame [ 1 ] = NONE ;mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ;# if CONFIG_VP9_TEMPORAL_DENOISING vp9_denoiser_reset_frame_stats ( ctx ) ;# endif if ( cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) {usable_ref_frame = LAST_FRAME ;}else {usable_ref_frame = GOLDEN_FRAME ;}for ( ref_frame = LAST_FRAME ;ref_frame <= usable_ref_frame ;const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ;x -> pred_mv_sad [ ref_frame ] = INT_MAX ;frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ;frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ;if ( ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) && ( yv12 != NULL ) ) {int_mv * const candidates = x -> mbmi_ext -> ref_mvs [ ref_frame ] ;const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ;vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , sf , sf ) ;if ( cm -> use_prev_frame_mvs ) vp9_find_mv_refs ( cm , xd , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col , NULL , NULL , x -> mbmi_ext -> mode_context ) ;else const_motion [ ref_frame ] = mv_refs_rt ( cm , x , xd , tile_info , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col ) ;vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , & frame_mv [ NEARESTMV ] [ ref_frame ] , & frame_mv [ NEARMV ] [ ref_frame ] ) ;if ( ! vp9_is_scaled ( sf ) && bsize >= BLOCK_8X8 ) vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , ref_frame , bsize ) ;}else {ref_frame_skip_mask |= ( 1 << ref_frame ) ;}}for ( idx = 0 ;idx < RT_INTER_MODES ;++ idx ) {int rate_mv = 0 ;int mode_rd_thresh ;int mode_index ;int i ;int64_t this_sse ;int is_skippable ;int this_early_term = 0 ;PREDICTION_MODE this_mode = ref_mode_set [ idx ] . pred_mode ;if ( cpi -> use_svc ) this_mode = ref_mode_set_svc [ idx ] . pred_mode ;if ( ! ( cpi -> sf . inter_mode_mask [ bsize ] & ( 1 << this_mode ) ) ) continue ;if ( const_motion [ ref_frame ] && this_mode == NEARMV ) continue ;i = ( ref_frame == LAST_FRAME ) {mode_idx [ NEARESTMV ] = THR_NEARESTMV ;",5205
1557,"if ( cpi -> sf . disable_inter_mode_mask [ bsize ] &  ( 1 << INTER_OFFSET ( this_mode ) ) )  continue ;int rate_mode = 0 ;if ( this_rd < ( int64_t ) ( 1 << num_pels_log2_lookup [ bsize ] ) )  continue ;full_pixel_motion_search ( cpi , x , tile , bsize , mi_row , mi_col ,  & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv ) ;if ( frame_mv [ NEWMV ] [ ref_frame ] . as_int == INVALID_MV )  continue ;rate_mode = x -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ;if ( RDCOST ( x -> rdmult , x -> rddiv , rate_mv + rate_mode , 0 ) > best_rd ) continue ;sub_pixel_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ ref_frame ] . as_mv ) ;}if ( this_mode != NEARESTMV )  if ( frame_mv [ this_mode ] [ ref_frame ] . as_int == frame_mv [ NEARESTMV ] [ ref_frame ] . as_int ) continue ;mbmi -> mv [ 0 ] . as_int = frame_mv [ this_mode ] [ ref_frame ] . as_int ;if ( ( this_mode == NEWMV || filter_ref == SWITCHABLE ) &&  ( ( mbmi -> mv [ 0 ] . as_mv . row & 0x07 ) != 0 ||  ( mbmi -> mv [ 0 ] . as_mv . col & 0x07 ) != 0 ) ) {int64_t tmp_rdcost1 = INT64_MAX ;int64_t tmp_rdcost2 = INT64_MAX ;int64_t tmp_rdcost3 = INT64_MAX ;mbmi -> interp_filter = EIGHTTAP ;vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ;model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP ] ,   & pf_dist [ EIGHTTAP ] ) ;tmp_rdcost1 = RDCOST ( x -> rdmult , x -> rddiv ,  vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP ] ,  pf_dist [ EIGHTTAP ] ) ;mbmi -> interp_filter = EIGHTTAP_SHARP ;model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP_SHARP ] , & pf_dist [ EIGHTTAP_SHARP ] ) ;tmp_rdcost2 = RDCOST ( x -> rdmult , x -> rddiv , vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP_SHARP ] , pf_dist [ EIGHTTAP_SHARP ] ) ;mbmi -> interp_filter = EIGHTTAP_SMOOTH ;model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP_SMOOTH ] , & pf_dist [ EIGHTTAP_SMOOTH ] ) ;tmp_rdcost3 = RDCOST ( x -> rdmult , x -> rddiv , vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP_SMOOTH ] , pf_dist [ EIGHTTAP_SMOOTH ] ) ;if ( tmp_rdcost2 < tmp_rdcost1 ) {if ( tmp_rdcost2 < tmp_rdcost3 ) mbmi -> interp_filter = EIGHTTAP_SHARP ;else mbmi -> interp_filter = EIGHTTAP_SMOOTH ;","if ( cpi -> sf . disable_inter_mode_mask [ bsize ] & ( 1 << ref_frame ) ;if ( ref_frame_skip_mask & ( 1 << ref_frame ) ) continue ;for ( i = 0 ;i < MAX_MB_PLANE ;i ++ ) xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ;mbmi -> ref_frame [ 0 ] = ref_frame ;set_ref_ptrs ( cm , xd , ref_frame , NONE ) ;mode_index = mode_idx [ ref_frame ] [ INTER_OFFSET ( this_mode ) ] ;mode_rd_thresh = best_mode_skip_txfm ? rd_threshes [ mode_index ] << 1 : rd_threshes [ mode_index ] ;if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) ) continue ;if ( ref_frame > LAST_FRAME && ! cpi -> use_svc ) {int tmp_sad ;int dis , cost_list [ 5 ] ;if ( bsize < BLOCK_16X16 ) continue ;tmp_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ;if ( tmp_sad > x -> pred_mv_sad [ LAST_FRAME ] ) continue ;if ( tmp_sad + ( num_pels_log2_lookup [ bsize ] , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref_frame ] , NULL , 0 , 0 ) ;}else if ( ! combined_motion_search ( cpi , x , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_int != INVALID_MV ) {const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ;const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . col >> 3 ) ;best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ;x -> pred_mv_sad [ LAST_FRAME ] = best_pred_sad ;}if ( cpi -> use_svc ) {if ( this_mode == NEWMV && ref_frame == GOLDEN_FRAME && frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . col >> 3 ) ;best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ;x -> pred_mv_sad [ GOLDEN_FRAME ] = best_pred_sad ;}}if ( this_mode != NEARESTMV ) if ( frame_mv [ this_mode ] [ ref_frame ] . as_int == frame_mv [ NEARESTMV ] [ ref_frame ] . as_int ) continue ;mbmi -> mv [ 0 ] . as_int = frame_mv [ this_mode ] [ ref_frame ] . as_int ;if ( reuse_inter_pred ) {if ( ! this_mode_pred ) {this_mode_pred = & tmp [ 3 ] ;}else {this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ;pd -> dst . buf = this_mode_pred -> data ;pd -> dst . stride = bw ;}}if ( ( this_mode == NEWMV || filter_ref == SWITCHABLE ) && pred_filter_search && ( ref_frame == LAST_FRAME || ( ref_frame == GOLDEN_FRAME && cpi -> use_svc ) ) && ( ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) != 0 || ( mbmi -> mv [ 0 ] . as_mv . col & 0x07 ) != 0 ) ) {unsigned int pf_var [ 3 ] ;unsigned int pf_sse [ 3 ] ;TX_SIZE pf_tx_size [ 3 ] ;int64_t best_cost = INT64_MAX ;INTERP_FILTER best_filter = SWITCHABLE , filter ;PRED_BUFFER * current_pred = this_mode_pred ;for ( filter = EIGHTTAP ;filter <= EIGHTTAP_SMOOTH ;++ filter ) {int64_t cost ;mbmi -> interp_filter = filter ;model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ filter ] , & pf_dist [ EIGHTTAP ] ) ;tmp_rdcost1 = RDCOST ( x -> rdmult , x -> rddiv , vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP ] , pf_dist [ EIGHTTAP ] ) ;mbmi -> interp_filter = EIGHTTAP_SHARP ;model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP_SHARP ] , & pf_dist [ filter ] , & pf_var [ filter ] , & pf_sse [ filter ] ) ;pf_rate [ filter ] += vp9_get_switchable_rate ( cpi , xd ) ;cost = RDCOST ( x -> rdmult , x -> rddiv , pf_rate [ filter ] , pf_dist [ filter ] ) ;pf_tx_size [ filter ] = mbmi -> tx_size ;if ( cost < best_cost ) {best_filter = filter ;best_cost = cost ;skip_txfm = x -> skip_txfm [ 0 ] ;if ( reuse_inter_pred ) {if ( this_mode_pred != current_pred ) {free_pred_buffer ( this_mode_pred ) ;this_mode_pred = current_pred ;}if ( filter < EIGHTTAP_SHARP ) {current_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ;pd -> dst . buf = current_pred -> data ;pd -> dst . stride = bw ;}}}}if ( reuse_inter_pred && this_mode_pred != current_pred ) free_pred_buffer ( current_pred ) ;mbmi -> interp_filter = best_filter ;mbmi -> tx_size = pf_tx_size [ best_filter ] ;this_rdc . rate = pf_rate [ best_filter ] ;this_rdc . dist = pf_dist [ best_filter ] ;var_y = pf_var [ best_filter ] ;sse_y = pf_sse [ best_filter ] ;x -> skip_txfm [ 0 ] = skip_txfm ;if ( reuse_inter_pred ) {pd -> dst . buf = this_mode_pred -> data ;pd -> dst . stride = this_mode_pred -> stride ;}",5205
1558,"model_rd_for_sb_y ( cpi , bsize , x , xd , & rate , & dist ) ;}rate += rate_mv ;rate += x -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ]  [ INTER_OFFSET ( this_mode ) ] ;","if ( bsize > BLOCK_32X32 && ! cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) && cm -> base_qindex ) {model_rd_for_sb_y_large ( cpi , bsize , x , xd , & this_rdc . this_rdc . rate , & this_rdc . dist , & var_y , & sse_y ) ;}}if ( ! this_early_term ) {this_sse = ( int64_t ) sse_y ;block_yrd ( cpi , x , & this_rdc . rate , & this_rdc . dist , & is_skippable , & this_sse , 0 , bsize , MIN ( mbmi -> tx_size , TX_16X16 ) ) ;x -> skip_txfm [ 0 ] = is_skippable ;if ( is_skippable ) {this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;}else {if ( RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , this_sse ) ) {this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;}else {this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;this_rdc . dist = this_sse ;x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ;}}if ( cm -> interp_filter == SWITCHABLE ) {if ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) this_rdc . rate += vp9_get_switchable_rate ( cpi , xd ) ;}}else {this_rdc . rate += cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd ) : 0 ;this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;}if ( x -> color_sensitivity [ 0 ] || x -> color_sensitivity [ 1 ] ) {int uv_rate = 0 ;int64_t uv_dist = 0 ;if ( x -> color_sensitivity [ 0 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 1 ) ;if ( x -> color_sensitivity [ 1 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 2 ) ;model_rd_for_sb_uv ( cpi , bsize , x , xd , & uv_rate , & uv_dist , & var_y , & sse_y ) ;this_rdc . rate += uv_rate ;this_rdc . dist += uv_dist ;}this_rdc . rate += rate_mv ;this_rdc . rate += cpi -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ;",5205
1559,"best_ref_frame = ref_frame ;}}mbmi -> ref_frame [ 0 ] = best_ref_frame ;mbmi -> mv [ 0 ] . as_int = frame_mv [ best_mode ] [ best_ref_frame ] . as_int ;xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = mbmi -> mv [ 0 ] . as_int ;if ( best_rd > inter_mode_thresh ) {for ( this_mode = DC_PRED ;this_mode <= DC_PRED ;++ this_mode ) {vp9_predict_intra_block ( xd , 0 , b_width_log2 ( bsize ) ,  mbmi -> tx_size , this_mode , & p -> src . buf [ 0 ] , p -> src . stride , & pd -> dst . buf [ 0 ] , pd -> dst . stride , 0 , 0 , 0 ) ;model_rd_for_sb_y ( cpi , bsize , x , xd , & rate , & dist ) ;rate += x -> mbmode_cost [ this_mode ] ;rate += intra_cost_penalty ;this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ;if ( this_rd + intra_mode_cost < best_rd ) {best_rd = this_rd ;* returnrate = rate ;* returndistortion = dist ;return INT64_MAX ;","best_tx_size = mbmi -> tx_size ;best_ref_frame = ref_frame ;best_mode_skip_txfm = x -> skip_txfm [ 0 ] ;best_early_term = this_early_term ;if ( reuse_inter_pred ) {free_pred_buffer ( best_pred ) ;best_pred = this_mode_pred ;}}else {if ( reuse_inter_pred ) free_pred_buffer ( this_mode_pred ) ;}if ( x -> skip ) break ;if ( best_early_term && idx > 0 ) {x -> skip = 1 ;break ;}mbmi -> tx_size = best_tx_size ;+ this_mode ) {mbmi -> ref_frame [ 0 ] = best_ref_frame ;mbmi -> mv [ 0 ] . as_int = frame_mv [ best_mode ] [ best_ref_frame ] . as_int ;x -> skip_txfm [ 0 ] = best_mode_skip_txfm ;if ( best_rdc . rdcost == INT64_MAX || ( ! x -> skip && best_rdc . rdcost > inter_mode_thresh && bsize <= cpi -> sf . max_intra_bsize ) ) {struct estimate_block_intra_args args = {cpi , x , DC_PRED , 0 , 0 };const TX_SIZE intra_tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ;int i ;TX_SIZE best_intra_tx_size = TX_SIZES ;if ( reuse_inter_pred && best_pred != NULL ) {if ( best_pred -> data == orig_dst . buf ) {this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ;# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ;else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ;# else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ;# endif best_pred = this_mode_pred ;}}pd -> dst = orig_dst ;for ( i = 0 ;i < 4 ;++ i ) {const PREDICTION_MODE this_mode = intra_mode_list [ i ] ;THR_MODES mode_index = mode_idx [ INTRA_FRAME ] [ mode_offset ( this_mode ) ] ;int mode_rd_thresh = rd_threshes [ mode_index ] ;if ( ! ( ( 1 << this_mode ) & cpi -> sf . intra_y_mode_bsize_mask [ bsize ] ) ) continue ;if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) ) continue ;args . mode = this_mode ;args . rate = 0 ;args . dist = 0 ;mbmi -> tx_size = intra_tx_size ;vp9_foreach_transformed_block_in_plane ( xd , bsize , 0 , estimate_block_intra , & args ) ;this_rdc . rate = args . rate ;this_rdc . dist = args . dist ;this_rdc . rate += cpi -> mbmode_cost [ this_mode ] ;this_rdc . rate += ref_frame_cost [ INTRA_FRAME ] ;this_rdc . rate += intra_cost_penalty ;this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ;if ( this_rdc . rdcost < best_rdc . rdcost ) {best_rdc = this_rdc ;best_mode = this_mode ;best_intra_tx_size = mbmi -> tx_size ;best_ref_frame = INTRA_FRAME ;best_mode_skip_txfm = x -> skip_txfm [ 0 ] ;}}if ( best_ref_frame != INTRA_FRAME ) {mbmi -> tx_size = best_tx_size ;}else {mbmi -> tx_size = best_intra_tx_size ;}}pd -> dst = orig_dst ;mbmi -> mode = best_mode ;mbmi -> ref_frame [ 0 ] = best_ref_frame ;x -> skip_txfm [ 0 ] = best_mode_skip_txfm ;if ( reuse_inter_pred && best_pred != NULL ) {if ( best_pred -> data != orig_dst . buf && is_inter_mode ( mbmi -> mode ) ) {# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ;else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ;# else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ;# endif }}if ( cpi -> sf . adaptive_rd_thresh ) {THR_MODES best_mode_idx = mode_idx [ best_ref_frame ] [ mode_offset ( mbmi -> mode ) ] ;if ( best_ref_frame == INTRA_FRAME ) {int intra_modes = sizeof ( intra_mode_list ) / sizeof ( PREDICTION_MODE ) ;int i ;for ( i = 0 ;i < intra_modes ;i ++ ) {update_thresh_freq_fact ( cpi , tile_data , bsize , INTRA_FRAME , best_mode_idx , intra_mode_list [ i ] ) ;}}else {for ( ref_frame = LAST_FRAME ;ref_frame <= GOLDEN_FRAME ;++ ref_frame ) {PREDICTION_MODE this_mode ;if ( best_ref_frame != ref_frame ) continue ;for ( this_mode = NEARESTMV ;this_mode <= NEWMV ;++ this_mode ) {update_thresh_freq_fact ( cpi , tile_data , bsize , ref_frame , best_mode_idx , this_mode ) ;}* rd_cost = best_rdc ;",5205
1560,"int r ;if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ;for ( ;if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) {","int r , dontmax = 0 ;if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ;if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) {st . st_size = 64 * 1024 ;dontmax = 1 ;}if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;for ( ;if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) {",5206
1561,"if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) )  timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ;remaining = kc -> timer_remaining ( timr , now ) ;","if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ;remaining = kc -> timer_remaining ( timr , now ) ;",5207
1562,"while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE )  {while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX )  {","while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) {while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) {",5208
1563,return rold -> umin_value == 0 &&  rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ;,return false ;,5209
1564,"memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ;memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ;","memset ( p , 0 , sizeof ( * p ) ) ;memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ;memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ;",5210
1565,ipv6_select_ident ( fh ) ;fh -> nexthdr = nexthdr ;,"ipv6_select_ident ( fh , rt ) ;fh -> nexthdr = nexthdr ;",5211
1566,ipv6_select_ident ( fh ) ;frag_id = fh -> identification ;,"ipv6_select_ident ( fh , rt ) ;frag_id = fh -> identification ;",5211
1567,if ( strlen ( parv [ 1 ] ) > 400 )  {,"if ( ( parv [ 1 ] [ 0 ] == \':\' ) || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) {sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , ""*"" , ""AUTHENTICATE"" , ""Invalid<S2SV_blank>parameter"" ) ;return 0 ;}if ( strlen ( parv [ 1 ] ) > 400 ) {",5212
1568,"void ptrace_triggered ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","void ptrace_triggered ( struct perf_event * bp , struct perf_sample_data * data , struct pt_regs * regs ) {",5213
1569,"if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_IPC ) == 0 ) {g_debug ( ""Disallowing<S2SV_blank>ipc<S2SV_blank>access"" ) ;flatpak_bwrap_add_args ( bwrap , ""--unshare-ipc"" , NULL ) ;}if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) == 0 ) {g_debug ( ""Disallowing<S2SV_blank>network<S2SV_blank>access"" ) ;flatpak_bwrap_add_args ( bwrap , ""--unshare-net"" , NULL ) ;}if ( context -> devices & FLATPAK_CONTEXT_DEVICE_ALL ) {flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev"" , ""/dev"" , NULL ) ;if ( g_file_test ( ""/dev/shm"" , G_FILE_TEST_IS_DIR ) ) {if ( ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) == 0 ) flatpak_bwrap_add_args ( bwrap , ""--tmpfs"" , ""/dev/shm"" , NULL ) ;}else if ( g_file_test ( ""/dev/shm"" , G_FILE_TEST_IS_SYMLINK ) ) {g_autofree char * link = flatpak_readlink ( ""/dev/shm"" , NULL ) ;if ( g_strcmp0 ( link , ""/run/shm"" ) == 0 ) {if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM && g_file_test ( ""/run/shm"" , G_FILE_TEST_IS_DIR ) ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , ""/run/shm"" , ""/run/shm"" , NULL ) ;else flatpak_bwrap_add_args ( bwrap , ""--dir"" , ""/run/shm"" , NULL ) ;}else g_warning ( ""Unexpected<S2SV_blank>/dev/shm<S2SV_blank>symlink<S2SV_blank>%s"" , link ) ;}}else {flatpak_bwrap_add_args ( bwrap , ""--dev"" , ""/dev"" , NULL ) ;if ( context -> devices & FLATPAK_CONTEXT_DEVICE_DRI ) {g_debug ( ""Allowing<S2SV_blank>dri<S2SV_blank>access"" ) ;int i ;char * dri_devices [ ] = {""/dev/dri"" , ""/dev/mali"" , ""/dev/mali0"" , ""/dev/umplock"" , ""/dev/nvidiactl"" , ""/dev/nvidia-modeset"" , ""/dev/nvidia-uvm"" , ""/dev/nvidia-uvm-tools"" , };for ( i = 0 ;i < G_N_ELEMENTS ( dri_devices ) ;i ++ ) {if ( g_file_test ( dri_devices [ i ] , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , dri_devices [ i ] , dri_devices [ i ] , NULL ) ;}char nvidia_dev [ 14 ] ;for ( i = 0 ;i < 20 ;i ++ ) {g_snprintf ( nvidia_dev , sizeof ( nvidia_dev ) , ""/dev/nvidia%d"" , i ) ;if ( g_file_test ( nvidia_dev , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , nvidia_dev , nvidia_dev , NULL ) ;}}if ( context -> devices & FLATPAK_CONTEXT_DEVICE_KVM ) {g_debug ( ""Allowing<S2SV_blank>kvm<S2SV_blank>access"" ) ;if ( g_file_test ( ""/dev/kvm"" , G_FILE_TEST_EXISTS ) ) flatpak_bwrap_add_args ( bwrap , ""--dev-bind"" , ""/dev/kvm"" , ""/dev/kvm"" , NULL ) ;}if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) {g_autofree char * real_dev_shm = realpath ( ""/dev/shm"" , NULL ) ;g_debug ( ""Allowing<S2SV_blank>/dev/shm<S2SV_blank>access<S2SV_blank>(as<S2SV_blank>%s)"" , real_dev_shm ) ;if ( real_dev_shm != NULL ) flatpak_bwrap_add_args ( bwrap , ""--bind"" , real_dev_shm , ""/dev/shm"" , NULL ) ;}}flatpak_context_append_bwrap_filesystem ( context , bwrap , app_id , app_id_dir , previous_app_id_dirs , & exports ) ;if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND ) {g_debug ( ""Allowing<S2SV_blank>wayland<S2SV_blank>access"" ) ;has_wayland = flatpak_run_add_wayland_args ( bwrap ) ;}if ( ( context -> sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11 ) != 0 ) allow_x11 = ! has_wayland ;else allow_x11 = ( context -> sockets & FLATPAK_CONTEXT_SOCKET_X11 ) != 0 ;flatpak_run_add_x11_args ( bwrap , allow_x11 ) ;if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH ) {flatpak_run_add_ssh_args ( bwrap ) ;}if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO ) {g_debug ( ""Allowing<S2SV_blank>pulseaudio<S2SV_blank>access"" ) ;flatpak_run_add_pulseaudio_args ( bwrap ) ;}if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_PCSC ) {flatpak_run_add_pcsc_args ( bwrap ) ;}if ( context -> sockets & FLATPAK_CONTEXT_SOCKET_CUPS ) {flatpak_run_add_cups_args ( bwrap ) ;}flatpak_run_add_session_dbus_args ( bwrap , proxy_arg_bwrap , context , flags , app_id ) ;flatpak_run_add_system_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ;flatpak_run_add_a11y_dbus_args ( bwrap , proxy_arg_bwrap , context , flags ) ;if ( g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) != NULL )  {flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""LD_LIBRARY_PATH"" , g_environ_getenv ( bwrap -> envp , ""LD_LIBRARY_PATH"" ) , NULL ) ;flatpak_bwrap_unset_env ( bwrap , ""LD_LIBRARY_PATH"" ) ;}if ( g_environ_getenv ( bwrap -> envp , ""TMPDIR"" ) != NULL ) {flatpak_bwrap_add_args ( bwrap , ""--setenv"" , ""TMPDIR"" , g_environ_getenv ( bwrap -> envp , ""TMPDIR"" ) , NULL ) ;flatpak_bwrap_unset_env ( bwrap , ""TMPDIR"" ) ;}","
",5214
1570,return ;},return 0 ;},5215
1571,"code = validate_as_request ( kdc_active_realm , request , * princ ,  no_server , kdc_time , status , & e_data ) ;","princ -> pw_expiration = 0 ;clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;code = validate_as_request ( kdc_active_realm , request , * princ , no_server , kdc_time , status , & e_data ) ;",5216
1572,"static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vp9_reader * r ) {FRAME_CONTEXT * const fc = & cm -> fc ;int i ;","static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vpx_reader * r ) {FRAME_CONTEXT * const fc = cm -> fc ;int i ;",5217
1573,"struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ;struct sock * sk = sock -> sk ;int chan = sa -> rc_channel ;int err = 0 ;BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa -> rc_bdaddr ) ;lock_sock ( sk ) ;if ( sk -> sk_state != BT_OPEN ) {err = - EBADFD ;goto done ;}if ( sk -> sk_type != SOCK_STREAM ) {err = - EINVAL ;goto done ;}write_lock ( & rfcomm_sk_list . lock ) ;if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) {err = - EADDRINUSE ;bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ;rfcomm_pi ( sk ) -> channel = chan ;sk -> sk_state = BT_BOUND ;","struct sockaddr_rc sa ;struct sock * sk = sock -> sk ;int chan = sa -> rc_channel ;int err = 0 ;memset ( & sa , 0 , sizeof ( sa ) ) ;len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ;memcpy ( & sa , addr , len ) ;BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa . rc_bdaddr ) ;lock_sock ( sk ) ;if ( sa . rc_channel && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) {err = - EADDRINUSE ;bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ;rfcomm_pi ( sk ) -> channel = chan ;sk -> sk_state = BT_BOUND ;",5218
1574,switch ( quantum_info -> depth )  {,pixel = 0 ;switch ( quantum_info -> depth ) {,5219
1575,"if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) &&  ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) )  goto invalid_key ;",if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED ) goto invalid_key ;,5220
1576,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,5221
1577,"if ( update_fragments ( ctx , data , data_sz , & res ) <= 0 )  return res ;","if ( ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) {return 0 ;}if ( update_fragments ( ctx , data , data_sz , & res ) <= 0 ) return res ;",5222
1578,"if ( ! res && ctx -> defer_alloc )  {int i ;for ( i = 1 ;! res && i < NELEMENTS ( ctx -> mmaps ) ;i ++ ) {vpx_codec_dec_cfg_t cfg ;cfg . w = ctx -> si . w ;cfg . h = ctx -> si . h ;ctx -> mmaps [ i ] . id = vp8_mem_req_segs [ i ] . id ;ctx -> mmaps [ i ] . sz = vp8_mem_req_segs [ i ] . sz ;ctx -> mmaps [ i ] . align = vp8_mem_req_segs [ i ] . align ;ctx -> mmaps [ i ] . flags = vp8_mem_req_segs [ i ] . flags ;if ( ! ctx -> mmaps [ i ] . sz ) ctx -> mmaps [ i ] . sz = vp8_mem_req_segs [ i ] . calc_sz ( & cfg , ctx -> base . init_flags ) ;res = vpx_mmap_alloc ( & ctx -> mmaps [ i ] ) ;}if ( ! res ) vp8_finalize_mmaps ( ctx ) ;ctx -> defer_alloc = 0 ;}if ( ! res && ! ctx -> decoder_init )  {",if ( ! res && ! ctx -> decoder_init ) {,5222
1579,ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_cb = ctx -> decrypt_cb ;ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_state = ctx -> decrypt_state ;}ctx -> decoder_init = 1 ;,ctx -> decoder_init = 1 ;}if ( ctx -> decoder_init ) {ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_cb = ctx -> decrypt_cb ;ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_state = ctx -> decrypt_state ;,5222
1580,return - 1 ;},vp8_clear_system_state ( ) ;return - 1 ;},5222
1581,"client -> auth_user = client -> db -> auth_user ;client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ;","client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ;",5223
1582,"bestsad = fn_ptr -> sdf ( what , what_stride , best_address ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , best_address , in_what_stride ) + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ;",5224
1583,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ;if ( thissad < bestsad ) {",5224
1584,"revisionId = enc28j60ReadReg ( interface , ENC28J60_REG_EREVID ) ;TRACE_INFO ( ""ENC28J60<S2SV_blank>revision<S2SV_blank>ID:<S2SV_blank>0x%02X\\\\r\\\enc28j60WriteReg ( interface , ENC28J60_REG_ECOCON , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAADR1 , interface -> macAddr . b [ 0 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAADR2 , interface -> macAddr . b [ 1 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAADR3 , interface -> macAddr . b [ 2 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAADR4 , interface -> macAddr . b [ 3 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAADR5 , interface -> macAddr . b [ 4 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAADR6 , interface -> macAddr . b [ 5 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTL , LSB ( ENC28J60_RX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTH , MSB ( ENC28J60_RX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ERXFCON , ERXFCON_UCEN |  ERXFCON_CRCEN | ERXFCON_HTEN | ERXFCON_BCEN ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MACON2 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MACON1 , MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN ) ;# if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED )  enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) |  MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX ) ;# else  enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) |  MACON3_TXCRCEN | MACON3_FRMLNEN ) ;# endif  enc28j60WriteReg ( interface , ENC28J60_REG_MACON4 , MACON4_DEFER ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAMXFLL , LSB ( ETH_MAX_FRAME_SIZE ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAMXFLH , MSB ( ETH_MAX_FRAME_SIZE ) ) ;# if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED )  enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x15 ) ;# else  enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x12 ) ;# endif  enc28j60WriteReg ( interface , ENC28J60_REG_MAIPGL , 0x12 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MAIPGH , 0x0C ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MACLCON2 , 63 ) ;# if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED )  enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , PHCON1_PDPXMD ) ;# else  enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , 0x0000 ) ;# endif  enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON2 , PHCON2_HDLDIS ) ;enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHLCON ,  PHLCON_LACFG ( 4 ) | PHLCON_LBCFG ( 7 ) | PHLCON_LFRQ ( 0 ) | PHLCON_STRCH ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EIR , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EIE , EIE_INTIE | EIE_PKTIE | EIE_LINKIE | EIE_TXIE | EIE_TXERIE ) ;enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHIE ,  PHIE_PLNKIE | PHIE_PGEIE ) ;enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_RXEN ) ;enc28j60DumpReg ( interface ) ;","revisionId = enc28j60ReadReg ( interface , ENC28J60_EREVID ) ;TRACE_INFO ( ""ENC28J60<S2SV_blank>revision<S2SV_blank>ID:<S2SV_blank>0x%02X\\\\r\\\enc28j60WriteReg ( interface , ENC28J60_ECOCON , ENC28J60_ECOCON_COCON_DISABLED ) ;enc28j60WriteReg ( interface , ENC28J60_MAADR5 , interface -> macAddr . b [ 0 ] ) ;enc28j60WriteReg ( interface , ENC28J60_MAADR4 , interface -> macAddr . b [ 1 ] ) ;enc28j60WriteReg ( interface , ENC28J60_MAADR3 , interface -> macAddr . b [ 2 ] ) ;enc28j60WriteReg ( interface , ENC28J60_MAADR2 , interface -> macAddr . b [ 3 ] ) ;enc28j60WriteReg ( interface , ENC28J60_MAADR1 , interface -> macAddr . b [ 4 ] ) ;enc28j60WriteReg ( interface , ENC28J60_MAADR0 , interface -> macAddr . b [ 5 ] ) ;enc28j60WriteReg ( interface , ENC28J60_ERXSTL , LSB ( ENC28J60_RX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERXSTH , MSB ( ENC28J60_RX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERXNDL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERXNDH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ;enc28j60WriteReg ( interface , ENC28J60_ERXFCON , ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN ) ;enc28j60WriteReg ( interface , ENC28J60_EHT0 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_EHT1 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_EHT2 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_EHT3 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_EHT4 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_EHT5 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_EHT6 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_EHT7 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_MACON2 , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_MACON1 , ENC28J60_MACON1_TXPAUS | ENC28J60_MACON1_RXPAUS | ENC28J60_MACON1_MARXEN ) ;# if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED ) enc28j60WriteReg ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN | ENC28J60_MACON3_FULDPX ) ;# else enc28j60WriteReg ( interface , ENC28J60_REG_MACON3 , MACON3_PADCFG ( 1 ) | MACON3_TXCRCEN | MACON3_FRMLNEN ) ;# endif enc28j60WriteReg ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN ) ;# if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED ) enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x15 ) ;# else enc28j60WriteReg ( interface , ENC28J60_REG_MABBIPG , 0x12 ) ;# endif enc28j60WriteReg ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_FD ) ;# if ( ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED ) enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHCON1 , PHCON1_PDPXMD ) ;# else enc28j60WritePhyReg ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_HD ) ;# endif enc28j60WritePhyReg ( interface , ENC28J60_PHCON2 , ENC28J60_PHCON2_HDLDIS ) ;enc28j60WritePhyReg ( interface , ENC28J60_PHLCON , ENC28J60_PHLCON_LACFG_LINK | ENC28J60_PHLCON_LBCFG_TX_RX | ENC28J60_PHLCON_LFRQ_40_MS | ENC28J60_PHLCON_STRCH ) ;enc28j60WriteReg ( interface , ENC28J60_EIR , 0x00 ) ;enc28j60WriteReg ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE | ENC28J60_EIE_PKTIE | ENC28J60_EIE_LINKIE | ENC28J60_EIE_TXIE | ENC28J60_EIE_TXERIE ) ;enc28j60WritePhyReg ( interface , ENC28J60_PHY_REG_PHIE , PHIE_PLNKIE | PHIE_PGEIE ) ;enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_RXEN ) ;enc28j60DumpReg ( interface ) ;",5225
1585,"
",ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ;,5226
1586,if ( sum != 0 ) {uint16_t icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ;,if ( sum != 0 ) {uint16_t icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ;,5226
1587,if ( * ( unsigned char * ) data > 1 )  return - ENOTSUPP ;,if ( datalen != 1 ) return - EINVAL ;if ( * ( unsigned char * ) data > 1 ) return - ENOTSUPP ;,5227
1588,if ( ! npages && ! old . npages ) goto out_free ;,"if ( npages ) {r = kvm_iommu_map_pages ( kvm , & new ) ;if ( r ) goto out_slots ;}",5228
1589,"kvm_arch_flush_shadow_memslot ( kvm , slot ) ;kfree ( old_memslots ) ;if ( r )  goto out_free ;if ( npages ) {","kvm_iommu_unmap_pages ( kvm , & old ) ;kvm_arch_flush_shadow_memslot ( kvm , slot ) ;kfree ( old_memslots ) ;if ( r ) goto out_free ;if ( npages ) {",5228
1590,if ( ! npages ) {new . dirty_bitmap = NULL ;,if ( ! npages ) {new . dirty_bitmap = NULL ;,5228
1591,"out_free :  kvm_free_physmem_slot ( & new , & old ) ;","out_slots : kfree ( slots ) ;out_free : kvm_free_physmem_slot ( & new , & old ) ;",5228
1592,if ( ! asoc -> temp ) {list_del ( & asoc -> asocs ) ;,if ( ! list_empty ( & asoc -> asocs ) ) {list_del ( & asoc -> asocs ) ;,5229
1593,"ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;","ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;",5230
1594,tlv = cp + i ;type = ( uint8_t ) tlv [ 0 ] ;,if ( i + 2 > length ) return - 1 ;tlv = cp + i ;type = ( uint8_t ) tlv [ 0 ] ;,5231
1595,"ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ;switch ( type ) {","ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ;if ( i + 2 + optlen > length ) return - 1 ;switch ( type ) {",5231
1596,"avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\\return AVERROR_PATCHWELCOME ;}s -> avctx -> profile = profile ;s -> avctx -> level = level ;}else if ( startcode == VISUAL_OBJ_STARTCODE ) {if ( s -> studio_profile ) {if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ;}else mpeg4_decode_visual_object ( s , gb ) ;}else if ( startcode == VOP_STARTCODE ) {break ;}align_get_bits ( gb ) ;startcode = 0xff ;}end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ;s -> avctx -> has_b_frames = ! s -> low_delay ;if ( s -> studio_profile ) {av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;if ( ! s -> avctx -> bits_per_raw_sample ) {",if ( ! s -> avctx -> bits_per_raw_sample ) {,5232
1597,"struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ;","struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ;",5233
1598,value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) |   ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) |   ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;,value = ( unsigned int ) buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ;value |= ( unsigned int ) buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;quantum . unsigned_value = value & 0xffffffff ) ;return ( quantum . signed_value ) ;,5234
1599,"static void  fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( bps * stride ) ) == 0 ) ;if ( ! tmp )  return ;while ( count > stride ) {","static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( cc % ( bps * stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ;return 0 ;}if ( ! tmp ) return 0 ;while ( count > stride ) {",5235
1600,},return 1 ;},5235
1601,"_Py_IDENTIFIER ( _fields ) ;Py_ssize_t i , numfields = 0 ;fields = _PyObject_GetAttrId ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields ) ;if ( ! fields ) PyErr_Clear ( ) ;if ( numfields == - 1 ) goto cleanup ;if ( PyTuple_GET_SIZE ( args ) > 0 ) {if ( numfields != PyTuple_GET_SIZE ( args ) ) {PyErr_Format ( PyExc_TypeError , ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>%s""  ""%zd<S2SV_blank>positional<S2SV_blank>argument%s"" ,  Py_TYPE ( self ) -> tp_name ,  numfields == 0 ? """" : ""either<S2SV_blank>0<S2SV_blank>or<S2SV_blank>"" , numfields , numfields == 1 ? """" : ""s"" ) ;for ( i = 0 ;i < PyTuple_GET_SIZE ( args ) ;i ++ ) {PyObject * name = PySequence_GetItem ( fields , i ) ;if ( ! name ) {res = - 1 ;goto cleanup ;}res = PyObject_SetAttr ( self , name , PyTuple_GET_ITEM ( args , i ) ) ;Py_DECREF ( name ) ;if ( res < 0 ) goto cleanup ;}}if ( kw ) {","Py_ssize_t i , numfields = 0 ;if ( lookup_attr_id ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields , & fields ) < 0 ) {goto cleanup ;}if ( numfields < numfields == - 1 ) goto cleanup ;if ( PyTuple_GET_SIZE ( args ) ) {PyErr_Format ( PyExc_TypeError , ""%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>%s"" ""%zd<S2SV_blank>positional<S2SV_blank>argument%s"" , Py_TYPE ( self ) -> tp_name , numfields == 0 ? """" : ""either<S2SV_blank>0<S2SV_blank>or<S2SV_blank>"" , numfields , numfields == 1 ? """" : ""s"" ) ;if ( kw ) {",5236
1602,"static void encode_frame ( vpx_codec_ctx_t * codec ,  vpx_image_t * img , int frame_index ,  VpxVideoWriter * writer ) {vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {","static int encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img , int frame_index , VpxVideoWriter * writer ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {",5237
1603,},return got_pkts ;},5237
1604,value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) |   ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) |   ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;,value = ( unsigned int ) buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ;value |= ( unsigned int ) buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;quantum . unsigned_value = value & 0xffffffff ) ;return ( quantum . signed_value ) ;,5238
1605,rp [ 0 ] = 1 ;res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ;res -> sign = 0 ;,"res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ;if ( res -> nlimbs ) {if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ;rp = res -> d ;rp [ 0 ] = 1 ;}res -> sign = 0 ;",5239
1606,free ( name ) ;return 0 ;,"if ( ! strcmp ( key , ""path"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , ""disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s"" , value ) ;free ( name ) ;return 0 ;",5240
1607,"pNew = sqlite3DbRealloc ( db , pList ,  sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ;if ( pNew == 0 ) {","pNew = sqlite3DbRealloc ( db , pList , sizeof ( * pList ) + ( 2 * ( sqlite3_int64 ) pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ;if ( pNew == 0 ) {",5241
1608,"vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",5242
1609,"mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ;mutex_unlock ( & mut ) ;","mc -> id = idr_alloc ( & multicast_idr , NULL , 0 , 0 , GFP_KERNEL ) ;mutex_unlock ( & mut ) ;",5243
1610,"void vp9_cond_prob_diff_update ( vp9_writer * w , vp9_prob * oldp ,  const unsigned int ct [ 2 ] ) {const vp9_prob upd = DIFF_UPDATE_PROB ;vp9_prob newp = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) ;const int savings = vp9_prob_diff_update_savings_search ( ct , * oldp , & newp , upd ) ;vp9_write ( w , 1 , upd ) ;vp9_write_prob_diff_update ( w , newp , * oldp ) ;vp9_write ( w , 0 , upd ) ;}","void vp9_cond_prob_diff_update ( vpx_writer * w , vp9_prob * oldp , const unsigned int ct [ 2 ] ) {const vpx_prob upd = DIFF_UPDATE_PROB ;vp9_prob newp = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) ;const int savings = vp9_prob_diff_update_savings_search ( ct , * oldp , & newp , upd ) ;vpx_write ( w , 1 , upd ) ;vp9_write_prob_diff_update ( w , newp , * oldp ) ;vpx_write ( w , 0 , upd ) ;}",5244
1611,"static u32 ip6_proxy_idents_hashrnd __read_mostly ;struct in6_addr buf [ 2 ] ;net_get_random_once ( & ip6_proxy_idents_hashrnd ,  sizeof ( ip6_proxy_idents_hashrnd ) ) ;id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd ,  & addrs [ 1 ] , & addrs [ 0 ] ) ;","struct in6_addr buf [ 2 ] ;id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , & addrs [ 1 ] , & addrs [ 0 ] ) ;",5245
1612,"static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb )  {s -> avctx -> profile = get_bits ( gb , 4 ) ;s -> avctx -> level = get_bits ( gb , 4 ) ;if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) {s -> avctx -> level = 0 ;}","static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb , int * profile , int * level ) {* profile = get_bits ( gb , 4 ) ;* level = get_bits ( gb , 4 ) ;if ( * profile == 0 && s -> avctx -> level == 8 ) {* level = 0 ;}",5246
1613,# undef _  default : switch ( variable & 0xff ) {,_ ( NPPVpluginUrlRequestsDisplayedBool ) ;_ ( NPPVpluginWantsAllNetworkStreams ) ;_ ( NPPVpluginNativeAccessibleAtkPlugId ) ;_ ( NPPVpluginCancelSrcStream ) ;_ ( NPPVSupportsAdvancedKeyHandling ) ;# undef _ default : switch ( variable & 0xff ) {,5247
1614,else if ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame )  return LAST_FRAME ;else  return GOLDEN_FRAME ;},else if ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) return GOLDEN_FRAME ;else return LAST_FRAME ;},5248
1615,"zend_throw_error ( exception_ce , message ) ;}","zend_throw_error ( exception_ce , ""%s"" , message ) ;}",5249
1616,"if ( skb_is_err_queue ( skb ) && skb -> len &&  ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) )  put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ;","if ( skb_is_err_queue ( skb ) && skb -> len && SKB_EXT_ERR ( skb ) -> opt_stats ) put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ;",5250
1617,"# line 496 ""ext/standard/var_unserializer.c""  {","# line 501 ""ext/standard/var_unserializer.c"" {",5251
1618,"yy3 :  # line 861 ""ext/standard/var_unserializer.re""  {# line 558 ""ext/standard/var_unserializer.c""  yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;","yy3 : # line 875 ""ext/standard/var_unserializer.re"" {# line 563 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;",5251
1619,"# line 855 ""ext/standard/var_unserializer.re""  {# line 607 ""ext/standard/var_unserializer.c""  yy16 : yych = * ++ YYCURSOR ;","# line 869 ""ext/standard/var_unserializer.re"" {# line 612 ""ext/standard/var_unserializer.c"" yy16 : yych = * ++ YYCURSOR ;",5251
1620,"# line 708 ""ext/standard/var_unserializer.re""  {","# line 717 ""ext/standard/var_unserializer.re"" {",5251
1621,"
",if ( elements < 0 ) {efree ( class_name ) ;return 0 ;},5251
1622,"if ( incomplete_class ) {php_store_class_name ( * rval , class_name , len2 ) ;# line 785 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;","if ( incomplete_class ) {php_store_class_name ( * rval , class_name , len2 ) ;# line 795 ""ext/standard/var_unserializer.c"" yy25 : yych = * ++ YYCURSOR ;",5251
1623,"# line 699 ""ext/standard/var_unserializer.re""  {return object_common2 ( UNSERIALIZE_PASSTHRU ,   object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ;}# line 819 ""ext/standard/var_unserializer.c""  yy32 : yych = * ++ YYCURSOR ;","# line 704 ""ext/standard/var_unserializer.re"" {long elements ;elements = object_common1 ( UNSERIALIZE_PASSTHRU , elements ) ;}# line 819 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;",5251
1624,"# line 678 ""ext/standard/var_unserializer.re""  {","# line 683 ""ext/standard/var_unserializer.re"" {",5251
1625,"# line 861 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;","# line 875 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;",5251
1626,"# line 643 ""ext/standard/var_unserializer.re""  {","# line 648 ""ext/standard/var_unserializer.re"" {",5251
1627,"# line 917 ""ext/standard/var_unserializer.c""  yy46 : yych = * ++ YYCURSOR ;","# line 931 ""ext/standard/var_unserializer.c"" yy46 : yych = * ++ YYCURSOR ;",5251
1628,"# line 610 ""ext/standard/var_unserializer.re""  {","# line 615 ""ext/standard/var_unserializer.re"" {",5251
1629,"# line 971 ""ext/standard/var_unserializer.c""  yy53 : yych = * ++ YYCURSOR ;","# line 985 ""ext/standard/var_unserializer.c"" yy53 : yych = * ++ YYCURSOR ;",5251
1630,"# line 600 ""ext/standard/var_unserializer.re""  {# line 1069 ""ext/standard/var_unserializer.c""  yy65 : yych = * ++ YYCURSOR ;","# line 605 ""ext/standard/var_unserializer.re"" {# line 1083 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;",5251
1631,"# line 585 ""ext/standard/var_unserializer.re""  {","# line 590 ""ext/standard/var_unserializer.re"" {",5251
1632,"# line 1143 ""ext/standard/var_unserializer.c""  yy76 : yych = * ++ YYCURSOR ;","# line 1157 ""ext/standard/var_unserializer.c"" yy76 : yych = * ++ YYCURSOR ;",5251
1633,"# line 558 ""ext/standard/var_unserializer.re""  {","# line 563 ""ext/standard/var_unserializer.re"" {",5251
1634,"# line 1197 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;# line 551 ""ext/standard/var_unserializer.re""  {# line 1212 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 544 ""ext/standard/var_unserializer.re""  {# line 1222 ""ext/standard/var_unserializer.c""  yy89 : yych = * ++ YYCURSOR ;","# line 1211 ""ext/standard/var_unserializer.c"" yy83 : yych = * ++ YYCURSOR ;# line 556 ""ext/standard/var_unserializer.re"" {# line 1226 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 549 ""ext/standard/var_unserializer.re"" {# line 1236 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;",5251
1635,"# line 521 ""ext/standard/var_unserializer.re""  {","# line 526 ""ext/standard/var_unserializer.re"" {",5251
1636,"# line 1268 ""ext/standard/var_unserializer.c""  yy95 : yych = * ++ YYCURSOR ;","# line 1282 ""ext/standard/var_unserializer.c"" yy95 : yych = * ++ YYCURSOR ;",5251
1637,"# line 500 ""ext/standard/var_unserializer.re""  {","# line 505 ""ext/standard/var_unserializer.re"" {",5251
1638,"# line 1312 ""ext/standard/var_unserializer.c""  }# line 863 ""ext/standard/var_unserializer.re""  return 0 ;","# line 1326 ""ext/standard/var_unserializer.c"" }# line 863 ""ext/standard/var_unserializer.re"" return 0 ;",5251
1639,"char buf [ 32 ] ;js_Object * self = js_toobject ( J , 0 ) ;","char buf [ 100 ] ;js_Object * self = js_toobject ( J , 0 ) ;",5252
1640,char buf [ 100 ] ;double number = self -> u . number ;,double number = self -> u . number ;,5252
1641,"REMOVE_BITS ( 16 ) ;}if ( ! lzx -> header_read ) {j = 0 ;READ_BITS ( i , 1 ) ;if ( i ) {READ_BITS ( i , 16 ) ;READ_BITS ( j , 16 ) ;}lzx -> intel_filesize = ( i << 16 ) | j ;lzx -> header_read = 1 ;}frame_size = LZX_FRAME_SIZE ;if ( lzx -> length && ( lzx -> length - lzx -> offset ) < ( off_t ) frame_size ) {frame_size = lzx -> length - lzx -> offset ;}bytes_todo = lzx -> frame_posn + frame_size - window_posn ;while ( bytes_todo > 0 ) {if ( lzx -> block_remaining == 0 ) {if ( ( lzx -> block_type == LZX_BLOCKTYPE_UNCOMPRESSED ) && ( lzx -> block_length & 1 ) ) {READ_IF_NEEDED ;i_ptr ++ ;}READ_BITS ( lzx -> block_type , 3 ) ;READ_BITS ( i , 16 ) ;READ_BITS ( j , 8 ) ;lzx -> block_remaining = lzx -> block_length = ( i << 8 ) | j ;switch ( lzx -> block_type ) {case LZX_BLOCKTYPE_ALIGNED : for ( i = 0 ;i < 8 ;i ++ ) {READ_BITS ( j , 3 ) ;lzx -> ALIGNED_len [ i ] = j ;}BUILD_TABLE ( ALIGNED ) ;case LZX_BLOCKTYPE_VERBATIM : READ_LENGTHS ( MAINTREE , 0 , 256 ) ;READ_LENGTHS ( MAINTREE , 256 , LZX_NUM_CHARS + lzx -> num_offsets ) ;BUILD_TABLE ( MAINTREE ) ;if ( lzx -> MAINTREE_len [ 0xE8 ] != 0 ) lzx -> intel_started = 1 ;READ_LENGTHS ( LENGTH , 0 , LZX_NUM_SECONDARY_LENGTHS ) ;BUILD_TABLE_MAYBE_EMPTY ( LENGTH ) ;break ;case LZX_BLOCKTYPE_UNCOMPRESSED : lzx -> intel_started = 1 ;ENSURE_BITS ( 16 ) ;if ( bits_left > 16 ) i_ptr -= 2 ;","
",5253
1642,"if ( iscntrl ( c ) ) m |= HTTP_CHARSET_CTL ;if ( isprint ( c ) && c <= 126 ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_VCHAR ;if ( c == \'<S2SV_blank>\' || c == \'\\\\t\' ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_LWS ;if ( isalpha ( c ) ) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_ALPHA ;if ( osIsdigit ( c ) ) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_DIGIT ;if ( isxdigit ( c ) ) m |= HTTP_CHARSET_HEX ;if ( c >= 128 ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_OBS_TEXT ;if ( strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) )  m |= HTTP_CHARSET_TCHAR ;","if ( osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) ) m |= HTTP_CHARSET_TCHAR ;",5254
1643,bh -> b_size = map . m_len << inode -> i_blkbits ;},bh -> b_size = ( u64 ) map . m_len << inode -> i_blkbits ;},5255
1644,"gint64 offset ;int pkt_len ;pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len ,   wth -> frame_buffer , err , err_info ) ;}","gint64 offset ;return parse_cosine_packet ( wth -> fh , & wth -> phdr , pkt_len , wth -> frame_buffer , line , err , err_info ) ;}",5256
1645,"char buf [ DN_BUF_LEN ] ;unsigned int bufsize = sizeof ( buf ) ;X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;md -> subject_dn = strdup ( buf ) ;if ( md -> subject_dn == NULL ) {ret = ENOMEM ;goto cleanup ;}X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;md -> issuer_dn = strdup ( buf ) ;if ( md -> issuer_dn == NULL ) {ret = ENOMEM ;goto cleanup ;}","X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , & md -> subject_dn = strdup ( buf ) ;if ( md -> subject_dn ) ;if ( ret ) goto cleanup ;ret = rfc2253_name ( X509_get_issuer_name ( cert ) , buf , & bufsize , XN_FLAG_SEP_COMMA_PLUS ) ;md -> issuer_dn ) ;if ( ret ) goto cleanup ;",5257
1646,"align_get_bits ( gb ) ;if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) {","align_get_bits ( gb ) ;if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ;if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) {",5258
1647,"int ret ;if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;usbnet_link_change ( dev , 0 , 0 ) ;return ret ;","if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;return cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;",5259
1648,"Total += vp8_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ;}","Total += vpx_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ;}",5260
1649,if ( event -> type == et_close ) {}if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) {,"if ( event -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) {sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ;}else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) {sd -> fv -> script_unsaved = false ;}else if ( event -> type == et_close ) {}if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) {",5261
1650,"buflen = MIN ( buflen , buf_size ) ;bytes_consumed = buflen + u4_length_of_start_code ;","buflen = MIN ( buflen , buf_size - 8 ) ;bytes_consumed = buflen + u4_length_of_start_code ;",5262
1651,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",5263
1652,stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ;stripinplane = ( strip % stripsperplane ) ;,stripsperplane = TIFFhowmany_32_maxuint_compat ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ;stripinplane = ( strip % stripsperplane ) ;,5264
1653,"int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;","int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;",5265
1654,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,5265
1655,"int x , y , i ;old_width = s_map -> layers [ layer ] . width ;if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) )  return false ;","size_t tilemap_size ;int x , y , i ;old_width = s_map -> layers [ layer ] . width ;tilemap_size = x_size * y_size * sizeof ( struct map_tile ) ;if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size ) ) ) return false ;",5266
1656,u_int16_t port ;unsigned int ret ;exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ;,struct nf_conn * ct = exp -> master ;union nf_inet_addr newaddr ;u_int16_t port ;unsigned int ret ;newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 ;exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ;,5267
1657,"nf_ct_helper_log ( skb , exp -> master , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ;return NF_DROP ;ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo ,  protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ;nf_ct_helper_log ( skb , exp -> master , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ;nf_ct_unexpect_related ( exp ) ;","nf_ct_helper_log ( skb , ct , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ;return NF_DROP ;snprintf ( buffer , sizeof ( buffer ) , ""%u<S2SV_blank>%u"" , ntohl ( newaddr . ip ) , port ) ;pr_debug ( ""nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\\\'%s\\\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\\ret = nf_nat_mangle_tcp_packet ( skb , ct , ctinfo , protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ;nf_ct_helper_log ( skb , ct , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ;nf_ct_unexpect_related ( exp ) ;",5267
1658,"args -> count = ntohl ( * p ++ ) ;len = min ( args -> count , max_blocksize ) ;","args -> count = ntohl ( * p ++ ) ;if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;len = min ( args -> count , max_blocksize ) ;",5268
1659,"return xdr_argsize_check ( rqstp , p ) ;}",return 1 ;},5268
1660,"static void perf_swevent_overflow ( struct perf_event * event , u64 overflow ,  int nmi , struct perf_sample_data * data ,  struct pt_regs * regs ) {","static void perf_swevent_overflow ( struct perf_event * event , u64 overflow , struct perf_sample_data * data , struct pt_regs * regs ) {",5269
1661,"if ( __perf_event_overflow ( event , nmi , throttle ,  data , regs ) ) {","if ( __perf_event_overflow ( event , throttle , data , regs ) ) {",5269
1662,"static INLINE void write_buffer_4x4 ( int16_t * output , __m128i * res ) {const __m128i kOne = _mm_set1_epi16 ( 1 ) ;out23 = _mm_srai_epi16 ( out23 , 2 ) ;_mm_store_si128 ( ( __m128i * ) ( output + 0 * 8 ) , out01 ) ;_mm_store_si128 ( ( __m128i * ) ( output + 1 * 8 ) , out23 ) ;}","static INLINE void write_buffer_4x4 ( tran_low_t * output , __m128i * res ) {const __m128i kOne = _mm_set1_epi16 ( 1 ) ;store_output ( & out01 , ( output + 0 * 8 ) , out01 ) ;_mm_store_si128 ( ( __m128i * ) ( output + 1 * 8 ) ) ;}",5270
1663,if ( image -> numcomps < 4 ) return ;max = w * h ;,"if ( ( image -> numcomps < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) {fprintf ( stderr , ""%s:%d:color_cmyk_to_rgb\\\return ;}max = w * h ;",5271
1664,trust_data . dwUIChoice = WTD_UI_ALL ;trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ;return r ;},"trust_data . dwUIChoice = WTD_UI_NONE ;trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ;switch ( r ) {case ERROR_SUCCESS : break ;case TRUST_E_NOSIGNATURE : uprintf ( ""PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ;MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ;break ;default : uprintf ( ""PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ;MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ;break ;}return r ;}",5272
1665,"for ( col = 0 ;col < imagewidth ;if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) {","for ( col = 0 ;col < imagewidth && colb < imagew ;if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) {",5273
1666,"case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  return 1 ;case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ;","case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : return 1 ;case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ;",5274
1667,sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ;if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ;,sc -> drefs_count = 0 ;sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ;if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ;,5275
1668,}ZVAL_NULL ( * rval ) ;,zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;}ZVAL_NULL ( * rval ) ;,5276
1669,"
","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}",5277
1670,"( void ) ReadBlobString ( image , text ) ;if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) {","( void ) ReadBlobString ( image , text ) ;if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) {",5277
1671,struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;unsigned long tmp ;write_lock ( & cluster -> cl_nodes_lock ) ;if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ;,struct o2nm_cluster * cluster ;unsigned long tmp ;o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {o2nm_unlock_subsystem ( ) ;return - EINVAL ;}write_lock ( & cluster -> cl_nodes_lock ) ;o2nm_unlock_subsystem ( ) ;if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ;,5278
1672,if ( ret )  return ret ;,if ( ret ) return ret ;,5278
1673,cm -> fc . nmvc = default_nmv_context ;},cm -> fc -> nmvc = default_nmv_context ;},5279
1674,if ( ! * passwd || ! * user -> passwd )  return false ;,"if ( ! user ) {slog_error ( client , ""Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?"" ) ;return false ;}if ( ! * passwd || ! * user -> passwd ) return false ;",5280
1675,"if ( unlikely ( ! hex2bin ( pool -> header_bin , header , 128 ) ) )  quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ;cb1 = ( unsigned char * ) calloc ( cb1_len , 1 ) ;","if ( unlikely ( ! hex2bin ( pool -> header_bin , header , 128 ) ) ) {applog ( LOG_WARNING , ""%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s"" , __func__ , header ) ;pool_failed ( pool ) ;return false ;}cb1 = ( unsigned char * ) calloc ( cb1_len , 1 ) ;",5281
1676,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |  NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ;if ( ses -> server -> sign ) {flags |= NTLMSSP_NEGOTIATE_SIGN ;}tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ;,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL ;if ( ses -> server -> sign ) flags |= NTLMSSP_NEGOTIATE_SIGN ;tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ;,5282
1677,"void next_character ( void )  {strlcpy ( cipher , english_alphabet , ENGLISH_ALPHABET_BUF ) ;","void next_character ( void ) {if ( ! recovery_started ) {recovery_abort ( ) ;fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ;layoutHome ( ) ;return ;}strlcpy ( cipher , english_alphabet , ENGLISH_ALPHABET_BUF ) ;",5283
1678,uint16_t mus_freq = 0 ;uint8_t mus_event [ ] = {uint8_t mus_event_size = 0 ;,# define MUS_SZ 4 uint16_t mus_freq = 0 ;uint8_t mus_event [ MUS_SZ ] = {uint8_t mus_event_size = 0 ;,5284
1679,"setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ;if ( setup_ret == 0 ) {","setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , MUS_SZ , 0 ) ;if ( setup_ret == 0 ) {",5284
1680,"void * dllhandle ;if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\","void * dllhandle ;if ( COM_CompareExtension ( name , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , name ) ;return NULL ;}if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\",5285
1681,"struct address_space * mapping = page -> mapping ;struct inode * inode = mapping -> host ;trace_f2fs_set_page_dirty ( page , DATA ) ;if ( ! PageUptodate ( page ) )  SetPageUptodate ( page ) ;if ( f2fs_is_atomic_file ( inode ) && ! f2fs_is_commit_atomic_write ( inode ) ) {","struct inode * inode = mapping -> host ;trace_f2fs_set_page_dirty ( page , DATA ) ;if ( ! PageUptodate ( page ) ) SetPageUptodate ( page ) ;if ( PageSwapCache ( page ) ) return __set_page_dirty_nobuffers ( page ) ;if ( f2fs_is_atomic_file ( inode ) && ! f2fs_is_commit_atomic_write ( inode ) ) {",5286
1682,if ( count < DJREPORT_SHORT_LENGTH - 2 )  count = DJREPORT_SHORT_LENGTH - 2 ;,if ( count > DJREPORT_SHORT_LENGTH - 2 ) count = DJREPORT_SHORT_LENGTH - 2 ;,5287
1683,"if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) {pr_err ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\\","if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ;if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ;if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) {pr_err ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\\",5288
1684,"while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END )  {","check_stack_depth ( ) ;while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) {",5289
1685,"char * tmp ;e = ast_for_expr ( c , CHILD ( ch , 0 ) ) ;","const char * tmp ;e = ast_for_expr ( c , CHILD ( ch , 0 ) ) ;",5290
1686,"if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pflags ) != IS_LONG ) {","if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) {zval_ptr_dtor ( & intern -> array ) ;",5291
1687,"if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) {goto outexcept ;","if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) {goto outexcept ;",5291
1688,assert ( idx >= 0 && idx <= PCI_BARMAX ) ;if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ;,if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ;,5292
1689,case PCIBAR_MEM64 :  if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) {,"case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) {pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>MEM64<S2SV_blank>type\\\return - 1 ;}if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) {",5292
1690,"default :  printf ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\assert ( 0 ) ;}","default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\return - 1 ;}",5292
1691,assert ( idx + 1 <= PCI_BARMAX ) ;pdi -> bar [ idx + 1 ] . type = PCIBAR_MEMHI64 ;,pdi -> bar [ idx + 1 ] . type = PCIBAR_MEMHI64 ;,5292
1692,if ( t -> pool -> shutdown ) {pthread_exit ( NULL ) ;,pthread_mutex_unlock ( & t -> cond_mutex ) ;if ( t -> pool -> shutdown ) {pthread_exit ( NULL ) ;,5293
1693,"size = urb -> transfer_buffer_length ;if ( usb_pipeout ( urb -> pipe ) ) return 0 ;size = urb -> actual_length ;if ( ! ( size > 0 ) ) return 0 ;ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ;if ( ret != size ) {}usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return ret ;}","if ( size > urb -> transfer_buffer_length ) {if ( ud -> side == USBIP_STUB ) {usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ;return 0 ;usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return - EPIPE ;}ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ;if ( ret != size ) {}usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return ret ;}",5294
1694,"ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ;","ret = ext4_split_unwritten_extents ( handle , inode , map , map , path , flags ) ;",5295
1695,"ret = ext4_convert_unwritten_extents_endio ( handle , inode ,  path ) ;","ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;",5295
1696,"av_cold void ff_mpv_idct_init ( MpegEncContext * s )  {ff_idctdsp_init ( & s -> idsp , s -> avctx ) ;","av_cold void ff_mpv_idct_init ( MpegEncContext * s ) {if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;ff_idctdsp_init ( & s -> idsp , s -> avctx ) ;",5296
1697,"mipspmu_event_update ( event , hwc , idx ) ;data -> period = event -> hw . last_period ;if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ;if ( perf_event_overflow ( event , 0 , data , regs ) )  mipspmu -> disable_event ( idx ) ;","mipspmu_event_update ( event , data , regs ) ) mipspmu -> disable_event ( idx ) ;",5297
1698,"if ( ! eof ) {memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ;","if ( ! eof && vars -> str . c != vars -> ptr ) {memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ;",5298
1699,"retval = generic_gss_oid_decompose ( minor_status ,  GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ;","if ( ctx -> terminated || ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;return GSS_S_NO_CONTEXT ;}retval = generic_gss_oid_decompose ( minor_status , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ;",5299
1700,cur_token = * indx ;mailbox_list = NULL ;,clist * list ;cur_token = * indx ;mailbox_list = NULL ;goto free_display_name ;}list = clist_new ( ) ;if ( list == NULL ) {res = MAILIMF_ERROR_MEMORY ;goto free_display_name ;}mailbox_list = mailimf_mailbox_list_new ( list ) ;if ( mailbox_list == NULL ) {res = MAILIMF_ERROR_MEMORY ;clist_free ( list ) ;,5300
1701,res = r ;goto free_display_name ;,res = r ;goto free_display_name ;,5300
1702,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ;",5301
1703,"
","memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;",5302
1704,av_freep ( & h -> DPB ) ;},av_freep ( & h -> DPB ) ;},5302
1705,"return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ;}","return __load_segment_descriptor ( ctxt , selector , seg , cpl , false , NULL ) ;}",5303
1706,"mark_object ( & c -> object , NULL , NULL , data ) ;}","mark_object ( & c -> object , NULL , data ) ;}",5304
1707,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;",5305
1708,"
",rcu_read_lock ( ) ;,5306
1709,"final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ;if ( ! dst ) {","final_p = fl6_update_dst ( fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ;if ( ! dst ) {",5306
1710,static struct desc_struct * get_desc ( unsigned short sel )  {struct desc_struct * desc = NULL ;struct ldt_struct * ldt ;if ( ldt && sel < ldt -> nr_entries )   desc = & ldt -> entries [ sel ] ;mutex_unlock ( & current -> active_mm -> context . lock ) ;return desc ;}if ( desc_base > gdt_desc . size )  return NULL ;return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ;},"static bool get_desc ( struct desc_struct * out , unsigned short sel ) {bool success = false ;struct ldt_struct * ldt ;if ( ldt && sel < ldt -> nr_entries ) {* out = ldt -> entries [ sel ] ;success = true ;}mutex_unlock ( & current -> active_mm -> context . lock ) ;return success ;}if ( desc_base > gdt_desc . size ) return false ;* out = * ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ;return true ;}",5307
1711,if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ;else if ( i > pos && i + insn -> off + 1 < pos )  insn -> off -= delta ;,if ( i < pos && i + insn -> off + 1 <= pos + delta ) insn -> off += delta ;else if ( i > pos + delta && i + insn -> off + 1 < pos ) insn -> off -= delta ;,5308
1712,"static int indenterror ( struct tok_state * tok )  {if ( tok -> alterror ) {return 1 ;}if ( tok -> altwarning ) {# ifdef PGEN PySys_WriteStderr ( ""inconsistent<S2SV_blank>use<S2SV_blank>of<S2SV_blank>tabs<S2SV_blank>and<S2SV_blank>spaces<S2SV_blank>"" ""in<S2SV_blank>indentation\\\# else PySys_FormatStderr ( ""%U:<S2SV_blank>inconsistent<S2SV_blank>use<S2SV_blank>of<S2SV_blank>tabs<S2SV_blank>and<S2SV_blank>spaces<S2SV_blank>"" ""in<S2SV_blank>indentation\\\# endif tok -> altwarning = 0 ;}return 0 ;",static int indenterror ( struct tok_state * tok ) {return ERRORTOKEN ;,5309
1713,"if ( NULL == siocb -> scm ) siocb -> scm = & scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;","if ( NULL == siocb -> scm , true ) siocb -> scm = & scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;",5310
1714,if ( ! ok ) return ( ( int ) n ) ;if ( s -> session -> peer != NULL ) {,if ( peer != NULL ) {,5311
1715,if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) )  {,if ( ( peer != NULL ) {,5311
1716,"bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ;APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ;","apr_brigade_cleanup ( brigade ) ;bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ;APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ;",5312
1717,case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ;,case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case RAPTOR_OPTION_RELATIVE_URIS : case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ;,5313
1718,"if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ;","if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ;",5314
1719,if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) ||  skb -> len < nlh -> nlmsg_len ) {err = - EINVAL ;goto ack ;,if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) ) {nfnl_err_reset ( & err_list ) ;status |= NFNL_BATCH_FAILURE ;goto done ;,5314
1720,"separator = strchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;","separator = osStrchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;",5315
1721,"c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ;if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) {av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\\return AVERROR_INVALIDDATA ;}if ( c -> nreslevels < s -> reduction_factor )   c -> nreslevels2decode = 1 ;else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ;",c -> nreslevels <= s -> reduction_factor ) c -> nreslevels2decode = 1 ;else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ;,5316
1722,"static void encode_segmentation ( VP9_COMP * cpi ,  struct vp9_write_bit_buffer * wb ) {struct segmentation * seg = & cpi -> common . seg ;vp9_wb_write_bit ( wb , seg -> enabled ) ;vp9_wb_write_bit ( wb , seg -> update_map ) ;if ( seg -> update_map ) {vp9_choose_segmap_coding_method ( cpi ) ;for ( i = 0 ;vp9_wb_write_bit ( wb , update ) ;if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ;vp9_wb_write_bit ( wb , seg -> temporal_update ) ;if ( seg -> temporal_update ) {vp9_wb_write_bit ( wb , update ) ;if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ;vp9_wb_write_bit ( wb , seg -> update_data ) ;if ( seg -> update_data ) {vp9_wb_write_bit ( wb , seg -> abs_delta ) ;for ( i = 0 ;const int active = vp9_segfeature_active ( seg , i , j ) ;vp9_wb_write_bit ( wb , active ) ;const int data = vp9_get_segdata ( seg , i , j ) ;const int data_max = vp9_seg_feature_data_max ( j ) ;vp9_wb_write_bit ( wb , data < 0 ) ;}","static void encode_segmentation ( VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer * wb ) {const struct segmentation * seg = & cm -> seg ;vpx_wb_write_bit ( wb , seg -> enabled ) ;vpx_wb_write_bit ( wb , seg -> update_map ) ;if ( seg -> update_map ) {vp9_choose_segmap_coding_method ( cm , xd ) ;for ( i = 0 ;vpx_wb_write_bit ( wb , update ) ;if ( update ) vpx_wb_write_literal ( wb , update ) ;if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ;vpx_wb_write_bit ( wb , seg -> temporal_update ) ;if ( seg -> temporal_update ) {vpx_wb_write_bit ( wb , update ) ;if ( update ) vpx_wb_write_literal ( wb , update ) ;if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ;vpx_wb_write_bit ( wb , seg -> update_data ) ;if ( seg -> update_data ) {vpx_wb_write_bit ( wb , seg -> abs_delta ) ;for ( i = 0 ;const int active = segfeature_active ( seg , i , j ) ;vpx_wb_write_bit ( wb , active ) ;const int data = get_segdata ( seg , i , j ) ;const int data_max = vp9_seg_feature_data_max ( j ) ;vpx_wb_write_bit ( wb , data < 0 ) ;}",5317
1723,void exit_io_context ( void )  {task_lock ( current ) ;ioc = current -> io_context ;current -> io_context = NULL ;task_unlock ( current ) ;if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) {,void exit_io_context ( struct task_struct * task ) {task_lock ( task ) ;ioc = current -> io_context ;task -> io_context = NULL ;task_unlock ( task ) ;if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) {,5318
1724,"run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;free ( fname ) ;","run_cmd ( tty_fd , xfr_cmd , fname ) ;free ( fname ) ;",5319
1725,"vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",5320
1726,"vpx_memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta_s = ( ENTROPY_CONTEXT * ) & t_above_s ;","memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta_s = ( ENTROPY_CONTEXT * ) & t_above_s ;",5320
1727,"vpx_memcpy ( ta_b , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( tl_b , tl_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;}vpx_memcpy ( ta , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( tl , tl_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;labels2mode ( x , labels , i , mode_selected , & mode_mv [ mode_selected ] , bsi -> ref_mv , x -> mvcost ) ;","memcpy ( ta_b , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( tl_b , tl_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;}memcpy ( ta , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( tl , tl_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;labels2mode ( x , labels , i , mode_selected , & mode_mv [ mode_selected ] , bsi -> ref_mv , x -> mvcost ) ;",5320
1728,"if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ;if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA )  && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ;switch ( ctxt -> mode ) {case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ;break ;case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ;break ;default : break ;}cs_sel = ( u16 ) msr_data ;cs_sel &= ~ SELECTOR_RPL_MASK ;ss_sel &= ~ SELECTOR_RPL_MASK ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) {cs . d = 0 ;ctxt -> _eip = msr_data ;ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ;* reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ;return X86EMUL_CONTINUE ;","if ( ctxt -> mode != X86EMUL_MODE_PROT64 ) && ( efer & EFER_LMA ) && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ;if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ;cs_sel = ( u16 ) msr_data ;cs_sel &= ~ SELECTOR_RPL_MASK ;ss_sel &= ~ SELECTOR_RPL_MASK ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) {cs . d = 0 ;ctxt -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) msr_data ;ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ;* reg_write ( ctxt , VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 ) msr_data ;return X86EMUL_CONTINUE ;",5321
1729,"if ( ! object )  return NULL ;json_init ( & object -> json , JSON_OBJECT ) ;","if ( ! object ) return NULL ;if ( ! hashtable_seed ) {json_object_seed ( 0 ) ;}json_init ( & object -> json , JSON_OBJECT ) ;",5322
1730,sr -> bytes_to_send = finfo . size ;sr -> headers . content_length = finfo . size ;,sr -> fd_is_fdt = MK_FALSE ;sr -> bytes_to_send = finfo . size ;sr -> headers . content_length = finfo . size ;,5323
1731,"static void record_recent_object ( struct object * obj ,  struct strbuf * path ,   const char * last ,  void * data ) {","static void record_recent_object ( struct object * obj , const char * last , void * data ) {",5324
1732,release_sock ( sk ) ;return 0 ;,haddr -> hci_channel = 0 ;release_sock ( sk ) ;return 0 ;,5325
1733,"flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;if ( ! flen ) continue ;","flen = udf_get_filename ( dir -> i_sb , nameptr , lfi , fname , UDF_NAME_LEN ) ;if ( ! flen ) continue ;",5326
1734,"else if ( eobs [ 0 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}else if ( eobs [ 1 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstu + 4 , stride , dstu + 4 , stride ) ;vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",5327
1735,"else if ( eobs [ 0 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}else if ( eobs [ 1 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstv + 4 , stride , dstv + 4 , stride ) ;vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",5327
1736,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,5328
1737,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",5328
1738,const char command5 [ ] = {int s ;,"const char command5 [ ] = {const char bad_command4 [ ] = {0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f };int s ;",5329
1739,"
",if ( n == 0 ) {,5329
1740,"
","n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ;n = read ( s , buf , sizeof ( buf ) ) ;printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\\printresponse ( buf , n ) ;close ( s ) ;s = connect_unix_socket ( sockpath ) ;}",5329
1741,close ( s ) ;return 0 ;},close ( s ) ;return 0 ;},5329
1742,buf = g_malloc ( size ) ;if ( object ) {,buf = g_malloc0 ( size ) ;if ( object ) {,5330
1743,"show_object ( obj , NULL , name , data ) ;continue ;","show_object ( obj , name , data ) ;continue ;",5331
1744,"process_blob ( revs , ( struct blob * ) obj , show_object ,  NULL , path , data ) ;continue ;","process_blob ( revs , ( struct blob * ) obj , show_object , NULL , path , data ) ;continue ;",5331
1745,"tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z ,  & p -> buff , p -> name ) ;","tf = ( luaY_parser ) ( L , p -> z , & p -> buff , p -> name ) ;",5332
1746,},"this_cpu_add ( net_rand_state . s1 , rol32 ( jiffies , 24 ) + user_tick ) ;}",5333
1747,( void ) mvcost ;( void ) distortion ;,( void ) mb ;( void ) mvcost ;( void ) distortion ;,5334
1748,"uint8_t * outbuf ;int rc ;command = buf [ 0 ] ;outbuf = ( uint8_t * ) r -> iov . iov_base ;DPRINTF ( ""Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x"" , req -> lun , req -> tag , buf [ 0 ] ) ;# ifdef DEBUG_SCSI {int i ;for ( i = 1 ;i < r -> req . cmd . len ;i ++ ) {printf ( ""<S2SV_blank>0x%02x"" , buf [ i ] ) ;}printf ( ""\\\}# endif switch ( command ) {case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 :  rc = scsi_disk_emulate_command ( r , outbuf ) ;if ( rc < 0 ) {return 0 ;}r -> iov . iov_len = rc ;break ;case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ;r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ;if ( r -> req . aiocb == NULL ) {scsi_flush_complete ( r , - EIO ) ;}return 0 ;case READ_6 : case READ_10 : case READ_12 : case READ_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ;","int rc ;command = buf [ 0 ] ;outbuf = ( uint8_t * ) r -> iov . iov_base ;DPRINTF ( ""Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x"" , req -> lun , req -> tag , buf [ 0 ] ;",5335
1749,if ( a -> name == MAPI_BODY_HTML )  {else if ( a -> name == MAPI_RTF_COMPRESSED )  {,if ( a -> type == szMAPI_BINARY && a -> name == MAPI_BODY_HTML ) {else if ( a -> type == szMAPI_BINARY && a -> name == MAPI_RTF_COMPRESSED ) {,5336
1750,"int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ;int hexdump ;int offset , subobj_type , subobj_len , total_subobj_len ;int link_type ;","u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ;int hexdump ;u_int offset ;u_int link_type ;",5337
1751,"
","if ( tlen < sizeof ( const struct lmp_common_header ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ;return ;}if ( tlen > len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ;tlen = len ;}",5337
1752,"tptr += sizeof ( const struct lmp_common_header ) ;tlen -= sizeof ( const struct lmp_common_header ) ;if ( lmp_obj_len % 4 || lmp_obj_len < 4 )  return ;ND_PRINT ( ( ndo , ""\\\obj_tptr = tptr + sizeof ( struct lmp_object_header ) ;case LMP_CTYPE_LOC : case LMP_CTYPE_RMT :  ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT :  ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT :  ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_UNMD_LOC :  case LMP_CTYPE_UNMD_RMT :  ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_1 :  ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_2 :  ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_LOC : case LMP_CTYPE_RMT :  ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_HELLO_CONFIG :  ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_HELLO :  ND_PRINT ( ( ndo , ""\\\case LMP_OBJ_TE_LINK :  ND_PRINT ( ( ndo , ""\\\switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_IPV6 :  case LMP_CTYPE_UNMD : default : hexdump = TRUE ;case LMP_OBJ_DATA_LINK :  ND_PRINT ( ( ndo , ""\\\switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : case LMP_CTYPE_UNMD : ND_PRINT ( ( ndo , ""\\\total_subobj_len = lmp_obj_len - 16 ;offset = 12 ;while ( total_subobj_len > 0 && hexdump == FALSE ) {subobj_type = EXTRACT_16BITS ( obj_tptr + offset ) >> 8 ;subobj_len = EXTRACT_16BITS ( obj_tptr + offset ) & 0x00FF ;ND_PRINT ( ( ndo , ""\\\switch ( subobj_type ) {case INT_SWITCHING_TYPE_SUBOBJ : ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ;ND_PRINT ( ( ndo , ""\\\bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ;ND_PRINT ( ( ndo , ""\\\case WAVELENGTH_SUBOBJ : ND_PRINT ( ( ndo , ""\\\break ;}","tptr += sizeof ( const struct lmp_common_header ) ;tlen -= sizeof ( const struct lmp_common_header ) ;ND_PRINT ( ( ndo , ""\\\if ( lmp_obj_len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ;return ;}if ( ( lmp_obj_len % 4 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ;return ;}obj_tptr = tptr + sizeof ( struct lmp_object_header ) ;case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;}ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_1 : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;}ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_2 : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ;break ;case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ;}break ;case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 : if ( obj_tlen != 20 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : case LMP_CTYPE_UNMD : ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\subobj_len = EXTRACT_16BITS ( obj_tptr + offset ) & 0x00FF ;ND_PRINT ( ( ndo , ""\\\switch ( subobj_type ) {case INT_SWITCHING_TYPE_SUBOBJ : ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;break ;}",5337
1753,"case LMP_OBJ_VERIFY_BEGIN :  switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 :  ND_PRINT ( ( ndo , ""\\\","case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 : ND_PRINT ( ( ndo , ""\\\",5337
1754,"case LMP_OBJ_VERIFY_BEGIN_ACK :  switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 :  ND_PRINT ( ( ndo , ""\\\case LMP_OBJ_VERIFY_ID :  switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 :  ND_PRINT ( ( ndo , ""\\\case LMP_OBJ_CHANNEL_STATUS :  switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 :  case LMP_CTYPE_UNMD : offset = 0 ;while ( offset < ( lmp_obj_len - ( int ) sizeof ( struct lmp_object_header ) ) ) {","case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : offset = 0 ;while ( offset + 8 <= obj_tlen ) {",5337
1755,"case LMP_CTYPE_IPV6 : default : hexdump = TRUE ;case LMP_OBJ_CHANNEL_STATUS_REQ :  switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 :  case LMP_CTYPE_UNMD : offset = 0 ;while ( offset < ( lmp_obj_len - ( int ) sizeof ( struct lmp_object_header ) ) ) {ND_PRINT ( ( ndo , ""\\\offset += 4 ;}break ;case LMP_CTYPE_IPV6 : default : hexdump = TRUE ;}break ;case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) {case LMP_CTYPE_BEGIN_VERIFY_ERROR : ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_LINK_SUMMARY_ERROR : ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) {ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_SERVICE_CONFIG_CPSA :   link_type = EXTRACT_16BITS ( obj_tptr ) >> 8 ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : ND_PRINT ( ( ndo , ""\\\","case LMP_CTYPE_IPV6 : offset = 0 ;while ( offset + 20 <= obj_tlen ) {ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\offset += 20 ;case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) {ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_SERVICE_CONFIG_CPSA : link_type = EXTRACT_16BITS ( obj_tptr ) >> 8 ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\",5337
1756,"static void findoprnd ( ITEM * ptr , int32 * pos )  {if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) {","static void findoprnd ( ITEM * ptr , int32 * pos ) {check_stack_depth ( ) ;if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) {",5338
1757,PHP_SHA512Init ( & context ) ;read_len = end_of_phar ;,"if ( sig_len < sizeof ( digest ) ) {if ( error ) {spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ;}return FAILURE ;}PHP_SHA512Init ( & context ) ;read_len = end_of_phar ;",5339
1758,PHP_SHA256Init ( & context ) ;read_len = end_of_phar ;,"if ( sig_len < sizeof ( digest ) ) {if ( error ) {spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ;}return FAILURE ;}PHP_SHA256Init ( & context ) ;read_len = end_of_phar ;",5339
1759,PHP_SHA1Init ( & context ) ;read_len = end_of_phar ;,"if ( sig_len < sizeof ( digest ) ) {if ( error ) {spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ;}return FAILURE ;}PHP_SHA1Init ( & context ) ;read_len = end_of_phar ;",5339
1760,PHP_MD5Init ( & context ) ;read_len = end_of_phar ;,"if ( sig_len < sizeof ( digest ) ) {read_size = sizeof ( buf ) ;}else {read_size = ( int ) read_len ;}while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) {PHP_MD5Update ( & context , buf , len ) ;read_len -= ( zend_off_t ) len ;if ( read_len < read_size ) {read_size = ( int ) read_len ;}}PHP_MD5Final ( digest , & context ) ;if ( memcmp ( digest , sig , sizeof ( digest ) ) ) {if ( error ) {spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ;}return FAILURE ;}PHP_MD5Init ( & context ) ;read_len = end_of_phar ;",5339
1761,"* signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ;break ;","* signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ;break ;",5339
1762,"struct mct_u232_private * priv ;priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ;priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ;priv -> read_urb -> context = port ;","struct usb_serial * serial = port -> serial ;struct mct_u232_private * priv ;if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) {dev_err ( & port -> dev , ""expected<S2SV_blank>endpoint<S2SV_blank>missing\\\return - ENODEV ;}priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ;priv -> read_urb = serial -> port [ 1 ] -> interrupt_in_urb ;priv -> read_urb -> context = port ;",5340
1763,"int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ;int64_t total_samples = 0 , infilesize ;","int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 , format_chunk = 0 ;int64_t total_samples = 0 , infilesize ;",5341
1764,"int supported = TRUE , format ;if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) {","int supported = TRUE , format ;if ( format_chunk ++ ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) {",5341
1765,"rq = blk_mq_tag_to_rq ( tags , off + bit ) ;fn ( rq , data , reserved ) ;","rq = tags -> rqs [ off + bit ) ;fn ( rq , data , reserved ) ;",5342
1766,pStart = sqlite3Malloc ( sz * cnt ) ;sqlite3EndBenignMalloc ( ) ;,pStart = sqlite3Malloc ( sz * ( sqlite3_int64 ) cnt ) ;sqlite3EndBenignMalloc ( ) ;,5343
1767,"rc = - EFAULT ;if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ;sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ;rc = - EINVAL ;if ( sipx -> sipx_family != AF_IPX ) break ;f . ipx_network = sipx -> sipx_network ;memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ;memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ;f . ipx_dlink_type = sipx -> sipx_type ;f . ipx_special = sipx -> sipx_special ;if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ;else rc = ipxitf_create ( & f ) ;break ;}case SIOCGIFADDR : {struct sockaddr_ipx * sipx ;struct ipx_interface * ipxif ;struct net_device * dev ;rc = - EFAULT ;if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ;sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ;dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ;rc = - ENODEV ;if ( ! dev ) break ;ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type ) ) ;rc = - EADDRNOTAVAIL ;if ( ! ipxif ) break ;sipx -> sipx_family = AF_IPX ;sipx -> sipx_network = ipxif -> if_netnum ;memcpy ( sipx -> sipx_node , ipxif -> if_node , sizeof ( sipx -> sipx_node ) ) ;rc = - EFAULT ;if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) )  break ;ipxitf_put ( ipxif ) ;rc = 0 ;","rc = 0 ;if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = - EFAULT ;ipxitf_put ( ipxif ) ;rc = 0 ;",5344
1768,if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {,"
",5345
1769,}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {,if ( src_known && dst_known ) {,5345
1770,if ( dst_reg -> smin_value < 0 ) {if ( umin_val ) {}},if ( dst_reg -> smin_value < 0 ) {if ( umin_val ) {}},5345
1771,"case LLDP_PRIVATE_8023_SUBTYPE_MTU :  ND_PRINT ( ( ndo , ""\\\break ;","case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;",5346
1772,int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ;for ( y = 0 ;,int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ;av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ;av_assert0 ( height <= JPEG2000_MAX_CBLKH ) ;for ( y = 0 ;,5347
1773,"LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ;for ( ++ x ;","LINE_OP ( output [ x ] , inverse_db_table [ y & 255 ] ) ;for ( ++ x ;",5348
1774,"LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ;}","LINE_OP ( output [ x ] , inverse_db_table [ y & 255 ] ) ;}",5348
1775,"if ( mobj )   memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ;return mobj ;","if ( mobj ) {size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ;memset ( mobj_get_va ( mobj , 0 ) , 0 , ROUNDUP ( size , granularity ) ) ;}return mobj ;",5349
1776,if ( text [ 1 ] == EOF )  return 0 ;if ( text [ 1 ] == 'x' ) {text [ 2 ] = RE_YY_INPUT ( yyscanner ) ;if ( text [ 2 ] == EOF )  return 0 ;if ( text [ 3 ] == EOF )  return 0 ;,if ( text [ 1 ] == EOF || text [ 1 ] == 0 ) return 0 ;if ( ! isxdigit ( text [ 1 ] == 'x' ) {text [ 2 ] ) ) return 0 ;if ( ! isxdigit ( text [ 3 ] ) ) return 0 ;,5350
1777,"* low = p - reg -> dmax ;if ( * low > s ) {if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc ,  ( pprev ? pprev : str ) , * low ) ;}","if ( p - str < reg -> dmax ) {* low = ( UChar * ) str ;if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ;}}else {* low = p - reg -> dmax ;if ( * low > s ) {if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ;}",5351
1778,"if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) )  goto out ;","if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) goto out ;",5352
1779,"channel = amqp_d16 ( amqp_offset ( raw_frame , 1 ) ) ;state -> target_size =   amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) + HEADER_SIZE + FOOTER_SIZE ;if ( ( size_t ) state -> frame_max < state -> target_size ) {","uint32_t frame_size ;channel = amqp_d16 ( amqp_offset ( raw_frame , 1 ) ) ;frame_size = amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) ;if ( frame_size >= INT32_MAX ) {return AMQP_STATUS_BAD_AMQP_DATA ;}state -> target_size = frame_size + HEADER_SIZE + FOOTER_SIZE ;if ( ( size_t ) state -> frame_max < state -> target_size ) {",5353
1780,"case MAPI_ATTACH_LONG_FILENAME :  if ( file -> name ) XFREE ( file -> name ) ;file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ;case MAPI_ATTACH_DATA_OBJ :  file -> len = a -> values [ 0 ] . len ;if ( file -> data ) XFREE ( file -> data ) ;case MAPI_ATTACH_MIME_TAG :  if ( file -> mime_type ) XFREE ( file -> mime_type ) ;file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;case MAPI_ATTACH_CONTENT_ID :  if ( file -> content_id ) XFREE ( file -> content_id ) ;file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;","case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ;if ( file -> name ) XFREE ( file -> name ) ;file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ;case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ;file -> len = a -> values [ 0 ] . len ;if ( file -> data ) XFREE ( file -> data ) ;case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ;if ( file -> mime_type ) XFREE ( file -> mime_type ) ;file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;if ( file -> content_id ) XFREE ( file -> content_id ) ;file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;",5354
1781,"if ( istreq ( str , ""all"" ) ) {* val_rtrn = MOD_REAL_MASK_ALL ;","if ( ! str ) return false ;if ( istreq ( str , ""all"" ) ) {* val_rtrn = MOD_REAL_MASK_ALL ;",5355
1782,"ihevcd_cxa_create_op_t * ps_create_op ;WORD32 ret ;ps_create_op = ( ihevcd_cxa_create_op_t * ) pv_api_op ;ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ;ret = ihevcd_allocate_static_bufs ( & ps_codec_obj , pv_api_ip , pv_api_op ) ;if ( ( IV_FAIL == ret ) && ( NULL != ps_codec_obj ) )  {ihevcd_free_static_bufs ( ps_codec_obj ) ;ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ;","ihevcd_cxa_create_ip_t * ps_create_ip ;ihevcd_cxa_create_op_t * ps_create_op ;WORD32 ret ;ps_create_ip = ( ihevcd_cxa_create_ip_t * ) pv_api_ip ;ps_create_op = ( ihevcd_cxa_create_op_t * ) pv_api_op ;ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ;ps_codec_obj = NULL ;ret = ihevcd_allocate_static_bufs ( & ps_codec_obj , pv_api_ip , pv_api_op ) ;if ( IV_FAIL == ret ) && ( NULL != ps_codec_obj ) {if ( ps_codec_obj -> pv_codec_handle ) {ihevcd_free_static_bufs ( ps_codec_obj ) ;}else {void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ;void * pv_mem_ctxt ;pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ;pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ;pf_aligned_free ( pv_mem_ctxt , ps_codec_obj ) ;}}ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ;",5356
1783,"int pkt_len ;char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) {* err = file_error ( wth -> random_fh , err_info ) ;if ( * err == 0 ) {* err = WTAP_ERR_SHORT_READ ;}return FALSE ;}pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;if ( pkt_len == - 1 )  return FALSE ;if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ;return TRUE ;","char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;return parse_netscreen_packet ( wth -> random_fh , phdr , buf , line , cap_int , & cap_dir , cap_dst , err , err_info ) ;",5357
1784,"alloc_limit_assert ( ""checked_xcalloc"" , ( num * size ) ) ;return xcalloc ( num , size ) ;","size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;alloc_limit_assert ( ""checked_xcalloc"" , ( res ) ) ;return xcalloc ( num , size ) ;",5358
1785,bufsize = file -> size ;sc_file_free ( file ) ;,"bufsize = MIN ( file -> size , sizeof buf ) ;sc_file_free ( file ) ;",5359
1786,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return simulate_ll ( regs , opcode ) ;perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return simulate_sc ( regs , opcode ) ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return simulate_ll ( regs , opcode ) ;perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return simulate_sc ( regs , opcode ) ;",5360
1787,"if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) )  goto out ;","if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) goto out ;",5361
1788,"if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) {memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ;","ret = sort_idmaps ( & new_map ) ;if ( ret < 0 ) goto out ;if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) {memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ;",5361
1789,int pixel_ptr = 0 ;int block_ptr ;,int pixel_ptr = - 4 ;int block_ptr ;,5362
1790,ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,ADVANCE_BLOCK ( ) ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,5362
1791,ADVANCE_BLOCK ( ) ;},},5362
1792,block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,5362
1793,ADVANCE_BLOCK ( ) ;}block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,}ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,5362
1794,ADVANCE_BLOCK ( ) ;break ;,break ;,5362
1795,* ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ;if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) {,assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;* ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ;if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) {,5363
1796,"}if ( rctx -> topdown ) {iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ;}","goto done ;}if ( rctx -> topdown ) {iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ;goto done ;}",5364
1797,int err = 0 ;if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ;,int err = 0 ;msg -> msg_namelen = 0 ;if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ;,5365
1798,put_io_context ( ioc ) ;}},}put_io_context ( ioc ) ;},5366
1799,},"add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ;hook_add_event ( ""nick_can_register"" ) ;hook_add_nick_can_register ( check_registration_keywords ) ;hook_add_event ( ""user_can_register"" ) ;hook_add_user_can_register ( check_registration_keywords ) ;}",5367
1800,if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC )  {,UNUSED ( u1_is_idr_slice ) ;if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) {,5368
1801,"if ( ! ps_dec -> u1_first_slice_in_stream )  {ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ;ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ;}","
",5368
1802,"static inline struct enamemem *  lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , const unsigned int nlen ) {struct enamemem * tp ;register u_int i , j , k ;","static inline struct bsnamemem * lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , const unsigned int nlen ) {struct bsnamemem * tp ;register u_int i , j , k ;",5369
1803,"while ( tp -> e_nxt )  if ( tp -> e_addr0 == i &&  tp -> e_addr1 == j &&   tp -> e_addr2 == k &&   memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 )  return tp ;else  tp = tp -> e_nxt ;tp -> e_addr0 = i ;tp -> e_addr1 = j ;tp -> e_addr2 = k ;tp -> e_bs = ( u_char * ) calloc ( 1 , nlen + 1 ) ;if ( tp -> e_bs == NULL )  ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ;memcpy ( tp -> e_bs , bs , nlen ) ;tp -> e_nxt = ( struct enamemem * ) calloc ( 1 , sizeof ( * tp ) ) ;if ( tp -> e_nxt == NULL )  ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ;","while ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes && tp -> e_addr1 == j && tp -> bs_addr1 == j && tp -> bs_addr2 == k && memcmp ( ( const char * ) bs , ( const char * ) ( tp -> bs_bytes ) , nlen ) == 0 ) return tp ;else tp = tp -> bs_nxt ;tp -> bs_addr0 = i ;tp -> bs_addr1 = j ;tp -> bs_addr2 = k ;tp -> bs_bytes = ( u_char * ) calloc ( 1 , nlen + 1 ) ;if ( tp -> bs_bytes == NULL ) ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ;memcpy ( tp -> bs_bytes , bs , nlen ) ;tp -> bs_nbytes = nlen ;tp -> bs_nxt = ( struct bsnamemem * ) calloc ( 1 , sizeof ( * tp ) ) ;if ( tp -> bs_nxt == NULL ) ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ;",5369
1804,"void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) {","void vp9_iht4x4_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) {",5370
1805,if ( length > 0 ) {buffer = malloc ( ( uint64_t ) length + 1 ) ;if ( buffer != NULL ) {,"if ( length == SIZE_MAX ) {rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ;rfbCloseClient ( cl ) ;return NULL ;}if ( length > 0 ) {buffer = malloc ( ( size_t ) length + 1 ) ;if ( buffer != NULL ) {",5371
1806,"static int mptctl_do_reset ( unsigned long arg )  {struct mpt_ioctl_diag_reset krinfo ;MPT_ADAPTER * iocp ;return - EFAULT ;}if ( mpt_verify_adapter ( krinfo . hdr . iocnum , & iocp ) < 0 ) {printk ( KERN_DEBUG MYNAM ""%s@%d::mptctl_do_reset<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;","static int mptctl_do_reset ( MPT_ADAPTER * iocp , unsigned long arg ) {struct mpt_ioctl_diag_reset krinfo ;return - EFAULT ;",5372
1807,"size_t off = 0 , len = 0 ;# define ADD_DELTA ( o , shift ) {","size_t off = 0 , len = 0 , end ;# define ADD_DELTA ( o , shift ) {",5373
1808,# undef ADD_DELTA  if ( base_len < off + len || res_sz < len )  goto fail ;,"# undef ADD_DELTA if ( GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || base_len < end || res_sz < len ) goto fail ;",5373
1809,"char * method = manager -> method ;int i ;build_config ( working_dir , server ) ;if ( server -> method ) method = server -> method ;snprintf ( cmd , BUF_SIZE ,  ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" ,   executable , method , manager -> manager_address ,   working_dir , server -> port , working_dir , server -> port ) ;if ( manager -> acl != NULL ) {","int i ;int port ;port = atoi ( server -> port ) ;build_config ( working_dir , manager , server ) ;snprintf ( cmd , BUF_SIZE , ""%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf"" , executable , method , manager -> manager_address , working_dir , port , working_dir , server -> port ) ;if ( manager -> acl != NULL ) {",5374
1810,msg -> msg_namelen = 0 ;err = - EAGAIN ;,err = - EAGAIN ;,5375
1811,"
",sas_destruct_devices ( port ) ;sas_destruct_ports ( port ) ;sas_probe_devices ( port ) ;,5376
1812,},},5376
1813,"if ( io_data -> read && ret > 0 ) {use_mm ( io_data -> mm ) ;ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ;if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ;unuse_mm ( io_data -> mm ) ;}io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ;if ( io_data -> ffs -> ffs_eventfd &&  ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) )  eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ;usb_ep_free_request ( io_data -> ep , io_data -> req ) ;io_data -> kiocb -> private = NULL ;","bool kiocb_has_eventfd = io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ;if ( io_data -> ffs -> ffs_eventfd && ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ;usb_ep_free_request ( io_data -> ep , io_data -> req ) ;io_data -> kiocb -> private = NULL ;",5377
1814,"dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;if ( csum )  dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) {","dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG ;if ( csum ) dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG ;if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) {",5378
1815,"ctx -> clockid = clockid ;if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ;","spin_lock_init ( & ctx -> cancel_lock ) ;ctx -> clockid = clockid ;if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ;",5379
1816,if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;if ( entry == ( kadm5_principal_ent_t ) NULL )  return EINVAL ;,if ( entry == NULL ) return EINVAL ;if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;,5380
1817,"if ( length == 0 && last )  COAP_SET_BLOCK_M ( value , 0 ) ;else   COAP_SET_BLOCK_M ( value , 1 ) ;COAP_SET_BLOCK_SZX ( value , blockSzx ) ;","if ( length == 0 && last ) {COAP_SET_BLOCK_M ( value , 0 ) ;}else {COAP_SET_BLOCK_M ( value , 1 ) ;}COAP_SET_BLOCK_SZX ( value , blockSzx ) ;",5381
1818,if ( '%' == * ptr ) {if ( '%' == ptr [ 1 ] ) {,if ( '%' == * ptr && ptr [ 1 ] ) {if ( '%' == ptr [ 1 ] ) {,5382
1819,unlock_mount_hash ( ) ;if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) {,"if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) {struct mount * p , * tmp ;list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) {umount_mnt ( p ) ;}}unlock_mount_hash ( ) ;if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) {",5383
1820,"zap = key -> payload . data [ 0 ] ;rcu_assign_keypointer ( key , upayload ) ;key -> expiry = 0 ;","if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) zap = key -> payload . data [ 0 ] ;else zap = NULL ;rcu_assign_keypointer ( key , upayload ) ;key -> expiry = 0 ;",5384
1821,"if ( ! asoc )  return - EINVAL ;if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ;","if ( ! asoc ) return - EINVAL ;if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ;if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ;",5385
1822,"if ( in_creds -> client == NULL && subject_cert == NULL ) {return EINVAL ;}if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) {int anonymous ;anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ;return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ;}memset ( & creds , 0 , sizeof ( creds ) ) ;memset ( & userid , 0 , sizeof ( userid ) ) ;if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ;code = krb5_get_init_creds_opt_alloc ( context , & opts ) ;if ( code != 0 ) goto cleanup ;krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ;krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ;krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ;krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ;krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ;krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ;if ( in_creds -> client != NULL ) {client = * in_creds -> client ;client . realm = in_creds -> server -> realm ;}else {client . magic = KV5M_PRINCIPAL ;client . realm = in_creds -> server -> realm ;client . data = NULL ;client . length = 0 ;client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ;}code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ;if ( code == 0 || code == KRB5_PREAUTH_FAILED ) {* canon_user = userid . user ;",if ( ! code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP ) {* canon_user = userid . user ;,5386
1823,"memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ;return 0 ;}","mutex_lock ( & ue -> card -> user_ctl_lock ) ;memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ;mutex_unlock ( & ue -> card -> user_ctl_lock ) ;return 0 ;}",5387
1824,"return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;}","return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID ) ;}",5388
1825,ps_dec -> u2_reinit_max_height = u2_height ;ps_dec -> u2_reinit_max_width = u2_width ;else {return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ;}}}if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) {IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ;return SET_IVD_FATAL_ERROR ( e_error ) ;},ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ;ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ;,5389
1826,if ( ! offset ) {return & EG ( uninitialized_zval_ptr ) ;,if ( ! offset || ! ht ) {return & EG ( uninitialized_zval_ptr ) ;,5390
1827,"gss_buffer_desc client_name , service_name ;OM_uint32 minor_stat ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;OM_uint32 minor_stat ;,5391
1828,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",5391
1829,"buffer = zend_string_alloc ( len , 0 ) ;n = zip_fread ( zr_rsrc -> zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ;","buffer = zend_string_safe_alloc ( 1 , len , 0 , 0 ) ;n = zip_fread ( zr_rsrc -> zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ;",5392
1830,sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ;if ( ! sbi -> s_mb_cache ) {,sbi -> s_mb_cache = ext4_xattr_create_cache ( ) ;if ( ! sbi -> s_mb_cache ) {,5393
1831,failed_mount_wq :  if ( sbi -> s_journal ) {,failed_mount_wq : if ( sbi -> s_mb_cache ) {ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ;sbi -> s_mb_cache = NULL ;}if ( sbi -> s_journal ) {,5393
1832,pack -> hdr . ver = ver ;pack -> hdr . T = 1 ;pack -> hdr . L = 1 ;pack -> hdr . S = 1 ;,pack -> hdr . flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | ( ver & L2TP_VER_MASK ) ;,5394
1833,error = 0 ;if ( pkt == NULL ) continue ;,error = 0 ;,5395
1834,if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;if ( ( mask & ~ ALL_PRINC_MASK ) )   return KADM5_BAD_MASK ;if ( entry == NULL ) return EINVAL ;,if ( entry == NULL ) return EINVAL ;if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;,5396
1835,"namespace_lock ( ) ;tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ;","namespace_lock ( ) ;if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ;else tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ;",5397
1836,"if ( ! asoc )  return - EINVAL ;if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ;","if ( ! asoc ) return - EINVAL ;if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ;if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ;",5398
1837,"status = HuffmanDecodeImage ( image ) ;if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}status = HuffmanDecodeImage ( image ) ;if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;",5399
1838,"static int  mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size )  {MPT_ADAPTER * ioc ;struct pci_dev * pdev ;ConfigPageHeader_t hdr ;int iocnum ;","static int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc , unsigned long arg , unsigned int data_size ) {struct pci_dev * pdev ;ConfigPageHeader_t hdr ;",5400
1839,"}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_hp_hostinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;","
",5400
1840,"if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ;if ( COMPAT_USE_64BIT_TIME )  return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ;if ( get_compat_timespec ( & ktspec , timeout ) )  return - EFAULT ;if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) )  datagrams = - EFAULT ;","if ( get_compat_timespec ( & ktspec , timeout ) ) return - EFAULT ;if ( compat_get_timespec ( & ktspec , timeout ) ) datagrams = - EFAULT ;",5401
1841,"SCV_NB10_HEADER nb10_hdr ;init_cv_nb10_header ( & nb10_hdr ) ;snprintf ( res -> guidstr , sizeof ( res -> guidstr ) ,  ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ;strncpy ( res -> file_name , ( const char * )  nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ;res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ;","if ( dbg_data_len < 20 ) {eprintf ( ""Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\\return 0 ;}SCV_NB10_HEADER nb10_hdr = {{0 }};init_cv_nb10_header ( & nb10_hdr ) ;snprintf ( res -> guidstr , sizeof ( res -> guidstr ) , ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ;res -> file_name [ 0 ] = 0 ;if ( nb10_hdr . file_name ) {strncpy ( res -> file_name , ( const char * ) nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ;}res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ;",5402
1842,bpm -> family = AF_BRIDGE ;bpm -> ifindex = dev -> ifindex ;,"memset ( bpm , 0 , sizeof ( * bpm ) ) ;bpm -> family = AF_BRIDGE ;bpm -> ifindex = dev -> ifindex ;",5403
1843,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS ,  1 , 0 , regs , regs -> cp0_badvaddr ) ;if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , regs -> cp0_badvaddr ) ;if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ;",5404
1844,"
","VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ;",5405
1845,"b = BCON_NEW ( ""my_dbref"" ,  ""{","b = BCON_NEW ( ""my_dbref"" , ""{",5405
1846,"vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ;if ( setjmp ( pbi -> common . error . jmp ) ) {","memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ;if ( setjmp ( pbi -> common . error . jmp ) ) {",5406
1847,# else  pbi -> ec_enabled = 0 ;# endif pbi -> ec_active = 0 ;,# else ( void ) oxcf ;pbi -> ec_enabled = 0 ;# endif pbi -> ec_active = 0 ;,5406
1848,"if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) {copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;","if ( is_link ( fname ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\\exit ( 1 ) ;}if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) {copy_file_as_user ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;",5407
1849,"if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( fname , & s ) == 0 ) return ;if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ;","copy_file_as_user ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ;",5407
1850,"if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ;","if ( is_link ( fname ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\\exit ( 1 ) ;}if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {copy_file_as_user ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ;",5407
1851,"if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) {vfy |= RPMVERIFY_LSTATFAIL ;goto exit ;","if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) ) {struct stat dsb ;if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) {uid_t fuid ;if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) {sb = dsb ;}}",5408
1852,"asdl_seq * body ;if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) {","asdl_seq * body ;asdl_seq * type_ignores ;if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) {",5409
1853,"Py_CLEAR ( tmp ) ;}* out = Module ( body , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ;if ( isinstance == - 1 ) {if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ;return 1 ;PyErr_Format ( PyExc_TypeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;body = _Py_asdl_seq_new ( len , arena ) ;if ( body == NULL ) goto failed ;for ( i = 0 ;stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;asdl_seq_SET ( body , i , val ) ;}* out = Interactive ( body , arena ) ;if ( * out == NULL ) goto failed ;isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ;if ( isinstance == - 1 ) {expr_ty body ;if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;","if ( _PyObject_LookupAttrId ( obj , ( PyObject * ) Interactive_type ) ;if ( isinstance == - 1 ) {if ( _PyObject_LookupAttrId ( obj , & PyId_type_ignores , & tmp ) < 0 ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""type_ignores\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;return 1 ;PyErr_Format ( PyExc_TypeError , ""Module<S2SV_blank>field<S2SV_blank>\\\\""type_ignores\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;type_ignores = _Py_asdl_seq_new ( len , arena ) ;if ( type_ignores == NULL ) goto failed ;for ( i = 0 ;type_ignore_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( body , i , val ) ;* out = Interactive ( body , arena ) ;if ( * out == NULL ) goto failed ;isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ;if ( isinstance == - 1 ) {expr_ty body ;if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;}else {int res ;res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Interactive<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( body , i , val ) ;}Py_CLEAR ( tmp ) ;}* out = Interactive ( body , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {expr_ty body ;if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;",5409
1854,"
","isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {asdl_seq * argtypes ;expr_ty returns ;if ( _PyObject_LookupAttrId ( obj , & PyId_argtypes , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;return 1 ;}else {int res ;Py_ssize_t len ;Py_ssize_t i ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;}len = PyList_GET_SIZE ( tmp ) ;argtypes = _Py_asdl_seq_new ( len , arena ) ;if ( argtypes == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""FunctionType<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( argtypes , i , val ) ;}Py_CLEAR ( tmp ) ;}if ( _PyObject_LookupAttrId ( obj , & PyId_returns , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""returns\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;return 1 ;}else {int res ;res = obj2ast_expr ( tmp , & returns , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}* out = FunctionType ( argtypes , returns , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}",5409
1855,"PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;","PyErr_Format ( PyExc_TypeError , ""Suite<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;",5409
1856,"PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;","PyErr_SetString ( PyExc_RuntimeError , ""Suite<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;",5409
1857,"[ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain ,  [ DISCE_PROBE ] = sas_probe_devices ,  [ DISCE_SUSPEND ] = sas_suspend_devices ,  [ DISCE_RESUME ] = sas_resume_devices ,  [ DISCE_DESTRUCT ] = sas_destruct_devices , }","[ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , [ DISCE_SUSPEND ] = sas_suspend_devices , [ DISCE_RESUME ] = sas_resume_devices , [ DISCE_DESTRUCT ] = sas_destruct_devices , }",5410
1858,"it = item_get ( key , nkey , c , DO_UPDATE ) ;if ( settings . detail_enabled ) {","it = limited_get ( key , nkey , c ) ;if ( settings . detail_enabled ) {",5411
1859,"s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , GFP_KERNEL ) ;if ( ! s_cmd ) return - ENOMEM ;if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) {ret = - EFAULT ;goto exit ;}s_cmd -> command += ec -> cmd_offset ;ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ;if ( ret < 0 ) goto exit ;if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) )  ret = - EFAULT ;",s_cmd = kmalloc ( sizeof ( * s_cmd ) + s_cmd -> insize ) ) ret = - EFAULT ;,5412
1860,proto = EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ndo -> ndo_eflag ) {,"const u_char * bp = p ;if ( length < CHDLC_HDRLEN ) goto trunc ;ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ;proto = EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ndo -> ndo_eflag ) {",5413
1861,"case ETHERTYPE_ISO :  if ( * ( p + 1 ) == 0x81 ||  * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;}","case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ;ND_TCHECK_16BITS ( p ) ;if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ;return ndo -> ndo_snapend - bp ;}",5413
1862,if ( atomic_read ( & current -> mm -> mm_users ) > 1 )  return - EINVAL ;,if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) return - EINVAL ;if ( current -> fs -> users != 1 ) return - EINVAL ;,5414
1863,"dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ;if ( ! dev || ( test_bit ( BTRFS_DEV_STATE_MISSING , & dev -> dev_state ) && ! is_dev_replace ) ) {","dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL , true ) ;if ( ! dev || ( test_bit ( BTRFS_DEV_STATE_MISSING , & dev -> dev_state ) && ! is_dev_replace ) ) {",5415
1864,for ( i = 0 ;i < len ;i ++ ) {if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) {szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ;j ++ ;else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;szLineConv [ j ] = szLine [ i ] ;i ++ ;szLineConv [ j ] = szLine [ i ] ;i ++ ;,"for ( i = 0 ;i < len && j < sizeof ( szLineConv ) - 1 ;i ++ , j ++ ) {if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) {if ( j + 1 < sizeof ( szLineConv ) - 1 ) {szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ;j ++ ;else break ;}else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) {if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;else {break ;}}if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;else {break ;}}if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;",5416
1865,i += 1 ;continue ;szLineConv [ j ] = szLine [ i ] ;j ++ ;,break ;if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ;}if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ;else szLineConv [ j ] = szLine [ i ] ;j ++ ;,5416
1866,if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen )  return - EINVAL ;,if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen || replay_esn -> bmp_len != up -> bmp_len ) return - EINVAL ;,5417
1867,"# ifdef HAVE_INT64_TIMESTAMP  char fstr [ MAXDATELEN + 1 ] ;strncpy ( fstr , ( cp + 1 ) , 7 ) ;strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ;* ( fstr + 6 ) = \'\\\\0\' ;",# ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ;int i ;cp ++ ;for ( i = 0 ;i < 6 ;i ++ ) fstr [ i ] = * cp != \'\\\\0\' ? * cp ++ : \'0\' ;fstr [ i ] = \'\\\\0\' ;,5418
1868,"int sctp_verify_asconf ( const struct sctp_association * asoc ,   struct sctp_paramhdr * param_hdr , void * chunk_end ,  struct sctp_paramhdr * * errp ) {sctp_addip_param_t * asconf_param ;union sctp_params param ;int length , plen ;param . v = ( sctp_paramhdr_t * ) param_hdr ;while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) {length = ntohs ( param . p -> length ) ;if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ;case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ;plen = ntohs ( asconf_param -> param_hdr . length ) ;if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ;case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ;default : break ;param . v += WORD_ROUND ( length ) ;if ( param . v != chunk_end ) return 0 ;return 1 ;","bool sctp_verify_asconf ( const struct sctp_association * asoc , struct sctp_chunk * chunk , bool addr_param_needed , struct sctp_paramhdr * * errp ) {sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr ;union sctp_params param ;bool addr_param_seen = false ;sctp_walk_params ( param , addip , addip_hdr . params ) {size_t length = ntohs ( param . p -> length ) ;case SCTP_PARAM_ERR_CAUSE : break ;case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ;addr_param_seen = true ;case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ;addr_param_seen = true ;case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ;length = ntohs ( param . addip -> param_hdr . length ) ;if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ;break ;case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ;break ;default : return false ;if ( addr_param_needed && ! addr_param_seen ) return false ;if ( ! addr_param_needed && addr_param_seen ) return false ;if ( param . v != chunk -> chunk_end ) return false ;return true ;",5419
1869,"if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 )  {close ( fd ) ;return HSM_COM_PATH_ERR ;unlink ( hdl -> c_path ) ;close ( fd ) ;return HSM_COM_BIND_ERR ;unlink ( hdl -> c_path ) ;close ( fd ) ;return HSM_COM_CHMOD_ERR ;","hsm_com_errno_t res = HSM_COM_OK ;if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) {res = HSM_COM_PATH_ERR ;goto cleanup ;res = HSM_COM_BIND_ERR ;goto cleanup ;res = HSM_COM_CHMOD_ERR ;goto cleanup ;",5420
1870,unlink ( hdl -> c_path ) ;close ( fd ) ;return HSM_COM_CONX_ERR ;return HSM_COM_SEND_ERR ;}return HSM_COM_OK ;,res = HSM_COM_CONX_ERR ;goto cleanup ;res = HSM_COM_SEND_ERR ;}return res ;cleanup : close ( fd ) ;return res ;,5420
1871,int counthook ;if ( ! ( mask & ( LUA_MASKLINE | LUA_MASKCOUNT ) ) ) {,const Proto * p = ci_func ( ci ) -> p ;int counthook ;int oldpc = ( L -> oldpc < p -> sizecode ) ? L -> oldpc : 0 ;if ( ! ( mask & ( LUA_MASKLINE | LUA_MASKCOUNT ) ) ) {,5421
1872,"const Proto * p = ci_func ( ci ) -> p ;int npci = pcRel ( pc , p ) ;if ( npci == 0 ||  pc <= L -> oldpc ||   changedline ( p , pcRel ( L -> oldpc , p ) , npci ) ) {int newline = luaG_getfuncline ( p , npci ) ;L -> oldpc = pc ;}","int npci = pcRel ( pc , p ) ;if ( npci == 0 || pc <= invpcRel ( oldpc , p ) || changedline ( p , oldpc , npci ) ) {int newline = luaG_getfuncline ( p , npci ) ;L -> oldpc = npci ;}",5421
1873,"static void sample_hbp_handler ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","static void sample_hbp_handler ( struct perf_event * bp , struct perf_sample_data * data , struct pt_regs * regs ) {",5422
1874,"assert_true_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" ,  NULL ) ;","assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;",5423
1875,"assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" ,  NULL ) ;","assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""foo\\\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""bar\\\\"")<S2SV_blank>==<S2SV_blank>-1\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\\\""FOO\\\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\\\""FOO\\\\\\\"" , NULL ) ;",5423
1876,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;",5424
1877,"u64 start = offset >> PAGE_CACHE_SHIFT ;unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ;u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ;pgoff_t curr ;struct page * page ;unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ;unsigned int from , to ;if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ;if ( unlikely ( error ) ) goto out ;curr = start ;offset = start << PAGE_CACHE_SHIFT ;from = start_offset ;to = PAGE_CACHE_SIZE ;while ( curr <= end ) {page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ;if ( unlikely ( ! page ) ) {error = - ENOMEM ;if ( curr == end ) to = end_offset ;error = write_empty_blocks ( page , from , to , mode ) ;if ( ! error && offset + to > inode -> i_size &&  ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {i_size_write ( inode , offset + to ) ;}","unsigned int nr_blks ;sector_t lblock = offset >> inode -> i_blkbits ;if ( unlikely ( error ) ) return error ;while ( len ) {struct buffer_head bh_map = {. b_state = 0 , . b_blocknr = 0 };bh_map . b_size = len ;set_buffer_zeronew ( & bh_map ) ;error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ;if ( unlikely ( error ) ) goto out ;len -= bh_map . b_size ;nr_blks = bh_map . b_size >> inode -> i_blkbits ;lblock += nr_blks ;if ( ! buffer_new ( & bh_map ) ) continue ;if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) {error = - EIO ;}if ( offset + len > inode -> i_size && ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {i_size_write ( inode , offset + to ) ;}",5425
1878,mark_inode_dirty ( inode ) ;brelse ( dibh ) ;out :  return error ;},mark_inode_dirty ( inode ) ;brelse ( dibh ) ;out : brelse ( dibh ) ;return error ;},5425
1879,"case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ssid . length != 0 ) {if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;if ( length < ssid . length ) return 0 ;memcpy ( & ssid . ssid , p + offset , ssid . length ) ;offset += ssid . length ;length -= ssid . length ;}ssid . ssid [ ssid . length ] = '\\\\0' ;if ( ! pbody -> ssid_present ) {pbody -> ssid = ssid ;pbody -> ssid_present = 1 ;}break ;case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( challenge . length != 0 ) {if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ;if ( length < challenge . length ) return 0 ;memcpy ( & challenge . text , p + offset , challenge . length ) ;offset += challenge . length ;length -= challenge . length ;}challenge . text [ challenge . length ] = '\\\\0' ;if ( ! pbody -> challenge_present ) {pbody -> challenge = challenge ;pbody -> challenge_present = 1 ;}break ;case E_RATES : memcpy ( & rates , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( rates . length != 0 ) {if ( rates . length > sizeof rates . rate ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ;if ( length < rates . length ) return 0 ;memcpy ( & rates . rate , p + offset , rates . length ) ;offset += rates . length ;length -= rates . length ;}if ( ! pbody -> rates_present && rates . length != 0 ) {pbody -> rates = rates ;pbody -> rates_present = 1 ;}break ;case E_DS : memcpy ( & ds , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ds . length != 1 ) {offset += ds . length ;length -= ds . length ;break ;}ds . channel = * ( p + offset ) ;offset += 1 ;length -= 1 ;if ( ! pbody -> ds_present ) {pbody -> ds = ds ;pbody -> ds_present = 1 ;}break ;case E_CF : memcpy ( & cf , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( cf . length != 6 ) {offset += cf . length ;length -= cf . length ;break ;}memcpy ( & cf . count , p + offset , 6 ) ;offset += 6 ;length -= 6 ;if ( ! pbody -> cf_present ) {pbody -> cf = cf ;pbody -> cf_present = 1 ;}break ;case E_TIM : memcpy ( & tim , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( tim . length <= 3 ) {","case E_SSID : memcpy ( & ssid , p + offset + 3 , tim . length <= 3 ) {",5426
1880,"memcpy ( tim . bitmap , p + ( tim . length - 3 ) ,   ( tim . length - 3 ) ) ;offset += tim . length - 3 ;length -= tim . length - 3 ;if ( ! pbody -> tim_present ) {","memcpy ( tim . bitmap , p + ( tim . length - 3 ) , ( tim . length - 3 ) ) ;offset += tim . length - 3 ;length -= tim . length - 3 ;if ( ! pbody -> tim_present ) {",5426
1881,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ;",5427
1882,"namespace_lock ( ) ;tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ;","namespace_lock ( ) ;if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ;else tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ;",5428
1883,"if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;","memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteOlympusEntry ) ) ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;",5429
1884,struct desc_struct * desc ;unsigned long limit ;if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ;desc = get_desc ( sel ) ;if ( ! desc )  return 0 ;limit = get_desc_limit ( desc ) ;if ( desc -> g )  limit = ( limit << 12 ) + 0xfff ;,struct desc_struct desc ;unsigned long limit ;desc = get_desc ( sel ) ;if ( ! desc ) return 0 ;limit = get_desc_limit ( & desc ) ;if ( desc . g ) limit = ( limit << 12 ) + 0xfff ;,5430
1885,"struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ;","struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ;",5431
1886,"if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer ,  & bufferoffset ,  i , t2p -> tiff_length ) ) {","if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , t2p -> tiff_datasize , & bufferoffset , i , t2p -> tiff_length ) ) {",5432
1887,"
",if ( l == NULL ) break ;,5433
1888,"if ( rows > 1 ) {pos = columnPos ( l , col ) ;","if ( rows > 1 ) {pos = columnPos ( l , col ) ;",5433
1889,"static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) {vp9_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ;if ( cm -> tx_mode >= ALLOW_32X32 )  vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ;if ( cm -> tx_mode == TX_MODE_SELECT ) {","static void encode_txfm_probs ( VP9_COMMON * cm , vpx_writer * w , FRAME_COUNTS * counts ) {vpx_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ;if ( cm -> tx_mode >= ALLOW_32X32 ) vpx_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ;if ( cm -> tx_mode == TX_MODE_SELECT ) {",5434
1890,"tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ;for ( j = 0 ;j ++ )  vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ;}tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ;for ( j = 0 ;j ++ )  vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] ,  ct_16x16p [ j ] ) ;tx_counts_to_branch_counts_32x32 ( cm -> counts . tx . p32x32 [ i ] , ct_32x32p ) ;for ( j = 0 ;j ++ )  vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p32x32 [ i ] [ j ] ,  ct_32x32p [ j ] ) ;","tx_counts_to_branch_counts_8x8 ( counts -> tx . p8x8 [ i ] , ct_8x8p ) ;for ( j = 0 ;j ++ ) vp9_cond_prob_diff_update ( w , & cm -> fc -> tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ;}tx_counts_to_branch_counts_16x16 ( counts -> tx . p16x16 [ i ] , ct_16x16p ) ;for ( j = 0 ;j ++ ) vp9_cond_prob_diff_update ( w , & cm -> fc -> tx_probs . p16x16 [ i ] [ j ] , ct_16x16p [ j ] ) ;tx_counts_to_branch_counts_32x32 ( counts -> tx . p32x32 [ i ] , ct_32x32p ) ;for ( j = 0 ;j ++ ) vp9_cond_prob_diff_update ( w , & cm -> fc -> tx_probs . p32x32 [ i ] [ j ] , ct_32x32p [ j ] ) ;",5434
1891,"int len , err = - ENOBUFS ;int alloc_min_size ;","struct module * module ;int len , err = - ENOBUFS ;int alloc_min_size ;",5435
1892,mutex_unlock ( nlk -> cb_mutex ) ;module_put ( cb -> module ) ;consume_skb ( cb -> skb ) ;return 0 ;,module = cb -> module ;skb = cb -> skb ;mutex_unlock ( nlk -> cb_mutex ) ;module_put ( module ) ;consume_skb ( cb -> skb ) ;return 0 ;,5435
1893,assert ( n >= 0 && n < 32 ) ;v = 0 ;,if ( n < 0 || n >= 32 ) {return - 1 ;}v = 0 ;,5436
1894,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,5437
1895,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",5437
1896,DEFINE_WAKE_Q ( wake_q ) ;if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ;,DEFINE_WAKE_Q ( wake_q ) ;if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL ;if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ;,5438
1897,"if ( n <= 0 ) return ( n ) ;if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) {s -> packet_length = 0 ;goto again ;}s -> rstate = SSL_ST_READ_BODY ;p = s -> packet ;if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ;rr -> type = * ( p ++ ) ;ssl_major = * ( p ++ ) ;ssl_minor = * ( p ++ ) ;version = ( ssl_major << 8 ) | ssl_minor ;n2s ( p , rr -> epoch ) ;memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ;p += 6 ;n2s ( p , rr -> length ) ;if ( ! s -> first_packet ) {if ( version != s -> version ) {rr -> length = 0 ;s -> packet_length = 0 ;goto again ;}}if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) {rr -> length = 0 ;s -> packet_length = 0 ;goto again ;}if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) {rr -> length = 0 ;s -> packet_length = 0 ;goto again ;}}if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) {i = rr -> length ;n = ssl3_read_n ( s , i , i , 1 ) ;if ( n <= 0 ) return ( n ) ;if ( n != i ) {",if ( n != i ) {,5439
1898,"if ( ! setup_stratum_curl ( pool ) ) goto out ;resend : if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) {",if ( n2size < 1 ) {,5440
1899,"if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;","if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;",5440
1900,next_character ( ) ;},recovery_started = true ;next_character ( ) ;},5441
1901,"kvm_for_each_memslot ( memslot , slots )  kvm_iommu_put_pages ( kvm , memslot -> base_gfn , memslot -> npages ) ;srcu_read_unlock ( & kvm -> srcu , idx ) ;","kvm_for_each_memslot ( memslot , slots ) kvm_iommu_unmap_pages ( kvm , memslot -> base_gfn , memslot -> npages ) ;srcu_read_unlock ( & kvm -> srcu , idx ) ;",5442
1902,"INTERNAL void vterm_allocator_free ( VTerm * vt , void * ptr )  {( * vt -> allocator -> free ) ( ptr , vt -> allocdata ) ;","INTERNAL void vterm_allocator_free ( VTerm * vt , void * ptr ) {if ( ptr ) ( * vt -> allocator -> free ) ( ptr , vt -> allocdata ) ;",5443
1903,for ( p = 0 ;p < 4 && in -> data [ p ] ;int w = inlink -> w ;,for ( p = 0 ;p < 4 && in -> data [ p ] && in -> linesize [ p ] ;int w = inlink -> w ;,5444
1904,"fprintf ( stderr , ""usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\\","fprintf ( stderr , ""usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\\",5445
1905,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,5446
1906,"strlcpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;","strncpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;",5447
1907,"u_int16_t offset = 22 , buf_out_len = 0 ;if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;","u_int32_t offset = 22 , buf_out_len = 0 ;if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;if ( len > UINT32_MAX - 4 - offset ) goto invalid_payload ;",5448
1908,offset += 4 + len ;if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;if ( client_hash ) {offset += 4 ;if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;offset += len ;}else offset += 4 + len ;if ( ! client_hash ) {offset += 4 ;if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;offset += len ;}else offset += 4 + len ;if ( client_hash ) {offset += 4 ;if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;offset += len ;}else offset += 4 + len ;if ( ! client_hash ) {offset += 4 ;if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;offset += len ;}else offset += 4 + len ;if ( client_hash ) {offset += 4 ;if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;offset += len ;}else offset += 4 + len ;if ( ! client_hash ) {offset += 4 ;if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;offset += len ;}else offset += 4 + len ;,offset += 4 ;offset += 4 + len ;if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;if ( client_hash ) {if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;}if ( len > UINT32_MAX - offset ) goto invalid_payload ;offset += len ;offset += 4 ;if ( ! client_hash ) {if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;}if ( len > UINT32_MAX - offset ) goto invalid_payload ;offset += len ;offset += 4 ;if ( client_hash ) {if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;}if ( len > UINT32_MAX - offset ) goto invalid_payload ;offset += len ;offset += 4 ;if ( ! client_hash ) {if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;}if ( len > UINT32_MAX - offset ) goto invalid_payload ;offset += len ;offset += 4 ;if ( client_hash ) {if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;}if ( len > UINT32_MAX - offset ) goto invalid_payload ;offset += len ;offset += 4 ;if ( ! client_hash ) {if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ;}if ( len > UINT32_MAX - offset ) goto invalid_payload ;offset += len ;,5448
1909,"pipe_buf_get ( ipipe , ibuf ) ;obuf = opipe -> bufs + nbuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}obuf = opipe -> bufs + nbuf ;",5449
1910,"struct snd_timer_user * tu ;void __user * argp = ( void __user * ) arg ;int __user * p = argp ;tu = file -> private_data ;switch ( cmd ) {case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ;mutex_lock ( & tu -> tread_sem ) ;if ( tu -> timeri ) {return - EBUSY ;}if ( get_user ( xarg , p ) ) {mutex_unlock ( & tu -> tread_sem ) ;return - EFAULT ;}tu -> tread = xarg ? 1 : 0 ;mutex_unlock ( & tu -> tread_sem ) ;return 0 ;}case SNDRV_TIMER_IOCTL_GINFO : return snd_timer_user_ginfo ( file , argp ) ;case SNDRV_TIMER_IOCTL_GPARAMS : return snd_timer_user_gparams ( file , argp ) ;case SNDRV_TIMER_IOCTL_GSTATUS : return snd_timer_user_gstatus ( file , argp ) ;case SNDRV_TIMER_IOCTL_SELECT : return snd_timer_user_tselect ( file , argp ) ;case SNDRV_TIMER_IOCTL_INFO : return snd_timer_user_info ( file , argp ) ;case SNDRV_TIMER_IOCTL_PARAMS : return snd_timer_user_params ( file , argp ) ;case SNDRV_TIMER_IOCTL_STATUS : return snd_timer_user_status ( file , argp ) ;case SNDRV_TIMER_IOCTL_START : case SNDRV_TIMER_IOCTL_START_OLD : return snd_timer_user_start ( file ) ;case SNDRV_TIMER_IOCTL_STOP : case SNDRV_TIMER_IOCTL_STOP_OLD : return snd_timer_user_stop ( file ) ;case SNDRV_TIMER_IOCTL_CONTINUE : case SNDRV_TIMER_IOCTL_CONTINUE_OLD : return snd_timer_user_continue ( file ) ;case SNDRV_TIMER_IOCTL_PAUSE : case SNDRV_TIMER_IOCTL_PAUSE_OLD : return snd_timer_user_pause ( file ) ;}return - ENOTTY ;","struct snd_timer_user * tu = file -> private_data ;switch ( cmd ) {case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ;mutex_lock ( & tu -> ioctl_lock ) ;ret = __snd_timer_user_ioctl ( file , cmd , arg ) ;return ret ;",5450
1911,if ( p -> io_context )  ret = p -> io_context -> ioprio ;out :  return ret ;,task_lock ( p ) ;if ( p -> io_context ) ret = p -> io_context -> ioprio ;task_unlock ( p ) ;out : return ret ;,5451
1912,},"signal_add ( ""server<S2SV_blank>disconnected"" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;}",5452
1913,"uint32x2_t d28u32 , d29u32 , d30u32 ;uint8x16_t q1u8 , q2u8 ;","uint8x16_t q1u8 , q2u8 ;uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ;uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ;uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ;",5453
1914,"d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ;d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ;q4u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q1u8 ) , 8 ) ;","d0u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 0 ] ) ;d1u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 1 ] ) ;q4u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q1u8 ) , 8 ) ;",5453
1915,"
","baud = min ( baud , 461550 ) ;{",5454
1916,"}else   tty_encode_baud_rate ( tty , baud , baud ) ;edge_port -> baud_rate = baud ;","}else tty_encode_baud_rate ( tty , baud , baud ) ;}edge_port -> baud_rate = baud ;",5454
1917,"struct timespec ts ;if ( ! nsec ) return ( struct timespec ) {ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ;if ( unlikely ( nsec < 0 ) )   set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ;return ts ;","struct timespec ts ;s32 rem ;if ( ! nsec ) return ( struct timespec ) {ts . tv_sec = div_s64_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( unlikely ( nsec < 0 ) ) {ts . tv_sec , ts . tv_nsec ) ;return ts ;",5455
1918,"void Huff_transmit ( huff_t * huff , int ch , byte * fout ) {int i ;Huff_transmit ( huff , NYT , fout ) ;for ( i = 7 ;send ( huff -> loc [ ch ] , NULL , fout ) ;}","void Huff_transmit ( huff_t * huff , int ch , byte * fout , int maxoffset ) {int i ;Huff_transmit ( huff , NYT , fout , maxoffset ) ;for ( i = 7 ;send ( huff -> loc [ ch ] , NULL , fout , maxoffset ) ;}",5456
1919,long timeo ;lock_sock ( sk ) ;,long timeo ;msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,5457
1920,"int bytes_returned , name_len ;__u16 params , byte_count ;","int bytes_returned ;unsigned int name_len ;__u16 params , byte_count ;",5458
1921,}read_lock ( & tasklist_lock ) ;,}if ( pid == INT_MIN ) return - ESRCH ;read_lock ( & tasklist_lock ) ;,5459
1922,int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ;if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ;,uint32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ;if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ;,5460
1923,return res ;},Util_getToken ( res -> token ) ;return res ;},5461
1924,"static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_MODE tx_mode ,   BLOCK_SIZE bsize , int allow_select , vp9_reader * r ) {const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ;","static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , int allow_select , vp9_reader * r ) {TX_MODE tx_mode = cm -> tx_mode ;BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ;",5462
1925,atomic_inc ( & sb -> s_active ) ;mnt -> mnt . mnt_sb = sb ;,if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;atomic_inc ( & sb -> s_active ) ;mnt -> mnt . mnt_sb = sb ;,5463
1926,"FILE * ip ;const char * oldFile = File ;# if ! ( defined ( WIN32 ) || defined ( cygwin ) )  char * token ;char space ;char newline ;struct stat dir_stat , idx_stat ;char tmpstr [ 300 ] ;char tmpstr1 [ 300 ] ;# endif DEBUGMSGTL ( ( ""parse-mibs"" , ""Scanning<S2SV_blank>directory<S2SV_blank>%s\\\# if ! ( defined ( WIN32 ) || defined ( cygwin ) )  token = netsnmp_mibindex_lookup ( dirname ) ;if ( ( ip = fopen ( token , ""r"" ) ) != NULL ) {fgets ( tmpstr , sizeof ( tmpstr ) , ip ) ;while ( fscanf ( ip , ""%127s%c%299[^\\\if ( space != \'<S2SV_blank>\' || newline != \'\\\snmp_log ( LOG_ERR , ""add_mibdir:<S2SV_blank>strings<S2SV_blank>scanned<S2SV_blank>in<S2SV_blank>from<S2SV_blank>%s/%s<S2SV_blank>"" ""are<S2SV_blank>too<S2SV_blank>large.<S2SV_blank><S2SV_blank>count<S2SV_blank>=<S2SV_blank>%d\\\break ;}snprintf ( tmpstr1 , sizeof ( tmpstr1 ) , ""%s/%s"" , dirname , tmpstr ) ;tmpstr1 [ sizeof ( tmpstr1 ) - 1 ] = 0 ;new_module ( token , tmpstr1 ) ;count ++ ;}fclose ( ip ) ;return count ;}else DEBUGMSGTL ( ( ""parse-mibs"" , ""Can\\\'t<S2SV_blank>read<S2SV_blank>index\\\}else DEBUGMSGTL ( ( ""parse-mibs"" , ""Index<S2SV_blank>outdated\\\}else DEBUGMSGTL ( ( ""parse-mibs"" , ""No<S2SV_blank>index\\\# endif filename_count = scan_directory ( & filenames , dirname ) ;ip = netsnmp_mibindex_new ( dirname ) ;for ( i = 0 ;if ( add_mibfile ( filenames [ i ] , strrchr ( filenames [ i ] , \'/\' ) , ip ) == 0 )  count ++ ;File = oldFile ;if ( ip ) fclose ( ip ) ;","const char * oldFile = File ;DEBUGMSGTL ( ( ""parse-mibs"" , ""Scanning<S2SV_blank>directory<S2SV_blank>%s\\\# if ! ( defined ( WIN32 ) || defined ( cygwin ) ) token = netsnmp_mibindex_lookup ( dirname ) ;filename_count = scan_directory ( & filenames , dirname ) ;ip = netsnmp_mibindex_new ( dirname ) ;for ( i = 0 ;if ( add_mibfile ( filenames [ i ] , strrchr ( filenames [ i ] , \'/\' ) , ip ) == 0 ) count ++ ;File = oldFile ;if ( ip ) fclose ( ip ) ;",5464
1927,int just_opened = 0 ;restart : if ( ! v -> needed ) return AVERROR_EOF ;,int just_opened = 0 ;int reload_count = 0 ;restart : if ( ! v -> needed ) return AVERROR_EOF ;,5465
1928,reload :  if ( ! v -> finished &&  av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) {,reload : reload_count ++ ;if ( reload_count > c -> max_reload ) return AVERROR_EOF ;if ( ! v -> finished && av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) {,5465
1929,"int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ;bool grab_newname = false ;fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , getpid ( ) ) ;return - 1 ;}fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , pid ) ;return - 1 ;}if ( setns ( fd , 0 ) < 0 ) {fprintf ( stderr , ""setns<S2SV_blank>to<S2SV_blank>container<S2SV_blank>network<S2SV_blank>namespace\\\goto out_err ;}close ( fd ) ;if ( ! * newnamep ) {if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) {fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index\\\goto out_err ;if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) {fprintf ( stderr , ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container\\\goto out_err ;char ifname [ IFNAMSIZ ] , * namep = ifname ;if ( ! if_indextoname ( ifindex , namep ) ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\\goto out_err ;if ( ! * newnamep )  goto out_err ;}if ( setns ( ofd , 0 ) < 0 ) {fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>netns\\\close ( ofd ) ;return - 1 ;}return 0 ;out_err : if ( ofd >= 0 ) close ( ofd ) ;if ( setns ( ofd , 0 ) < 0 ) fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace\\\if ( fd >= 0 ) close ( fd ) ;return - 1 ;","uid_t ruid , suid , euid ;int fret = - 1 ;int fd = - 1 , ifindex = - 1 , ofd = - 1 , ret ;bool grab_newname = false ;usernic_error ( ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , getpid ( ) ) ;return fret ;}usernic_error ( ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , pid ) ;return - 1 ;}if ( setns ( fd , CLONE_NEWNET ) ;close ( fd ) ;if ( ! * newnamep ) {if ( ! ifindex ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\\goto do_full_cleanup ;ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ;if ( ret < 0 ) {usernic_error ( ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\\goto do_full_cleanup ;char ifname [ IFNAMSIZ ] , * namep = ifname ;if ( ! if_indextoname ( ifindex , namep ) ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\\goto do_full_cleanup ;if ( ! * newnamep ) goto do_full_cleanup ;}fret = 0 ;do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ;if ( ret < 0 ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\\fret = - 1 ;}ret = setns ( ofd , CLONE_NEWNET ) ;if ( ret < 0 ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>"" ""of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\\fret = - 1 ;}do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ;return fret ;",5466
1930,"i ++ )  NLSF_Q15 [ i ] = silk_max_int ( NLSF_Q15 [ i ] , NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ;NLSF_Q15 [ L - 1 ] = silk_min_int ( NLSF_Q15 [ L - 1 ] , ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ) ;","i ++ ) NLSF_Q15 [ i ] = silk_max_int ( NLSF_Q15 [ i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) ) ;NLSF_Q15 [ L - 1 ] = silk_min_int ( NLSF_Q15 [ L - 1 ] , ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ) ;",5467
1931,"vpx_memset ( input , 0 , 32 ) ;}","memset ( input , 0 , 32 ) ;}",5468
1932,"enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ;status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ;if ( ( status & EIR_LINKIF ) != 0 )  {enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE ) ;interface -> nicEvent = TRUE ;if ( ( status & EIR_PKTIF ) != 0 )  {enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_PKTIE ) ;interface -> nicEvent = TRUE ;if ( ( status & ( EIR_TXIF | EIR_TXABTIF ) ) != 0 )  {enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ;flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ;enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ;return flag ;","enc624j600ClearBit ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE ) ;status = enc624j600ReadReg ( interface , ENC624J600_EIR ) ;if ( ( status & ENC624J600_EIR_LINKIF ) != 0 ) {enc624j600ClearBit ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE ) ;interface -> nicEvent = TRUE ;if ( ( status & ENC624J600_EIR_PKTIF ) != 0 ) {enc624j600ClearBit ( interface , ENC624J600_EIE , ENC624J600_EIE_PKTIE ) ;interface -> nicEvent = TRUE ;if ( ( status & ( ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF ) ) != 0 ) {enc624j600ClearBit ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF ) ;flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ;enc624j600SetBit ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE ) ;return flag ;",5469
1933,"if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 )  {close ( fd ) ;return HSM_COM_PATH_ERR ;unlink ( hdl -> c_path ) ;close ( fd ) ;return HSM_COM_BIND_ERR ;unlink ( hdl -> c_path ) ;close ( fd ) ;return HSM_COM_CHMOD_ERR ;","hsm_com_errno_t res = HSM_COM_OK ;if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) {res = HSM_COM_PATH_ERR ;goto cleanup ;res = HSM_COM_BIND_ERR ;goto cleanup ;res = HSM_COM_CHMOD_ERR ;goto cleanup ;",5470
1934,unlink ( hdl -> c_path ) ;close ( fd ) ;return HSM_COM_CONX_ERR ;return HSM_COM_SEND_ERR ;}return HSM_COM_OK ;,res = HSM_COM_CONX_ERR ;goto cleanup ;res = HSM_COM_SEND_ERR ;}return res ;cleanup : close ( fd ) ;return res ;,5470
1935,"opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ;sk_dst_reset ( sk ) ;","opt = xchg ( ( __force struct ipv6_txoptions * * ) & inet6_sk ( sk ) -> opt , opt ) ;sk_dst_reset ( sk ) ;",5471
1936,if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f ||  s -> cur_pic . field_picture ||  s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ;,if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture ) return 0 ;,5472
1937,"char build [ ATUSB_BUILD_SIZE + 1 ] ;int ret ;ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ;return ret ;}","char * build ;int ret ;build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ;if ( ! build ) return - ENOMEM ;ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ;kfree ( build ) ;return ret ;}",5473
1938,"if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) {pte_unmap_unlock ( ptep , ptl ) ;","if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) {pte_unmap_unlock ( ptep , ptl ) ;",5474
1939,void *  xmalloc ( size_t size )   {void * ptr = malloc ( size ) ;if ( ! ptr && ( size != 0 ) ) {,"void * xmalloc ( size_t num , size_t size ) {size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;void * ptr = malloc ( res ) ;if ( ! ptr && ( size != 0 ) ) {",5475
1940,"long mtemp , save_adjust , rem ;s64 freq_adj ;","long mtemp , save_adjust ;s64 freq_adj ;",5476
1941,"time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ;","time_offset = div_s64 ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ;",5476
1942,"time_offset = div_long_long_rem_signed ( time_offset ,   NTP_INTERVAL_FREQ ,  & rem ) ;","time_offset = div_long_long_rem_signed ( time_offset , NTP_INTERVAL_FREQ ) ;",5476
1943,"# ifdef CONFIG_SMP  s -> s_files = alloc_percpu ( struct list_head ) ;if ( ! s -> s_files ) goto fail ;for_each_possible_cpu ( i )  INIT_LIST_HEAD ( per_cpu_ptr ( s -> s_files , i ) ) ;# else INIT_LIST_HEAD ( & s -> s_files ) ;# endif for ( i = 0 ;lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] ,  & type -> s_writers_key [ i ] , 0 ) ;","for ( i = 0 ;lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ;",5477
1944,if ( list_lru_init ( & s -> s_dentry_lru ) )  goto fail ;if ( list_lru_init ( & s -> s_inode_lru ) )  goto fail ;,if ( list_lru_init ( & s -> s_dentry_lru ) ) goto fail ;if ( list_lru_init ( & s -> s_dentry_lru ) ) goto fail ;if ( list_lru_init ( & s -> s_inode_lru ) ) goto fail ;,5477
1945,"if ( log_fp )  return log_fp ;log_fp = fopen ( log_file , ""a+"" ) ;if ( daemon_mode == FALSE ) {printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>for<S2SV_blank>writing\\\}return NULL ;","int fh ;struct stat st ;if ( log_fp ) return log_fp ;if ( ( fh = open ( log_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) {if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>for<S2SV_blank>writing\\\return NULL ;}if ( ( fstat ( fh , & st ) ) == - 1 ) {log_fp = NULL ;close ( fh ) ;if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>fstat<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\\\'%s\\\'\\\return NULL ;}if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) {log_fp = NULL ;close ( fh ) ;if ( daemon_mode == FALSE ) printf ( ""Warning:<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>mode\\\return NULL ;}log_fp = fdopen ( fh , ""a+"" ) ;if ( daemon_mode == FALSE ) {printf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>for<S2SV_blank>writing\\\}return NULL ;",5478
1946,"if ( strcmp ( f -> file , ""tasks"" ) == 0 || strcmp ( f -> file , ""/tasks"" ) == 0 || strcmp ( f -> file , ""/cgroup.procs"" ) == 0 || strcmp ( f -> file , ""cgroup.procs"" ) == 0 )  r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ;else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ;","if ( strcmp ( f -> file , ""tasks"" ) == 0 || strcmp ( f -> file , ""/tasks"" ) == 0 || strcmp ( f -> file , ""/cgroup.procs"" ) == 0 || strcmp ( f -> file , ""cgroup.procs"" ) == 0 ) r = do_write_pids ( fc -> pid , fc -> uid , f -> controller , f -> cgroup , f -> file , localbuf ) ;else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ;",5479
1947,if ( sec_attr == NULL ) {if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ;,if ( sec_attr == NULL || sec_attr_len ) {if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ;,5480
1948,"pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ;if ( ! pop3c -> mailbox )  return CURLE_OUT_OF_MEMORY ;return CURLE_OK ;","return Curl_urldecode ( data , path , 0 , NULL ) ;if ( ! pop3c -> mailbox , NULL , TRUE ) ;",5481
1949,sock_put ( sk ) ;isk -> inet_num = 0 ;,sk_nulls_node_init ( & sk -> sk_nulls_node ) ;sock_put ( sk ) ;isk -> inet_num = 0 ;,5482
1950,"print_fmt ( ""codec_tag"" , ""0x%04"" PRIx32 , par -> codec_tag ) ;switch ( par -> codec_type ) {case AVMEDIA_TYPE_VIDEO : print_int ( ""width"" , par -> width ) ;print_int ( ""height"" , par -> height ) ;if ( dec_ctx ) {print_int ( ""coded_width"" , dec_ctx -> coded_width ) ;print_int ( ""coded_height"" , dec_ctx -> coded_height ) ;}print_int ( ""has_b_frames"" , par -> video_delay ) ;sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ;if ( sar . den ) {print_q ( ""sample_aspect_ratio"" , sar , \':\' ) ;av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ;print_q ( ""display_aspect_ratio"" , dar , \':\' ) ;}else {print_str_opt ( ""sample_aspect_ratio"" , ""N/A"" ) ;print_str_opt ( ""display_aspect_ratio"" , ""N/A"" ) ;}s = av_get_pix_fmt_name ( par -> format ) ;if ( s ) print_str ( ""pix_fmt"" , s ) ;else print_str_opt ( ""pix_fmt"" , ""unknown"" ) ;print_int ( ""level"" , par -> level ) ;if ( par -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( par -> color_range ) ) ;else print_str_opt ( ""color_range"" , ""N/A"" ) ;if ( par -> color_space != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ;else print_str_opt ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ;if ( par -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ;else print_str_opt ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ;if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED )  print_str ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ;","print_primaries ( w , par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) print_str ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ;",5483
1951,if ( p -> io_context )  ret = p -> io_context -> ioprio ;out :  return ret ;,task_lock ( p ) ;if ( p -> io_context ) ret = p -> io_context -> ioprio ;task_unlock ( p ) ;out : return ret ;,5484
1952,"monitor_sync ( pmonitor ) ;while ( waitpid ( pid , & status , 0 ) < 0 ) {","while ( waitpid ( pid , & status , 0 ) < 0 ) {",5485
1953,"void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf )  {get_page ( buf -> page ) ;}","bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {return try_get_page ( buf -> page ) ;}",5486
1954,"r_cons_printf ( ""["" ) ;}else if ( IS_MODE_SET ( mode ) ) {r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ;}else if ( ! at && exponly ) {if ( IS_MODE_RAD ( mode ) ) {r_cons_printf ( ""fs<S2SV_blank>exports\\\}else if ( IS_MODE_NORMAL ( mode ) ) {r_cons_printf ( printHere ? """" : ""[Exports]\\\}}else if ( ! at && ! exponly ) {if ( IS_MODE_RAD ( mode ) ) {r_cons_printf ( ""fs<S2SV_blank>symbols\\\}else if ( IS_MODE_NORMAL ( mode ) ) {r_cons_printf ( printHere ? """" : ""[Symbols]\\\}}if ( IS_MODE_NORMAL ( mode ) ) {r_cons_printf ( ""Num<S2SV_blank>Paddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vaddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Bind<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Size<S2SV_blank>Name\\\}size_t count = 0 ;r_list_foreach ( symbols , iter , symbol ) {if ( ! symbol -> name ) {continue ;}char * r_symbol_name = r_str_escape_utf8 ( symbol -> name , false , true ) ;ut64 addr = compute_addr ( r -> bin , symbol -> paddr , symbol -> vaddr , va ) ;int len = symbol -> size ? symbol -> size : 32 ;SymName sn = {0 };if ( exponly && ! isAnExport ( symbol ) ) {free ( r_symbol_name ) ;continue ;}if ( name && strcmp ( r_symbol_name , name ) ) {free ( r_symbol_name ) ;continue ;}if ( at && ( ! symbol -> size || ! is_in_range ( at , addr , symbol -> size ) ) ) {free ( r_symbol_name ) ;continue ;}if ( ( printHere && ! is_in_range ( r -> offset , symbol -> paddr , len ) ) && ( printHere && ! is_in_range ( r -> offset , addr , len ) ) ) {free ( r_symbol_name ) ;continue ;}count ++ ;snInit ( r , & sn , symbol , lang ) ;if ( IS_MODE_SET ( mode ) && ( is_section_symbol ( symbol ) || is_file_symbol ( symbol ) ) ) {}else if ( IS_MODE_SET ( mode ) && is_special_symbol ( symbol ) ) {if ( is_arm ) {handle_arm_special_symbol ( r , symbol , va ) ;}}else if ( IS_MODE_SET ( mode ) ) {if ( is_arm ) {handle_arm_symbol ( r , symbol , info , va ) ;}select_flag_space ( r , symbol ) ;if ( sn . classname ) {RFlagItem * fi = r_flag_get ( r -> flags , sn . methflag ) ;if ( r -> bin -> prefix ) {char * prname = r_str_newf ( ""%s.%s"" , r -> bin -> prefix , sn . methflag ) ;r_name_filter ( sn . methflag , - 1 ) ;free ( sn . methflag ) ;sn . methflag = prname ;}if ( fi ) {r_flag_item_set_realname ( fi , sn . methname ) ;if ( ( fi -> offset - r -> flags -> base ) == addr ) {r_flag_unset ( r -> flags , fi ) ;}}else {fi = r_flag_set ( r -> flags , sn . methflag , addr , symbol -> size ) ;char * comment = fi -> comment ? strdup ( fi -> comment ) : NULL ;if ( comment ) {r_flag_item_set_comment ( fi , comment ) ;R_FREE ( comment ) ;}}}else {const char * n = sn . demname ? sn . demname : sn . name ;const char * fn = sn . demflag ? sn . demflag : sn . nameflag ;char * fnp = ( r -> bin -> prefix ) ? r_str_newf ( ""%s.%s"" , r -> bin -> prefix , fn ) : strdup ( fn ) ;RFlagItem * fi = r_flag_set ( r -> flags , fnp , addr , symbol -> size ) ;if ( fi ) {r_flag_item_set_realname ( fi , n ) ;fi -> demangled = ( bool ) ( size_t ) sn . demname ;}else {if ( fn ) {eprintf ( ""[Warning]<S2SV_blank>Can\\\'t<S2SV_blank>find<S2SV_blank>flag<S2SV_blank>(%s)\\\}}free ( fnp ) ;}if ( sn . demname ) {r_meta_add ( r -> anal , R_META_TYPE_COMMENT , addr , symbol -> size , sn . demname ) ;}r_flag_space_pop ( r -> flags ) ;}else if ( IS_MODE_JSON ( mode ) ) {char * str = r_str_escape_utf8_for_json ( r_symbol_name , - 1 ) ;r_cons_printf ( ""%s{\\\\""name\\\\"":\\\\""%s\\\\"","" ""\\\\""demname\\\\"":\\\\""%s\\\\"","" ""\\\\""flagname\\\\"":\\\\""%s\\\\"","" ""\\\\""ordinal\\\\"":%d,"" ""\\\\""bind\\\\"":\\\\""%s\\\\"","" ""\\\\""size\\\\"":%d,"" ""\\\\""type\\\\"":\\\\""%s\\\\"","" ""\\\\""vaddr\\\\"":%"" PFMT64d "","" ""\\\\""paddr\\\\"":%"" PFMT64d ""}"" , ( ( exponly && firstexp ) || printHere ) ? """" : ( iter -> p ? "","" : """" ) , str , sn . demname ? sn . demname : """" , sn . nameflag , symbol -> ordinal , symbol -> bind , ( int ) symbol -> size , symbol -> type , ( ut64 ) addr , ( ut64 ) symbol -> paddr ) ;free ( str ) ;}else if ( IS_MODE_SIMPLE ( mode ) ) {const char * name = sn . demname ? sn . demname : r_symbol_name ;r_cons_printf ( ""0x%08"" PFMT64x ""<S2SV_blank>%d<S2SV_blank>%s\\\}else if ( IS_MODE_SIMPLEST ( mode ) ) {const char * name = sn . demname ? sn . demname : r_symbol_name ;r_cons_printf ( ""%s\\\}else if ( IS_MODE_RAD ( mode ) ) {if ( is_special_symbol ( symbol ) ) {goto next ;}RBinFile * binfile ;RBinPlugin * plugin ;const char * name = sn . demname ? sn . demname : r_symbol_name ;if ( ! name ) {goto next ;}if ( ! strncmp ( name , ""imp."" , 4 ) ) {if ( lastfs != \'i\' ) {r_cons_printf ( ""fs<S2SV_blank>imports\\\}lastfs = \'i\' ;}else {if ( lastfs != \'s\' ) {const char * fs = exponly ? ""exports"" : ""symbols"" ;r_cons_printf ( ""fs<S2SV_blank>%s\\\}lastfs = \'s\' ;}if ( r -> bin -> prefix || * name ) {char * flagname = construct_symbol_flagname ( ""sym"" , name , MAXFLAG_LEN_DEFAULT ) ;if ( ! flagname ) {goto next ;}r_cons_printf ( ""\\\\""f<S2SV_blank>%s%s%s<S2SV_blank>%u<S2SV_blank>0x%08"" PFMT64x ""\\\\""\\\free ( flagname ) ;}binfile = r_bin_cur ( r -> bin ) ;plugin = r_bin_file_cur_plugin ( binfile ) ;if ( plugin && plugin -> name ) {if ( r_str_startswith ( plugin -> name , ""pe"" ) ) {char * module = strdup ( r_symbol_name ) ;char * p = strstr ( module , "".dll_"" ) ;if ( p && strstr ( module , ""imp."" ) ) {char * symname = __filterShell ( p + 5 ) ;char * m = __filterShell ( module ) ;* p = 0 ;if ( r -> bin -> prefix ) {r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\\r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s\\\","r_cons_printf ( ""\\\\""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\\\""\\\r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s\\\",5487
1955,"ALOGE ( ""b/26366256"" ) ;return ;","ALOGE ( ""b/26366256"" ) ;android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;return ;",5488
1956,"cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ;DPRINTF ( ( ""Chain:"" ) ) ;","cdf_secid_t maxsector = ( cdf_secid_t ) ( ( sat -> sat_len * size ) / sizeof ( maxsector ) ) ;DPRINTF ( ( ""Chain:"" ) ) ;",5489
1957,"if ( sid > maxsector ) {DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\\","if ( sid >= maxsector ) {DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\\",5489
1958,err :  aio_free_ring ( ctx ) ;free_percpu ( ctx -> cpu ) ;,err : free_percpu ( ctx -> cpu ) ;,5490
1959,"static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec ,  bool compat )  {return 0 ;}","static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec , bool compat , struct iov_iter * iter ) {iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;return 0 ;}",5491
1960,"
",len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ;,5492
1961,"if ( IS_NOT_NULL ( Else ) ) {len += SIZE_OP_JUMP ;tlen = compile_length_tree ( Else , reg ) ;","if ( IS_NOT_NULL ( Else ) ) {len += SIZE_OP_JUMP ;tlen = compile_length_tree ( Else , reg ) ;",5492
1962,"if ( vmx_set_msr ( vcpu , & msr ) != 0 ) {trace_kvm_msr_write_ex ( ecx , data ) ;","if ( kvm_set_msr ( vcpu , & msr ) != 0 ) {trace_kvm_msr_write_ex ( ecx , data ) ;",5493
1963,"
",mutt_socket_empty ( conn ) ;,5494
1964,rc = smtp_get_resp ( conn ) ;if ( rc != 0 ) return rc ;,rc = smtp_get_resp ( conn ) ;if ( rc != 0 ) return rc ;,5494
1965,"signal_remove ( ""message<S2SV_blank>quit"" , ( SIGNAL_FUNC ) msg_quit ) ;signal_remove ( ""message<S2SV_blank>join"" , ( SIGNAL_FUNC ) msg_join ) ;","signal_remove ( ""server<S2SV_blank>disconnected"" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;signal_remove ( ""message<S2SV_blank>quit"" , ( SIGNAL_FUNC ) msg_quit ) ;signal_remove ( ""message<S2SV_blank>join"" , ( SIGNAL_FUNC ) msg_join ) ;",5495
1966,"static int may_create_in_sticky ( struct dentry * const dir ,  struct inode * const inode ) {if ( ( ! sysctl_protected_fifos && S_ISFIFO ( inode -> i_mode ) ) || ( ! sysctl_protected_regular && S_ISREG ( inode -> i_mode ) ) ||  likely ( ! ( dir -> d_inode -> i_mode & S_ISVTX ) ) ||   uid_eq ( inode -> i_uid , dir -> d_inode -> i_uid ) ||  uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return 0 ;if ( likely ( dir -> d_inode -> i_mode & 0002 ) ||   ( dir -> d_inode -> i_mode & 0020 &&  ( ( sysctl_protected_fifos >= 2 && S_ISFIFO ( inode -> i_mode ) ) || ( sysctl_protected_regular >= 2 && S_ISREG ( inode -> i_mode ) ) ) ) ) {","static int may_create_in_sticky ( umode_t dir_mode , kuid_t dir_uid , struct inode * const inode ) {if ( ( ! sysctl_protected_fifos && S_ISFIFO ( inode -> i_mode ) ) || ( ! sysctl_protected_regular && S_ISREG ( inode -> i_mode ) ) || likely ( ! ( dir_mode & S_ISVTX ) ) || uid_eq ( inode -> i_uid , dir_uid ) || uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return 0 ;if ( likely ( dir_mode & 0002 ) || ( dir -> d_inode -> i_mode & 0020 && ( ( sysctl_protected_fifos >= 2 && S_ISFIFO ( inode -> i_mode ) ) || ( sysctl_protected_regular >= 2 && S_ISREG ( inode -> i_mode ) ) ) ) ) {",5496
1967,"static int  mptctl_fw_download ( unsigned long arg )  {return mptctl_do_fw_download ( kfwdl . iocnum , kfwdl . bufp , kfwdl . fwlen ) ;}","static int mptctl_fw_download ( MPT_ADAPTER * iocp , unsigned long arg ) {return mptctl_do_fw_download ( iocp , kfwdl . bufp , kfwdl . fwlen ) ;}",5497
1968,dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ;dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ;,dt -> proto = IP_GET_IPPROTO ( p ) ;dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ;dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ;,5498
1969,while ( collen > 0 )  {while ( replen > 0 )  {,while ( indexw < width && collen > 0 ) {while ( indexw < width && replen > 0 ) {,5499
1970,while ( collen > 0 )  {,while ( indexw < width && collen > 0 ) {,5499
1971,while ( replen > 0 )  {,while ( indexw < width && replen > 0 ) {,5499
1972,"void  pci_populate_msicap ( struct msicap * msicap , int msgnum , int nextptr ) {assert ( ( msgnum & ( msgnum - 1 ) ) == 0 && msgnum >= 1 && msgnum <= 32 ) ;mmc = ffs ( msgnum ) - 1 ;}","int pci_populate_msicap ( struct msicap * msicap , int msgnum , int nextptr ) {if ( ( ( msgnum & ( msgnum - 1 ) ) != 0 ) || msgnum < 1 || msgnum > 32 ) {pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>msi<S2SV_blank>messages!\\\return - 1 ;}mmc = ffs ( msgnum ) - 1 ;return 0 ;}",5500
1973,"memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ;if ( p -> fname ) {if ( priv -> ctrl . fname == NULL )  rc = - ENOMEM ;}","priv -> ctrl . fname = NULL ;memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ;if ( p -> fname ) {if ( priv -> ctrl . fname == NULL ) return - ENOMEM ;}",5501
1974,priv = hw -> priv ;priv -> hw = hw ;,"
",5502
1975,"ret = ca8210_get_platform_data ( priv -> spi , pdata ) ;if ( ret ) {ret = ca8210_dev_com_init ( priv ) ;if ( ret ) {","ret = ca8210_get_platform_data ( priv -> spi , pdata ) ;if ( ret ) {ret = ca8210_get_platform_data ( priv -> spi , pdata ) ;if ( ret ) {dev_crit ( & spi_device -> dev , ""ca8210_get_platform_data<S2SV_blank>failed\\\goto error ;}ret = ca8210_dev_com_init ( priv ) ;if ( ret ) {",5502
1976,"while ( offset < end_offset )  offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;return offset ;}","while ( offset > 0 && offset < end_offset ) {offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;}return offset ;}",5503
1977,"byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ;","byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_offset ] ) , size_copy ) ;",5504
1978,"
","if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) {libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ;goto on_error ;}if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) {libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ;goto on_error ;}",5504
1979,"
","if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) {libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ;goto on_error ;}",5504
1980,"if ( libfvalue_value_type_initialize (  & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) {","if ( libfvalue_value_type_initialize ( & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) {",5504
1981,if ( strings_size != 0 )  {# if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {,if ( strings_size != 0 ) {# if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {,5504
1982,"# if defined ( HAVE_DEBUG_OUTPUT )  if ( libcnotify_verbose != 0 ) {libcnotify_print_data (  & ( record_data [ data_offset ] ) ,  ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;","# if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {libcnotify_print_data ( & ( record_data [ data_offset ] ) , ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;",5504
1983,"int received = recv ( slot -> fd , buf , size , 0 ) ;if ( received == size ) {","int received = TEMP_FAILURE_RETRY ( recv ( slot -> fd , buf , size , 0 ) ) ;if ( received == size ) {",5505
1984,"if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0  && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) {if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ;else success = 1 ;}","success = data_eq_string ( * realm , handle -> params . realm ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ;",5506
1985,"struct scatterlist sg [ 1 ] ;if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ;sg_init_one ( sg , buf , count ) ;return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ;}","struct scatterlist sg [ 1 ] ;void * data ;int ret ;if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ;data = kmemdup ( buf , count , GFP_ATOMIC ) ;if ( ! data ) return - ENOMEM ;sg_init_one ( sg , data , count ) ;return __send_to_port ( port , sg , 1 , count , data , false ) ;kfree ( data ) ;return ret ;}",5507
1986,if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) {avctx -> pix_fmt = AV_PIX_FMT_PAL8 ;,if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) {avctx -> pix_fmt = AV_PIX_FMT_PAL8 ;,5508
1987,}else {,rdp -> nego -> transport -> credssp = NULL ;}else {,5509
1988,"struct free_nid * i ;struct nat_entry * ne ;int err ;if ( unlikely ( nid == 0 ) ) return false ;if ( build ) {ne = __lookup_nat_cache ( nm_i , nid ) ;if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) )  return false ;}if ( radix_tree_preload ( GFP_NOFS ) ) {kmem_cache_free ( free_nid_slab , i ) ;return true ;}spin_unlock ( & nm_i -> nid_list_lock ) ;if ( err ) {kmem_cache_free ( free_nid_slab , i ) ;return true ;}return true ;","struct free_nid * i , * e ;struct nat_entry * ne ;int err = - EINVAL ;bool ret = false ;if ( unlikely ( nid == 0 ) ) return false ;if ( radix_tree_preload ( GFP_NOFS ) ) goto err ;if ( build ) {ne = __lookup_nat_cache ( nm_i , nid ) ;if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) goto err_out ;e = __lookup_free_nid_list ( nm_i , nid ) ;if ( e ) {if ( e -> state == NID_NEW ) ret = true ;goto err_out ;}}ret = true ;err_out : spin_unlock ( & nm_i -> nid_list_lock ) ;err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ;return ret ;",5510
1989,file_sb_list_del ( file ) ;BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ;,BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ;,5511
1990,"gdImageWBMPCtx ( im , fg , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;","if ( ! _gdImageWBMPCtx ( im , fg , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",5512
1991,if ( image_info -> ping )  {return ( image ) ;},"if ( image_info -> ping != MagickFalse ) {return ( image ) ;}status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",5513
1992,"size_t l = 0 ;do {ptr += strspn ( ptr , ""\\\\r\\\if ( * ptr == \'\\\\0\' || ptr >= buf + len ) {l = strcspn ( ptr , ""\\\\r\\\if ( l > 3 && ptr + l <= buf + len ) {p += base64decode_block ( outbuf + p , ptr , l ) ;ptr += l ;else {break ;","int wv , w1 , w2 , w3 , w4 ;int tmpval [ 4 ] ;int tmpcnt = 0 ;do {while ( ptr < buf + len && ( * ptr == \'<S2SV_blank>\' || * ptr == \'\\\\t\' || * ptr == \'\\\ptr ++ ;}if ( * ptr == \'\\\\0\' || ptr >= buf + len ) {if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) {continue ;}tmpval [ tmpcnt ++ ] = wv ;if ( tmpcnt == 4 ) {tmpcnt = 0 ;w1 = tmpval [ 0 ] ;w2 = tmpval [ 1 ] ;w3 = tmpval [ 2 ] ;w4 = tmpval [ 3 ] ;if ( w2 >= 0 ) {outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ;}if ( w3 >= 0 ) {outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ;}if ( w4 >= 0 ) {outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ;",5514
1993,return tmp ;}return tmp ;}return state -> ptr = tmp ;},goto softfail ;}goto softfail ;}softfail : state -> offset = 0 ;return state -> ptr = tmp ;},5515
1994,"ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 )  ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;""  ""<S2SV_blank>using<S2SV_blank>read-until-close"" , tenc ) ;return APR_EGENERAL ;}lenp = NULL ;","ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" , tenc ) ;return APR_EINVAL ;",5516
1995,return APR_ENOSPC ;},return APR_ENOSPC ;},5516
1996,if ( rv != APR_SUCCESS ) {return AP_FILTER_ERROR ;,apr_brigade_cleanup ( bb ) ;if ( rv != APR_SUCCESS ) {return AP_FILTER_ERROR ;,5516
1997,"case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT :  case BODY_CHUNK_END : {rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ;","case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF : {rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ;",5516
1998,"int merge_trailers =  conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ;return read_chunked_trailers ( ctx , f , b , merge_trailers ) ;","return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ) ;",5516
1999,break ;},"ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( int ) ctx -> state ) ;return APR_EGENERAL ;}",5516
2000,"memcpy ( name , fp + n , name_len ) ;name [ name_len ] = \'\\\\0\' ;attr_len = fp [ n ++ ] ;memcpy ( attr , fp + n , attr_len ) ;","IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ;) ;memcpy ( name , fp + n , name_len ) ;name [ name_len ] = \'\\\\0\' ;attr_len = fp [ n ++ ] ;IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ;) ;memcpy ( attr , fp + n , attr_len ) ;",5517
2001,egress :  if ( errcode != 0 )  assert ( state -> status != 0 ) ;,"egress : if ( errcode != 0 && state -> status == NULL ) state -> status = ""UNKNOWN_REASON"" ;",5518
2002,if ( ret == - EEXIST )  goto fail_dir_item ;,if ( ret == - EEXIST || ret == - EOVERFLOW ) goto fail_dir_item ;,5519
2003,"static void fadst8 ( const int16_t * input , int16_t * output ) {int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;int x0 = input [ 7 ] ;int x1 = input [ 0 ] ;int x2 = input [ 5 ] ;int x3 = input [ 2 ] ;int x4 = input [ 3 ] ;int x5 = input [ 4 ] ;int x6 = input [ 1 ] ;int x7 = input [ 6 ] ;s0 = cospi_2_64 * x0 + cospi_30_64 * x1 ;","static void fadst8 ( const tran_low_t * input , tran_low_t * output ) {int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;int x0 = input [ 7 ] ;tran_high_t x1 = input [ 0 ] ;tran_high_t x2 = input [ 5 ] ;tran_high_t x3 = input [ 2 ] ;tran_high_t x4 = input [ 3 ] ;tran_high_t x5 = input [ 4 ] ;tran_high_t x6 = input [ 1 ] ;tran_high_t x7 = input [ 6 ] ;s0 = cospi_2_64 * x0 + cospi_30_64 * x1 ;",5520
2004,output [ 0 ] = x0 ;output [ 1 ] = - x4 ;output [ 2 ] = x6 ;output [ 3 ] = - x2 ;output [ 4 ] = x3 ;output [ 5 ] = - x7 ;output [ 6 ] = x5 ;output [ 7 ] = - x1 ;},output [ 0 ] = ( tran_low_t ) x0 ;output [ 1 ] = ( tran_low_t ) - x4 ;output [ 2 ] = ( tran_low_t ) x6 ;output [ 3 ] = ( tran_low_t ) - x2 ;output [ 4 ] = ( tran_low_t ) x3 ;output [ 5 ] = ( tran_low_t ) - x7 ;output [ 6 ] = ( tran_low_t ) x5 ;output [ 7 ] = ( tran_low_t ) - x1 ;},5520
2005,"static void  fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( bps * stride ) ) == 0 ) ;if ( ! tmp )  return ;_TIFFmemcpy ( tmp , cp0 , cc ) ;","static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( bps * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ;return 0 ;}if ( ! tmp ) return 0 ;_TIFFmemcpy ( tmp , cp0 , cc ) ;",5521
2006,cp -- )  },cp -- ) return 1 ;},5521
2007,if ( dataSize > MAX_DLS_WAVE_SIZE )  {,if ( dataSize < 0 || dataSize > MAX_DLS_WAVE_SIZE ) {,5522
2008,"char * bufp , * commentp , * altp ;mungspaces ( buf ) ;","char * bufp , * commentp , * altp ;if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\\\0' ;mungspaces ( buf ) ;",5523
2009,"static vpx_codec_err_t ctrl_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {int * corrupted = va_arg ( args , int * ) ;if ( ctx -> pbi )   * corrupted = ctx -> pbi -> common . frame_to_show -> corrupted ;else return VPX_CODEC_ERROR ;return VPX_CODEC_INVALID_PARAM ;}}","static vpx_codec_err_t ctrl_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , va_list args ) {int * corrupted = va_arg ( args , int * ) ;if ( ctx -> frame_workers ) {VPxWorker * const worker = ctx -> frame_workers ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;RefCntBuffer * const frame_bufs = frame_worker_data -> pbi -> common . buffer_pool -> frame_bufs ;if ( frame_worker_data -> pbi -> common . frame_to_show == NULL ) return VPX_CODEC_ERROR ;if ( ctx -> last_show_frame >= 0 ) * corrupted = frame_bufs [ ctx -> last_show_frame ] . buf . corrupted ;return VPX_CODEC_ERROR ;}}return VPX_CODEC_INVALID_PARAM ;}",5524
2010,"int mi_repair ( MI_CHECK * param , register MI_INFO * info ,  char * name , int rep_quick )  {","int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick , my_bool no_copy_stat ) {",5525
2011,"if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {mi_check_print_error ( param , ""Can\\\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\\\'%s\\\'"" , param -> temp_filename ) ;goto err ;}if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ;info -> s -> state . dellink = HA_OFFSET_ERROR ;info -> rec_cache . file = new_file ;if ( param -> testflag & T_UNPACK ) {share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;mi_int2store ( share -> state . header . options , share -> options ) ;}}sort_info . info = info ;sort_info . param = param ;sort_param . read_cache = param -> read_cache ;sort_param . pos = sort_param . max_pos = share -> pack . header_length ;sort_param . filepos = new_header_length ;param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( info -> dfile , 0L , MY_SEEK_END , MYF ( 0 ) ) ;sort_info . dupp = 0 ;sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ;sort_param . master = 1 ;sort_info . max_records = ~ ( ha_rows ) 0 ;set_data_file_type ( & sort_info , share ) ;del = info -> state -> del ;info -> state -> records = info -> state -> del = share -> state . split = 0 ;info -> state -> empty = 0 ;param -> glob_crc = 0 ;if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ;info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;if ( param -> testflag & T_CREATE_MISSING_KEYS ) mi_set_all_keys_active ( share -> state . key_map , share -> base . keys ) ;mi_drop_all_indexes ( param , info , TRUE ) ;lock_memory ( param ) ;while ( ! ( error = sort_get_next_record ( & sort_param ) ) ) {if ( writekeys ( & sort_param ) ) {if ( my_errno != HA_ERR_FOUND_DUPP_KEY ) goto err ;DBUG_DUMP ( ""record"" , ( uchar * ) sort_param . record , share -> base . pack_reclength ) ;mi_check_print_info ( param , ""Duplicate<S2SV_blank>key<S2SV_blank>%2d<S2SV_blank>for<S2SV_blank>record<S2SV_blank>at<S2SV_blank>%10s<S2SV_blank>against<S2SV_blank>new<S2SV_blank>record<S2SV_blank>at<S2SV_blank>%10s"" , info -> errkey + 1 , llstr ( sort_param . start_recpos , llbuff ) , llstr ( info -> dupp_key_pos , llbuff2 ) ) ;if ( param -> testflag & T_VERBOSE ) {( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ;_mi_print_key ( stdout , share -> keyinfo [ info -> errkey ] . seg , info -> lastkey , USE_WHOLE_KEY ) ;}sort_info . dupp ++ ;if ( ( param -> testflag & ( T_FORCE_UNIQUENESS | T_QUICK ) ) == T_QUICK ) {param -> testflag |= T_RETRY_WITHOUT_QUICK ;param -> error_printed = 1 ;goto err ;}continue ;}if ( sort_write_record ( & sort_param ) ) goto err ;}if ( error > 0 || write_data_suffix ( & sort_info , ( my_bool ) ! rep_quick ) || flush_io_cache ( & info -> rec_cache ) || param -> read_cache . error < 0 ) goto err ;if ( param -> testflag & T_WRITE_LOOP ) {( void ) fputs ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\\\r"" , stdout ) ;( void ) fflush ( stdout ) ;}if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) {mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;goto err ;}if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {mi_check_print_error ( param , ""Couldn\\\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ;mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ;got_error = 1 ;param -> retry_repair = 1 ;param -> testflag |= T_RETRY_WITHOUT_QUICK ;goto err ;}if ( param -> testflag & T_SAFE_REPAIR ) {if ( info -> state -> records + 1 < start_records ) {info -> state -> records = start_records ;got_error = 1 ;goto err ;}}if ( ! rep_quick ) {mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;info -> dfile = new_file ;info -> state -> data_file_length = sort_param . filepos ;share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;}else {info -> state -> data_file_length = sort_param . max_pos ;}if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;if ( ! ( param -> testflag & T_SILENT ) ) {if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\\if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ;}got_error = 0 ;if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;err : if ( ! got_error ) {if ( new_file >= 0 ) {mysql_file_close ( new_file , MYF ( 0 ) ) ;info -> dfile = new_file = - 1 ;if ( info -> s -> file_map ) {( void ) my_munmap ( ( char * ) info -> s -> file_map , ( size_t ) info -> s -> mmaped_length ) ;info -> s -> file_map = NULL ;}if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;","if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;",5525
2012,"# ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}# endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;","SSL_SET_OPTIONS ( & mysql_connection ) ;if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",5526
2013,"av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\\","av_log ( mxf -> fc -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\\",5527
2014,"av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\\continue ;","av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\\continue ;",5527
2015,"assert ( ops != NULL ) ;pr_notice ( ""pci<S2SV_blank>deinit<S2SV_blank>%s\\\","if ( ! ops ) {pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\\continue ;}pr_notice ( ""pci<S2SV_blank>deinit<S2SV_blank>%s\\\",5528
2016,ut8 opcode = * ( p4 ++ ) & 0xff ;while ( keep ) {,if ( p4 <= 0 ) {return ;}ut8 opcode = * ( p4 ++ ) & 0xff ;while ( keep ) {,5529
2017,"change = ue -> tlv_data_size != size ;if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ;kfree ( ue -> tlv_data ) ;ue -> tlv_data = new_data ;ue -> tlv_data_size = size ;}else {if ( ! ue -> tlv_data_size || ! ue -> tlv_data )  return - ENXIO ;if ( size < ue -> tlv_data_size )   return - ENOSPC ;if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) )   return - EFAULT ;}return change ;","mutex_lock ( & ue -> card -> user_ctl_lock ) ;change = ue -> tlv_data_size != size ;if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ;kfree ( ue -> tlv_data ) {ret = - ENXIO ;goto err_unlock ;}if ( size < ue -> tlv_data_size ) return - ENOSPC ;goto err_unlock ;}if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) return - EFAULT ;err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ;if ( ret ) return ret ;}return change ;",5530
2018,}is_request = ( pinfo -> srcport == NO_ENDPOINT ) ;,usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ;}else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) {return 0 ;}is_request = ( pinfo -> srcport == NO_ENDPOINT ) ;,5531
2019,"ND_TCHECK2 ( dp [ 0 ] , 0 ) ;astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ;","ND_TCHECK ( dp [ 0 ] , 0 ) ;astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ;",5532
2020,"static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row , int mi_col ,  int output_enabled , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index > 0 ) return ;set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ,  output_enabled ) ;encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ;if ( output_enabled ) {update_stats ( cpi ) ;( * tp ) -> token = EOSB_TOKEN ;","static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , ThreadData * td , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {MACROBLOCK * const x = & td -> mb ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index > 0 ) return ;set_offsets ( cpi , td , ctx , mi_row , mi_col , bsize ) ;update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , output_enabled ) ;encode_superblock ( cpi , td , tp , output_enabled , mi_row , mi_col , bsize , ctx ) ;if ( output_enabled ) {update_stats ( & cpi -> common , td ) ;( * tp ) -> token = EOSB_TOKEN ;",5533
2021,"if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ;","memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnotePentaxEntry ) ) ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ;",5534
2022,if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) {r_asn1_free_object ( object ) ;,if ( ! object || object -> list . length != 2 || ! object -> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || object -> list . objects [ 1 ] -> list . length != 1 ) {r_asn1_free_object ( object ) ;,5535
2023,struct task_struct * task = current ;file_sb_list_del ( file ) ;,struct task_struct * task = current ;,5536
2024,"static void exif_data_load_data_content ( ExifData * data , ExifIfd ifd , const unsigned char * d ,  unsigned int ds , unsigned int offset , unsigned int recursion_depth )  {if ( ! data || ! data -> priv ) return ;if ( ( ( ( int ) ifd ) < 0 ) || ( ( ( int ) ifd ) >= EXIF_IFD_COUNT ) ) return ;if ( recursion_depth > 12 ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" ,  ""Deep<S2SV_blank>recursion<S2SV_blank>detected!"" ) ;return ;exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , offset + 2 , ds ) ;","static void exif_data_load_data_content ( ExifData * data , ExifIfd ifd , const unsigned char * d , unsigned int recursion_cost ) {if ( recursion_cost > 170 ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""Deep<S2SV_blank>recursion<S2SV_blank>detected!"" ) ;return ;exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""Deep/expensive<S2SV_blank>recursion<S2SV_blank>detected!"" ) ;",5537
2025,"exif_data_load_data_content ( data , EXIF_IFD_EXIF , d , ds , o , recursion_depth + 1 ) ;break ;exif_data_load_data_content ( data , EXIF_IFD_GPS , d , ds , o , recursion_depth + 1 ) ;break ;exif_data_load_data_content ( data , EXIF_IFD_INTEROPERABILITY , d , ds , o , recursion_depth + 1 ) ;break ;","exif_data_load_data_content ( data , EXIF_IFD_EXIF , d , ds , o , recursion_cost + level_cost ( n ) ) ;break ;exif_data_load_data_content ( data , EXIF_IFD_GPS , d , ds , o , recursion_cost + level_cost ( n ) ) ;break ;exif_data_load_data_content ( data , EXIF_IFD_INTEROPERABILITY , d , ds , o , recursion_cost + level_cost ( n ) ) ;break ;",5537
2026,int n ;int ret ;long newbufsize ;long newpos ;,size_t n ;int ret ;size_t newbufsize ;size_t newpos ;,5538
2027,"newbufsize <<= 1 ;assert ( newbufsize >= 0 ) ;JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%z\\\JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%ul\\\if ( m -> pos_ > m -> len_ ) {n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ;","if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) {JAS_DBGLOG ( 100 , ( ""new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\\return - 1 ;}JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\\assert ( newbufsize > 0 ) ;if ( m -> pos_ > m -> len_ ) {n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ;",5538
2028,down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ;if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ;,"error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ;if ( error ) goto out_dput ;down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ;if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ;",5539
2029,dst [ y * linesize + x ] = clr ;lx = x ;,if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;dst [ y * linesize + x ] = clr ;lx = x ;,5540
2030,int bind_ports ( void ) {SERVICE_OPTIONS * opt ;,NOEXPORT int bind_ports ( void ) {SERVICE_OPTIONS * opt ;,5541
2031,"void sec_decrypt ( uint8 * data , int length )  {if ( g_sec_decrypt_use_count == 4096 ) {","void sec_decrypt ( uint8 * data , int length ) {if ( length <= 0 ) return ;if ( g_sec_decrypt_use_count == 4096 ) {",5542
2032,"const int kBufferFrameCount = 65536 ;void * buffer = malloc ( kBufferFrameCount * frameSize ) ;AFframecount totalFrames = afGetFrameCount ( infile , AF_DEFAULT_TRACK ) ;","int kBufferFrameCount = 65536 ;int bufferSize ;while ( multiplyCheckOverflow ( kBufferFrameCount , frameSize , & bufferSize ) ) kBufferFrameCount /= 2 ;void * buffer = malloc ( bufferSize ) ;AFframecount totalFrames = afGetFrameCount ( infile , AF_DEFAULT_TRACK ) ;",5543
2033,}return new_fpl ;,new_fpl -> user = get_uid ( fpl -> user ) ;}return new_fpl ;,5544
2034,"i ++ )  vpx_memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ;if ( dh < ( int ) dst -> y_height ) for ( i = dh - 1 ;i ++ )  vpx_memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ;Scale2D ( ( unsigned char * ) src -> u_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> u_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ;i ++ )  vpx_memset ( dst -> u_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> u_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ;if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ;i ++ )  vpx_memcpy ( dst -> u_buffer + i * dst -> uv_stride , dst -> u_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ;Scale2D ( ( unsigned char * ) src -> v_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> v_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ;i ++ )  vpx_memset ( dst -> v_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> v_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ;if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ;i ++ )  vpx_memcpy ( dst -> v_buffer + i * dst -> uv_stride , dst -> v_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ;}","i ++ ) memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ;if ( dh < ( int ) dst -> y_height ) for ( i = dh - 1 ;i ++ ) memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ;Scale2D ( ( unsigned char * ) src -> u_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> u_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ;i ++ ) memset ( dst -> u_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> u_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ;if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ;i ++ ) memcpy ( dst -> u_buffer + i * dst -> uv_stride , dst -> u_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ;Scale2D ( ( unsigned char * ) src -> v_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> v_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ;i ++ ) memset ( dst -> v_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> v_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ;if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ;i ++ ) memcpy ( dst -> v_buffer + i * dst -> uv_stride , dst -> v_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ;}",5545
2035,"
","attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ;if ( attr && ! ippValidateAttribute ( attr ) ) {send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ;if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ;return ( NULL ) ;}",5546
2036,"if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL )  {","if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL ) {",5546
2037,"apply_printer_defaults ( printer , job ) ;attr = ippFindAttribute ( job -> attrs , ""requesting-user-name"" , IPP_TAG_NAME ) ;","apply_printer_defaults ( printer , job ) ;",5546
2038,"struct dentry * dentry = path -> dentry ;struct inode * inode = dentry -> d_inode ;file -> f_path = * path ;}return do_dentry_open ( file , inode , NULL , cred ) ;","struct inode * inode = dentry -> d_inode ;file -> f_path = * path ;file -> f_path = * path ;return do_dentry_open ( file , inode , NULL , cred ) ;",5547
2039,"static inline bool unconditional ( const struct ip6t_ip6 * ipv6 )  {return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ;}","static inline bool unconditional ( const struct ip6t_entry * e ) {return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> ipv6 , & uncond , sizeof ( uncond ) ) == 0 ;}",5548
2040,"
",kfree_skb ( skb ) ;,5549
2041,return - ETIMEDOUT ;},return - ETIMEDOUT ;},5549
2042,"int ret ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data ,  indx , & data , 1 , 1000 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}","u8 * buf ;int ret ;buf = kmemdup ( & data , 1 , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data , indx , buf , 1 , 1000 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\kfree ( buf ) ;return ret ;}",5550
2043,"static gboolean  accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) {IceListenObj listener ;IceConn ice_conn ;IceAcceptStatus status ;GsmClient * client ;GsmXsmpServer * server ;listener = data -> listener ;server = data -> server ;g_debug ( ""GsmXsmpServer:<S2SV_blank>accept_ice_connection()"" ) ;ice_conn = IceAcceptConnection ( listener , & status ) ;if ( status != IceAcceptSuccess ) {g_debug ( ""GsmXsmpServer:<S2SV_blank>IceAcceptConnection<S2SV_blank>returned<S2SV_blank>%d"" , status ) ;return TRUE ;client = gsm_xsmp_client_new ( ice_conn ) ;ice_conn -> context = client ;gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ;g_object_unref ( client ) ;return TRUE ;","typedef struct {guint watch_id ;guint protocol_timeout ;GsmIceConnectionWatch ;static void disconnect_ice_connection ( IceConn ice_conn ) {IceSetShutdownNegotiation ( ice_conn , FALSE ) ;IceCloseConnection ( ice_conn ) ;",5551
2044,tp -> prr_delivered += newly_acked_sacked ;if ( delta < 0 ) {,if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;tp -> prr_delivered += newly_acked_sacked ;if ( delta < 0 ) {,5552
2045,"ND_TCHECK ( bp [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>auto-rp<S2SV_blank>"" ) ) ;","if ( len < 8 ) goto trunc ;ND_TCHECK ( bp [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>auto-rp<S2SV_blank>"" ) ) ;",5553
2046,"ND_TCHECK ( bp [ 1 ] ) ;numrps = bp [ 1 ] ;ND_TCHECK2 ( bp [ 2 ] , 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>Hold<S2SV_blank>"" ) ) ;hold = EXTRACT_16BITS ( & bp [ 2 ] ) ;if ( hold ) unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ;else ND_PRINT ( ( ndo , ""FOREVER"" ) ) ;bp += 8 ;len -= 8 ;while ( numrps -- ) {int nentries ;char s ;ND_TCHECK2 ( bp [ 0 ] , 4 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>RP<S2SV_blank>%s"" , ipaddr_string ( ndo , bp ) ) ) ;ND_TCHECK ( bp [ 4 ] ) ;switch ( bp [ 4 ] & 0x3 ) {case 0 : ND_PRINT ( ( ndo , ""<S2SV_blank>PIMv?"" ) ) ;","ND_TCHECK ( bp [ 0 ] & 0x3 ) {case 0 : ND_PRINT ( ( ndo , ""<S2SV_blank>PIMv?"" ) ) ;",5553
2047,"if ( bp [ 4 ] & 0xfc )   ND_PRINT ( ( ndo , ""<S2SV_blank>[rsvd=0x%02x]"" , bp [ 4 ] & 0xfc ) ) ;ND_TCHECK ( bp [ 5 ] ) ;nentries = bp [ 5 ] ;bp += 6 ;s = \'<S2SV_blank>\' ;ND_TCHECK2 ( bp [ 0 ] , 6 ) ;ND_PRINT ( ( ndo , ""%c%s%s/%d"" , s , bp [ 0 ] & 1 ? ""!"" : """" , ipaddr_string ( ndo , & bp [ 2 ] ) , bp [ 1 ] ) ) ;if ( bp [ 0 ] & 0x02 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>bidir"" ) ) ;}","if ( bp [ 4 ] & 0xfc ) ND_PRINT ( ( ndo , ""<S2SV_blank>[rsvd=0x%02x]"" , bp [ 4 ] & 0xfc ) ) ;ND_TCHECK ( bp [ 5 ] ) ;nentries = bp [ 5 ] ;bp += 6 ;s = \'<S2SV_blank>\' ;ND_TCHECK2 ( bp [ 0 ] , 6 ) ;ND_PRINT ( ( ndo , ""%c%s%s/%d"" , s , bp [ 0 ] & 1 ? ""!"" : """" , ipaddr_string ( ndo , & bp [ 2 ] ) , bp [ 1 ] ) ) ;bp += 1 ;len -= 1 ;if ( len < 1 ) goto trunc ;",5553
2048,if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,if ( num < 0 || num >= 256 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,5554
2049,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,5554
2050,"static int em_call ( struct x86_emulate_ctxt * ctxt )  {long rel = ctxt -> src . val ;jmp_rel ( ctxt , rel ) ;return em_push ( ctxt ) ;","static int em_call ( struct x86_emulate_ctxt * ctxt ) {int rc ;long rel = ctxt -> src . val ;rc = jmp_rel ( ctxt , rel ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;return em_push ( ctxt ) ;",5555
2051,"if ( nfs_wait_on_sequence ( calldata -> arg . seqid , task ) != 0 ) return ;clear_rd = clear_wr = clear_rdwr = 0 ;spin_lock ( & state -> owner -> so_lock ) ;if ( state -> n_rdwr == 0 ) {if ( state -> n_rdonly == 0 ) {clear_rd |= test_and_clear_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ;clear_rdwr |= test_and_clear_bit ( NFS_O_RDWR_STATE , & state -> flags ) ;if ( state -> n_wronly == 0 ) {clear_wr |= test_and_clear_bit ( NFS_O_WRONLY_STATE , & state -> flags ) ;clear_rdwr |= test_and_clear_bit ( NFS_O_RDWR_STATE , & state -> flags ) ;}}spin_unlock ( & state -> owner -> so_lock ) ;if ( ! clear_rd && ! clear_wr && ! clear_rdwr ) {task -> tk_action = NULL ;return ;}nfs_fattr_init ( calldata -> res . fattr ) ;if ( test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ) {task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_DOWNGRADE ] ;calldata -> arg . open_flags = FMODE_READ ;}calldata -> arg . open_flags = FMODE_WRITE ;}",if ( nfs_wait_on_sequence ( calldata -> arg . fmode = FMODE_READ ;calldata -> arg . open_flags = FMODE_WRITE ;},5556
2052,"int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ;aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ;","sqlite3_int64 nBytes = sizeof ( sqlite3_vtab * ) * ( ( sqlite3_int64 ) db -> nVTrans + ARRAY_INCR ) ;aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ;",5557
2053,static void follow_dotdot ( struct nameidata * nd )  {,static int follow_dotdot ( struct nameidata * nd ) {,5558
2054,break ;}},if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;break ;}return 0 ;},5558
2055,update_db_bp_intercept ( vcpu ) ;},},5559
2056,"if ( ! proc_fd_access_allowed ( inode ) ) goto out ;error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ;nd -> last_type = LAST_BIND ;out : return ERR_PTR ( error ) ;",out : return ERR_PTR ( error ) ;,5560
2057,"used = recv_actor ( desc , skb , offset , len ) ;if ( used < 0 ) {if ( ! copied ) copied = used ;break ;}else if ( used <= len ) {seq += used ;copied += used ;offset += used ;}skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ;if ( ! skb || ( offset + 1 != skb -> len ) ) break ;}if ( tcp_hdr ( skb ) -> fin ) {sk_eat_skb ( sk , skb , 0 ) ;++ seq ;break ;}sk_eat_skb ( sk , skb , 0 ) ;if ( ! desc -> count ) break ;}tp -> copied_seq = seq ;tcp_rcv_space_adjust ( sk ) ;if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ;","tp -> copied_seq = seq ;+ seq ;tp -> copied_seq = seq ;tcp_rcv_space_adjust ( sk ) ;if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ;",5561
2058,"if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) {pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\\","if ( assoc_array_ptr_is_leaf ( ptr ) && ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) {pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\\",5562
2059,if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {},if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {}else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) {return false ;},5563
2060,"conn -> sasl_username = NULL ;conn -> sasl_password = NULL ;if ( ircnet -> sasl_mechanism != NULL ) {if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , ""plain"" ) ) {conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ;if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && ircnet -> sasl_password != NULL && * ircnet -> sasl_password ) {conn -> sasl_username = ircnet -> sasl_username ;conn -> sasl_password = ircnet -> sasl_password ;",conn -> sasl_username = g_strdup ( ircnet -> sasl_username ) ;conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) ;,5564
2061,"request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;request_buf . value = buf2 ;","request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 , sizeof ( buf2 ) ) ;request_buf . value = buf2 ;",5565
2062,"request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;request_buf . value = buf2 ;","request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 , sizeof ( buf2 ) ) ;request_buf . value = buf2 ;",5565
2063,"void * dllhandle ;if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\","void * dllhandle ;if ( COM_CompareExtension ( name , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , name ) ;return NULL ;}if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\",5566
2064,int ret = 0 ;if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ;,"int ret = 0 ;if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ;if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ;",5567
2065,"char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ;if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) {","char * prop_chunk ;if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ;prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ;if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) {",5568
2066,"vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim ,  lfi -> hev_thr , 2 ) ;vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim ,  lfi -> hev_thr , 1 ) ;}}else if ( mask_8x8 & 1 ) {if ( ( mask_8x8 & 3 ) == 3 ) {const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ;vp9_lpf_horizontal_8_dual ( s , pitch , lfi -> mblim , lfi -> lim ,  lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ;vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim ,  lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ;else if ( mask_4x4_int & 2 )  vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim ,  lfin -> lim , lfin -> hev_thr , 1 ) ;vp9_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ;vp9_lpf_horizontal_4_dual ( s , pitch , lfi -> mblim , lfi -> lim ,  lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ;if ( ( mask_4x4_int & 3 ) == 3 ) {vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim ,  lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ;else if ( mask_4x4_int & 2 )  vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim ,  lfin -> lim , lfin -> hev_thr , 1 ) ;vp9_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;","vpx_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 2 ) ;vpx_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;vpx_lpf_horizontal_8_dual ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ;vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ;else if ( mask_4x4_int & 2 ) vp9_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim , lfin -> lim , lfin -> hev_thr , 1 ) ;vp9_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;if ( mask_4x4_int & 1 ) vp9_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ;}else {if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ;else if ( mask_4x4_int & 2 ) vpx_lpf_horizontal_4 ( s + 8 + 4 * pitch , pitch , lfin -> mblim , lfin -> lim , lfin -> hev_thr , 1 ) ;vpx_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;",5569
2067,"return perf_read_hw ( event , buf , count ) ;}","struct perf_event_context * ctx ;int ret ;ctx = perf_event_ctx_lock ( event ) ;ret = perf_read_hw ( event , buf , count ) ;perf_event_ctx_unlock ( event , ctx ) ;return ret ;}",5570
2068,return SQLITE_NOMEM ;},"return sqlite3ErrorToParser ( db , SQLITE_NOMEM ) ;}if ( rc && pParse -> nErr == 0 ) {assert ( pParse -> db -> mallocFailed ) ;return sqlite3ErrorToParser ( pParse -> db , SQLITE_NOMEM ) ;}",5571
2069,return rc ;},return rc ;},5571
2070,vpx_codec_ctx_t codec [ NUM_ENCODERS ] ;vpx_codec_enc_cfg_t cfg [ NUM_ENCODERS ] ;vpx_codec_pts_t frame_cnt = 0 ;vpx_image_t raw [ NUM_ENCODERS ] ;int frame_avail ;int got_data ;int arg_deadline = VPX_DL_REALTIME ;int show_psnr = 0 ;uint64_t psnr_sse_total [ NUM_ENCODERS ] = {uint64_t psnr_samples_total [ NUM_ENCODERS ] = {,"int frame_cnt = 0 ;vpx_image_t raw [ NUM_ENCODERS ] ;int length_frame ;int frame_avail ;int got_data ;int layer_id = 0 ;int key_frame_insert = 0 ;int layer_flags [ VPX_TS_MAX_PERIODICITY * NUM_ENCODERS ] = {double cx_time = 0 ;struct timeval tv1 , tv2 , difftv ;int flag_periodicity ;int arg_deadline = VPX_DL_REALTIME ;int show_psnr = 0 ;uint64_t psnr_sse_total [ NUM_ENCODERS ] = {0 };uint64_t psnr_samples_total [ NUM_ENCODERS ] = {",5572
2071,int psnr_count [ NUM_ENCODERS ] = {unsigned int target_bitrate [ NUM_ENCODERS ] = {,"unsigned int num_temporal_layers [ NUM_ENCODERS ] = {3 , 3 , 3 };int psnr_count [ NUM_ENCODERS ] = {unsigned int target_bitrate [ NUM_ENCODERS ] = {",5572
2072,"if ( argc != ( 5 + NUM_ENCODERS ) )   die ( ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank><output<S2SV_blank>psnr?>\\\width = strtol ( argv [ 1 ] , NULL , 0 ) ;height = strtol ( argv [ 2 ] , NULL , 0 ) ;if ( width < 16 || width % 2 || height < 16 || height % 2 ) die ( ""Invalid<S2SV_blank>resolution:<S2SV_blank>%ldx%ld"" , width , height ) ;if ( ! ( infile = fopen ( argv [ 3 ] , ""rb"" ) ) )   die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , argv [ 3 ] ) ;for ( i = 0 ;if ( ! ( outfile [ i ] = fopen ( argv [ i + 4 ] , ""wb"" ) ) )  die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , argv [ i + 4 ] ) ;show_psnr = strtol ( argv [ NUM_ENCODERS + 4 ] , NULL , 0 ) ;for ( i = 0 ;i ++ )  {res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ;if ( res [ i ] ) {}cfg [ 0 ] . g_w = width ;cfg [ 0 ] . g_threads = 1 ;cfg [ 0 ] . rc_dropframe_thresh = 30 ;cfg [ 0 ] . rc_min_quantizer = 4 ;cfg [ 0 ] . rc_max_quantizer = 56 ;cfg [ 0 ] . rc_undershoot_pct = 98 ;cfg [ 0 ] . rc_overshoot_pct = 100 ;cfg [ 0 ] . rc_buf_initial_sz = 500 ;","if ( argc != ( 7 + 3 * NUM_ENCODERS ) ) die ( ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><frame_rate><S2SV_blank><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank>"" ""<rate_encoder(s)><S2SV_blank><temporal_layer(s)><S2SV_blank><key_frame_insert><S2SV_blank><output<S2SV_blank>psnr?><S2SV_blank>\\\width = strtol ( argv [ 4 ] , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , argv [ 3 ] ) ;for ( i = 0 ;if ( ! ( outfile [ i ] = fopen ( argv [ i + 4 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , argv [ i + 4 ] ) ;}for ( i = 0 ;i < NUM_ENCODERS ;i ++ ) {target_bitrate [ i ] = strtol ( argv [ NUM_ENCODERS + 5 + i ] , NULL , 0 ) ;}for ( i = 0 ;i < NUM_ENCODERS ;i ++ ) {num_temporal_layers [ i ] = strtol ( argv [ 2 * NUM_ENCODERS + 5 + i ] , NULL , 0 ) ;if ( num_temporal_layers [ i ] < 1 || num_temporal_layers [ i ] > 3 ) die ( ""Invalid<S2SV_blank>temporal<S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>1,<S2SV_blank>2,<S2SV_blank>or<S2SV_blank>3.<S2SV_blank>\\\}for ( i = 0 ;i < NUM_ENCODERS - 1 ;i ++ ) {if ( sprintf ( filename , ""ds%d.yuv"" , NUM_ENCODERS - i ) < 0 ) {return EXIT_FAILURE ;}downsampled_input [ i ] = fopen ( filename , ""wb"" ) ;key_frame_insert = strtol ( argv [ 3 * NUM_ENCODERS + 5 ] , NULL , 0 ) ;show_psnr = strtol ( argv [ 3 * NUM_ENCODERS + 6 ] , NULL , 0 ) ;for ( i = 0 ;i ++ ) {res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ;if ( res [ i ] ) {}cfg [ 0 ] . rc_dropframe_thresh = 0 ;cfg [ 0 ] . g_threads = 1 ;cfg [ 0 ] . rc_dropframe_thresh = 30 ;cfg [ 0 ] . rc_min_quantizer = 2 ;cfg [ 0 ] . rc_max_quantizer = 56 ;cfg [ 0 ] . rc_undershoot_pct = 100 ;cfg [ 0 ] . rc_overshoot_pct = 15 ;cfg [ 0 ] . rc_buf_initial_sz = 500 ;",5572
2073,"memcpy ( & cfg [ i ] , & cfg [ 0 ] , sizeof ( vpx_codec_enc_cfg_t ) ) ;cfg [ i ] . g_threads = 1 ;unsigned int iw = cfg [ i - 1 ] . g_w * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ;unsigned int ih = cfg [ i - 1 ] . g_h * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ;cfg [ i ] . g_w = iw / dsf [ i - 1 ] . num ;cfg [ i ] . g_h = ih / dsf [ i - 1 ] . num ;}if ( ( cfg [ i ] . g_w ) % 2 ) cfg [ i ] . g_w ++ ;for ( i = 0 ;i ++ )  if ( ! vpx_img_alloc ( & raw [ i ] , VPX_IMG_FMT_I420 , cfg [ i ] . g_w , cfg [ i ] . g_h , 32 ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , cfg [ i ] . g_w , cfg [ i ] . g_h ) ;i ++ ) if ( outfile [ i ] )  write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , 0 ) ;if ( vpx_codec_enc_init_multi ( & codec [ 0 ] , interface , & cfg [ 0 ] , NUM_ENCODERS , ( show_psnr ? VPX_CODEC_USE_PSNR : 0 ) , & dsf [ 0 ] ) ) die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_CPUUSED , speed ) )   die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>cpu_used"" ) ;}unsigned int static_thresh = 1 ;if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , static_thresh ) )   die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" ) ;}","memcpy ( & cfg [ i ] , & cfg [ 0 ] , sizeof ( vpx_codec_enc_cfg_t ) ) ;cfg [ i ] . g_threads = 1 ;unsigned int max_intra_size_pct = ( int ) ( ( ( double ) cfg [ 0 ] . rc_buf_optimal_sz * 0.5 ) * framerate / 10 ) ;cfg [ 0 ] . g_threads = 2 ;cfg [ 1 ] . g_threads = 1 ;cfg [ 2 ] . g_threads = 1 ;for ( i = 0 ;i ++ ) if ( ! vpx_img_alloc ( & raw [ i ] , VPX_IMG_FMT_I420 , cfg [ i ] . g_w , cfg [ i ] . g_h , 32 ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , cfg [ i ] . g_w , cfg [ i ] . g_h ) ;i ++ ) if ( outfile [ i ] ) write_ivf_file_header ( outfile [ i ] , VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct ) ) die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;if ( i == NUM_ENCODERS - 1 ) speed = - 4 ;if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_CPUUSED , speed ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>cpu_used"" ) ;}if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , 1 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" ) ;}if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity"" ) ;for ( i = 1 ;i < NUM_ENCODERS ;i ++ ) {if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity"" ) ;}for ( i = 0 ;i < NUM_ENCODERS ;i ++ ) {if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_TOKEN_PARTITIONS , 1 ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" ) ;}for ( i = 0 ;i < NUM_ENCODERS ;i ++ ) {unsigned int static_thresh = 1 ;if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , static_thresh ) ) die_codec ( & codec [ i ] , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold"" ) ;}",5572
2074,"}}if ( vpx_codec_encode ( & codec [ 0 ] , frame_avail ? & raw [ 0 ] : NULL ,  frame_cnt , 1 , flags , arg_deadline ) )   die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame"" ) ;for ( i = NUM_ENCODERS - 1 ;","length_frame = cfg [ i ] . g_w * cfg [ i ] . g_h * 3 / 2 ;if ( fwrite ( raw [ i ] . planes [ 0 ] , 1 , 0 , arg_deadline ) ) {die_codec ( & codec [ 0 ] , ""Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame"" ) ;}gettimeofday ( & tv2 , NULL ) ;timersub ( & tv2 , & tv1 , & difftv ) ;cx_time += ( double ) ( difftv . tv_sec * 1000000 + difftv . tv_usec ) ;for ( i = NUM_ENCODERS - 1 ;",5572
2075,"printf ( pkt [ i ] -> kind == VPX_CODEC_CX_FRAME_PKT  && ( pkt [ i ] -> data . frame . flags & VPX_FRAME_IS_KEY ) ? ""K"" : ""."" ) ;fflush ( stdout ) ;printf ( ""\\\fclose ( infile ) ;","printf ( pkt [ i ] -> kind == VPX_CODEC_CX_FRAME_PKT && ( pkt [ i ] -> data . frame . flags & VPX_FRAME_IS_KEY ) ? ""K"" : """" ) ;fflush ( stdout ) ;printf ( ""\\\printf ( ""FPS<S2SV_blank>for<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>%f<S2SV_blank>%f<S2SV_blank>\\\fclose ( infile ) ;",5572
2076,"int i , retval ;bzrtpPacket_t * zrtpPacket ;bzrtpContext_t * context87654321 = bzrtp_createBzrtpContext ( 0x87654321 ) ;bzrtpContext_t * context12345678 = bzrtp_createBzrtpContext ( 0x12345678 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 0 ] , H12345678 [ 0 ] , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 1 ] , H12345678 [ 1 ] , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 2 ] , H12345678 [ 2 ] , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 3 ] , H12345678 [ 3 ] , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 0 ] , H87654321 [ 0 ] , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 1 ] , H87654321 [ 1 ] , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 2 ] , H87654321 [ 2 ] , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 3 ] , H87654321 [ 3 ] , 32 ) ;context87654321 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ;context12345678 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ;context87654321 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ;context12345678 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ;context87654321 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256 ;context12345678 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256 ;updateCryptoFunctionPointers ( context87654321 -> channelContext [ 0 ] ) ;updateCryptoFunctionPointers ( context12345678 -> channelContext [ 0 ] ) ;context87654321 -> channelContext [ 0 ] -> mackeyi = ( uint8_t * ) malloc ( 32 ) ;context12345678 -> channelContext [ 0 ] -> mackeyi = ( uint8_t * ) malloc ( 32 ) ;context87654321 -> channelContext [ 0 ] -> mackeyr = ( uint8_t * ) malloc ( 32 ) ;context12345678 -> channelContext [ 0 ] -> mackeyr = ( uint8_t * ) malloc ( 32 ) ;context87654321 -> channelContext [ 0 ] -> zrtpkeyi = ( uint8_t * ) malloc ( 16 ) ;context12345678 -> channelContext [ 0 ] -> zrtpkeyi = ( uint8_t * ) malloc ( 16 ) ;context87654321 -> channelContext [ 0 ] -> zrtpkeyr = ( uint8_t * ) malloc ( 16 ) ;context12345678 -> channelContext [ 0 ] -> zrtpkeyr = ( uint8_t * ) malloc ( 16 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> mackeyi , mackeyi , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> mackeyr , mackeyr , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> zrtpkeyi , zrtpkeyi , 16 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> zrtpkeyr , zrtpkeyr , 16 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> mackeyi , mackeyi , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> mackeyr , mackeyr , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> zrtpkeyi , zrtpkeyi , 16 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> zrtpkeyr , zrtpkeyr , 16 ) ;context12345678 -> channelContext [ 0 ] -> role = RESPONDER ;for ( i = 0 ;i < TEST_PACKET_NUMBER ;i ++ ) {uint8_t freePacketFlag = 1 ;zrtpPacket = bzrtp_packetCheck ( patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] , ( patternZRTPMetaData [ i ] [ 1 ] ) - 1 , & retval ) ;retval += bzrtp_packetParser ( ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) ? context12345678 : context87654321 , ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) ? context12345678 -> channelContext [ 0 ] : context87654321 -> channelContext [ 0 ] , patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] , zrtpPacket ) ;if ( zrtpPacket -> messageType == MSGTYPE_HELLO ) {if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) {context12345678 -> channelContext [ 0 ] -> peerPackets [ HELLO_MESSAGE_STORE_ID ] = zrtpPacket ;}else {context87654321 -> channelContext [ 0 ] -> peerPackets [ HELLO_MESSAGE_STORE_ID ] = zrtpPacket ;}freePacketFlag = 0 ;}if ( zrtpPacket -> messageType == MSGTYPE_COMMIT ) {if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) {context12345678 -> channelContext [ 0 ] -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] = zrtpPacket ;}else {context87654321 -> channelContext [ 0 ] -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] = zrtpPacket ;}freePacketFlag = 0 ;}if ( zrtpPacket -> messageType == MSGTYPE_DHPART1 || zrtpPacket -> messageType == MSGTYPE_DHPART2 ) {if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) {context12345678 -> channelContext [ 0 ] -> peerPackets [ DHPART_MESSAGE_STORE_ID ] = zrtpPacket ;}else {context87654321 -> channelContext [ 0 ] -> peerPackets [ DHPART_MESSAGE_STORE_ID ] = zrtpPacket ;}freePacketFlag = 0 ;}free ( zrtpPacket -> packetString ) ;retval = bzrtp_packetBuild ( ( patternZRTPMetaData [ i ] [ 2 ] == 0x12345678 ) ? context12345678 : context87654321 , ( patternZRTPMetaData [ i ] [ 2 ] == 0x12345678 ) ? context12345678 -> channelContext [ 0 ] : context87654321 -> channelContext [ 0 ] , zrtpPacket , patternZRTPMetaData [ i ] [ 1 ] ) ;if ( zrtpPacket -> packetString != NULL ) {CU_ASSERT_TRUE ( memcmp ( zrtpPacket -> packetString , patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] ) == 0 ) ;}else {CU_FAIL ( ""Unable<S2SV_blank>to<S2SV_blank>build<S2SV_blank>packet"" ) ;}if ( freePacketFlag == 1 ) {bzrtp_freeZrtpPacket ( zrtpPacket ) ;}}bzrtp_destroyBzrtpContext ( context87654321 , 0x87654321 ) ;bzrtp_destroyBzrtpContext ( context12345678 , 0x12345678 ) ;",test_parser_param ( 0 ) ;,5573
2077,"in_uint16_le ( s , length ) ;in_uint16_le ( s , flags ) ;in_uint8 ( s , type ) ;next_order = s -> p + ( sint16 ) length + 7 ;","struct stream packet = * s ;in_uint16_le ( s , length ) ;in_uint16_le ( s , flags ) ;in_uint8 ( s , type ) ;if ( ! s_check_rem ( s , length + 7 ) ) {rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ;}next_order = s -> p + ( sint16 ) length + 7 ;",5574
2078,"size_t columns ,  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads ,  sizeof ( * pixels ) ) ;( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ )  {","size_t columns , rows ;rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( rows , sizeof ( * pixels ) ) ;columns = MaxPixelChannels ;for ( i = 0 ;i ++ ) {",5575
2079,"conn -> c_trans = trans ;ret = trans -> conn_alloc ( conn , gfp ) ;","if ( trans == NULL ) {kmem_cache_free ( rds_conn_slab , conn ) ;conn = ERR_PTR ( - ENODEV ) ;goto out ;}conn -> c_trans = trans ;ret = trans -> conn_alloc ( conn , gfp ) ;",5576
2080,"ni6 = ( const struct icmp6_nodeinfo * ) dp ;ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ;","ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ;ni6 = ( const struct icmp6_nodeinfo * ) dp ;ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ;",5577
2081,cp = ( const u_char * ) ( ni6 + 1 ) + 4 ;if ( cp [ 0 ] == ep - cp - 1 ) {,cp = ( const u_char * ) ( ni6 + 1 ) + 4 ;ND_TCHECK ( cp [ 0 ] ) ;if ( cp [ 0 ] == ep - cp - 1 ) {,5577
2082,Py_ssize_t new_memo_size = 0 ;Py_ssize_t i ;,size_t new_memo_size = 0 ;,5578
2083,for ( i = 0 ;Py_XINCREF ( unpickler -> memo [ i ] ) ;,for ( size_t i = 0 ;Py_XINCREF ( unpickler -> memo [ i ] ) ;,5578
2084,i = new_memo_size ;while ( -- i >= 0 ) {,for ( size_t i = new_memo_size - 1 ;i != SIZE_MAX ;i -- ) {,5578
2085,"cJSON_AddIntToObject ( j , ""omit"" , test -> omit ) ;if ( test -> server_affinity != - 1 )  cJSON_AddIntToObject ( j , ""server_affinity"" , test -> server_affinity ) ;if ( test -> duration ) cJSON_AddIntToObject ( j , ""time"" , test -> duration ) ;","cJSON_AddNumberToObject ( j , ""omit"" , test -> omit ) ;if ( test -> server_affinity != - 1 ) cJSON_AddNumberToObject ( j , ""get_server_output"" , iperf_get_test_get_server_output ( test ) ) ;== == == = cJSON_AddNumberToObject ( j , ""get_server_output"" , iperf_get_test_get_server_output ( test ) ) ;if ( test -> udp_counters_64bit ) cJSON_AddNumberToObject ( j , ""udp_counters_64bit"" , iperf_get_test_udp_counters_64bit ( test ) ) ;if ( test -> no_fq_socket_pacing ) cJSON_AddNumberToObject ( j , ""no_fq_socket_pacing"" , iperf_get_no_fq_socket_pacing ( test ) ) ;cJSON_AddStringToObject ( j , ""title"" , test -> title ) ;if ( test -> congestion ) cJSON_AddStringToObject ( j , ""congestion"" , test -> congestion ) ;if ( test -> get_server_output ) << << << < HEAD cJSON_AddIntToObject ( j , ""server_affinity"" , test -> server_affinity ) ;if ( test -> duration ) cJSON_AddIntToObject ( j , ""time"" , test -> duration ) ;",5579
2086,"if ( test -> settings -> rate ) cJSON_AddIntToObject ( j , ""bandwidth"" , test -> settings -> rate ) ;if ( test -> settings -> burst ) cJSON_AddIntToObject ( j , ""burst"" , test -> settings -> burst ) ;if ( test -> title )  cJSON_AddStringToObject ( j , ""title"" , test -> title ) ;if ( test -> congestion ) cJSON_AddStringToObject ( j , ""congestion"" , test -> congestion ) ;","if ( test -> settings -> rate ) cJSON_AddIntToObject ( j , ""client_version"" , IPERF_VERSION ) ;>> >> >> > ed94082 ... Fix a buffer overflow / heap corruption issue that could occur if a if ( test -> settings -> burst ) cJSON_AddIntToObject ( j , ""burst"" , test -> settings -> burst ) ;if ( test -> title ) cJSON_AddStringToObject ( j , ""title"" , test -> title ) ;if ( test -> congestion ) cJSON_AddStringToObject ( j , ""congestion"" , test -> congestion ) ;",5579
2087,"if ( timeri -> master )  list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ;spin_unlock_irqrestore ( & slave_active_lock , flags ) ;return 1 ;","if ( timeri -> master && timeri -> timer ) {spin_lock ( & timeri -> timer -> lock ) ;list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ;spin_unlock ( & timeri -> timer -> lock ) ;}spin_unlock_irqrestore ( & slave_active_lock , flags ) ;return 1 ;",5580
2088,"spin_lock_irq ( & tu -> qlock ) ;while ( ( long ) count - result >= unit ) {while ( ! tu -> qused ) {wait_queue_t wait ;if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) {err = - EAGAIN ;goto _error ;}set_current_state ( TASK_INTERRUPTIBLE ) ;init_waitqueue_entry ( & wait , current ) ;add_wait_queue ( & tu -> qchange_sleep , & wait ) ;spin_unlock_irq ( & tu -> qlock ) ;schedule ( ) ;spin_lock_irq ( & tu -> qlock ) ;",mutex_lock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;mutex_unlock ( & tu -> ioctl_lock ) ;schedule ( ) ;mutex_lock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;,5581
2089,"mutex_lock ( & tu -> ioctl_lock ) ;if ( tu -> tread ) {else {if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ;}mutex_unlock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;return result > 0 ? result : err ;}",if ( tu -> tread ) {spin_lock_irq ( & tu -> qlock ) ;mutex_unlock ( & tu -> ioctl_lock ) ;return result > 0 ? result : err ;},5581
2090,else if ( ( ctxt -> internalized ) && ( target != NULL ) && ( target -> doc != NULL ) &&  ( target -> doc -> dict == ctxt -> dict ) ) {text -> content = ( xmlChar * ) value ;,"else if ( ( ctxt -> internalized ) && ( target != NULL ) && ( target -> doc != NULL ) && ( target -> doc -> dict == ctxt -> dict ) && xmlDictOwns ( ctxt -> dict , value ) ) {text -> content = ( xmlChar * ) value ;",5582
2091,"return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ;}","return TEMP_FAILURE_RETRY ( send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) ) == sizeof ( cmd ) ;}",5583
2092,"if ( sock -> ops ) {struct module * owner = sock -> ops -> owner ;sock -> ops -> release ( sock ) ;sock -> ops = NULL ;module_put ( owner ) ;}if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list )  pr_err ( ""%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\\if ( ! sock -> file ) {iput ( SOCK_INODE ( sock ) ) ;return ;}sock -> file = NULL ;","__sock_release ( sock , NULL ) ;",5584
2093,"# if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject :  return g_NPN_GetValue_real ( instance , variable , value ) ;default : switch ( variable & 0xff ) {","# if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : return g_NPN_GetValue_real ( instance , variable , value ) ;default : switch ( variable & 0xff ) {",5585
2094,ps_dec -> u2_total_mbs_coded ++ ;u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ;,u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ;,5586
2095,if ( u1_tfr_n_mb )  u1_num_mbs = 0 ;,ps_dec -> u2_total_mbs_coded += u1_num_mbs ;if ( u1_tfr_n_mb ) u1_num_mbs = 0 ;,5586
2096,"memcpy ( new , ours , sizeof ( * new ) ) ;len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ;","memcpy ( new , ours , sizeof ( * new ) ) ;memset ( dte , 0 , sizeof ( * dte ) ) ;len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ;",5587
2097,"if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) {c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ;aligned_height = FFALIGN ( c -> tile_height , 16 ) ;","if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width , 16 ) * 3 ;aligned_height = FFALIGN ( c -> tile_height , 16 ) ;",5588
2098,if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 ) {,if ( ( sqlite3SelectTrace & 0x2000 ) != 0 && ExplainQueryPlanParent ( pParse ) == 0 && p -> pWin == 0 ) {,5589
2099,"# endif if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0  ) {p -> selFlags &= ~ SF_Distinct ;","# endif if ( ( p -> selFlags & ( SF_Distinct | SF_Aggregate ) ) == SF_Distinct && sqlite3ExprListCompare ( sSort . pOrderBy , pEList , - 1 ) == 0 ) {p -> selFlags &= ~ SF_Distinct ;",5589
2100,"
","if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) {avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ;return AVERROR_PATCHWELCOME ;}",5590
2101,c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;if ( c -> cblk_style != 0 ) {,c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;if ( c -> cblk_style != 0 ) {,5590
2102,kfree ( fpl ) ;},free_uid ( fpl -> user ) ;kfree ( fpl ) ;},5591
2103,"void vp9_cyclic_refresh_update_segment ( VP9_COMP * const cpi , MB_MODE_INFO * const mbmi , int mi_row , int mi_col ,  BLOCK_SIZE bsize , int use_rd ) {const VP9_COMMON * const cm = & cpi -> common ;const int refresh_this_block = candidate_refresh_aq ( cr , mbmi , bsize , use_rd ) ;int new_map_value = cr -> map [ block_index ] ;if ( mbmi -> segment_id > 0 && ! refresh_this_block )  mbmi -> segment_id = 0 ;if ( mbmi -> segment_id == 1 ) {new_map_value = - cr -> time_for_refresh ;","void vp9_cyclic_refresh_update_segment ( VP9_COMP * const cpi , MB_MODE_INFO * const mbmi , int mi_row , int mi_col , BLOCK_SIZE bsize , int64_t rate , int64_t dist , int skip ) {const VP9_COMMON * const cm = & cpi -> common ;const int refresh_this_block = candidate_refresh_aq ( cr , mbmi , rate , dist , bsize ) ;int new_map_value = cr -> map [ block_index ] ;if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) {mbmi -> segment_id = refresh_this_block ;if ( skip ) mbmi -> segment_id = CR_SEGMENT_ID_BASE ;}if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) {new_map_value = - cr -> time_for_refresh ;",5592
2104,cr -> map [ block_index + y * cm -> mi_cols + x ] = new_map_value ;cpi -> segmentation_map [ block_index + y * cm -> mi_cols + x ] =  mbmi -> segment_id ;if ( mbmi -> segment_id ) cr -> num_seg_blocks += xmis * ymis ;,"int map_offset = block_index + y * cm -> mi_cols + x ;cr -> map [ map_offset ] = new_map_value ;cpi -> segmentation_map [ map_offset ] = mbmi -> segment_id ;if ( ! is_inter_block ( mbmi ) || ! skip ) cr -> last_coded_q_map [ map_offset ] = clamp ( cm -> base_qindex + cr -> qindex_delta [ mbmi -> segment_id ] , 0 , MAXQ ) ;",5592
2105,"static char * create_output_name ( unsigned char * fname , unsigned char * dir ,  int lower , int isunix , int utf8 ) {unsigned char * p , * name , c , * fe , sep , slash ;unsigned int x ;sep = ( isunix ) ? \'/\' : \'\\\\\\\\\' ;slash = ( isunix ) ? \'\\\\\\\\\' : \'/\' ;x = strlen ( ( char * ) fname ) ;if ( utf8 ) x *= 3 ;if ( dir ) x += strlen ( ( char * ) dir ) ;fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\\return NULL ;while ( * fname == sep ) fname ++ ;p = & name [ strlen ( ( char * ) name ) ] ;fe = & fname [ strlen ( ( char * ) fname ) ] ;if ( utf8 ) {do {if ( fname >= fe ) {free ( name ) ;if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) {x = ( c & 0x1F ) << 6 ;x |= * fname ++ & 0x3F ;}else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) {x = ( c & 0xF ) << 12 ;x |= ( * fname ++ & 0x3F ) << 6 ;x |= * fname ++ & 0x3F ;}else x = \'?\' ;}if ( x == sep ) x = \'/\' ;else if ( x == slash ) x = \'\\\\\\\\\' ;else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ;if ( x < 0x80 ) {* p ++ = ( unsigned char ) x ;}else if ( x < 0x800 ) {* p ++ = 0xC0 | ( x >> 6 ) ;* p ++ = 0x80 | ( x & 0x3F ) ;}else {* p ++ = 0xE0 | ( x >> 12 ) ;* p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ;* p ++ = 0x80 | ( x & 0x3F ) ;}while ( x ) ;}else {do {c = * fname ++ ;if ( c == sep ) c = \'/\' ;else if ( c == slash ) c = \'\\\\\\\\\' ;else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ;while ( ( * p ++ = c ) ) ;return ( char * ) name ;","char * create_output_name ( unsigned char * fname ) {char * out , * p ;if ( utf8 ) x *= 3 ;if ( dir ) x += strlen ( ( char * ) dir ) ;fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\\return NULL ;while ( * fname == \'/\' || * fname == \'\\\\\\\\\' ) fname ++ ;strcpy ( out , ( * fname ) ? fname : ""x"" ) ;for ( p = out ;* p ;p ++ ) {if ( fname >= fe ) {free ( name ) ;if ( p [ 0 ] == \'.\' && p [ 1 ] == \'.\' && ( p [ 2 ] == \'/\' || p [ 2 ] == \'\\\\\\\\\' ) ) {p [ 0 ] = p [ 1 ] = \'x\' ;return out ;",5593
2106,"ERR ( ""callocing<S2SV_blank>this<S2SV_blank>failed"" ) ;goto error ;this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ;if ( this -> sd < 0 ) {ERR ( ""sockect<S2SV_blank>open<S2SV_blank>failed"" ) ;goto error ;struct sockaddr_in6 addr ;addr . sin6_family = AF_INET6 ;addr . sin6_port = htons ( port ) ;addr . sin6_addr = in6addr_any ;if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) {if ( g_options . only_desired_port == 1 )  ERR ( ""Bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>""  ""Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions."" ) ;ERR ( ""listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ;goto error ;","ERR ( ""IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed"" ) ;goto error ;this -> sd = socket ( AF_INET , SOCK_STREAM , 0 ) ;if ( this -> sd < 0 ) {ERR ( ""IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed"" ) ;goto error ;struct sockaddr_in addr ;addr . sin_family = AF_INET ;addr . sin_port = htons ( port ) ;addr . sin_addr . s_addr = htonl ( 0x7F000001 ) ;if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) {if ( g_options . only_desired_port == 1 ) ERR ( ""IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" ""Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions."" ) ;ERR ( ""IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ;goto error ;",5594
2107,"aeDeleteFileEvent ( server . el , c -> fd , AE_READABLE ) ;aeDeleteFileEvent ( server . el , c -> fd , AE_WRITABLE ) ;listRelease ( c -> reply ) ;freeClientArgv ( c ) ;close ( c -> fd ) ;ln = listSearchKey ( server . clients , c ) ;redisAssert ( ln != NULL ) ;listDelNode ( server . clients , ln ) ;redisAssert ( server . vm_enabled ) ;if ( listLength ( c -> io_keys ) == 0 ) {",aeDeleteFileEvent ( server . ds_enabled ) ;redisAssert ( server . vm_enabled ) ;if ( listLength ( c -> io_keys ) == 0 ) {,5595
2108,server . vm_blocked_clients -- ;},server . cache_blocked_clients -- ;},5595
2109,"void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc ,   int length , int offset , int total_size )  {","void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , u8 status , const u8 * desc , u8 length , u16 offset , u16 total_size ) {",5596
2110,int copy_len ;int required_size = urb -> transfer_buffer_length ;if ( required_size > total_size ) required_size = total_size ;,unsigned int copy_len ;unsigned int required_size = urb -> transfer_buffer_length ;if ( required_size > total_size ) required_size = total_size ;,5596
2111,"info . flags = VFIO_DEVICE_FLAGS_PCI ;if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ;info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ;info . num_irqs = VFIO_PCI_NUM_IRQS ;return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) {struct pci_dev * pdev = vdev -> pdev ;struct vfio_region_info info ;struct vfio_info_cap caps = {. buf = NULL , . size = 0 };int i , ret ;minsz = offsetofend ( struct vfio_region_info , offset ) ;if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( info . argsz < minsz ) return - EINVAL ;switch ( info . index ) {case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = pdev -> cfg_size ;info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;break ;case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = pci_resource_len ( pdev , info . index ) ;if ( ! info . size ) {info . flags = 0 ;break ;}info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;if ( vdev -> bar_mmap_supported [ info . index ] ) {info . flags |= VFIO_REGION_INFO_FLAG_MMAP ;if ( info . index == vdev -> msix_bar ) {ret = msix_sparse_mmap_cap ( vdev , & caps ) ;if ( ret ) return ret ;}}case VFIO_PCI_ROM_REGION_INDEX : {void __iomem * io ;size_t size ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . flags = 0 ;info . size = pci_resource_len ( pdev , info . index ) ;if ( ! info . size ) {if ( pdev -> resource [ PCI_ROM_RESOURCE ] . flags & IORESOURCE_ROM_SHADOW ) info . size = 0x20000 ;else break ;}io = pci_map_rom ( pdev , & size ) ;if ( ! io || ! size ) {info . size = 0 ;}pci_unmap_rom ( pdev , io ) ;info . flags = VFIO_REGION_INFO_FLAG_READ ;}case VFIO_PCI_VGA_REGION_INDEX : if ( ! vdev -> has_vga ) return - EINVAL ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = 0xc0000 ;info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;break ;default : if ( info . index >= VFIO_PCI_NUM_REGIONS + vdev -> num_regions ) return - EINVAL ;i = info . index - VFIO_PCI_NUM_REGIONS ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = vdev -> region [ i ] . size ;info . flags = vdev -> region [ i ] . flags ;ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ;if ( ret ) return ret ;}if ( caps . size ) {info . flags |= VFIO_REGION_INFO_FLAG_CAPS ;if ( info . argsz < sizeof ( info ) + caps . size ) {info . argsz = sizeof ( info ) + caps . size ;info . cap_offset = 0 ;}else {vfio_info_cap_shift ( & caps , sizeof ( info ) ) ;if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) {kfree ( caps . buf ) ;return - EFAULT ;}info . cap_offset = sizeof ( info ) ;}kfree ( caps . buf ) ;}return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_GET_IRQ_INFO ) {struct vfio_irq_info info ;minsz = offsetofend ( struct vfio_irq_info , count ) ;if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( info . argsz < minsz || info . index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ;switch ( info . index ) {case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX : case VFIO_PCI_REQ_IRQ_INDEX : break ;case VFIO_PCI_ERR_IRQ_INDEX : if ( pci_is_pcie ( vdev -> pdev ) ) break ;info . flags = VFIO_IRQ_INFO_EVENTFD ;info . count = vfio_pci_get_irq_count ( vdev , info . index ) ;if ( info . index == VFIO_PCI_INTX_IRQ_INDEX ) info . flags |= ( VFIO_IRQ_INFO_MASKABLE | VFIO_IRQ_INFO_AUTOMASKED ) ;else info . flags |= VFIO_IRQ_INFO_NORESIZE ;return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_SET_IRQS ) {struct vfio_irq_set hdr ;u8 * data = NULL ;int ret = 0 ;minsz = offsetofend ( struct vfio_irq_set , count ) ;if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( hdr . argsz < minsz || hdr . index >= VFIO_PCI_NUM_IRQS ||  hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK |  VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ;if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) {size_t size ;int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL )  size = sizeof ( uint8_t ) ;else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ;else return - EINVAL ;if ( hdr . argsz - minsz < hdr . count * size ||  hdr . start >= max || hdr . start + hdr . count > max )  return - EINVAL ;","max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) size = sizeof ( uint8_t ) ;else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ;else return - EINVAL ;if ( hdr . argsz - minsz < hdr . count * size || hdr . start >= max || hdr . start + hdr . count > max ) return - EINVAL ;switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) {case VFIO_IRQ_SET_DATA_NONE : size = 0 ;case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ;case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ;if ( size ) {if ( hdr . argsz - minsz < hdr . count * size ) return - EINVAL ;",5597
2112,"
",if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) {PUSH_ENV ( HTML_DL ) ;},5598
2113,"if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) {if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ;","if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) {if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ;",5598
2114,while ( buflen > 0 ) {union_desc = ( struct usb_cdc_union_desc * ) buf ;return union_desc ;},"while ( buflen >= sizeof ( * union_desc ) ) {union_desc = ( struct usb_cdc_union_desc * ) buf ;if ( union_desc -> bLength > buflen ) {dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\\return NULL ;}if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ;dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\\return NULL ;}",5599
2115,static int sd_isoc_init ( struct gspca_dev * gspca_dev )  {struct usb_host_interface * alt ;,static int sd_isoc_init ( struct gspca_dev * gspca_dev ) {struct usb_interface_cache * intfc ;struct usb_host_interface * alt ;,5600
2116,alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ;alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( max_packet_size ) ;,intfc = gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] ;if ( intfc -> num_altsetting < 2 ) return - ENODEV ;alt = & intfc -> altsetting [ 1 ] ;if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( max_packet_size ) ;,5600
2117,head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ;track_shift = 2 * head_shift + 3 ;,if ( ! F_SECT_PER_TRACK ) return ;head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ;track_shift = 2 * head_shift + 3 ;,5601
2118,"if ( copy_from_user ( & sas , optval , len ) )  return - EFAULT ;","len = min_t ( size_t , len , sizeof ( sas ) ) ;if ( copy_from_user ( & sas , optval , len ) ) return - EFAULT ;",5602
2119,"len = min_t ( size_t , len , sizeof ( sas ) ) ;if ( put_user ( len , optlen ) ) return - EFAULT ;","if ( put_user ( len , optlen ) ) return - EFAULT ;",5602
2120,"if ( buf )   _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;out_ok : ret = res . acl_len ;","if ( buf ) {if ( res . acl_len > buflen ) {ret = - ERANGE ;goto out_free ;}_copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;}out_ok : ret = res . acl_len ;",5603
2121,"pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ;if ( rv )  fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\fs_logger2 ( ""clone"" , dest ) ;}","copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\fs_logger2 ( ""clone"" , dest ) ;}",5604
2122,"if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ;if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ;if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ;size = max ( hdr . size_in , hdr . size_out ) ;if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ;if ( size > SZ_16M ) return - E2BIG ;is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ;if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ;else buf = kmalloc ( size , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) {ret = - EFAULT ;","if ( copy_from_user ( & hdr , ( void * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) ) ) {ret = - EFAULT ;",5605
2123,"static int bson_string_is_db_ref ( const unsigned char * string , const int length ) {int result = 0 ;","static int bson_string_is_db_ref ( const unsigned char * string , const size_t length ) {int result = 0 ;",5606
2124,"# define ThrowDCMException ( exception , message ) {","# define ThrowDCMException ( exception , message ) \\\\\",5607
2125,"}char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;","\\\\\char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;",5607
2126,"data = ( unsigned char * ) NULL ;if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ;else if ( ( length == 1 ) && ( quantum == 2 ) ) {if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ;else datum = ReadBlobSignedShort ( image ) ;}else if ( ( length == 1 ) && ( quantum == 4 ) ) {if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ;else datum = ReadBlobSignedLong ( image ) ;}else if ( ( quantum != 0 ) && ( length != 0 ) ) {if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ;if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , ( size_t ) quantum * length , data ) ;if ( count != ( ssize_t ) ( quantum * length ) ) {if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\\ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;}data [ length * quantum ] = \'\\\\0\' ;}if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) {if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;continue ;}switch ( group ) {case 0x0002 : {switch ( element ) {case 0x0010 : {char transfer_syntax [ MagickPathExtent ] ;if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) {explicit_retry = MagickTrue ;( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ;group = 0 ;element = 0 ;if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\break ;}* transfer_syntax = \'\\\\0\' ;if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ;if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\\if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) {int subtype , type ;type = 1 ;subtype = 0 ;if ( strlen ( transfer_syntax ) > 17 ) {count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ;if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;}switch ( type ) {case 1 : {image -> endian = LSBEndian ;break ;}case 2 : {image -> endian = MSBEndian ;break ;}case 4 : {if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ;else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ;else image -> compression = JPEGCompression ;break ;}case 5 : {image -> compression = RLECompression ;break ;}}}break ;}default : break ;}break ;}case 0x0028 : {switch ( element ) {case 0x0002 : {info . samples_per_pixel = ( size_t ) datum ;if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;break ;}case 0x0004 : {if ( data == ( unsigned char * ) NULL ) break ;for ( i = 0 ;i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ;i ++ ) photometric [ i ] = ( char ) data [ i ] ;photometric [ i ] = \'\\\\0\' ;info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ;break ;}case 0x0006 : {if ( datum == 1 ) image -> interlace = PlaneInterlace ;break ;}case 0x0008 : {if ( data == ( unsigned char * ) NULL ) break ;number_scenes = StringToUnsignedLong ( ( char * ) data ) ;break ;}case 0x0010 : {height = ( size_t ) datum ;break ;}case 0x0011 : {width = ( size_t ) datum ;break ;}case 0x0100 : {info . bits_allocated = ( size_t ) datum ;info . bytes_per_pixel = 1 ;if ( datum > 8 ) info . bytes_per_pixel = 2 ;info . depth = info . bits_allocated ;if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;info . max_value = ( 1UL << info . bits_allocated ) - 1 ;image -> depth = info . depth ;break ;}case 0x0101 : {info . significant_bits = ( size_t ) datum ;info . bytes_per_pixel = 1 ;if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ;info . depth = info . significant_bits ;if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;info . max_value = ( 1UL << info . significant_bits ) - 1 ;info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ;image -> depth = info . depth ;break ;}case 0x0102 : {break ;}case 0x0103 : {info . signed_data = ( size_t ) datum ;break ;}case 0x1050 : {if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ;break ;}case 0x1051 : {if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ;break ;}case 0x1052 : {if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ;break ;}case 0x1053 : {if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ;break ;}case 0x1200 : case 0x3006 : {if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / info . bytes_per_pixel ) ;datum = ( int ) colors ;if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ;graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ;if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ;else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ;break ;}case 0x1201 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ;redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ;if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;redmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1202 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ;greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ;if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;greenmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1203 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ;bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ;if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;bluemap [ i ] = ( int ) index ;p += 2 ;}break ;}default : break ;}break ;}case 0x2050 : {switch ( element ) {case 0x0020 : {if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ;break ;}default : break ;}break ;}default : break ;}if ( data != ( unsigned char * ) NULL ) {char * attribute ;for ( i = 0 ;dicom_info [ i ] . description != ( char * ) NULL ;i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ;if ( dicom_info [ i ] . description != ( char * ) NULL ) {attribute = AcquireString ( ""dcm:"" ) ;( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ;for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) {( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ;( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ;}attribute = DestroyString ( attribute ) ;}}if ( image_info -> verbose != MagickFalse ) {if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\\else {for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) {ssize_t j ;datum = 0 ;for ( j = ( ssize_t ) length - 1 ;j >= 0 ;j -- ) datum = ( 256 * datum + data [ j ] ) ;( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ;}else for ( i = 0 ;i < ( ssize_t ) length ;i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ;else ( void ) FormatLocaleFile ( stdout , ""%c"" , \'.\' ) ;( void ) FormatLocaleFile ( stdout , ""\\\}}if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}}if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) {Image * last ;last = RemoveLastImageFromList ( & image ) ;if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ;break ;}if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ;if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) {Image * images ;ImageInfo * read_info ;int c ;for ( i = 0 ;i < ( ssize_t ) stream_info -> remaining ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ;length = ( size_t ) ReadBlobLSBLong ( image ) ;if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;stream_info -> offset_count = length >> 2 ;if ( stream_info -> offset_count != 0 ) {if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ;stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ;if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;offset = TellBlob ( image ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] += offset ;}read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;images = NewImageList ( ) ;for ( scene = 0 ;scene < ( ssize_t ) number_scenes ;scene ++ ) {char filename [ MagickPathExtent ] ;const char * property ;FILE * file ;Image * jpeg_image ;int unique_file ;unsigned int tag ;tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ;length = ( size_t ) ReadBlobLSBLong ( image ) ;if ( tag == 0xFFFEE0DD ) break ;if ( tag != 0xFFFEE000 ) {read_info = DestroyImageInfo ( read_info ) ;ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;}file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( file == ( FILE * ) NULL ) {( void ) RelinquishUniqueFileResource ( filename ) ;ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ;break ;}for ( c = EOF ;length != 0 ;length -- ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",5607
2127,"static int detect_flash ( const struct twopass_rc * twopass , int offset ) {FIRSTPASS_STATS next_frame ;int flash_detected = 0 ;if ( read_frame_stats ( twopass , & next_frame , offset ) != EOF ) {if ( next_frame . pcnt_second_ref > next_frame . pcnt_inter &&   next_frame . pcnt_second_ref >= 0.5 )  flash_detected = 1 ;}return flash_detected ;","static int detect_flash ( const TWO_PASS * twopass , int offset ) {const FIRSTPASS_STATS * const next_frame = read_frame_stats ( twopass , & next_frame , offset ) != EOF ) {if ( next_frame . pcnt_second_ref > next_frame -> pcnt_inter && next_frame . pcnt_second_ref >= 0.5 ;",5608
2128,}else  inode -> i_gid = current_fsgid ( ) ;,"else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;}else inode -> i_gid = current_fsgid ( ) ;",5609
2129,cl -> wsctx = ( wsCtx * ) wsctx ;return TRUE ;,hybiDecodeCleanup ( wsctx ) ;cl -> wsctx = ( wsCtx * ) wsctx ;return TRUE ;,5610
2130,"ret = - EEXIST ;if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ;if ( vm_shared ) {page_dup_rmap ( page , true ) ;}else {ClearPagePrivate ( page ) ;hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ;}_dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ;if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ;_dst_pte = pte_mkyoung ( _dst_pte ) ;set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ;( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ;hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ;update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ;spin_unlock ( ptl ) ;ret = 0 ;out : return ret ;out_release_unlock : spin_unlock ( ptl ) ;out_release_nounlock :  if ( vm_shared ) unlock_page ( page ) ;put_page ( page ) ;",out_release_nounlock : put_page ( page ) ;,5611
2131,"struct variable_list * vb ;const data_set_t * ds ;size_t oid_list_len = data -> values_len + 1 ;oid_t oid_list [ oid_list_len ] ;_Bool oid_list_todo [ oid_list_len ] ;int status ;size_t i ;csnmp_list_instances_t * instance_list_head ;csnmp_list_instances_t * instance_list_tail ;csnmp_table_values_t * * value_list_head ;csnmp_table_values_t * * value_list_tail ;DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table<S2SV_blank>(host<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>data<S2SV_blank>=<S2SV_blank>%s)"" , host -> name , data -> name ) ;if ( host -> sess_handle == NULL ) {DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table:<S2SV_blank>host->sess_handle<S2SV_blank>==<S2SV_blank>NULL"" ) ;return ( - 1 ) ;}ds = plugin_get_ds ( data -> type ) ;if ( ! ds ) {ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>DataSet<S2SV_blank>`%s\\\'<S2SV_blank>not<S2SV_blank>defined."" , data -> type ) ;return ( - 1 ) ;}if ( ds -> ds_num != data -> values_len ) {ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>DataSet<S2SV_blank>`%s\\\'<S2SV_blank>requires<S2SV_blank>%zu<S2SV_blank>values,<S2SV_blank>but<S2SV_blank>config<S2SV_blank>talks<S2SV_blank>"" ""about<S2SV_blank>%zu"" , data -> type , ds -> ds_num , data -> values_len ) ;return ( - 1 ) ;}assert ( data -> values_len > 0 ) ;memcpy ( oid_list , data -> values , data -> values_len * sizeof ( oid_t ) ) ;if ( data -> instance . oid . oid_len > 0 ) memcpy ( oid_list + data -> values_len , & data -> instance . oid , sizeof ( oid_t ) ) ;else oid_list_len -- ;for ( i = 0 ;i < oid_list_len ;i ++ ) oid_list_todo [ i ] = 1 ;value_list_head = calloc ( data -> values_len , sizeof ( * value_list_head ) ) ;value_list_tail = calloc ( data -> values_len , sizeof ( * value_list_tail ) ) ;if ( ( value_list_head == NULL ) || ( value_list_tail == NULL ) ) {ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table:<S2SV_blank>calloc<S2SV_blank>failed."" ) ;sfree ( value_list_head ) ;sfree ( value_list_tail ) ;return ( - 1 ) ;}instance_list_head = NULL ;instance_list_tail = NULL ;status = 0 ;while ( status == 0 ) {int oid_list_todo_num ;req = snmp_pdu_create ( SNMP_MSG_GETNEXT ) ;if ( req == NULL ) {ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>snmp_pdu_create<S2SV_blank>failed."" ) ;status = - 1 ;break ;}oid_list_todo_num = 0 ;for ( i = 0 ;i < oid_list_len ;i ++ ) {if ( ! oid_list_todo [ i ] ) continue ;oid_list_todo_num ++ ;snmp_add_null_var ( req , oid_list [ i ] . oid , oid_list [ i ] . oid_len ) ;}if ( oid_list_todo_num == 0 ) {DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree"" ) ;status = 0 ;break ;}res = NULL ;status = snmp_sess_synch_response ( host -> sess_handle , req , & res ) ;if ( ( status != STAT_SUCCESS ) || ( res == NULL ) ) {char * errstr = NULL ;snmp_sess_error ( host -> sess_handle , NULL , NULL , & errstr ) ;c_complain ( LOG_ERR , & host -> complaint , ""snmp<S2SV_blank>plugin:<S2SV_blank>host<S2SV_blank>%s:<S2SV_blank>snmp_sess_synch_response<S2SV_blank>failed:<S2SV_blank>%s"" , host -> name , ( errstr == NULL ) ? ""Unknown<S2SV_blank>problem"" : errstr ) ;if ( res != NULL ) snmp_free_pdu ( res ) ;res = NULL ;req = NULL ;sfree ( errstr ) ;",sfree ( errstr ) ;,5612
2132,if ( req != NULL )  snmp_free_pdu ( req ) ;req = NULL ;,"
",5612
2133,int m ;m = n ;,"int m ;if ( n < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ;}m = n ;",5613
2134,"# if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> option . client ) section -> ctx = SSL_CTX_new ( TLS_client_method ( ) ) ;else section -> ctx = SSL_CTX_new ( TLS_server_method ( ) ) ;if ( ! SSL_CTX_set_min_proto_version ( section -> ctx , section -> min_proto_version ) ) {s_log ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>minimum<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>0x%X"" , section -> min_proto_version ) ;return 1 ;}if ( ! SSL_CTX_set_max_proto_version ( section -> ctx , section -> max_proto_version ) ) {s_log ( LOG_ERR , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>0x%X"" , section -> max_proto_version ) ;return 1 ;}# else if ( section -> option . client ) section -> ctx = SSL_CTX_new ( section -> client_method ) ;else section -> ctx = SSL_CTX_new ( section -> server_method ) ;# endif if ( ! section -> ctx ) {sslerror ( ""SSL_CTX_new"" ) ;return 1 ;}if ( ! SSL_CTX_set_ex_data ( section -> ctx , index_ssl_ctx_opt , section ) ) {sslerror ( ""SSL_CTX_set_ex_data"" ) ;return 1 ;}current_section = section ;if ( section -> cipher_list ) {s_log ( LOG_DEBUG , ""Ciphers:<S2SV_blank>%s"" , section -> cipher_list ) ;if ( ! SSL_CTX_set_cipher_list ( section -> ctx , section -> cipher_list ) ) {sslerror ( ""SSL_CTX_set_cipher_list"" ) ;return 1 ;}}# ifndef OPENSSL_NO_TLS1_3 if ( section -> ciphersuites ) {s_log ( LOG_DEBUG , ""TLSv1.3<S2SV_blank>ciphersuites:<S2SV_blank>%s"" , section -> ciphersuites ) ;if ( ! SSL_CTX_set_ciphersuites ( section -> ctx , section -> ciphersuites ) ) {sslerror ( ""SSL_CTX_set_ciphersuites"" ) ;return 1 ;}}# endif SSL_CTX_set_options ( section -> ctx , SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 ) ;# ifdef SSL_OP_NO_COMPRESSION SSL_CTX_clear_options ( section -> ctx , SSL_OP_NO_COMPRESSION ) ;# endif SSL_CTX_set_options ( section -> ctx , ( SSL_OPTIONS_TYPE ) ( section -> ssl_options_set ) ) ;# if OPENSSL_VERSION_NUMBER >= 0x009080dfL SSL_CTX_clear_options ( section -> ctx , ( SSL_OPTIONS_TYPE ) ( section -> ssl_options_clear ) ) ;# endif # if OPENSSL_VERSION_NUMBER >= 0x009080dfL s_log ( LOG_DEBUG , ""TLS<S2SV_blank>options:<S2SV_blank>0x%08lX<S2SV_blank>(+0x%08lX,<S2SV_blank>-0x%08lX)"" , SSL_CTX_get_options ( section -> ctx ) , section -> ssl_options_set , section -> ssl_options_clear ) ;# else s_log ( LOG_DEBUG , ""TLS<S2SV_blank>options:<S2SV_blank>0x%08lX<S2SV_blank>(+0x%08lX)"" , SSL_CTX_get_options ( section -> ctx ) , section -> ssl_options_set ) ;# endif if ( conf_init ( section ) ) return 1 ;# ifdef SSL_MODE_RELEASE_BUFFERS SSL_CTX_set_mode ( section -> ctx , SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_RELEASE_BUFFERS ) ;# else SSL_CTX_set_mode ( section -> ctx , SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER ) ;# endif # if OPENSSL_VERSION_NUMBER >= 0x10101000L SSL_CTX_set_session_ticket_cb ( section -> ctx , generate_session_ticket_cb , decrypt_session_ticket_cb , NULL ) ;# endif # if OPENSSL_VERSION_NUMBER >= 0x10000000L if ( ( section -> ticket_key ) && ( section -> ticket_mac ) ) SSL_CTX_set_tlsext_ticket_key_cb ( section -> ctx , ssl_tlsext_ticket_key_cb ) ;# endif if ( ! section -> option . client ) {unsigned servname_len = ( unsigned ) strlen ( section -> servname ) ;if ( servname_len > SSL_MAX_SSL_SESSION_ID_LENGTH ) servname_len = SSL_MAX_SSL_SESSION_ID_LENGTH ;if ( ! SSL_CTX_set_session_id_context ( section -> ctx , ( unsigned char * ) section -> servname , servname_len ) ) {sslerror ( ""SSL_CTX_set_session_id_context"" ) ;return 1 ;}}SSL_CTX_set_session_cache_mode ( section -> ctx , SSL_SESS_CACHE_BOTH | SSL_SESS_CACHE_NO_INTERNAL_STORE ) ;SSL_CTX_sess_set_cache_size ( section -> ctx , section -> session_size ) ;SSL_CTX_set_timeout ( section -> ctx , section -> session_timeout ) ;SSL_CTX_sess_set_new_cb ( section -> ctx , sess_new_cb ) ;SSL_CTX_sess_set_get_cb ( section -> ctx , sess_get_cb ) ;SSL_CTX_sess_set_remove_cb ( section -> ctx , sess_remove_cb ) ;SSL_CTX_set_info_callback ( section -> ctx , info_callback ) ;if ( auth_init ( section ) ) return 1 ;if ( verify_init ( section ) ) return 1 ;if ( ! section -> option . client ) {# ifndef OPENSSL_NO_TLSEXT SSL_CTX_set_tlsext_servername_callback ( section -> ctx , servername_cb ) ;# endif  }return 0 ;","# if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> option . client ) SSL_CTX_set_tlsext_servername_callback ( section -> ctx , servername_cb ) ;# endif }return 0 ;",5614
2135,"static void  ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ;}if ( ( length + 1 ) & 3 )  ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ;ptr = cp [ 2 ] - 1 ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ;if ( ptr > len ) ND_PRINT ( ( ndo , "","" ) ) ;}}","static int ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ( 0 ) ;}if ( ( length + 1 ) & 3 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ;ND_TCHECK ( cp [ 2 ] ) ;ptr = cp [ 2 ] - 1 ;ND_TCHECK2 ( cp [ len ] , 4 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ;if ( ptr > len ) ND_PRINT ( ( ndo , "","" ) ) ;}return ( 0 ) ;trunc : return ( - 1 ) ;}",5615
2136,if ( cpi -> pass == 2 ) {,Adjustment = ( cpi -> pass == 2 ) {,5616
2137,if ( cpi -> frames_since_golden == ( cpi -> current_gf_interval >> 1 ) )  cpi -> this_frame_target += ( ( cpi -> current_gf_interval - 1 ) * Adjustment ) ;else cpi -> this_frame_target -= Adjustment ;,if ( cpi -> frames_since_golden == ( cpi -> current_gf_interval >> 1 ) ) cpi -> this_frame_target += ( ( cpi -> current_gf_interval - 1 ) * Adjustment ;if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ;cpi -> this_frame_target += Adjustment ;}else cpi -> this_frame_target -= Adjustment ;,5616
2138,"if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) {* status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ;","if ( check_anon ( kdc_active_realm , client . princ , request -> server ) != 0 ) {* status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ;",5617
2139,facilities_len -= len + 1 ;p += len + 1 ;facilities_len -= len + 1 ;p += len + 1 ;,if ( len < 0 ) return 0 ;facilities_len -= len + 1 ;p += len + 1 ;if ( len < 0 ) return 0 ;facilities_len -= len + 1 ;p += len + 1 ;,5618
2140,"if ( ! capable ( CAP_NET_ADMIN ) )   return - EPERM ;if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) {if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 )  return - EFAULT ;","unsigned int copylen ;if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL ;if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) {copylen = get_arglen [ GET_CMDID ( cmd ) ] ;if ( copylen > 128 ) return - EINVAL ;if ( copy_from_user ( arg , user , copylen ) != 0 ) return - EFAULT ;",5619
2141,"
","if ( ! ND_TTEST2 ( * bp , 2 ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ;return ;}",5620
2142,opt_type = * bp ++ ;opt_len = * bp ++ ;,opt_type = * bp ++ ;opt_len = * bp ++ ;,5620
2143,"void vp9_rd_pick_intra_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x ,  int * returnrate , int64_t * returndist ,  BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) {int rate_y = 0 , rate_uv = 0 , rate_y_tokenonly = 0 , rate_uv_tokenonly = 0 ;int y_skip = 0 , uv_skip = 0 ;int64_t dist_y = 0 , dist_uv = 0 , tx_cache [ TX_MODES ] = {0 };TX_SIZE max_uv_tx_size ;if ( bsize >= BLOCK_8X8 ) {if ( rd_pick_intra_sby_mode ( cpi , x , & rate_y , & rate_y_tokenonly ,  & dist_y , & y_skip , bsize , tx_cache ,  best_rd ) >= best_rd ) {* returnrate = INT_MAX ;return ;}max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi . tx_size , bsize ) ;rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly ,  & dist_uv , & uv_skip , bsize , max_uv_tx_size ) ;}else {y_skip = 0 ;if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) {rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly , & dist_uv , & uv_skip , BLOCK_8X8 , max_uv_tx_size ) ;if ( y_skip && uv_skip ) {* returnrate = rate_y + rate_uv - rate_y_tokenonly - rate_uv_tokenonly +  vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;* returndist = dist_y + dist_uv ;vp9_zero ( ctx -> tx_rd_diff ) ;}int i ;* returnrate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;* returndist = dist_y + dist_uv ;if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ;i < TX_MODES ;i ++ ) {if ( tx_cache [ i ] < INT64_MAX && tx_cache [ cm -> tx_mode ] < INT64_MAX ) ctx -> tx_rd_diff [ i ] = tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ;else ctx -> tx_rd_diff [ i ] = 0 ;","void vp9_rd_pick_intra_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) {struct macroblockd_plane * const pd = xd -> plane ;int rate_y = 0 , rate_uv = 0 , rate_y_tokenonly = 0 , rate_uv_tokenonly = 0 ;int y_skip = 0 , uv_skip = 0 ;int64_t dist_y = 0 , dist_uv = 0 ;TX_SIZE max_uv_tx_size ;xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ;if ( bsize >= BLOCK_8X8 ) {if ( rd_pick_intra_sby_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , & y_skip , bsize , best_rd ) >= best_rd ) {rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly , & dist_uv , & uv_skip , bsize , max_uv_tx_size ) ;}else {y_skip = 0 ;if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) {rd_cost -> rate = INT_MAX ;return ;}y_skip = 0 ;if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) {rd_cost -> rate = INT_MAX ;return ;}max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi . tx_size , bsize , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y ) ;rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly , & dist_uv , & uv_skip , MAX ( BLOCK_8X8 , bsize ) , max_uv_tx_size ) ;if ( y_skip && uv_skip ) {rd_cost -> rate = rate_y + rate_uv - rate_y_tokenonly - rate_uv_tokenonly + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;rd_cost -> dist = dist_y + dist_uv ;}else {rd_cost -> rate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;rd_cost -> dist = dist_y + dist_uv ;ctx -> mbmi_ext = * x -> mbmi_ext ;rd_cost -> rdcost = RDCOST ( x -> rdmult , x -> rddiv , rd_cost -> rate , rd_cost -> dist ) ;",5621
2144,kern_msg -> msg_name = kern_address ;},if ( kern_msg -> msg_name ) kern_msg -> msg_name = kern_address ;},5622
2145,"while ( ( c = ReadBlobByte ( image ) ) != EOF )  ( void ) fputc ( c , file ) ;( void ) fclose ( file ) ;","while ( ( c = ReadBlobByte ( image ) ) != EOF ) if ( fputc ( c , file ) != c ) break ;( void ) fclose ( file ) ;",5623
2146,"pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ;void * memory ;","pgprot_t prot = __get_dma_pgprot ( attrs , PAGE_KERNEL ) ;void * memory ;",5624
2147,assert ( bidx <= PCI_BARMAX ) ;assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 ||   pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ;assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ;,"if ( addr + size > pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . size ) {printf ( ""%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range.\\\return - ESRCH ;}",5625
2148,if ( sk != asoc -> base . sk )  goto do_error ;,"
",5626
2149,if ( image_info -> ping ) goto Finish ;if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ;,"if ( image_info -> ping != MagickFalse ) goto Finish ;status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ;",5627
2150,"for ( col = 0 ;col < imagewidth ;if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) {","for ( col = 0 ;col < imagewidth && colb < imagew ;if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) {",5628
2151,"pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows *  number_planes_filled * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * number_planes_filled ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;","pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;",5629
2152,m -> msg_name = address ;},if ( m -> msg_name ) m -> msg_name = address ;},5630
2153,* sent = 0 ;if ( ssocket == NULL ) return - ENOTSOCK ;,* sent = 0 ;,5631
2154,"u8 smac [ ETH_ALEN ] ;u8 alt_smac [ ETH_ALEN ] ;u8 * psmac = smac ;u8 * palt_smac = alt_smac ;int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ;","
",5632
2155,"if ( is_iboe ) {if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ;else psmac = NULL ;if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ;else palt_smac = NULL ;}mutex_lock ( & lock ) ;if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ;","mutex_lock ( & lock ) ;if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ;",5632
2156,"static int t220_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ 3 ] = {0xe , 0x87 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x86 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x80 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 50 ) ;obuf [ 0 ] = 0xe ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config ,   & d -> dev -> i2c_adap , NULL ) ;if ( d -> fe_adap [ 0 ] . fe != NULL ) {if ( dvb_attach ( tda18271_attach , d -> fe_adap [ 0 ] . fe , 0x60 ,   & d -> dev -> i2c_adap , & tda18271_config ) ) {info ( ""Attached<S2SV_blank>TDA18271HD/CXD2820R!"" ) ;","static int t220_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x87 ;state -> data [ 2 ] = 0x0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x86 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 50 ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config , & d -> i2c_adap , NULL ) ;if ( d -> fe_adap [ 0 ] . fe != NULL ) {if ( dvb_attach ( tda18271_attach , adap -> fe_adap [ 0 ] . fe , 0x60 , & d -> i2c_adap , & tda18271_config ) ) {info ( ""Attached<S2SV_blank>TDA18271HD/CXD2820R!"" ) ;",5633
2157,"if ( cpu_id != RING_BUFFER_ALL_CPUS && ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) return size ;size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ;size *= BUF_PAGE_SIZE ;","nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ;if ( nr_pages < 2 ) nr_pages = 2 ;size = nr_pages * BUF_PAGE_SIZE ;",5634
2158,"static void  horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 2 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 2 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc16"" , ""%s"" , ""cc%(2*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",5635
2159,},return 1 ;},5635
2160,if ( ! * passwd || ! * user -> passwd )  return false ;,"if ( ! user ) {slog_error ( client , ""Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?"" ) ;return false ;}if ( ! * passwd || ! * user -> passwd ) return false ;",5636
2161,char * buf ;pkglen = s -> end - s -> p ;,"char * buf ;struct stream packet = * s ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ;}pkglen = s -> end - s -> p ;",5637
2162,for ( col = 0 ;col < imagewidth ;if ( colb + tilew > imagew ) {,for ( col = 0 ;col < imagewidth && colb < imagew ;if ( colb + tilew > imagew ) {,5638
2163,"write_webm_file_footer ( & stream -> ebml , stream -> hash ) ;free ( stream -> ebml . cue_list ) ;stream -> ebml . cue_list = NULL ;",write_webm_file_footer ( & stream -> ebml ) ;,5639
2164,"static void encode_uniform ( vp9_writer * w , int v ) {const int l = 8 ;vp9_write_literal ( w , v , l - 1 ) ;}vp9_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ;vp9_write_literal ( w , ( v - m ) & 1 , 1 ) ;}","static void encode_uniform ( vpx_writer * w , int v ) {const int l = 8 ;vpx_write_literal ( w , v , l - 1 ) ;}vpx_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ;vpx_write_literal ( w , ( v - m ) & 1 , 1 ) ;}",5640
2165,"k -> get_config ( vdev , vdev -> config ) ;if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ;","if ( addr + sizeof ( val ) > vdev -> config_len ) {return ( uint32_t ) - 1 ;}k -> get_config ( vdev , vdev -> config ) ;",5641
2166,"strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ;return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ;","nla_strlcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME ) ;return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ;",5642
2167,"gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc ,   & pdev -> dev , gpio_dev ) ;if ( IS_ERR ( gpio_dev -> pctrl ) ) {if ( ret )  goto out1 ;ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;","gpio_dev -> pctrl = devm_pinctrl_register ( & pdev -> dev , & amd_pinctrl_desc , gpio_dev ) ;if ( IS_ERR ( gpio_dev -> pctrl ) ) {if ( ret ) return ret ;ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;",5643
2168,out1 :  pinctrl_unregister ( gpio_dev -> pctrl ) ;,"
",5643
2169,"if ( ret >= 0 ) close ( ret ) ;if ( console -> master < 0 ) {INFO ( ""no<S2SV_blank>console"" ) ;return 0 ;}if ( mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 ) ) {ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\\\'%s\\\'<S2SV_blank>on<S2SV_blank>\\\'%s\\\'"" , console -> name , lxcpath ) ;","if ( safe_mount ( console -> name , lxcpath ) ;",5644
2170,"static void nsc_decode ( NSC_CONTEXT * context )  {UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ;BYTE shift = context -> ColorLossLevel - 1 ;BYTE * bmpdata = context -> BitmapData ;for ( y = 0 ;","static BOOL nsc_decode ( NSC_CONTEXT * context ) {UINT16 rw ;BYTE shift ;BYTE * bmpdata ;size_t pos = 0 ;if ( ! context ) return FALSE ;rw = ROUND_UP_TO ( context -> width , 8 ) ;shift = context -> ColorLossLevel - 1 ;bmpdata = context -> BitmapData ;if ( ! bmpdata ) return FALSE ;for ( y = 0 ;",5645
2171,"* bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ;* bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ;","if ( pos + 4 > context -> BitmapDataLength ) return FALSE ;pos += 4 ;* bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ;* bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ;",5645
2172,},return TRUE ;},5645
2173,"static void atomic2gen ( lua_State * L , global_State * g ) {sweep2old ( L , & g -> allgc ) ;","static void atomic2gen ( lua_State * L , global_State * g ) {g -> gcstate = GCSswpallgc ;sweep2old ( L , & g -> allgc ) ;",5646
2174,"int vp8dx_start_decode ( BOOL_DECODER * br , const unsigned char * source , unsigned int source_sz ,  vp8_decrypt_cb * decrypt_cb ,  void * decrypt_state ) {","int vp8dx_start_decode ( BOOL_DECODER * br , const unsigned char * source , unsigned int source_sz , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) {",5647
2175,# define REMAIN ( buf -> length - ( ptr - bufstart ) )  if ( REMAIN > INT_MAX )  return GSS_S_DEFECTIVE_TOKEN ;,# define REMAIN ( buf -> length - ( ptr - bufstart ) ) if ( REMAIN == 0 || REMAIN > INT_MAX ) return GSS_S_DEFECTIVE_TOKEN ;,5648
2176,"return - EACCES ;err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;}else if ( opcode == BPF_MOV ) {if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( insn -> imm != 0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ;if ( err ) return err ;}else {if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}}err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ;regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ;}else {if ( is_pointer_value ( env , insn -> src_reg ) ) {verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\return - EACCES ;}mark_reg_unknown ( env , regs , insn -> dst_reg ) ;regs [ insn -> dst_reg ] . var_off = tnum_cast (  regs [ insn -> dst_reg ] . var_off , 4 ) ;__update_reg_bounds ( & regs [ insn -> dst_reg ] ) ;}","coerce_reg_to_size ( & regs [ insn -> dst_reg ] , 4 ) ;",5649
2177,"WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec ,  UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num ) {WORD32 ret ;ps_dec -> u2_mbx = 0xffff ;ps_dec -> u2_mby = 0 ;",WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec ) {WORD32 ret ;,5650
2178,"ps_dec -> u2_total_mbs_coded = 0 ;{pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ;pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ;if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ;if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ;if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) {ret = ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ;if ( ret != OK ) return ret ;}ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ;ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ;ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ;if ( ps_cur_slice -> u1_nal_ref_idc ) {ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ;ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ;ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ;ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ;ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ;ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ;}}","
",5650
2179,if ( ! file )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,5651
2180,"DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\\return - EINVAL ;","DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\\return - EINVAL ;}if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) {DRM_DEBUG ( ""execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\\return - EINVAL ;",5652
2181,"long tmp = * old ;* old = atomic_long_cmpxchg ( & sem -> count , * old , new ) ;return * old == tmp ;}","long tmp = atomic_long_cmpxchg ( & sem -> count , * old , new ) ;if ( tmp == * old ) {* old = new ;return 1 ;}else {* old = tmp ;return 0 ;}}",5653
2182,"char buf [ 32 ] , * e ;sprintf ( buf , fmt , w , n ) ;","char buf [ 50 ] , * e ;sprintf ( buf , fmt , w , n ) ;",5654
2183,"nfcf_poll -> sensf_res_len = * data ++ ;pr_debug ( ""bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\","nfcf_poll -> sensf_res_len = min_t ( __u8 , * data ++ , NFC_SENSF_RES_MAXSIZE ) ;pr_debug ( ""bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\",5655
2184,mutex_unlock ( & file -> mut ) ;ucma_put_ctx ( ctx ) ;,"mutex_lock ( & mut ) ;idr_replace ( & multicast_idr , mc , mc -> id ) ;mutex_unlock ( & mut ) ;mutex_unlock ( & file -> mut ) ;ucma_put_ctx ( ctx ) ;",5656
2185,if ( pWalker -> eCode ) {,if ( pParse -> nErr || pWalker -> eCode ) {,5657
2186,"if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) {return WRC_Abort ;","if ( db -> mallocFailed || sqliteProcessJoin ( pParse , p ) ) {return WRC_Abort ;",5657
2187,u64 msr_data ;int usermode ;cs . dpl = 3 ;ss . dpl = 3 ;,"u64 msr_data , rcx , rdx ;int usermode ;rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ;rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ;cs . dpl = 3 ;ss . dpl = 3 ;",5658
2188,"break ;}ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ;* reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;return X86EMUL_CONTINUE ;","if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ;break ;}ctxt -> _eip = rdx ;* reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;return X86EMUL_CONTINUE ;",5658
2189,"struct packet_sock * po = pkt_sk ( sk ) ;struct packet_fanout * f , * match ;","struct packet_rollover * rollover = NULL ;struct packet_sock * po = pkt_sk ( sk ) ;struct packet_fanout * f , * match ;",5659
2190,"if ( ! po -> running )   return - EINVAL ;if ( po -> fanout )  return - EALREADY ;if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ;if ( ! po -> rollover )  return - ENOMEM ;atomic_long_set ( & po -> rollover -> num , 0 ) ;atomic_long_set ( & po -> rollover -> num_huge , 0 ) ;atomic_long_set ( & po -> rollover -> num_failed , 0 ) ;}mutex_lock ( & fanout_mutex ) ;match = NULL ;list_for_each_entry ( f , & fanout_list , list ) {if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {match = f ;break ;}}if ( match && match -> flags != flags ) goto out ;if ( ! match ) {match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match ) goto out ;write_pnet ( & match -> net , sock_net ( sk ) ) ;match -> id = id ;match -> type = type ;match -> flags = flags ;INIT_LIST_HEAD ( & match -> list ) ;spin_lock_init ( & match -> lock ) ;atomic_set ( & match -> sk_ref , 0 ) ;fanout_init_data ( match ) ;match -> prot_hook . type = po -> prot_hook . type ;match -> prot_hook . dev = po -> prot_hook . dev ;match -> prot_hook . func = packet_rcv_fanout ;match -> prot_hook . af_packet_priv = match ;match -> prot_hook . id_match = match_fanout_group ;dev_add_pack ( & match -> prot_hook ) ;list_add ( & match -> list , & fanout_list ) ;}err = - EINVAL ;if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {err = - ENOSPC ;if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) {__dev_remove_pack ( & po -> prot_hook ) ;po -> fanout = match ;atomic_inc ( & match -> sk_ref ) ;__fanout_link ( sk , po ) ;err = 0 ;}}out :  mutex_unlock ( & fanout_mutex ) ;if ( err ) {kfree ( po -> rollover ) ;po -> rollover = NULL ;","mutex_lock ( & fanout_mutex ) ;if ( ! po -> running ) goto out ;err = - EALREADY ;if ( po -> fanout ) goto out ;if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ;if ( ! rollover ) goto out ;atomic_long_set ( & po -> rollover -> num , 0 ) ;atomic_long_set ( & rollover -> num_huge , 0 ) ;atomic_long_set ( & rollover -> num_failed , 0 ) ;mutex_lock ( & fanout_mutex ) ;",5659
2191,return fd ;},sr -> fd_is_fdt = MK_TRUE ;return fd ;},5660
2192,"int vp8_denoiser_allocate ( VP8_DENOISER * denoiser , int width , int height )  {assert ( denoiser ) ;for ( i = 0 ;","int vp8_denoiser_allocate ( VP8_DENOISER * denoiser , int width , int height , int num_mb_rows , int num_mb_cols , int mode ) {assert ( denoiser ) ;denoiser -> num_mb_cols = num_mb_cols ;for ( i = 0 ;",5661
2193,"vpx_memset ( denoiser -> yv12_running_avg [ i ] . buffer_alloc , 0 ,  denoiser -> yv12_running_avg [ i ] . frame_size ) ;vpx_memset ( denoiser -> yv12_mc_running_avg . buffer_alloc , 0 ,  denoiser -> yv12_mc_running_avg . frame_size ) ;return 0 ;}","memset ( denoiser -> yv12_running_avg [ i ] . buffer_alloc , 0 , denoiser -> yv12_running_avg [ i ] . frame_size ) ;memset ( denoiser -> yv12_mc_running_avg . buffer_alloc , 0 , denoiser -> yv12_mc_running_avg . frame_size ) ;if ( vp8_yv12_alloc_frame_buffer ( & denoiser -> yv12_last_source , width , height , VP8BORDERINPIXELS ) < 0 ) {vp8_denoiser_free ( denoiser ) ;return 1 ;}memset ( denoiser -> yv12_last_source . buffer_alloc , 0 , denoiser -> yv12_last_source . frame_size ) ;denoiser -> denoise_state = vpx_calloc ( ( num_mb_rows * num_mb_cols ) , 1 ) ;memset ( denoiser -> denoise_state , 0 , ( num_mb_rows * num_mb_cols ) ) ;vp8_denoiser_set_parameters ( denoiser , mode ) ;denoiser -> nmse_source_diff = 0 ;denoiser -> nmse_source_diff_count = 0 ;denoiser -> qp_avg = 0 ;denoiser -> qp_threshold_up = 80 ;denoiser -> qp_threshold_down = 128 ;denoiser -> bitrate_threshold = 400000 ;denoiser -> threshold_aggressive_mode = 80 ;if ( width * height > 1280 * 720 ) {denoiser -> bitrate_threshold = 3000000 ;denoiser -> threshold_aggressive_mode = 200 ;}else if ( width * height > 960 * 540 ) {denoiser -> bitrate_threshold = 1200000 ;denoiser -> threshold_aggressive_mode = 120 ;}else if ( width * height > 640 * 480 ) {denoiser -> bitrate_threshold = 600000 ;denoiser -> threshold_aggressive_mode = 100 ;}return 0 ;}",5661
2194,"struct mct_u232_private * priv ;priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ;priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ;priv -> read_urb -> context = port ;","struct usb_serial * serial = port -> serial ;struct mct_u232_private * priv ;if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) {dev_err ( & port -> dev , ""expected<S2SV_blank>endpoint<S2SV_blank>missing\\\return - ENODEV ;}priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ;priv -> read_urb = serial -> port [ 1 ] -> interrupt_in_urb ;priv -> read_urb -> context = port ;",5662
2195,"ptr = sshpkt_ptr ( ssh , & dlen ) ;if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ;","ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;ptr = sshpkt_ptr ( ssh , & dlen ) ;if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ;",5663
2196,if ( ( temp_buffer & 0xffffff00 ) != 0x100 )  continue ;else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ;else if ( temp_buffer < 0x120 )  VO ++ ;else if ( temp_buffer < 0x130 )  VOL ++ ;,if ( temp_buffer & 0xfffffe00 ) continue ;if ( temp_buffer >= 0x100 && temp_buffer < 2 ) continue ;else if ( temp_buffer >= 0x120 && temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ;else if ( temp_buffer < 0x120 ) VO ++ ;else if ( temp_buffer < 0x130 ) VOL ++ ;,5664
2197,"unsigned short sel ;memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ;rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;ctxt -> _eip = 0 ;memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;return X86EMUL_CONTINUE ;}","unsigned short sel , old_sel ;struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;u8 cpl = ctxt -> ops -> cpl ( ctxt ) ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) ;memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ;rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;rc = assign_eip_far ( ctxt , ctxt -> src . valptr , ctxt -> op_bytes ) ;return rc ;}return rc ;}",5665
2198,if ( x & ( 1 << i ) ) return i ;},if ( x & ( 1U << ( unsigned int ) i ) ) return i ;},5666
2199,"or_circuit_t * or_circ = NULL ;const or_options_t * options = get_options ( ) ;if ( ! CIRCUIT_IS_ORIGIN ( circ ) )   or_circ = TO_OR_CIRCUIT ( circ ) ;relay_header_unpack ( & rh , cell -> payload ) ;","or_circuit_t * or_circ = NULL ;origin_circuit_t * origin_circ = NULL ;crypt_path_t * layer_hint = NULL ;const or_options_t * options = get_options ( ) ;if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) {or_circ = TO_OR_CIRCUIT ( circ ) ;}else {tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ;origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ;layer_hint = origin_circ -> cpath -> prev ;}relay_header_unpack ( & rh , cell -> payload ) ;",5667
2200,"relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , layer_hint ) ;return 0 ;",5667
2201,"relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_NOTDIRECTORY , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_NOTDIRECTORY , layer_hint ) ;return 0 ;",5667
2202,"relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_INTERNAL , NULL ) ;return 0 ;relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_EXITPOLICY , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_INTERNAL , layer_hint ) ;return 0 ;relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , layer_hint ) ;return 0 ;",5667
2203,"origin_circuit_t * origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ;log_info ( LD_REND , ""begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream."" ) ;","tor_assert ( origin_circ ) ;log_info ( LD_REND , ""begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream."" ) ;",5667
2204,"relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_DONE ,  origin_circ -> cpath -> prev ) ;connection_free ( TO_CONN ( n_stream ) ) ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_DONE , layer_hint ) ;connection_free ( TO_CONN ( n_stream ) ) ;",5667
2205,struct unix_sock * u = unix_sk ( sk ) ;msg -> msg_namelen = 0 ;,struct unix_sock * u = unix_sk ( sk ) ;,5668
2206,}if ( ret ) fpstate_init ( & fpu -> state ) ;,if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;}if ( ret ) fpstate_init ( & fpu -> state ) ;,5669
2207,"retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ;}}else acl = NULL ;switch ( handler -> flags ) {case ACL_TYPE_ACCESS : if ( acl ) {umode_t mode = inode -> i_mode ;retval = posix_acl_equiv_mode ( acl , & mode ) ;if ( retval < 0 ) goto err_out ;else {struct iattr iattr ;if ( retval == 0 ) {acl = NULL ;iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ;}}","struct iattr iattr ;retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ;if ( ! acl ) {}}",5670
2208,"return ( ! _cups_strcasecmp ( con -> clientname , ""localhost"" ) || ! _cups_strcasecmp ( con -> clientname , ""localhost."" ) ||  # ifdef __linux  ! _cups_strcasecmp ( con -> clientname , ""localhost.localdomain"" ) || # endif ! strcmp ( con -> clientname , ""127.0.0.1"" ) || ! strcmp ( con -> clientname , ""[::1]"" ) ) ;","return ( ! _cups_strcasecmp ( con -> clientname , ""localhost"" ) || ! _cups_strcasecmp ( con -> clientname , ""localhost."" ) || ! strcmp ( con -> clientname , ""127.0.0.1"" ) || ! strcmp ( con -> clientname , ""[::1]"" ) ) ;",5671
2209,if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,if ( num < 0 || num >= 256 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,5672
2210,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,5672
2211,INST_HANDLER ( lds ) {int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,INST_HANDLER ( lds ) {if ( len < 4 ) {return ;}int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,5673
2212,for ( col = 0 ;col < imagewidth ;if ( colb + tilew > imagew ) {,for ( col = 0 ;col < imagewidth && colb < imagew ;if ( colb + tilew > imagew ) {,5674
2213,"}else  log_ppp_warn ( ""radius:packet:<S2SV_blank>vendor<S2SV_blank>%i<S2SV_blank>not<S2SV_blank>found\\\","if ( len < 0 ) {log_ppp_warn ( ""radius:packet<S2SV_blank>invalid<S2SV_blank>vendor<S2SV_blank>attribute<S2SV_blank>len<S2SV_blank>received\\\goto out_err ;}if ( 2 + len > n ) {log_ppp_warn ( ""radius:packet:<S2SV_blank>too<S2SV_blank>long<S2SV_blank>vendor<S2SV_blank>attribute<S2SV_blank>received<S2SV_blank>(%i,<S2SV_blank>%i)\\\goto out_err ;}}else log_ppp_warn ( ""radius:packet:<S2SV_blank>vendor<S2SV_blank>%i<S2SV_blank>not<S2SV_blank>found\\\",5675
2214,"}err = hidp_connection_add ( & ca , csock , isock ) ;","}ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;err = hidp_connection_add ( & ca , csock , isock ) ;",5676
2215,if ( flags & MSG_OOB )  goto out ;msg -> msg_namelen = 0 ;,if ( flags & MSG_OOB ) goto out ;,5677
2216,atomic_inc ( & prog -> aux -> refcnt ) ;fdput ( f ) ;,prog = bpf_prog_inc ( prog ) ;fdput ( f ) ;,5678
2217,if ( len < tcp_hdrlen )  return - 1 ;,if ( len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) ) return - 1 ;if ( tcp_hdrlen >= 15 * 4 ) return 0 ;,5679
2218,"if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ;","if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ;",5679
2219,"up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE ,  & control -> id ) ;return 0 ;","struct snd_ctl_elem_id id = control -> id ;up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , & id ) ;return 0 ;",5680
2220,"memmove ( s + j , s + qs , blen - qs ) ;j += blen - qs ;}","const int qslen = blen - qs ;memmove ( s + j , s + qs , ( size_t ) qslen ) ;qs = j ;j += qslen ;}",5681
2221,"case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ;","case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> unary . child -> ident . ident ) ;",5682
2222,"case EXPR_INVERT : case EXPR_NOT :  ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;if ( ok ) * set_rtrn = ! * set_rtrn ;","case EXPR_INVERT : case EXPR_NOT : ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;if ( ok ) * set_rtrn = ! * set_rtrn ;",5682
2223,"data = NULL ;ZVAL_UNDEF ( & d ) ;if ( ! objprops ) {if ( Z_TYPE ( key ) == IS_LONG ) {idx = Z_LVAL ( key ) ;numeric_key : if ( UNEXPECTED ( ( old_data = zend_hash_index_find ( ht , idx ) ) != NULL ) ) {","
",5683
2224,if ( UNEXPECTED ( Z_ISUNDEF_P ( data ) ) ) {if ( Z_TYPE ( key ) == IS_LONG ) {,if ( UNEXPECTED ( Z_ISUNDEF_P ( data ) ) ) {if ( Z_TYPE ( key ) == IS_LONG ) {,5683
2225,}zval_dtor ( & key ) ;,zval_dtor ( & key ) ;,5683
2226,"if ( new -> process_keyring )  return - EEXIST ;keyring = keyring_alloc ( ""_pid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;","if ( new -> process_keyring ) return 0 ;keyring = keyring_alloc ( ""_pid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;",5684
2227,"memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ;state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ;","if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ;state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ;",5685
2228,"void vp9_idct32x32_add ( const int16_t * input , uint8_t * dest , int stride ,  int eob ) {if ( eob == 1 )  vp9_idct32x32_1_add ( input , dest , stride ) ;else if ( eob <= 34 )  vp9_idct32x32_34_add ( input , dest , stride ) ;else  vp9_idct32x32_1024_add ( input , dest , stride ) ;}","void vp9_idct32x32_add ( const tran_low_t * input , uint8_t * dest , int stride , int eob ) {if ( eob == 1 ) vpx_idct32x32_1_add ( input , dest , stride ) ;else if ( eob <= 34 ) vpx_idct32x32_34_add ( input , dest , stride ) ;else vpx_idct32x32_1024_add ( input , dest , stride ) ;}",5686
2229,"static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst )  {switch ( ctxt -> op_bytes ) {case 2 : ctxt -> _eip = ( u16 ) dst ;break ;case 4 : ctxt -> _eip = ( u32 ) dst ;break ;case 8 : ctxt -> _eip = dst ;break ;default : WARN ( 1 , ""unsupported<S2SV_blank>eip<S2SV_blank>assignment<S2SV_blank>size\\\}","static inline int assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) {return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 ) ;",5687
2230,"if ( sr -> smb_fid != 0xffff ) {smbsr_lookup_file ( sr ) ;if ( sr -> fid_ofile == NULL ) {smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ;smb_flush_file ( sr , sr -> fid_ofile ) ;}smb_flush_file ( sr , file ) ;mutex_exit ( & file -> f_mutex ) ;","smb_ofile_flush ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ;smb_flush_file ( sr , sr -> fid_ofile ) ;}smb_ofile_flush ( sr , file ) ;mutex_exit ( & file -> f_mutex ) ;",5688
2231,static void print_bpf_insn ( struct bpf_insn * insn )  {,"static void print_bpf_insn ( const struct bpf_verifier_env * env , const struct bpf_insn * insn ) {",5689
2232,"}else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) {verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%x\\\}","}else if ( BPF_MODE ( insn -> code ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) {u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ;bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ;if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ;verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\\}",5689
2233,if ( net != & init_net )  return - EAFNOSUPPORT ;,if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( net != & init_net ) return - EAFNOSUPPORT ;,5690
2234,"uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ;uint32 stripsize = TIFFStripSize ( in ) ;","uint32 strip , nstrips = TIFFNumberOfStrips ( in ) ;uint32 stripsize = TIFFStripSize ( in ) ;",5691
2235,"s = tcp_recv ( NULL , 4 ) ;if ( s == NULL ) return False ;if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) {logger ( Protocol , Error , ""cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x"" , s -> p [ 0 ] ) ;return False ;if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ;else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ;else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ;else return False ;s = tcp_recv ( s , length ) ;if ( ! ber_in_header ( s , & tagval , & length ) ||  tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ;in_uint8s ( s , length ) ;if ( token ) {if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ;token -> end = token -> p = token -> data ;out_uint8p ( token , s -> p , length ) ;","struct stream packet ;s = tcp_recv ( NULL , 4 ) ;if ( s == NULL ) return False ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;s_realloc ( token , length ) ;s_reset ( token ) ;out_uint8p ( token , s -> p , length ) ;",5692
2236,addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;addr . sin_port = htons ( port ) ;,addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;addr . sin_port = htons ( port ) ;,5693
2237,if ( ret != 0 )  return ret ;bo -> dumb = false ;,if ( ret != 0 ) {kfree ( bo ) ;return ret ;}bo -> dumb = false ;,5694
2238,"char * fpath = NULL , * path1 , * cgdir = NULL , * controller ;const char * cgroup ;if ( ! fc ) return - EIO ;controller = pick_controller_from_path ( fc , path ) ;if ( ! controller ) return - EINVAL ;cgroup = find_cgroup_in_path ( path ) ;if ( ! cgroup ) return - EINVAL ;get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ;if ( ! fpath ) path1 = ""/"" ;else path1 = cgdir ;if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {ret = - EACCES ;goto out ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {ret = - EACCES ;return ret ;}","char * fpath = NULL , * path1 , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next ) ) {ret = - EACCES ;goto out ;}if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {ret = - EACCES ;goto out ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {ret = - EACCES ;free ( next ) ;return ret ;}",5695
2239,bool_t status ;netContext . entropy += netGetSystemTickCount ( ) ;# if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG )  size_t length = netBufferGetLength ( buffer ) - offset ;# endif if ( interface -> configured && interface -> nicDriver != NULL ) {,bool_t status ;# if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) size_t length = netBufferGetLength ( buffer ) - offset ;# endif netContext . entropy += netGetSystemTickCount ( ) ;if ( interface -> configured && interface -> nicDriver != NULL ) {,5696
2240,"if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ;if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ;if ( ( ( int ) arg >= cdi -> capacity ) )  return - EINVAL ;",if ( arg >= cdi -> capacity ) ) return - EINVAL ;,5697
2241,unsigned int random_variable = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {random_variable = get_random_int ( ) & STACK_RND_MASK ;random_variable <<= PAGE_SHIFT ;,unsigned long random_variable = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {random_variable = ( unsigned long ) get_random_int ( ) ;random_variable &= STACK_RND_MASK ;random_variable <<= PAGE_SHIFT ;,5698
2242,"SCSIDiskReq * r ;req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ;r = DO_UPCAST ( SCSIDiskReq , req , req ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ;","req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ;",5699
2243,"config_set_special_field ( ""dbfilename"" ) {if ( ! pathIsBaseName ( o -> ptr ) ) {addReplyError ( c , ""dbfilename<S2SV_blank>can\\\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ) ;return ;}zfree ( server . rdb_filename ) ;server . rdb_filename = zstrdup ( o -> ptr ) ;}config_set_special_field ( ""requirepass"" ) {if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ;zfree ( server . requirepass ) ;server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ;}config_set_special_field ( ""masterauth"" ) {zfree ( server . masterauth ) ;server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ;}config_set_special_field ( ""cluster-announce-ip"" ) {zfree ( server . cluster_announce_ip ) ;server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ;}config_set_special_field ( ""maxclients"" ) {int orig_value = server . maxclients ;if ( getLongLongFromObject ( o , & ll ) == C_ERR || ll < 1 ) goto badfmt ;server . maxclients = ll ;if ( ll > orig_value ) {adjustOpenFilesLimit ( ) ;if ( server . maxclients != ll ) {addReplyErrorFormat ( c , ""The<S2SV_blank>operating<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients,<S2SV_blank>try<S2SV_blank>with<S2SV_blank>%d"" , server . maxclients ) ;server . maxclients = orig_value ;return ;}if ( ( unsigned int ) aeGetSetSize ( server . el ) < server . maxclients + CONFIG_FDSET_INCR ) {if ( aeResizeSetSize ( server . el , server . maxclients + CONFIG_FDSET_INCR ) == AE_ERR ) {addReplyError ( c , ""The<S2SV_blank>event<S2SV_blank>loop<S2SV_blank>API<S2SV_blank>used<S2SV_blank>by<S2SV_blank>Redis<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients"" ) ;server . maxclients = orig_value ;return ;}}}}config_set_special_field ( ""appendonly"" ) {int enable = yesnotoi ( o -> ptr ) ;if ( enable == - 1 ) goto badfmt ;if ( enable == 0 && server . aof_state != AOF_OFF ) {stopAppendOnly ( ) ;}else if ( enable && server . aof_state == AOF_OFF ) {if ( startAppendOnly ( ) == C_ERR ) {addReplyError ( c , ""Unable<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>on<S2SV_blank>AOF.<S2SV_blank>Check<S2SV_blank>server<S2SV_blank>logs."" ) ;return ;}}}config_set_special_field ( ""save"" ) {int vlen , j ;sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , ""<S2SV_blank>"" , 1 , & vlen ) ;if ( vlen & 1 ) {for ( j = 0 ;j < vlen ;j ++ ) {char * eptr ;long val ;val = strtoll ( v [ j ] , & eptr , 10 ) ;if ( eptr [ 0 ] != \'\\\\0\' || ( ( j & 1 ) == 0 && val < 1 ) || ( ( j & 1 ) == 1 && val < 0 ) ) {sdsfreesplitres ( v , vlen ) ;goto badfmt ;}}resetServerSaveParams ( ) ;for ( j = 0 ;j < vlen ;j += 2 ) {time_t seconds ;int changes ;seconds = strtoll ( v [ j ] , NULL , 10 ) ;changes = strtoll ( v [ j + 1 ] , NULL , 10 ) ;appendServerSaveParams ( seconds , changes ) ;}sdsfreesplitres ( v , vlen ) ;}config_set_special_field ( ""dir"" ) {if ( chdir ( ( char * ) o -> ptr ) == - 1 ) {addReplyErrorFormat ( c , ""Changing<S2SV_blank>directory:<S2SV_blank>%s"" , strerror ( errno ) ) ;return ;}}config_set_special_field ( ""client-output-buffer-limit"" ) {int vlen , j ;sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , ""<S2SV_blank>"" , 1 , & vlen ) ;if ( vlen % 4 ) {sdsfreesplitres ( v , vlen ) ;goto badfmt ;}for ( j = 0 ;j < vlen ;j ++ ) {long val ;if ( ( j % 4 ) == 0 ) {if ( getClientTypeByName ( v [ j ] ) == - 1 ) {sdsfreesplitres ( v , vlen ) ;goto badfmt ;}",int class = getClientTypeByName ( v [ j ] ) ;if ( class == - 1 || class == CLIENT_TYPE_MASTER ) {,5700
2244,"return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ;}","return TEMP_FAILURE_RETRY ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) ) == sizeof ( cmd ) ;}",5701
2245,"
","if ( metadata -> data_count > metadata -> data_capacity ) {ALOGE ( ""%s:<S2SV_blank>Data<S2SV_blank>count<S2SV_blank>(%"" PRIu32 "")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>data<S2SV_blank>capacity<S2SV_blank>"" ""(%"" PRIu32 "")"" , __FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ;android_errorWriteLog ( SN_EVENT_LOG_ID , ""30591838"" ) ;return ERROR ;}",5702
2246,const metadata_uptrdiff_t entries_end =  metadata -> entries_start + metadata -> entry_capacity ;,const metadata_uptrdiff_t entries_end = metadata -> entries_start + metadata -> entry_capacity ;,5702
2247,"dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\\","dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\\",5703
2248,"const uint32_t c_w =  ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ;for ( i = 0 ;++ i )  match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , img2 -> planes [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ] ,  img1 -> d_w ) == 0 ) ;for ( i = 0 ;","uint32_t l_w = img1 -> d_w ;uint32_t c_w = ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ;# if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) {l_w *= 2 ;c_w *= 2 ;}# endif for ( i = 0 ;+ i )  match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , img2 -> planes [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ] ,  img1 -> d_w ) == 0 ) ;++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , l_w ) == 0 ) ;for ( i = 0 ;",5704
2249,unsigned int blocks ;unsigned int range_count ;,size_t blocks ;unsigned int range_count ;if ( blksize != 0 ) {,5705
2250,"blocks = ( ( size - 1 ) / blksize ) + 1 ;pMap -> range_count = range_count ;pMap -> ranges = malloc ( range_count * sizeof ( MappedRange ) ) ;memset ( pMap -> ranges , 0 , range_count * sizeof ( MappedRange ) ) ;unsigned char * reserve ;return - 1 ;}pMap -> ranges [ range_count - 1 ] . addr = reserve ;pMap -> ranges [ range_count - 1 ] . length = blocks * blksize ;int fd = open ( block_dev , O_RDONLY ) ;","blocks = ( ( size - 1 ) / blksize ) + 1 ;}if ( size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0 ) {LOGE ( ""invalid<S2SV_blank>data<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>file:<S2SV_blank>size<S2SV_blank>%zu,<S2SV_blank>blksize<S2SV_blank>%u,<S2SV_blank>range_count<S2SV_blank>%u\\\return - 1 ;}pMap -> range_count = range_count ;pMap -> ranges = calloc ( range_count , sizeof ( MappedRange ) ) ;if ( pMap -> ranges , 0 , range_count * sizeof ( MappedRange ) , strerror ( errno ) ) ;free ( pMap -> ranges ) ;return - 1 ;}int fd = open ( block_dev , O_RDONLY ) ;if ( fd < 0 ) {LOGW ( ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>block<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%s\\\munmap ( reserve , blocks * blksize ) ;free ( pMap -> ranges ) ;return - 1 ;}unsigned char * next = reserve ;size_t remaining_size = blocks * blksize ;bool success = true ;for ( i = 0 ;i < range_count ;++ i ) {size_t start , end ;if ( fscanf ( mapf , ""%zu<S2SV_blank>%zu\\\LOGW ( ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>range<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map\\\success = false ;break ;}size_t length = ( end - start ) * blksize ;if ( end <= start || ( end - start ) > SIZE_MAX / blksize || length > remaining_size ) {LOGE ( ""unexpected<S2SV_blank>range<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map:<S2SV_blank>%zu<S2SV_blank>%zu\\\success = false ;break ;}void * addr = mmap64 ( next , length , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ;if ( addr == MAP_FAILED ) {LOGW ( ""failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>block<S2SV_blank>%d:<S2SV_blank>%s\\\success = false ;break ;}unsigned char * reserve ;return - 1 ;}pMap -> ranges [ i ] . addr = reserve ;pMap -> ranges [ range_count - 1 ] . length = blocks * blksize ;int fd = open ( block_dev , O_RDONLY ) ;",5705
2251,next += pMap -> ranges [ i ] . length ;},next += pMap -> ranges [ i ] . length ;},5705
2252,"sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ;if ( port_len ) snprintf ( port , 6 , ""%.*s"" , port_len , port_start ) ;","if ( url_len >= sizeof ( url_address ) ) {applog ( LOG_WARNING , ""%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\\\'%.*s\\\'"" , __func__ , url_len , url_begin ) ;url_len = sizeof ( url_address ) - 1 ;}sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ;if ( port_len ) snprintf ( port , 6 , ""%.*s"" , port_len , port_start ) ;",5706
2253,"pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ;if ( rv )  fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\fs_logger2 ( ""clone"" , dest ) ;}","copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\fs_logger2 ( ""clone"" , dest ) ;}",5707
2254,"return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) ,  re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) ;","return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) , 0 , re -> flags | RE_FLAGS_SCAN , NULL , NULL ) ;",5708
2255,"void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run ,  BLOCK_SIZE bsize ) {MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;TOKENEXTRA * t_backup = * t ;const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id ,  SEG_LVL_SKIP ) ;struct tokenize_b_args arg = {cpi , xd , t }if ( mbmi -> skip ) {if ( ! dry_run )  cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ;reset_skip_context ( xd , bsize ) ;if ( dry_run )  * t = t_backup ;cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ;vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ;else {vp9_foreach_transformed_block ( xd , bsize , set_entropy_context_b , & arg ) ;* t = t_backup ;}","void vp9_tokenize_sb ( VP9_COMP * cpi , ThreadData * td , TOKENEXTRA * * t , int dry_run , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;const int skip_inc = ! segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ;struct tokenize_b_args arg = {cpi , td , t }if ( mbmi -> skip ) {if ( ! dry_run ) td -> counts -> skip [ ctx ] [ 1 ] += skip_inc ;reset_skip_context ( xd , bsize ) ;cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ;vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ;",5709
2256,if ( cmd & 0x02 ) off |= * delta ++ << 8UL ;if ( cmd & 0x08 ) off |= * delta ++ << 24UL ;if ( cmd & 0x10 ) len = * delta ++ ;,if ( cmd & 0x02 ) off |= ( ( unsigned ) * delta ++ << 8UL ;if ( cmd & 0x08 ) off |= * delta ++ << 24UL ) ;if ( cmd & 0x10 ) len = * delta ++ ;,5710
2257,"if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) {goto _xmi_end ;","if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , xmi_size , 0 ) ) == 0 ) {goto _xmi_end ;",5711
2258,"return KRB5KDC_ERR_BADOPTION ;}if ( ! krb5_principal_compare ( kdc_context , server -> princ ,  server_princ ) ) {return KRB5KDC_ERR_SERVER_NOMATCH ;","* status = ""INVALID_S4U2PROXY_OPTIONS"" ;return KRB5KDC_ERR_BADOPTION ;}if ( ! krb5_principal_compare ( kdc_context , server -> princ , server_princ ) ) {* status = ""EVIDENCE_TICKET_MISMATCH"" ;return KRB5KDC_ERR_SERVER_NOMATCH ;",5712
2259,"static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  {","static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) {",5713
2260,"if ( perf_event_overflow ( event , nmi , & data , regs ) )  power_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) power_pmu_stop ( event , 0 ) ;",5713
2261,"
","if ( s -> diff_start + s -> diff_height > cur_blk_height ) {av_log ( avctx , AV_LOG_ERROR , ""Block<S2SV_blank>parameters<S2SV_blank>invalid\\\return AVERROR_INVALIDDATA ;}",5714
2262,"av_log ( avctx , AV_LOG_DEBUG ,  ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\","av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\",5714
2263,"
",same -> dest_count = count ;,5715
2264,"ret = vfs_dedupe_file_range ( file , same ) ;if ( ret ) goto out ;","ret = vfs_dedupe_file_range ( file , same ) ;if ( ret ) goto out ;",5715
2265,"while ( cp < ep && cp < ep2 ) {if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;}if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ;","while ( cp < ep && cp < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ;",5716
2266,struct cpuinfo_x86 * c ;cpu = iminor ( file -> f_path . dentry -> d_inode ) ;,struct cpuinfo_x86 * c ;if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ;cpu = iminor ( file -> f_path . dentry -> d_inode ) ;,5717
2267,bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ;,bond_dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ;,5718
2268,"int vp9_receive_compressed_data ( VP9Decoder * pbi ,  size_t size , const uint8_t * * psource ,  int64_t time_stamp ) {VP9_COMMON * const cm = & pbi -> common ;const uint8_t * source = * psource ;if ( cm -> frame_refs [ 0 ] . idx != INT_MAX )  cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ;if ( cm -> new_fb_idx >= 0 && cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 )   cm -> release_fb_cb ( cm -> cb_priv ,   & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ;cm -> new_fb_idx = get_free_fb ( cm ) ;if ( setjmp ( cm -> error . jmp ) ) {cm -> error . setjmp = 0 ;if ( cm -> frame_refs [ 0 ] . idx != INT_MAX )  cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ;if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ;retcode = vp9_decode_frame ( pbi , source , source + size , psource ) ;if ( retcode < 0 ) {cm -> error . error_code = VPX_CODEC_ERROR ;cm -> error . setjmp = 0 ;if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ;swap_frame_buffers ( pbi ) ;# if WRITE_RECON_BUFFER == 2 if ( cm -> show_frame ) write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame ) ;","int vp9_receive_compressed_data ( VP9Decoder * pbi , size_t size , const uint8_t * * psource ) {VP9_COMMON * volatile const cm = & pbi -> common ;BufferPool * volatile const pool = cm -> buffer_pool ;RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs ;const uint8_t * source = * psource ;if ( cm -> frame_refs [ 0 ] . idx > 0 ) {assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ;cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ;}pbi -> ready_for_new_data = 0 ;if ( ! pbi -> frame_parallel_decode && cm -> new_fb_idx >= 0 && frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 ) pool -> release_fb_cb ( cm -> cb_priv , & frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ;cm -> new_fb_idx = get_free_fb ( cm ) ;if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ;cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ;pbi -> hold_ref_buf = 0 ;pbi -> ready_for_new_data = 1 ;winterface -> sync ( & pbi -> lf_worker ) ;for ( i = 0 ;i < pbi -> num_tile_workers ;++ i ) {winterface -> sync ( & pbi -> tile_workers [ i ] ) ;}lock_buffer_pool ( pool ) ;if ( pbi -> hold_ref_buf == 1 ) {int ref_index = 0 , mask ;for ( mask = pbi -> refresh_frame_flags ;mask ;mask >>= 1 ) {const int old_idx = cm -> ref_frame_map [ ref_index ] ;decrease_ref_count ( old_idx , frame_bufs , pool ) ;if ( ( mask & 1 ) && old_idx >= 0 ) {decrease_ref_count ( old_idx , frame_bufs , pool ) ;}++ ref_index ;}for ( ;ref_index < REF_FRAMES && ! cm -> show_existing_frame ;++ ref_index ) {const int old_idx = cm -> ref_frame_map [ ref_index ] ;decrease_ref_count ( old_idx , frame_bufs , pool ) ;}pbi -> hold_ref_buf = 0 ;}decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ;unlock_buffer_pool ( pool ) ;vpx_clear_system_state ( ) ;vp9_decode_frame ( pbi , source , source + size , psource ) ;swap_frame_buffers ( pbi ) ;vpx_clear_system_state ( ) ;if ( ! cm -> show_existing_frame ) {cm -> last_show_frame = cm -> show_frame ;cm -> prev_frame = cm -> cur_frame ;if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) vp9_swap_current_and_last_seg_map ( cm ) ;}if ( pbi -> frame_parallel_decode ) {VPxWorker * const worker = pbi -> frame_worker_owner ;FrameWorkerData * const frame_worker_data = worker -> data1 ;vp9_frameworker_lock_stats ( worker ) ;if ( cm -> show_frame ) {cm -> current_video_frame ++ ;}frame_worker_data -> frame_decoded = 1 ;frame_worker_data -> frame_context_ready = 1 ;vp9_frameworker_signal_stats ( worker ) ;vp9_frameworker_unlock_stats ( worker ) ;}else {cm -> last_width = cm -> width ;cm -> last_height = cm -> height ;if ( cm -> show_frame ) {cm -> current_video_frame ++ ;}}cm -> error . setjmp = 0 ;if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ;swap_frame_buffers ( pbi ) ;# if WRITE_RECON_BUFFER == 2 if ( cm -> show_frame ) write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame ) ;",5719
2269,"r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ;","r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . ss -> c_string , r2 . ss -> length ) != NULL ;",5720
2270,"r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length ,  r2 . re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) >= 0 ;","r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL ) >= 0 ;",5720
2271,"static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref ,  int_mv * prev_golden_ref_mv ,  YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;","static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref , const MV * prev_golden_ref_mv , YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) {MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;",5721
2272,"if ( ! copy_from_iter_full ( kbuf , len , from ) )  return - EFAULT ;if ( mutex_lock_interruptible ( & eptdev -> ept_lock ) ) {","if ( ! copy_from_iter_full ( kbuf , len , from ) ) {ret = - EFAULT ;goto free_kbuf ;}if ( mutex_lock_interruptible ( & eptdev -> ept_lock ) ) {",5722
2273,"void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  {","static void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) {",5723
2274,return TRUE ;},if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;return TRUE ;},5724
2275,"for ( pad = ( ( 3 * w ) % 4 ) ? ( 4 - ( 3 * w ) % 4 ) : 0 ;else {fdest = fopen ( outfile , ""wb"" ) ;if ( ! fdest ) {fprintf ( stderr , ""ERROR<S2SV_blank>-><S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\\return 1 ;}w = ( int ) image -> comps [ 0 ] . w ;h = ( int ) image -> comps [ 0 ] . h ;fprintf ( fdest , ""BM"" ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + 54 + 1024 + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + w * ( w % 2 ) ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 54 + 1024 ) & 0xff , ( ( 54 + 1024 ) >> 8 ) & 0xff , ( ( 54 + 1024 ) >> 16 ) & 0xff , ( ( 54 + 1024 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 40 ) & 0xff , ( ( 40 ) >> 8 ) & 0xff , ( ( 40 ) >> 16 ) & 0xff , ( ( 40 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( w ) & 0xff ) , ( OPJ_UINT8 ) ( ( w ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( h ) & 0xff ) , ( OPJ_UINT8 ) ( ( h ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c"" , ( 1 ) & 0xff , ( ( 1 ) >> 8 ) & 0xff ) ;fprintf ( fdest , ""%c%c"" , ( 8 ) & 0xff , ( ( 8 ) >> 8 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ;if ( image -> comps [ 0 ] . prec > 8 ) {adjustR = ( int ) image -> comps [ 0 ] . prec - 8 ;printf ( ""BMP<S2SV_blank>CONVERSION:<S2SV_blank>Truncating<S2SV_blank>component<S2SV_blank>0<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>to<S2SV_blank>8<S2SV_blank>bits\\\}else adjustR = 0 ;for ( i = 0 ;i < 256 ;i ++ ) {fprintf ( fdest , ""%c%c%c%c"" , i , i , i , 0 ) ;}for ( i = 0 ;i < w * h ;i ++ ) {int r ;r = image -> comps [ 0 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ;r += ( image -> comps [ 0 ] . sgnd ? 1 << ( image -> comps [ 0 ] . prec - 1 ) : 0 ) ;r = ( ( r >> adjustR ) + ( ( r >> ( adjustR - 1 ) ) % 2 ) ) ;if ( r > 255 ) r = 255 ;else if ( r < 0 ) r = 0 ;fprintf ( fdest , ""%c"" , ( OPJ_UINT8 ) r ) ;if ( ( i + 1 ) % w == 0 ) {for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ;pad > 0 ;pad -- )  fprintf ( fdest , ""%c"" , 0 ) ;}}fclose ( fdest ) ;}",for ( pad = ( w % 4 ) ? ( 4 - w % 4 ) : 0 ;,5725
2276,while ( c && which > 0 ) {c = c -> next ;-- which ;,while ( c && which > 0 ) c = c -> next ;-- which ;,5726
2277,"if ( arg_debug ) printf ( ""Initializing<S2SV_blank>child<S2SV_blank>process\\\close ( parent_to_child_fds [ 1 ] ) ;close ( child_to_parent_fds [ 0 ] ) ;wait_for_other ( parent_to_child_fds [ 0 ] ) ;if ( arg_debug && child_pid == 1 ) printf ( ""PID<S2SV_blank>namespace<S2SV_blank>installed\\\if ( cfg . hostname ) {if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( ""sethostname"" ) ;}if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) {chk_chroot ( ) ;}preproc_mount_mnt_dir ( ) ;if ( mount ( LIBDIR ""/firejail"" , RUN_FIREJAIL_LIB_DIR , ""none"" , MS_BIND , NULL ) < 0 ) errExit ( ""mounting<S2SV_blank>"" RUN_FIREJAIL_LIB_DIR ) ;if ( cfg . name ) fs_logger2 ( ""sandbox<S2SV_blank>name:"" , cfg . name ) ;fs_logger2int ( ""sandbox<S2SV_blank>pid:"" , ( int ) sandbox_pid ) ;if ( cfg . chrootdir ) fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>chroot"" ) ;else if ( arg_overlay ) fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>overlay"" ) ;else fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>local"" ) ;fs_logger ( ""install<S2SV_blank>mount<S2SV_blank>namespace"" ) ;if ( arg_netfilter && any_bridge_configured ( ) ) {netfilter ( arg_netfilter_file ) ;}if ( arg_netfilter6 && any_bridge_configured ( ) ) {netfilter6 ( arg_netfilter6_file ) ;}int gw_cfg_failed = 0 ;if ( arg_nonetwork ) {net_if_up ( ""lo"" ) ;if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>enabled,<S2SV_blank>only<S2SV_blank>loopback<S2SV_blank>interface<S2SV_blank>available\\\}else if ( arg_netns ) {netns ( arg_netns ) ;if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>\\\'%s\\\'<S2SV_blank>activated\\\}else if ( any_bridge_configured ( ) || any_interface_configured ( ) ) {net_if_up ( ""lo"" ) ;if ( mac_not_zero ( cfg . bridge0 . macsandbox ) ) net_config_mac ( cfg . bridge0 . devsandbox , cfg . bridge0 . macsandbox ) ;sandbox_if_up ( & cfg . bridge0 ) ;if ( mac_not_zero ( cfg . bridge1 . macsandbox ) ) net_config_mac ( cfg . bridge1 . devsandbox , cfg . bridge1 . macsandbox ) ;sandbox_if_up ( & cfg . bridge1 ) ;if ( mac_not_zero ( cfg . bridge2 . macsandbox ) ) net_config_mac ( cfg . bridge2 . devsandbox , cfg . bridge2 . macsandbox ) ;sandbox_if_up ( & cfg . bridge2 ) ;if ( mac_not_zero ( cfg . bridge3 . macsandbox ) ) net_config_mac ( cfg . bridge3 . devsandbox , cfg . bridge3 . macsandbox ) ;sandbox_if_up ( & cfg . bridge3 ) ;if ( cfg . interface0 . configured && cfg . interface0 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface0 . dev , cfg . interface0 . ip , cfg . interface0 . mask , cfg . interface0 . mtu ) ;}if ( cfg . interface1 . configured && cfg . interface1 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface1 . dev , cfg . interface1 . ip , cfg . interface1 . mask , cfg . interface1 . mtu ) ;}if ( cfg . interface2 . configured && cfg . interface2 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface2 . dev , cfg . interface2 . ip , cfg . interface2 . mask , cfg . interface2 . mtu ) ;}if ( cfg . interface3 . configured && cfg . interface3 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface3 . dev , cfg . interface3 . ip , cfg . interface3 . mask , cfg . interface3 . mtu ) ;}if ( cfg . defaultgw ) {if ( net_add_route ( 0 , 0 , cfg . defaultgw ) ) {fwarning ( ""cannot<S2SV_blank>configure<S2SV_blank>default<S2SV_blank>route\\\gw_cfg_failed = 1 ;}}if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>enabled\\\}if ( ! arg_quiet ) {if ( any_bridge_configured ( ) || any_interface_configured ( ) || cfg . defaultgw || cfg . dns1 ) {fmessage ( ""\\\if ( any_bridge_configured ( ) || any_interface_configured ( ) ) {if ( arg_scan ) sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 3 , PATH_FNET , ""printif"" , ""scan"" ) ;else sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 2 , PATH_FNET , ""printif"" ) ;}if ( cfg . defaultgw != 0 ) {if ( gw_cfg_failed ) fmessage ( ""Default<S2SV_blank>gateway<S2SV_blank>configuration<S2SV_blank>failed\\\else fmessage ( ""Default<S2SV_blank>gateway<S2SV_blank>%d.%d.%d.%d\\\}if ( cfg . dns1 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns2 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns3 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns4 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\fmessage ( ""\\\}}if ( arg_nonetwork || any_bridge_configured ( ) || any_interface_configured ( ) ) {}else {EUID_USER ( ) ;env_ibus_load ( ) ;EUID_ROOT ( ) ;}# ifdef HAVE_SECCOMP if ( cfg . protocol ) {if ( arg_debug ) printf ( ""Build<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\\int rv = sbox_run ( SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP , 5 , PATH_FSECCOMP , ""protocol"" , ""build"" , cfg . protocol , RUN_SECCOMP_PROTOCOL ) ;if ( rv ) exit ( rv ) ;}if ( arg_seccomp && ( cfg . seccomp_list || cfg . seccomp_list_drop || cfg . seccomp_list_keep ) ) arg_seccomp_postexec = 1 ;# endif bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec ;if ( getuid ( ) != 0 && ( arg_appimage || cfg . chrootdir || arg_overlay ) ) {enforce_filters ( ) ;need_preload = arg_trace || arg_tracelog ;}if ( need_preload ) fs_trace_preload ( ) ;if ( cfg . hosts_file ) fs_store_hosts_file ( ) ;# ifdef HAVE_CHROOT if ( cfg . chrootdir ) {fs_chroot ( cfg . chrootdir ) ;if ( need_preload ) fs_trace_preload ( ) ;}else # endif # ifdef HAVE_OVERLAYFS if ( arg_overlay ) fs_overlayfs ( ) ;else # endif fs_basic_fs ( ) ;if ( arg_private ) {if ( cfg . home_private ) {if ( cfg . chrootdir ) fwarning ( ""private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_homedir ( ) ;}else if ( cfg . home_private_keep ) {if ( cfg . chrootdir ) fwarning ( ""private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_home_list ( ) ;}else fs_private ( ) ;}if ( arg_private_dev ) fs_private_dev ( ) ;if ( arg_private_etc ) {if ( cfg . chrootdir ) fwarning ( ""private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/etc"" , RUN_ETC_DIR , cfg . etc_private_keep ) ;if ( need_preload ) fs_trace_preload ( ) ;}}if ( arg_private_opt ) {if ( cfg . chrootdir ) fwarning ( ""private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/opt"" , RUN_OPT_DIR , cfg . opt_private_keep ) ;}}if ( arg_private_srv ) {if ( cfg . chrootdir ) fwarning ( ""private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/srv"" , RUN_SRV_DIR , cfg . srv_private_keep ) ;}}if ( arg_private_bin && ! arg_appimage ) {if ( cfg . chrootdir ) fwarning ( ""private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {if ( arg_x11_xorg ) {EUID_USER ( ) ;char * tmp ;if ( asprintf ( & tmp , ""%s,xauth"" , cfg . bin_private_keep ) == - 1 ) errExit ( ""asprintf"" ) ;cfg . bin_private_keep = tmp ;EUID_ROOT ( ) ;}fs_private_bin_list ( ) ;}}if ( arg_private_lib && ! arg_appimage ) {if ( cfg . chrootdir ) fwarning ( ""private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_lib ( ) ;}}if ( arg_private_cache ) {if ( cfg . chrootdir ) fwarning ( ""private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_cache ( ) ;}if ( arg_private_tmp ) {EUID_USER ( ) ;fs_private_tmp ( ) ;EUID_ROOT ( ) ;}if ( arg_nodbus ) dbus_session_disable ( ) ;if ( cfg . hostname ) fs_hostname ( cfg . hostname ) ;if ( cfg . hosts_file ) fs_mount_hosts_file ( ) ;if ( arg_netns ) netns_mounts ( arg_netns ) ;fs_proc_sys_dev_boot ( ) ;if ( checkcfg ( CFG_DISABLE_MNT ) ) fs_mnt ( 1 ) ;else if ( arg_disable_mnt ) fs_mnt ( 0 ) ;fs_whitelist ( ) ;fs_blacklist ( ) ;if ( arg_nosound ) {pulseaudio_disable ( ) ;fs_dev_disable_sound ( ) ;}else if ( ! arg_noautopulse ) pulseaudio_init ( ) ;if ( arg_no3d ) fs_dev_disable_3d ( ) ;if ( arg_notv ) fs_dev_disable_tv ( ) ;if ( arg_nodvd ) fs_dev_disable_dvd ( ) ;if ( arg_nou2f ) fs_dev_disable_u2f ( ) ;if ( arg_novideo ) fs_dev_disable_video ( ) ;if ( need_preload ) fs_trace ( ) ;fs_resolvconf ( ) ;fs_logger_print ( ) ;fs_logger_change_owner ( ) ;EUID_USER ( ) ;int cwd = 0 ;if ( cfg . cwd ) {if ( chdir ( cfg . cwd ) == 0 ) cwd = 1 ;}if ( ! cwd ) {if ( chdir ( ""/"" ) < 0 ) errExit ( ""chdir"" ) ;if ( cfg . homedir ) {struct stat s ;if ( stat ( cfg . homedir , & s ) == 0 ) {if ( chdir ( cfg . homedir ) < 0 ) errExit ( ""chdir"" ) ;}}}if ( arg_debug ) {char * cpath = get_current_dir_name ( ) ;if ( cpath ) {printf ( ""Current<S2SV_blank>directory:<S2SV_blank>%s\\\free ( cpath ) ;}}EUID_ROOT ( ) ;fs_x11 ( ) ;if ( arg_x11_xorg ) x11_xorg ( ) ;save_umask ( ) ;save_nonewprivs ( ) ;set_caps ( ) ;save_cpu ( ) ;",save_cpu ( ) ;,5727
2278,# endif  FILE * rj = create_ready_for_join_file ( ) ;,# endif FILE * rj = create_ready_for_join_file ( ) ;,5727
2279,"}png_memset ( info_ptr , 0 , png_sizeof ( png_info ) ) ;","if ( info_ptr == NULL ) return ;}png_memset ( info_ptr , 0 , png_sizeof ( png_info ) ) ;",5728
2280,"opj_write_bytes ( p_data , J2K_MS_SOD ,  2 ) ;","if ( p_total_data_size < 4 ) {opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\\return OPJ_FALSE ;}opj_write_bytes ( p_data , J2K_MS_SOD , 2 ) ;",5729
2281,static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer )  {kfree ( mixer -> id_elems ) ;,static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) {snd_usb_mixer_disconnect ( mixer ) ;kfree ( mixer -> id_elems ) ;,5730
2282,"memcpy ( ( u8 * ) & priv -> curr_bss_params . bss_descriptor .  wmm_ie , wmm_param_ie , wmm_param_ie -> vend_hdr . len + 2 ) ;","if ( wmm_param_ie -> vend_hdr . len + 2 > sizeof ( struct ieee_types_wmm_parameter ) ) break ;memcpy ( ( u8 * ) & priv -> curr_bss_params . bss_descriptor . wmm_ie , wmm_param_ie , wmm_param_ie -> vend_hdr . len + 2 ) ;",5731
2283,"usleep ( 200000 ) ;memset ( hidreport , 0 , 9 ) ;","TEMP_FAILURE_RETRY ( usleep ( 200000 ) ) ;memset ( hidreport , 0 , 9 ) ;",5732
2284,if ( ! del_timer ( & task -> slow_task -> timer ) )  return ;,del_timer ( & task -> slow_task -> timer ) ;,5733
2285,"memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;fl6 . saddr = ireq -> ir_v6_loc_addr ;","memset ( & fl6 , rcu_dereference ( 0 , sizeof ( fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt ) , & final ) ;fl6 . saddr = ireq -> ir_v6_loc_addr ;",5734
2286,ue -> info = * info ;ue -> info . access = 0 ;,ue -> card = card ;ue -> info = * info ;ue -> info . access = 0 ;,5735
2287,"
",down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;,5736
2288,"truncate_pagecache ( inode , inode -> i_size ) ;if ( shrink )  ext4_truncate ( inode ) ;}","truncate_pagecache ( inode , inode -> i_size ) ;if ( shrink ) ext4_truncate ( inode ) ;up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;}",5736
2289,"pid_t my_pid = getpid ( ) ;char base [ sizeof ( ""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"" ) + 2 * sizeof ( long ) * 3 ] ;","if ( g_settings_privatereports ) {if ( ( g_opts & OPT_x ) ) log ( ""Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on"" ) ;mode = DEFAULT_DUMP_DIR_MODE ;my_euid = 0 ;}pid_t my_pid = getpid ( ) ;char base [ sizeof ( ""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"" ) + 2 * sizeof ( long ) * 3 ] ;",5737
2290,"
",if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) {return IHEVCD_INVALID_PARAMETER ;}if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) {return IHEVCD_INVALID_PARAMETER ;},5738
2291,"UEV_PARSE ( ""num_reorder_pics"" , value , ps_bitstrm ) ;ps_sps -> ai1_sps_max_num_reorder_pics [ i ] = value ;UEV_PARSE ( ""max_latency_increase"" , value , ps_bitstrm ) ;ps_sps -> ai1_sps_max_latency_increase [ i ] = value ;","UEV_PARSE ( ""num_reorder_pics"" , value , ps_bitstrm ) ;ps_sps -> ai1_sps_max_num_reorder_pics [ i ] = value ;UEV_PARSE ( ""max_latency_increase"" , value , ps_bitstrm ) ;ps_sps -> ai1_sps_max_latency_increase [ i ] = value ;",5738
2292,key_put ( ci -> ci_keyring_key ) ;crypto_free_skcipher ( ci -> ci_ctfm ) ;,crypto_free_skcipher ( ci -> ci_ctfm ) ;,5739
2293,"if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox )  {","size_t len = 0 ;if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) {",5740
2294,"snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>\\\\""%s\\\\"""" , subscribe ? """" : ""un"" , path ) ;if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\\","len = snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>"" , subscribe ? """" : ""un"" ) ;imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true ) ;if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\\",5740
2295,"if ( key_is_instantiated ( key ) )  seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ;","if ( key_is_positive ( key ) ) seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ;",5741
2296,return 0 ;},skip_metadata ( ps ) ;return 0 ;},5742
2297,if ( nsops < 1 )  return - EINVAL ;,if ( nsops < 1 || nsops > SEMOPM ) return - EINVAL ;,5743
2298,"vp8_sub_pixel_variance8x8 ( uptr , pre_stride ,  mv_col & 7 , mv_row & 7 , upred_ptr , uv_stride , & sse2 ) ;vp8_sub_pixel_variance8x8 ( vptr , pre_stride ,  mv_col & 7 , mv_row & 7 , vpred_ptr , uv_stride , & sse1 ) ;vp8_variance8x8 ( uptr , pre_stride ,  upred_ptr , uv_stride , & sse2 ) ;vp8_variance8x8 ( vptr , pre_stride ,  vpred_ptr , uv_stride , & sse1 ) ;","vpx_sub_pixel_variance8x8 ( uptr , pre_stride , mv_col & 7 , mv_row & 7 , upred_ptr , uv_stride , & sse2 ) ;vpx_sub_pixel_variance8x8 ( vptr , pre_stride , mv_col & 7 , mv_row & 7 , vpred_ptr , uv_stride , & sse1 ) ;vpx_variance8x8 ( uptr , pre_stride , upred_ptr , uv_stride , & sse2 ) ;vpx_variance8x8 ( vptr , pre_stride , vpred_ptr , uv_stride , & sse1 ) ;",5744
2299,"static void super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x ,  int * rate , int64_t * distortion , int * skippable , int64_t * sse , BLOCK_SIZE bsize , int64_t ref_best_rd ) {TX_SIZE uv_txfm_size = get_uv_tx_size ( mbmi ) ;int plane ;if ( ref_best_rd < 0 )   goto term ;if ( is_inter_block ( mbmi ) ) {int plane ;++ plane ) vp9_subtract_plane ( x , bsize , plane ) ;}* rate = 0 ;* distortion = 0 ;* sse = 0 ;* skippable = 1 ;for ( plane = 1 ;plane < MAX_MB_PLANE ;++ plane ) {txfm_rd_in_plane ( x , & pnrate , & pndist , & pnskip , & pnsse ,  ref_best_rd , plane , bsize , uv_txfm_size ,  cpi -> sf . use_fast_coef_costing ) ;if ( pnrate == INT_MAX )  goto term ;* rate += pnrate ;return ;term : * rate = INT_MAX ;return ;","static int super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , BLOCK_SIZE bsize , int64_t ref_best_rd ) {const TX_SIZE uv_tx_size = get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ;int plane ;int is_cost_valid = 1 ;if ( ref_best_rd < 0 ) is_cost_valid = 0 ;if ( is_inter_block ( mbmi ) && is_cost_valid ) {int plane ;+ plane ) vp9_subtract_plane ( x , bsize , plane ) ;+ plane ) {++ plane ) vp9_subtract_plane ( x , bsize , uv_tx_size , cpi -> sf . use_fast_coef_costing ) ;if ( pnrate == INT_MAX ) goto term ;* rate += pnrate ;if ( ! is_cost_valid ) {* rate = INT_MAX ;}return is_cost_valid ;",5745
2300,"int sctp_verify_asconf ( const struct sctp_association * asoc ,   struct sctp_paramhdr * param_hdr , void * chunk_end ,  struct sctp_paramhdr * * errp ) {sctp_addip_param_t * asconf_param ;union sctp_params param ;int length , plen ;param . v = ( sctp_paramhdr_t * ) param_hdr ;while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) {length = ntohs ( param . p -> length ) ;if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ;case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ;plen = ntohs ( asconf_param -> param_hdr . length ) ;if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ;case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ;default : break ;param . v += WORD_ROUND ( length ) ;if ( param . v != chunk_end ) return 0 ;return 1 ;","bool sctp_verify_asconf ( const struct sctp_association * asoc , struct sctp_chunk * chunk , bool addr_param_needed , struct sctp_paramhdr * * errp ) {sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr ;union sctp_params param ;bool addr_param_seen = false ;sctp_walk_params ( param , addip , addip_hdr . params ) {size_t length = ntohs ( param . p -> length ) ;case SCTP_PARAM_ERR_CAUSE : break ;case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ;addr_param_seen = true ;case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ;addr_param_seen = true ;case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ;length = ntohs ( param . addip -> param_hdr . length ) ;if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ;break ;case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ;break ;default : return false ;if ( addr_param_needed && ! addr_param_seen ) return false ;if ( ! addr_param_needed && addr_param_seen ) return false ;if ( param . v != chunk -> chunk_end ) return false ;return true ;",5746
2301,assert ( ! vct_iscrlf ( * p ) ) ;* p ++ = '\\\\0' ;assert ( ! vct_iscrlf ( * p ) ) ;hh [ n ++ ] = p ;if ( vct_iscrlf ( * p ) ) {hh [ n ++ ] = NULL ;,assert ( ! vct_iscrlf ( p ) ) ;* p ++ = '\\\\0' ;assert ( ! vct_iscrlf ( p ) ) ;hh [ n ++ ] = p ;if ( vct_iscrlf ( p ) ) {hh [ n ++ ] = NULL ;,5747
2302,while ( ! vct_iscrlf ( * p ) )  p ++ ;,while ( ! vct_iscrlf ( p ) ) p ++ ;,5747
2303,if ( vct_iscrlf ( * p ) )  break ;while ( * p != '\\\\0' && ! vct_iscrlf ( * p ) )  p ++ ;,if ( vct_iscrlf ( p ) ) break ;while ( * p != '\\\\0' && ! vct_iscrlf ( p ) ) p ++ ;,5747
2304,"spin_lock_irqsave ( & mpu -> input_lock , flags ) ;while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) !=  readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) {u16 wTmp , val ;val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ;if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ;wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ;if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ;else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ;spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ;","u16 head , tail , size ;spin_lock_irqsave ( & mpu -> input_lock , flags ) ;head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ;tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ;size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ;if ( head > size || tail > size ) goto out ;while ( head != tail ) {unsigned char val = readw ( pwMIDQData + 2 * head ) ;if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val , 1 ) ;if ( ++ head > size ) head = 0 ;writew ( head , mpu -> dev -> MIDQ + JQS_wHead ) ;out : spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ;",5748
2305,"if ( vma -> vm_ops ) {if ( likely ( vma -> vm_ops -> fault ) ) return do_fault ( mm , vma , address , pte ,  pmd , flags , entry ) ;}return do_anonymous_page ( mm , vma , address ,  pte , pmd , flags ) ;}","if ( vma -> vm_ops ) return do_fault ( mm , vma , address , pte , pmd , flags , entry ) ;}return do_anonymous_page ( mm , vma , address , pte , pmd , flags ) ;}",5749
2306,"case S_IFREG : case S_IFLNK : case S_IFDIR :  switch ( dip -> di_format ) {case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ;if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ;if ( dip -> di_nextents ) return __this_address ;case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ;default : return __this_address ;}switch ( dip -> di_aformat ) {case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ;case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ;default : return __this_address ;}","case S_IFREG : case S_IFLNK : case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ;if ( fa ) return fa ;fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ;if ( fa ) return fa ;",5750
2307,"it = item_get ( key , nkey , c , DO_UPDATE ) ;if ( settings . detail_enabled ) {","it = limited_get ( key , nkey , c ) ;if ( settings . detail_enabled ) {",5751
2308,"strncpy ( hid -> name , req -> name , 128 ) ;snprintf ( hid -> phys , sizeof ( hid -> phys ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ;","strncpy ( hid -> name , sizeof ( req -> name ) - 1 ) ;snprintf ( hid -> phys , sizeof ( hid -> phys ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ;",5752
2309,"jas_matrix_t * jas_matrix_create ( int numrows , int numcols )  {int i ;size_t size ;","jas_matrix_t * jas_matrix_create ( jas_matind_t numrows , jas_matind_t numcols ) {jas_matind_t i ;size_t size ;",5753
2310,"static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode ,  struct ext4_ext_path * path )  {struct ext4_extent * ex ;int depth ;ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical""  ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\\","static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path ) {struct ext4_extent * ex ;ext4_lblk_t ee_block ;unsigned int ee_len ;int depth ;ee_block = le32_to_cpu ( ex -> ee_block ) ;ee_len = ext4_ext_get_actual_len ( ex ) ;ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\\if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) {err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ;if ( err < 0 ) goto out ;ext4_ext_drop_refs ( path ) ;path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ;if ( IS_ERR ( path ) ) {err = PTR_ERR ( path ) ;goto out ;}depth = ext_depth ( inode ) ;ex = path [ depth ] . p_ext ;}",5754
2311,"char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ;if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) {","char * prop_chunk ;if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ;prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ;if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) {",5755
2312,"int family = sk -> sk_family ;struct sockaddr_in * sin ;struct sockaddr_in6 * sin6 ;if ( addr_len ) {if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ;else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ;}return ip_recv_error ( sk , msg , len ) ;","int family = sk -> sk_family ;struct sockaddr_in * return ip_recv_error ( sk , msg , len ) ;",5756
2313,"if ( family == AF_INET ) {sin = ( struct sockaddr_in * ) msg -> msg_name ;sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ;memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ;# if IS_ENABLED ( CONFIG_IPV6 ) }else if ( family == AF_INET6 ) {struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ;sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;","struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ;* addr_len = sizeof ( * sin6 ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;",5756
2314,"if ( ! port -> interrupt_in_urb ) {dev_err ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>interrupt_in_urb<S2SV_blank>is<S2SV_blank>empty!\\\return - 1 ;}","
",5757
2315,"
","if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ;switch ( val ) {case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ;default : return - EINVAL ;}lock_sock ( sk ) ;",5758
2316,"if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec )   return - EBUSY ;if ( copy_from_user ( & val , optval , sizeof ( val ) ) )  return - EFAULT ;return 0 ;default : return - EINVAL ;","if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) {ret = - EBUSY ;if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ;ret = 0 ;release_sock ( sk ) ;return ret ;",5758
2317,"addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ;addModuleArgument ( db , pTab , 0 ) ;addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ;rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ;","addModuleArgument ( pParse , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ;addModuleArgument ( pParse , pTab , 0 ) ;addModuleArgument ( pParse , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ;rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ;",5759
2318,"return write ( fd , & event , sizeof ( event ) ) ;}","return TEMP_FAILURE_RETRY ( write ( fd , & event , sizeof ( event ) ) ) ;}",5760
2319,"str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ;if ( str == ( unsigned char * ) NULL ) {","str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count + 1 , sizeof ( * str ) ) ;if ( str == ( unsigned char * ) NULL ) {",5761
2320,"struct ip_options * opt = inet_rsk ( req ) -> opt ;struct net * net = sock_net ( sk ) ;flowi4_init_output ( & fl4 , sk -> sk_bound_dev_if , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) ,  ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr ,  ireq -> loc_addr , ireq -> rmt_port , inet_sk ( sk ) -> inet_sport ) ;if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway )  goto route_err ;","struct ip_options_rcu * opt = inet_rsk ( req ) -> opt ;struct net * net = sock_net ( sk ) ;flowi4_init_output ( & fl4 , sk -> sk_bound_dev_if , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) , ( opt && opt -> opt . srr ) ? opt -> opt . faddr : ireq -> rmt_addr , ireq -> loc_addr , ireq -> rmt_port , inet_sk ( sk ) -> inet_sport ) ;if ( opt && opt -> opt . is_strictroute && rt -> rt_dst != rt -> rt_gateway ) goto route_err ;",5762
2321,field [ nf ] = lp ;if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) {,field [ nf ] = lp ;if ( nf >= MAXDATEFIELDS ) return - 1 ;if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) {,5763
2322,if ( nf > MAXDATEFIELDS )  return - 1 ;,"
",5763
2323,"int a = getnum ( L , fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;","int a = getnum ( fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;",5764
2324,"for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ;","for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] && frame -> linesize [ plane ] ;int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ;",5765
2325,"for ( plane = 1 ;plane ++ )  av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ;","for ( plane = 1 ;plane ++ ) av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ;",5765
2326,if ( i > ( sizeof ( outbuff ) - 20 ) ) {outbuff [ i ] = \'\\\\0\' ;,if ( i > ( sizeof ( outbuff ) - 128 ) ) {outbuff [ i ] = \'\\\\0\' ;,5766
2327,"static int test_candidate_kf ( struct twopass_rc * twopass ,  const FIRSTPASS_STATS * last_frame , const FIRSTPASS_STATS * this_frame , const FIRSTPASS_STATS * next_frame ) {if ( ( this_frame -> pcnt_second_ref < 0.10 ) &&   ( next_frame -> pcnt_second_ref < 0.10 ) &&  ( ( this_frame -> pcnt_inter < 0.05 ) || ( ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < 0.35 ) && ( ( this_frame -> intra_error /  DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) &&  ( ( fabs ( last_frame -> coded_error - this_frame -> coded_error ) /  DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > 0.40 ) ||  ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) /  DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > 0.40 ) ||  ( ( next_frame -> intra_error /  DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) {int i ;","static int test_candidate_kf ( TWO_PASS * twopass , const FIRSTPASS_STATS * last_frame , const FIRSTPASS_STATS * this_frame , const FIRSTPASS_STATS * next_frame ) {double pcnt_intra = 1.0 - this_frame -> pcnt_inter ;double modified_pcnt_inter = this_frame -> pcnt_inter - this_frame -> pcnt_neutral ;if ( ( this_frame -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( next_frame -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( ( this_frame -> pcnt_inter < VERY_LOW_INTER_THRESH ) || ( ( pcnt_intra > MIN_INTRA_LEVEL ) && ( pcnt_intra > ( INTRA_VS_INTER_THRESH * modified_pcnt_inter ) ) && ( ( this_frame -> pcnt_inter < 0.05 ) || ( ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < 0.35 ) && ( ( this_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < KF_II_ERR_THRESHOLD ) && ( ( fabs ( last_frame -> coded_error - this_frame -> coded_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > ERR_CHANGE_THRESHOLD ) || ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > ERR_CHANGE_THRESHOLD ) || ( ( next_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > II_IMPROVEMENT_THRESHOLD ) ) ) ) ) {int i ;",5767
2328,double next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error /  DOUBLE_DIVIDE_CHECK ( local_next_frame . coded_error ) ) ;if ( next_iiratio > RMAX )  next_iiratio = RMAX ;,double next_iiratio = ( BOOST_FACTOR * local_next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( local_next_frame . coded_error ) ) ;if ( next_iiratio > KF_II_MAX ) next_iiratio = KF_II_MAX ;,5767
2329,"for ( j = 1 ;lua_pushnumber ( L , j ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array"" ) ;for ( j = 1 ;lua_pushnumber ( L , j ) ;",5768
2330,"size_t maxlen = 3 * len ;struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ;","size_t maxlen = 3 * len + 8 ;struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ;",5769
2331,"if ( data -> multi_easy )   curl_multi_cleanup ( data -> multi_easy ) ;Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ;","if ( data -> multi_easy ) {curl_multi_cleanup ( data -> multi_easy ) ;data -> multi_easy = NULL ;}Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ;",5770
2332,"while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) {u16 wTmp ;snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ) ) ;wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ;if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) )  writew ( 0 , chip -> DSPQ + JQS_wHead ) ;}inb ( chip -> io + HP_RXL ) ;","u16 head , tail , size ;head = readw ( chip -> DSPQ + JQS_wHead ) + 1 ;if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) writew ( 0 , chip -> DSPQ + JQS_wHead ) ;}inb ( chip -> io + HP_RXL ) ;",5771
2333,m = PyModule_Create ( & _astmodule3 ) ;if ( ! m ) return NULL ;,m = PyModule_Create ( & _astmodule ) ;if ( ! m ) return NULL ;,5772
2334,"if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) {spin_lock_irq ( & child -> sighand -> siglock ) ;WARN_ON_ONCE ( task_is_stopped ( child ) ) ;if ( ignore_state || ( task_is_traced ( child ) &&  ! ( child -> jobctl & JOBCTL_LISTENING ) ) )  ret = 0 ;spin_unlock_irq ( & child -> sighand -> siglock ) ;if ( ! ret && ! ignore_state )   ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ;return ret ;","if ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) {WARN_ON ( child -> state == __TASK_TRACED ) ;if ( ignore_state || ( task_is_traced ( child ) && ! ( child -> jobctl & JOBCTL_LISTENING ) ) ) ret = 0 ;if ( ! ret && ! ignore_state ) {if ( ! wait_task_inactive ( child , __TASK_TRACED ) ) {WARN_ON ( child -> state == __TASK_TRACED ) ;ret = - ESRCH ;}}return ret ;",5773
2335,kfree ( user ) ;},cleanup_srcu_struct ( & user -> release_barrier ) ;kfree ( user ) ;},5774
2336,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;if ( error == 0 )  acl = NULL ;}","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",5775
2337,char * curl_cmd = NULL ;char * extractor_cmd = NULL ;char * abspath_to_archive = NULL ;char * abspath_to_file = NULL ;char * archive_name = NULL ;size_t archive_name_len = 0 ;char * symbol_store_path = NULL ;char * dbg_file = NULL ;char * guid = NULL ;char * archive_name_escaped = NULL ;char * user_agent = NULL ;char * symbol_server = NULL ;if ( ! checkCurl ( ) ) {return 0 ;,if ( ! checkCurl ( ) ) {return 0 ;,5776
2338,"symbol_store_path = r_str_escape ( opt -> symbol_store_path ) ;dbg_file = r_str_escape ( opt -> dbg_file ) ;abspath_to_archive = r_str_newf ( ""%s%s%s%s%s%s%s"" ,  symbol_store_path , R_SYS_DIR , dbg_file , R_SYS_DIR , guid , R_SYS_DIR , archive_name_escaped ) ;","symbol_store_path = r_str_escape ( opt -> symbol_store_path ) ;dbg_file = r_str_escape ( opt -> dbg_file ) ;abspath_to_archive = r_str_newf ( ""%s%s%s%s%s%s%s"" , symbol_store_path , R_SYS_DIR , dbg_file , R_SYS_DIR , guid , R_SYS_DIR , archive_name_escaped ) ;",5776
2339,"# else  const char * cabextractor = ""cabextract"" ;const char * format = ""%s<S2SV_blank>-d<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>\\\\""%s\\\\"""" ;extractor_cmd = r_str_newf ( format , cabextractor , abspath_to_dir , abspath_to_archive ) ;R_FREE ( abspath_to_dir ) ;# endif  eprintf ( ""Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>compressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\\if ( ( cmd_ret = r_sys_cmd ( curl_cmd ) != 0 ) ) {eprintf ( ""Attempting<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>pdb\\\if ( opt -> extract > 0 ) {if ( res && ( ( cmd_ret = r_sys_cmd ( extractor_cmd ) ) != 0 ) ) {eprintf ( ""cab<S2SV_blank>extractor<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%d\\\res = 0 ;}r_file_rm ( abspath_to_archive ) ;}R_FREE ( curl_cmd ) ;}if ( res == 0 ) {eprintf ( ""Falling<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uncompressed<S2SV_blank>pdb\\\res = 1 ;archive_name_escaped [ strlen ( archive_name_escaped ) - 1 ] = \'b\' ;curl_cmd = r_str_newf ( ""curl<S2SV_blank>-sfLA<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>\\\\""%s/%s/%s/%s\\\\""<S2SV_blank>--create-dirs<S2SV_blank>-o<S2SV_blank>\\\\""%s\\\\"""" , opt -> user_agent , opt -> symbol_server , opt -> dbg_file , opt -> guid , archive_name_escaped , abspath_to_file ) ;eprintf ( ""Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>uncompressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\\if ( ( cmd_ret = r_sys_cmd ( curl_cmd ) != 0 ) ) {eprintf ( ""curl<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%d\\\res = 0 ;}R_FREE ( curl_cmd ) ;R_FREE ( abspath_to_archive ) ;","# else const char * cabextractor = ""cabextract"" ;const char * format = ""%s<S2SV_blank>-d<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>\\\\""%s\\\\"""" ;extractor_cmd = r_str_newf ( format , cabextractor , abspath_to_dir , abspath_to_archive ) ;R_FREE ( abspath_to_dir ) ;# endif eprintf ( ""Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>compressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\\if ( ( cmd_ret = r_sys_cmd ( curl_cmd ) != 0 ) ) {char * abspath_to_file = r_str_newf ( ""%s%s%s%s%s%s%s"" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , opt -> dbg_file ) ;if ( r_file_exists ( abspath_to_file ) ) {eprintf ( ""File<S2SV_blank>already<S2SV_blank>downloaded.\\\free ( abspath_to_file ) ;return 1 ;if ( checkExtract ( ) || opt -> extract == 0 ) {char * extractor_cmd = NULL ;char * archive_name = strdup ( opt -> dbg_file ) ;archive_name [ strlen ( archive_name ) - 1 ] = \'b\' ;curl_cmd = r_str_newf ( ""cabextract<S2SV_blank>-d<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>\\\\""%s\\\\"""" , abs_arch_esc , abs_dir_esc ) ;free ( abs_dir_esc ) ;free ( abspath_to_dir ) ;",5776
2340,spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ;spl_handler_ArrayObject . read_property = spl_array_read_property ;,spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ;spl_handler_ArrayObject . get_gc = spl_array_get_gc ;spl_handler_ArrayObject . read_property = spl_array_read_property ;,5777
2341,error_cmd :  kfree ( cmd ) ;kfree_skb ( ack_skb ) ;,error_cmd : kfree_skb ( ack_skb ) ;kfree ( cmd ) ;,5778
2342,"if ( strcmp ( tokens [ 1 ] . value , ""tune"" ) == 0 && ntokens >= 7 ) {if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) {out_string ( c , ""ERROR"" ) ;}else {if ( pct_hot + pct_warm > 80 ) {out_string ( c , ""ERROR<S2SV_blank>hot<S2SV_blank>and<S2SV_blank>warm<S2SV_blank>pcts<S2SV_blank>must<S2SV_blank>not<S2SV_blank>exceed<S2SV_blank>80"" ) ;}else if ( factor <= 0 || hot_factor <= 0 ) {out_string ( c , ""ERROR<S2SV_blank>hot/warm<S2SV_blank>age<S2SV_blank>factors<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ;}else {settings . hot_lru_pct = pct_hot ;settings . warm_lru_pct = pct_warm ;settings . hot_max_factor = hot_factor ;settings . warm_max_factor = factor ;out_string ( c , ""OK"" ) ;}}}else if ( strcmp ( tokens [ 1 ] . value , ""mode"" ) == 0 && ntokens >= 3 &&  settings . lru_maintainer_thread ) {","if ( strcmp ( tokens [ 1 ] . value , ""tune"" ) == 0 && ntokens >= 4 && settings . lru_maintainer_thread ) {",5779
2343,"}else if ( strcmp ( tokens [ 1 ] . value , ""temp_ttl"" ) == 0 && ntokens >= 3 &&  settings . lru_maintainer_thread ) {","}else if ( strcmp ( tokens [ 1 ] . value , ""temp_ttl"" ) == 0 && ntokens >= 3 && settings . lru_maintainer_thread ) {",5779
2344,"ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ;if ( credssp -> server ) {","SecInvalidateHandle ( & credssp -> context ) ;ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ;if ( credssp -> server ) {",5780
2345,"for ( plane = 0 ;plane < 4 && src -> data [ plane ] ;plane ++ )  av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ;","for ( plane = 0 ;plane < 4 && src -> data [ plane ] && src -> linesize [ plane ] ;plane ++ ) av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ;",5781
2346,"int aff = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ;if ( aff > SQLITE_AFF_BLOB ) {","int aff ;if ( pExpr -> y . pTab ) {aff = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ;}else {aff = pExpr -> affExpr ;}if ( aff > SQLITE_AFF_BLOB ) {",5782
2347,"kfree ( inet -> opt ) ;dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ;","kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) ) ;dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ;",5783
2348,"if ( ! c -> c_normalize && ! init_normalization ( c ) ) {Py_DECREF ( id ) ;PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , id ) ;id2 = PyObject_Call ( c -> c_normalize , c -> c_normalize_args , NULL ) ;Py_DECREF ( id ) ;","PyObject * form ;PyObject * args [ 2 ] ;_Py_IDENTIFIER ( NFKC ) ;if ( ! c -> c_normalize && ! init_normalization ( c ) ) {Py_DECREF ( id ) ;return NULL ;}form = _PyUnicode_FromId ( & PyId_NFKC ) ;if ( form == NULL ) {Py_DECREF ( id ) ;args [ 0 ] = form ;args [ 1 ] = id ;id2 = _PyObject_FastCall ( c -> c_normalize_args , 1 , id ) ;id2 = PyObject_Call ( c -> c_normalize , args , 2 ) ;Py_DECREF ( id ) ;if ( ! PyUnicode_Check ( id2 ) ) {PyErr_Format ( PyExc_TypeError , ""unicodedata.normalize()<S2SV_blank>must<S2SV_blank>return<S2SV_blank>a<S2SV_blank>string,<S2SV_blank>not<S2SV_blank>"" ""%.200s"" , Py_TYPE ( id2 ) -> tp_name ) ;Py_DECREF ( id2 ) ;return NULL ;}",5784
2349,"if ( pdu -> securityStateRef &&  pdu -> command == SNMP_MSG_TRAP2 ) {netsnmp_assert ( pdu -> securityModel == SNMP_DEFAULT_SECMODEL ) ;ret = usm_clone_usmStateReference ( ( struct usmStateReference * ) pdu -> securityStateRef , ( struct usmStateReference * * ) & newpdu -> securityStateRef ) ;}if ( ( sptr = find_sec_mod ( newpdu -> securityModel ) ) != NULL && sptr -> pdu_clone != NULL ) {","sptr = find_sec_mod ( newpdu -> securityModel ) ;if ( sptr && sptr -> pdu_clone ) {ret = sptr -> pdu_clone ( pdu , newpdu ) ;}if ( ( sptr = find_sec_mod ( newpdu -> securityModel ) ) != NULL && sptr -> pdu_clone != NULL ) {",5785
2350,"while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE )  {","while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) {",5786
2351,"struct dw2102_state * state = d -> priv ;u8 obuf [ 3 ] = {0xe , 0x80 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x02 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;m88ds3103_pdata . clk = 27000000 ;","struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0x0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x02 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;mutex_unlock ( & d -> data_mutex ) ;m88ds3103_pdata . clk = 27000000 ;",5787
2352,"ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;* val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) &   0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ;return 0 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;* val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( jas_longlong , ( ( ( ~ tmp ) & 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( jas_longlong , tmp ) ;return 0 ;",5788
2353,"mipspmu_event_update ( event , hwc , idx ) ;data -> period = event -> hw . last_period ;if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ;if ( perf_event_overflow ( event , 0 , data , regs ) )  mipspmu -> disable_event ( idx ) ;","mipspmu_event_update ( event , data , regs ) ) mipspmu -> disable_event ( idx ) ;",5789
2354,"mrb_value value ;fiber_check_cfunc ( mrb , c ) ;if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>transferred<S2SV_blank>fiber"" ) ;}if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""double<S2SV_blank>resume<S2SV_blank>(fib)"" ) ;}if ( c -> status == MRB_FIBER_TERMINATED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>dead<S2SV_blank>fiber"" ) ;}mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ;c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ;if ( c -> status == MRB_FIBER_CREATED ) {mrb_value * b , * e ;if ( len >= c -> stend - c -> stack ) {mrb_raise ( mrb , E_FIBER_ERROR , ""too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>to<S2SV_blank>fiber"" ) ;}","enum mrb_fiber_state status ;mrb_value value ;fiber_check_cfunc ( mrb , c ) ;status = c -> status ;if ( resume && status == MRB_FIBER_TRANSFERRED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>transferred<S2SV_blank>fiber"" ) ;}if ( status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""double<S2SV_blank>resume<S2SV_blank>(fib)"" ) ;}if ( status == MRB_FIBER_TERMINATED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>dead<S2SV_blank>fiber"" ) ;}old_c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ;c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ;fiber_switch_context ( mrb , c ) ;if ( status == MRB_FIBER_CREATED ) {mrb_value * b , * e ;mrb_stack_extend ( mrb , len + 2 ) ;",5790
2355,"fiber_switch_context ( mrb , c ) ;if ( vmexec ) {",if ( vmexec ) {,5790
2356,# endif EVP_MD_CTX md_ctx ;,# endif EVP_MD_CTX_init ( & md_ctx ) ;EVP_MD_CTX md_ctx ;,5791
2357,"# endif  n = s -> method -> ssl_get_message ( s ,  SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ;if ( ! ok ) return ( ( int ) n ) ;if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) {# ifndef OPENSSL_NO_PSK   if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK )  {","# endif n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ;if ( ! ok ) return ( ( int ) n ) ;alg_k = s -> s3 -> tmp . new_cipher -> algorithm_auth ;al = SSL_AD_UNEXPECTED_MESSAGE ;goto f_err ;}# ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) {s -> session -> sess_cert = ssl_sess_cert_new ( ) ;if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ;s -> ctx -> psk_identity_hint = NULL ;}# endif s -> s3 -> tmp . reuse_message = 1 ;return ( 1 ) ;}param = p = ( unsigned char * ) s -> init_msg ;if ( s -> session -> sess_cert != NULL ) {# ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) {RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ;s -> session -> sess_cert -> peer_rsa_tmp = NULL ;}# endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) {DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ;s -> session -> sess_cert -> peer_dh_tmp = NULL ;}# endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) {EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ;s -> session -> sess_cert -> peer_ecdh_tmp = NULL ;}# endif }else {s -> session -> sess_cert = ssl_sess_cert_new ( ) ;}param_len = 0 ;alg_a = s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) {",5791
2358,"static void write_mv_update ( const vp9_tree_index * tree ,   vp9_prob probs [ ] ,  const unsigned int counts [ ] ,  int n , vp9_writer * w ) {int i ;","static void write_mv_update ( const vpx_tree_index * tree , vp9_prob probs [ ] , const unsigned int counts [ ] , int n , vpx_writer * w ) {int i ;",5792
2359,if ( val == 0 && sp -> do_auto_asconf ) {list_del ( & sp -> auto_asconf_list ) ;return 0 ;},spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;if ( val == 0 && sp -> do_auto_asconf ) {list_del ( & sp -> auto_asconf_list ) ;spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;return 0 ;},5793
2360,"int len = mutt_b64_decode ( buffer , encoded ) ;if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) {","int len = mutt_b64_decode ( buffer , encoded , sizeof ( buffer ) ) ;if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) {",5794
2361,"}if ( trans == NULL ) {kmem_cache_free ( rds_conn_slab , conn ) ;conn = ERR_PTR ( - ENODEV ) ;goto out ;","
",5795
2362,"void vp9_iht4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride ,  int tx_type ) {{idct4 , idct4 },  {iadst4 , idct4 }idct4 , iadst4 }iadst4 , iadst4 }int16_t out [ 4 * 4 ] ;int16_t * outptr = out ;int16_t temp_in [ 4 ] , temp_out [ 4 ] ;for ( i = 0 ;","void vp9_iht4x4_16_add_c ( const tran_low_t * input , uint8_t * dest , int stride , int tx_type ) {{idct4_c , idct4_c }iadst4_c , idct4_c }idct4_c , iadst4_c }, {iadst4_c , iadst4_c }tran_low_t out [ 4 * 4 ] ;tran_low_t * outptr = out ;int16_t temp_in [ 4 ] , temp_out [ 4 ] ;for ( i = 0 ;",5796
2363,"++ j ) temp_in [ j ] = out [ j * 4 + i ] ;for ( j = 0 ;++ j )   dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 )   + dest [ j * stride + i ] ) ;}","+ j ) temp_in [ j ] = out [ j * 4 + i ] ;++ j ) {temp_in [ j ] = out [ j * 4 + i ] ;for ( j = 0 ;+ j )   dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 )   + dest [ j * stride + i ] ) ;++ j ) dest [ j * stride + i ] = clip_pixel_add ( dest [ j * stride + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) ) ;}}",5796
2364,"if ( ! chrooted && strncmp ( dir , home , strlen ( home ) ) ) {DBG ( ""Failed<S2SV_blank>non-chroot<S2SV_blank>dir:%s<S2SV_blank>vs<S2SV_blank>home:%s"" , dir , home ) ;","if ( ! chrooted && strncmp ( rpath , home , strlen ( home ) ) ) {DBG ( ""Failed<S2SV_blank>non-chroot<S2SV_blank>dir:%s<S2SV_blank>vs<S2SV_blank>home:%s"" , dir , home ) ;",5797
2365,pinctrl_unregister ( gpio_dev -> pctrl ) ;return 0 ;,return 0 ;,5798
2366,"size_t l = 0 ;do {ptr += strspn ( ptr , ""\\\\r\\\if ( * ptr == \'\\\\0\' || ptr >= buf + len ) {l = strcspn ( ptr , ""\\\\r\\\if ( l > 3 && ptr + l <= buf + len ) {p += base64decode_block ( outbuf + p , ptr , l ) ;ptr += l ;else {break ;","int wv , w1 , w2 , w3 , w4 ;int tmpval [ 4 ] ;int tmpcnt = 0 ;do {while ( ptr < buf + len && ( * ptr == \'<S2SV_blank>\' || * ptr == \'\\\\t\' || * ptr == \'\\\ptr ++ ;}if ( * ptr == \'\\\\0\' || ptr >= buf + len ) {if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) {continue ;}tmpval [ tmpcnt ++ ] = wv ;if ( tmpcnt == 4 ) {tmpcnt = 0 ;w1 = tmpval [ 0 ] ;w2 = tmpval [ 1 ] ;w3 = tmpval [ 2 ] ;w4 = tmpval [ 3 ] ;if ( w2 >= 0 ) {outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ;}if ( w3 >= 0 ) {outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ;}if ( w4 >= 0 ) {outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ;",5799
2367,"if ( likely ( walk . nbytes == nbytes ) )  {salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ;return blkcipher_walk_done ( desc , & walk , 0 ) ;}","
",5800
2368,rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ;,"if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) {iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ;goto done ;}rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ;",5801
2369,int tlen ;uint8_t nitems ;ND_TCHECK ( * vqp_common_header ) ;if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) {,u_int tlen ;uint8_t nitems ;ND_TCHECK ( * vqp_common_header ) ;if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc ;if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) {,5802
2370,vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ;vqp_obj_len = EXTRACT_16BITS ( vqp_obj_tlv -> obj_length ) ;,ND_TCHECK ( * vqp_obj_tlv ) ;if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ;vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ;vqp_obj_len = EXTRACT_16BITS ( vqp_obj_tlv -> obj_length ) ;,5802
2371,"switch ( vqp_obj_type ) {case VQP_OBJ_IP_ADDRESS :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ;break ;case VQP_OBJ_MAC_ADDRESS :  case VQP_OBJ_MAC_NULL :  ND_PRINT ( ( ndo , ""%s"" , etheraddr_string ( ndo , tptr ) ) ) ;","if ( vqp_obj_len > tlen ) goto trunc ;switch ( vqp_obj_type ) {case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ;break ;case VQP_OBJ_MAC_ADDRESS : case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""%s"" , etheraddr_string ( ndo , tptr ) ) ) ;",5802
2372,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;line_step = frame -> linesize [ plane ] ;,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ;line_step = frame -> linesize [ plane ] ;,5803
2373,if ( tsk -> io_context )  exit_io_context ( ) ;if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ;,if ( tsk -> io_context ) exit_io_context ( tsk ) ;if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ;,5804
2374,if ( key_is_instantiated ( key ) ) {int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ;,if ( key_is_positive ( key ) ) {int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ;,5805
2375,static void pcrypt_free ( struct crypto_instance * inst )  {struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;crypto_drop_aead ( & ctx -> spawn ) ;,static void pcrypt_free ( struct aead_instance * inst ) {struct pcrypt_instance_ctx * ctx = aead_instance_ctx ( inst ) ;crypto_drop_aead ( & ctx -> spawn ) ;,5806
2376,"uint8_t value ;dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\\ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV ,  0 , reg , & value , 1 , 1000 ) ;return ret >= 0 ? value : ret ;}","uint8_t * buffer ;uint8_t value ;buffer = kmalloc ( 1 , GFP_KERNEL ) ;if ( ! buffer ) return - ENOMEM ;dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\\ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , 0 , reg , buffer , 1 , 1000 ) ;return ret >= 0 ) {value = buffer [ 0 ] ;kfree ( buffer ) ;return value ;}else {kfree ( buffer ) ;return ret ;}}",5807
2377,"int main_loop ( int argc , const char * * argv_ ) {vpx_codec_ctx_t decoder ;int do_md5 = 0 , progress = 0 ;int stop_after = 0 , postproc = 0 , summary = 0 , quiet = 1 ;int ec_enabled = 0 ;const VpxInterface * interface = NULL ;vpx_codec_dec_cfg_t cfg = {0 }# if CONFIG_VP8_DECODER vp8_postproc_cfg_t vp8_pp_cfg = {","static int main_loop ( int argc , const char * * argv_ ) {vpx_codec_ctx_t decoder ;int do_md5 = 0 , progress = 0 , frame_parallel = 0 ;int stop_after = 0 , postproc = 0 , summary = 0 , quiet = 1 ;int ec_enabled = 0 ;int keep_going = 0 ;const VpxInterface * interface = NULL ;int opt_yv12 = 0 ;int opt_i420 = 0 ;vpx_codec_dec_cfg_t cfg = {0 , 0 , 0 }# if CONFIG_VP9_HIGHBITDEPTH int output_bit_depth = 0 ;# endif # if CONFIG_VP8_DECODER vp8_postproc_cfg_t vp8_pp_cfg = {",5808
2378,"int frame_avail , got_data ;int num_external_frame_buffers = 0 ;struct ExternalFrameBufferList ext_fb_list = {0 }const char * outfile_pattern = NULL ;struct VpxDecInputContext input = {0 }struct VpxInputContext vpx_input_ctx = {struct WebmInputContext webm_ctx = {0 };input . vpx_input_ctx = & vpx_input_ctx ;input . webm_ctx = & webm_ctx ;","# if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * img_shifted = NULL ;# endif int frame_avail , got_data , flush_decoder = 0 ;int num_external_frame_buffers = 0 ;struct ExternalFrameBufferList ext_fb_list = {0 , NULL }const char * outfile_pattern = NULL ;struct VpxDecInputContext input = {NULL , NULL }struct VpxInputContext vpx_input_ctx ;# if CONFIG_WEBM_IO struct WebmInputContext webm_ctx = {input . webm_ctx = & webm_ctx ;# endif input . vpx_input_ctx = & vpx_input_ctx ;",5808
2379,"if ( arg_match ( & arg , & codecarg , argi ) ) {","opt_yv12 = 1 ;# if CONFIG_VP9_HIGHBITDEPTH output_bit_depth = 8 ;# endif if ( arg_match ( & arg , & codecarg , argi ) ) {",5808
2380,"}use_y4m = 0 ;}else if ( arg_match ( & arg , & flipuvarg , argi ) )  flipuv = 1 ;else if ( arg_match ( & arg , & skiparg , argi ) ) arg_skip = arg_parse_uint ( & arg ) ;else if ( arg_match ( & arg , & postprocarg , argi ) ) postproc = 1 ;else if ( arg_match ( & arg , & verbosearg , argi ) )  quiet = 0 ;else if ( arg_match ( & arg , & fb_arg , argi ) )  num_external_frame_buffers = arg_parse_uint ( & arg ) ;# if CONFIG_VP8_DECODER else if ( arg_match ( & arg , & addnoise_level , argi ) ) {","opt_i420 = 1 ;}else if ( arg_match ( & arg , & rawvideo , argi ) ) {use_y4m = 0 ;}use_y4m = 0 ;}else if ( arg_match ( & arg , & flipuvarg , argi ) ) flipuv = 1 ;# if CONFIG_VP9_DECODER || CONFIG_VP10_DECODER else if ( arg_match ( & arg , & frameparallelarg , argi ) ) frame_parallel = 1 ;# endif else if ( arg_match ( & arg , & skiparg , argi ) ) arg_skip = arg_parse_uint ( & arg ) ;else if ( arg_match ( & arg , & continuearg , argi ) ) keep_going = 1 ;# if CONFIG_VP9_HIGHBITDEPTH else if ( arg_match ( & arg , & outbitdeptharg , argi ) ) {output_bit_depth = arg_parse_uint ( & arg ) ;}# endif else if ( arg_match ( & arg , & postprocarg , argi ) ) postproc = 1 ;else if ( arg_match ( & arg , & verbosearg , argi ) ) quiet = 0 ;else if ( arg_match ( & arg , & fb_arg , argi ) ) num_external_frame_buffers = arg_parse_uint ( & arg ) ;# if CONFIG_VP8_DECODER else if ( arg_match ( & arg , & addnoise_level , argi ) ) {",5808
2381,"if ( ! fn )   usage_exit ( ) ;infile = strcmp ( fn , ""-"" ) ? fopen ( fn , ""rb"" ) : set_binary_mode ( stdin ) ;fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\\\'%s\\\'"" , strcmp ( fn , ""-"" ) ? fn : ""stdin"" ) ;return EXIT_FAILURE ;","if ( ! fn ) {free ( argv ) ;usage_exit ( ) ;}infile = strcmp ( fn , ""-"" ) ? fopen ( fn , ""rb"" ) : set_binary_mode ( stdin ) ;fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file<S2SV_blank>\\\'%s\\\'"" , strcmp ( fn , ""-"" ) ? fn : ""stdin"" ) ;",5808
2382,"fprintf ( stderr , ""YUV4MPEG2<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>output<S2SV_blank>patterns,""  ""<S2SV_blank>try<S2SV_blank>--i420<S2SV_blank>or<S2SV_blank>--yv12.\\\return EXIT_FAILURE ;","fprintf ( stderr , ""YUV4MPEG2<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>output<S2SV_blank>patterns,"" ""<S2SV_blank>try<S2SV_blank>--i420<S2SV_blank>or<S2SV_blank>--yv12<S2SV_blank>or<S2SV_blank>--rawvideo.\\\return EXIT_FAILURE ;",5808
2383,"dec_flags = ( postproc ? VPX_CODEC_USE_POSTPROC : 0 ) |  ( ec_enabled ? VPX_CODEC_USE_ERROR_CONCEALMENT : 0 ) ;if ( vpx_codec_dec_init ( & decoder , interface -> interface ( ) , & cfg , dec_flags ) ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder:<S2SV_blank>%s\\\","dec_flags = ( postproc ? VPX_CODEC_USE_POSTPROC : 0 ) | ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 ) | ( ec_enabled ? VPX_CODEC_USE_ERROR_CONCEALMENT : 0 ) ;if ( vpx_codec_dec_init ( & decoder , interface -> codec_interface ( ) , & cfg , dec_flags ) ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder:<S2SV_blank>%s\\\",5808
2384,int corrupted ;frame_avail = 0 ;,int corrupted = 0 ;frame_avail = 0 ;,5808
2385,"goto fail ;}}}vpx_usec_timer_start ( & timer ) ;got_data = 0 ;if ( ( img = vpx_codec_get_frame ( & decoder , & iter ) ) ) {if ( vpx_codec_control ( & decoder , VP8D_GET_FRAME_CORRUPTED , & corrupted ) ) {warn ( ""Failed<S2SV_blank>VP8_GET_FRAME_CORRUPTED:<S2SV_blank>%s"" , vpx_codec_error ( & decoder ) ) ;goto fail ;","if ( ! keep_going ) goto fail ;}}else {flush_decoder = 1 ;}}else {flush_decoder = 1 ;}vpx_usec_timer_start ( & timer ) ;if ( flush_decoder ) {if ( vpx_codec_decode ( & decoder , NULL , 0 , NULL , 0 ) ) {warn ( ""Failed<S2SV_blank>to<S2SV_blank>flush<S2SV_blank>decoder:<S2SV_blank>%s"" , vpx_codec_error ( & decoder ) ) ;}}got_data = 0 ;if ( ! frame_parallel && ( img = vpx_codec_get_frame ( & decoder , & iter ) ) ) {if ( vpx_codec_control ( & decoder , VP8D_GET_FRAME_CORRUPTED , & corrupted ) ) {warn ( ""Failed<S2SV_blank>VP8_GET_FRAME_CORRUPTED:<S2SV_blank>%s"" , vpx_codec_error ( & decoder ) ) ;if ( ! keep_going ) goto fail ;",5808
2386,"scaled_img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , display_width ,   display_height , 16 ) ;}vpx_image_scale ( img , scaled_img , kFilterBox ) ;img = scaled_img ;}}if ( single_file ) {if ( frame_out == 1 ) {len = y4m_write_file_header ( buf , sizeof ( buf ) , vpx_input_ctx . width , vpx_input_ctx . height ,  & vpx_input_ctx . framerate , img -> fmt ) ;if ( do_md5 ) {len = y4m_write_frame_header ( buf , sizeof ( buf ) ) ;if ( do_md5 ) {MD5Update ( & md5_ctx , ( md5byte * ) buf , ( unsigned int ) len ) ;}fputs ( buf , outfile ) ;}if ( do_md5 ) {","scaled_img = vpx_img_alloc ( NULL , img -> fmt , display_width , display_height , 16 ) ;scaled_img -> bit_depth = img -> bit_depth ;}# if CONFIG_LIBYUV libyuv_scale ( img , scaled_img , kFilterBox ) ;img = scaled_img ;# else fprintf ( stderr , ""Failed<S2SV_blank><S2SV_blank>to<S2SV_blank>scale<S2SV_blank>output<S2SV_blank>frame:<S2SV_blank>%s.\\\return EXIT_FAILURE ;# endif }}# if CONFIG_VP9_HIGHBITDEPTH if ( ! output_bit_depth ) {output_bit_depth = img -> bit_depth ;}if ( output_bit_depth != img -> bit_depth ) {const vpx_img_fmt_t shifted_fmt = output_bit_depth == 8 ? img -> fmt ^ ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) : img -> fmt | VPX_IMG_FMT_HIGHBITDEPTH ;if ( img -> fmt , img -> bit_depth == VPX_IMG_FMT_I440 || img -> fmt == VPX_IMG_FMT_I44016 ) {fprintf ( stderr , ""Cannot<S2SV_blank>produce<S2SV_blank>y4m<S2SV_blank>output<S2SV_blank>for<S2SV_blank>440<S2SV_blank>sampling.\\\goto fail ;}if ( img_shifted && img_shifted_realloc_required ( img , img_shifted , shifted_fmt ) ) {vpx_img_free ( img_shifted ) ;img_shifted = NULL ;}if ( ! img_shifted ) {img_shifted = vpx_img_alloc ( NULL , shifted_fmt , img -> d_w , img -> d_h , 16 ) ;img_shifted -> bit_depth = output_bit_depth ;}if ( output_bit_depth > img -> bit_depth ) {vpx_img_upshift ( img_shifted , img , output_bit_depth - img -> bit_depth ) ;}else {vpx_img_downshift ( img_shifted , img , img -> bit_depth - output_bit_depth ) ;}img = img_shifted ;}# endif if ( single_file ) {if ( frame_out == 1 ) {len = y4m_write_file_header ( buf , sizeof ( buf ) , vpx_input_ctx . width , vpx_input_ctx . height , & vpx_input_ctx . framerate , img -> fmt ) ;if ( do_md5 ) {if ( frame_out == 1 ) {if ( opt_i420 ) {if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_I42016 ) {fprintf ( stderr , ""Cannot<S2SV_blank>produce<S2SV_blank>i420<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\\goto fail ;}if ( opt_yv12 ) {if ( ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) || img -> bit_depth != 8 ) {fprintf ( stderr , ""Cannot<S2SV_blank>produce<S2SV_blank>yv12<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\\goto fail ;}}}}if ( do_md5 ) {",5808
2387,if ( stop_after && frame_in >= stop_after )  break ;,if ( stop_after && frame_in >= stop_after ) break ;,5808
2388,if ( scaled_img ) vpx_img_free ( scaled_img ) ;for ( i = 0 ;,if ( scaled_img ) vpx_img_free ( scaled_img ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( img_shifted ) vpx_img_free ( img_shifted ) ;# endif for ( i = 0 ;,5808
2389,"if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) )  return - EFAULT ;","memset ( txc , 0 , sizeof ( struct timex ) ) ;if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) return - EFAULT ;",5809
2390,if ( key_is_instantiated ( key ) ) {int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ;,if ( key_is_positive ( key ) ) {int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ;,5810
2391,"return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ;}","struct dm_dev * dev = fc -> dev ;int r = 0 ;if ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ;}",5811
2392,char buf [ L_BUF_SIZE ] ;l_uint8 * allheaders ;,char buf [ L_BUFSIZE ] ;l_uint8 * allheaders ;,5812
2393,"ret = sscanf ( argv [ i ] + 1 , ""prestring=%s"" , buf ) ;if ( ret != 1 ) {if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) {L_WARNING ( ""prestring<S2SV_blank>too<S2SV_blank>large;","ret = sscanf ( argv [ i ] + 1 , ""prestring=%490s"" , buf ) ;if ( ret != 1 ) {if ( ( len = strlen ( buf ) ) > L_BUFSIZE - 3 ) {L_WARNING ( ""prestring<S2SV_blank>too<S2SV_blank>large;",5812
2394,"ret = sscanf ( argv [ i ] + 1 , ""protos=%s"" , buf ) ;if ( ret != 1 ) {","ret = sscanf ( argv [ i ] + 1 , ""protos=%490s"" , buf ) ;if ( ret != 1 ) {",5812
2395,"snprintf ( buf , L_BUF_SIZE ,  ""<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\\\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s"" , version ) ;","snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\\\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s"" , version ) ;",5812
2396,"snprintf ( buf , L_BUF_SIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" ,  filein , tempfile ) ;","snprintf ( buf , L_BUFSIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" , filein , tempfile ) ;",5812
2397,"char buf [ L_BUF_SIZE ] ;char emptystring [ ] = """" ;","char buf [ L_BUFSIZE ] ;char emptystring [ ] = """" ;",5813
2398,"snprintf ( buf , L_BUF_SIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ;sarrayAddString ( gplot -> datanames , buf , L_COPY ) ;","snprintf ( buf , L_BUFSIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ;sarrayAddString ( gplot -> datanames , buf , L_COPY ) ;",5813
2399,"snprintf ( buf , L_BUF_SIZE , ""%f<S2SV_blank>%f\\\sarrayAddString ( sa , buf , L_COPY ) ;","snprintf ( buf , L_BUFSIZE , ""%f<S2SV_blank>%f\\\sarrayAddString ( sa , buf , L_COPY ) ;",5813
2400,"struct mount * n , * p ;for ( n = m ;if ( p == dest_master || IS_MNT_MARKED ( p ) ) {while ( last_dest -> mnt_master != p ) {last_source = last_source -> mnt_master ;last_dest = last_source -> mnt_parent ;if ( ! peers ( n , last_dest ) ) {last_dest = last_source -> mnt_parent ;}break ;}","struct mount * n , * p ;bool done ;for ( n = m ;if ( p == dest_master || IS_MNT_MARKED ( p ) ) break ;do {struct mount * parent = last_source -> mnt_parent ;if ( last_source == first_source ) break ;done = parent -> mnt_master == p ;if ( done && peers ( n , parent ) ) break ;while ( ! done ) ;",5814
2401,"slapi_send_ldap_result ( pb , LDAP_NO_SUCH_OBJECT , NULL , NULL , 0 , NULL ) ;return ( SLAPI_BIND_FAIL ) ;slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ;slapi_entry_free ( ec ) ;slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ;slapi_entry_free ( ec ) ;","slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ;slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ;return ( SLAPI_BIND_FAIL ) ;slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set"" ) ;slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ;slapi_entry_free ( ec ) ;slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Invalid<S2SV_blank>credentials"" ) ;slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ;slapi_entry_free ( ec ) ;",5815
2402,vpn_packet_t outpkt ;outpkt . len = len ;,vpn_packet_t outpkt ;if ( len > sizeof outpkt . data ) return ;outpkt . len = len ;,5816
2403,last_source = source_mnt ;mp = dest_mp ;,first_source = source_mnt ;last_source = source_mnt ;mp = dest_mp ;,5817
2404,"if ( error ) return error ;dentry = fhp -> fh_dentry ;inode = d_inode ( dentry ) ;if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) )  return nfserr_attrnotsupp ;host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ;if ( host_error < 0 )  goto out_release ;if ( S_ISDIR ( inode -> i_mode ) ) {host_error = inode -> i_op -> set_acl ( inode , dpacl ,  ACL_TYPE_DEFAULT ) ;out_release :  posix_acl_release ( pacl ) ;","fh_lock ( fhp ) ;host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl ) ;if ( host_error < 0 ) goto out_drop_lock ;if ( S_ISDIR ( inode -> i_mode ) ) {host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl ) ;out_release : posix_acl_release ( pacl ) ;",5818
2405,"assert ( bi != NULL ) ;dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"" ""PosDecode,<S2SV_blank>EntireRange,"" ) ;","dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"" ""PosDecode,<S2SV_blank>EntireRange,"" ) ;",5819
2406,"unsigned long off ;unsigned long start ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) )  return - EINVAL ;off = vma -> vm_pgoff << PAGE_SHIFT ;fb = info -> fbops ;if ( fb -> fb_mmap ) {int res ;len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . smem_len ) ;if ( off >= len ) {off -= len ;if ( info -> var . accel_flags ) {mutex_unlock ( & info -> mm_lock ) ;return - EINVAL ;}len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . mmio_len ) ;start &= PAGE_MASK ;if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) return - EINVAL ;off += start ;vma -> vm_pgoff = off >> PAGE_SHIFT ;fb_pgprotect ( file , vma , off ) ;if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) return - EAGAIN ;return 0 ;","unsigned long mmio_pgoff ;unsigned long start ;fb = info -> fbops ;if ( fb -> fb_mmap ) {int res ;len = info -> fix . smem_len ;mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ;if ( vma -> vm_pgoff >= mmio_pgoff ) {vma -> vm_pgoff -= mmio_pgoff ;len = info -> fix . mmio_len ;if ( fb -> fb_mmap ) {int res ;res = fb -> fb_mmap ( info , vma ) ;mutex_unlock ( & info -> mm_lock ) ;fb_pgprotect ( file , vma , start ) ;return vm_iomap_memory ( vma , start , len ) ;",5820
2407,spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ;spl_handler_ArrayObject . read_property = spl_array_read_property ;,spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ;spl_handler_ArrayObject . get_gc = spl_array_get_gc ;spl_handler_ArrayObject . read_property = spl_array_read_property ;,5821
2408,"return PNG_OUT_OF_MEMORY_ERROR ;}if ( setjmp ( mainprog_ptr -> jmpbuf ) ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return LIBPNG_FATAL_ERROR ;}# if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ;# endif # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) ""pHYs\\\\0iTXt\\\\0tEXt\\\\0zTXt"" , 4 ) ;# endif png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ;struct rwpng_read_data read_data = {infile , 0 };png_set_read_fn ( png_ptr , & read_data , user_read_data ) ;png_read_info ( png_ptr , info_ptr ) ;png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , & bit_depth , & color_type , NULL , NULL , NULL ) ;if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return PNG_OUT_OF_MEMORY_ERROR ;}","
",5822
2409,"
","if ( rowbytes > INT_MAX / mainprog_ptr -> height ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return PNG_OUT_OF_MEMORY_ERROR ;}",5822
2410,"if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) {fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\","if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) {fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\",5822
2411,"void isoclns_print ( netdissect_options * ndo ,  const uint8_t * p , u_int length , u_int caplen )  {if ( caplen <= 1 ) {ND_PRINT ( ( ndo , ""|OSI"" ) ) ;case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) )  print_unknown_data ( ndo , p , ""\\\break ;case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) )  print_unknown_data ( ndo , p , ""\\\break ;","void isoclns_print ( netdissect_options * ndo , const uint8_t * p , u_int length ) {if ( caplen <= 1 ) {ND_PRINT ( ( ndo , ""|OSI"" ) ) ;case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) ) print_unknown_data ( ndo , p , ""\\\break ;case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) ) print_unknown_data ( ndo , p , ""\\\break ;",5823
