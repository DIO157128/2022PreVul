,source,target,group
0,"resend : if ( ! setup_stratum_socket ( pool ) ) {sockd = false ;goto out ;}sockd = true ;if ( recvd ) {clear_sock ( pool ) ;sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;}else {if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\"",<S2SV_blank>\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\""]}"" , swork_id ++ ) ;}if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) {",resend : if ( ! valid_hex ( nonce1 ) ) {,0
1,"applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ;if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;nonce1 = json_array_string ( res_val , 1 ) ;if ( ! nonce1 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;","applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;if ( n2size < 2 || n2size > 16 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;",0
2,"ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ;tptr += sizeof ( const struct eap_frame_t ) ;tlen -= sizeof ( const struct eap_frame_t ) ;switch ( eap -> type ) {case EAP_FRAME_TYPE_PACKET :  type = * ( tptr ) ;len = EXTRACT_16BITS ( tptr + 2 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\","ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , subtype ) , subtype ) ) ;ND_TCHECK_8BITS ( tptr + 4 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\",1
3,"ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST :  ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM :  ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" ,  tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;","ND_TCHECK_8BITS ( tptr + count ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ;if ( subtype == EAP_TYPE_TTLS ) ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS : ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;",1
4,"
",kfree_skb ( skb ) ;,2
5,return - ETIMEDOUT ;},return - ETIMEDOUT ;},2
6,case SIOCYAMGCFG :  yi . cfg . mask = 0xffffffff ;yi . cfg . iobase = yp -> iobase ;,"case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;yi . cfg . mask = 0xffffffff ;yi . cfg . iobase = yp -> iobase ;",3
7,"if ( unlikely ( skb -> len <= mss ) ) goto out ;if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) {int type = skb_shinfo ( skb ) -> gso_type ;if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ;skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ;segs = NULL ;goto out ;}if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ;else {offset = skb_checksum_start_offset ( skb ) ;csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ;offset += skb -> csum_offset ;* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ;skb -> ip_summed = CHECKSUM_NONE ;tnl_hlen = skb_tnl_header_len ( skb ) ;if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;","if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;",4
8,"int64_t time , offset ;if ( version == 1 ) {","int64_t time , offset ;if ( avio_feof ( f ) ) {index -> item_count = 0 ;av_freep ( & index -> items ) ;return AVERROR_INVALIDDATA ;}if ( version == 1 ) {",5
9,"unsigned long tpgt ;int ret ;if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ;if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX )  return ERR_PTR ( - EINVAL ) ;","u16 tpgt ;int ret ;if ( kstrtou16 ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) return ERR_PTR ( - EINVAL ) ;",6
10,"TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ;gf_isom_box_del ( writer -> stco ) ;","TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ;gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ;gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc ) ;gf_isom_box_del ( writer -> stco ) ;",7
11,u32 data ;void * vapic ;vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ;kunmap_atomic ( vapic ) ;,"u32 data ;kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ;",8
12,* dst = * src ;clear_task_ebb ( dst ) ;,__switch_to_tm ( src ) ;tm_recheckpoint_new_task ( src ) ;* dst = * src ;clear_task_ebb ( dst ) ;,9
13,cJSON * c = array -> child ;while ( c && item > 0 ) {-- item ;c = c -> next ;}return c ;,"cJSON * c = array ? array -> child : 0 ;while ( c && item > 0 ) item -- , c = c -> next ;}return c ;",10
14,"ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" ,  ( char * ) * data ) ;","ext3_msg ( sb , KERN_ERR , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , ( char * ) * data ) ;",11
15,"ipv6_select_ident ( fptr ) ;segs = skb_segment ( skb , features ) ;","ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ;segs = skb_segment ( skb , features ) ;",12
16,"void __perf_sw_event ( u32 event_id , u64 nr , int nmi ,  struct pt_regs * regs , u64 addr ) {do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , nmi , & data , regs ) ;perf_swevent_put_recursion_context ( rctx ) ;","void __perf_sw_event ( u32 event_id , u64 nr , struct pt_regs * regs , u64 addr ) {do_perf_sw_event ( PERF_TYPE_SOFTWARE , event_id , nr , & data , regs ) ;perf_swevent_put_recursion_context ( rctx ) ;",13
17,"# ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;# endif struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;return - 1 ;","char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;if ( ! buf ) {return - 1 ;}struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;free ( buf ) ;return - 1 ;",14
18,"if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;else  {return fileblock + start ;}return - 1 ;}}if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;","if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) {free ( buf ) ;return 0 ;}else {free ( buf ) ;return fileblock + start ;}free ( buf ) ;return - 1 ;}free ( buf ) ;}if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;",14
19,"if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;","if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;",14
20,"static void fdct16 ( const int16_t in [ 16 ] , int16_t out [ 16 ] ) {int step1 [ 8 ] ;int step2 [ 8 ] ;int step3 [ 8 ] ;int input [ 8 ] ;int temp1 , temp2 ;input [ 0 ] = in [ 0 ] + in [ 15 ] ;","static void fdct16 ( const tran_low_t in [ 16 ] , int16_t out [ 16 ] ) {tran_high_t step1 [ 8 ] ;int step2 [ 8 ] ;tran_high_t step3 [ 8 ] ;int input [ 8 ] ;tran_high_t temp1 , temp2 ;input [ 0 ] = in [ 0 ] + in [ 15 ] ;",15
21,"int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;int t0 , t1 , t2 , t3 ;int x0 , x1 , x2 , x3 ;s0 = input [ 0 ] + input [ 7 ] ;","tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;tran_high_t t0 , t1 , t2 , t3 ;tran_high_t x0 , x1 , x2 , x3 ;s0 = input [ 0 ] + input [ 7 ] ;",15
22,out [ 0 ] = fdct_round_shift ( t0 ) ;out [ 4 ] = fdct_round_shift ( t2 ) ;out [ 8 ] = fdct_round_shift ( t1 ) ;out [ 12 ] = fdct_round_shift ( t3 ) ;t0 = ( s6 - s5 ) * cospi_16_64 ;,out [ 0 ] = ( tran_low_t ) fdct_round_shift ( t0 ) ;out [ 4 ] = ( tran_low_t ) fdct_round_shift ( t2 ) ;out [ 8 ] = ( tran_low_t ) fdct_round_shift ( t1 ) ;out [ 12 ] = ( tran_low_t ) fdct_round_shift ( t3 ) ;t0 = ( s6 - s5 ) * cospi_16_64 ;,15
23,out [ 2 ] = fdct_round_shift ( t0 ) ;out [ 6 ] = fdct_round_shift ( t2 ) ;out [ 10 ] = fdct_round_shift ( t1 ) ;out [ 14 ] = fdct_round_shift ( t3 ) ;},out [ 2 ] = ( tran_low_t ) fdct_round_shift ( t0 ) ;out [ 6 ] = ( tran_low_t ) fdct_round_shift ( t2 ) ;out [ 10 ] = ( tran_low_t ) fdct_round_shift ( t1 ) ;out [ 14 ] = ( tran_low_t ) fdct_round_shift ( t3 ) ;},15
24,temp2 = step3 [ 2 ] * - cospi_24_64 - step3 [ 5 ] * cospi_8_64 ;step2 [ 1 ] = fdct_round_shift ( temp1 ) ;temp1 = step3 [ 2 ] * - cospi_8_64 + step3 [ 5 ] * cospi_24_64 ;temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ;step1 [ 2 ] = step3 [ 3 ] - step2 [ 2 ] ;step1 [ 3 ] = step3 [ 3 ] + step2 [ 2 ] ;step1 [ 4 ] = step3 [ 4 ] + step2 [ 5 ] ;out [ 1 ] = fdct_round_shift ( temp1 ) ;out [ 9 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ;out [ 5 ] = fdct_round_shift ( temp1 ) ;out [ 13 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ;out [ 3 ] = fdct_round_shift ( temp1 ) ;out [ 11 ] = fdct_round_shift ( temp2 ) ;temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ;out [ 7 ] = fdct_round_shift ( temp1 ) ;out [ 15 ] = fdct_round_shift ( temp2 ) ;},temp2 = step3 [ 2 ] * cospi_24_64 + step3 [ 5 ] * cospi_8_64 ;step2 [ 1 ] = fdct_round_shift ( temp1 ) ;temp1 = step3 [ 2 ] * cospi_8_64 - step3 [ 5 ] * cospi_24_64 ;temp2 = step3 [ 1 ] * cospi_24_64 + step3 [ 6 ] * cospi_8_64 ;step1 [ 2 ] = step3 [ 3 ] + step2 [ 2 ] ;step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ;step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ;step1 [ 5 ] = step3 [ 4 ] + step2 [ 5 ] ;out [ 1 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 9 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 2 ] * cospi_22_64 + step1 [ 5 ] * cospi_10_64 ;out [ 5 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 13 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 3 ] * - cospi_26_64 + step1 [ 4 ] * cospi_6_64 ;out [ 3 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 11 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;temp1 = step1 [ 1 ] * - cospi_18_64 + step1 [ 6 ] * cospi_14_64 ;out [ 7 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;out [ 15 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;},15
25,if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ;,if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) sanitize_dead_code ( env ) ;if ( ret == 0 ) return - EINVAL ;,16
26,if ( ret == 0 )  ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,if ( ret == 0 ) ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,16
27,int i ;wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ;,"int i ;if ( ! config -> sample_rate ) {strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ;return FALSE ;}wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ;",17
28,"SDev = cd -> device ;retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) {result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen ,  ( unsigned char * ) cgc -> sense , & sshdr ,  cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ;","unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ;SDev = cd -> device ;if ( cgc -> sense ) senseptr = sense_buffer ;retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) {result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ;if ( cgc -> sense ) ) ;",18
29,if ( get4 ( ) == 0x48454150 )  {# ifdef LIBRAW_LIBRARY_BUILD  imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ;imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ;,if ( get4 ( ) == 0x48454150 # ifdef LIBRAW_LIBRARY_BUILD && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) {# ifdef LIBRAW_LIBRARY_BUILD imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ;imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ;,19
30,"static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi ,  int partial_frame ) {VP9_COMMON * const cm = & cpi -> common ;struct loopfilter * const lf = & cm -> lf ;const int min_filter_level = 0 ;int best_err ;int filt_best ;int filt_direction = 0 ;int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ;int ss_err [ MAX_LOOP_FILTER + 1 ] ;vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ;int filt_err ;int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;if ( cpi -> twopass . section_intra_rating < 20 )   bias = bias * cpi -> twopass . section_intra_rating / 20 ;if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ;filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;ss_err [ filt_low ] = filt_err ;}else {filt_err = ss_err [ filt_low ] ;if ( ( filt_err - bias ) < best_err ) {if ( filt_err < best_err )  best_err = filt_err ;if ( ss_err [ filt_high ] < 0 ) {filt_err = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ;ss_err [ filt_high ] = filt_err ;}else {filt_err = ss_err [ filt_high ] ;}if ( filt_err < ( best_err - bias ) ) {best_err = filt_err ;filt_best = filt_high ;","static int search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , int partial_frame ) {const VP9_COMMON * const cm = & cpi -> common ;const struct loopfilter * const lf = & cm -> lf ;const int min_filter_level = 0 ;int filt_direction = 0 ;int64_t best_err ;int filt_best ;int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ;int64_t ss_err [ MAX_LOOP_FILTER + 1 ] ;memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ;int64_t bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;if ( ( cpi -> oxcf . pass == 2 ) && ( cpi -> twopass . section_intra_rating < 20 ) ) bias = ( bias * cpi -> twopass . section_intra_rating ) / 20 ;if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ;ss_err [ filt_low ] = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;if ( ( ss_err [ filt_low ] - bias ) < best_err ) {if ( filt_err < best_err ) best_err = filt_err ;if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] ;filt_best = filt_high ;",20
31,lf -> filter_level = filt_best ;},lf -> filter_level = filt_best ;},20
32,"lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;",21
33,"static void encode_mv_component ( vp9_writer * w , int comp ,  const nmv_component * mvcomp , int usehp ) {","static void encode_mv_component ( vpx_writer * w , int comp , const nmv_component * mvcomp , int usehp ) {",22
34,"vp9_write ( w , sign , mvcomp -> sign ) ;vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ;","vpx_write ( w , sign , mvcomp -> sign ) ;vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ;",22
35,"++ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;}if ( usehp )  vp9_write ( w , hp ,  mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ;","+ i )  vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;++ i ) vpx_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ;}if ( usehp ) vpx_write ( w , hp , mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ;",22
36,return alg -> cra_rng . rng_make_random ?  alg -> cra_rng . seedsize : ralg -> seedsize ;,return ralg -> seedsize ;,23
37,if ( sp -> sa_protocol != PX_PROTO_PPTP )  return - EINVAL ;,if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;if ( sp -> sa_protocol != PX_PROTO_PPTP ) return - EINVAL ;,24
38,if ( blockSize == 16 )  request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ;else if ( blockSize == 32 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ;else if ( blockSize == 64 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ;else if ( blockSize == 128 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ;else if ( blockSize == 256 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ;else if ( blockSize == 512 )   request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ;else   request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ;if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) )  request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ;osReleaseMutex ( & request -> context -> mutex ) ;,if ( blockSize == 16 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ;}else if ( blockSize == 32 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ;}else if ( blockSize == 64 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ;}else if ( blockSize == 128 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ;}else if ( blockSize == 256 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ;}else if ( blockSize == 512 ) {request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ;}else {request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ;}if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) {request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ;}osReleaseMutex ( & request -> context -> mutex ) ;,25
39,"char * fmtname ;if ( jas_init ( ) ) {while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_INFILE :  infile = jas_optarg ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {","char * fmtname ;int debug ;if ( jas_init ( ) ) {debug = 0 ;while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_DEBUG : debug = atoi ( jas_optarg ) ;break ;case OPT_INFILE : infile = jas_optarg ;jas_setdbglevel ( debug ) ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {jas_stream_close ( instream ) ;",26
40,"if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\","if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\",26
41,"asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr )  {console_verbose ( ) ;die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ;local_irq_disable ( ) ;panic ( ""bad<S2SV_blank>mode"" ) ;","asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) {siginfo_t info ;void __user * pc = ( void __user * ) instruction_pointer ( regs ) ;console_verbose ( ) ;__show_regs ( regs ) ;info . si_signo = SIGILL ;info . si_errno = 0 ;info . si_code = ILL_ILLOPC ;info . si_addr = pc ;arm64_notify_die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , & info , 0 ) ;",27
42,"ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str ,  ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ;if ( length > 5 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ;}","if ( length < 5 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%04x,<S2SV_blank>"" , EXTRACT_16BITS ( dat ) ) ) ;ND_PRINT ( ( ndo , ""%04x<S2SV_blank>"" , EXTRACT_16BITS ( ptr ) ) ) ;dat += 2 ;length -= 2 ;ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str , ""Direction-#%u"" , EXTRACT_8BITS ( ptr ) ) ) ) ;length -- ;if ( length != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length ) ;}",28
43,"int alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( alt < 0 )  return alt ;return usb_set_interface ( udev ,  intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ;}","struct usb_host_interface * alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( ! alt ) return - ENODEV ;return usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ;}",29
44,"static void udf_pc_to_char ( struct super_block * sb , unsigned char * from ,   int fromlen , unsigned char * to )  {unsigned char * p = to ;while ( elen < fromlen ) {case 2 :  p = to ;* p ++ = \'/\' ;break ;case 3 : memcpy ( p , ""../"" , 3 ) ;break ;case 4 :  memcpy ( p , ""./"" , 2 ) ;p += 2 ;break ;case 5 :  p += udf_get_filename ( sb , pc -> componentIdent , p ,  pc -> lengthComponentIdent ) ;* p ++ = \'/\' ;break ;}","static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) {int comp_len ;unsigned char * p = to ;tolen -- ;while ( elen < fromlen ) {case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ;p = to ;* p ++ = \'/\' ;tolen -- ;break ;case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ;memcpy ( p , ""../"" , 3 ) ;tolen -= 3 ;break ;case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ;memcpy ( p , ""./"" , 2 ) ;p += 2 ;tolen -= 2 ;break ;case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ;p += comp_len ;tolen -= comp_len ;if ( tolen == 0 ) return - ENAMETOOLONG ;* p ++ = \'/\' ;tolen -- ;break ;return 0 ;}",30
45,"if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) {err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;","if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 || class == CLIENT_TYPE_MASTER ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\\\'master\\\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" ;",31
46,"if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;","if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;",31
47,"unsigned long flags ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;","unsigned long flags ;if ( qid > NVMET_NR_QUEUES ) return NULL ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;",32
48,"dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ;usb_set_intfdata ( interface , dev ) ;retval = usb_register_dev ( interface , & tower_class ) ;if ( retval ) {dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\\usb_set_intfdata ( interface , NULL ) ;goto error ;}dev -> minor = interface -> minor ;dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\\","
",33
49,exit :  return retval ;,"usb_set_intfdata ( interface , dev ) ;retval = usb_register_dev ( interface , & tower_class ) ;if ( retval ) {dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\\usb_set_intfdata ( interface , NULL ) ;goto error ;}dev -> minor = interface -> minor ;dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\\exit : return retval ;",33
50,"if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return false ;}Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ;if ( ! defs ) {return false ;}if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) {section_name = & bin -> shstrtab [ shdr -> sh_name ] ;}if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) {link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ;}if ( ! defs ) {bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\\return NULL ;}sdb = sdb_new0 ( ) ;end = ( char * ) defs + shdr -> sh_size ;sdb_set ( sdb , ""section_name"" , section_name , 0 ) ;sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ;++ cnt ) {Sdb * sdb_verdef = sdb_new0 ( ) ;char * vstart = ( ( char * ) defs ) + i ;char key [ 32 ] = {0 };Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;Elf_ ( Verdaux ) aux = {0 };int j = 0 ;int isum = 0 ;r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ;verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ;if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {sdb_free ( sdb_verdef ) ;",+ cnt ) {if ( shdr -> sh_size < 1 || vstart + vdaux < vstart ) {sdb_free ( sdb_verdef ) ;,34
51,"static void construct_get_dest_keyring ( struct key * * _dest_keyring )  {kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {key_get ( dest_keyring ) ;}else {switch ( cred -> jit_keyring ) {case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) {authkey = cred -> request_key_auth ;down_read ( & authkey -> sem ) ;rka = authkey -> payload . data [ 0 ] ;if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ;up_read ( & authkey -> sem ) ;if ( dest_keyring )  break ;}","static int construct_get_dest_keyring ( struct key * * _dest_keyring ) {int ret ;kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {do_perm_check = false ;break ;}}",35
52,}* _dest_keyring = dest_keyring ;return ;},"if ( dest_keyring && do_perm_check ) {ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ;if ( ret ) {key_put ( dest_keyring ) ;return 0 ret ;}}}* _dest_keyring = dest_keyring ;return ;}",35
53,sc = create_spnego_ctx ( ) ;if ( sc == NULL ) return GSS_S_FAILURE ;,sc = create_spnego_ctx ( 1 ) ;if ( sc == NULL ) return GSS_S_FAILURE ;,36
54,"if ( ! sock_flag ( sk , SOCK_ZAPPED ) )  return - EINVAL ;if ( addr_len < sizeof ( struct sockaddr_l2tpip ) )  return - EINVAL ;if ( addr -> l2tp_family != AF_INET )  return - EINVAL ;lock_sock ( sk ) ;if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;","if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ;if ( addr -> l2tp_family != AF_INET ) return - EINVAL ;if ( addr -> l2tp_family != AF_INET ) return - EINVAL ;lock_sock ( sk ) ;if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out ;if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ;",37
55,static unsigned int stack_maxrandom_size ( void )  {unsigned int max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ;},static unsigned long stack_maxrandom_size ( void ) {unsigned long max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1UL ) & STACK_RND_MASK ) << PAGE_SHIFT ;},38
56,"gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;","gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;",39
57,tm = localtime ( & t ) ;str = g_strdup ( asctime ( tm ) ) ;,"tm = localtime ( & t ) ;if ( tm == NULL ) return g_strdup ( ""???"" ) ;str = g_strdup ( asctime ( tm ) ) ;",40
58,"memcpy ( hashed , password , strlen ( password ) ) ;attr = find_attribute ( request , PW_PASSWORD ) ;","memcpy ( hashed , password , length ) ;attr = find_attribute ( request , PW_PASSWORD ) ;",41
59,"static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ ] = {0x51 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;","static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;mutex_unlock ( & d -> data_mutex ) ;adap -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;",42
60,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",43
61,"if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;","fix_google_param ( google_out ) ;fix_google_param ( google_sig ) ;fix_google_param ( google_reqId ) ;fix_google_param ( google_version ) ;fix_google_param ( responseHandler ) ;fix_google_param ( outFileName ) ;if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;",44
62,"static void  horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % stride ) == 0 ) ;if ( cc > stride ) {","static int horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ;return 0 ;}if ( cc > stride ) {",45
63,"
",return 1 ;,45
64,},},45
65,inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;,"uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",46
66,"struct address_space * mapping ;mapping = ( struct address_space * ) page_private ( page ) ;if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) {update_and_free_page ( h , page ) ;h -> surplus_huge_pages -- ;h -> surplus_huge_pages_node [ nid ] -- ;}else {enqueue_huge_page ( h , page ) ;}spin_unlock ( & hugetlb_lock ) ;if ( mapping )  hugetlb_put_quota ( mapping , 1 ) ;","struct hugepage_subpool * spool = ( struct hugepage_subpool * ) page_private ( page ) ;hugepage_subpool_put_pages ( spool , 1 ) ;",47
67,"
",if ( avio_feof ( pb ) ) {return AVERROR_EOF ;},48
68,"if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\","if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\",48
69,if ( ! e || e == p )  goto not_found ;,if ( ! e || e == p ) goto not_found ;if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;,49
70,"void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf )  {get_page ( buf -> page ) ;}","bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {return try_get_page ( buf -> page ) ;}",50
71,"while ( cp < ep && cp < ep2 ) {if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;}if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ;","while ( cp < ep && cp < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ;",51
72,"if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  attr -> ia_mode &= ~ S_ISGID ;","if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) attr -> ia_mode &= ~ S_ISGID ;",52
73,"timeout . tv_usec = 0 ;select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ;return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ;","TEMP_FAILURE_RETRY ( timeout . tv_usec = 0 ;select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ) ;return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ;",53
74,fpm_globals . max_requests = wp -> config -> pm_max_requests ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,fpm_globals . max_requests = wp -> config -> pm_max_requests ;fpm_globals . listening_socket = dup ( wp -> listening_socket ) ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,54
75,"static int detect_transition_to_still ( struct twopass_rc * twopass ,  int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) {int trans_to_still = 0 ;if ( frame_interval > MIN_GF_INTERVAL &&  loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) {const FIRSTPASS_STATS * position = twopass -> stats_in ;FIRSTPASS_STATS tmp_next_frame ;if ( EOF == input_stats ( twopass , & tmp_next_frame ) )  break ;if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 )  break ;reset_fpf_position ( twopass , position ) ;if ( j == still_interval )  trans_to_still = 1 ;return trans_to_still ;}","static int detect_transition_to_still ( VP9_COMP * cpi , int frame_interval , int still_interval , double loop_decay_rate , double last_decay_rate ) {TWO_PASS * const twopass = & cpi -> twopass ;RATE_CONTROL * const rc = & cpi -> rc ;if ( frame_interval > rc -> min_gf_interval && loop_decay_rate >= 0.999 && last_decay_rate < 0.9 ) {if ( EOF == input_stats ( twopass , & tmp_next_frame ) ) break ;if ( stats -> pcnt_inter - stats -> pcnt_motion < 0.999 ) break ;return j == still_interval ) trans_to_still = 1 ;}return 0 ;",55
76,if ( ! handle -> h_transaction ) {err = jbd2_journal_stop ( handle ) ;return handle -> h_err ? handle -> h_err : err ;}sb = handle -> h_transaction -> t_journal -> j_private ;err = handle -> h_err ;,err = handle -> h_err ;if ( ! handle -> h_transaction ) {rc = jbd2_journal_stop ( handle ) ;return err ? err : rc ;}sb = handle -> h_transaction -> t_journal -> j_private ;,56
77,"if ( io -> flag != EXT4_IO_UNWRITTEN ) return ret ;if ( offset + size <= i_size_read ( inode ) )  ret = ext4_convert_unwritten_extents ( inode , offset , size ) ;","ret = ext4_convert_unwritten_extents ( inode , offset , size ) ;",57
78,"
",args -> rmtvaluelen = args -> valuelen ;,58
79,"}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;","}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;",58
80,"request_module ( ""%s"" , name ) ;if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) )  request_module ( ""%s-all"" , name ) ;alg = crypto_alg_lookup ( name , type , mask ) ;","request_module ( ""crypto-%s"" , name ) ;if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) request_module ( ""crypto-%s-all"" , name ) ;alg = crypto_alg_lookup ( name , type , mask ) ;",59
81,"stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;switch ( stlv_type ) {case ISIS_SUBTLV_SPB_INSTANCE :  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\","ND_TCHECK2 ( * tptr , 2 ) ;stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;if ( len < stlv_len ) goto trunc ;ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;switch ( stlv_type ) {case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",60
82,"while ( tmp )  {ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ;ND_PRINT ( ( ndo , ""\\\len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;tmp -- ;case ISIS_SUBTLV_SPBM_SI :  ND_TCHECK2 ( * tptr , 8 ) ;ND_PRINT ( ( ndo , ""\\\","stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;while ( tmp ) {if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;tmp -- ;case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",60
83,}return 0 ;,tptr += stlv_len ;len -= stlv_len ;}return 0 ;,60
84,"return reply_msg ( c , MSG_BAD_FORMAT ) ;type = which_cmd ( c ) ;dprintf ( ""got<S2SV_blank>%s<S2SV_blank>command:<S2SV_blank>\\\\""%s\\\\""\\\switch ( type ) {case OP_PUT : r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;r = read_delay ( & delay , delay_buf , & ttr_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;r = read_ttr ( & ttr , ttr_buf , & size_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;errno = 0 ;body_size = strtoul ( size_buf , & end_buf , 10 ) ;if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ;if ( body_size > job_data_size_limit ) {return reply_msg ( c , MSG_JOB_TOO_BIG ) ;}","return skip ( c , body_size + 2 , MSG_JOB_TOO_BIG ) ;",61
85,"ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;","memset ( & ddi , 0 , sizeof ( ddi ) ) ;ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;",62
86,if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;,if ( ! ( opt_len == 12 && ( flags & TH_SYN ) ) && ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ;,63
87,int procfd = payload -> procfd ;lxc_attach_options_t * options = payload -> options ;,lxc_attach_options_t * options = payload -> options ;,64
88,"uid_t new_uid ;gid_t new_gid ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;","int lsm_labelfd ;uid_t new_uid ;gid_t new_gid ;ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;",64
89,"ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ;ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}new_uid = 0 ;new_gid = 0 ;if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ;if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ;if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ;if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) {if ( setsid ( ) < 0 ) {SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ;if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) {SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}}","ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s."" , strerror ( errno ) ) ;ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>"" ""that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s"" , strerror ( errno ) ) ;",64
90,"ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;","ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;",64
91,"rexit ( - 1 ) ;}INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>""  ""gainable<S2SV_blank>privileges."" ) ;}on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) {rexit ( - 1 ) ;}rexit ( - 1 ) ;}lxc_proc_put_context_info ( init_ctx ) ;if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ;if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ;if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ;if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ;if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ;if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ;for ( fd = 0 ;fd <= 2 ;fd ++ ) {flags = fcntl ( fd , F_GETFL ) ;if ( flags < 0 ) continue ;if ( flags & FD_CLOEXEC ) if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ;}close ( procfd ) ;rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;","shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}INFO ( ""PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>"" ""gainable<S2SV_blank>privileges."" ) ;}status = 3 ;ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ;if ( ret <= 0 ) {ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ;if ( ret <= 0 ) {ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( lsm_labelfd , on_exec , init_ctx -> lsm_label ) < 0 ) {SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label."" ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;close ( lsm_labelfd ) ;rexit ( - 1 ) ;}close ( lsm_labelfd ) ;shutdown ( ipc_socket , SHUT_RDWR ) ;rexit ( - 1 ) ;}rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;",64
92,"line += 3 ;if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) )  goto out_err ;line = ptr + 1 ;if ( ! ( ptr = strchr ( line , '\\\","if ( len < 3 ) goto out_err ;line += 3 ;len -= 3 ;if ( ! ( ptr = memchr ( line , '<S2SV_blank>' , len ) ) ) goto out_err ;if ( len < 1 ) goto out_err ;line = ptr + 1 ;len -= 1 ;if ( ! ( ptr = memchr ( line , '\\\",65
93,switch ( header -> biSize ) {,"switch ( header -> biBitCount == 0 ) {fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\\return OPJ_FALSE ;}if ( header -> biSize ) {",66
94,if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,66
95,"SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\","sas_probe_devices ( port ) ;SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\\",67
96,"
",if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;,68
97,"if ( tga_info . colormap_type != 0 )  {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","if ( tga_info . colormap_type != 0 ) {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",68
98,"ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;",69
99,}line . clock_type = get_status ( port ) -> clocking ;,"}memset ( & line , 0 , sizeof ( line ) ) ;line . clock_type = get_status ( port ) -> clocking ;",70
100,"return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;}","int ret ;ret = scsi_verify_blk_ioctl ( bd , cmd ) ;if ( ret < 0 ) return ret ;return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;}",71
101,"void nego_process_negotiation_request ( rdpNego * nego , wStream * s )  {UINT16 length ;Stream_Read_UINT8 ( s , flags ) ;}","BOOL nego_process_negotiation_request ( rdpNego * nego , wStream * s ) {UINT16 length ;if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE ;Stream_Read_UINT8 ( s , flags ) ;return TRUE ;}",72
102,int req_len ;struct qeth_arp_query_info qinfo = {,unsigned int req_len ;struct qeth_arp_query_info qinfo = {,73
103,"if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  return - EFAULT ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;","if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) return - EFAULT ;if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;",73
104,int m ;m = n ;,"int m ;if ( n < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad"" ) ;}m = n ;",74
105,int xd_size = 0 ;int data_len [ 256 ] ;,int xd_size = 1 ;int data_len [ 256 ] ;,75
106,"xd_size += len ;}ret = ff_alloc_extradata ( st -> codecpar , 64 + xd_size + xd_size / 255 ) ;","xd_size += len + 1 + len / 255 ;}ret = ff_alloc_extradata ( st -> codecpar , xd_size ) ;",75
107,if ( delta > data_len [ j ] ) {return AVERROR_INVALIDDATA ;},av_assert0 ( delta <= xd_size - offset ) ;,75
108,offset += data_len [ j ] ;},av_assert0 ( data_len [ j ] <= xd_size - offset ) ;offset += data_len [ j ] ;},75
109,"av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\\","av_log ( mxf -> fc -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\\",76
110,"av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\\continue ;","av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\\continue ;",76
111,"return mount_entry_on_generic ( mntent , path ) ;}","return mount_entry_on_generic ( mntent , path , rootfs ) ;}",77
112,"-------------------\\\psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;return 1 ;return 0 ;}","if ( psf -> fileoffset < psf -> filelength ) {psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;return 1 ;};return 0 ;}",78
113,"
",ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;,79
114,l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,79
115,return NF_ACCEPT ;},return err == 0 ? NF_ACCEPT : NF_DROP ;},80
116,"if ( ! rta )  return 0 ;p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;if ( ! p ) return - ENOMEM ;pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ;if ( ! pp ) {* replay_esn = p ;* preplay_esn = pp ;","int klen , ulen ;if ( ! rta ) return 0 ;klen = xfrm_replay_state_esn_len ( up ) ;ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ;p = kzalloc ( klen , GFP_KERNEL ) ;if ( ! p ) return - ENOMEM ;pp = kzalloc ( klen , GFP_KERNEL ) ;if ( ! pp ) {memcpy ( p , up , ulen ) ;memcpy ( pp , up , ulen ) ;* replay_esn = p ;* preplay_esn = pp ;",81
117,io -> io_cleanup = mem_cleanup ;switch ( io -> regsize ) {,switch ( io -> regsize ) {,82
118,"
",io -> io_cleanup = mem_cleanup ;,82
119,return 0 ;},return 0 ;},82
120,result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;break ;,result = ( MagickRealType ) ( ( ssize_t ) pixel & ( size_t ) ( value + 0.5 ) ) ;break ;,83
121,result = ( MagickRealType ) ( ( size_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;break ;,result = ( MagickRealType ) ( ( ssize_t ) pixel << ( size_t ) ( value + 0.5 ) ) ;break ;,83
122,result = ( MagickRealType ) ( ( size_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;break ;,result = ( MagickRealType ) ( ( ssize_t ) pixel | ( size_t ) ( value + 0.5 ) ) ;break ;,83
123,result = ( MagickRealType ) ( ( size_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;break ;,result = ( MagickRealType ) ( ( ssize_t ) pixel >> ( size_t ) ( value + 0.5 ) ) ;break ;,83
124,"result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : QuantumRange ) ;break ;}case ThresholdBlackEvaluateOperator : {result = ( MagickRealType ) ( ( ( MagickRealType ) pixel <= value ) ? 0 : pixel ) ;case ThresholdWhiteEvaluateOperator : {result = ( MagickRealType ) ( ( ( MagickRealType ) pixel > value ) ? QuantumRange : pixel ) ;break ;}case UniformNoiseEvaluateOperator : {result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , UniformNoise , value ) ;break ;}case XorEvaluateOperator : {result = ( MagickRealType ) ( ( size_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;break ;}",result = ( MagickRealType ) ( ( ssize_t ) pixel ^ ( size_t ) ( value + 0.5 ) ) ;,83
125,btif_config_flush ( ) ;return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ;,"if ( is_restricted_mode ( ) ) {BTIF_TRACE_WARNING ( ""%s:<S2SV_blank>\\\'%s\\\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted"" , __func__ , bdstr ) ;btif_config_set_int ( bdstr , ""Restricted"" , 1 ) ;}btif_config_flush ( ) ;return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ;",84
126,"if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;","if ( ! ( buf = jas_alloc3 ( bufsize , numcols , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;",85
127,vpx_codec_enc_cfg_map_t * map ;if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ;for ( map = iface -> enc . cfg_maps ;map -> usage >= 0 ;map ++ ) {if ( map -> usage == ( int ) usage ) {,vpx_codec_enc_cfg_map_t * map ;int i ;if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ;for ( i = 0 ;i < iface -> enc . cfg_map_count ;++ i ) {map = iface -> enc . cfg_maps + i ;if ( map -> usage == ( int ) usage ) {,86
128,"netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\\return - EINVAL ;netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\\return - EINVAL ;","netdev_err ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;netdev_err ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;",87
129,"static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  {if ( bitmap_pos < 0 ) {char * name = path_name ( path , last ) ;bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}","static void show_object ( struct object * object , const char * last , void * data ) {if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ;free ( name ) ;}",88
130,"run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ;free ( fname ) ;","run_cmd ( tty_fd , xfr_cmd , fname ) ;free ( fname ) ;",89
131,static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer )  {kfree ( mixer -> id_elems ) ;,static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) {snd_usb_mixer_disconnect ( mixer ) ;kfree ( mixer -> id_elems ) ;,90
132,"struct packet_sock * po = pkt_sk ( sk ) ;struct packet_fanout * f , * match ;","struct packet_rollover * rollover = NULL ;struct packet_sock * po = pkt_sk ( sk ) ;struct packet_fanout * f , * match ;",91
133,"if ( ! po -> running )   return - EINVAL ;if ( po -> fanout )  return - EALREADY ;if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ;if ( ! po -> rollover )  return - ENOMEM ;atomic_long_set ( & po -> rollover -> num , 0 ) ;atomic_long_set ( & po -> rollover -> num_huge , 0 ) ;atomic_long_set ( & po -> rollover -> num_failed , 0 ) ;}mutex_lock ( & fanout_mutex ) ;match = NULL ;list_for_each_entry ( f , & fanout_list , list ) {if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {match = f ;break ;}}if ( match && match -> flags != flags ) goto out ;if ( ! match ) {match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match ) goto out ;write_pnet ( & match -> net , sock_net ( sk ) ) ;match -> id = id ;match -> type = type ;match -> flags = flags ;INIT_LIST_HEAD ( & match -> list ) ;spin_lock_init ( & match -> lock ) ;atomic_set ( & match -> sk_ref , 0 ) ;fanout_init_data ( match ) ;match -> prot_hook . type = po -> prot_hook . type ;match -> prot_hook . dev = po -> prot_hook . dev ;match -> prot_hook . func = packet_rcv_fanout ;match -> prot_hook . af_packet_priv = match ;match -> prot_hook . id_match = match_fanout_group ;dev_add_pack ( & match -> prot_hook ) ;list_add ( & match -> list , & fanout_list ) ;}err = - EINVAL ;if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {err = - ENOSPC ;if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) {__dev_remove_pack ( & po -> prot_hook ) ;po -> fanout = match ;atomic_inc ( & match -> sk_ref ) ;__fanout_link ( sk , po ) ;err = 0 ;}}out :  mutex_unlock ( & fanout_mutex ) ;if ( err ) {kfree ( po -> rollover ) ;po -> rollover = NULL ;","mutex_lock ( & fanout_mutex ) ;if ( ! po -> running ) goto out ;err = - EALREADY ;if ( po -> fanout ) goto out ;if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) {rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ;if ( ! rollover ) goto out ;atomic_long_set ( & po -> rollover -> num , 0 ) ;atomic_long_set ( & rollover -> num_huge , 0 ) ;atomic_long_set ( & rollover -> num_failed , 0 ) ;mutex_lock ( & fanout_mutex ) ;",91
134,"memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;rcu_read_lock ( ) ;","memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;rcu_read_lock ( ) ;",92
135,return NULL ;},kfree ( table ) ;return NULL ;},93
136,"void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) {fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ;","static void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) {fprintf ( stderr , ""%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%"" PRId64 ""<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ;",94
137,buffer -> buffer_length = fbh -> length ;buffer -> buffer = ( char * ) fbh -> data ;if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) {,buffer -> buffer = ( char * ) fbh -> data ;imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ;imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ;buffer -> buffer = ( char * ) fbh -> data ;if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) {,95
138,"enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIR_TXERIF ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteBuffer ( interface , buffer , offset ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_TXRTS ) ;return NO_ERROR ;","enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST ) ;enc28j60ClearBit ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ;enc28j60WriteReg ( interface , ENC28J60_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteReg ( interface , ENC28J60_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ;enc28j60WriteBuffer ( interface , ENC28J60_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ;enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS ) ;return NO_ERROR ;",96
139,"
","value = ast2obj_string ( o -> type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;",97
140,value = ast2obj_int ( o -> lineno ) ;if ( ! value ) goto failed ;,value = ast2obj_int ( o -> lineno ) ;if ( ! value ) goto failed ;,97
141,"if ( page && ( access ( page , R_OK ) == 0 ) )  {file_write ( page , wikitext ) ;http_response_printf ( res , ""success"" ) ;return ;}if ( page && ( unlink ( page ) > 0 ) )  {","if ( page && page_name_is_good ( page ) && ( access ( page , R_OK ) == 0 ) ) {if ( page_name_is_good ( page ) ) {}file_write ( page , wikitext ) ;http_response_printf ( res , ""success"" ) ;return ;}if ( page && page_name_is_good ( page ) && ( unlink ( page ) > 0 ) ) {",98
142,"if ( page == NULL ) page = http_request_get_query_string ( req ) ;if ( page && ( access ( page , R_OK ) == 0 ) )  {","if ( page && page_name_is_good ( page ) == NULL ) page = http_request_get_query_string ( req ) ;if ( page && ( access ( page , R_OK ) == 0 ) ) {",98
143,"if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else  ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;goto out ;if ( flags == EXT4_GET_BLOCKS_CONVERT ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;","if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;goto out ;if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;",99
144,"ND_PRINT ( ( ndo , ""\\\switch ( opt ) {case IPCPOPT_2ADDR : if ( len != 10 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 6 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ;break ;case IPCPOPT_IPCOMP : if ( len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;",ND_TCHECK_16BITS ( p + 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;,100
145,"
","if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) {ret = - ENOENT ;goto out ;}",101
146,"if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;",101
147,"void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh ,  int flag )  {int mb_rows = source -> y_width >> 4 ;int mb_cols = source -> y_height >> 4 ;unsigned char * limits = cm -> pp_limits_buffer ;int mbr , mbc ;( void ) post ;vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;for ( mbr = 0 ;vp8_post_proc_down_and_across_mb_row (  source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride ,  source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;}","void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , int flag , int uvfilter ) {int mbr ;int mb_rows = cm -> mb_rows ;int mb_cols = source -> y_height >> 4 ;unsigned char * limits = cm -> pp_limits_buffer ;( void ) post ;memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ;for ( mbr = 0 ;if ( uvfilter == 1 ) {vp8_post_proc_down_and_across_mb_row ( source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ;}}",102
148,"ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;","struct floppy_raw_cmd cmd = * ptr ;cmd . next = NULL ;cmd . kernel_data = NULL ;ret = copy_to_user ( param , & cmd , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;",103
149,"skip :  if ( ( new -> euid != old -> uid ||  new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {","skip : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ;if ( ( new -> euid != old -> uid || new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {",104
150,"static void  ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh )  {struct mb_cache_entry * ce ;int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;error = 0 ;}else {ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;mb_cache_entry_release ( ce ) ;}","static void ext4_xattr_cache_insert ( struct mb2_cache * ext4_mb_cache , struct buffer_head * bh ) {int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;else ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;",105
151,"return NULL ;}host += 3 ;char * port = strchr ( host , \':\' ) ;if ( ! port ) {port = ( ssl ) ? ""443"" : ""80"" ;}else {* port ++ = 0 ;}char * path = strchr ( host , \'/\' ) ;if ( ! path ) {path = """" ;}else {* path ++ = 0 ;}s = r_socket_new ( ssl ) ;if ( ! s ) {printf ( ""Cannot<S2SV_blank>create<S2SV_blank>socket\\\free ( uri ) ;return NULL ;}if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) {","return socket_http_answer ( s , host , port , 0 ) ) {",106
152,"return r_socket_http_answer ( s , code , rlen ) ;}","return r_socket_http_answer ( s , code , rlen , 0 ) ;}",106
153,"tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z ,  & p -> buff , p -> name ) ;","tf = ( luaY_parser ) ( L , p -> z , & p -> buff , p -> name ) ;",107
154,int err ;sock -> state = SS_UNCONNECTED ;,int err ;if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ;sock -> state = SS_UNCONNECTED ;,108
155,"int ip_options_get_from_user ( struct net * net , struct ip_options * * optp ,  unsigned char __user * data , int optlen ) {struct ip_options * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) {kfree ( opt ) ;","int ip_options_get_from_user ( struct net * net , struct ip_options_rcu * * optp , unsigned char __user * data , int optlen ) {struct ip_options_rcu * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen && copy_from_user ( opt -> opt . __data , data , optlen ) ) {kfree ( opt ) ;",109
156,"dl = kmalloc ( size , GFP_KERNEL ) ;if ( ! dl ) return - ENOMEM ;","dl = kzalloc ( size , GFP_KERNEL ) ;if ( ! dl ) return - ENOMEM ;",110
157,"dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;","dagid_str = ip6addr_string ( ndo , ""%s"" , rpl_tstr ) ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",111
158,"static int   rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent )  {pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) ,  pdu_type , pdu_len ) ) ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU :  case RPKI_RTR_END_OF_DATA_PDU :  msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU :  break ;case RPKI_RTR_CACHE_RESPONSE_PDU :  ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ;tlen = pdu_len ;tptr += sizeof ( * pdu ) ;tlen -= sizeof ( * pdu ) ;if ( encapsulated_pdu_length &&  ( encapsulated_pdu_length <= tlen ) ) {if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) )  goto trunc ;tptr += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = 0 ;if ( tlen > 4 ) {text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;}ND_TCHECK2 ( * tptr , text_length ) ;if ( text_length && ( text_length <= tlen ) ) {ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ;if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ;}break ;default : hexdump = TRUE ;return 0 ;trunc :  return 1 ;}","static u_int rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , const u_int len , const u_char recurse , const u_int indent ) {ND_TCHECK_8BITS ( tptr ) ;if ( * tptr != 0 ) {ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ;return len ;}if ( len < sizeof ( rpki_rtr_pdu ) ) {ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ;goto invalid ;}ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , pdu_type , pdu_len ) ) ;if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;break ;case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;tlen = sizeof ( rpki_rtr_pdu ) ;if ( pdu_len < tlen + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , tlen + 4 ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;tlen += 4 ;if ( encapsulated_pdu_length && ( encapsulated_pdu_length <= tlen ) ) {rpki_rtr_pdu_print ( ndo , tptr + tlen , encapsulated_pdu_length , 0 , indent + 2 ) ;tlen += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = TRUE ;return 0 ;trunc : ND_PRINT ( ( ndo , ""\\\return len ;}",112
159,"int n , len ;skb -> sk = NULL ;memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ;len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ;len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ;if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) {rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ;","int n ;skb -> sk = NULL ;memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ;if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) {rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ;",113
160,addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;addr . sin_port = htons ( port ) ;,addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;addr . sin_port = htons ( port ) ;,114
161,# endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap )  {errmsg = keymap_init ( ) ;,# endif # ifdef FEAT_KEYMAP else if ( varp == & curbuf -> b_p_keymap ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;else errmsg = keymap_init ( ) ;,115
162,if ( ! gui_mch_set_rendering_options ( p_rop ) )  errmsg = e_invarg ;,if ( ! gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ;}# endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;}# endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) {if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ;,115
163,"ret = posix_acl_equiv_mode ( acl , & new_mode ) ;if ( ret < 0 ) goto out ;if ( ret == 0 ) acl = NULL ;","ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ;if ( ret ) goto out ;",116
164,"struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;int ret , i ;","struct o2nm_cluster * cluster ;int ret , i ;",117
165,ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;,o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {o2nm_unlock_subsystem ( ) ;return - EINVAL ;}ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;o2nm_unlock_subsystem ( ) ;,117
166,if ( ret )  return ret ;,if ( ret ) return ret ;,117
167,"case BSD_AFNUM_ISO :  isoclns_print ( ndo , p , length , caplen ) ;break ;","case BSD_AFNUM_ISO : isoclns_print ( ndo , p , length , caplen ) ;break ;",118
168,# endif if ( * src == \'/\' )  separator = * src ++ ;for ( ;,"# endif if ( * src == \'/\' ) {if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ;return ( ARCHIVE_FAILED ) ;}separator = * src ++ ;}for ( ;",119
169,"TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg ,  TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {TPM2B_DIGEST tmpResult ;TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;TPM_RC rval ;int i , j ;","TPM_RC tpm_kdfa ( TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) {TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ;TPM_RC rval = TPM_RC_SUCCESS ;int i , j ;",120
170,"while ( resultKey -> t . size < bytes )  {i_Swizzled = string_bytes_endian_convert_32 ( i ) ;* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ;bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ;rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;if ( rval != TPM_RC_SUCCESS )  {return ( rval ) ;return TSS2_SYS_RC_BAD_VALUE ;}return TPM_RC_SUCCESS ;","const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ;if ( ! md ) {LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ;return TPM_RC_HASH ;}HMAC_CTX ctx ;HMAC_CTX_init ( & ctx ) ;int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;return TPM_RC_MEMORY ;}while ( resultKey -> t . size < bytes ) {TPM2B_DIGEST tmpResult ;i_Swizzled = string_bytes_endian_convert_32 ( i ) ;* ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ;bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ;int c ;for ( c = 0 ;c < j ;c ++ ) {TPM2B_DIGEST * digest = bufferList [ c ] ;int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ;if ( ! rc ) {LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ;rval = TPM_RC_MEMORY ;goto err ;tmpResult . t . size = size ;rval = TSS2_SYS_RC_BAD_VALUE ;goto err ;}err : HMAC_CTX_cleanup ( & ctx ) ;return rval ;",120
171,"cmpt = 0 ;if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) {if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) ||  ! jas_safe_intfast32_add ( tly , height , 0 ) ) {goto error ;}if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) {goto error ;}cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ;cmpt -> tlx_ = tlx ;cmpt -> tly_ = tly ;cmpt -> hstep_ = hstep ;cmpt -> vstep_ = vstep ;cmpt -> width_ = width ;cmpt -> height_ = height ;cmpt -> prec_ = depth ;cmpt -> sgnd_ = sgnd ;cmpt -> stream_ = 0 ;cmpt -> cps_ = ( depth + 7 ) / 8 ;if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) ||  ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) {","JAS_DBGLOG ( 100 , ( ""jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\\cmpt = 0 ;if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) {if ( ! jas_safe_size_mul3 ( cmpt -> width_ , cmpt -> height_ , & size ) || ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) {",121
172,tdata_t _TIFFmalloc ( tsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,tdata_t _TIFFmalloc ( tsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,122
173,if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ;if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,123
174,"
","( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;",124
175,MinVal = 0 ;MaxVal = 0 ;,MinVal = 0 ;MaxVal = 0 ;,124
176,if ( peer )  get_net ( peer ) ;spin_unlock_bh ( & net -> nsid_lock ) ;,if ( peer ) peer = maybe_get_net ( peer ) ;spin_unlock_bh ( & net -> nsid_lock ) ;,125
177,while ( header_buf [ i ] == '\\\\r' || header_buf [ i ] == '\\\,while ( ( i < ( int ) header_buf_used ) && ( header_buf [ i ] == '\\\\r' || header_buf [ i ] == '\\\,126
178,"assert ( proto != LLDP_MGMT_ADDR_NONE ) ;if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ;","if ( proto == LLDP_MGMT_ADDR_NONE ) continue ;if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_MGMT_ADDR ) && POKE_UINT8 ( mgmt -> m_addrsize + 1 ) && POKE_UINT8 ( proto ) && POKE_BYTES ( & mgmt -> m_addr , mgmt -> m_addrsize ) ) ) goto toobig ;",127
179,if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) ||  dp == datalen ) {flags &= ~ FLAG_LAST_MATCHED ;,if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) ) {flags &= ~ FLAG_LAST_MATCHED ;,128
180,"list_add_tail ( & sp -> auto_asconf_list ,  & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;}else   sp -> do_auto_asconf = 0 ;local_bh_enable ( ) ;","spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;list_add_tail ( & sp -> auto_asconf_list , & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;}else {sp -> do_auto_asconf = 0 ;}local_bh_enable ( ) ;",129
181,"static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb )  {s -> avctx -> profile = get_bits ( gb , 4 ) ;s -> avctx -> level = get_bits ( gb , 4 ) ;if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) {s -> avctx -> level = 0 ;}","static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb , int * profile , int * level ) {* profile = get_bits ( gb , 4 ) ;* level = get_bits ( gb , 4 ) ;if ( * profile == 0 && s -> avctx -> level == 8 ) {* level = 0 ;}",130
182,"spin_lock_irqsave ( & mpu -> input_lock , flags ) ;while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) !=  readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) {u16 wTmp , val ;val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ;if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ;wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ;if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ;else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ;spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ;","u16 head , tail , size ;spin_lock_irqsave ( & mpu -> input_lock , flags ) ;head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ;tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ;size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ;if ( head > size || tail > size ) goto out ;while ( head != tail ) {unsigned char val = readw ( pwMIDQData + 2 * head ) ;if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val , 1 ) ;if ( ++ head > size ) head = 0 ;writew ( head , mpu -> dev -> MIDQ + JQS_wHead ) ;out : spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ;",131
183,return result ;},if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;return result ;},132
184,file_sb_list_del ( file ) ;file_free ( file ) ;,file_free ( file ) ;,133
185,passert ( GLOBALS_ARE_RESET ( ) ) ;},},134
186,\\\\\\,\\\\\\,135
187,"if ( s_poll_interval == NULL )  s_poll_interval = ""3000"" ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id ,  session_state , op_iframe_id , s_poll_interval , redirect_uri ,  redirect_uri ) ;","int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ;if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , session_state , op_iframe_id , poll_interval , redirect_uri , redirect_uri ) ;",135
188,"static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req ,  size_t * acl_len )  {__be32 * savep ;uint32_t attrlen , bitmap [ 3 ] = {* acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 )  goto out ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;recvd = req -> rq_rcv_buf . len - hdrlen ;dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr""  ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\* acl_len = attrlen ;}","static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , struct nfs_getaclres * res ) {__be32 * savep , * bm_p ;uint32_t attrlen , bitmap [ 3 ] = {res -> acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) goto out ;bm_p = xdr -> p ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;xdr -> p = bm_p ;res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ;res -> acl_data_offset <<= 2 ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;attrlen += res -> acl_data_offset ;recvd = req -> rq_rcv_buf . len - hdrlen ;if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) {res -> acl_len = attrlen ;goto out ;}dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\res -> acl_len = attrlen ;}",136
189,nexthdr = * prevhdr ;* prevhdr = NEXTHDR_FRAGMENT ;,if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;nexthdr = * prevhdr ;* prevhdr = NEXTHDR_FRAGMENT ;,137
190,while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) {i ++ ;,while ( ( i < to_read ) && ( tmpName [ i ] != 0 ) ) {i ++ ;,138
191,"long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",139
192,"for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ;","for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ;",140
193,"strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ;}","strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 ) ;}",141
194,"owner = stok ( auth , "":"" , & tok ) ;if ( owner && * owner ) {","owner = ssplit ( auth , "":"" , & tok ) ;if ( owner && * owner ) {",142
195,"group = stok ( tok , "":"" , & perms ) ;if ( group && * group ) {","group = ssplit ( tok , "":"" , & perms ) ;if ( group && * group ) {",142
196,"q = ( const uint8_t * ) ( const void * )  ( ( const char * ) ( const void * ) p +  CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {","size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {",143
197,if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;,"struct ip_options_rcu * inet_opt ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;",144
198,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_INET_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",145
199,"tlen = len - sizeof ( struct eigrp_common_header ) ;ND_PRINT ( ( ndo , ""\\\","if ( len < sizeof ( struct eigrp_common_header ) ) {ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ;if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ;break ;}return ;}tlen = len - sizeof ( struct eigrp_common_header ) ;ND_PRINT ( ( ndo , ""\\\",146
200,"tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;if ( bit_length > 32 ) {","tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ;tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ;if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ;break ;}bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ;if ( bit_length > 32 ) {",146
201,bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;if ( bit_length > 32 ) {,"if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ;break ;}bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ;if ( bit_length > 32 ) {",146
202,"ND_PRINT ( ( ndo , ""\\\case EIGRP_TLV_AT_INT :  tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\","if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\case EIGRP_TLV_AT_INT : tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ;if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\",146
203,"# if CONFIG_MEM_MANAGER  int number_aau ;if ( vpx_mm_create_heap_memory ( ) < 0 ) {_P ( printf ( ""[vpx][mm]<S2SV_blank>ERROR<S2SV_blank>vpx_memalign()<S2SV_blank>Couldn\\\'t<S2SV_blank>create<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Heap.\\\) }number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ;# endif  if ( addr ) {",addr = malloc ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ;if ( addr ) {,147
204,"int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ;long long export_index_table [ indexes ] ;res = read_fs_bytes ( fd , sBlk . s . lookup_table_start ,  SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ;","int indexes = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ;int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) sBlk . s . inodes ) ;long long * export_index_table ;if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) {ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\return FALSE ;}export_index_table = alloc_index_table ( indexes ) ;res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , length , export_index_table ) ;",148
205,"ptr = strchr ( ptr + 1 , '/' ) + 1 ;rw_exit ( & sdvp -> sdev_contents ) ;","ptr = strchr ( ptr + 1 , '/' ) ;if ( ptr == NULL ) return ( ENOENT ) ;ptr ++ ;rw_exit ( & sdvp -> sdev_contents ) ;",149
206,"flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;","if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;",150
207,"ret = posix_acl_equiv_mode ( acl , & new_mode ) ;if ( ret < 0 ) goto out ;if ( ret == 0 ) acl = NULL ;","ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ;if ( ret ) goto out ;",151
208,"else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SecRuleEngine:<S2SV_blank>%s"" , p1 ) ;return NULL ;","else return apr_psprintf ( cmd -> pool , ""ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SexHashEngine:<S2SV_blank>%s"" , p1 ) ;return NULL ;",152
209,"
",rcu_read_lock ( ) ;,153
210,"final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",153
211,"uint16 nstrips = 0 , ntiles = 0 , planar = 0 ;uint16 bps = 0 , spp = 0 , res_unit = 0 ;","uint32 nstrips = 0 , ntiles = 0 ;uint16 planar = 0 ;uint16 bps = 0 , spp = 0 , res_unit = 0 ;",154
212,"if ( ! read_buff )  read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;else  {if ( prev_readsize < buffsize )  {new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ;","if ( ! read_buff ) {if ( buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ;return ( - 1 ) ;}read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ;}else {if ( prev_readsize < buffsize ) {if ( buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ;return ( - 1 ) ;}new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ;",154
213,if ( 0 ) {# if CONFIG_VP8_ENCODER },"# if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ;# endif # if CONFIG_VP10_ENCODER }else if ( strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) {ctrl_args = vp10_args ;ctrl_args_map = vp10_arg_ctrl_map ;# endif if ( 0 ) {# if CONFIG_VP8_ENCODER }",155
214,# endif  }for ( argi = argj = argv ;,# endif }for ( argi = argj = argv ;,155
215,"if ( 0 ) {}else if ( arg_match ( & arg , & outputfile , argi ) ) {}","if ( arg_match ( & arg , & outputfile , argi ) ) {# if CONFIG_FP_MB_STATS }else if ( arg_match ( & arg , & fpmbf_name , argi ) ) {config -> fpmb_stats_fn = arg . val ;# endif }else if ( arg_match ( & arg , & use_webm , argi ) ) {# if CONFIG_WEBM_IO config -> write_webm = 1 ;# else die ( ""Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled."" ) ;# endif }else if ( arg_match ( & arg , & use_ivf , argi ) ) {config -> write_webm = 0 ;}else if ( arg_match ( & arg , & fpf_name , argi ) ) {config -> stats_fn = arg . val ;# if CONFIG_VP9_HIGHBITDEPTH }else if ( arg_match ( & arg , & bitdeptharg , argi ) ) {config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ;# endif }else if ( arg_match ( & arg , & resize_width , argi ) ) {config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_height , argi ) ) {config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) {config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ;# endif # if CONFIG_WEBM_IO }",155
216,}config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;},}config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;},155
217,"if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) {warn ( ""non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\\config -> cfg . g_lag_in_frames = 0 ;}}else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) {config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_allowed , argi ) ) {config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) {config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & end_usage , argi ) ) {config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ;}else if ( arg_match ( & arg , & target_bitrate , argi ) ) {config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & min_quantizer , argi ) ) {config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & max_quantizer , argi ) ) {config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & undershoot_pct , argi ) ) {config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & overshoot_pct , argi ) ) {config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_sz , argi ) ) {config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) {config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) {config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & bias_pct , argi ) ) {config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & minsection_pct , argi ) ) {config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & maxsection_pct , argi ) ) {config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ;if ( global -> passes < 2 ) warn ( ""option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\\}else if ( arg_match ( & arg , & kf_min_dist , argi ) ) {config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ;}else if ( arg_match ( & arg , & kf_max_dist , argi ) ) {config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ;config -> have_kf_max_dist = 1 ;}else if ( arg_match ( & arg , & kf_disabled , argi ) ) {config -> cfg . kf_mode = VPX_KF_DISABLED ;}else {int i , match = 0 ;for ( i = 0 ;ctrl_args [ i ] ;i ++ ) {if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) {int j ;match = 1 ;for ( j = 0 ;j < config -> arg_ctrl_cnt ;j ++ )  if ( config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] )  break ;assert ( j < ARG_CTRL_CNT_MAX ) ;if ( j < ARG_CTRL_CNT_MAX ) {config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ;return eos_mark_found ;}","if ( ctrl_args_map != NULL && j < ( int ) ARG_CTRL_CNT_MAX ) {config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ;# if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 || strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) {config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ;# endif }return eos_mark_found ;}",155
218,"if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) {","if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ! use_privsep || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) {",156
219,if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0  || no_port_forwarding_flag || options . disable_forwarding ) {success = 0 ;,if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding ) {success = 0 ;,156
220,dev -> netdev_ops = & l2tp_eth_netdev_ops ;dev -> destructor = free_netdev ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & l2tp_eth_netdev_ops ;dev -> destructor = free_netdev ;,157
221,"
","if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",158
222,for ( ;offset ++ )  {,for ( ;offset ++ ) {,158
223,"if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;","gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . length = 4 ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;",159
224,if ( ext_depth ( inode ) )  goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ;,size_t ext_size = 0 ;if ( ext_depth ( inode ) ) goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ;,160
225,"memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data ,   sizeof ( EXT4_I ( inode ) -> i_data ) ) ;neh = ext_block_hdr ( bh ) ;","ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ;memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , ext_size ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;neh = ext_block_hdr ( bh ) ;",160
226,"if ( verify_checks ( c , preverify_ok , callback_ctx ) ) {SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ;int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated ,  ( void * ) ( - 1 ) ) ;SSL_SESSION_free ( sess ) ;","if ( verify_checks ( c , preverify_ok , callback_ctx ) ) return 1 ;if ( c -> opt -> option . client || c -> opt -> protocol ) return 0 ;if ( c -> opt -> redirect_addr . names ) {SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ;int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated , NULL ) ;SSL_SESSION_free ( sess ) ;",161
227,if ( c -> opt -> option . client || c -> opt -> protocol )  return 0 ;if ( c -> opt -> redirect_addr . names )  return 1 ;,"
",161
228,"int ret ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;","int ret ;if ( current_chrooted ( ) ) return - EPERM ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;",162
229,"if ( is_signed ) {if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ;fixed_length = at91_aes_roundup ( data_length ) ;cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ;if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) )  goto exit ;","if ( ! consttime_memequal ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) goto exit ;",163
230,"c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ;if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) {av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\\return AVERROR_INVALIDDATA ;}if ( c -> nreslevels < s -> reduction_factor )   c -> nreslevels2decode = 1 ;else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ;",c -> nreslevels <= s -> reduction_factor ) c -> nreslevels2decode = 1 ;else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ;,164
231,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",165
232,"bool is_drop_n_account = false ;BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ;if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ;sk = pt -> af_packet_priv ;po = pkt_sk ( sk ) ;if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ;if ( dev -> header_ops ) {",bool is_drop_n_account = false ;bool do_vnet = false ;BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ;if ( do_vnet ) {,166
233,if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;macoff = netoff - maclen ;},if ( po -> has_vnet_hdr ) {netoff += sizeof ( struct virtio_net_hdr ) ;do_vnet = true ;}macoff = netoff - maclen ;},166
234,if ( ( int ) snaplen < 0 )   snaplen = 0 ;},if ( ( int ) snaplen < 0 ) {snaplen = 0 ;do_vnet = false ;}},166
235,}},do_vnet = false ;}},166
236,"if ( po -> has_vnet_hdr ) {if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {","if ( po -> has_vnet_hdr ) {if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {",166
237,"}if ( ! asoc -> assoc_id ) {sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ;}}kfree ( asoc -> peer . peer_random ) ;asoc -> peer . peer_random = new -> peer . peer_random ;new -> peer . peer_random = NULL ;kfree ( asoc -> peer . peer_chunks ) ;asoc -> peer . peer_chunks = new -> peer . peer_chunks ;new -> peer . peer_chunks = NULL ;kfree ( asoc -> peer . peer_hmacs ) ;asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ;new -> peer . peer_hmacs = NULL ;sctp_auth_key_put ( asoc -> asoc_shared_key ) ;sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ;","sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ;",167
238,return true ;},if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ;else return true ;},168
239,"int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) {int labelfd = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 )  goto out ;if ( strcmp ( name , ""none"" ) == 0 )  goto out ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;if ( on_exec ) {labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ;}else {labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ;}if ( labelfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}ret = - 1 ;goto out ;ret = - 1 ;goto out ;}if ( write ( labelfd , command , size + 1 ) < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}else if ( strcmp ( name , ""SELinux"" ) == 0 ) {if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) {ret = - 1 ;ret = - 1 ;goto out ;if ( labelfd != - 1 )   close ( labelfd ) ;return ret ;}","static int lsm_set_label_at ( int lsm_labelfd , int on_exec , char * lsm_label ) {int fret = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 ) return 0 ;if ( strcmp ( name , ""none"" ) == 0 ) return 0 ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;ret = - 1 ;goto out ;goto out ;if ( write ( labelfd , command , size + 1 ) < 0 ) {INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ;ret = - 1 ;goto out ;if ( labelfd != - 1 ) close ( labelfd ) ;return fret ;}",169
240,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},170
241,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,170
242,"static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  {","static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) {",171
243,"if ( perf_event_overflow ( event , nmi , & data , regs ) )  power_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) power_pmu_stop ( event , 0 ) ;",171
244,"# ifdef DISABLE_RC_LONG_TERM_MEM  const uint64_t bits_used = cpi -> rc . this_frame_target ;# else const uint64_t bits_used = cpi -> rc . projected_frame_size ;# endif cpi -> twopass . bits_left -= bits_used ;cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ;if ( cpi -> common . frame_type == KEY_FRAME ) {cpi -> twopass . kf_group_bits += cpi -> rc . this_frame_target - bits_used ;cpi -> twopass . kf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ;}cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ;","TWO_PASS * const twopass = & cpi -> twopass ;RATE_CONTROL * const rc = & cpi -> rc ;const int bits_used = rc -> base_frame_target ;rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ;twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ;if ( rc -> total_actual_bits ) {rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ;rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ;rc -> rate_error_estimate = 0 ;}if ( cpi -> common . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) {twopass -> kf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits -= bits_used ;cpi -> twopass . gf_group_bits = MAX ( twopass -> kf_group_bits , 0 ) ;++ twopass -> gf_group . index ;if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) {const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ;const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ;if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) {-- twopass -> extend_maxq ;if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ;}else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) {-- twopass -> extend_minq ;if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ;}else {if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ;if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ;else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ;}twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ;twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ;if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) {int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ;if ( rc -> projected_frame_size < fast_extra_thresh ) {rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ;rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ;if ( rc -> avg_frame_bandwidth ) {twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ;}twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ;}else if ( rc -> vbr_bits_off_target_fast ) {twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ;}else {twopass -> extend_minq_fast = 0 ;}}}",172
245,num ++ ;curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ;,"num ++ ;if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) ) ;curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ;",173
246,"static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header ,  struct mb_cache_entry * * pce )  {struct mb_cache_entry * ce ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;again :   ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev ,  hash ) ;if ( IS_ERR ( ce ) ) {if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ;break ;}","static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , struct mb2_cache_entry * * pce ) {struct mb2_cache_entry * ce ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ce = mb2_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , hash ) ;",174
247,"ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;}","ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce ) ;}",174
248,"gint64 offset ;int pkt_len ;pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len ,   wth -> frame_buffer , err , err_info ) ;}","gint64 offset ;return parse_cosine_packet ( wth -> fh , & wth -> phdr , pkt_len , wth -> frame_buffer , line , err , err_info ) ;}",175
249,if ( pkt == NULL )  continue ;,"
",176
250,"
",if ( left == 0 && extend ) return 0 ;,177
251,if ( left > 0 && n > left )  n = left ;,if ( left > 0 && n > left ) n = left ;,177
252,"# ifndef _MSC_VER   char buf [ EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;# endif struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;return - 1 ;","char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ] ;# else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ;if ( ! buf ) {return - 1 ;}struct grub_ext4_extent_header * leaf ;grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ;free ( buf ) ;return - 1 ;",178
253,"if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) )  return 0 ;else  {return fileblock + start ;}return - 1 ;}}if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;","if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) {free ( buf ) ;return 0 ;}else {free ( buf ) ;return fileblock + start ;}free ( buf ) ;return - 1 ;}free ( buf ) ;}if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ;",178
254,"if ( ! indir )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz ,  0 , blksz , indir ) )   return grub_errno ;blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;","if ( ! indir ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) {return grub_errno ;}blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ;",178
255,UnpackRaster :  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {,"UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) break ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {",179
256,"else {if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}if ( bpp == 1 ) {if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) {image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ;}}if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) {DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ;}if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) {if ( BitmapHeader2 . RotAngle & 0x8000 ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x2000 ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x0FFF ) {Image * rotate_image ;rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ;if ( rotate_image != ( Image * ) NULL ) {DuplicateBlob ( rotate_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , rotate_image ) ;}}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ;break ;}}break ;case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ;StartWPG . PosSizePrecision = 0 ;while ( ! EOFBlob ( image ) ) {( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ;if ( EOFBlob ( image ) ) break ;Rec2 . Class = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rd_WP_DWORD ( image , & Rec2 . Extension ) ;Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ;if ( EOFBlob ( image ) ) break ;Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ;switch ( Rec2 . RecType ) {case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ;StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ;StartWPG . PosSizePrecision = ReadBlobByte ( image ) ;break ;case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ;WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ;image -> colors = WPG_Palette . NumOfEntries ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = WPG_Palette . StartIndex ;i < ( int ) WPG_Palette . NumOfEntries ;i ++ ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;( void ) ReadBlobByte ( image ) ;}break ;case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ;Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ;if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;Bitmap2Header1 . Depth = ReadBlobByte ( image ) ;Bitmap2Header1 . Compression = ReadBlobByte ( image ) ;if ( Bitmap2Header1 . Compression > 1 ) continue ;switch ( Bitmap2Header1 . Depth ) {case 1 : bpp = 1 ;break ;case 2 : bpp = 2 ;break ;case 3 : bpp = 4 ;break ;case 4 : bpp = 8 ;break ;case 8 : bpp = 24 ;break ;default : continue ;}image -> columns = Bitmap2Header1 . Width ;image -> rows = Bitmap2Header1 . Height ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {size_t one ;one = 1 ;image -> colors = one << bpp ;if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ;}else {if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}switch ( Bitmap2Header1 . Compression ) {case 0 : {ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ;BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;for ( i = 0 ;i < ( ssize_t ) image -> rows ;i ++ ) {( void ) ReadBlob ( image , ldblk , BImgBuff ) ;InsertRow ( image , BImgBuff , i , bpp , exception ) ;}if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;break ;}case 1 : {if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ;break ;}}if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x12 : i = ReadBlobLSBShort ( image ) ;if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ;break ;case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ;( void ) WPG2Flags ;break ;}}break ;default : {ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;}}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;","
",179
257,"if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ;if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ;if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ;size = max ( hdr . size_in , hdr . size_out ) ;if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ;if ( size > SZ_16M ) return - E2BIG ;is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ;if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ;else buf = kmalloc ( size , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) {ret = - EFAULT ;","if ( copy_from_user ( & hdr , ( void * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) ) ) {ret = - EFAULT ;",180
258,"int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;","int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;",181
259,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,181
260,"if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}case RMT_RAW : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ;if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ;image -> columns = sun_info . width ;image -> rows = sun_info . height ;if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;","if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;",182
261,"if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;","if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ;else {if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ;}sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;",182
262,# define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ;,"# define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\\\if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( ( exception ) , ( message ) ) ;colormap = ( unsigned char * ) NULL ;pixel_info = ( MemoryInfo * ) NULL ;\\\\\char magick [ 12 ] ;",183
263,"if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;assert ( exception != ( ExceptionInfo * ) NULL ) ;assert ( exception -> signature == MagickCoreSignature ) ;image = AcquireImage ( image_info , exception ) ;status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;if ( ( count != 2 ) || ( memcmp ( magick , ""\\\\122\\\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;do {image -> page . x = ReadBlobLSBShort ( image ) ;image -> page . y = ReadBlobLSBShort ( image ) ;image -> columns = ReadBlobLSBShort ( image ) ;image -> rows = ReadBlobLSBShort ( image ) ;flags = ( MagickStatusType ) ReadBlobByte ( image ) ;image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ;number_planes = ( size_t ) ReadBlobByte ( image ) ;bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ;number_colormaps = ( size_t ) ReadBlobByte ( image ) ;map_length = ( unsigned char ) ReadBlobByte ( image ) ;if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;one = 1 ;map_length = one << map_length ;","if ( image_info -> debug != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;one = 1 ;map_length = one << map_length ;",183
264,"if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;colormap = ( unsigned char * ) NULL ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps ,  3 * map_length * sizeof ( * colormap ) ) ;if ( colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (  ReadBlobLSBShort ( image ) ) ) ;}","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;colormap = ( unsigned char * ) NULL ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ;if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ) ;}",183
265,"if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;break ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ;if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {ssize_t j ;p = pixels ;for ( i = 0 ;i < ( ssize_t ) number_pixels ;i ++ ) {if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ;j < ( ssize_t ) number_planes ;j ++ ) * p ++ = background_color [ j ] ;else {for ( j = 0 ;j < ( ssize_t ) ( number_planes - 1 ) ;j ++ ) * p ++ = background_color [ j ] ;* p ++ = 0 ;}}}plane = 0 ;x = 0 ;y = 0 ;opcode = ReadBlobByte ( image ) ;do  {switch ( opcode & 0x3f ) {case SkipLinesOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x = 0 ;y += operand ;break ;}case SetColorOp : {operand = ReadBlobByte ( image ) ;plane = ( unsigned char ) operand ;if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ;x = 0 ;break ;}case SkipPixelsOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x += operand ;break ;}case ByteDataOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;operand ++ ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( number_colormaps != 0 ) {colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;",183
266,if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;operand ++ ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {,if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ;operand ++ ;if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,183
267,}if ( number_colormaps != 0 ) {,}if ( number_colormaps != 0 ) {,183
268,"ValidateColormapValue ( image , * p & mask , & index , exception ) ;* p = colormap [ ( ssize_t ) index ] ;","ValidateColormapValue ( image , * p & mask , & index , exception ) ;* p = colormap [ ( ssize_t ) index ] ;",183
269,"ValidateColormapValue ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) ;","ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ;",183
270,"SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;","SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;",183
271,"if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;( void ) ReadBlobByte ( image ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;","if ( number_colormaps != 0 ) colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ;if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( colormap == ( unsigned char * ) magick ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;",183
272,ext2_xattr_put_super ( sb ) ;if ( ! ( sb -> s_flags & MS_RDONLY ) ) {,if ( sbi -> s_mb_cache ) {ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;sbi -> s_mb_cache = NULL ;}if ( ! ( sb -> s_flags & MS_RDONLY ) ) {,184
273,"endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\","if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\\error = - EINVAL ;goto err_free_urb ;}endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\",185
274,"if ( ! cfg . shell )  cfg . shell = guess_shell ( ) ;if ( ! cfg . shell ) {fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\\exit ( 1 ) ;}arg [ 0 ] = cfg . shell ;arg [ 1 ] = ""-c"" ;","arg [ 0 ] = cfg . shell ;arg [ 1 ] = ""-c"" ;",186
275,return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;},if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;else return NULL ;},187
276,"static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags )  {nfs_set_open_stateid_locked ( state , stateid , open_flags ) ;write_sequnlock ( & state -> seqlock ) ;","static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , fmode_t fmode ) {nfs_set_open_stateid_locked ( state , stateid , fmode ) ;write_sequnlock ( & state -> seqlock ) ;",188
277,"
",if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;,189
278,"uint32_t vsize = avio_rb32 ( pb ) ;avio_skip ( pb , 8 ) ;","uint32_t vsize = avio_rb32 ( pb ) ;avio_skip ( pb , 8 ) ;",189
279,"if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\","if ( q < p || q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\",190
280,"# ifdef AUTOKEY  filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;# endif  # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;# endif  step_callback = & ntpd_time_stepped ;","filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;# endif step_callback = & ntpd_time_stepped ;",191
281,"char * dir = ""/etc"" ;if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;","if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;",192
282,"attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;","n -> mounts += n -> pending_mounts ;n -> pending_mounts = 0 ;attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;",193
283,"savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds | prev -> ds ) )  loadsegment ( ds , next -> ds ) ;savesegment ( fs , fsindex ) ;","savesegment ( fs , fsindex ) ;savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds ) ;",194
284,problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;,"
",195
285,"
",if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) {return IHEVCD_INVALID_HEADER ;},196
286,"BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ;ps_pps -> i1_entropy_coding_sync_enabled_flag = value ;","BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ;ps_pps -> i1_entropy_coding_sync_enabled_flag = value ;",196
287,eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) |  ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ;if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ;,eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) | ( 1u << AC_VECTOR ) ;if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ;,197
288,"static char temp [ NFSX_V3FHMAX + 1 ] ;strncpy ( temp , sfsname , NFSX_V3FHMAX ) ;temp [ sizeof ( temp ) - 1 ] = \'\\\\0\' ;spacep = strchr ( temp , \'<S2SV_blank>\' ) ;","char temp [ NFSX_V3FHMAX + 1 ] ;u_int stringlen ;stringlen = len ;if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ;strncpy ( temp , sfsname , stringlen ) ;temp [ sizeof ( temp ) - 1 ] = \'\\\\0\' ;spacep = strchr ( temp , \'<S2SV_blank>\' ) ;",198
289,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen ,  int transhdrlen , int mtu , unsigned int flags )  {","static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) {",199
290,ipv6_select_ident ( & fhdr ) ;skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;,"ipv6_select_ident ( & fhdr , rt ) ;skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;",199
291,if ( res )  return res ;res = register_netdevice ( hsr_dev ) ;,if ( res ) goto err_add_port ;res = register_netdevice ( hsr_dev ) ;,200
292,return res ;},err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;return res ;},200
293,"
",flush_cmd ( ) ;,201
294,( void ) tls_init_new_session ( ) ;},( void ) tls_init_new_session ( ) ;},201
295,"void vp9_setup_dst_planes ( MACROBLOCKD * xd ,  const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) {uint8_t * const buffers [ 4 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride }struct macroblockd_plane * const pd = & xd -> plane [ i ] ;setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ;","void vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) {uint8_t * const buffers [ MAX_MB_PLANE ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride }struct macroblockd_plane * const pd = & planes [ i ] ;setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ;",202
296,len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 ;len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,203
297,"static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst )  {switch ( ctxt -> op_bytes ) {case 2 : ctxt -> _eip = ( u16 ) dst ;break ;case 4 : ctxt -> _eip = ( u32 ) dst ;break ;case 8 : ctxt -> _eip = dst ;break ;default : WARN ( 1 , ""unsupported<S2SV_blank>eip<S2SV_blank>assignment<S2SV_blank>size\\\}","static inline int assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) {return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 ) ;",204
298,"static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {ctx -> invert_tile_order = va_arg ( args , int ) ;","static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , va_list args ) {ctx -> invert_tile_order = va_arg ( args , int ) ;",205
299,"remaining = tvb_captured_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {","remaining = tvb_reported_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {",206
300,"if ( iov_iter_rw ( iter ) == READ )  get_block = ocfs2_get_block ;else  get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;","if ( iov_iter_rw ( iter ) == READ ) get_block = ocfs2_lock_get_block ;else get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;",207
301,msg -> msg_namelen = 0 ;copied = skb -> len ;,copied = skb -> len ;,208
302,"if ( fscanf ( f , ""%79s<S2SV_blank>%[^\\\","if ( fscanf ( f , ""%79s<S2SV_blank>%99[^\\\",209
303,"if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ;perf_read_regs ( regs ) ;nmi = perf_intr_is_nmi ( regs ) ;if ( nmi ) nmi_enter ( ) ;else irq_enter ( ) ;for ( i = 0 ;i < cpuhw -> n_events ;++ i ) {event = cpuhw -> event [ i ] ;if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ;val = read_pmc ( event -> hw . idx ) ;if ( ( int ) val < 0 ) {found = 1 ;record_and_restart ( event , val , regs , nmi ) ;}}if ( ! found ) {for ( i = 0 ;i < ppmu -> n_counter ;++ i ) {if ( is_limited_pmc ( i + 1 ) ) continue ;val = read_pmc ( i + 1 ) ;if ( ( int ) val < 0 )  write_pmc ( i + 1 , 0 ) ;","+ i ) {+ i ) {if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ;",210
304,"else len = get_line_size ( * b , * avail , nl ) ;","else len = get_line_size ( * b + len , * avail - len , nl ) ;",211
305,"len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;","len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;",211
306,"int all_whitespace = 1 ;int kind ;void * data ;mod_ty mod ;char * str ;PyObject * o , * fstring_name ;Py_ssize_t len ;o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ;if ( o == NULL ) return NULL ;len = PyUnicode_GET_LENGTH ( o ) ;kind = PyUnicode_KIND ( o ) ;data = PyUnicode_DATA ( o ) ;for ( i = 0 ;i < len ;i ++ ) {if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) {all_whitespace = 0 ;Py_DECREF ( o ) ;if ( all_whitespace ) {if ( str == NULL )  return NULL ;str [ 0 ] = \'(\' ;fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ;mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ;PyMem_RawFree ( str ) ;if ( ! mod ) return NULL ;","node * mod_n ;mod_ty mod ;char * str ;PyObject * o , * fstring_name ;Py_ssize_t len ;for ( s = expr_start ;s != expr_end ;s ++ ) {char c = * s ;if ( ! ( c == \'<S2SV_blank>\' || c == \'\\\\t\' || c == \'\\\if ( s == expr_end ) {if ( str == NULL ) return NULL ;str [ 0 ] = \'(\' ;mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ;if ( ! mod_n ) {PyMem_RawFree ( str ) ;Ta3Node_Free ( mod_n ) ;return NULL ;}str [ 0 ] = \'{\' ;str [ len + 1 ] = \'}\' ;fstring_fix_node_location ( n , mod_n , str ) ;fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ;mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ;PyMem_RawFree ( str ) ;if ( ! mod ) return NULL ;",212
307,"void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name )  {","static void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) {",213
308,"cJSON * c = object -> child ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ;","cJSON * c = object ? object -> child : 0 ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ;",214
309,"if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;up_write ( & key -> sem ) ;","if ( ret == 0 ) mark_key_instantiated ( key , 0 ) ;up_write ( & key -> sem ) ;",215
310,"if ( ! ( plen <= * len ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;","if ( ! ( plen <= * len && plen > 0 ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;",216
311,"args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;","args . rmtvaluelen = valuelen ;args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;",217
312,"if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ;if ( COMPAT_USE_64BIT_TIME )  return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ;if ( get_compat_timespec ( & ktspec , timeout ) )  return - EFAULT ;if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) )  datagrams = - EFAULT ;","if ( get_compat_timespec ( & ktspec , timeout ) ) return - EFAULT ;if ( compat_get_timespec ( & ktspec , timeout ) ) datagrams = - EFAULT ;",218
313,"image -> columns = sun_info . width ;image -> rows = sun_info . height ;image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ;if ( sun_info . depth < 24 ) {size_t one ;image -> storage_class = PseudoClass ;image -> colors = sun_info . maplength ;}switch ( sun_info . maptype ) {case RMT_NONE :  {if ( sun_info . depth < 24 ) {break ;}unsigned char  * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","image -> colors = sun_info . maplength ;switch ( sun_info . maptype ) {unsigned char * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",219
314,"int ret ;assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;ret = hns_nic_net_xmit_hw ( ndev , skb ,  & tx_ring_data ( priv , skb -> queue_mapping ) ) ;if ( ret == NETDEV_TX_OK ) {netif_trans_update ( ndev ) ;ndev -> stats . tx_bytes += skb -> len ;ndev -> stats . tx_packets ++ ;}return ( netdev_tx_t ) ret ;","assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ;return hns_nic_net_xmit_hw ( ndev , skb , & tx_ring_data ( priv , skb -> queue_mapping ) ) ;",220
315,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,221
316,"if ( settings . num_threads > 64 ) {fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\\}break ;case \'D\' : if ( ! optarg || ! optarg [ 0 ] ) {fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\\return 1 ;}settings . prefix_delimiter = optarg [ 0 ] ;settings . detail_enabled = 1 ;break ;case \'L\' : if ( enable_large_pages ( ) == 0 ) {preallocate = true ;}else {fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\\return 1 ;}break ;case \'C\' : settings . use_cas = false ;break ;case \'b\' : settings . backlog = atoi ( optarg ) ;break ;case \'B\' : protocol_specified = true ;if ( strcmp ( optarg , ""auto"" ) == 0 ) {settings . binding_protocol = negotiating_prot ;}else if ( strcmp ( optarg , ""binary"" ) == 0 ) {settings . binding_protocol = binary_prot ;}else if ( strcmp ( optarg , ""ascii"" ) == 0 ) {settings . binding_protocol = ascii_prot ;}else {fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\\exit ( EX_USAGE ) ;}break ;case \'I\' : buf = strdup ( optarg ) ;unit = buf [ strlen ( buf ) - 1 ] ;if ( unit == \'k\' || unit == \'m\' || unit == \'K\' || unit == \'M\' ) {buf [ strlen ( buf ) - 1 ] = \'\\\\0\' ;size_max = atoi ( buf ) ;if ( unit == \'k\' || unit == \'K\' ) size_max *= 1024 ;if ( unit == \'m\' || unit == \'M\' ) size_max *= 1024 * 1024 ;settings . item_size_max = size_max ;}else {settings . item_size_max = atoi ( buf ) ;}free ( buf ) ;break ;case \'S\' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\\exit ( EX_USAGE ) ;# endif settings . sasl = true ;break ;case \'F\' : settings . flush_enabled = false ;break ;case \'X\' : settings . dump_enabled = false ;break ;case \'o\' : subopts_orig = subopts = strdup ( optarg ) ;while ( * subopts != \'\\\\0\' ) {switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) {case MAXCONNS_FAST : settings . maxconns_fast = true ;break ;case HASHPOWER_INIT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\\return 1 ;}settings . hashpower_init = atoi ( subopts_value ) ;if ( settings . hashpower_init < 12 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\\return 1 ;}else if ( settings . hashpower_init > 32 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\\return 1 ;}break ;case NO_HASHEXPAND : start_assoc_maint = false ;break ;case SLAB_REASSIGN : settings . slab_reassign = true ;break ;case SLAB_AUTOMOVE : if ( subopts_value == NULL ) {settings . slab_automove = 1 ;break ;}settings . slab_automove = atoi ( subopts_value ) ;if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) {fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\\return 1 ;}break ;case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_ratio = atof ( subopts_value ) ;if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) {fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\\return 1 ;}break ;case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_window = atoi ( subopts_value ) ;if ( settings . slab_automove_window < 3 ) {fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\\return 1 ;}break ;case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\\return 1 ;}settings . tail_repair_time = atoi ( subopts_value ) ;if ( settings . tail_repair_time < 10 ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\\return 1 ;}break ;case HASH_ALGORITHM : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\\return 1 ;};if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) {hash_type = JENKINS_HASH ;}else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) {hash_type = MURMUR3_HASH ;}else {fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\\return 1 ;}break ;case LRU_CRAWLER : start_lru_crawler = true ;break ;case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_sleep = atoi ( subopts_value ) ;if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) {fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\\return 1 ;}break ;case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) {fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_tocrawl = tocrawl ;break ;case LRU_MAINTAINER : start_lru_maintainer = true ;settings . lru_segmented = true ;break ;case HOT_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . hot_lru_pct = atoi ( subopts_value ) ;if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case WARM_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . warm_lru_pct = atoi ( subopts_value ) ;if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) {fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case HOT_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\\return 1 ;}settings . hot_max_factor = atof ( subopts_value ) ;if ( settings . hot_max_factor <= 0 ) {fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case WARM_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\\return 1 ;}settings . warm_max_factor = atof ( subopts_value ) ;if ( settings . warm_max_factor <= 0 ) {fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case TEMPORARY_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\\return 1 ;}settings . temp_lru = true ;settings . temporary_ttl = atoi ( subopts_value ) ;break ;case IDLE_TIMEOUT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\\return 1 ;}settings . idle_timeout = atoi ( subopts_value ) ;break ;case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\\return 1 ;}settings . logger_watcher_buf_size *= 1024 ;break ;case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\\return 1 ;}settings . logger_buf_size *= 1024 ;case SLAB_SIZES : slab_sizes_unparsed = subopts_value ;break ;case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\\}if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\\}slab_chunk_size_changed = true ;break ;case TRACK_SIZES : item_stats_sizes_init ( ) ;break ;case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ;break ;case INLINE_ASCII_RESP : settings . inline_ascii_response = true ;break ;case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ;break ;case NO_SLAB_REASSIGN : settings . slab_reassign = false ;break ;case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ;break ;case NO_MAXCONNS_FAST : settings . maxconns_fast = false ;break ;case NO_LRU_CRAWLER : settings . lru_crawler = false ;start_lru_crawler = false ;break ;case NO_LRU_MAINTAINER : start_lru_maintainer = false ;settings . lru_segmented = false ;break ;# ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\\return 1 ;}ext_cf . page_size *= 1024 * 1024 ;break ;case EXT_PAGE_COUNT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\\return 1 ;}break ;case EXT_WBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\\return 1 ;}ext_cf . wbuf_size *= 1024 * 1024 ;settings . ext_wbuf_size = ext_cf . wbuf_size ;break ;case EXT_THREADS : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\\return 1 ;}break ;case EXT_IO_DEPTH : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\\return 1 ;}break ;case EXT_ITEM_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\\return 1 ;}break ;case EXT_ITEM_AGE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\\return 1 ;}break ;case EXT_LOW_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\\return 1 ;}break ;case EXT_RECACHE_RATE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\\return 1 ;}break ;case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\\return 1 ;}break ;case EXT_DROP_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\\return 1 ;}break ;case EXT_MAX_FRAG : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\\return 1 ;}break ;case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\\return 1 ;}break ;case EXT_DROP_UNREAD : settings . ext_drop_unread = true ;break ;case EXT_PATH : storage_file = strdup ( subopts_value ) ;break ;# endif case MODERN : break ;case NO_MODERN : if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size ;}settings . slab_reassign = false ;settings . slab_automove = 0 ;settings . maxconns_fast = false ;settings . inline_ascii_response = true ;settings . lru_segmented = false ;hash_type = JENKINS_HASH ;start_lru_crawler = false ;start_lru_maintainer = false ;break ;case NO_DROP_PRIVILEGES : settings . drop_privileges = false ;break ;# ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ;break ;# endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\\\""%s\\\\""\\\return 1 ;}}free ( subopts_orig ) ;break ;default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\\\""%c\\\\""\\\return 1 ;}}if ( settings . item_size_max < 1024 ) {fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > 1024 * 1024 ) {if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size / 2 ;}}if ( settings . slab_chunk_size_max > settings . item_size_max ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\\exit ( EX_USAGE ) ;}# ifdef EXTSTORE if ( storage_file ) {if ( settings . item_size_max > ext_cf . wbuf_size ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\\exit ( EX_USAGE ) ;}if ( settings . inline_ascii_response ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( settings . udpport ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\\exit ( EX_USAGE ) ;}}# endif if ( slab_sizes_unparsed != NULL ) {if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) {use_slab_sizes = true ;}else {exit ( EX_USAGE ) ;}}if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\\exit ( EX_USAGE ) ;}if ( settings . temp_lru && ! start_lru_maintainer ) {fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( hash_init ( hash_type ) != 0 ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\\exit ( EX_USAGE ) ;}if ( settings . inter != NULL && strchr ( settings . inter , \',\' ) ) {settings . num_threads_per_udp = 1 ;}else {settings . num_threads_per_udp = settings . num_threads ;}if ( settings . sasl ) {if ( ! protocol_specified ) {settings . binding_protocol = binary_prot ;}else {if ( settings . binding_protocol != binary_prot ) {fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\\exit ( EX_USAGE ) ;}}}if ( tcp_specified && settings . port != 0 && ! udp_specified ) {settings . udpport = settings . port ;}else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {",if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {,222
317,"RAnalOp next_op ;avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;","RAnalOp next_op = {0 };avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;",223
318,px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;,if ( ! px -> ft ) {return FALSE ;}px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;,224
319,"int ret = 0 , found = 0 ;char * repo_config = NULL ;","int ret = 0 , found = 0 ;",225
320,"repo_config = perf_pathdup ( ""config"" ) ;if ( ! access ( repo_config , R_OK ) ) {ret += perf_config_from_file ( fn , repo_config , data ) ;found += 1 ;}free ( repo_config ) ;","
",225
321,"static int  validate_event ( struct pmu_hw_events * hw_events ,  struct perf_event * event ) {struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF )  return 1 ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}","static int validate_event ( struct pmu * pmu , struct pmu_hw_events * hw_events , struct perf_event * event ) {struct arm_pmu * armpmu ;struct hw_perf_event fake_event = event -> hw ;if ( event -> pmu != pmu ) return 0 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;armpmu = to_arm_pmu ( event -> pmu ) ;return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ;}",226
322,"static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid ,  struct uid_gid_map * new_map ) {","static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) {",227
323,"if ( ns_capable ( ns -> parent , cap_setid ) )  return true ;","if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ;",227
324,"j ++ )  {body [ j ] = XMALLOC ( VarLenData , 1 ) ;return body ;}","j ++ ) {if ( a -> type == szMAPI_BINARY ) {body [ j ] = XMALLOC ( VarLenData , 1 ) ;}return body ;}",228
325,"u8 reset ;int ret , pos = 0 ;hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! hx ) return - ENOMEM ;reset = 1 ;if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 )  err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;","u8 * buf ;int ret , pos = 0 ;u16 cpu_cs_register = cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;",229
326,"kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( hx ) ;return ret ;","kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register ;buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;hx = ( struct hexline * ) buf ;buf [ 0 ] = 1 ;if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( buf ) ;return ret ;",229
327,"static void  l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat )  {ptr ++ ;val_h = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;","static void l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ptr ++ ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}return ;}val_h = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_l = EXTRACT_16BITS ( ptr ) ;length -= 2 ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;",230
328,"if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0  && strncmp ( ""kadmin"" , c1 -> data , c1 -> length ) == 0 ) {if ( strncmp ( ""history"" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ;else success = 1 ;}","success = data_eq_string ( * realm , handle -> params . realm ) && data_eq_string ( * c1 , ""kadmin"" ) && ! data_eq_string ( * c2 , ""history"" ) ;",231
329,if ( uniforms_offset < shader_rec_offset ||  exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) {,if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) {,232
330,# endif  # if HAVA_LZMA_H && HAVE_LIBLZMA  if ( zip -> zipx_lzma_valid ) {,# endif # if HAVE_LZMA_H && HAVE_LIBLZMA if ( zip -> zipx_lzma_valid ) {,233
331,"struct file * file = vma -> vm_file ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {","struct file * file = vma -> vm_file ) ;down_read ( & EXT4_I ( inode ) -> i_mmap_sem ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {",234
332,out :  sb_end_pagefault ( inode -> i_sb ) ;return ret ;,out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;sb_end_pagefault ( inode -> i_sb ) ;return ret ;,234
333,"ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;",235
334,"r_return_val_if_fail ( arg , NULL ) ;char * a = malloc ( strlen ( arg ) + 1 ) ;if ( ! a ) {return NULL ;}char * b = a ;while ( * arg ) {switch ( * arg ) {case '@' : case '`' : case '|' : case ';' :  case '\\\default :  * b ++ = * arg ;break ;",char ch = * arg ;switch ( ch ) {case '@' : case '`' : case '|' : case ';' : case '=' : case '\\\default : * b ++ = * arg ;break ;,236
335,"if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;","if ( map && nmap ) cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;else cp = ikev1_attr_print ( ndo , cp , ep2 ) ;if ( cp == NULL ) goto trunc ;",237
336,"static gboolean  accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) {IceListenObj listener ;IceConn ice_conn ;IceAcceptStatus status ;GsmClient * client ;GsmXsmpServer * server ;listener = data -> listener ;server = data -> server ;g_debug ( ""GsmXsmpServer:<S2SV_blank>accept_ice_connection()"" ) ;ice_conn = IceAcceptConnection ( listener , & status ) ;if ( status != IceAcceptSuccess ) {g_debug ( ""GsmXsmpServer:<S2SV_blank>IceAcceptConnection<S2SV_blank>returned<S2SV_blank>%d"" , status ) ;return TRUE ;client = gsm_xsmp_client_new ( ice_conn ) ;ice_conn -> context = client ;gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ;g_object_unref ( client ) ;return TRUE ;","typedef struct {guint watch_id ;guint protocol_timeout ;GsmIceConnectionWatch ;static void disconnect_ice_connection ( IceConn ice_conn ) {IceSetShutdownNegotiation ( ice_conn , FALSE ) ;IceCloseConnection ( ice_conn ) ;",238
337,"if ( ( skb_headroom ( skb ) < frag_hdr_sz ) &&  pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;","if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;",239
338,"# ifdef GIT_WIN32  test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ;# endif  }","test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ;test_checkout_fails ( ""refs/heads/git_tilde1"" , ""git~1/foobar"" ) ;}",240
339,"case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ;","case SO_DEBUG : v . val = ! ! sock_flag ( sk , SOCK_DBG ) ;",241
340,"case SO_PASSCRED :  v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ;break ;","case SO_PASSCRED : v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ;break ;",241
341,"case SO_ACCEPTCONN : v . val = sk -> sk_state == TCP_LISTEN ;case SO_PASSSEC :  v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ;break ;","case SO_ACCEPTCONN : v . val = ! ! sk -> sk_state == TCP_LISTEN ;break ;case SO_PASSSEC : v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ;",241
342,if ( sk -> sk_shutdown & RCV_SHUTDOWN ) {msg -> msg_namelen = 0 ;return 0 ;},if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ;,242
343,else  msg -> msg_namelen = 0 ;,"
",242
344,return in ;},return NULL ;},243
345,"uint8_t * const buffers [ 4 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride }","uint8_t * const buffers [ MAX_MB_PLANE ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride }",244
346,"char buf [ DN_BUF_LEN ] ;unsigned int bufsize = sizeof ( buf ) ;X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;md -> subject_dn = strdup ( buf ) ;if ( md -> subject_dn == NULL ) {ret = ENOMEM ;goto cleanup ;}X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize ,  XN_FLAG_SEP_COMMA_PLUS ) ;md -> issuer_dn = strdup ( buf ) ;if ( md -> issuer_dn == NULL ) {ret = ENOMEM ;goto cleanup ;}","X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , & md -> subject_dn = strdup ( buf ) ;if ( md -> subject_dn ) ;if ( ret ) goto cleanup ;ret = rfc2253_name ( X509_get_issuer_name ( cert ) , buf , & bufsize , XN_FLAG_SEP_COMMA_PLUS ) ;md -> issuer_dn ) ;if ( ret ) goto cleanup ;",245
347,if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,if ( ! npages || base_gfn != old . base_gfn ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,246
348,if ( ! npages ) {struct kvm_memory_slot * slot ;,if ( ! npages ) {struct kvm_memory_slot * slot ;,246
349,if ( err > 0 ) {signo = SIGCHLD ;err = 0 ;}if ( ! err ) {,"
",247
350,struct skcipher_ctx * ctx = ask -> private ;unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ;struct skcipher_sg_list * sgl ;struct scatterlist * sg ;unsigned long iovlen ;struct iovec * iov ;int err = - EAGAIN ;int used ;long copied = 0 ;lock_sock ( sk ) ;msg -> msg_namelen = 0 ;,"
",248
351,"register u_int amt ;register u_int i ;int j ;int trunc ;if ( ndo -> ndo_snapend < dat ) return ;amt = ndo -> ndo_snapend - dat ;i = min ( length , amt ) ;if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ;i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ;case RIP6_REQUEST :  j = length / sizeof ( * ni ) ;if ( j == 1  && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6  && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ;else  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE :  j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i >= sizeof ( * ni ) ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( trunc )  ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;}if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;}","unsigned int length_left ;u_int j ;ND_TCHECK ( rp -> rip6_cmd ) ;case RIP6_REQUEST : j = length / sizeof ( * ni ) ;if ( j == 1 && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {}if ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length ) ) ;else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE : j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;length_left >= sizeof ( * ni ) ;length_left -= sizeof ( * ni ) , ++ ni ) {ND_TCHECK ( * ni ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( length_left != 0 ) goto trunc ;}ND_TCHECK ( rp -> rip6_vers ) ;if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;return ;trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;return ;}",249
352,if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,250
353,"vpx_memcpy ( sortlist , cpi -> mb_activity_map ,  sizeof ( unsigned int ) * cpi -> common . MBs ) ;","memcpy ( sortlist , cpi -> mb_activity_map , sizeof ( unsigned int ) * cpi -> common . MBs ) ;",251
354,"retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ;bprm -> argc ++ ;bprm -> interp = iname ;interp_file = open_exec ( iname ) ;","retval = bprm_change_interp ( iname , bprm ) ;interp_file = open_exec ( iname ) ;",252
355,int iSrc ;res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;,int iSrc ;,253
356,for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},253
357,_ipmi_destroy_user ( user ) ;cleanup_srcu_struct ( & user -> release_barrier ) ;,_ipmi_destroy_user ( user ) ;,254
358,"Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",255
359,int sl = strlen ( cursor -> ns ) + 1 ;int limit = 0 ;,size_t sl = strlen ( cursor -> ns ) + 1 ;int limit = 0 ;,256
360,"if ( mobj )   memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ;return mobj ;","if ( mobj ) {size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ;memset ( mobj_get_va ( mobj , 0 ) , 0 , ROUNDUP ( size , granularity ) ) ;}return mobj ;",257
361,timer -> it_overrun += 1 << i ;delta -= incr ;,timer -> it_overrun += 1LL << i ;delta -= incr ;,258
362,"if ( n_fors == - 1 ) return NULL ;comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ;if ( ! comps ) return NULL ;for ( i = 0 ;i < n_fors ;i ++ ) {comprehension_ty comp ;asdl_seq * t ;expr_ty expression , first ;node * for_ch ;int is_async = 0 ;REQ ( n , comp_for ) ;if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) {is_async = 1 ;}if ( is_async && c -> c_feature_version < 6 ) {for_ch = CHILD ( n , 1 + is_async ) ;t = ast_for_exprlist ( c , for_ch , Store ) ;expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ;if ( ! expression ) return NULL ;if ( NCH ( n ) == ( 5 + is_async ) ) {int j , n_ifs ;n = CHILD ( n , 4 + is_async ) ;n_ifs = count_comp_ifs ( c , n ) ;","if ( NCH ( n ) == 2 ) {is_async = 1 ;}if ( is_async && c -> c_feature_version < 6 ) {for_ch = CHILD ( n , 1 + is_async ) ;t = ast_for_exprlist ( c , for_ch , Store ) ;expression = ast_for_expr ( c , CHILD ( n , 3 + is_async ) ) ;if ( ! expression ) return NULL ;if ( NCH ( n ) == ( 5 + is_async ) ) {int j , n_ifs ;n = CHILD ( n , 4 + is_async ) ;n_ifs = count_comp_ifs ( c , n ) ;",259
363,"expression = ast_for_expr ( c , CHILD ( n , 1 ) ) ;","expression = ast_for_expr ( c , CHILD ( sync_n , 3 ) ) ;",259
364,}dst_state -> curframe = src -> curframe ;,}dst_state -> speculative = src -> speculative ;dst_state -> curframe = src -> curframe ;,260
365,"static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 ,   vp9_writer * w ) {const VP9_COMMON * const cm = & cpi -> common ;const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ;const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;write_skip ( cpi , mbmi -> segment_id , mi , w ) ;if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT )  write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ;if ( bsize >= BLOCK_8X8 ) {","static void write_mb_modes_kf ( const VP9_COMMON * cm , const MACROBLOCKD * xd , MODE_INFO * * mi_8x8 , vpx_writer * w ) {const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ;const MODE_INFO * const left_mi = xd -> left_mi ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;write_skip ( cm , xd , mbmi -> segment_id , mi , w ) ;if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT ) write_selected_tx_size ( cm , xd , w ) ;if ( bsize >= BLOCK_8X8 ) {",261
366,saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;,saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,262
367,"SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;int n ;if ( r -> req . aiocb != NULL ) {r -> req . aiocb = NULL ;bdrv_acct_done ( s -> bs , & r -> acct ) ;}if ( ret ) {if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) {return ;}}DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\\n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}","SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> qiov . size ) ;n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}",263
368,"if ( cs > CQSPI_MAX_CHIPSELECT ) {dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\","if ( cs >= CQSPI_MAX_CHIPSELECT ) {dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\\",264
369,"if ( n > maxn ) SWF_error ( ""Action<S2SV_blank>overflow!!"" ) ;# ifdef DEBUG fprintf ( stderr , ""%d:\\\\tACTION[%3.3d]:<S2SV_blank>%s\\\# endif  switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode )  {","# ifdef DEBUG fprintf ( stderr , ""%d:\\\\tACTION[%3.3d]:<S2SV_blank>%s\\\# endif switch ( OpCode ( actions , n , maxn ) ) {",265
370,"memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;","if ( l > ll ) l = ll ;memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;",266
371,}},}}if ( free < 0 ) {err = - ENOMEM ;goto out ;},267
372,if ( len < sizeof ( * prep ) ) {return ( - 1 ) ;}n = EXTRACT_32BITS ( & prep -> pp_n ) ;,if ( len < sizeof ( * prep ) || ! ND_TTEST ( * prep ) ) return ( - 1 ) ;n = EXTRACT_32BITS ( & prep -> pp_n ) ;,268
373,"rq -> skip_clock_update = 0 ;prev -> sched_class -> put_prev_task ( rq , prev ) ;","prev -> sched_class -> put_prev_task ( rq , prev ) ;",269
374,"uint8_t value ;dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\\ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV ,  0 , reg , & value , 1 , 1000 ) ;return ret >= 0 ? value : ret ;}","uint8_t * buffer ;uint8_t value ;buffer = kmalloc ( 1 , GFP_KERNEL ) ;if ( ! buffer ) return - ENOMEM ;dev_dbg ( & usb_dev -> dev , ""atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\\ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , 0 , reg , buffer , 1 , 1000 ) ;return ret >= 0 ) {value = buffer [ 0 ] ;kfree ( buffer ) ;return value ;}else {kfree ( buffer ) ;return ret ;}}",270
375,"static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) {int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ;char * * azModuleArg ;azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ;","static void addModuleArgument ( Parse * pParse , Table * pTable , char * zArg ) {sqlite3_int64 nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ;char * * azModuleArg ;sqlite3 * db = pParse -> db ;if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) {sqlite3ErrorMsg ( pParse , ""too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s"" , pTable -> zName ) ;}azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ;",271
376,"memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;}","s -> append_char ( s , 0 ) ;strncpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;}",272
377,CurrentColorSpace = ColorSpaceOut ;}Error :  cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,Lut = NULL ;CurrentColorSpace = ColorSpaceOut ;}Error : if ( Lut != NULL ) cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,273
378,for ( i = 0 ;i < sec -> size ;ut32 addr32 = r_read_le32 ( buf + i ) ;,for ( i = 0 ;( i + 3 ) < sec -> size ;ut32 addr32 = r_read_le32 ( buf + i ) ;,274
379,for ( i = 0 ;i < sec -> size ;ut64 addr64 = r_read_le64 ( buf + i ) ;,for ( i = 0 ;( i + 7 ) < sec -> size ;ut64 addr64 = r_read_le64 ( buf + i ) ;,274
380,"case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD :  ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" ,  ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ;ND_TCHECK2 ( * tptr , 4 ) ;bw . i = EXTRACT_32BITS ( tptr ) ;","case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ;ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ;ND_TCHECK2 ( * tptr , 4 ) ;bw . i = EXTRACT_32BITS ( tptr ) ;",275
381,if ( anal_size == 40 ) {,if ( ptr_hbe_txposer -> anal_size == 40 ) {,276
382,"if ( ixheaacd_cmplx_anal_fft != NULL )   ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ;else return - 1 ;","if ( ixheaacd_cmplx_anal_fft != NULL ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) ( u_in , u_out , anal_size * 2 ) ;else return - 1 ;",276
383,"while ( p < q ) p += enclen ( reg -> enc , p ) ;}","if ( q >= end ) return 0 ;while ( p < q ) p += enclen ( reg -> enc , p ) ;}",277
384,"static void bfq_idle_slice_timer_body ( struct bfq_queue * bfqq )  {struct bfq_data * bfqd = bfqq -> bfqd ;enum bfqq_expiration reason ;spin_lock_irqsave ( & bfqd -> lock , flags ) ;bfq_clear_bfqq_wait_request ( bfqq ) ;}if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ;","static void bfq_idle_slice_timer_body ( struct bfq_data * bfqd , struct bfq_queue * bfqq ) {enum bfqq_expiration reason ;spin_lock_irqsave ( & bfqd -> lock , flags ) ;}bfq_clear_bfqq_wait_request ( bfqq ) ;if ( bfq_bfqq_budget_timeout ( bfqq ) ) reason = BFQQE_BUDGET_TIMEOUT ;",278
385,"if ( key_is_instantiated ( key ) &&  ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ;","if ( key_is_positive ( key ) && ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ;",279
386,"RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;if ( ! work_to_do ) {","if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) {netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\\netbk_fatal_tx_err ( vif ) ;continue ;}RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;if ( ! work_to_do ) {",280
387,"if ( unlikely ( work_to_do < 0 ) ) {netbk_tx_err ( vif , & txreq , idx ) ;continue ;}if ( unlikely ( ret < 0 ) ) {netbk_tx_err ( vif , & txreq , idx - ret ) ;continue ;}",if ( unlikely ( work_to_do < 0 ) ) continue ;if ( unlikely ( ret < 0 ) ) continue ;,280
388,"netdev_dbg ( vif -> dev ,  ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\\netbk_tx_err ( vif , & txreq , idx ) ;continue ;","netdev_err ( vif -> dev , ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\\netbk_fatal_tx_err ( vif ) ;continue ;",280
389,"netbk_tx_err ( vif , & txreq , idx ) ;continue ;",continue ;,280
390,"
",flush_cmd ( ) ;,281
391,( void ) tls_init_new_session ( ) ;},( void ) tls_init_new_session ( ) ;},281
392,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;struct net * net = sock_net ( cb -> skb -> sk ) ;,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ;struct net * net = sock_net ( cb -> skb -> sk ) ;,282
393,return ;update_idle_timeout ( conn ) ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {,if ( return ;update_idle_timeout ( conn ) != 0 ) return ;parse_input ( conn ) ;if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) {,283
394,"struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ;struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ;struct xen_netif_tx_request * txp ;if ( unlikely ( err ) ) {pending_ring_idx_t index ;index = pending_index ( netbk -> pending_prod ++ ) ;txp = & pending_tx_info [ pending_idx ] . req ;make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;netbk -> pending_ring [ index ] = pending_idx ;xenvif_put ( vif ) ;pending_ring_idx_t index ;pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ;if ( unlikely ( err ) )  xen_netbk_idx_release ( netbk , pending_idx ) ;continue ;txp = & netbk -> pending_tx_info [ pending_idx ] . req ;make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;index = pending_index ( netbk -> pending_prod ++ ) ;netbk -> pending_ring [ index ] = pending_idx ;xen_netbk_idx_release ( netbk , pending_idx ) ;for ( j = start ;xen_netbk_idx_release ( netbk , pending_idx ) ;}","if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ;netbk -> pending_ring [ index ] = pending_idx ;xenvif_put ( vif ) ;pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ;if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ;continue ;xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY , XEN_NETIF_RSP_ERROR ) ;index = pending_index ( netbk -> pending_prod ++ ) ;netbk -> pending_ring [ index ] = pending_idx ;xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ;for ( j = start ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",284
395,assert ( image_info != ( const ImageInfo * ) NULL ) ;,assert ( image_info != ( const ImageInfo * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,285
396,"if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;","}if ( chroma_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;",285
397,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,285
398,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,285
399,"if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( y = 0 ;","if ( resize_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}for ( y = 0 ;",285
400,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,285
401,"if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;","if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;if ( addr . nl_pid ) {syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ;continue ;}incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ;incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ;",286
402,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;",287
403,"if ( client -> ipc == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;","if ( client -> ipc == NULL && client -> session == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;",288
404,"if ( PyTuple_GET_SIZE ( tuple ) != 3 ) {PyMem_Free ( newData ) ;PyErr_SetString ( PyExc_TypeError , ""expecting<S2SV_blank>tuple<S2SV_blank>of<S2SV_blank>size<S2SV_blank>3"" ) ;return NULL ;}x = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 0 ) ) ;y = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 1 ) ) ;z = PyLong_AsLong ( PyTuple_GET_ITEM ( tuple , 2 ) ) ;if ( newpos + x > newDataLength ||  diffPtr + x > diffBlock + diffBlockLength ||  extraPtr + y > extraBlock + extraBlockLength ) {memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;","memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;for ( j = 0 ;j < x ;j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ;newpos += x ;oldpos += x ;if ( newpos + y > newDataLength || extraPtr + y > extraBlock + extraBlockLength ) {memcpy ( newData + newpos , diffPtr , x ) ;diffPtr += x ;",289
405,"flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;","flen = udf_get_filename ( dir -> i_sb , nameptr , lfi , fname , UDF_NAME_LEN ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;",290
406,"__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;","memset ( & t , 0 , sizeof ( t ) ) ;__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;",291
407,"if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , req , IPPROTO_TCP ) ) == NULL ) goto done ;err = ip6_xmit ( sk , skb , fl6 , np -> opt , np -> tclass ) ;err = net_xmit_eval ( err ) ;","if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , rcu_dereference ( req , IPPROTO_TCP ) ) == NULL ) goto done ;err = ip6_xmit ( sk , skb , fl6 , np -> opt ) , np -> tclass ) ;err = net_xmit_eval ( err ) ;",292
408,ssize_t result ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,ssize_t result ;if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,293
409,"char * fpath = NULL , * path1 , * cgdir = NULL , * controller ;const char * cgroup ;if ( ! fc ) return - EIO ;controller = pick_controller_from_path ( fc , path ) ;if ( ! controller ) return - EINVAL ;cgroup = find_cgroup_in_path ( path ) ;if ( ! cgroup ) return - EINVAL ;get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ;if ( ! fpath ) path1 = ""/"" ;else path1 = cgdir ;if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {ret = - EACCES ;goto out ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {ret = - EACCES ;return ret ;}","char * fpath = NULL , * path1 , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next ) ) {ret = - EACCES ;goto out ;}if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) {ret = - EACCES ;goto out ;if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) {ret = - EACCES ;free ( next ) ;return ret ;}",294
410,disk -> queue = NULL ;continue ;,put_disk ( disk ) ;disk -> queue = NULL ;continue ;,295
411,"void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  {","static void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) {",296
412,"if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ;( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ;( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ;( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ;( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ;( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ;count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ;viff_info . comment [ 511 ] = \'\\\\0\' ;if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment , exception ) ;if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ;else image -> endian = MSBEndian ;viff_info . rows = ReadBlobLong ( image ) ;viff_info . columns = ReadBlobLong ( image ) ;viff_info . subrows = ReadBlobLong ( image ) ;viff_info . x_offset = ReadBlobSignedLong ( image ) ;viff_info . y_offset = ReadBlobSignedLong ( image ) ;viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . location_type = ReadBlobLong ( image ) ;viff_info . location_dimension = ReadBlobLong ( image ) ;viff_info . number_of_images = ReadBlobLong ( image ) ;viff_info . number_data_bands = ReadBlobLong ( image ) ;viff_info . data_storage_type = ReadBlobLong ( image ) ;viff_info . data_encode_scheme = ReadBlobLong ( image ) ;viff_info . map_scheme = ReadBlobLong ( image ) ;viff_info . map_storage_type = ReadBlobLong ( image ) ;viff_info . map_rows = ReadBlobLong ( image ) ;viff_info . map_columns = ReadBlobLong ( image ) ;viff_info . map_subrows = ReadBlobLong ( image ) ;viff_info . map_enable = ReadBlobLong ( image ) ;viff_info . maps_per_cycle = ReadBlobLong ( image ) ;viff_info . color_space_model = ReadBlobLong ( image ) ;for ( i = 0 ;i < 420 ;i ++ ) ( void ) ReadBlobByte ( image ) ;if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ;number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ;if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ;if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ;if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ;if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ;if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ;if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ;if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ;switch ( ( int ) viff_info . map_scheme ) {case VFF_MS_NONE : {if ( viff_info . number_data_bands < 3 ) {if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;status = AcquireImageColormap ( image , image -> colors , exception ) ;if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",297
413,"int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( pos != last_pos ) {","int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( avio_feof ( s -> pb ) ) {ret = AVERROR_INVALIDDATA ;goto end ;}if ( pos != last_pos ) {",298
414,"rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE ,  GFP_KERNEL ) ;","rinfo = kzalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , GFP_KERNEL ) ;",299
415,"# endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ;","# endif install_keyword ( ""umask"" , & umask_handler ) ;install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ;",300
416,# endif  },# endif },300
417,return encoder_common_init ( ctx ) ;},"vpx_codec_err_t res = VPX_CODEC_OK ;( void ) data ;if ( ctx -> priv == NULL ) {vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ;if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ;ctx -> priv = ( vpx_codec_priv_t * ) priv ;ctx -> priv -> init_flags = ctx -> init_flags ;ctx -> priv -> enc . total_encoders = 1 ;priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ;if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ;# if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) {return VPX_CODEC_MEM_ERROR ;}# endif if ( ctx -> config . enc ) {priv -> cfg = * ctx -> config . enc ;ctx -> config . enc = & priv -> cfg ;}priv -> extra_cfg = default_extra_cfg ;once ( vp9_initialize_enc ) ;res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ;if ( res == VPX_CODEC_OK ) {set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ;# if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ;# endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ;if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ;else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ;}}return res ;}",301
418,char * tmpptr = key + strlen ( key ) ;* tmpptr = \'=\' ;,char * tmpptr = key + strlen ( key ) ;* tmpptr = \'=\' ;,302
419,"else if ( errno == ENOENT )  touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;}","else if ( errno == ENOENT ) touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID ) ;}",303
420,"if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {goto error ;box -> ops = & jp2_boxinfo_unk . ops ;JAS_DBGLOG ( 10 , (  ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\if ( box -> len == 1 ) {if ( jp2_getuint64 ( in , & extlen ) ) {","if ( ! ( box = jp2_box_create0 ( ) ) ) {goto error ;JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\\if ( box -> len == 1 ) {JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\\if ( jp2_getuint64 ( in , & extlen ) ) {",304
421,"static int  _Unpickler_ResizeMemoList ( UnpicklerObject * self , Py_ssize_t new_size )  {Py_ssize_t i ;assert ( new_size > self -> memo_size ) ;","static int _Unpickler_ResizeMemoList ( UnpicklerObject * self , size_t new_size ) {Py_ssize_t i ;assert ( new_size > self -> memo_size ) ;",305
422,int copylen ;bool zerocopy = false ;,int copylen = 0 ;bool zerocopy = false ;err = - EMSGSIZE ;if ( unlikely ( count > UIO_MAXIOV ) ) goto err ;,306
423,"if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) )  zerocopy = true ;copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;","if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) zerocopy = true ;if ( count > MAX_SKB_FRAGS ) {copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ;if ( copylen < vnet_hdr_len ) copylen = 0 ;else copylen -= vnet_hdr_len ;}if ( copylen < vnet_hdr . hdr_len ) copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;",306
424,u16 offset = sizeof ( struct ipv6hdr ) ;struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ;while ( offset + 1 <= packet_len ) {switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,u16 offset = sizeof ( struct ipv6hdr ) ;while ( offset <= packet_len ) {struct ipv6_opt_hdr * exthdr ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,307
425,offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) +  offset ) ;return offset ;,if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ;offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;return - EINVAL ;,307
426,"static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) {if ( delta_q != 0 ) {vp9_wb_write_bit ( wb , 1 ) ;vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ;vp9_wb_write_bit ( wb , delta_q < 0 ) ;}vp9_wb_write_bit ( wb , 0 ) ;}","static void write_delta_q ( struct vpx_write_bit_buffer * wb , int delta_q ) {if ( delta_q != 0 ) {vpx_wb_write_bit ( wb , 1 ) ;vpx_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ;vpx_wb_write_bit ( wb , delta_q < 0 ) ;}vpx_wb_write_bit ( wb , 0 ) ;}",308
427,mv . as_mv . col = mvy [ vcnt / 2 ] ;find = 1 ;* sr = 0 ;,* sr = 0 ;,309
428,"put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;}","aux . tp_padding = 0 ;put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;}",310
429,"}if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) ||  ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) {dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\\return ;","
",311
430,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_ARP_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",312
431,"int bson_check_field_name ( bson * b , const char * string ,  const int length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ;","int bson_check_field_name ( bson * b , const char * string , const size_t length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ;",313
432,sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;int all_param_pass = 1 ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ;bool all_param_pass = true ;union sctp_params param ;sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,314
433,"while ( chunk_len > 0 ) {err_code = sctp_process_asconf_param ( asoc , asconf ,  asconf_param ) ;if ( SCTP_ERROR_NO_ERROR != err_code )  all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack ,  asconf_param -> crr_id , err_code ,  asconf_param ) ;length = ntohs ( asconf_param -> param_hdr . length ) ;asconf_param = ( void * ) asconf_param + length ;chunk_len -= length ;","sctp_walk_params ( param , addip , addip_hdr . params ) {if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ;err_code = sctp_process_asconf_param ( asoc , asconf , param . addip ) ;if ( err_code != SCTP_ERROR_NO_ERROR ) all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , param . addip -> crr_id , err_code , asconf_param ) ;",314
434,"JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\\result = realloc ( ptr , size ) ;","JAS_DBGLOG ( 101 , ( ""jas_realloc(%x,<S2SV_blank>%zu)\\\result = realloc ( ptr , size ) ;",315
435,"m -> msg_namelen = 0 ;timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;","timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;",316
436,# endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) &&  is_kvmppc_hv_enabled ( kvm ) ;break ;,# endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && hv_enabled ;break ;,317
437,"pci_populate_msicap ( & msicap , msgnum , 0 ) ;return pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ;","return pci_populate_msicap ( & msicap , msgnum , 0 ) || pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ;",318
438,"keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) ,   ( wchar_t * ) kvp_data -> data . key ) ;kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;valuelen = utf8s_to_utf16s ( value , strlen ( value ) ,   ( wchar_t * ) kvp_data -> data . value ) ;kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ;","keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 ) ;kvp_data -> data . key_size = 2 * ( keylen + 1 ) ;valuelen = utf8s_to_utf16s ( value , strlen ( value ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2 ) ;kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ;",319
439,ctx = d -> log_ctx ;d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ;,d -> log_file = eventfp ;ctx = d -> log_ctx ;d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ;,320
440,"if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) {sycc420_to_rgb ( img ) ;else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) {sycc422_to_rgb ( img ) ;}else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) {sycc444_to_rgb ( img ) ;}else {fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\\return ;}img -> color_space = OPJ_CLRSPC_SRGB ;}","
",321
441,void * parg = NULL ;long err = - EINVAL ;int is_ext_ctrl ;size_t ctrls_size = 0 ;void __user * user_ptr = NULL ;is_ext_ctrl = ( cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS || cmd == VIDIOC_TRY_EXT_CTRLS ) ;switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE :  parg = NULL ;case _IOC_READ :  case _IOC_WRITE :  case ( _IOC_WRITE | _IOC_READ ) :  if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;,"void * parg = ( void * ) arg ;long err = - EINVAL ;if ( has_array_args ) {* kernel_ptr = user_ptr ;if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ;goto out_array_args ;}if ( err < 0 ) goto out ;out_array_args : switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE : parg = NULL ;case _IOC_READ : case _IOC_WRITE : case ( _IOC_WRITE | _IOC_READ ) : if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;",322
442,"if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) {addReplyError ( c , ""operation<S2SV_blank>not<S2SV_blank>permitted"" ) ;return REDIS_OK ;}if ( server . maxmemory ) freeMemoryIfNeeded ( ) ;if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) {addReplyError ( c , ""command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>when<S2SV_blank>used<S2SV_blank>memory<S2SV_blank>><S2SV_blank>\\\'maxmemory\\\'"" ) ;return REDIS_OK ;}if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) {addReplyError ( c , ""only<S2SV_blank>(P)SUBSCRIBE<S2SV_blank>/<S2SV_blank>(P)UNSUBSCRIBE<S2SV_blank>/<S2SV_blank>QUIT<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>this<S2SV_blank>context"" ) ;return REDIS_OK ;}if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) {addReplyError ( c , ""link<S2SV_blank>with<S2SV_blank>MASTER<S2SV_blank>is<S2SV_blank>down<S2SV_blank>and<S2SV_blank>slave-serve-stale-data<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>no"" ) ;return REDIS_OK ;}if ( server . loading && cmd -> proc != infoCommand ) {addReply ( c , shared . loadingerr ) ;return REDIS_OK ;}if ( c -> flags & REDIS_MULTI && cmd -> proc != execCommand && cmd -> proc != discardCommand && cmd -> proc != multiCommand && cmd -> proc != watchCommand ) {queueMultiCommand ( c , cmd ) ;addReply ( c , shared . queued ) ;}else {if ( server . vm_enabled && server . vm_max_threads > 0 &&  blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;","if ( server . ds_enabled && blockClientOnSwappedKeys ( c , cmd ) ) return REDIS_ERR ;",323
443,"static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data )  {return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) ,  RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE ,  indx , 0 , data , size , 500 ) ;}","static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , const void * data ) {void * buf ;int ret ;buf = kmemdup ( data , size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE , indx , 0 , buf , size , 500 ) ;kfree ( buf ) ;return ret ;}",324
444,"endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\","if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & usbinterface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\\error = - EINVAL ;goto err_free_urb ;}endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;dev_dbg ( & usbinterface -> dev , ""gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\\",325
445,"case RESPONSE_RUN :  {nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ;g_free ( uri ) ;}break ;case RESPONSE_MARK_TRUSTED : {file = nautilus_file_get_location ( parameters -> file ) ;nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;","case GTK_RESPONSE_OK : {file = nautilus_file_get_location ( parameters -> file ) ;nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ;nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;nautilus_file_invalidate_all_attributes ( parameters -> file ) ;",326
446,if ( status ) {if ( edge_port -> lsr_event ) {edge_port -> lsr_event = 0 ;,if ( urb -> actual_length > 0 && status ) {if ( edge_port -> lsr_event ) {edge_port -> lsr_event = 0 ;,327
447,"static struct cifsSesInfo *  cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username )  {struct list_head * tmp ;list_for_each ( tmp , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) )   continue ;++ ses -> ses_count ;","static struct cifsSesInfo * cifs_find_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * vol ) {+ ses -> ses_count ;list_for_each_entry ( ses , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , vol -> username , MAX_USERNAME_SIZE ) ) continue ;if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ;}++ ses -> ses_count ;",328
448,"if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) )   && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) )   ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;","if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) {if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values"" ) ;}if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;",329
449,"if ( input [ 0 ] == \'<S2SV_blank>\' )  input ++ ;ptr = strchr ( input , \'<S2SV_blank>\' ) ;","if ( input [ 0 ] == \'<S2SV_blank>\' ) {input ++ ;}ptr = strchr ( input , \'<S2SV_blank>\' ) ;",330
450,"if ( ! r_fs_mount ( core -> fs , ptr , input , off ) )  eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) )  eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\\else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) )   eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\free ( ptr ) ;","if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) {eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}}if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) {eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\\}else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) {eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}free ( ptr ) ;",330
451,"if ( vm_flags & VM_NORESERVE )  return 0 ;if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ;else {struct resv_map * resv_map = resv_map_alloc ( ) ;if ( ! resv_map ) return - ENOMEM ;chg = to - from ;set_vma_resv_map ( vma , resv_map ) ;set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ;}if ( chg < 0 ) return chg ;if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;","struct hugepage_subpool * spool = subpool_inode ( inode ) ;if ( hugepage_subpool_get_pages ( spool , chg ) ) return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;",331
452,"struct key * keyring ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;","struct key * keyring ;if ( new -> thread_keyring ) return 0 ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;",332
453,static size_t scanned ;static size_t readnbd ;,"
",333
454,"fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;fptr_orig = io_get_open_fptr ( mrb , orig ) ;","fptr_orig = io_get_open_fptr ( mrb , orig ) ;fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;",334
455,". index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = user_match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",". index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",335
456,"cpi -> zbin_mode_boost = 0 ;vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;}","vp9_init_plane_quantizers ( cpi , & cpi -> td . mb ) ;}",336
457,"utee_param_to_param ( param , callee_params ) ;}","res = utee_param_to_param ( utc , param , callee_params ) ;if ( res != TEE_SUCCESS ) return res ;}",337
458,"old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ;old_eip = ctxt -> _eip ;if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) )  return X86EMUL_CONTINUE ;ctxt -> _eip = 0 ;memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;return em_push ( ctxt ) ;","struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;old_eip = ctxt -> _eip ;ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ;rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ;if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ;rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;if ( rc != X86EMUL_CONTINUE ) goto fail ;rc = em_push ( ctxt ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;return rc ;fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ;return rc ;",338
459,"reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;","reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;",339
460,"band -> prec = av_malloc_array ( reslevel -> num_precincts_x *  ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;","band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;",339
461,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",340
462,"amount = n_got * sizeof ( ut32 ) ;if ( amount < n_got || amount > UT32_MAX ) {goto out_error ;}struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ;if ( got_table ) {",amount = n_got * sizeof ( struct reloc_struct_t ) ) ;if ( got_table ) {,341
463,if ( info -> si_code >= 0 )   return - EPERM ;info -> si_signo = sig ;,if ( info -> si_code != SI_QUEUE ) {WARN_ON_ONCE ( info -> si_code < 0 ) ;return - EPERM ;}info -> si_signo = sig ;,342
464,"* p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ;* p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ;* p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ;* p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ;* p_max_prec = 0 ;","* p_tx0 = ( OPJ_INT32 ) opj_uint_max ( p_cp -> tx0 + p * p_cp -> tdx , p_image -> x0 ) ;* p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx , p_image -> x1 ) ;* p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy , p_image -> y0 ) ;* p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy , p_image -> y1 ) ;* p_max_prec = 0 ;",343
465,"static char * create_output_name ( unsigned char * fname , unsigned char * dir ,  int lower , int isunix , int utf8 ) {unsigned char * p , * name , c , * fe , sep , slash ;unsigned int x ;sep = ( isunix ) ? \'/\' : \'\\\\\\\\\' ;slash = ( isunix ) ? \'\\\\\\\\\' : \'/\' ;x = strlen ( ( char * ) fname ) ;if ( utf8 ) x *= 3 ;if ( dir ) x += strlen ( ( char * ) dir ) ;fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\\return NULL ;while ( * fname == sep ) fname ++ ;p = & name [ strlen ( ( char * ) name ) ] ;fe = & fname [ strlen ( ( char * ) fname ) ] ;if ( utf8 ) {do {if ( fname >= fe ) {free ( name ) ;if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) {x = ( c & 0x1F ) << 6 ;x |= * fname ++ & 0x3F ;}else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) {x = ( c & 0xF ) << 12 ;x |= ( * fname ++ & 0x3F ) << 6 ;x |= * fname ++ & 0x3F ;}else x = \'?\' ;}if ( x == sep ) x = \'/\' ;else if ( x == slash ) x = \'\\\\\\\\\' ;else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ;if ( x < 0x80 ) {* p ++ = ( unsigned char ) x ;}else if ( x < 0x800 ) {* p ++ = 0xC0 | ( x >> 6 ) ;* p ++ = 0x80 | ( x & 0x3F ) ;}else {* p ++ = 0xE0 | ( x >> 12 ) ;* p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ;* p ++ = 0x80 | ( x & 0x3F ) ;}while ( x ) ;}else {do {c = * fname ++ ;if ( c == sep ) c = \'/\' ;else if ( c == slash ) c = \'\\\\\\\\\' ;else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ;while ( ( * p ++ = c ) ) ;return ( char * ) name ;","char * create_output_name ( unsigned char * fname ) {char * out , * p ;if ( utf8 ) x *= 3 ;if ( dir ) x += strlen ( ( char * ) dir ) ;fprintf ( stderr , ""out<S2SV_blank>of<S2SV_blank>memory!\\\return NULL ;while ( * fname == \'/\' || * fname == \'\\\\\\\\\' ) fname ++ ;strcpy ( out , ( * fname ) ? fname : ""x"" ) ;for ( p = out ;* p ;p ++ ) {if ( fname >= fe ) {free ( name ) ;if ( p [ 0 ] == \'.\' && p [ 1 ] == \'.\' && ( p [ 2 ] == \'/\' || p [ 2 ] == \'\\\\\\\\\' ) ) {p [ 0 ] = p [ 1 ] = \'x\' ;return out ;",344
466,"zval * options = NULL , * classes = NULL ;HashTable * class_hash = NULL ;","zval * options = NULL , * classes = NULL ;zval * retval ;HashTable * class_hash = NULL ;",345
467,"if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;zval_ptr_dtor ( return_value ) ;if ( ! EG ( exception ) ) {var_push_dtor ( & var_hash , return_value ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;","retval = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize_ex ( retval , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;if ( ! EG ( exception ) ) {ZVAL_COPY ( return_value , retval ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;",345
468,kfree ( tu -> queue ) ;tu -> queue = NULL ;,tu -> qhead = tu -> qtail = tu -> qused = 0 ;kfree ( tu -> queue ) ;tu -> queue = NULL ;,346
469,if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ;tmp_strsize = ( u32 ) ptr -> size - 8 ;tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ;,if ( ptr -> size ;tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ;,347
470,else  buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ;},else buf = ctx -> iface -> enc . get_glob_hdrs ( get_alg_priv ( ctx ) ) ;},348
471,if ( exim_uid == 0 ) {,"if ( exim_uid == 0 ) if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}else {",349
472,uschar * p = & argrest [ 2 ] ;,"uschar * hn ;if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}p = & argrest [ 2 ] ;",349
473,"else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;","else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;",349
474,"uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {","uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {",349
475,if ( info -> si_code >= 0 )   return - EPERM ;info -> si_signo = sig ;,if ( info -> si_code != SI_QUEUE ) {WARN_ON_ONCE ( info -> si_code < 0 ) ;return - EPERM ;}info -> si_signo = sig ;,350
476,"s -> off = strtoll ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 )  s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ;}","s -> off = strtoull ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 ) s -> filesize = strtoull ( slash + 1 , NULL , 10 ) ;}",351
477,"unsigned int maxw , maxh , max ;int offset , upb ;unsigned int i , j ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;for ( i = 0U ;++ i )  {for ( j = 0U ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {","size_t maxw , maxh , max , offx , loopmaxw ;int offset , upb ;size_t i ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;offx = img -> x0 & 1U ;loopmaxw = maxw - offx ;for ( i = 0U ;+ i )  {++ i ) {size_t j ;if ( offx > 0U ) {sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ;++ y ;++ r ;++ g ;++ b ;}for ( j = 0U ;j < ( loopmaxw & ~ ( unsigned int ) 1U ) ;j += 2U ) {",352
478,"if ( j < maxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;","if ( j < loopmaxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;",352
479,# if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = maxw ;img -> comps [ 2 ] . h = maxh ;# else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;# endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;},img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;img -> comps [ 2 ] . h = img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ;img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails : free ( r ) ;if ( g ) free ( g ) ;free ( b ) ;},352
480,"void  nfs4_state_set_mode_locked ( struct nfs4_state * state , mode_t mode )  {if ( state -> state == mode )  return ;if ( ( mode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) {if ( mode & FMODE_WRITE )  list_move ( & state -> open_states , & state -> owner -> so_states ) ;state -> state = mode ;}","void nfs4_state_set_mode_locked ( struct nfs4_state * state , fmode_t fmode ) {if ( state -> state == fmode ) return ;if ( ( fmode & FMODE_WRITE ) != ( state -> state & FMODE_WRITE ) ) {if ( fmode & FMODE_WRITE ) list_move ( & state -> open_states , & state -> owner -> so_states ) ;state -> state = fmode ;}",353
481,"ptr = sshpkt_ptr ( ssh , & dlen ) ;if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ;","ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;ptr = sshpkt_ptr ( ssh , & dlen ) ;if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ;",354
482,"assert_true_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" ,  NULL ) ;","assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;",355
483,"assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" ,  NULL ) ;","assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""foo\\\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""bar\\\\"")<S2SV_blank>==<S2SV_blank>-1\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\\\""FOO\\\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\\\""FOO\\\\\\\"" , NULL ) ;",355
484,( void ) CloseBlob ( pwp_image ) ;pwp_image = DestroyImage ( pwp_image ) ;,"
",356
485,"char lbase [ 256 ] ;char strbase [ 256 ] ;char ltest [ 256 ] ;char strtest [ 256 ] ;if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) {","char lbase [ 512 ] ;char strbase [ 256 ] ;char ltest [ 512 ] ;char strtest [ 256 ] ;if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) {",357
486,"while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) {int nbase = sscanf ( lbase , ""%255[^\\\\r\\\int ntest = sscanf ( ltest , ""%255[^\\\\r\\\assert ( nbase != 255 && ntest != 255 ) ;if ( nbase != 1 || ntest != 1 ) {","while ( fgets ( lbase , ""%511[^\\\\r\\\int ntest = sscanf ( ltest , ""%255[^\\\\r\\\assert ( nbase != 255 && ntest != 255 ) ;if ( nbase != 1 || ntest != 1 ) {",357
487,"int ret ;if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;usbnet_link_change ( dev , 0 , 0 ) ;return ret ;","if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ;return cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ;",358
488,"if ( ! virtqueue_pop ( vq , & elem ) ) {return 0 ;}memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ;virtqueue_push ( vq , & elem , len ) ;","iov_from_buf ( elem . in_sg [ 0 ] . iov_base , buf , len ) ;virtqueue_push ( vq , & elem , len ) ;",359
489,\\\},\\\},360
490,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",361
491,}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) && c -> format != CHUNKY ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,362
492,"isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return ( 1 ) ;","isoclns_print ( ndo , p + 1 , length - 1 ) ;return ( 1 ) ;",363
493,snd_seq_timer_stop ( q -> timer ) ;snd_seq_timer_close ( q ) ;snd_use_lock_sync ( & q -> use_lock ) ;,mutex_lock ( & q -> timer_mutex ) ;snd_seq_timer_stop ( q -> timer ) ;snd_seq_timer_close ( q ) ;mutex_unlock ( & q -> timer_mutex ) ;snd_use_lock_sync ( & q -> use_lock ) ;,364
494,"u64 start = offset >> PAGE_CACHE_SHIFT ;unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ;u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ;pgoff_t curr ;struct page * page ;unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ;unsigned int from , to ;if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ;if ( unlikely ( error ) ) goto out ;curr = start ;offset = start << PAGE_CACHE_SHIFT ;from = start_offset ;to = PAGE_CACHE_SIZE ;while ( curr <= end ) {page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ;if ( unlikely ( ! page ) ) {error = - ENOMEM ;if ( curr == end ) to = end_offset ;error = write_empty_blocks ( page , from , to , mode ) ;if ( ! error && offset + to > inode -> i_size &&  ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {i_size_write ( inode , offset + to ) ;}","unsigned int nr_blks ;sector_t lblock = offset >> inode -> i_blkbits ;if ( unlikely ( error ) ) return error ;while ( len ) {struct buffer_head bh_map = {. b_state = 0 , . b_blocknr = 0 };bh_map . b_size = len ;set_buffer_zeronew ( & bh_map ) ;error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ;if ( unlikely ( error ) ) goto out ;len -= bh_map . b_size ;nr_blks = bh_map . b_size >> inode -> i_blkbits ;lblock += nr_blks ;if ( ! buffer_new ( & bh_map ) ) continue ;if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) {error = - EIO ;}if ( offset + len > inode -> i_size && ! ( mode & FALLOC_FL_KEEP_SIZE ) ) {i_size_write ( inode , offset + to ) ;}",365
495,mark_inode_dirty ( inode ) ;brelse ( dibh ) ;out :  return error ;},mark_inode_dirty ( inode ) ;brelse ( dibh ) ;out : brelse ( dibh ) ;return error ;},365
496,"VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( ! load -> real ) {if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ;# ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\\# endif load -> real -> progress_signal = load -> out ;g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ;if ( class -> load ( load ) ||  vips_image_pio_input ( load -> real ) )  return ( NULL ) ;if ( ! vips_foreign_load_iscompat ( load -> real , out ) )  return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;","VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( load -> error ) return ( NULL ) ;if ( ! load -> real ) || vips_foreign_load_iscompat ( load -> real , out ) ) return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;",366
497,"const char * name = fit_get_name ( fit , noffset , NULL ) ;if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) {","const char * name = fit_get_name ( fit , noffset , NULL ) ;if ( strchr ( name , \'@\' ) ) {err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ;goto error ;}if ( ! strncmp ( name , FIT_SIG_NODENAME , strlen ( FIT_SIG_NODENAME ) ) ) {",367
498,"if ( context -> resynch ) {entry = & entries [ 0 ] ;for ( i = 0 ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) {if ( cursor -> offset == context -> dupcnt ) {context -> dupcnt = 0 ;break ;}context -> dupcnt ++ ;}else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) {context -> dupcnt = 0 ;break ;}}if ( i == ichdr . count ) {trace_xfs_attr_list_notfound ( context ) ;return 0 ;}}else {entry = & entries [ 0 ] ;i = 0 ;}context -> resynch = 0 ;retval = 0 ;for ( ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) {cursor -> hashval = be32_to_cpu ( entry -> hashval ) ;cursor -> offset = 0 ;}if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ;if ( entry -> flags & XFS_ATTR_LOCAL ) {xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ;retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;","if ( ! retval ) retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;",368
499,if ( retval )  return retval ;,if ( retval ) return retval ;,368
500,"if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) )  return - ENOMEM ;state -> dev = dev ;sd = & state -> sd ;","if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) {kfree ( state ) ;return - ENOMEM ;}state -> dev = dev ;sd = & state -> sd ;",369
501,"size += service_name_tlv_length ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;size += rw_tlv_length ;pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\\","if ( ! service_name_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += service_name_tlv_length ;}if ( ! miux_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;if ( ! rw_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += rw_tlv_length ;pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\\",370
502,"struct ssh * ssh = active_state ;struct monitor * mon ;if ( options . compression ) {mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ;mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ;ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ;}",struct monitor * mon ;,371
503,"vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_dec_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) {else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ;","vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , const vpx_codec_dec_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) {",372
504,res = VPX_CODEC_OK ;if ( ! ( flags & VPX_CODEC_USE_XMA ) ) {}if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ;,"
",372
505,"unsigned int channo ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {","unsigned int channo ;cdef -> ents = 0 ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {",373
506,"value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ;value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ;tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ;","value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL ;value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ;tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ;",374
507,"if ( ip_options_echo ( & icmp_param . replyopts , skb_in ) )  goto out_unlock ;","if ( ip_options_echo ( & icmp_param . replyopts . opt . opt , skb_in ) ) goto out_unlock ;",375
508,ipc . opt = & icmp_param . replyopts ;ipc . tx_flags = 0 ;room -= sizeof ( struct iphdr ) + icmp_param . replyopts . optlen ;room -= sizeof ( struct icmphdr ) ;,ipc . opt = & icmp_param . replyopts . opt ;ipc . tx_flags = 0 ;room -= sizeof ( struct iphdr ) + icmp_param . replyopts . opt . opt . optlen ;room -= sizeof ( struct icmphdr ) ;,375
509,"ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;","ND_TCHECK_32BITS ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",376
510,skb_dst_drop ( skb ) ;},if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ;else skb_dst_drop ( skb ) ;},377
511,crypto_free_skcipher ( private ) ;},struct skcipher_tfm * tfm = private ;crypto_free_skcipher ( tfm -> skcipher ) ;kfree ( tfm ) ;},378
512,struct inode * inode = file_inode ( bprm -> file ) ;umode_t mode = inode -> i_mode ;bprm -> cred -> euid = current_euid ( ) ;bprm -> cred -> egid = current_egid ( ) ;,bprm -> cred -> euid = current_euid ( ) ;bprm -> cred -> egid = current_egid ( ) ;,379
513,"return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;","if ( unlikely ( datalen > 0 ) ) {r = UIO_MAXIOV + 1 ;goto err ;}return headcount ;err : vhost_discard_vq_desc ( vq , headcount ) ;",380
514,"for ( ;* s && dlen ;s ++ ) {if ( strchr ( quote , * s ) ) {dlen -= 2 ;if ( dlen == 0 ) break ;","
",381
515,"rq = blk_mq_tag_to_rq ( tags , off + bit ) ;fn ( rq , data , reserved ) ;","rq = tags -> rqs [ off + bit ) ;fn ( rq , data , reserved ) ;",382
516,else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ;,"
",383
517,if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ;,"
",383
518,msg -> msg_namelen = 0 ;err = 0 ;,err = 0 ;,384
519,if ( skb_is_nonlinear ( skb ) )  return 0 ;,if ( skb_is_nonlinear ( skb ) ) return 0 ;if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;,385
520,"encode_share_access ( xdr , arg -> open_flags ) ;RESERVE_SPACE ( 28 ) ;","encode_share_access ( xdr , arg -> fmode ) ;RESERVE_SPACE ( 28 ) ;",386
521,"if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ;","if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len ) ) goto trunc ;",387
522,"case ETHERTYPE_GRE_ISO :  isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;","case ETHERTYPE_GRE_ISO : isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;",387
523,tilebuf = _TIFFmalloc ( tile_buffsize ) ;if ( tilebuf == 0 )  return 0 ;dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ;,"if ( tile_buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ;exit ( - 1 ) ;}tilebuf = _TIFFmalloc ( tile_buffsize + 3 ) ;if ( tilebuf == 0 ) return 0 ;tilebuf [ tile_buffsize ] = 0 ;tilebuf [ tile_buffsize + 1 ] = 0 ;tilebuf [ tile_buffsize + 2 ] = 0 ;dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ;",388
524,"int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( fd == - 1 ) {","int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( fd == - 1 ) {",389
525,"static void  modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) {return ;}","static int modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) {return 0 ;}",390
526,assert ( error == 0 ) ;},return error ;},390
527,struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;unsigned long tmp ;if ( tmp && tmp == cluster -> cl_has_local &&  cluster -> cl_local_node != node -> nd_num )  return - EBUSY ;if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret )  return ret ;},struct o2nm_cluster * cluster ;unsigned long tmp ;o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {ret = - EINVAL ;goto out ;}if ( tmp && tmp == cluster -> cl_has_local && cluster -> cl_local_node != node -> nd_num ) {ret = - EBUSY ;goto out ;}if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret ) goto out ;},391
528,return count ;},ret = count ;out : o2nm_unlock_subsystem ( ) ;return ret ;},391
529,"if ( fscanf ( fp , ""\\\if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ;if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\\","if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\\",392
530,"
",if ( len > 1 ) {,393
531,"if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;","if ( data [ 1 ] <= 127 ) {op -> jump = addr + data [ 1 ] + op -> size ;}else {op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;}}else {op -> jump = addr ;}op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;",393
532,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",394
533,"s = strchr ( token , \'?\' ) ;if ( s != NULL ) {","s = osStrchr ( token , \'?\' ) ;if ( s != NULL ) {",395
534,"if ( fop == NULL )  return - E_NOTHANDLED ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;","if ( fop == NULL ) return - E_NOTHANDLED ;if ( ninst == 0 ) return - E_INVALID ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;",396
535,ND_TCHECK ( lshp -> ls_type ) ;ND_TCHECK ( lshp -> ls_seq ) ;,ND_TCHECK ( lshp -> ls_length ) ;,397
536,"static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val )  {","static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) {",398
537,"case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ssid . length != 0 ) {if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;if ( length < ssid . length ) return 0 ;memcpy ( & ssid . ssid , p + offset , ssid . length ) ;offset += ssid . length ;length -= ssid . length ;}ssid . ssid [ ssid . length ] = '\\\\0' ;if ( ! pbody -> ssid_present ) {pbody -> ssid = ssid ;pbody -> ssid_present = 1 ;}break ;case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( challenge . length != 0 ) {if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ;if ( length < challenge . length ) return 0 ;memcpy ( & challenge . text , p + offset , challenge . length ) ;offset += challenge . length ;length -= challenge . length ;}challenge . text [ challenge . length ] = '\\\\0' ;if ( ! pbody -> challenge_present ) {pbody -> challenge = challenge ;pbody -> challenge_present = 1 ;}break ;case E_RATES : memcpy ( & rates , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( rates . length != 0 ) {if ( rates . length > sizeof rates . rate ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ;if ( length < rates . length ) return 0 ;memcpy ( & rates . rate , p + offset , rates . length ) ;offset += rates . length ;length -= rates . length ;}if ( ! pbody -> rates_present && rates . length != 0 ) {pbody -> rates = rates ;pbody -> rates_present = 1 ;}break ;case E_DS : memcpy ( & ds , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ds . length != 1 ) {offset += ds . length ;length -= ds . length ;break ;}ds . channel = * ( p + offset ) ;offset += 1 ;length -= 1 ;if ( ! pbody -> ds_present ) {pbody -> ds = ds ;pbody -> ds_present = 1 ;}break ;case E_CF : memcpy ( & cf , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( cf . length != 6 ) {offset += cf . length ;length -= cf . length ;break ;}memcpy ( & cf . count , p + offset , 6 ) ;offset += 6 ;length -= 6 ;if ( ! pbody -> cf_present ) {pbody -> cf = cf ;pbody -> cf_present = 1 ;}break ;case E_TIM : memcpy ( & tim , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( tim . length <= 3 ) {","case E_SSID : memcpy ( & ssid , p + offset + 3 , tim . length <= 3 ) {",399
538,"memcpy ( tim . bitmap , p + ( tim . length - 3 ) ,   ( tim . length - 3 ) ) ;offset += tim . length - 3 ;length -= tim . length - 3 ;if ( ! pbody -> tim_present ) {","memcpy ( tim . bitmap , p + ( tim . length - 3 ) , ( tim . length - 3 ) ) ;offset += tim . length - 3 ;length -= tim . length - 3 ;if ( ! pbody -> tim_present ) {",399
539,"pipe_buf_get ( ipipe , ibuf ) ;* obuf = * ibuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}* obuf = * ibuf ;",400
540,"r_buf_set_bytes ( tbuf , buf , sz ) ;struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ;","if ( ! tbuf ) {return NULL ;}r_buf_set_bytes ( tbuf , buf , sz ) ;struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ;",401
541,"mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;","unsigned int status = 0 ;mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ( unsigned int __user * ) & status , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= put_user ( status , ustatus ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;",402
542,",  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL }LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL },  {","LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/tty"" , NULL , MS_BIND , NULL }, {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/tty"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL }, {",403
543,"r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ;saved_errno = errno ;","r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL ) ;saved_errno = errno ;",403
544,"ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ;st -> st_oakley . group = lookup_group ( ke -> isak_group ) ;if ( st -> st_oakley . group == NULL ) {libreswan_log (  ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return v2N_INVALID_KE_PAYLOAD ;}","libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return STF_FAIL + v2N_INVALID_KE_PAYLOAD ;}",404
545,"void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride )  {nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ;if ( context -> ChromaSubsamplingLevel ) {nsc_encode_subsampling ( context ) ;}","BOOL nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) {if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ;if ( ! nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ) return FALSE ;if ( context -> ChromaSubsamplingLevel ) {if ( ! nsc_encode_subsampling ( context ) ) return FALSE ;}return TRUE ;",405
546,"void vp9_tree_probs_from_distribution ( vp9_tree tree ,  unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) {","void vp9_tree_probs_from_distribution ( vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) {",406
547,if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_xgmac_stats_string ) ;,if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ;,407
548,if ( image -> depth == 1 )  return ( ( image -> columns + 7 ) / 8 ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;,if ( image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) ) ;else return ( image -> columns * GetPSDPacketSize ( image ) ) ;,408
549,"p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;if ( p_dev -> fd < 0 ) {","p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ;if ( p_dev -> fd < 0 ) {",409
550,"p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ;if ( p_dev -> fd < 0 ) {","p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ;if ( p_dev -> fd < 0 ) {",409
551,alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,if ( ! pcu -> ctrl_intf ) return - EINVAL ;alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;if ( ! pcu -> data_intf ) return - EINVAL ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,410
552,"const char * name = d -> name ;struct device dev = d -> udev -> dev ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\dvb_usbv2_exit ( d ) ;dev_info ( & dev , ""%s:<S2SV_blank>\\\'%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}","const char * devname = kstrdup ( dev_name ( & d -> udev -> dev ) , GFP_KERNEL ) ;const char * drvname = d -> name ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\pr_info ( ""%s:<S2SV_blank>\\\'%s:%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}",411
553,xstep = picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;,"if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",412
554,if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",412
555,"r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end ,  & cpat , & cpat_end ) ;if ( r != 0 ) return r ;",return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION ;,413
556,"static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y ,  ExceptionInfo * exception ) {size_t bit ;ssize_t x ;register Quantum * q ;Quantum index ;switch ( depth )  {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}for ( bit = 0 ;bit ++ )  {index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}( void ) SyncAuthenticPixels ( image , exception ) ;break ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL )  break ;index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;","static MagickBooleanType InsertRow ( Image * image , ssize_t bpp , unsigned char * p , ssize_t y , ExceptionInfo * exception ) {int bit ;Quantum index ;register Quantum * q ;Quantum index ;switch ( bpp ) {index = ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}for ( bit = 0 ;bit ++ ) {index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;}break ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns - 3 ) ;x += 4 ) {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 4 ) > 2 ) {index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;}}p ++ ;}break ;}case 4 : {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;",414
557,"index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;q += GetPixelChannels ( image ) ;}}( void ) SyncAuthenticPixels ( image , exception ) ;break ;}case 4 : {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 1 ) ;x += 2 ) {q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ;SetPixelIndex ( image , index , q ) ;if ( ( image -> columns % 2 ) != 0 ) {index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;}q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL )  break ;index = ConstrainColormapIndex ( image , * p , exception ) ;SetPixelIndex ( image , index , q ) ;( void ) SyncAuthenticPixels ( image , exception ) ;","index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 ) {if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;p ++ ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;index = ConstrainColormapIndex ( image , * p , exception ) ;SetPixelIndex ( image , index , q ) ;",414
558,"static int cfm_network_addr_print ( netdissect_options * ndo ,  register const u_char * tptr )  {u_int hexdump = FALSE ;network_addr_type = * tptr ;case AFNUM_INET :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;","static int cfm_network_addr_print ( netdissect_options * ndo , register const u_char * tptr , const u_int length ) {u_int hexdump = FALSE ;if ( length < 1 ) {ND_PRINT ( ( ndo , ""\\\return hexdump ;}network_addr_type = * tptr ;case AFNUM_INET : if ( length != 1 + 4 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 : if ( length != 1 + 16 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;",415
559,u64 msr_data ;int usermode ;cs . dpl = 3 ;ss . dpl = 3 ;,"u64 msr_data , rcx , rdx ;int usermode ;rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ;rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ;cs . dpl = 3 ;ss . dpl = 3 ;",416
560,"break ;}ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ;* reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;return X86EMUL_CONTINUE ;","if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ;break ;}ctxt -> _eip = rdx ;* reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ;return X86EMUL_CONTINUE ;",416
561,"return sprintf ( buf , ""%s\\\}","ssize_t len ;device_lock ( dev ) ;len = sprintf ( buf , ""%s\\\device_unlock ( dev ) ;return len ;}",417
562,"BIO * tmpout = NULL ;if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ;else if ( flags & CMS_TEXT ) {tmpout = BIO_new ( BIO_s_mem ( ) ) ;BIO_set_mem_eof_return ( tmpout , 0 ) ;else tmpout = out ;","BIO * tmpout ;tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ;goto err ;for ( ;;) {i = BIO_read ( in , buf , sizeof ( buf ) ) ;if ( i <= 0 ) {if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) {if ( ! BIO_get_cipher_status ( in ) ) goto err ;}if ( i < 0 ) goto err ;break ;}if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ;}if ( flags & CMS_TEXT ) {",418
563,"rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;}","if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;}",419
564,"static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs ,  int i , int c ) {const vp9_prob prob = probs [ i / 2 ] ;int b ;const vp9_tree_index ii = tree [ i + b ] ;if ( ii <= 0 ) costs [ - ii ] = cc ;","static void cost ( int * costs , vpx_tree tree , const vp9_prob * probs , int i , int c ) {const vpx_prob prob = probs [ i / 2 ] ;int b ;const vpx_tree_index ii = tree [ i + b ] ;if ( ii <= 0 ) costs [ - ii ] = cc ;",420
565,create_option_search_table ( ) ;goto open_rc ;,"# ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ;if ( tmp_dir == NULL ) tmp_dir = rc_dir ;# endif create_option_search_table ( ) ;goto open_rc ;",421
566,"switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;","size_t pathlen = 0 ;switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;",422
567,"case AF_UNIX :  strncpy ( addr_text ,   ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ,  sizeof ( addr_text ) - 1 ) ;addr_text [ sizeof ( addr_text ) - 1 ] = \'\\\\0\' ;","case AF_UNIX : pathlen = sizeof ( ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ) ;if ( MAXPATHLEN <= pathlen ) {pathlen = MAXPATHLEN - 1 ;}strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ;addr_text [ pathlen ] = \'\\\\0\' ;",422
568,"static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 ,  __m128i * in1 , int stride ) {","static INLINE void write_buffer_16x16 ( tran_low_t * output , __m128i * in0 , __m128i * in1 , int stride ) {",423
569,"err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ;if ( err < 0 ) return err ;","err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf + p , c , 0 ) ;if ( err < 0 ) return err ;",424
570,"struct hstate * h = hstate_vma ( vma ) ;struct page * page ;struct address_space * mapping = vma -> vm_file -> f_mapping ;struct inode * inode = mapping -> host ;if ( chg )  if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return ERR_PTR ( - VM_FAULT_SIGBUS ) ;page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ;if ( ! page ) {hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;","struct hugepage_subpool * spool = subpool_vma ( vma ) ;struct hstate * h = hstate_vma ( vma ) ;struct page * page ;if ( chg ) if ( hugepage_subpool_get_pages ( spool , chg ) ) return ERR_PTR ( - VM_FAULT_SIGBUS ) ;hugepage_subpool_put_pages ( spool , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;",425
571,"DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\","if ( NULL == filegen ) {msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ;continue ;}DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\",426
572,filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;,"if ( NULL == filegen ) {msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\\\'%s\\\'<S2SV_blank>unrecognized"" , filegen_file ) ;continue ;}filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;",426
573,"if ( t -> stamp_path )  touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ;timer_set_state ( t , TIMER_RUNNING ) ;","if ( t -> stamp_path ) touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , MODE_INVALID ) ;timer_set_state ( t , TIMER_RUNNING ) ;",427
574,"static void fadst16 ( const int16_t * input , int16_t * output ) {int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s10 , s11 , s12 , s13 , s14 , s15 ;int x0 = input [ 15 ] ;int x1 = input [ 0 ] ;int x2 = input [ 13 ] ;int x3 = input [ 2 ] ;int x4 = input [ 11 ] ;int x5 = input [ 4 ] ;int x6 = input [ 9 ] ;int x7 = input [ 6 ] ;int x8 = input [ 7 ] ;int x9 = input [ 8 ] ;int x10 = input [ 5 ] ;int x11 = input [ 10 ] ;int x12 = input [ 3 ] ;int x13 = input [ 12 ] ;int x14 = input [ 1 ] ;int x15 = input [ 14 ] ;s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ;","static void fadst16 ( const tran_low_t * input , int16_t * output ) {tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 ;tran_high_t s9 , s10 , s11 , s12 , s13 , s14 , s15 ;tran_high_t x0 = input [ 15 ] ;tran_high_t x1 = input [ 0 ] ;tran_high_t x2 = input [ 13 ] ;tran_high_t x3 = input [ 2 ] ;tran_high_t x4 = input [ 11 ] ;tran_high_t x5 = input [ 4 ] ;tran_high_t x6 = input [ 9 ] ;tran_high_t x7 = input [ 6 ] ;tran_high_t x8 = input [ 7 ] ;tran_high_t x9 = input [ 8 ] ;tran_high_t x10 = input [ 5 ] ;tran_high_t x11 = input [ 10 ] ;tran_high_t x12 = input [ 3 ] ;tran_high_t x13 = input [ 12 ] ;tran_high_t x14 = input [ 1 ] ;tran_high_t x15 = input [ 14 ] ;s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ;",428
575,output [ 0 ] = x0 ;output [ 1 ] = - x8 ;output [ 2 ] = x12 ;output [ 3 ] = - x4 ;output [ 4 ] = x6 ;output [ 5 ] = x14 ;output [ 6 ] = x10 ;output [ 7 ] = x2 ;output [ 8 ] = x3 ;output [ 9 ] = x11 ;output [ 10 ] = x15 ;output [ 11 ] = x7 ;output [ 12 ] = x5 ;output [ 13 ] = - x13 ;output [ 14 ] = x9 ;output [ 15 ] = - x1 ;},output [ 0 ] = ( tran_low_t ) x0 ;output [ 1 ] = ( tran_low_t ) - x8 ;output [ 2 ] = ( tran_low_t ) x12 ;output [ 3 ] = ( tran_low_t ) - x4 ;output [ 4 ] = ( tran_low_t ) x6 ;output [ 5 ] = ( tran_low_t ) x14 ;output [ 6 ] = ( tran_low_t ) x10 ;output [ 7 ] = ( tran_low_t ) x2 ;output [ 8 ] = ( tran_low_t ) x3 ;output [ 9 ] = ( tran_low_t ) x11 ;output [ 10 ] = ( tran_low_t ) x15 ;output [ 11 ] = ( tran_low_t ) x7 ;output [ 12 ] = ( tran_low_t ) x5 ;output [ 13 ] = ( tran_low_t ) - x13 ;output [ 14 ] = ( tran_low_t ) x9 ;output [ 15 ] = ( tran_low_t ) - x1 ;},428
576,# if HAVE_EDSP  flags |= HAS_EDSP ;# endif # if HAVE_MEDIA flags |= HAS_MEDIA ;# endif  # if HAVE_NEON  flags |= HAS_NEON ;,# if HAVE_MEDIA flags |= HAS_MEDIA ;# endif # if HAVE_NEON || HAVE_NEON_ASM flags |= HAS_NEON ;,429
577,"MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi ,  const MODE_INFO * left_mi , int b ) {","PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO * left_mi , int b ) {",430
578,"static void  swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc16 ( tif , cp0 , cc ) ;}","static int swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc16 ( tif , cp0 , cc ) ;}",431
579,opt2 -> tot_len = tot_len ;p = ( char * ) ( opt2 + 1 ) ;,"atomic_set ( & opt2 -> refcnt , 1 ) ;opt2 -> tot_len = tot_len ;p = ( char * ) ( opt2 + 1 ) ;",432
580,"for ( i = 0 ;i ++ )  av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;return 0 ;}","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;}return 0 ;}",433
581,if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) ||  dp == datalen ) {flags &= ~ FLAG_LAST_MATCHED ;,if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) ) {flags &= ~ FLAG_LAST_MATCHED ;,434
582,"char * fpath = NULL , * cgdir = NULL , * controller ;const char * cgroup ;","char * fpath = NULL , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;",435
583,"fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\\if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;return ret ;}","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , & next ) ) {if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;goto out ;}if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ;else ret = - ENOENT ;if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) {ret = - EACCES ;goto out ;}if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;free ( next ) ;return ret ;}",435
584,if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ;if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ;else mnt -> mnt_group_id = old -> mnt_group_id ;if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) {err = mnt_alloc_group_id ( mnt ) ;if ( err ) goto out_free ;mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ;if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) )  mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) )  mnt -> mnt . mnt_flags |= MNT_LOCKED ;,if ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ;if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ;if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) mnt -> mnt . mnt_flags |= MNT_LOCKED ;,436
585,"}if ( trans == NULL ) {kmem_cache_free ( rds_conn_slab , conn ) ;conn = ERR_PTR ( - ENODEV ) ;goto out ;","
",437
586,if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 &&  rdesc [ 106 ] == 0x03 ) {,if ( * rsize >= 112 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && rdesc [ 106 ] == 0x03 ) {,438
587,"if ( ( tot_len - offset - 4 ) < bodyLength ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;","if ( ( ( tot_len - offset - 4 ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;",439
588,"if ( likely ( port -> exists && ! filtered ) )  serio_interrupt ( serio , data , dfl ) ;","if ( likely ( serio && ! filtered ) ) serio_interrupt ( serio , data , dfl ) ;",440
589,"if ( ! er )  ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ;return ;",if ( ! er ) {ND_TCHECK ( dp [ 0 ] ) ) ) ;return ;,441
590,"static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName ,   int udfLen , uint8_t * fidName ,  int fidNameLen ) {","static int udf_translate_to_linux ( uint8_t * newName , int newLen , uint8_t * udfName , int udfLen , uint8_t * fidName , int fidNameLen ) {",442
591,if ( newIndex < 256 )  newName [ newIndex ++ ] = curr ;,if ( newIndex < newLen ) newName [ newIndex ++ ] = curr ;,442
592,maxFilenameLen = 250 - localExtIndex ;if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ;else newIndex = newExtIndex ;}else if ( newIndex > 250 )  newIndex = 250 ;,maxFilenameLen = newLen - CRC_LEN - localExtIndex ;if ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN ;,442
593,"static void count_segs_sb ( VP9_COMP * cpi , const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) {const VP9_COMMON * const cm = & cpi -> common ;const int mis = cm -> mi_stride ;const int bs = num_8x8_blocks_wide_lookup [ bsize ] , hbs = bs / 2 ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;if ( bw == bs && bh == bs ) {count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 + hbs * mis , no_pred_segcounts ,  temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ;count_segs ( cpi , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count ,  t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ;count_segs ( cpi , tile , mi_8x8 + hbs ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ;","static void count_segs_sb ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi_8x8 , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) {const int mis = cm -> mi_stride ;const int bs = num_8x8_blocks_wide_lookup [ mi [ 0 ] -> mbmi . sb_type ] ;bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ;if ( bw == bs && bh == bs ) {count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi + hbs * mis , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ;count_segs ( cm , xd , tile , mi , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col ) ;count_segs ( cm , xd , tile , mi + hbs , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , hbs , bs , mi_row , mi_col + hbs ) ;",443
594,"count_segs_sb ( cpi , tile , & mi_8x8 [ mi_dr * mis + mi_dc ] ,  no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ;","count_segs_sb ( cm , xd , tile , & mi [ mi_dr * mis + mi_dc ] , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , mi_row + mi_dr , mi_col + mi_dc , subsize ) ;",443
595,if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ;if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ;if ( ! c -> reqtype ) {,if ( ! ( c -> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) ) break ;if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ;if ( ! c -> reqtype ) {,444
596,get_blocks_flags = EXT4_GET_BLOCKS_CREATE ;if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ;,get_blocks_flags = EXT4_GET_BLOCKS_CREATE ;if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT ;if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ;,445
597,"int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err :  DSA_SIG_free ( s ) ;return ( ret ) ;","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = DSA_SIG_new ( ) ;if ( d2i_DSA_SIG ( & s , & p , siglen ) == NULL ) goto err ;derlen = i2d_DSA_SIG ( s , & der ) ;if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}DSA_SIG_free ( s ) ;return ( ret ) ;",446
598,"gdImageGifCtx ( im , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;","if ( ! _gdImageGifCtx ( im , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",447
599,kfree ( bprm ) ;},if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;kfree ( bprm ) ;},448
600,"size_t canonnamelen = 0 ;if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) )  {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle ,  & p -> ai_flags ,   & p -> ai_family ,   & p -> ai_socktype ,   & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen ,  NULL ,  canonnamelen ,  & canonnamelen , NULL ) != OE_OK ) {","size_t canonnamelen_in = 0 ;if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , & p_out . ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol , p -> ai_addrlen , & p -> ai_addrlen , NULL , canonnamelen , & canonnamelen , NULL ) != OE_OK ) {",449
601,"if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) )  {if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) )  {if ( oe_syscall_getaddrinfo_read_ocall (  & retval , handle , & p -> ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol ,  p -> ai_addrlen ,  & p -> ai_addrlen , p -> ai_addr ,  canonnamelen ,  & canonnamelen , p -> ai_canonname ) != OE_OK ) {if ( tail )  {","if ( p -> ai_addrlen && ! ( p -> ai_addr = oe_calloc ( 1 , p -> ai_addrlen ) ) ) {if ( canonnamelen && ! ( p -> ai_canonname = oe_calloc ( 1 , canonnamelen ) ) ) {if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , & p -> ai_flags , & p_out . ai_family , & p -> ai_socktype , & p_out . ai_protocol , p_out . ai_addrlen , & p -> ai_addrlen , p -> ai_addr , canonnamelen_in , & canonnamelen_out , p -> ai_canonname ) != OE_OK ) {if ( ( p -> ai_flags != p_out . ai_flags ) || ( p -> ai_family != p_out . ai_family ) || ( p -> ai_socktype != p_out . ai_socktype ) || ( p -> ai_protocol != p_out . ai_protocol ) || ( p -> ai_addrlen != p_out . ai_addrlen ) || ( canonnamelen_out != canonnamelen_in ) || ( canonnamelen_out && p -> ai_canonname [ canonnamelen_out - 1 ] != '\\\\0' ) ) {ret = OE_EAI_FAIL ;goto done ;}if ( tail ) {",449
602,"separator = strchr ( token , \':\' ) ;if ( separator != NULL ) {","separator = osStrchr ( token , \':\' ) ;if ( separator != NULL ) {",450
603,"separator = strchr ( token , \'=\' ) ;if ( separator != NULL ) {","separator = osStrchr ( token , \'=\' ) ;if ( separator != NULL ) {",450
604,rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ;,"if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) {iw_set_error ( rctx -> ctx , ""Invalid<S2SV_blank>image<S2SV_blank>dimensions"" ) ;goto done ;}rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ;rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ;",451
605,"vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs ,  sizeof ( default_coef_probs ) ) ;","memcpy ( pc -> fc . coef_probs , default_coef_probs , sizeof ( default_coef_probs ) ) ;",452
606,"static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data )  {int ret ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 ,  indx , data , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}","static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , const void * data ) {u8 * buf ;int ret ;buf = kmemdup ( data , size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , indx , buf , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\kfree ( buf ) ;return ret ;}",453
607,"mod_ty  Module ( asdl_seq * body , PyArena * arena )  {return p ;}","mod_ty Module ( asdl_seq * body , asdl_seq * type_ignores , PyArena * arena ) {p -> v . Module . type_ignores = type_ignores ;return p ;}",454
608,"sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ;}",},455
609,"int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src ,  int64_t ts_start , int64_t ts_end , unsigned int flags ) {struct lookahead_entry * buf ;# endif  if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ;# if USE_PARTIAL_COPY   if ( ctx -> max_sz == 1 && active_map && ! flags ) {for ( row = 0 ;","int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src , int64_t ts_start , int64_t ts_end , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif unsigned int flags ) {struct lookahead_entry * buf ;# endif int width = src -> y_crop_width ;int height = src -> y_crop_height ;int uv_width = src -> uv_crop_width ;int uv_height = src -> uv_crop_height ;int subsampling_x = src -> subsampling_x ;int subsampling_y = src -> subsampling_y ;int larger_dimensions , new_dimensions ;if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ;new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ;larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ;assert ( ! larger_dimensions || new_dimensions ) ;# if USE_PARTIAL_COPY if ( ! new_dimensions && ctx -> max_sz == 1 && active_map && ! flags ) {for ( row = 0 ;",456
610,"vp9_copy_and_extend_frame ( src , & buf -> img ) ;}# else vp9_copy_and_extend_frame ( src , & buf -> img ) ;","# endif if ( larger_dimensions ) {YV12_BUFFER_CONFIG new_img ;memset ( & new_img , 0 , sizeof ( new_img ) ) ;if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ;vpx_free_frame_buffer ( & buf -> img ) ;# if USE_PARTIAL_COPY }",456
611,"rc = fuse_dev_release ( inode , file ) ;return rc ;","fuse_conn_put ( & cc -> fc ) ;rc = fuse_dev_release ( inode , file ) ;return rc ;",457
612,"if ( code )  return code ;code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;","if ( code ) {* status = ""DECODE_PA_S4U_X509_USER"" ;return code ;}code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;",458
613,"static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf )  {","static int scsi_disk_emulate_command ( SCSIDiskReq * r ) {uint8_t * outbuf ;if ( ! r -> iov . iov_base ) {if ( req -> cmd . xfer > 65536 ) {goto illegal_request ;}r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}outbuf = r -> iov . iov_base ;",459
614,if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f ||  s -> cur_pic . field_picture ||  s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ;,if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture ) return 0 ;,460
615,"if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;}return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;}","struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ;int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ;goto out ;}out : return ret ;}",461
616,"if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) )  return 0 ;ext_block = ( struct grub_ext4_extent_header * ) buf ;","if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) ) {return 0 ;}ext_block = ( struct grub_ext4_extent_header * ) buf ;",462
617,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}",ret = key_read_state ( key ) ;if ( ret < 0 ) goto error2 ;,463
618,"ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;",464
619,"ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 1 ) ;if ( bp [ hlen ] & 0xf0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( bp [ hlen ] & 0x10 )  ND_PRINT ( ( ndo , ""K"" ) ) ;hlen += 1 ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;hlen += 2 ;break ;case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( * mh , hlen + 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;if ( bp [ hlen ] & 0xf0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;}if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , ""K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( bp [ hlen ] , 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;",464
620,dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,465
621,uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,uint32_t data_siz ;uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,466
622,}UNUSED ( hmi_size ) ;,"}if ( hmi_track_offset [ i ] >= hmi_size ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz = hmi_size - hmi_track_offset [ i ] ;",466
623,"if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_track_offset [ i ] += hmi_tmp ;}else if ( hmi_data [ 1 ] == 0x15 ) {hmi_data += 4 ;}hmi_data += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;","if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_tmp += 4 ;hmi_tmp = 8 ;}else {hmi_tmp = 4 ;}hmi_data += 4 ;if ( hmi_tmp > data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -= hmi_tmp ;}hmi_data += 4 ;hmi_track_offset [ i ] += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , data_siz , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;",466
624,hmi_track_offset [ i ] += setup_ret ;note [ hmi_tmp ] . length = 0 ;if ( * hmi_data > 0x7f ) {do {note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;hmi_track_offset [ i ] ++ ;}}hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {,"data_siz -= setup_ret ;}}if ( data_siz && * hmi_data > 0x7f ) {do {if ( ! data_siz ) break ;if ( ! data_siz ) break ;note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;}}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {",466
625,}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,466
626,release_sock ( sk ) ;return 0 ;,haddr -> hci_channel = 0 ;release_sock ( sk ) ;return 0 ;,467
627,fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,fh16 [ 3 ] = 0 ;fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,468
628,"if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) {* status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ;","if ( check_anon ( kdc_active_realm , client . princ , request -> server ) != 0 ) {* status = ""ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED"" ;",469
629,if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {,"
",470
630,}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {,if ( src_known && dst_known ) {,470
631,if ( dst_reg -> smin_value < 0 ) {if ( umin_val ) {}},if ( dst_reg -> smin_value < 0 ) {if ( umin_val ) {}},470
632,"if ( method == LPF_PICK_FROM_Q ) {const int min_filter_level = 0 ;const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ;int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ;search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;}","if ( method == LPF_PICK_MINIMAL_LPF && lf -> filter_level ) {lf -> filter_level = 0 ;}else if ( method >= LPF_PICK_FROM_Q ) {const int min_filter_level = 0 ;const int q = vp9_ac_quant ( cm -> base_qindex , 0 , cm -> bit_depth ) ;# if CONFIG_VP9_HIGHBITDEPTH int filt_guess ;switch ( cm -> bit_depth ) {case VPX_BITS_8 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;break ;case VPX_BITS_10 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 4060632 , 20 ) ;break ;case VPX_BITS_12 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 16242526 , 22 ) ;break ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>"" ""or<S2SV_blank>VPX_BITS_12"" ) ;return ;}# else int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;# endif if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ;lf -> filter_level = search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;}",471
633,for ( i = 0 ;,TEMP_FAILURE_RETRY ( for ( i = 0 ;,472
634,"usleep ( 100000 ) ;kill ( getpid ( ) , SIGKILL ) ;","usleep ( 100000 ) ) ;kill ( getpid ( ) , SIGKILL ) ;",472
635,quantum_info = DestroyQuantumInfo ( quantum_info ) ;return ( DestroyImageList ( image ) ) ;,quantum_info = DestroyQuantumInfo ( quantum_info ) ;canvas_image = DestroyImage ( canvas_image ) ;return ( DestroyImageList ( image ) ) ;,473
636,"int a = getnum ( fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;","int a = getnum ( L , fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;",474
637,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\\",475
638,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,476
639,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",476
640,"if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) )  break ;SetImageColorspace ( image , CMYKColorspace ) ;","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;SetImageColorspace ( image , CMYKColorspace ) ;",477
641,"long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",478
642,"if ( ! ctx || ( ! data && data_sz ) )  res = VPX_CODEC_INVALID_PARAM ;res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz ,  user_priv , deadline ) ;","if ( ! ctx || ( ! data && data_sz ) || ( data && ! data_sz ) ) res = VPX_CODEC_INVALID_PARAM ;res = ctx -> iface -> dec . decode ( get_alg_priv ( ctx ) , data , data_sz , user_priv , deadline ) ;",479
643,"if ( ! strcmp ( attr , ""packetization-mode"" ) ) {","if ( * value == 0 || ! strcmp ( attr , ""packetization-mode"" ) ) {",480
644,"if ( value [ strlen ( value ) - 1 ] == \',\' ) {av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\\","if ( value [ strlen ( value ) - 1 ] == \',\' ) {av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\\",480
645,static int isofs_read_inode ( struct inode * inode )  {,"static int isofs_read_inode ( struct inode * inode , int relocated ) {",481
646,"parse_rock_ridge_inode ( de , inode ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;","parse_rock_ridge_inode ( de , inode , relocated ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;",481
647,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",482
648,"if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ;if ( length <= 2 ) {ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""bad<S2SV_blank>pkt!"" : ""no<S2SV_blank>header<S2SV_blank>at<S2SV_blank>all!"" ) ) ;return ;}esis_header = ( const struct esis_header_t * ) pptr ;ND_TCHECK ( * esis_header ) ;li = esis_header -> length_indicator ;optr = pptr ;if ( esis_header -> nlpid != NLPID_ESIS ) {ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ;return ;}if ( esis_header -> version != ESIS_VERSION ) {ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ;return ;}if ( li > length ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ;return ;}if ( li < sizeof ( struct esis_header_t ) + 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ;while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ;return ;}esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ;if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ;return ;}else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\\ND_PRINT ( ( ndo , "",<S2SV_blank>v:<S2SV_blank>%u%s"" , esis_header -> version , esis_header -> version == ESIS_VERSION ? """" : ""unsupported"" ) ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>checksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( esis_header -> cksum ) ) ) ;osi_print_cksum ( ndo , pptr , EXTRACT_16BITS ( esis_header -> cksum ) , 7 , li ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>indicator:<S2SV_blank>%u"" , EXTRACT_16BITS ( esis_header -> holdtime ) , li ) ) ;if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , optr , ""\\\pptr += sizeof ( struct esis_header_t ) ;li -= sizeof ( struct esis_header_t ) ;switch ( esis_pdu_type ) {case ESIS_PDU_REDIRECT : {const uint8_t * dst , * snpa , * neta ;u_int dstl , snpal , netal ;ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}dstl = * pptr ;pptr ++ ;li -- ;ND_TCHECK2 ( * pptr , dstl ) ;if ( li < dstl ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}dst = pptr ;pptr += dstl ;li -= dstl ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}snpal = * pptr ;pptr ++ ;li -- ;ND_TCHECK2 ( * pptr , snpal ) ;if ( li < snpal ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}snpa = pptr ;pptr += snpal ;li -= snpal ;ND_TCHECK ( * pptr ) ;if ( li < 1 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}netal = * pptr ;pptr ++ ;ND_TCHECK2 ( * pptr , netal ) ;if ( li < netal ) {ND_PRINT ( ( ndo , "",<S2SV_blank>bad<S2SV_blank>redirect/li"" ) ) ;return ;}neta = pptr ;pptr += netal ;li -= netal ;if ( netal == 0 )   ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\","if ( snpal == 6 ) ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\if ( netal != 0 ) ND_PRINT ( ( ndo , ""\\\else ND_PRINT ( ( ndo , ""\\\",483
649,"outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ;}}","sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K"" , c , m , y , k ) ;}sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k"" , c , m , y , k ) ;}sendClean ( outputbuffer ) ;}",484
650,BUG ( ) ;}BUG ( ) ;},return false ;}}else if ( r -> CRn == 0 && r -> CRm == 9 ) {if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ;idx = ARMV8_PMU_CYCLE_IDX ;return false ;},485
651,case IS_STRING :  convert_to_double_ex ( zval_affine_elem ) ;affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ;break ;,case IS_STRING : {zval dval ;dval = * * zval_affine_elem ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;affine [ i ] = Z_DVAL ( dval ) ;}break ;,486
652,"convert_to_long_ex ( tmp ) ;rect . x = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;convert_to_long_ex ( tmp ) ;rect . height = Z_LVAL_PP ( tmp ) ;}","if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . x = Z_LVAL ( lval ) ;}}rect . x = Z_LVAL_PP ( tmp ) ;}else {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . y = Z_LVAL ( lval ) ;}}else {rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . width = Z_LVAL ( lval ) ;}}else {rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . height = Z_LVAL ( lval ) ;}else {rect . height = Z_LVAL_PP ( tmp ) ;}}",486
653,static void ast_dealloc ( AST_object * self )  {Py_CLEAR ( self -> dict ) ;,static void ast_dealloc ( AST_object * self ) {PyObject_GC_UnTrack ( self ) ;Py_CLEAR ( self -> dict ) ;,487
654,free ( szSepLine ) ;return 0 ;,return 0 ;,488
655,"r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ;if ( r ) return - EFAULT ;","r = __copy_from_user ( data , ( void __user * ) addr + offset , len ) ;if ( r ) return - EFAULT ;",489
656,"char * p , * q , * r ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;","char * p , * q ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;",490
657,"printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;","printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;",490
658,"if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( * p ) ;p ++ )  ;lenIV = atoi ( line + 6 ) ;}else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) )  && strstr ( line , ""readstring"" ) ) {* p = \'\\\\0\' ;q = strrchr ( line , \'/\' ) ;if ( q ) {r = cs_start ;++ q ;while ( ! isspace ( * q ) && * q != \'{\' ) * r ++ = * q ++ ;* r = \'\\\\0\' ;* p = \'s\' ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) )  ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) )  ever_active = active = 1 ;for ( q = p ;isspace ( * q ) && * q != \'\\\q ++ )  ;","if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( ( unsigned char ) line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( ( unsigned char ) * p ) ;p ++ ) ;+ q ;set_lenIV ( line ) ;else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) ) ) {set_cs_start ( line ) ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( ( unsigned char ) p [ 7 ] ) ) ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( ( unsigned char ) p [ 13 ] ) ) ever_active = active = 1 ;for ( q = p ;isspace ( ( unsigned char ) * q ) && * q != \'\\\q ++ ) ;",490
659,"
",info -> port = NULL ;,491
660,usb_autopm_put_interface ( serial -> interface ) ;error_get_interface : usb_serial_put ( serial ) ;,usb_autopm_put_interface ( serial -> interface ) ;error_get_interface : usb_serial_put ( serial ) ;,491
661,"lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ;lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ;cpuctx -> ctx . type = cpu_context ;cpuctx -> ctx . pmu = pmu ;",lockdep_set_class ( & cpuctx -> ctx . pmu = pmu ;,492
662,"static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len ,  struct iovec * iovec )  {return 0 ;}","static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , struct iovec * iovec , struct iov_iter * iter ) {if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ;iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;return 0 ;}",493
663,int groups_per_flex = 0 ;size_t size ;groups_per_flex = 1 << sbi -> s_log_groups_per_flex ;if ( groups_per_flex < 2 ) {sbi -> s_log_groups_per_flex = 0 ;return 1 ;},unsigned int groups_per_flex = 0 ;size_t size ;,494
664,if ( unlikely ( chunk_length < required_length ) )  return 0 ;,if ( unlikely ( chunk -> pdiscard ) ) return 0 ;if ( unlikely ( chunk_length < required_length ) ) return 0 ;,495
665,for ( i = 0 ;++ i ) {n = cJSON_CreateString ( strings [ i ] ) ;if ( ! i )  a -> child = n ;,for ( i = 0 ;+ i ) {i ++ ) {n = cJSON_CreateString ( strings [ i ] ) ;if ( ! n ) {cJSON_Delete ( a ) ;return 0 ;}if ( ! i ) a -> child = n ;,496
666,"
","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;",497
667,"if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",497
668,"if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;","if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",497
669,else # endif  for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,else # endif for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,498
670,match_length += callback_args -> forward_matches ;if ( callback_args -> full_word ) {,match_length += callback_args -> forward_matches ;assert ( match_offset + match_length <= callback_args -> data_size ) ;if ( callback_args -> full_word ) {,499
671,"if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 &&  ! no_port_forwarding_flag && ! options . disable_forwarding ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;","if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 && ! no_port_forwarding_flag && ! options . disable_forwarding && use_privsep ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;",500
672,if ( ! bitstream_read_bit ( bc ) ) {if ( hc -> current >= 256 ) {,"if ( length > SMKTREE_DECODE_MAX_RECURSION ) {av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\\return AVERROR_INVALIDDATA ;}if ( ! bitstream_read_bit ( bc ) ) {if ( hc -> current >= 256 ) {",501
673,m -> msg_name = address ;},if ( m -> msg_name ) m -> msg_name = address ;},502
674,"if ( obj == Py_None ) {* out = NULL ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;","if ( lookup_attr_id ( obj , ( PyObject * ) Module_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;return 1 ;}else {int res ;Py_ssize_t i ;",503
675,"stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ;","stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""type_ignores\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;else {Py_ssize_t i ;",503
676,"type_ignore_ty value ;res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( type_ignores , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""type_ignores\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module"" ) ;return 1 ;","type_ignore_ty val ;res = obj2ast_type_ignore ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( type_ignores , i , val ) ;}",503
677,"if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;","if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ;return 1 ;}else {Py_ssize_t i ;",503
678,"stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive"" ) ;return 1 ;","stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}",503
679,"if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {asdl_seq * argtypes ;expr_ty returns ;if ( _PyObject_HasAttrId ( obj , & PyId_argtypes ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ;","if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression"" ) ;return 1 ;}else {Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , & PyId_argtypes ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_argtypes ) ;",503
680,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( argtypes , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;return 1 ;tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;if ( tmp == NULL ) goto failed ;","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( argtypes , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""argtypes\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType"" ) ;return 1 ;tmp = _PyObject_GetAttrId ( obj , & PyId_returns ) ;if ( tmp == NULL ) goto failed ;",503
681,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;",Py_ssize_t i ;,503
682,"stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;","stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;}int res ;res = obj2ast_expr ( tmp , & returns , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}* out = Suite ( body , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}PyErr_Format ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite"" ) ;return 1 ;",503
683,int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;,int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;,504
684,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,504
685,"iwl_sta_ucode_activate ( priv , sta_id ) ;ret = 0 ;","ret = iwl_sta_ucode_activate ( priv , sta_id ) ;",505
686,"log_file = NULL ;}if ( ! name ) return ;file_name = make_file_name ( name , prog , namespace , instance ) ;log_file = fopen ( file_name , ""a"" ) ;if ( log_file ) {","log_file = fopen_safe ( file_name , ""a"" ) ;if ( log_file ) {",506
687,},"assert_regexp_syntax_error ( ""\\\\\\\\x0"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\xxy"" ) ;}",507
688,"if ( hashbin -> hb_type & HB_LOCK ) {spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ;}queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;while ( queue ) {if ( free_func )  ( * free_func ) ( queue ) ;queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;}}hashbin -> hb_current = NULL ;hashbin -> magic = ~ HB_MAGIC ;if ( hashbin -> hb_type & HB_LOCK ) {spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP  hashbin_lock_depth -- ;","if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ;while ( 1 ) {queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;if ( ! queue ) break ;if ( free_func ) {if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;free_func ( queue ) ;if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP hashbin_lock_depth -- ;",508
689,"err = security_sb_remount ( sb , data ) ;if ( err ) return err ;","if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) {return - EPERM ;}err = security_sb_remount ( sb , data ) ;if ( err ) return err ;",509
690,"int copied , err ;struct sockaddr_ll * sll ;","int copied , err ;",510
691,"sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;if ( sock -> type == SOCK_PACKET )  msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;else  msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name )  memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa ,  msg -> msg_namelen ) ;if ( pkt_sk ( sk ) -> auxdata ) {","copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name ) {if ( sock -> type == SOCK_PACKET ) {msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;}else {struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;}memcpy ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ;}if ( pkt_sk ( sk ) -> auxdata ) {",510
692,uchar buf [ RAS_MAGICLEN ] ;int i ;,jas_uchar buf [ RAS_MAGICLEN ] ;int i ;,511
693,if ( serial -> num_ports < 2 )  return - 1 ;,if ( serial -> num_bulk_out < 2 ) return - 1 ;,512
694,"int do_rf64 = 0 , write_junk = 1 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;JunkChunk junkchunk ;","int do_rf64 = 0 , write_junk = 1 , table_length = 0 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;CS64Chunk cs64_chunk ;JunkChunk junkchunk ;",513
695,"if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;","total_riff_bytes += table_length * sizeof ( CS64Chunk ) ;if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;",513
696,ds64hdr . ckSize = sizeof ( ds64_chunk ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;riffhdr . ckSize = ( uint32_t ) - 1 ;,ds64hdr . ckSize = sizeof ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;ds64_chunk . tableLength = table_length ;riffhdr . ckSize = ( uint32_t ) - 1 ;,513
697,"WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {","if ( table_length ) {strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ;cs64_chunk . chunkSize64 = 12345678 ;WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ;}WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}if ( ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {",513
698,"if ( MSG_CMSG_COMPAT & flags ) {if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ;else {err = copy_msghdr_from_user ( msg_sys , msg ) ;if ( err ) return err ;}if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) {err = - EMSGSIZE ;if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ;err = - ENOMEM ;iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ;if ( ! iov ) goto out ;}uaddr = ( __force void __user * ) msg_sys -> msg_name ;uaddr_len = COMPAT_NAMELEN ( msg ) ;if ( MSG_CMSG_COMPAT & flags ) {err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;}else  err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;","if ( MSG_CMSG_COMPAT & flags ) err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;else err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ;msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ;msg_sys -> msg_namelen = 0 ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;",514
699,"struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;u64 bn , dblock = 0 ;const unsigned end_of_metadata = height - 1 ;int eob = 0 ;","struct super_block * sb = sdp -> sd_vfs ;struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;u64 bn , dblock = 0 ;const unsigned end_of_metadata = height - 1 ;int ret ;int eob = 0 ;",515
700,"
","if ( buffer_zeronew ( bh_map ) ) {ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ;if ( ret ) {fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\\clear_buffer_zeronew ( bh_map ) ;}}",515
701,break ;},break ;},515
702,"fprintf ( stderr , ""Codec:<S2SV_blank>%s\\\fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\\}SHOW ( g_timebase . num ) ;SHOW ( g_timebase . den ) ;SHOW ( rc_resize_allowed ) ;SHOW ( rc_resize_up_thresh ) ;","fprintf ( stderr , ""Codec:<S2SV_blank>%s\\\fprintf ( stderr , ""Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\\}SHOW ( g_bit_depth ) ;SHOW ( g_input_bit_depth ) ;SHOW ( g_timebase . num ) ;SHOW ( g_timebase . den ) ;SHOW ( rc_resize_allowed ) ;SHOW ( rc_scaled_width ) ;SHOW ( rc_scaled_height ) ;SHOW ( rc_resize_up_thresh ) ;",516
703,"
",{BOOL rc ;,517
704,"PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data )   nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data )  PROFILER_ENTER ( context -> priv -> prof_nsc_decode )   context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode )  if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;","PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) rc = nsc_rle_decompress_data ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ;}{BOOL rc ;PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) rc = context -> decode ( context ) ;PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) if ( ! rc ) return FALSE ;}if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ;",517
705,else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) &&  ( target -> doc -> dict == ctxt -> dict ) )  {,"else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) && ( target -> doc -> dict == ctxt -> dict ) && xmlDictOwns ( ctxt -> dict , value ) ) {",518
706,"if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;}else {}}free ( fname ) ;}else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) {if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( fname , & s ) == 0 ) return ;if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ;}else {FILE * fp = fopen ( fname , ""w"" ) ;if ( fp ) {fprintf ( fp , ""\\\SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ;fclose ( fp ) ;}}","copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;}else {else {touch_file_as_user ( fname , u , g , 0644 ) ;}}",519
707,"if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ;}free ( fname ) ;","if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) {fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ;}free ( fname ) ;",519
708,"static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req ,  size_t * acl_len )  {__be32 * savep ;uint32_t attrlen , bitmap [ 3 ] = {* acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 )  goto out ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;recvd = req -> rq_rcv_buf . len - hdrlen ;dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr""  ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\* acl_len = attrlen ;}","static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , struct nfs_getaclres * res ) {__be32 * savep , * bm_p ;uint32_t attrlen , bitmap [ 3 ] = {res -> acl_len = 0 ;if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) goto out ;bm_p = xdr -> p ;if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ;xdr -> p = bm_p ;res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ;res -> acl_data_offset <<= 2 ;hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ;attrlen += res -> acl_data_offset ;recvd = req -> rq_rcv_buf . len - hdrlen ;if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) {res -> acl_len = attrlen ;goto out ;}dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\\res -> acl_len = attrlen ;}",520
709,if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {},if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) {}else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) {return false ;},521
710,"assert ( msix_tab_size % 4096 == 0 ) ;bzero ( msixcap , sizeof ( struct msixcap ) ) ;","bzero ( msixcap , sizeof ( struct msixcap ) ) ;",522
711,when = timespec_to_ns ( new_setting -> it_value ) ;period = timespec_to_ns ( new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( n ) ;if ( when > now ) when -= now ;,when = timespec_to_ns ( & new_setting -> it_value ) ;period = timespec_to_ns ( & new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( & n ) ;if ( when > now ) when -= now ;,523
712,"if ( ! js_regexec ( re -> prog , text , & m , 0 ) )  js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;","if ( ! js_doregexec ( J , re -> prog , text , & m , 0 ) ) js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;",524
713,"case OFreshOID :  if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 )  caml_set_oo_id ( ( value ) dest ) ;","case OFreshOID : if ( Long_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) caml_set_oo_id ( ( value ) dest ) ;",525
714,"struct range * range ;struct evbuffer * evb = NULL ;size_t content_length ;int code = 500 , fd = - 1 , i , nranges , ret ;uint32_t boundary ;if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) {code = 416 ;if ( ( evb = evbuffer_new ( ) ) == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ;goto abort ;}( void ) snprintf ( content_range , sizeof ( content_range ) ,  ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;content_length = range -> end - range -> start + 1 ;if ( buffer_add_range ( fd , evb , range ) == 0 )  goto abort ;content_length = 0 ;boundary = arc4random ( ) ;-%ud\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\\\r\\\range ++ ;}if ( ( i = evbuffer_add_printf ( evb , ""\\\\r\\\-%ud--\\\\r\\\content_length += i ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) ,  ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ;media = & multipart_media ;-%llu--\\\\r\\\close ( fd ) ;fd = - 1 ;case 0 :  goto done ;default : break ;if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 )  goto fail ;bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ;if ( clt -> clt_persist )  clt -> clt_toread = TOREAD_HTTP_HEADER ;else clt -> clt_toread = TOREAD_HTTP_NONE ;clt -> clt_done = 0 ;done : evbuffer_free ( evb ) ;server_reset_http ( clt ) ;abort :  if ( evb != NULL )  evbuffer_free ( evb ) ;","struct range_data * r = & clt -> clt_ranges ;struct range * range ;size_t content_length = 0 ;int code = 500 , fd = - 1 , i , nranges , ret ;if ( ( nranges = parse_ranges ( clt , range_str , st -> st_size ) ) < 1 ) {code = 416 ;r -> range_media = media ;range = & r -> range [ 0 ] ;( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;range = & r -> range [ 0 ] ;content_length += range -> end - range -> start + 1 ;content_length = 0 ;boundary = arc4random ( ) ;content_length += ret + range -> end , st -> st_size ) ) == - 1 ) goto abort ;range ++ ;}if ( ( ret = snprintf ( NULL , 0 , ""\\\\r\\\content_length += ret ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary ) ;media = & multipart_media ;r -> range_toread = TOREAD_HTTP_RANGE ;case 0 : close ( fd ) ;goto done ;default : break ;}clt -> clt_fd = fd ;if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ;clt -> clt_srvbev_throttled = 0 ;clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ;if ( clt -> clt_srvbev == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ;goto fail ;bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ;bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ;bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ;bufferevent_disable ( clt -> clt_bev , EV_READ ) ;done : server_reset_http ( clt ) ;abort : if ( evb != NULL ) evbuffer_free ( evb ) ;",526
715,"ier = ksz8851ReadReg ( interface , KSZ8851_REG_IER ) ;ksz8851WriteReg ( interface , KSZ8851_REG_IER , 0 ) ;isr = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ;if ( ( isr & ISR_LCIS ) != 0 ) {ier &= ~ IER_LCIE ;interface -> nicEvent = TRUE ;if ( ( isr & ISR_TXIS ) != 0 )  {ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_TXIS ) ;n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ;if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) {if ( ( isr & ISR_RXIS ) != 0 )  {ier &= ~ IER_RXIE ;interface -> nicEvent = TRUE ;ksz8851WriteReg ( interface , KSZ8851_REG_IER , ier ) ;return flag ;","ier = ksz8851ReadReg ( interface , KSZ8851_IER ) ;ksz8851WriteReg ( interface , KSZ8851_IER , 0 ) ;isr = ksz8851ReadReg ( interface , KSZ8851_ISR ) ;if ( ( isr & KSZ8851_ISR_LCIS ) != 0 ) {ier &= ~ KSZ8851_IER_LCIE ;interface -> nicEvent = TRUE ;if ( ( isr & KSZ8851_ISR_TXIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS ) ;n = ksz8851ReadReg ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA ;if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) {if ( ( isr & KSZ8851_ISR_RXIS ) != 0 ) {ier &= ~ KSZ8851_IER_RXIE ;interface -> nicEvent = TRUE ;ksz8851WriteReg ( interface , KSZ8851_IER , ier ) ;return flag ;",527
716,"static void encode_quantization ( VP9_COMMON * cm ,   struct vp9_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ;write_delta_q ( wb , cm -> y_dc_delta_q ) ;","static void encode_quantization ( const VP9_COMMON * const cm , struct vp9_write_bit_buffer * wb ) {vpx_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ;write_delta_q ( wb , cm -> y_dc_delta_q ) ;",528
717,}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,}else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) && c -> format != CHUNKY ) {if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ;,529
718,"if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 )  {","if ( TEMP_FAILURE_RETRY ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) ) < 0 ) {",530
719,return tmp ;}return tmp ;}return state -> ptr = tmp ;},goto softfail ;}goto softfail ;}softfail : state -> offset = 0 ;return state -> ptr = tmp ;},531
720,struct fb_vblank vblank ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;,"struct fb_vblank vblank ;memset ( & vblank , 0 , sizeof ( vblank ) ) ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;",532
721,"static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags )  {if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {}else if ( ctx -> might_cancel ) {timerfd_remove_cancel ( ctx ) ;}","static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) {spin_lock ( & ctx -> cancel_lock ) ;if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {else {__timerfd_remove_cancel ( ctx ) ;}spin_unlock ( & ctx -> cancel_lock ) ;}",533
722,"
","if ( c16 -> Curves [ i ] == NULL ) {for ( j = 0 ;j < i ;j ++ ) {_cmsFree ( ContextID , c16 -> Curves [ j ] ) ;}_cmsFree ( ContextID , c16 -> Curves ) ;_cmsFree ( ContextID , c16 ) ;return NULL ;}",534
723,"c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {","c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {",534
724,"if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;","if ( ! dev_name || kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;",535
725,"isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return ( 1 ) ;","isoclns_print ( ndo , p + 1 , length - 1 ) ;return ( 1 ) ;",536
726,"struct tmComResBusInfo * bus = & dev -> bus ;u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ;struct tmComResInfo msg_tmp ;int ret = SAA_ERR_BAD_PARAMETER ;saa7164_bus_verify ( dev ) ;if ( msg == NULL ) return ret ;if ( msg -> size > dev -> bus . m_wMaxReqSize ) {printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\\return ret ;}if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) {printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\\return ret ;}mutex_lock ( & bus -> lock ) ;curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ;curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ;if ( curr_gwp == curr_grp ) {ret = SAA_ERR_EMPTY ;goto out ;}bytes_to_read = sizeof ( * msg ) ;write_distance = 0 ;if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ;else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ;if ( bytes_to_read > write_distance ) {printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\\ret = SAA_ERR_INVALID_COMMAND ;goto out ;}new_grp = curr_grp + bytes_to_read ;if ( new_grp > bus -> m_dwSizeGetRing ) {new_grp -= bus -> m_dwSizeGetRing ;space_rem = bus -> m_dwSizeGetRing - curr_grp ;memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ;}else {memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ;}msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ;msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ;msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ;if ( peekonly ) {memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ;goto peekout ;",goto peekout ;,537
727,"memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing ,  sizeof ( * msg ) - space_rem ) ;if ( buf )  memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) -  space_rem , buf_size ) ;}memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;","memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ;memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , sizeof ( * msg ) - space_rem ) ;if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ;}memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;",537
728,"memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ;if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ;msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ;msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ;msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ;","memcpy_fromio ( msg , bus -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ;}else if ( space_rem == sizeof ( * msg ) ) {if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ;memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ;",537
729,"RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}","if ( new_len > INT_MAX ) {efree ( replaced ) ;RETURN_FALSE ;}RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}",538
730,"if ( peerkey && ! EVP_PKEY_cmp ( peerkey , localkey ) ) {log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ;","if ( peerkey && EVP_PKEY_cmp ( peerkey , localkey ) != 1 ) {log_debug ( ""%s:<S2SV_blank>public<S2SV_blank>key<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>%s"" , __func__ , file ) ;",539
731,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",540
732,"static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col ,  BLOCK_SIZE bsize , BLOCK_SIZE subsize ) {MACROBLOCKD * xd = & x -> e_mbd ;int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ;assert ( bsize >= BLOCK_8X8 ) ;case PARTITION_NONE :  set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;case PARTITION_VERT :  * get_sb_index ( x , subsize ) = 0 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ;}case PARTITION_HORZ :  * get_sb_index ( x , subsize ) = 0 ;set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;set_modeinfo_offsets ( cm , xd , mi_row + hbs , mi_col ) ;* ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ;}case PARTITION_SPLIT :  * get_sb_index ( x , subsize ) = 0 ;fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 1 ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 2 ;fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize ,  * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 3 ;break ;default : break ;","static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {MACROBLOCKD * xd = & x -> e_mbd ;int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ;PARTITION_TYPE partition = pc_tree -> partitioning ;BLOCK_SIZE subsize = get_subsize ( bsize , partition ) ;assert ( bsize >= BLOCK_8X8 ) ;case PARTITION_NONE : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> none . mic ;* ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;case PARTITION_VERT : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 0 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , subsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , subsize ) ;}case PARTITION_HORZ : set_mode_info_offsets ( cm , x , xd , mi_row , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 0 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , subsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ;* ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . mic ;* ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ;duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , subsize ) ;}case PARTITION_SPLIT : {fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize , * ( get_sb_partitioning ( x , subsize ) ) ) ;* get_sb_index ( x , subsize ) = 1 ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 0 ] ) ;fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) ;fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) ;break ;}default : break ;",541
733,free ( name ) ;return 0 ;,"if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;free ( name ) ;return 0 ;",542
734,int pixel_ptr = 0 ;int block_ptr ;,int pixel_ptr = - 4 ;int block_ptr ;,543
735,ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,ADVANCE_BLOCK ( ) ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
736,ADVANCE_BLOCK ( ) ;},},543
737,block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
738,ADVANCE_BLOCK ( ) ;}block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,}ADVANCE_BLOCK ( ) ;block_ptr = row_ptr + pixel_ptr ;for ( pixel_y = 0 ;,543
739,ADVANCE_BLOCK ( ) ;break ;,break ;,543
740,int n ;assert ( cnt >= 0 ) ;,ssize_t n ;assert ( cnt >= 0 ) ;,544
741,__be16 type ;off = skb_gro_offset ( skb ) ;,__be16 type ;if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ;NAPI_GRO_CB ( skb ) -> encap_mark = 1 ;off = skb_gro_offset ( skb ) ;,545
742,if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,if ( numrows < 0 || numcols < 0 ) {return 0 ;}if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,546
743,"rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) ,  & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;","rval = tpm_kdfa ( session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;",547
744,"ret = key_permission ( key_ref , KEY_NEED_READ ) ;if ( ret == 0 ) goto can_read_key ;","if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}ret = key_permission ( key_ref , KEY_NEED_READ ) ;if ( ret == 0 ) goto can_read_key ;",548
745,if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  {,if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) {ps_dec -> u4_slice_start_code_found = 0 ;,549
746,if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) {if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T )  || ( ret == ERROR_UNAVAIL_MVBUF_T ) )  {,if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) {if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) {,549
747,dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {,if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {,550
748,"
","switch ( rc ) {case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) {CIFSSMBClose ( xid , pTcon , fileHandle ) ;break ;}case - ENOENT : posix_open = true ;case - EOPNOTSUPP : break ;default : pTcon -> broken_posix_open = true ;}}if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ;}else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ;",551
749,"if ( ( rc == 0 ) || ( rc == - ENOENT ) )  posix_open = true ;else if ( ( rc == - EINVAL ) || ( rc != - EOPNOTSUPP ) ) pTcon -> broken_posix_open = true ;}if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ;}else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ;","
",551
750,"
","rc = PTR_ERR ( filp ) ;CIFSSMBClose ( xid , pTcon , fileHandle ) ;goto lookup_out ;}cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ;if ( cfile == NULL ) {fput ( filp ) ;CIFSSMBClose ( xid , pTcon , fileHandle ) ;rc = - ENOMEM ;goto lookup_out ;}}renew_parental_timestamps ( direntry ) ;}else if ( rc == - ENOENT ) {",551
751,"info . flags = VFIO_DEVICE_FLAGS_PCI ;if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ;info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ;info . num_irqs = VFIO_PCI_NUM_IRQS ;return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) {struct pci_dev * pdev = vdev -> pdev ;struct vfio_region_info info ;struct vfio_info_cap caps = {. buf = NULL , . size = 0 };int i , ret ;minsz = offsetofend ( struct vfio_region_info , offset ) ;if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( info . argsz < minsz ) return - EINVAL ;switch ( info . index ) {case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = pdev -> cfg_size ;info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;break ;case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = pci_resource_len ( pdev , info . index ) ;if ( ! info . size ) {info . flags = 0 ;break ;}info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;if ( vdev -> bar_mmap_supported [ info . index ] ) {info . flags |= VFIO_REGION_INFO_FLAG_MMAP ;if ( info . index == vdev -> msix_bar ) {ret = msix_sparse_mmap_cap ( vdev , & caps ) ;if ( ret ) return ret ;}}case VFIO_PCI_ROM_REGION_INDEX : {void __iomem * io ;size_t size ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . flags = 0 ;info . size = pci_resource_len ( pdev , info . index ) ;if ( ! info . size ) {if ( pdev -> resource [ PCI_ROM_RESOURCE ] . flags & IORESOURCE_ROM_SHADOW ) info . size = 0x20000 ;else break ;}io = pci_map_rom ( pdev , & size ) ;if ( ! io || ! size ) {info . size = 0 ;}pci_unmap_rom ( pdev , io ) ;info . flags = VFIO_REGION_INFO_FLAG_READ ;}case VFIO_PCI_VGA_REGION_INDEX : if ( ! vdev -> has_vga ) return - EINVAL ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = 0xc0000 ;info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ;break ;default : if ( info . index >= VFIO_PCI_NUM_REGIONS + vdev -> num_regions ) return - EINVAL ;i = info . index - VFIO_PCI_NUM_REGIONS ;info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ;info . size = vdev -> region [ i ] . size ;info . flags = vdev -> region [ i ] . flags ;ret = region_type_cap ( vdev , & caps , vdev -> region [ i ] . type , vdev -> region [ i ] . subtype ) ;if ( ret ) return ret ;}if ( caps . size ) {info . flags |= VFIO_REGION_INFO_FLAG_CAPS ;if ( info . argsz < sizeof ( info ) + caps . size ) {info . argsz = sizeof ( info ) + caps . size ;info . cap_offset = 0 ;}else {vfio_info_cap_shift ( & caps , sizeof ( info ) ) ;if ( copy_to_user ( ( void __user * ) arg + sizeof ( info ) , caps . buf , caps . size ) ) {kfree ( caps . buf ) ;return - EFAULT ;}info . cap_offset = sizeof ( info ) ;}kfree ( caps . buf ) ;}return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_GET_IRQ_INFO ) {struct vfio_irq_info info ;minsz = offsetofend ( struct vfio_irq_info , count ) ;if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( info . argsz < minsz || info . index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ;switch ( info . index ) {case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX : case VFIO_PCI_REQ_IRQ_INDEX : break ;case VFIO_PCI_ERR_IRQ_INDEX : if ( pci_is_pcie ( vdev -> pdev ) ) break ;info . flags = VFIO_IRQ_INFO_EVENTFD ;info . count = vfio_pci_get_irq_count ( vdev , info . index ) ;if ( info . index == VFIO_PCI_INTX_IRQ_INDEX ) info . flags |= ( VFIO_IRQ_INFO_MASKABLE | VFIO_IRQ_INFO_AUTOMASKED ) ;else info . flags |= VFIO_IRQ_INFO_NORESIZE ;return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ;}else if ( cmd == VFIO_DEVICE_SET_IRQS ) {struct vfio_irq_set hdr ;u8 * data = NULL ;int ret = 0 ;minsz = offsetofend ( struct vfio_irq_set , count ) ;if ( copy_from_user ( & hdr , ( void __user * ) arg , minsz ) ) return - EFAULT ;if ( hdr . argsz < minsz || hdr . index >= VFIO_PCI_NUM_IRQS ||  hdr . flags & ~ ( VFIO_IRQ_SET_DATA_TYPE_MASK |  VFIO_IRQ_SET_ACTION_TYPE_MASK ) ) return - EINVAL ;if ( ! ( hdr . flags & VFIO_IRQ_SET_DATA_NONE ) ) {size_t size ;int max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL )  size = sizeof ( uint8_t ) ;else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ;else return - EINVAL ;if ( hdr . argsz - minsz < hdr . count * size ||  hdr . start >= max || hdr . start + hdr . count > max )  return - EINVAL ;","max = vfio_pci_get_irq_count ( vdev , hdr . index ) ;if ( hdr . flags & VFIO_IRQ_SET_DATA_BOOL ) size = sizeof ( uint8_t ) ;else if ( hdr . flags & VFIO_IRQ_SET_DATA_EVENTFD ) size = sizeof ( int32_t ) ;else return - EINVAL ;if ( hdr . argsz - minsz < hdr . count * size || hdr . start >= max || hdr . start + hdr . count > max ) return - EINVAL ;switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) {case VFIO_IRQ_SET_DATA_NONE : size = 0 ;case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ;case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ;if ( size ) {if ( hdr . argsz - minsz < hdr . count * size ) return - EINVAL ;",552
752,"if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) {ret = ext4_jbd2_file_inode ( handle , inode ) ;if ( ret ) {unlock_page ( page ) ;put_page ( page ) ;goto errout ;}}","
",553
753,s -> filesize = - 1 ;s -> location = av_strdup ( uri ) ;,s -> filesize = UINT64_MAX ;s -> location = av_strdup ( uri ) ;,554
754,"int opt_size = sizeof ( struct ip_options ) + opt -> optlen ;ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ;if ( ireq -> opt != NULL && ip_options_echo ( ireq -> opt , skb ) ) {kfree ( ireq -> opt ) ;","int opt_size = sizeof ( struct ip_options_rcu ) + opt -> optlen ;ireq -> opt = kmalloc ( opt_size , GFP_ATOMIC ) ;if ( ireq -> opt != NULL && ip_options_echo ( & ireq -> opt -> opt , skb ) ) {kfree ( ireq -> opt ) ;",555
755,"int mutt_b64_decode ( char * out , const char * in )  {","int mutt_b64_decode ( char * out , const char * in , size_t olen ) {",556
756,* out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;len ++ ;* out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;len ++ ;* out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;len ++ ;,if ( len == olen ) return len ;* out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;len ++ ;if ( len == olen ) return len ;* out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;len ++ ;if ( len == olen ) return len ;* out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;len ++ ;,556
757,pinctrl_unregister ( gpio_dev -> pctrl ) ;return 0 ;,return 0 ;,557
758,"size_t copied , len , cur_len ;ssize_t total_written = 0 ;","size_t bytes , copied , len , cur_len ;ssize_t total_written = 0 ;",558
759,"copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it ,  0 , copied ) ;cur_len -= copied ;}cur_len = save_len - cur_len ;wdata -> sync_mode = WB_SYNC_ALL ;","bytes = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , bytes ) ;cur_len -= copied ;if ( copied < bytes ) break ;}cur_len = save_len - cur_len ;if ( ! cur_len ) {for ( i = 0 ;i < nr_pages ;i ++ ) put_page ( wdata -> pages [ i ] ) ;kfree ( wdata ) ;rc = - EFAULT ;break ;}for ( ;nr_pages > i + 1 ;nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) ;wdata -> sync_mode = WB_SYNC_ALL ;",558
760,if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) )  return rdesc ;,if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ;if ( * rsize < 4 ) return rdesc ;,559
761,"int number_of_frames , number_of_keyframes , encode_frame_count ;int i , j ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || si == NULL ) return NULL ;svc_log_reset ( svc_ctx ) ;encode_frame_count = si -> encode_frame_count ;if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ;svc_log ( svc_ctx , SVC_LOG_INFO , ""\\\number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ;for ( i = 0 ;number_of_frames = encode_frame_count ;if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) {number_of_frames -= number_of_keyframes ;}","int number_of_frames ;int i , j ;SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;number_of_frames = si -> psnr_pkt_received ;if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ;svc_log ( svc_ctx , SVC_LOG_INFO , ""\\\for ( i = 0 ;",560
762,"si -> encode_frame_count = 0 ;svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\\","si -> psnr_pkt_received = 0 ;svc_log ( svc_ctx , SVC_LOG_INFO , ""Total<S2SV_blank>Bytes=[%u]\\\",560
763,"static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize )  {","static BOOL nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 outSize , UINT32 originalSize ) {",561
764,* out ++ = value ;left -- ;,if ( outSize < 1 ) return FALSE ;outSize -- ;* out ++ = value ;left -- ;,561
765,"FillMemory ( out , len , value ) ;out += len ;* out ++ = value ;left -- ;* ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ;","if ( outSize < len ) return FALSE ;outSize -= len ;FillMemory ( out , len , value ) ;out += len ;if ( outSize < 1 ) return FALSE ;outSize -- ;* out ++ = value ;left -- ;if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ;memcpy ( out , in , 4 ) ;return TRUE ;",561
766,"if ( screen -> sb_buffer )  vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ;","vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ;",562
767,"static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) {const char * literal_start = * str ;const char * literal_end ;int in_named_escape = 0 ;for ( ;char ch = * * str ;if ( ! in_named_escape && ch == \'{\' && ( * str ) - literal_start >= 2 &&  * ( * str - 2 ) == \'\\\\\\\\\' && * ( * str - 1 ) == \'N\' ) {in_named_escape = 0 ;}if ( * str + 1 < end && * ( * str + 1 ) == ch ) {literal_end = * str + 1 ;ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\\\'}return - 1 ;break ;}literal_end = * str ;assert ( * str <= end ) ;assert ( * str == end || * * str == \'{done :  if ( literal_start != literal_end ) {if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start ,  literal_end - literal_start ,  NULL , NULL ) ;else * literal = decode_unicode_with_escapes ( c , n , literal_start ,  literal_end - literal_start ) ;if ( ! * literal ) return - 1 ;","static int fstring_find_literal ( const char * s = * str ;const char * literal_start = s ;for ( ;char ch = * * str ;if ( ! in_named_escape && ch == \'{\' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == \'\\\\\\\\\' && * ( * str - 1 ) == \'N\' ) {in_named_escape = 0 ;}if ( * str + 1 < end && * ( * str + 1 ) == ch ) {literal_end = * str + 1 ;ast_error ( c , n , ""f-string:<S2SV_blank>single<S2SV_blank>\\\'}return - 1 ;}break ;literal_end = * str ;assert ( * str <= end ) ;assert ( * str == end || * * str == \'{done : if ( literal_start != literal_end ) {if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ;while ( s < end ) {char ch = * s ++ ;if ( ! * literal ) return - 1 ;",563
768,"static int mem_resize ( jas_stream_memobj_t * m , int bufsize )  {assert ( bufsize >= 0 ) ;JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {","static int mem_resize ( jas_stream_memobj_t * m , size_t bufsize ) {JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\\if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {if ( ! bufsize ) {jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\\}",564
769,"struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ;char * problem_id = NULL ;","struct dump_dir * dd = NULL ;if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ;else dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ;char * problem_id = NULL ;",565
770,"if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) {log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\\\""%s\\\\"";","if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) || ! expr -> action . args ) {log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\\\""%s\\\\"";",566
771,static void pcrypt_free ( struct crypto_instance * inst )  {struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;crypto_drop_aead ( & ctx -> spawn ) ;,static void pcrypt_free ( struct aead_instance * inst ) {struct pcrypt_instance_ctx * ctx = aead_instance_ctx ( inst ) ;crypto_drop_aead ( & ctx -> spawn ) ;,567
772,z ++ )  pixel_value += ( srcptr2 [ z ] << ( 8 * z ) ) ;break ;,z ++ ) pixel_value += ( ( unsigned long ) srcptr2 [ z ] << ( 8 * z ) ) ;break ;,568
773,if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) )  if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;,"if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",569
774,"in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) ;}skip_defrtr : if ( in6_dev -> nd_parms ) {unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ;if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ ) {rtime = ( rtime * HZ ) / 1000 ;if ( rtime < HZ / 10 ) rtime = HZ / 10 ;NEIGH_VAR_SET ( in6_dev -> nd_parms , RETRANS_TIME , rtime ) ;in6_dev -> tstamp = jiffies ;inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ;}rtime = ntohl ( ra_msg -> reachable_time ) ;if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) ) {rtime = ( rtime * HZ ) / 1000 ;if ( rtime < HZ / 10 ) rtime = HZ / 10 ;if ( rtime != NEIGH_VAR ( in6_dev -> nd_parms , BASE_REACHABLE_TIME ) ) {NEIGH_VAR_SET ( in6_dev -> nd_parms , BASE_REACHABLE_TIME , rtime ) ;NEIGH_VAR_SET ( in6_dev -> nd_parms , GC_STALETIME , 3 * rtime ) ;in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ) ;in6_dev -> tstamp = jiffies ;inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ;}}}skip_linkparms : if ( ! neigh ) neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , skb -> dev , 1 ) ;if ( neigh ) {u8 * lladdr = NULL ;if ( ndopts . nd_opts_src_lladdr ) {lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , skb -> dev ) ;if ( ! lladdr ) {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>link-layer<S2SV_blank>address<S2SV_blank>length\\\goto out ;}}neigh_update ( neigh , lladdr , NUD_STALE , NEIGH_UPDATE_F_WEAK_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_OVERRIDE_ISROUTER | NEIGH_UPDATE_F_ISROUTER ) ;if ( ! ipv6_accept_ra ( in6_dev ) ) {ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>accept_ra<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\\goto out ;}# ifdef CONFIG_IPV6_ROUTE_INFO if ( ! in6_dev -> cnf . accept_ra_from_local && ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , NULL , 0 ) ) {ND_PRINTK ( 2 , info , ""RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>router<S2SV_blank>info<S2SV_blank>ignored.\\\goto skip_routeinfo ;}if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri ) {struct nd_opt_hdr * p ;for ( p = ndopts . nd_opts_ri ;p ;p = ndisc_next_option ( p , ndopts . nd_opts_ri_end ) ) {struct route_info * ri = ( struct route_info * ) p ;# ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT && ri -> prefix_len == 0 ) continue ;# endif if ( ri -> prefix_len == 0 && ! in6_dev -> cnf . accept_ra_defrtr ) continue ;if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen ) continue ;rt6_route_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , & ipv6_hdr ( skb ) -> saddr ) ;}}skip_routeinfo : # endif # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) {ND_PRINTK ( 2 , info , ""RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT<S2SV_blank>(interior<S2SV_blank>routes),<S2SV_blank>dev:<S2SV_blank>%s\\\goto out ;}# endif if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi ) {struct nd_opt_hdr * p ;for ( p = ndopts . nd_opts_pi ;p ;p = ndisc_next_option ( p , ndopts . nd_opts_pi_end ) ) {addrconf_prefix_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , ndopts . nd_opts_src_lladdr != NULL ) ;}}if ( ndopts . nd_opts_mtu && in6_dev -> cnf . accept_ra_mtu ) {__be32 n ;u32 mtu ;memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ) ;mtu = ntohl ( n ) ;if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu ) {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>invalid<S2SV_blank>mtu:<S2SV_blank>%d\\\else if ( in6_dev -> cnf . mtu6 != mtu ) {in6_dev -> cnf . mtu6 = mtu ;","if ( in6_dev -> cnf . hop_limit < ra_msg -> icmph . icmp6_hop_limit ;if ( rt ) dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , ra_msg -> icmph . icmp6_hop_limit ) {in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ;else {ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\\",570
775,"static void  l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat )  {const uint16_t * ptr = ( const uint16_t * ) dat ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ;","static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint16_t * ptr = ( const uint16_t * ) dat ;if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ;",571
776,if ( ! replay_esn || ! rp )  return 0 ;if ( xfrm_replay_state_esn_len ( replay_esn ) !=   xfrm_replay_state_esn_len ( up ) )  return - EINVAL ;,int ulen ;if ( ! replay_esn || ! rp ) return 0 ;ulen = xfrm_replay_state_esn_len ( up ) ;if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) return - EINVAL ;,572
777,"int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;","int ret = proc_dointvec_minmax ( table , write , buffer , lenp , ppos ) ;if ( ret || ! write ) return ret ;",573
778,"bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",574
779,"fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ;for ( i = 0 ;i < 3 ;i ++ ) {thissad = sad_array [ i ] ;if ( thissad < bestsad ) {this_mv . as_mv . col = c ;thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride ) ;",574
780,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {",574
781,"l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;if  ( ! l_current_pi -> include ) {","l_current_pi -> include = 00 ;if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}if ( ! l_current_pi -> include ) {",575
782,"return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" ,  name ) ;","return try_then_request_module ( __crypto_lookup_template ( name ) , ""crypto-%s"" , name ) ;",576
783,"int start = 0 ;u32 prev_legacy , cur_legacy ;kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;","int start = 0 ;int i ;u32 prev_legacy , cur_legacy ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , kvm -> arch . vpit -> pit_state . channels [ i ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",577
784,"static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , TOKENEXTRA * * tp ) {VP9_COMMON * cm = & cpi -> common ;MACROBLOCKD * xd = & cpi -> mb . e_mbd ;vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {int dummy_rate = 0 ;int64_t dummy_dist = 0 ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ;MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ;BLOCK_SIZE bsize ;cpi -> mb . source_variance = UINT_MAX ;vp9_zero ( cpi -> mb . pred_mv ) ;switch ( cpi -> sf . partition_search_type ) {case VAR_BASED_PARTITION :  choose_partitioning ( cpi , tile , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case SOURCE_VAR_BASED_PARTITION :  set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case VAR_BASED_FIXED_PARTITION :  case FIXED_PARTITION :  bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ?  cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ;set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,   1 , & dummy_rate , & dummy_dist ) ;break ;case REFERENCE_PARTITION :  if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) {nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 ,   & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ;}else {copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col ,   BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;}}}","static void encode_nonrd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) {SPEED_FEATURES * const sf = & cpi -> sf ;VP9_COMMON * const cm = & cpi -> common ;TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;memset ( & xd -> left_context ) ) ;memset ( xd -> left_seg_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile_info -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {const struct segmentation * const seg = & cm -> seg ;RD_COST dummy_rdc ;MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ;PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type ;BLOCK_SIZE bsize ;cpi -> mb . source_variance = UINT_MAX ;vp9_zero ( x -> pred_mv ) ;switch ( cpi -> sf . partition_search_type ) {case VAR_BASED_PARTITION : choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ;nonrd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;break ;case SOURCE_VAR_BASED_PARTITION : set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ;break ;case VAR_BASED_FIXED_PARTITION : case FIXED_PARTITION : bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ? cpi -> sf . always_this_block_size : get_nonrd_var_based_fixed_partition ( cpi , tile_info , x , mi , mi_row , mi_col , bsize ) ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;break ;case REFERENCE_PARTITION : if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) {nonrd_pick_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ;}break ;}}",578
785,"pipe_buf_get ( ipipe , ibuf ) ;obuf = opipe -> bufs + nbuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}obuf = opipe -> bufs + nbuf ;",579
786,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;BUG_ON ( dh == NULL ) ;","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;BUG_ON ( dh == NULL ) ;",580
787,"Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL )  return HTTP_UNAUTHORIZED ;}","# ifdef UPNP_ENABLE_POST_WRITE Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL ) return HTTP_UNAUTHORIZED ;# else return HTTP_NOT_FOUND ;# endif }",581
788,"char * dir = ""/etc"" ;if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;","if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) {ulckpwdf ( ) ;",582
789,if ( IS_ERR ( blkg ) ) {blkg_free ( new_blkg ) ;return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,if ( IS_ERR ( blkg ) ) return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,583
790,if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,if ( bpp == 1 && buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,584
791,if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( bpp == 8 && pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,584
792,"krb5_data rspac ;const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ;","krb5_data rspac ;const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ;const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ;",585
793,"ret = krb5_unparse_name ( context , cp , & cpn ) ;","ret = krb5_unparse_name ( context , cp , tgt_realm , & cpn ) ;",585
794,"ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp ,  krbtgt_out ,  tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ;","ret = tgs_make_reply ( context , config , b , tp , tgt , replykey , rk_is_subkey , ekey , & sessionkey , kvno , * auth_data , server , rsp , spn , client , cp , krbtgt_out , tkey_sign -> key . keytype , spp , & rspac , & enc_pa_data , e_text , reply ) ;",585
795,"cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;","nd -> last_type = LAST_BIND ;cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;",586
796,"struct usbdevfs_connectinfo ci = {. devnum = ps -> dev -> devnum ,  . slow = ps -> dev -> speed == USB_SPEED_LOW  };if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;","struct usbdevfs_connectinfo ci ;memset ( & ci , 0 , sizeof ( ci ) ) ;ci . devnum = ps -> dev -> devnum ;ci . slow = ps -> dev -> speed == USB_SPEED_LOW ;if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;",587
797,"static int ip_options_get_finish ( struct net * net , struct ip_options * * optp ,   struct ip_options * opt , int optlen )  {while ( optlen & 3 )  opt -> __data [ optlen ++ ] = IPOPT_END ;opt -> optlen = optlen ;if ( optlen && ip_options_compile ( net , opt , NULL ) ) {kfree ( opt ) ;","static int ip_options_get_finish ( struct net * net , struct ip_options_rcu * * optp , struct ip_options * opt , int optlen ) {while ( optlen & 3 ) opt -> opt . __data [ optlen ++ ] = IPOPT_END ;opt -> opt . optlen = optlen ;if ( optlen && ip_options_compile ( net , & opt -> opt , NULL ) ) {kfree ( opt ) ;",588
798,"}retval = xfs_attr3_leaf_add ( bp , args ) ;","args -> rmtvaluelen2 = args -> rmtvaluelen ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;args -> rmtvaluelen = 0 ;}retval = xfs_attr3_leaf_add ( bp , args ) ;",589
799,if ( args -> rmtblkno ) {error = xfs_attr_rmtval_remove ( args ) ;,args -> rmtvaluelen = args -> rmtvaluelen2 ;if ( args -> rmtblkno ) {error = xfs_attr_rmtval_remove ( args ) ;,589
800,ACCESS_MASK access = FILE_READ_ATTRIBUTES ;,"size_t devicePathLen = 0 ;if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\\\\\Device\\\\\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) {byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ;if ( ! readBuffer ) {Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ;Irp -> IoStatus . Information = 0 ;}else {Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;break ;}",590
801,"
",if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) {,590
802,"
",Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;}TCfree ( readBuffer ) ;}}else {,590
803,"byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) )  {","byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , sizeof ( readBuffer ) , & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) ) {",590
804,Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},590
805,if ( connection == NULL )  goto error ;,if ( connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE ) goto error ;,591
806,"uint16 nif = 0 ;if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) {","uint32 replylen ;uint16 nif = 0 ;if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) {",592
807,"for ( d = alldevs ;d = d -> next )  {if ( d -> description )  plen += strlen ( d -> description ) ;if ( d -> name )  plen += strlen ( d -> name ) ;plen += sizeof ( struct rpcap_findalldevs_if ) ;for ( address = d -> addresses ;case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif  plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ;break ;rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver ,  RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ;for ( d = alldevs ;","replylen = 0 ;for ( d = alldevs ;d = d -> next ) {if ( d -> description ) replylen += strlen ( d -> description ) ;if ( d -> name ) replylen += strlen ( d -> name ) ;replylen += sizeof ( struct rpcap_findalldevs_if ) ;for ( address = d -> addresses ;case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif replylen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ;break ;rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_FINDALLIF_REPLY , nif , replylen ) ;for ( d = alldevs ;",592
808,"struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ;if ( ! dd ) {","struct dump_dir * dd = dd_create ( path , g_settings_privatereports ? 0 : client_uid , DEFAULT_DUMP_DIR_MODE ) ;if ( ! dd ) {",593
809,x += 8 ) {for ( bit = 0 ;bit < 8 ;bit ++ ) {,x += 4 ) {,594
810,for ( x = 0 ;x += 2 )  {,for ( x = 0 ;x += 2 ) {,594
811,"BN_ULONG t1 , t2 ;BN_ULONG c1 , c2 , c3 ;","BN_ULONG c1 , c2 , c3 ;",595
812,"static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk ,  int tstype )  {int err ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {","static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , int tstype , bool opt_stats ) {int err ;BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;serr -> opt_stats = opt_stats ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {",596
813,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",597
814,"if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue )  {","if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) {",597
815,"if ( in_cksum ( vec , 1 ) )  ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" ,  EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;}","if ( in_cksum ( vec , 1 ) ) {ND_TCHECK_16BITS ( & bp [ 6 ] ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)"" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ;}}",598
816,"
","run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ;",599
817,"run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;","run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ;",599
818,"if ( same_thread_group ( task , current ) ) return 0 ;rcu_read_lock ( ) ;tcred = __task_cred ( task ) ;if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ;if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ;ok : rcu_read_unlock ( ) ;smp_rmb ( ) ;if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ;rcu_read_lock ( ) ;if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {rcu_read_unlock ( ) ;return - EPERM ;","if ( dumpable != SUID_DUMP_USER && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {",600
819,for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,601
820,"if ( flags & __GFP_ZERO )  memset ( addr , 0 , size ) ;","memset ( addr , 0 , size ) ;",602
821,int i ;int j ;int rowstep ;if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) {,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) {,603
822,"
","if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) {for ( i = 0 ;i < u4_payload_size / 4 ;i ++ ) {ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ;}ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ;}else {",604
823,"ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;break ;","ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ;}break ;",604
824,"ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec ,   u4_payload_size ) ;break ;","if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) {for ( i = 0 ;i < u4_payload_size / 4 ;i ++ ) {ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ;}ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ;}else {ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , u4_payload_size ) ;}break ;",604
825,"priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;","if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) {dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\\return - ENODEV ;}priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;",605
826,"if ( ret < 0 ) goto bail ;if ( ret < 0 )  goto bail ;dd -> sdma_rht = tmp_sdma_rht ;dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\\","if ( ret < 0 ) {kfree ( tmp_sdma_rht ) ;goto bail ;}if ( ret < 0 ) goto bail ;dd -> sdma_rht = tmp_sdma_rht ;dd_dev_info ( dd , ""SDMA<S2SV_blank>num_sdma:<S2SV_blank>%u\\\",606
827,put_device ( & dev -> dev ) ;return 0 ;,cancel_autoload_drivers ( ) ;put_device ( & dev -> dev ) ;return 0 ;,607
828,"int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  {","int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick , my_bool no_copy_stat ) {",608
829,"if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {mi_check_print_error ( param , ""Can\\\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\\\'%s\\\'"" , param -> temp_filename ) ;goto err ;}if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ;if ( param -> testflag & T_UNPACK ) {share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;mi_int2store ( share -> state . header . options , share -> options ) ;}share -> state . dellink = HA_OFFSET_ERROR ;info -> rec_cache . file = new_file ;}info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;mi_drop_all_indexes ( param , info , FALSE ) ;key_map = share -> state . key_map ;if ( param -> testflag & T_CREATE_MISSING_KEYS ) {key_map = ~ key_map ;}sort_info . info = info ;sort_info . param = param ;set_data_file_type ( & sort_info , share ) ;sort_info . dupp = 0 ;sort_info . buff = 0 ;param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ;if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ;else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ;else rec_length = share -> base . pack_reclength ;sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ;del = info -> state -> del ;param -> glob_crc = 0 ;max_pack_reclength = share -> base . pack_reclength ;if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ;if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) {mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>key!"" ) ;goto err ;}total_key_length = 0 ;rec_per_key_part = param -> rec_per_key_part ;info -> state -> records = info -> state -> del = share -> state . split = 0 ;info -> state -> empty = 0 ;for ( i = key = 0 , istep = 1 ;key < share -> base . keys ;rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) {sort_param [ i ] . key = key ;sort_param [ i ] . keyinfo = share -> keyinfo + key ;sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ;if ( ! mi_is_key_active ( key_map , key ) ) {memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;istep = 0 ;continue ;}istep = 1 ;if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\\if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) {sort_param [ i ] . key_read = sort_ft_key_read ;sort_param [ i ] . key_write = sort_ft_key_write ;}else {sort_param [ i ] . key_read = sort_key_read ;sort_param [ i ] . key_write = sort_key_write ;}sort_param [ i ] . key_cmp = sort_key_cmp ;sort_param [ i ] . lock_in_memory = lock_memory ;sort_param [ i ] . tmpdir = param -> tmpdir ;sort_param [ i ] . sort_info = & sort_info ;sort_param [ i ] . master = 0 ;sort_param [ i ] . fix_datafile = 0 ;sort_param [ i ] . calc_checksum = 0 ;sort_param [ i ] . filepos = new_header_length ;sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ;sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ;if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) {mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory!"" ) ;goto err ;}sort_param [ i ] . key_length = share -> rec_reflength ;for ( keyseg = sort_param [ i ] . seg ;keyseg -> type != HA_KEYTYPE_END ;keyseg ++ ) {sort_param [ i ] . key_length += keyseg -> length ;if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ;if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ;if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ;}total_key_length += sort_param [ i ] . key_length ;if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) {uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ;sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ;init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ;}}sort_info . total_keys = i ;sort_param [ 0 ] . master = 1 ;sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ;sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ;if ( ! ftparser_alloc_param ( info ) ) goto err ;sort_info . got_error = 0 ;mysql_mutex_lock ( & sort_info . mutex ) ;if ( i > 1 ) {if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ;else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ;}else io_share . total_threads = 0 ;( void ) pthread_attr_init ( & thr_attr ) ;( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ;for ( i = 0 ;i < sort_info . total_keys ;i ++ ) {sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ;DBUG_PRINT ( ""io_cache_share"" , ( ""thread:<S2SV_blank>%u<S2SV_blank><S2SV_blank>read_cache:<S2SV_blank>0x%lx"" , i , ( long ) & sort_param [ i ] . read_cache ) ) ;sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ;# else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ;# endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) {mi_check_print_error ( param , ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread<S2SV_blank>(errno=<S2SV_blank>%d)"" , error ) ;if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ;DBUG_PRINT ( ""error"" , ( ""Cannot<S2SV_blank>start<S2SV_blank>a<S2SV_blank>repair<S2SV_blank>thread"" ) ) ;sort_info . got_error = 1 ;}else sort_info . threads_running ++ ;}( void ) pthread_attr_destroy ( & thr_attr ) ;while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ;mysql_mutex_unlock ( & sort_info . mutex ) ;if ( ( got_error = thr_write_keys ( sort_param ) ) ) {param -> retry_repair = 1 ;goto err ;}got_error = 1 ;if ( sort_param [ 0 ] . fix_datafile ) {if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ;if ( param -> testflag & T_SAFE_REPAIR ) {if ( info -> state -> records + 1 < start_records ) {info -> state -> records = start_records ;goto err ;}}share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ;share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;info -> dfile = new_file ;share -> data_file_type = sort_info . new_data_file_type ;share -> pack . header_length = ( ulong ) new_header_length ;}else info -> state -> data_file_length = sort_param -> max_pos ;if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {mi_check_print_error ( param , ""Couldn\\\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ;mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ;param -> retry_repair = 1 ;param -> testflag |= T_RETRY_WITHOUT_QUICK ;goto err ;}if ( rep_quick & T_FORCE_UNIQUENESS ) {my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ;# ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ;# endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;}if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;if ( ! ( param -> testflag & T_SILENT ) ) {if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\\if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ;}got_error = 0 ;if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;( void ) end_io_cache ( & info -> rec_cache ) ;if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ;if ( ! got_error ) {if ( new_file >= 0 ) {mysql_file_close ( new_file , MYF ( 0 ) ) ;info -> dfile = new_file = - 1 ;if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;","if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;",608
830,if ( p == q || size < 16 || size > 256 )  return ( ( Image * ) NULL ) ;,if ( ( p == q ) || ( size < 16 || size > 256 ) ) return ( ( Image * ) NULL ) ;,609
831,"uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ;nblks += dblocks ;","uint dblocks = xfs_attr3_rmt_blocks ( mp , valuelen ) ;nblks += dblocks ;",610
832,pairs = palloc ( pcount * sizeof ( Pairs ) ) ;for ( i = 0 ;,"if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;pairs = palloc ( pcount * sizeof ( Pairs ) ) ;for ( i = 0 ;",611
833,"ruleaddvar ( r , var , val ) ;if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ;","ruleaddvar ( r , var , val ) ;if ( ! val ) continue ;if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ;",612
834,if ( text [ 1 ] == EOF )  return 0 ;if ( text [ 1 ] == 'x' ) {text [ 2 ] = RE_YY_INPUT ( yyscanner ) ;if ( text [ 2 ] == EOF )  return 0 ;if ( text [ 3 ] == EOF )  return 0 ;,if ( text [ 1 ] == EOF || text [ 1 ] == 0 ) return 0 ;if ( ! isxdigit ( text [ 1 ] == 'x' ) {text [ 2 ] ) ) return 0 ;if ( ! isxdigit ( text [ 3 ] ) ) return 0 ;,613
835,"
","memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;",614
836,c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ;c -> req -> path . len = ( int ) ( path . end - path . start ) ;,c -> req -> path . start = c -> req -> msg + ( path . start - c -> buf ) ;c -> req -> path . len = ( int ) ( path . end - path . start ) ;,614
837,"void vp9_fht16x16_c ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {vp9_fdct16x16_c ( input , output , stride ) ;}int16_t out [ 256 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;int16_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = FHT_16 [ tx_type ] ;++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j )  outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;}","void vp9_fht16x16_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {vpx_fdct16x16_c ( input , output , stride ) ;}tran_low_t out [ 256 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;tran_low_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = FHT_16 [ tx_type ] ;+ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j ) out [ j * stride + i ] * 4 ;+ j )  outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;++ j ) outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;}",615
838,"else if ( g_str_has_prefix ( arg , ""@@"" ) )  g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\\else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;","else if ( g_str_has_prefix ( arg , ""@@"" ) ) {flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s"" ) , arg ) ;goto out ;}else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;",616
839,"if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;if ( error )  goto out_errno ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;","error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;",617
840,"BUG_IF ( tree_root == NULL ) ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;","if ( tree_root == NULL ) return 0 ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;",618
841,"char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ;if ( ! temp_filename ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>filename."" , __func__ ) ;return false ;strcpy ( temp_filename , filename ) ;strcat ( temp_filename , "".new"" ) ;FILE * fp = fopen ( temp_filename , ""wt"" ) ;","int dir_fd = - 1 ;FILE * fp = NULL ;static const char * temp_file_ext = "".new"" ;const int filename_len = strlen ( filename ) ;const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ;char * temp_filename = osi_calloc ( temp_filename_len ) ;snprintf ( temp_filename , temp_filename_len , ""%s%s"" , filename , temp_file_ext ) ;char * temp_dirname = osi_strdup ( filename ) ;const char * directoryname = dirname ( temp_dirname ) ;if ( ! directoryname ) {LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , filename , strerror ( errno ) ) ;goto error ;dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ;if ( dir_fd < 0 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;goto error ;}fp = fopen ( temp_filename , ""wt"" ) ;",619
842,"fprintf ( fp , ""[%s]\\\for ( const list_node_t * enode = list_begin ( section -> entries ) ;fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\\}if ( list_next ( node ) != list_end ( config -> sections ) )  fputc ( \'\\\}fflush ( fp ) ;fclose ( fp ) ;if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) {","if ( fprintf ( fp , ""[%s]\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}for ( const list_node_t * enode = list_begin ( section -> entries ) ;if ( fprintf ( fp , ""%s<S2SV_blank>=<S2SV_blank>%s\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}}if ( list_next ( node ) != list_end ( config -> sections ) ) {if ( fputc ( \'\\\LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}}}if ( fsync ( fileno ( fp ) == EOF ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;goto error ;}if ( fsync ( dir_fd ) < 0 ) {LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;}if ( close ( dir_fd ) < 0 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , directoryname , strerror ( errno ) ) ;goto error ;}fp = NULL ) < 0 ) {LOG_WARN ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\\\'%s\\\':<S2SV_blank>%s"" , __func__ , temp_filename , strerror ( errno ) ) ;}if ( fclose ( fp ) ;if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) {",619
843,osi_free ( temp_filename ) ;return true ;error : ;unlink ( temp_filename ) ;osi_free ( temp_filename ) ;return false ;,osi_free ( temp_filename ) ;osi_free ( temp_dirname ) ;return true ;error : unlink ( temp_filename ) ;if ( fp ) fclose ( fp ) ;if ( dir_fd != - 1 ) close ( dir_fd ) ;osi_free ( temp_filename ) ;osi_free ( temp_dirname ) ;return false ;,619
844,"switch ( pc -> componentType ) {case 1 : if ( pc -> lengthComponentIdent > 0 )  break ;case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ;p = to ;* p ++ = \'/\' ;tolen -- ;break ;case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ;memcpy ( p , ""../"" , 3 ) ;p += 3 ;tolen -= 3 ;break ;case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ;memcpy ( p , ""./"" , 2 ) ;p += 2 ;tolen -= 2 ;break ;case 5 :  comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ;p += comp_len ;tolen -= comp_len ;if ( tolen == 0 ) return - ENAMETOOLONG ;* p ++ = \'/\' ;tolen -- ;elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ;}",elen += sizeof ( struct pathComponent ) ;switch ( pc -> componentType ) {case 1 : if ( pc -> lengthComponentIdent > 0 ) {elen += pc -> lengthComponentIdent ;},620
845,ND_TCHECK ( dp [ 0 ] ) ;,ND_TCHECK ( dp [ 4 ] ) ;,621
846,"ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;dp += 3 ;ND_TCHECK ( dp [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ;","ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] ) ) ) ) ;",621
847,"if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""\\\mgmtd_len = * ( tptr + 3 ) ;if ( mgmtd_len < 1 || mgmtd_len > 32 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ;return ;}fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ;tptr += VTP_HEADER_LEN ;switch ( type ) {case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ;ND_PRINT ( ( ndo , ""\\\tptr += 8 ;ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ;tptr += VTP_UPDATE_TIMESTAMP_LEN ;ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ;tptr += VTP_MD5_DIGEST_LEN ;break ;case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ;tptr += 4 ;while ( tptr < ( pptr + length ) ) {ND_TCHECK_8BITS ( tptr ) ;len = * tptr ;if ( len == 0 ) break ;ND_TCHECK2 ( * tptr , len ) ;vtp_vlan = ( const struct vtp_vlan_ * ) tptr ;ND_TCHECK ( * vtp_vlan ) ;ND_PRINT ( ( ndo , ""\\\fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ;len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;while ( len > 0 ) {type = * tptr ;tlv_len = * ( tptr + 1 ) ;if ( type == 0 || tlv_len == 0 ) {return ;ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;tlv_value = EXTRACT_16BITS ( tptr + 2 ) ;","len -= VTP_VLAN_INFO_FIXED_PART_LEN ;tptr += VTP_VLAN_INFO_FIXED_PART_LEN ;if ( len < 4 * ( ( vtp_vlan -> name_len , NULL ) ;len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += 4 * ( ( vtp_vlan -> name_len , NULL ) ;len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;while ( len > 0 ) {if ( len < 2 ) goto trunc ;ND_TCHECK2 ( * tptr , 2 ) ;if ( tlv_len != 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ;else {type = * tptr ;tlv_len = * ( tptr + 1 ) ;if ( type == 0 || tlv_len == 0 ) {return ;ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;tlv_value = EXTRACT_16BITS ( tptr + 2 ) ;",622
848,len -= 2 + tlv_len * 2 ;tptr += 2 + tlv_len * 2 ;,}len -= 2 + tlv_len * 2 ;tptr += 2 + tlv_len * 2 ;,622
849,"if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData ,  target , NULL ) ;ctxt -> instate = state ;","if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , target , NULL ) ;if ( ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate = state ;",623
850,SKIP_BLANKS ;,if ( SKIP_BLANKS ;,623
851,ctxt -> instate = state ;,ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate = state ;,623
852,ctxt -> instate = state ;},ctxt -> instate = state ;},623
853,bool slow ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,bool slow ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,624
854,"}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",624
855,"u_int tlen , pdu_type , pdu_len ;const u_char * tptr ;const rpki_rtr_pdu * pdu_header ;tptr = pptr ;tlen = len ;while ( tlen >= sizeof ( rpki_rtr_pdu ) ) {ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;","while ( tlen >= sizeof ( rpki_rtr_pdu ) ) {ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;",625
856,"if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) )  goto trunc ;tlen -= pdu_len ;tptr += pdu_len ;}return ;trunc : ND_PRINT ( ( ndo , ""\\\","if ( rpki_rtr_pdu_print ( ndo , pptr , len , 1 , 8 ) ;len -= pdu_len ;tptr += pdu_len ;}",625
857,"s = tcp_recv ( NULL , 4 ) ;if ( s == NULL ) return False ;if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) {logger ( Protocol , Error , ""cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x"" , s -> p [ 0 ] ) ;return False ;if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ;else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ;else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ;else return False ;s = tcp_recv ( s , length ) ;if ( ! ber_in_header ( s , & tagval , & length ) ||  tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ;in_uint8s ( s , length ) ;if ( token ) {if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ;if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ;token -> end = token -> p = token -> data ;out_uint8p ( token , s -> p , length ) ;","struct stream packet ;s = tcp_recv ( NULL , 4 ) ;if ( s == NULL ) return False ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;s_realloc ( token , length ) ;s_reset ( token ) ;out_uint8p ( token , s -> p , length ) ;",626
858,"int chars_processed ;int elt ;int data_size = ndo -> ndo_snapend - bp ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed = 1 ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {","int elt ;u_int offset , max_offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;max_offset = ( u_int ) ( cp - bp ) ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {",627
859,"cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {","offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( offset >= max_offset ) {ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ;return ( NULL ) ;}max_offset = offset ;cp = bp + offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {",627
860,"chars_processed += l ;ND_PRINT ( ( ndo , ""."" ) ) ;chars_processed ++ ;if ( ! compress ) rp += l + 1 ;","ND_PRINT ( ( ndo , ""."" ) ) ;if ( ! compress ) rp += l + 1 ;",627
861,"blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ;error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ;","blkcnt = xfs_attr3_rmt_blocks ( mp , args -> rmtvaluelen ) ;error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ;",628
862,lblkno = args -> rmtblkno ;blkcnt = args -> rmtblkcnt ;valuelen = args -> valuelen ;while ( valuelen > 0 ) {,lblkno = args -> rmtvaluelen ;while ( valuelen > 0 ) {,628
863,"int rv = Socket_print ( S ,  ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\\\r\\\","MD_T token ;StringBuffer_append ( data , ""%ssecuritytoken=%s"" , StringBuffer_length ( data ) > 0 ? ""&"" : """" , Util_getToken ( token ) ) ;int rv = Socket_print ( S , ""POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\\\r\\\",629
864,"pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 )  errExit ( ""chown"" ) ;if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 )  errExit ( ""chmod"" ) ;","copy_file_as_user ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chmod"" ) ;",630
865,if ( rc != BFA_STATUS_OK )  return NULL ;wait_for_completion ( & fcomp . comp ) ;hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ;,if ( rc != BFA_STATUS_OK ) {kfree ( fcstats ) ;return NULL ;}wait_for_completion ( & fcomp . comp ) ;hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ;,631
866,"value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ;value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ;value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ;}","value -> x = MagickMin ( 1.0f , MaxF ( 0.0f , value -> x ) ) ;value -> y = MinF ( 1.0f , MagickMax ( 0.0f , value -> y ) ) ;value -> z = MinF ( 1.0f , MagickMax ( 0.0f , value -> z ) ) ;}",632
867,* head = NULL ;* out = line ;return 0 ;,"giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ;return GIT_ERROR ;",633
868,"if ( check_stack_guard_page ( vma , address ) < 0 )  return VM_FAULT_SIGSEGV ;","if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ;if ( check_stack_guard_page ( vma , address ) < 0 ) return VM_FAULT_SIGSEGV ;",634
869,rec -> sasl_username = src -> sasl_username ;rec -> sasl_password = src -> sasl_password ;* dest = ( SERVER_CONNECT_REC * ) rec ;,rec -> sasl_username = g_strdup ( src -> sasl_username ) ;rec -> sasl_password = g_strdup ( src -> sasl_password ) ;* dest = ( SERVER_CONNECT_REC * ) rec ;,635
870,"struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ;if ( cnt == 1 ) return 0 ;env -> insn_aux_data = new_data ;vfree ( old_data ) ;","struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ;int i ;if ( cnt == 1 ) return 0 ;for ( i = off ;i < off + cnt - 1 ;i ++ ) new_data [ i ] . seen = true ;env -> insn_aux_data = new_data ;vfree ( old_data ) ;",636
871,ND_TCHECK ( dp -> ip6f_offlg ) ;if ( ndo -> ndo_vflag ) {,ND_TCHECK ( * dp ) ;if ( ndo -> ndo_vflag ) {,637
872,"
",ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;,638
873,"ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" ,  EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ;","ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ;",638
874,"vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;","memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;",639
875,"assert ( ( occ0 % rowsize ) == 0 ) ;assert ( sp -> decodepfunc != NULL ) ;( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ;occ0 -= rowsize ;","if ( ( occ0 % rowsize ) != 0 ) {if ( ! TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize<S2SV_blank>!=<S2SV_blank>0"" ) ;return 0 ;}assert ( sp -> decodepfunc != NULL ) ;( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ) return 0 ;occ0 -= rowsize ;",640
876,"size_t i , tcount , o , datao ;if ( ! n || ! buf || ! buf_size ) {","size_t i , tcount , o , datao ;long failsafe_size = 0 ;if ( ! n || ! buf || ! buf_size ) {",641
877,++ tcount ;},"+ tcount ;failsafe_size += mnote_canon_entry_count_values ( & n -> entries [ tcount ] ) ;if ( failsafe_size > FAILSAFE_SIZE_MAX ) {exif_mem_free ( ne -> mem , n -> entries [ tcount ] . data ) ;exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Failsafe<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%ld)"" , failsafe_size , FAILSAFE_SIZE_MAX ) ;break ;}++ tcount ;}",641
878,if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,if ( ctx -> terminated || ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,642
879,kfree ( sbi ) ;},if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;kfree ( sbi ) ;},643
880,"if ( param -> testflag & T_REP_BY_SORT )  error = mi_repair_by_sort ( param , info , filename , rep_quick ) ;else  error = mi_repair_parallel ( param , info , filename , rep_quick ) ;state_updated = 1 ;else if ( param -> testflag & T_REP_ANY )  error = mi_repair ( param , info , filename , rep_quick ) ;}","if ( param -> testflag & T_REP_BY_SORT ) error = mi_repair_by_sort ( param , info , filename , rep_quick , FALSE ) ;else error = mi_repair_parallel ( param , info , filename , rep_quick , FALSE ) ;state_updated = 1 ;}else if ( param -> testflag & T_REP_ANY ) error = mi_repair ( param , info , filename , rep_quick , FALSE ) ;",644
881,"error = mi_repair_by_sort ( param , info , filename , 1 ) ;}if ( ! error && param -> testflag & T_SORT_INDEX )  error = mi_sort_index ( param , info , filename ) ;if ( ! error ) share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ;","error = mi_repair_by_sort ( param , info , filename , 1 , FALSE ) ;}if ( ! error && param -> testflag & T_SORT_INDEX ) error = mi_sort_index ( param , info , filename , FALSE ) ;if ( ! error ) share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ;",644
882,int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ;char * ns = malloc ( alloc ) ;unsigned char in ;int strindex = 0 ;unsigned long hex ;CURLcode res ;if ( ! ns ) return NULL ;,char * str = NULL ;size_t inputlen = length ;size_t outputlen ;CURLcode res ;if ( ! ns ) return NULL ;,645
883,"res = Curl_convert_from_network ( handle , & in , 1 ) ;if ( res ) {free ( ns ) ;return NULL ;}string += 2 ;alloc -= 2 ;}ns [ strindex ++ ] = in ;string ++ ;}ns [ strindex ] = 0 ;if ( olen )  * olen = strindex ;return ns ;","res = Curl_convert_from_network ( handle , string , inputlen , & str , & outputlen , FALSE ) ;if ( res ) return NULL ;if ( olen ) * olen = curlx_uztosi ( outputlen ) ;return str ;",645
884,"RAnalOp next_op ;avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;","RAnalOp next_op = {0 };avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;",646
885,"
","iov_iter_advance ( i , copied ) ;",647
886,"if ( unlikely ( copied == 0 ) ) {bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ;iov_iter_advance ( i , copied ) ;pos += copied ;","if ( unlikely ( copied == 0 ) ) {bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ;pos += copied ;",647
887,if ( unlikely ( len == 0 ) ) {,if ( unlikely ( len + ring -> frameoffset == 0 ) ) {,648
888,if ( unlikely ( len > ring -> rx_buffersize ) ) {int cnt = 0 ;,if ( unlikely ( len > ring -> rx_buffersize ) ) {int cnt = 0 ;,648
889,def -> pdu_free_state_ref = usm_free_usmStateReference ;def -> session_setup = usm_session_init ;,def -> pdu_clone = usm_clone ;def -> pdu_free_state_ref = usm_free_usmStateReference ;def -> session_setup = usm_session_init ;,649
890,"show_object ( obj , NULL , name , data ) ;continue ;","show_object ( obj , name , data ) ;continue ;",650
891,"process_blob ( revs , ( struct blob * ) obj , show_object ,  NULL , path , data ) ;continue ;","process_blob ( revs , ( struct blob * ) obj , show_object , NULL , path , data ) ;continue ;",650
892,"return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ;}","return match ( prog -> start , sp , sp , prog -> flags | eflags , sub , 0 ) ;}",651
893,if ( src_end - src < zsize )  return AVERROR_INVALIDDATA ;,if ( src_end - src < zsize + ( sub_type != 2 ) ) return AVERROR_INVALIDDATA ;,652
894,bitbuf = * src ++ ;bits = 8 ;,if ( src >= src_end ) return AVERROR_INVALIDDATA ;bitbuf = * src ++ ;bits = 8 ;,652
895,drop_futex_key_refs ( & q -> key ) ;},},653
896,# ifndef NETSNMP_NO_WRITE_SUPPORT  switch ( action ) {,# if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS switch ( action ) {,654
897,"
",CheckNumberCompactPixels ;,655
898,}continue ;}length ++ ;for ( j = 0 ;j < ( ssize_t ) length ;j ++ ) {switch ( depth )  {case 1 : {CheckNumberPixels ( 8 ) ;* pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ;break ;}case 2 : {CheckNumberPixels ( 4 ) ;* pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ;* pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ;* pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ;* pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ;break ;}case 4 : {CheckNumberPixels ( 2 ) ;* pixels ++ = ( * compact_pixels >> 4 ) & 0xff ;* pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ;break ;}default : {CheckNumberPixels ( 1 ) ;* pixels ++ = ( * compact_pixels ) ;break ;}}CheckNumberCompactPixels ;compact_pixels ++ ;,compact_pixels ++ ;,655
899,"list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head ,  open_list ) {spin_lock_irq ( & slave_active_lock ) ;_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;spin_unlock_irq ( & slave_active_lock ) ;}mutex_unlock ( & register_mutex ) ;","spin_lock_irq ( & slave_active_lock ) ;spin_lock ( & timer -> lock ) ;list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {list_del_init ( & slave -> ack_list ) ;list_del_init ( & slave -> active_list ) ;}spin_unlock ( & timer -> lock ) ;spin_unlock_irq ( & slave_active_lock ) ;mutex_unlock ( & register_mutex ) ;",656
900,"ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 1 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ;","ND_TCHECK ( p [ 2 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ;ND_TCHECK ( p [ 3 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ;ND_TCHECK ( p [ 3 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ;",657
901,"const char * arch = info -> arch ;ut16 bits = info -> bits ;if ( info -> cpu && * info -> cpu ) {r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ;}r_core_bin_set_cur ( r , binfile ) ;return true ;","char * arch = info -> arch ;ut16 bits = info -> bits ;if ( cpu && * info -> cpu ) {r_config_set ( r -> config , ""anal.cpu"" , cpu ) ;}r_core_bin_set_cur ( r , binfile ) ;free ( cpu ) ;free ( arch ) ;return true ;",658
902,"static void sas_probe_devices ( struct work_struct * work )  {struct domain_device * dev , * n ;struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ;struct asd_sas_port * port = ev -> port ;clear_bit ( DISCE_PROBE , & port -> disc . pending ) ;","static void sas_probe_devices ( struct asd_sas_port * port ) {struct domain_device * dev , * n ;",659
903,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read )  ps_dec -> u4_bitoffset = ih264d_read_mmco_commands (  ps_dec ) ;,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) {i_temp = ih264d_read_mmco_commands ( ps_dec ) ;if ( i_temp < 0 ) {return ERROR_DBP_MANAGER_T ;}ps_dec -> u4_bitoffset = i_temp ;},660
904,"int pkt_len ;char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int ,   cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) )  return FALSE ;","char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , cap_dst , & wth -> phdr , wth -> frame_buffer , line , err , err_info ) ) return FALSE ;",661
905,"dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) ,   s -> s3 -> rrec . seq_num ) ;}","if ( dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , s -> s3 -> rrec . seq_num ) < 0 ) return - 1 ;}",662
906,int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ;int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ;const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ;if ( newRasterSize > info -> rasterSize || widthOverflow > 0 || heightOverflow > 0 ) {,const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ;if ( newRasterSize == 0 ) {free ( info -> rasterBits ) ;info -> rasterBits = NULL ;info -> rasterSize = newRasterSize ;return ;}const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ;const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ;if ( newRasterSize > info -> rasterSize || widthOverflow > 0 || heightOverflow > 0 ) {,663
907,"if ( ret == 0 ) goto can_read_key ;if ( ret != - EACCES ) goto error ;if ( ! is_key_possessed ( key_ref ) ) {ret = - EACCES ;goto error2 ;}can_read_key :  ret = key_validate ( key ) ;if ( ret == 0 ) {ret = - EOPNOTSUPP ;if ( key -> type -> read ) {down_read ( & key -> sem ) ;ret = key -> type -> read ( key , buffer , buflen ) ;up_read ( & key -> sem ) ;}","if ( ret == 0 ) ret = key -> type -> read ) {down_read ( & key -> sem ) ;ret = key_validate ( key ) ;if ( ret == 0 ) {ret = - EOPNOTSUPP ;if ( key -> type -> read ) {down_read ( & key -> sem ) ;ret = key -> type -> read ( key , buffer , buflen ) ;up_read ( & key -> sem ) ;",664
908,if ( ( conn -> validator == NULL ) ||  cherokee_buffer_is_empty ( & conn -> validator -> user ) )  return ret_error ;,if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ;,665
909,"# define ThrowPICTException ( exception , message ) {}char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;","# define ThrowPICTException ( exception , message ) \\\\\\\\\\char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;",666
910,"( void ) ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;while ( ( c = ReadBlobByte ( image ) ) == 0 ) ;if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;version = ( ssize_t ) ReadBlobByte ( image ) ;if ( version == 2 ) {c = ReadBlobByte ( image ) ;if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;}else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;flags = 0 ;image -> depth = 8 ;image -> columns = ( size_t ) ( frame . right - frame . left ) ;image -> rows = ( size_t ) ( frame . bottom - frame . top ) ;image -> resolution . x = DefaultResolution ;image -> resolution . y = DefaultResolution ;image -> units = UndefinedResolution ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;jpeg = MagickFalse ;for ( code = 0 ;EOFBlob ( image ) == MagickFalse ;) {if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ;if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ;if ( code < 0 ) break ;if ( code == 0 ) continue ;if ( code > 0xa1 ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ;}else {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ;switch ( code ) {case 0x01 : {length = ReadBlobMSBShort ( image ) ;if ( length != 0x000a ) {for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ;image -> columns = ( size_t ) ( frame . right - frame . left ) ;image -> rows = ( size_t ) ( frame . bottom - frame . top ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;break ;}case 0x12 : case 0x13 : case 0x14 : {ssize_t pattern ;size_t height , width ;pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < 8 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;if ( pattern == 2 ) {for ( i = 0 ;i < 5 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ;length = ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = ( size_t ) pixmap . component_size ;image -> resolution . x = 1.0 * pixmap . horizontal_resolution ;image -> resolution . y = 1.0 * pixmap . vertical_resolution ;image -> units = PixelsPerInchResolution ;( void ) ReadBlobMSBLong ( image ) ;flags = ( ssize_t ) ReadBlobMSBShort ( image ) ;length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i <= ( ssize_t ) length ;i ++ ) ( void ) ReadBlobMSBLong ( image ) ;width = ( size_t ) ( frame . bottom - frame . top ) ;height = ( size_t ) ( frame . right - frame . left ) ;if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ;if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ;if ( length == 0 ) length = width ;if ( length < 8 ) {for ( i = 0 ;i < ( ssize_t ) ( length * height ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}else for ( i = 0 ;i < ( ssize_t ) height ;i ++ ) {if ( EOFBlob ( image ) != MagickFalse ) break ;if ( length > 200 ) {for ( j = 0 ;j < ( ssize_t ) ReadBlobMSBShort ( image ) ;j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}else for ( j = 0 ;j < ( ssize_t ) ReadBlobByte ( image ) ;j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}break ;}case 0x1b : {image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;break ;}case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : {length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : {PICTRectangle source , destination ;register unsigned char * p ;size_t j ;ssize_t bytes_per_line ;unsigned char * pixels ;bytes_per_line = 0 ;if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ;else {( void ) ReadBlobMSBShort ( image ) ;( void ) ReadBlobMSBShort ( image ) ;( void ) ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ;if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) {if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;tile_image -> depth = ( size_t ) pixmap . component_size ;tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ;tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ;tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ;tile_image -> units = PixelsPerInchResolution ;if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ;}if ( ( code != 0x9a ) && ( code != 0x9b ) ) {tile_image -> colors = 2 ;if ( ( bytes_per_line & 0x8000 ) != 0 ) {( void ) ReadBlobMSBLong ( image ) ;flags = ( ssize_t ) ReadBlobMSBShort ( image ) ;tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ;}status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ;if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( bytes_per_line & 0x8000 ) != 0 ) {for ( i = 0 ;i < ( ssize_t ) tile_image -> colors ;i ++ ) {j = ReadBlobMSBShort ( image ) % tile_image -> colors ;if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ;tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;}}else {for ( i = 0 ;i < ( ssize_t ) tile_image -> colors ;i ++ ) {tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ;tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ;tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ;}}}if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;( void ) ReadBlobMSBShort ( image ) ;if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) {length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ;else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ;if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ;p = pixels ;for ( y = 0 ;y < ( ssize_t ) tile_image -> rows ;y ++ ) {if ( p > ( pixels + extent + image -> columns ) ) {pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;}q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) tile_image -> columns ;x ++ ) {if ( tile_image -> storage_class == PseudoClass ) {index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ;SetPixelIndex ( tile_image , index , q ) ;SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ;SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ;SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ;}else {if ( pixmap . bits_per_pixel == 16 ) {i = ( ssize_t ) ( * p ++ ) ;j = ( size_t ) ( * p ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ;}else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) {if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ;}else {if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ;}}p ++ ;q += GetPixelChannels ( tile_image ) ;}if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ;if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) {p += ( pixmap . component_count - 1 ) * tile_image -> columns ;if ( p < pixels ) break ;}status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ;if ( status == MagickFalse ) break ;}pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ;tile_image = DestroyImage ( tile_image ) ;break ;}case 0xa1 : {unsigned char * info ;size_t type ;type = ReadBlobMSBShort ( image ) ;length = ReadBlobMSBShort ( image ) ;if ( length == 0 ) break ;( void ) ReadBlobMSBLong ( image ) ;length -= MagickMin ( length , 4 ) ;if ( length == 0 ) break ;info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ;if ( info == ( unsigned char * ) NULL ) break ;count = ReadBlob ( image , length , info ) ;if ( count != ( ssize_t ) length ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ;}switch ( type ) {case 0xe0 : {profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;SetStringInfoDatum ( profile , info ) ;status = SetImageProfile ( image , ""icc"" , profile , exception ) ;profile = DestroyStringInfo ( profile ) ;if ( status == MagickFalse ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case 0x1f2 : {profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;SetStringInfoDatum ( profile , info ) ;status = SetImageProfile ( image , ""iptc"" , profile , exception ) ;if ( status == MagickFalse ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}profile = DestroyStringInfo ( profile ) ;break ;}default : break ;}info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;break ;}default : {if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ;else for ( i = 0 ;i < ( ssize_t ) codes [ code ] . length ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}}}if ( code == 0xc00 ) {for ( i = 0 ;i < 24 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;continue ;}if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ;if ( code == 0x8200 ) {char filename [ MaxTextExtent ] ;FILE * file ;int unique_file ;jpeg = MagickTrue ;read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) {( void ) RelinquishUniqueFileResource ( read_info -> filename ) ;( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ;ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ;}length = ReadBlobMSBLong ( image ) ;if ( length > 154 ) {for ( i = 0 ;i < 6 ;i ++ ) ( void ) ReadBlobMSBLong ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) {( void ) fclose ( file ) ;( void ) RelinquishUniqueFileResource ( read_info -> filename ) ;ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;}for ( i = 0 ;i < 122 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;for ( i = 0 ;i < ( ssize_t ) ( length - 154 ) ;i ++ ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",666
911,"ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;* val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) &   0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ;return 0 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;* val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( jas_longlong , ( ( ( ~ tmp ) & 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( jas_longlong , tmp ) ;return 0 ;",667
912,kfree ( rm -> atomic . op_notifier ) ;return ret ;,rm -> atomic . op_active = 0 ;kfree ( rm -> atomic . op_notifier ) ;return ret ;,668
913,assert ( bi != NULL ) ;si = & bi -> slotinfo [ dev -> slot ] ;,"if ( bi == NULL ) {pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\\return ;}si = & bi -> slotinfo [ dev -> slot ] ;",669
914,"rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\msg -> msg_namelen = 0 ;","rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\",670
915,"if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) )  return - 1 ;","if ( snprintf ( spath , sizeof ( spath ) ) return - 1 ;if ( strstr ( name , "".."" ) || strchr ( name , \'/\' ) , var , iface ) >= sizeof ( spath ) ) return - 1 ;",671
916,for ( s += 9 ;isspace ( * s ) ;if ( * s == \'/\' ) {while ( * t && ! isspace ( * t ) ) t ++ ;free ( font_name ) ;,for ( s += 9 ;isspace ( ( unsigned char ) * s ) ;if ( * s == \'/\' ) {while ( * t && ! isspace ( ( unsigned char ) * t ) ) t ++ ;free ( font_name ) ;,672
917,"mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ;# ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ;","mutt_bcache_del ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) ;# ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ;",673
918,break ;},* objp = NULL ;break ;},674
919,"result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ;if ( result == 0 ) {","result = TEMP_FAILURE_RETRY ( select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ) ;if ( result == 0 ) {",675
920,goto discard ;},consume_skb ( skb ) ;return 0 ;},676
921,assert ( msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES ) ;assert ( barnum >= 0 && barnum <= PCIR_MAX_BAR_0 ) ;,"if ( msgnum > MAX_MSIX_TABLE_ENTRIES ) {pr_err ( ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>entries!\\\return - 1 ;}",677
922,"pci_msix_table_init ( dev , msgnum ) ;pci_populate_msixcap ( & msixcap , msgnum , barnum , tab_size ) ;","if ( pci_msix_table_init ( dev , msgnum ) != 0 ) return - 1 ;pci_populate_msixcap ( & msixcap , msgnum , barnum , tab_size ) ;",677
923,"if ( err ) goto out ;upperdentry = ovl_dentry_upper ( dentry ) ;if ( upperdentry ) {mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;","mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;",678
924,while ( isspace ( * p ) )  p ++ ;,while ( isspace ( ( unsigned char ) * p ) ) p ++ ;,679
925,"if ( ! authctxt -> valid ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;return 0 ;}","
",680
926,"
","if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;}",680
927,"if ( ( b = sshbuf_new ( ) ) == NULL )  fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ;","if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ;",680
928,"static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) {const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ;return data > max ? max : data ;","static int decode_unsigned_max ( struct vpx_read_bit_buffer * rb , int max ) {const int data = vpx_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ;return data > max ? max : data ;",681
929,"for ( i = 0 ;i ++ )  if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ;","if ( strlen ( line ) == 0 ) return - 1 ;for ( i = 0 ;i ++ ) if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ;",682
930,"if ( is == NULL )  goto cleanup ;status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ;cleanup :  X509_NAME_free ( is -> issuer ) ;","if ( is == NULL ) return retval ;status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ;X509_NAME_free ( is -> issuer ) ;",683
931,"
",if ( band -> prec ) {,684
932,Jpeg2000Prec * prec = band -> prec + precno ;av_freep ( & prec -> zerobits ) ;av_freep ( & band -> prec ) ;},Jpeg2000Prec * prec = band -> prec + precno ;av_freep ( & prec -> zerobits ) ;}av_freep ( & band -> prec ) ;},684
933,"if ( xmlPushInput ( ctxt , input ) < 0 )  return ;","if ( xmlPushInput ( ctxt , input ) < 0 ) {xmlFreeInputStream ( input ) ;return ;}",685
934,"
",rcu_read_lock ( ) ;,686
935,"final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;if ( IS_ERR ( dst ) ) {err = PTR_ERR ( dst ) ;dst = NULL ;goto done ;}skb = dccp_make_response ( sk , dst , req ) ;if ( skb != NULL ) {struct dccp_hdr * dh = dccp_hdr ( skb ) ;dh -> dccph_checksum = dccp_v6_csum_finish ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ;fl6 . daddr = ireq -> ir_v6_rmt_addr ;err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;err = net_xmit_eval ( err ) ;","final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ;rcu_read_unlock ( ) ;err = net_xmit_eval ( err ) ;",686
936,static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) {if ( cpi -> oxcf . lossless ) {return ONLY_4X4 ;}else if ( cpi -> common . current_video_frame == 0 ) {return TX_MODE_SELECT ;else {if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) {return ALLOW_32X32 ;}else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) {const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;return cpi -> rd_tx_select_threshes [ frame_type ] [ ALLOW_32X32 ] > cpi -> rd_tx_select_threshes [ frame_type ] [ TX_MODE_SELECT ] ? ALLOW_32X32 : TX_MODE_SELECT ;,"static TX_MODE select_tx_mode ( const VP9_COMP * cpi , MACROBLOCKD * const xd ) {if ( xd -> lossless ) return ONLY_4X4 ;else if ( cpi -> common . frame_type == KEY_FRAME && cpi -> sf . use_nonrd_pick_mode ) return ALLOW_16X16 ;if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) return ALLOW_32X32 ;}else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD || cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return TX_MODE_SELECT ;else return cpi -> rd_tx_select_threshes [ frame_type ] [ ALLOW_32X32 ] > cpi -> rd_tx_select_threshes [ frame_type ] [ TX_MODE_SELECT ] ? ALLOW_32X32 : TX_MODE_SELECT ;",687
937,}}},"
",687
938,void * H264SwDecMalloc ( u32 size )  {return malloc ( size ) ;},"void * H264SwDecMalloc ( u32 size , u32 num ) {if ( size > UINT32_MAX / num ) {return NULL ;}return malloc ( size * num ) ;}",688
939,"else if ( ! im -> gdes [ i ] . strftm && strstr ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) {","else if ( bad_format_print ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) {",689
940,"}rrd_set_error  ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>PRINT<S2SV_blank>in<S2SV_blank>\\\'%s\\\'"" , im -> gdes [ i ] . format ) ;",},689
941,if ( im -> gdes [ i ] . strftm ) {if ( im -> gdes [ vidx ] . vf . never == 1 ) {,if ( bad_format_print ( im -> gdes [ vidx ] . vf . never == 1 ) {,689
942,"if ( bad_format ( im -> gdes [ i ] . format ) ) {rrd_set_error  ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>GPRINT<S2SV_blank>in<S2SV_blank>\\\'%s\\\'"" , im -> gdes [ i ] . format ) ;",if ( bad_format ( im -> gdes [ i ] . format ) ) {,689
943,if ( shdr -> sh_size < 1 ) {return NULL ;,if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return NULL ;,690
944,if ( buf1 -> size < buf2 -> size ) {return 1 ;}else if ( buf1 -> size == buf2 -> size ) {return 0 ;}else {return - 1 ;},return ( int ) ( buf2 -> size - buf1 -> size ) ;,691
945,"# endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn ,  root_storage -> d_storage_uuid ) ) < 0 )  expn = ""Can\\\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ;","# endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn , root_storage ) ) < 0 ) expn = ""Can\\\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ;",692
946,size_t sz = sizeof ( * info ) + size ;if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ;,size_t sz = sizeof ( * info ) + size ;if ( sz < sizeof ( * info ) ) return NULL ;if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ;,693
947,"if ( ! eof ) {memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ;","if ( ! eof && vars -> str . c != vars -> ptr ) {memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ;",694
948,"if ( ! net_eq ( net , & init_net ) )  return - EAFNOSUPPORT ;","if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;",695
949,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;if ( in_atomic ( ) || ! mm ) goto no_context ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;if ( in_atomic ( ) || ! mm ) goto no_context ;",696
950,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , regs , address ) ;",696
951,ctxt -> _eip = ctxt -> src . val ;ctxt -> src . val = old_eip ;case 4 :  ctxt -> _eip = ctxt -> src . val ;break ;,"rc = assign_eip_near ( ctxt , ctxt -> src . val ) ;if ( rc != X86EMUL_CONTINUE ) break ;ctxt -> src . val = old_eip ;case 4 : rc = assign_eip_near ( ctxt , ctxt -> src . val ) ;break ;",697
952,"if ( ! list . name || list . noselect ) return ;imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ;url . path = errstr + 1 ;","if ( ! list . name , true || list . noselect ) return ;imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ;url . path = errstr + 1 ;",698
953,"static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret ,  void * * p , void * end ,  void * dbuf , void * ticket_buf ) {void * dp , * dend ;int dlen ;struct ceph_crypto_key old_key ;void * tp , * tpend ;ceph_decode_need ( p , end , sizeof ( u32 ) + 1 , bad ) ;type = ceph_decode_32 ( p ) ;dout ( ""<S2SV_blank>ticket<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>%s\\\tkt_struct_v = ceph_decode_8 ( p ) ;dlen = ceph_x_decrypt ( secret , p , end , dbuf ,  TEMP_TICKET_BUF_LEN ) ;","static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * * p , void * end ) {void * dbuf = NULL ;void * dp , * dend ;int dlen ;struct ceph_crypto_key old_key ;void * ticket_buf = NULL ;void * tp , * tpend ;ceph_decode_need ( p , end , & dbuf , 0 ) ;dlen = ceph_x_decrypt ( secret , p , end , dbuf , TEMP_TICKET_BUF_LEN ) ;",699
954,"tp = ticket_buf ;if ( is_enc ) {dlen = ceph_x_decrypt ( & old_key , p , end , ticket_buf , TEMP_TICKET_BUF_LEN ) ;}dlen = ceph_decode_32 ( & tp ) ;ceph_decode_need ( p , end , dlen , bad ) ;ceph_decode_copy ( p , ticket_buf , dlen ) ;","if ( is_enc ) {dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 ) ;}tp = ticket_buf ;dlen = ceph_decode_32 ( & tp ) ;ticket_buf = kmalloc ( dlen , GFP_NOFS ) ;if ( ! ticket_buf ) {ret = - ENOMEM ;goto out ;}tp = ticket_buf ;ceph_decode_need ( p , end , dlen , bad ) ;ceph_decode_copy ( p , ticket_buf , dlen ) ;",699
955,out :  return ret ;bad : ret = - EINVAL ;,out : kfree ( ticket_buf ) ;kfree ( dbuf ) ;return ret ;bad : ret = - EINVAL ;,699
956,pairs = palloc ( count * sizeof ( Pairs ) ) ;for ( i = 0 ;,"if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;pairs = palloc ( count * sizeof ( Pairs ) ) ;for ( i = 0 ;",700
957,"rq -> skip_clock_update = 0 ;prev -> sched_class -> put_prev_task ( rq , prev ) ;","prev -> sched_class -> put_prev_task ( rq , prev ) ;",701
958,"n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ;n2s ( p , ticklen ) ;","if ( s -> session -> session_id_length > 0 ) {int i = s -> session_ctx -> session_cache_mode ;SSL_SESSION * new_sess ;if ( i & SSL_SESS_CACHE_CLIENT ) {if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) {if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ;}else {SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ;}}if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) {al = SSL_AD_INTERNAL_ERROR ;SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ;goto f_err ;}SSL_SESSION_free ( s -> session ) ;s -> session = new_sess ;}n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ;n2s ( p , ticklen ) ;",702
959,"
",b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ;,703
960,"r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ;if ( r < 0 ) {","r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ;if ( r < 0 ) {",703
961,"
",errors += test_float_formatting ( ) ;,704
962,if ( errors )  return TEST_ERR_MAJOR_BAD ;,if ( errors ) return TEST_ERR_MAJOR_BAD ;,704
963,"return ( * field_rtrn != NULL ) ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;* field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ;* index_rtrn = NULL ;return true ;case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ;return true ;default : break ;","return ( * elem_rtrn != NULL && * field_rtrn != NULL ) ;case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ;if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ;if ( * field_rtrn == NULL ) return false ;return true ;default : break ;",705
964,if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun )  sas_eh_defer_cmd ( cmd ) ;},if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) sas_eh_finish_cmd ( cmd ) ;},706
965,"REQ ( n , funcdef ) ;name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ;","node * tc ;string type_comment = NULL ;REQ ( n , funcdef ) ;name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ;",707
966,"body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ;if ( ! body ) return NULL ;if ( is_async )   return AsyncFunctionDef ( name , args , body , decorator_seq , returns ,  LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else  return FunctionDef ( name , args , body , decorator_seq , returns ,  LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;","if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) {type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ;if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) {tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ;if ( TYPE ( tc ) == TYPE_COMMENT ) {if ( type_comment != NULL ) {ast_error ( c , n , ""Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def"" ) ;return NULL ;}type_comment = NEW_TYPE_COMMENT ( tc ) ;if ( ! type_comment ) return NULL ;}}if ( ! type_comment ) return NULL ;name_i += 1 ;}body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ;if ( ! body ) return NULL ;if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;",707
967,int err = 0 ;if ( ! asoc ) return - EINVAL ;,"int err = 0 ;if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL ;if ( ! asoc ) return - EINVAL ;",708
968,"if ( likely ( walk . nbytes == nbytes ) )  {salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ;return blkcipher_walk_done ( desc , & walk , 0 ) ;}","
",709
969,lock_sock ( sk ) ;if ( sk -> sk_state != SS_CONNECTED ) {,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;if ( sk -> sk_state != SS_CONNECTED ) {,710
970,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,711
971,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",711
972,image -> columns = image -> rows = 0 ;image -> colors = 0 ;,image -> columns = image -> rows = 0 ;image -> colors = 0 ;,712
973,if ( BImgBuff )  BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;;break ;,if ( BImgBuff ) ;break ;,712
974,"static int em_loop ( struct x86_emulate_ctxt * ctxt )  {register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ;if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;return X86EMUL_CONTINUE ;}","static int em_loop ( struct x86_emulate_ctxt * ctxt ) {int rc = X86EMUL_CONTINUE ;register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ;if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;return rc ;}",713
975,"freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;if ( ! freq_reg ) return - ENOMEM ;","if ( ! res ) return - EINVAL ;freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;if ( ! freq_reg ) return - ENOMEM ;",714
976,"case SEEK_SET :  if ( position > SIGNED_SIZEOF ( psf -> header ) )  {psf_fseek ( psf , position , whence ) ;return ;};if ( position > psf -> headend )   psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ;psf -> headindex = position ;case SEEK_CUR :  if ( psf -> headindex + position < 0 )  break ;if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) )  {psf_fseek ( psf , position , whence ) ;return ;};if ( psf -> headindex + position <= psf -> headend )  {psf -> headindex += position ;};if ( psf -> headindex + position > SIGNED_SIZEOF ( psf -> header ) )  {psf -> headindex = psf -> headend ;psf_fseek ( psf , position , SEEK_CUR ) ;break ;};psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ;psf -> headindex = psf -> headend ;break ;","case SEEK_SET : if ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ;if ( position > psf -> header . end ) psf -> header . end += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ;psf -> headindex = position ;case SEEK_CUR : if ( psf -> headindex + position < 0 ) break ;if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header . ptr + psf -> header . end , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ;psf -> headindex = psf -> headend ;",715
977,"truncate_pagecache ( inode , ioffset ) ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;goto out_dio ;}","ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;truncate_pagecache ( inode , ioffset ) ;goto out_mmap ;}",716
978,"inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;ext4_mark_inode_dirty ( handle , inode ) ;out_stop : ext4_journal_stop ( handle ) ;out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;",out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;ext4_inode_resume_unlocked_dio ( inode ) ;,716
979,uint32_t track_size ;uint8_t * * tracks ;,uint8_t * * tracks ;uint32_t * track_size ;,717
980,"track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ;if ( midi_size < 8 ) {if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>track<S2SV_blank>header)"" , 0 ) ;midi_data += 4 ;midi_size -= 4 ;track_size = * midi_data ++ << 24 ;track_size |= * midi_data ++ << 16 ;track_size |= * midi_data ++ << 8 ;track_size |= * midi_data ++ ;midi_size -= 4 ;if ( midi_size < track_size ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}if ( track_size < 3 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ;goto _end ;}if ( ( midi_data [ track_size - 3 ] != 0xFF )   || ( midi_data [ track_size - 2 ] != 0x2F )   || ( midi_data [ track_size - 1 ] != 0x00 ) ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ;midi_data += track_size ;midi_size -= track_size ;track_end [ i ] = 0 ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;if ( midi_type == 1 ) {","track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ;if ( midi_size < tmp_val ) {if ( tmp_val < 3 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ;if ( ( midi_data [ track_size - 3 ] != 0xFF ) || ( midi_data [ track_size - 2 ] != 0x2F ) || ( midi_data [ track_size - 1 ] != 0x00 ) ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ;midi_data += track_size ;midi_size -= track_size ;track_end [ i ] = 0 ;track_size [ i ] -- ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;if ( midi_type == 1 ) {",717
981,"setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {","setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {",717
982,goto NEXT_TRACK ;},track_size [ i ] -= 3 ;goto NEXT_TRACK ;},717
983,if ( * tracks [ i ] > 0x7f ) {do {track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;}}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;},"track_size [ i ] -= setup_ret ;if ( * tracks [ i ] > 0x7f ) {do {if ( ! track_size [ i ] ) break ;track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}}if ( ! track_size [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}",717
984,"setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {","setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {",717
985,track_delta [ i ] = 0 ;if ( * tracks [ i ] > 0x7f ) {track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;}}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ;,"track_size [ i ] -= setup_ret ;track_delta [ i ] = 0 ;if ( * tracks [ i ] > 0x7f ) {if ( ! track_size [ i ] ) break ;track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}}if ( ! track_size [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ;",717
986,if ( mdi -> reverb ) return ( mdi ) ;_WM_freeMDI ( mdi ) ;,free ( track_size ) ;if ( mdi -> reverb ) return ( mdi ) ;_WM_freeMDI ( mdi ) ;,717
987,"sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ;sk -> sk_write_space ( sk ) ;","sk -> sk_sndbuf = max_t ( int , val * 2 , SOCK_MIN_SNDBUF ) ;sk -> sk_write_space ( sk ) ;",718
988,"sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ;break ;","sk -> sk_rcvbuf = max_t ( int , val * 2 , SOCK_MIN_RCVBUF ) ;break ;",718
989,"int ret = 0 ;bh = udf_read_tagged ( sb , block , block , & ident ) ;lvd = ( struct logicalVolDesc * ) bh -> b_data ;ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ;i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ;i ++ , offset += gpm -> partitionMapLength ) {","unsigned int table_len ;int ret = 0 ;bh = udf_read_tagged ( sb , block , block , & ident ) ;lvd = ( struct logicalVolDesc * ) bh -> b_data ;table_len = le32_to_cpu ( lvd -> mapTableLength ) ;if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) {udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\\goto out_bh ;}ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ;i < sbi -> s_partitions && offset < table_len ;i ++ , offset += gpm -> partitionMapLength ) {",719
990,"if ( optstr ) {jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\\return 0 ;}","image = 0 ;info = 0 ;if ( optstr ) {jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\\goto error ;}",720
991,"return 0 ;}JAS_DBGLOG ( 1 ,  ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>""  ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>""  ""mincolors<S2SV_blank>%d\\\if ( ! bmp_issupported ( & hdr , info ) ) {bmp_info_destroy ( info ) ;return 0 ;return 0 ;}bmp_info_destroy ( info ) ;return 0 ;","goto error ;}JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\\if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) {jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\\goto error ;}if ( ! bmp_issupported ( & hdr , info ) ) {goto error ;goto error ;}goto error ;",720
992,bmp_info_destroy ( info ) ;return 0 ;,goto error ;,720
993,bmp_info_destroy ( info ) ;jas_image_destroy ( image ) ;return 0 ;}bmp_info_destroy ( info ) ;return image ;,goto error ;}bmp_info_destroy ( info ) ;return image ;error : if ( info ) {bmp_info_destroy ( info ) ;}if ( image ) {jas_image_destroy ( image ) ;}return 0 ;,720
994,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" ,  dev_name ( & qedi -> pdev -> dev ) , nfunc , line ,  qedi -> host_no , & vaf ) ;else  pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",721
995,return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ;},if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) {return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ;}return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ;},722
996,"save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ;if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) {","save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ;problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) {",723
997,"media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ;if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ;","memset ( & pad , 0 , sizeof ( pad ) ) ;media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ;if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ;",724
998,"media_device_kpad_to_upad ( entity -> links [ l ] . source ,  & link . source ) ;","memset ( & link , 0 , sizeof ( link ) ) ;media_device_kpad_to_upad ( entity -> links [ l ] . source , & link . source ) ;",724
999,if ( line -> indent < ctx -> code_indent_offset && pivot_line -> type == MD_LINE_TEXT  && ( CH ( off ) == _T ( \'=\' ) || CH ( off ) == _T ( \'-\' ) )  && ( n_parents == ctx -> n_containers ) ) {,"if ( line -> indent < ctx -> code_indent_offset && pivot_line -> type == MD_LINE_TEXT && off < ctx -> size && ISANYOF2 ( off , _T ( \'=\' ) , _T ( \'-\' ) ) && ( n_parents == ctx -> n_containers ) ) {",725
1000,"if ( line -> indent < ctx -> code_indent_offset && ISANYOF ( off , _T ( ""-_*"" ) ) && off >= hr_killer ) {if ( md_is_hr_line ( ctx , off , & off , & hr_killer ) ) {if ( n_parents < ctx -> n_containers && n_brothers + n_children == 0 ) {","if ( line -> indent < ctx -> code_indent_offset && off < ctx -> size && off >= hr_killer ) {if ( md_is_hr_line ( ctx , off , & off , & hr_killer ) ) {if ( n_parents < ctx -> n_containers && ISANYOF2_ n_brothers + n_children == 0 ) {",725
1001,if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers && ( off >= ctx -> size || ISNEWLINE ( off ) ) && container . ch != _T ( \'>\' ) ) {}else if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers &&  ( container . ch == _T ( \'.\' ) || container . ch == _T ( \')\' ) ) && container . start != 1 )  {,"if ( pivot_line -> type == MD_LINE_TEXT && n_parents == ctx -> n_containers && ( off >= ctx -> size || ISNEWLINE ( off ) ) && container . ch , _T ( \'.\' ) || container . ch == _T ( \')\' ) ) && container . start != 1 ) {",725
1002,"if ( line -> indent < ctx -> code_indent_offset && CH ( off ) == _T ( \'#\' ) ) {unsigned level ;if ( md_is_atxheader_line ( ctx , off , & line -> beg , & off , & level ) ) {line -> type = MD_LINE_ATXHEADER ;line -> data = level ;break ;}}if ( CH ( off ) == _T ( \'`\' ) || CH ( off ) == _T ( \'~\' ) ) {if ( md_is_opening_code_fence ( ctx , off , & off ) ) {line -> type = MD_LINE_FENCEDCODE ;line -> data = 1 ;break ;}}if ( CH ( off ) == _T ( \'<\' ) && ! ( ctx -> parser . flags & MD_FLAG_NOHTMLBLOCKS ) ) {",if ( line -> indent < ctx -> code_indent_offset && off < ctx -> size && CH ( off ) == _T ( \'<\' ) && ! ( ctx -> parser . flags & MD_FLAG_NOHTMLBLOCKS ) ) {,725
1003,if ( ( ctx -> parser . flags & MD_FLAG_TABLES ) && pivot_line -> type == MD_LINE_TEXT &&   ( CH ( off ) == _T ( \'|\' ) || CH ( off ) == _T ( \'-\' ) || CH ( off ) == _T ( \':\' ) ) &&  n_parents == ctx -> n_containers ) {,if ( ( ctx -> parser . flags & MD_FLAG_TABLES ) && pivot_line -> type == MD_LINE_TEXT && ( CH ( off ) == _T ( \'|\' ) || CH ( off ) == _T ( \'-\' ) || CH ( off ) == _T ( \':\' ) ) && n_parents == ctx -> n_containers ) {,725
1004,"size_t bytes_per_line , extent ,  height ,  length ;","size_t bytes_per_line , extent , height ;",726
1005,"if ( bytes_per_line == 0 )   bytes_per_line = image -> columns ;length = image -> rows * ( image -> columns + image -> columns % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;","
",726
1006,"SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 )  p ++ ;","SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 ) p ++ ;",726
1007,"length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {","
",726
1008,"static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client ,  krb5_principal client_principal ,  hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) {","static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , krb5_principal client_principal , const char * tgt_realm , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) {",727
1009,"# define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) ,  krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ;if ( ret ) goto out ;","# define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , tgt_realm ) ;if ( ret ) goto out ;",727
1010,"if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;","if ( ( MagickSizeType ) image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;",728
1011,"}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ;if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;bmp_info . file_size = ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;bmp_info . offset_bits = ReadBlobLSBLong ( image ) ;bmp_info . size = ReadBlobLSBLong ( image ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ;if ( bmp_info . size == 12 ) {( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ;bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ;bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ;bmp_info . planes = ReadBlobLSBShort ( image ) ;bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ;bmp_info . x_pixels = 0 ;bmp_info . y_pixels = 0 ;bmp_info . number_colors = 0 ;bmp_info . compression = BI_RGB ;bmp_info . image_size = 0 ;bmp_info . alpha_mask = 0 ;if ( image -> debug != MagickFalse ) {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ;}}else {if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ;bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;bmp_info . planes = ReadBlobLSBShort ( image ) ;bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ;bmp_info . compression = ReadBlobLSBLong ( image ) ;bmp_info . image_size = ReadBlobLSBLong ( image ) ;bmp_info . x_pixels = ReadBlobLSBLong ( image ) ;bmp_info . y_pixels = ReadBlobLSBLong ( image ) ;bmp_info . number_colors = ReadBlobLSBLong ( image ) ;if ( bmp_info . number_colors > GetBlobSize ( image ) )  ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;bmp_info . colors_important = ReadBlobLSBLong ( image ) ;if ( image -> debug != MagickFalse ) {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ;( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ;switch ( bmp_info . compression ) {case BI_RGB : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ;break ;}case BI_RLE4 : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ;break ;}case BI_RLE8 : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ;break ;}case BI_BITFIELDS : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ;break ;}case BI_PNG : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ;break ;}case BI_JPEG : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ;break ;}default : {( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ;}}( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ;}bmp_info . red_mask = ReadBlobLSBLong ( image ) ;bmp_info . green_mask = ReadBlobLSBLong ( image ) ;bmp_info . blue_mask = ReadBlobLSBLong ( image ) ;if ( bmp_info . size > 40 ) {double gamma ;bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ;bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ;# define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ;gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . red_primary . x *= gamma ;bmp_info . red_primary . y *= gamma ;image -> chromaticity . red_primary . x = bmp_info . red_primary . x ;image -> chromaticity . red_primary . y = bmp_info . red_primary . y ;gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . green_primary . x *= gamma ;bmp_info . green_primary . y *= gamma ;image -> chromaticity . green_primary . x = bmp_info . green_primary . x ;image -> chromaticity . green_primary . y = bmp_info . green_primary . y ;gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ;gamma = PerceptibleReciprocal ( gamma ) ;bmp_info . blue_primary . x *= gamma ;bmp_info . blue_primary . y *= gamma ;image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ;image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ;bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ;image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ;}else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ;if ( bmp_info . size > 108 ) {size_t intent ;intent = ReadBlobLSBLong ( image ) ;switch ( ( int ) intent ) {case LCS_GM_BUSINESS : {image -> rendering_intent = SaturationIntent ;break ;}case LCS_GM_GRAPHICS : {image -> rendering_intent = RelativeIntent ;break ;}case LCS_GM_IMAGES : {image -> rendering_intent = PerceptualIntent ;break ;}case LCS_GM_ABS_COLORIMETRIC : {image -> rendering_intent = AbsoluteIntent ;break ;}}( void ) ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;( void ) ReadBlobLSBLong ( image ) ;}}if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\\\'"" , image -> filename ) ;else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\\\'"" , image -> filename ) ;if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ;if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ;if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ;if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ;if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ;switch ( bmp_info . compression ) {case BI_RGB : image -> compression = NoCompression ;break ;case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ;break ;case BI_BITFIELDS : break ;case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ;case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ;default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ;image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ;image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ;image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ;if ( bmp_info . bits_per_pixel < 16 ) {size_t one ;image -> storage_class = PseudoClass ;image -> colors = bmp_info . number_colors ;one = 1 ;if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ;}image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ;image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ;image -> units = PixelsPerCentimeterResolution ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( image -> storage_class == PseudoClass ) {unsigned char * bmp_colormap ;size_t packet_size ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ;if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ;else packet_size = 4 ;offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ;if ( offset < 0 ) {bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ;if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) {bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;}p = bmp_colormap ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) {image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ;if ( packet_size == 4 ) p ++ ;}bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ;}if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;offset_bits = bmp_info . offset_bits ;offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ;if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ;bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ;length = ( size_t ) bytes_per_line * image -> rows ;if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) {if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ;count = ReadBlob ( image , length , pixels ) ;if ( count != ( ssize_t ) length ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;}}else {pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ;if ( status == MagickFalse ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ;}}if ( bmp_info . compression == BI_RGB ) {if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) {bytes_per_line = 4 * ( image -> columns ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {if ( * ( p + 3 ) != 0 ) {image -> alpha_trait = BlendPixelTrait ;y = - 1 ;break ;}p += 4 ;}}}bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ;bmp_info . red_mask = 0x00ff0000U ;bmp_info . green_mask = 0x0000ff00U ;bmp_info . blue_mask = 0x000000ffU ;if ( bmp_info . bits_per_pixel == 16 ) {bmp_info . red_mask = 0x00007c00U ;bmp_info . green_mask = 0x000003e0U ;bmp_info . blue_mask = 0x0000001fU ;}}( void ) memset ( & shift , 0 , sizeof ( shift ) ) ;( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ;if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) {register unsigned int sample ;if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) {shift . red ++ ;if ( shift . red >= 32U ) break ;}if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) {shift . green ++ ;if ( shift . green >= 32U ) break ;}if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) {shift . blue ++ ;if ( shift . blue >= 32U ) break ;}if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) {shift . alpha ++ ;if ( shift . alpha >= 32U ) break ;}sample = shift . red ;while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ;sample = shift . green ;while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ;sample = shift . blue ;while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ;sample = shift . alpha ;while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) {sample ++ ;if ( sample >= 32U ) break ;}quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ;}switch ( bmp_info . bits_per_pixel ) {case 1 : {for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 7 ) ;x += 8 ) {for ( bit = 0 ;bit < 8 ;bit ++ ) {index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}p ++ ;}if ( ( image -> columns % 8 ) != 0 ) {for ( bit = 0 ;bit < ( image -> columns % 8 ) ;bit ++ ) {index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}p ++ ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 4 : {for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 1 ) ;x += 2 ) {ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;}if ( ( image -> columns % 2 ) != 0 ) {ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;x ++ ;}if ( x < ( ssize_t ) image -> columns ) break ;if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 8 : {if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = ( ssize_t ) image -> columns ;x != 0 ;-- x ) {ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;break ;}case 16 : {unsigned int alpha , pixel ;if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ;image -> storage_class = DirectClass ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {pixel = ( unsigned int ) ( * p ++ ) ;pixel |= ( * p ++ ) << 8 ;red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ;if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ;if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ;green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ;if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ;if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ;if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ;blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ;if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ;if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ;SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ;SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ;SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) {alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ;if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ;SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ;}q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}case 24 : {bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}case 32 : {if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ;}bytes_per_line = 4 * ( image -> columns ) ;for ( y = ( ssize_t ) image -> rows - 1 ;y >= 0 ;y -- ) {unsigned int alpha , pixel ;p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {pixel = ( unsigned int ) ( * p ++ ) ;pixel |= ( ( unsigned int ) * p ++ << 8 ) ;pixel |= ( ( unsigned int ) * p ++ << 16 ) ;pixel |= ( ( unsigned int ) * p ++ << 24 ) ;red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ;if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ;green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ;if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ;blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ;if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ;SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ;SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ;SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) {alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ;if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ;SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ;}q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ;if ( status == MagickFalse ) break ;}}break ;}default : {pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}}pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( y > 0 ) break ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( bmp_info . height < 0 ) {Image * flipped_image ;flipped_image = FlipImage ( image , exception ) ;if ( flipped_image != ( Image * ) NULL ) {DuplicateBlob ( flipped_image , image ) ;ReplaceImageInList ( & image , flipped_image ) ;image = flipped_image ;}}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;* magick = \'\\\\0\' ;if ( bmp_info . ba_offset != 0 )   {offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ;if ( offset < 0 )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}count = ReadBlob ( image , 2 , magick ) ;","offset = ( MagickOffsetType ) bmp_info . ba_offset ;if ( offset != 0 ) {offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ;count = ReadBlob ( image , 2 , magick ) ;",728
1012,newinet -> inet_daddr = ireq -> rmt_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;,newinet -> inet_opt = ireq -> rmt_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;,729
1013,data -> l_head = NULL ;data -> portListing = NULL ;data -> portListingLength = 0 ;,"memset ( data , 0 , sizeof ( struct NameValueParserData ) ) ;",730
1014,"if ( offset != 0 )  csum = csum_sub ( csum ,  csum_partial ( skb_transport_header ( skb ) + tlen ,   offset , 0 ) ) ;put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;","if ( offset != 0 ) {int tend_off = skb_transport_offset ( skb ) + tlen ;csum = csum_sub ( csum , skb_checksum ( skb , tend_off , offset , 0 ) ) ;}put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;",731
1015,"goto unmap_pages ;}unmap_pages :  kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ;return r ;","kvm_unpin_pages ( kvm , pfn , page_size ) ;goto unmap_pages ;}unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ;return r ;",732
1016,"memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ;state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ;","if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ;state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ;",733
1017,"struct perf_event_context * ctx = event -> ctx ;struct task_struct * task = ctx -> task ;if ( ! task ) {cpu_function_call ( event -> cpu , __perf_event_disable , event ) ;return ;retry : if ( ! task_function_call ( task , __perf_event_disable , event ) ) return ;raw_spin_lock_irq ( & ctx -> lock ) ;if ( event -> state == PERF_EVENT_STATE_ACTIVE ) {raw_spin_unlock_irq ( & ctx -> lock ) ;task = ctx -> task ;goto retry ;}if ( event -> state == PERF_EVENT_STATE_INACTIVE ) {update_group_times ( event ) ;event -> state = PERF_EVENT_STATE_OFF ;}",struct perf_event_context * ctx ;ctx = perf_event_ctx_lock ( event ) ;event -> state = PERF_EVENT_STATE_OFF ;,734
1018,value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) |   ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;}value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) |   ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;},value = ( unsigned int ) buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;}value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ;value |= ( unsigned int ) buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;return ( value & 0xffffffff ) ;},735
1019,"struct free_nid * i ;struct nat_entry * ne ;int err ;if ( unlikely ( nid == 0 ) ) return false ;if ( build ) {ne = __lookup_nat_cache ( nm_i , nid ) ;if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) )  return false ;}if ( radix_tree_preload ( GFP_NOFS ) ) {kmem_cache_free ( free_nid_slab , i ) ;return true ;}spin_unlock ( & nm_i -> nid_list_lock ) ;if ( err ) {kmem_cache_free ( free_nid_slab , i ) ;return true ;}return true ;","struct free_nid * i , * e ;struct nat_entry * ne ;int err = - EINVAL ;bool ret = false ;if ( unlikely ( nid == 0 ) ) return false ;if ( radix_tree_preload ( GFP_NOFS ) ) goto err ;if ( build ) {ne = __lookup_nat_cache ( nm_i , nid ) ;if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) goto err_out ;e = __lookup_free_nid_list ( nm_i , nid ) ;if ( e ) {if ( e -> state == NID_NEW ) ret = true ;goto err_out ;}}ret = true ;err_out : spin_unlock ( & nm_i -> nid_list_lock ) ;err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ;return ret ;",736
1020,flags -> post_proc_flag =  # if CONFIG_POSTPROC_VISUALIZER  ( ctx -> dbg_color_ref_frame_flag ? VP9D_DEBUG_CLR_FRM_REF_BLKS : 0 ) | ( ctx -> dbg_color_mb_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_color_b_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_display_mv_flag ? VP9D_DEBUG_DRAW_MV : 0 ) | # endif ctx -> postproc_cfg . post_proc_flag ;# if CONFIG_POSTPROC_VISUALIZER  flags -> display_ref_frame_flag = ctx -> dbg_color_ref_frame_flag ;flags -> display_mb_modes_flag = ctx -> dbg_color_mb_modes_flag ;flags -> display_b_modes_flag = ctx -> dbg_color_b_modes_flag ;flags -> display_mv_flag = ctx -> dbg_display_mv_flag ;# endif },flags -> post_proc_flag = ctx -> postproc_cfg . post_proc_flag ;},737
1021,"netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\\return - EBADR ;netdev_dbg ( vif -> dev ,   ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\\return - EINVAL ;","netdev_err ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\\netbk_fatal_tx_err ( vif ) ;return - EBADR ;netdev_err ( vif -> dev , ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;",738
1022,"
",hdr -> sadb_msg_reserved = 0 ;,739
1023,"pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;","pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;",739
1024,r1 . event = event ;r1 . tstamp = * tstamp ;,"memset ( & r1 , 0 , sizeof ( r1 ) ) ;r1 . event = event ;r1 . tstamp = * tstamp ;",740
1025,"defaultoptions ( & h ) ;lua_settop ( L , 2 ) ;size_t size = optsize ( L , opt , & fmt ) ;pos += gettoalign ( pos , & h , opt , size ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;switch ( opt ) {lua_pushnumber ( L , res ) ;break ;case \'x\' : {case \'f\' : {float f ;memcpy ( & f , data + pos , size ) ;correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ;lua_pushnumber ( L , f ) ;break ;}case \'d\' : {double d ;memcpy ( & d , data + pos , size ) ;correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ;lua_pushnumber ( L , d ) ;break ;}case \'c\' : {if ( size == 0 ) {if ( ! lua_isnumber ( L , - 1 ) )   luaL_error ( L , ""format<S2SV_blank>`c0\\\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ;size = lua_tonumber ( L , - 1 ) ;lua_pop ( L , 1 ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;}lua_pushlstring ( L , data + pos , size ) ;break ;}lua_pushlstring ( L , data + pos , size - 1 ) ;break ;return lua_gettop ( L ) - 2 ;}","int n = 0 ;defaultoptions ( & h ) ;size_t size = optsize ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;switch ( opt ) {lua_pushnumber ( L , ""format<S2SV_blank>\\\'c0\\\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ;size = lua_tonumber ( L , - 1 ) ;n -- ;lua_pop ( L , 1 ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;lua_pushlstring ( L , data + pos , size ) ;n ++ ;lua_pushlstring ( L , data + pos , size - 1 ) ;n ++ ;break ;return n + 1 ;}",741
1026,"if ( length < sizeof ( struct olsr_common ) ) {goto trunc ;}ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ;ptr . common = ( const struct olsr_common * ) tptr ;length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ;ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ;tptr += sizeof ( struct olsr_common ) ;if ( ndo -> ndo_vflag < 1 ) {return ;}while ( tptr < ( pptr + length ) ) {union {const struct olsr_msg4 * v4 ;const struct olsr_msg6 * v6 ;}msgptr ;int msg_len_valid = 0 ;ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;if ( is_ipv6 ) {",if ( length < sizeof ( struct olsr_msg6 ) ) ;,742
1027,else  {msgptr . v4 = ( const struct olsr_msg4 * ) tptr ;,"else {ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;msgptr . v4 = ( const struct olsr_msg4 * ) tptr ;",742
1028,u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;u_int addr_size = 4 ;int name_entries_valid = 0 ;u_int i ;if ( is_ipv6 ) addr_size = 16 ;if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) )  name_entries_valid = 1 ;if ( msg_tlen < 4 ) goto trunc ;,u_int name_entries ;u_int addr_size ;int name_entries_valid ;u_int i ;if ( msg_tlen < 4 ) goto trunc ;name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;addr_size = 4 ;int name_entries_valid = 0 ;if ( is_ipv6 ) addr_size = 16 ;if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) name_entries_valid = 1 ;,742
1029,int n ;if ( ! body -> unit_size )  break ;n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 )  / body -> unit_size ;,unsigned int n ;if ( ! body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 ) ) / body -> unit_size ;,743
1030,"# if HAVE_NEON  int64_t store_reg [ 8 ] ;# if CONFIG_RUNTIME_CPU_DETECT VP8_COMMON * cm = & cpi -> common ;# endif # endif struct vpx_usec_timer timer ;# if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {if ( sd -> y_width != cpi -> oxcf . Width || sd -> y_height != cpi -> oxcf . Height ) {assert ( cpi -> oxcf . lag_in_frames < 2 ) ;dealloc_raw_frame_buffers ( cpi ) ;alloc_raw_frame_buffers ( cpi ) ;}if ( vp8_lookahead_push ( cpi -> lookahead , sd , time_stamp , end_time , frame_flags , cpi -> active_map_enabled ? cpi -> active_map : NULL ) ) res = - 1 ;vpx_usec_timer_mark ( & timer ) ;cpi -> time_receive_data += vpx_usec_timer_elapsed ( & timer ) ;# if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_pop_neon ( store_reg ) ;}# endif return res ;",struct vpx_usec_timer timer ;# if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {return res ;,744
1031,"fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\\exit ( 1 ) ;pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 )  errExit ( ""fchown"" ) ;if ( chmod ( dest , 0600 ) == - 1 ) errExit ( ""fchmod"" ) ;","fprintf ( stderr , ""Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\\return 0 ;copy_file_as_user ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) , 0600 ) ;fs_logger2 ( ""clone"" , dest ) ;",745
1032,idata -> status = IMAP_FATAL ;return ;,"idata -> status = IMAP_FATAL ;return ;}if ( strlen ( idata -> buf ) < litlen ) {mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\\return ;",746
1033,"sas_discover_event ( dev -> port , DISCE_PROBE ) ;return 0 ;",return 0 ;,747
1034,"if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) {EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ;","size_t ext_size = 0 ;if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) {EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ;ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;",748
1035,"ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;","ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;",748
1036,"ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;","ext4_extent_block_csum_set ( inode , neh ) ;set_buffer_uptodate ( bh ) ;",748
1037,"ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;break ;case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ;ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;break ;case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ;ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ;break ;case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ;ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;break ;case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ;default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ;ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ;ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;}ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ;memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ;synth_size = 2 * ptr_hbe_txposer -> synth_size ;ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ;memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ;sfb = 0 ;if ( upsamp_4_flag ) {stop_patch = MAX_NUM_PATCHES ;ptr_hbe_txposer -> max_stretch = MAX_STRETCH ;}else {stop_patch = MAX_STRETCH ;}for ( patch = 1 ;patch <= stop_patch ;patch ++ ) {while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ;if ( sfb <= p_num_sfb [ LOW ] ) {if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) {ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ;}else {WORD32 sfb = 0 ;while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ;ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ;else {ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ;ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ;break ;}}}return 0 ;}",ptr_hbe_txposer -> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ;ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ;}return 0 ;},749
1038,cmap_len = get_ushort ( & tga [ 5 ] ) ;cmap_entry_size = tga [ 7 ] ;# if 0  x_origin = get_ushort ( & tga [ 8 ] ) ;y_origin = get_ushort ( & tga [ 10 ] ) ;# endif  image_w = get_ushort ( & tga [ 12 ] ) ;image_h = get_ushort ( & tga [ 14 ] ) ;pixel_depth = tga [ 16 ] ;,cmap_len = get_tga_ushort ( & tga [ 5 ] ) ;cmap_entry_size = tga [ 7 ] ;# if 0 x_origin = get_tga_ushort ( & tga [ 8 ] ) ;y_origin = get_tga_ushort ( & tga [ 10 ] ) ;# endif image_w = get_tga_ushort ( & tga [ 12 ] ) ;image_h = get_tga_ushort ( & tga [ 14 ] ) ;pixel_depth = tga [ 16 ] ;,750
1039,ssize_t ret ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,ssize_t ret ;if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,751
1040,"if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) {tp -> tv_sec = div_long_long_rem ( cpu . sched ,  NSEC_PER_SEC , & tp -> tv_nsec ) ;else {cputime_to_timespec ( cpu . cpu , tp ) ;}}","if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) * tp = ns_to_timespec ( cpu . sched , NSEC_PER_SEC , & tp -> tv_nsec ) ;",752
1041,uint32 nstrips ;if ( td -> td_nstrips ) return td -> td_nstrips ;,uint32 nstrips ;,753
1042,"rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\msg -> msg_namelen = 0 ;","rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\",754
1043,"const lua_authz_provider_spec * prov_spec = parsed_require_line ;int result ;if ( L == NULL ) {ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02314 ) ""Unable<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>VM<S2SV_blank>for<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s"" , prov_spec -> name ) ;return AUTHZ_GENERAL_ERROR ;}lua_getglobal ( L , prov_spec -> function_name ) ;if ( ! lua_isfunction ( L , - 1 ) ) {ap_log_rerror ( APLOG_MARK , APLOG_CRIT , 0 , r , APLOGNO ( 02319 ) ""Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>entry<S2SV_blank>function<S2SV_blank>\\\'%s\\\'<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>function)"" , prov_spec -> function_name , prov_spec -> file_name ) ;ap_lua_release_state ( L , spec , r ) ;return AUTHZ_GENERAL_ERROR ;}ap_lua_run_lua_request ( L , r ) ;if ( prov_spec -> args ) {int i ;if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) {ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02315 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>arguments"" , prov_spec -> name ) ;for ( i = 0 ;const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ;lua_pushstring ( L , arg ) ;nargs = prov_spec -> args -> nelts ;}","const lua_authz_provider_func * prov_func = parsed_require_line ;const lua_authz_provider_spec * prov_spec = prov_func -> spec ;int result ;if ( prov_func -> args ) {int i ;if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) {ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02315 ) ""Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>arguments"" , prov_spec -> name ) ;for ( i = 0 ;const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ;lua_pushstring ( L , arg ) ;}nargs = prov_spec -> args -> nelts ;",755
1044,int error ;address &= PAGE_MASK ;error = security_mmap_addr ( address ) ;if ( error ) return error ;,int error = 0 ;address &= PAGE_MASK ;if ( address < mmap_min_addr ) return - EPERM ;,756
1045,"umode_t mode = inode -> i_mode ;error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error <= 0 ) {acl = NULL ;if ( error < 0 ) return error ;}error = xfs_set_mode ( inode , mode ) ;","umode_t mode ;error = posix_acl_equiv_mode ( acl , & mode , & acl ) ;if ( error ) return error ;}error = xfs_set_mode ( inode , mode ) ;",757
1046,"static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags ,  const char * data , int optional )  {# endif  if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) {if ( optional ) {","static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , const char * data , int optional , const char * rootfs ) {# endif if ( safe_mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data , rootfs ) ) {if ( optional ) {",758
1047,"# endif if ( mount ( fsname , target , fstype ,  mountflags | MS_REMOUNT , data ) ) {if ( optional ) {","# endif if ( mount ( fsname , target , fstype , mountflags | MS_REMOUNT , data ) < 0 ) {if ( optional ) {",758
1048,return ( GetFirstImageInList ( image ) ) ;},"return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",759
1049,timr -> it_overrun = - 1 ;++ timr -> it_requeue_pending ;info -> si_overrun += timr -> it_overrun_last ;},"+ timr -> it_requeue_pending ;timr -> it_overrun = - 1LL ;++ timr -> it_requeue_pending ;info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) ;}",760
1050,if ( ! proto_end )  return 0 ;,"if ( ! proto_end ) {if ( ! quiet ) warning ( _ ( ""url<S2SV_blank>has<S2SV_blank>no<S2SV_blank>scheme:<S2SV_blank>%s"" ) , url ) ;return - 1 ;}",761
1051,"bool __net_get_random_once ( void * buf , int nbytes , bool * done ,  struct static_key * done_key )  {","bool __net_get_random_once ( void * buf , int nbytes , bool * done , struct static_key * once_key ) {",762
1052,__net_random_once_disable_jump ( done_key ) ;return true ;,__net_random_once_disable_jump ( once_key ) ;return true ;,762
1053,"if ( io_data -> read && ret > 0 ) {use_mm ( io_data -> mm ) ;ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ;if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ;unuse_mm ( io_data -> mm ) ;}io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ;if ( io_data -> ffs -> ffs_eventfd &&  ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) )  eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ;usb_ep_free_request ( io_data -> ep , io_data -> req ) ;io_data -> kiocb -> private = NULL ;","bool kiocb_has_eventfd = io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ;if ( io_data -> ffs -> ffs_eventfd && ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ;usb_ep_free_request ( io_data -> ep , io_data -> req ) ;io_data -> kiocb -> private = NULL ;",763
1054,"if ( skb -> pkt_type != PACKET_HOST ) goto drop ;if ( skb_warn_if_lro ( skb ) ) goto drop ;if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_FWD , skb ) ) goto drop ;if ( IPCB ( skb ) -> opt . router_alert && ip_call_ra_chain ( skb ) ) return NET_RX_SUCCESS ;skb_forward_csum ( skb ) ;if ( ip_hdr ( skb ) -> ttl <= 1 ) goto too_many_hops ;if ( ! xfrm4_route_forward ( skb ) ) goto drop ;rt = skb_rtable ( skb ) ;if ( opt -> is_strictroute && rt -> rt_uses_gateway ) goto sr_failed ;IPCB ( skb ) -> flags |= IPSKB_FORWARDED ;mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ;if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) {IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ;icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , htonl ( mtu ) ) ;goto drop ;}if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) goto drop ;iph = ip_hdr ( skb ) ;ip_decrease_ttl ( iph ) ;if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) )  ip_rt_send_redirect ( skb ) ;",if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) ip_rt_send_redirect ( skb ) ;,764
1055,passert ( GLOBALS_ARE_RESET ( ) ) ;},},765
1056,struct trusted_key_payload * p = key -> payload . data [ 0 ] ;struct trusted_key_payload * new_p ;struct trusted_key_options * new_o ;,"struct trusted_key_payload * p ;struct trusted_key_payload * new_p ;struct trusted_key_options * new_o ;if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ;p = key -> payload . data [ 0 ] ;",766
1057,v |= ( c << 24 ) ;if ( -- n <= 0 ) {,"v |= ( JAS_CAST ( uint_fast32_t , c ) << 24 ) ;if ( -- n <= 0 ) {",767
1058,while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) {lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ;dest = ( rose_address * ) ( skb -> data + 4 ) ;lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ;,while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) {if ( skb -> len < ROSE_MIN_LEN ) {kfree_skb ( skb ) ;continue ;}lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ;if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) {kfree_skb ( skb ) ;continue ;}dest = ( rose_address * ) ( skb -> data + ROSE_CALL_REQ_DEST_ADDR_OFF ) ;lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ;,768
1059,if ( ! npages && ! old . npages ) goto out_free ;,"if ( npages ) {r = kvm_iommu_map_pages ( kvm , & new ) ;if ( r ) goto out_slots ;}",769
1060,"kvm_arch_flush_shadow_memslot ( kvm , slot ) ;kfree ( old_memslots ) ;if ( r )  goto out_free ;if ( npages ) {","kvm_iommu_unmap_pages ( kvm , & old ) ;kvm_arch_flush_shadow_memslot ( kvm , slot ) ;kfree ( old_memslots ) ;if ( r ) goto out_free ;if ( npages ) {",769
1061,if ( ! npages ) {new . dirty_bitmap = NULL ;,if ( ! npages ) {new . dirty_bitmap = NULL ;,769
1062,"out_free :  kvm_free_physmem_slot ( & new , & old ) ;","out_slots : kfree ( slots ) ;out_free : kvm_free_physmem_slot ( & new , & old ) ;",769
1063,if ( indev != NULL ) {ifa = indev -> ifa_list ;,if ( indev && indev -> ifa_list ) {ifa = indev -> ifa_list ;,770
1064,end = path ;* end = '\\\\0' ;,bool expect_end = false ;end = path ;* end = '\\\\0' ;,771
1065,switch ( tag ) {case FDT_PROP : include = want >= 2 ;,if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ;switch ( tag ) {case FDT_PROP : include = want >= 2 ;,771
1066,"name = fdt_get_name ( fdt , offset , & len ) ;if ( end - path + 2 + len >= path_len ) return - FDT_ERR_NOSPACE ;","name = fdt_get_name ( fdt , offset , & len ) ;if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT ;if ( end - path + 2 + len >= path_len ) return - FDT_ERR_NOSPACE ;",771
1067,break ;case FDT_END : include = 1 ;,if ( depth == - 1 ) expect_end = true ;break ;case FDT_END : include = 1 ;,771
1068,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ;",772
1069,"if ( p7 -> d . ptr == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ;return NULL ;}i = OBJ_obj2nid ( p7 -> type ) ;p7 -> state = PKCS7_S_HEADER ;switch ( i ) {case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ;if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ;goto err ;}md_sk = p7 -> d . sign -> md_algs ;break ;case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ;md_sk = p7 -> d . signed_and_enveloped -> md_algs ;data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ;enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ;evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ;if ( evp_cipher == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ;goto err ;}break ;case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ;enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ;data_body = p7 -> d . enveloped -> enc_data -> enc_data ;evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ;if ( evp_cipher == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ;goto err ;}break ;default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ;goto err ;}if ( md_sk != NULL ) {for ( i = 0 ;i < sk_X509_ALGOR_num ( md_sk ) ;i ++ ) {xa = sk_X509_ALGOR_value ( md_sk , i ) ;if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ;goto err ;}j = OBJ_obj2nid ( xa -> algorithm ) ;evp_md = EVP_get_digestbynid ( j ) ;if ( evp_md == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ;goto err ;}BIO_set_md ( btmp , evp_md ) ;if ( out == NULL ) out = btmp ;else BIO_push ( out , btmp ) ;btmp = NULL ;}}if ( evp_cipher != NULL ) {if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ;goto err ;}if ( pcert ) {for ( i = 0 ;i < sk_PKCS7_RECIP_INFO_num ( rsk ) ;i ++ ) {ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ;if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ;ri = NULL ;}if ( ri == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ;goto err ;}}if ( pcert == NULL ) {for ( i = 0 ;i < sk_PKCS7_RECIP_INFO_num ( rsk ) ;i ++ ) {ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ;if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ;ERR_clear_error ( ) ;}}else {if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ;ERR_clear_error ( ) ;}evp_ctx = NULL ;BIO_get_cipher_ctx ( etmp , & evp_ctx ) ;if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ;if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ;tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ;tkey = OPENSSL_malloc ( tkeylen ) ;if ( ! tkey ) goto err ;if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ;if ( ek == NULL ) {ek = tkey ;eklen = tkeylen ;tkey = NULL ;}if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) {if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) {OPENSSL_clear_free ( ek , eklen ) ;ek = tkey ;eklen = tkeylen ;tkey = NULL ;}}ERR_clear_error ( ) ;if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ;OPENSSL_clear_free ( ek , eklen ) ;ek = NULL ;OPENSSL_clear_free ( tkey , tkeylen ) ;tkey = NULL ;if ( out == NULL ) out = etmp ;else BIO_push ( out , etmp ) ;etmp = NULL ;}if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) {bio = in_bio ;",if ( in_bio != NULL ) ) {bio = in_bio ;,773
1070,"if ( server . shutdown_asap ) {if ( prepareForShutdown ( ) == REDIS_OK ) exit ( 0 ) ;redisLog ( REDIS_WARNING , ""SIGTERM<S2SV_blank>received<S2SV_blank>but<S2SV_blank>errors<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>shut<S2SV_blank>down<S2SV_blank>the<S2SV_blank>server,<S2SV_blank>check<S2SV_blank>the<S2SV_blank>logs<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information"" ) ;}for ( j = 0 ;j < server . dbnum ;j ++ ) {long long size , used , vkeys ;size = dictSlots ( server . db [ j ] . dict ) ;used = dictSize ( server . db [ j ] . dict ) ;vkeys = dictSize ( server . db [ j ] . expires ) ;if ( ! ( loops % 50 ) && ( used || vkeys ) ) {redisLog ( REDIS_VERBOSE , ""DB<S2SV_blank>%d:<S2SV_blank>%lld<S2SV_blank>keys<S2SV_blank>(%lld<S2SV_blank>volatile)<S2SV_blank>in<S2SV_blank>%lld<S2SV_blank>slots<S2SV_blank>HT."" , j , used , vkeys , size ) ;}}if ( server . bgsavechildpid == - 1 && server . bgrewritechildpid == - 1 ) {if ( ! ( loops % 10 ) ) tryResizeHashTables ( ) ;if ( server . activerehashing ) incrementallyRehash ( ) ;}if ( ! ( loops % 50 ) ) {redisLog ( REDIS_VERBOSE , ""%d<S2SV_blank>clients<S2SV_blank>connected<S2SV_blank>(%d<S2SV_blank>slaves),<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>use"" , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , zmalloc_used_memory ( ) ) ;}if ( ( server . maxidletime && ! ( loops % 100 ) ) || server . bpop_blocked_clients ) closeTimedoutClients ( ) ;if ( server . bgsavechildpid != - 1 || server . bgrewritechildpid != - 1 ) {int statloc ;pid_t pid ;if ( ( pid = wait3 ( & statloc , WNOHANG , NULL ) ) != 0 ) {if ( pid == server . bgsavechildpid ) {backgroundSaveDoneHandler ( statloc ) ;}else {backgroundRewriteDoneHandler ( statloc ) ;}updateDictResizePolicy ( ) ;}}else {time_t now = time ( NULL ) ;for ( j = 0 ;j < server . saveparamslen ;j ++ ) {struct saveparam * sp = server . saveparams + j ;if ( server . dirty >= sp -> changes && now - server . lastsave > sp -> seconds ) {redisLog ( REDIS_NOTICE , ""%d<S2SV_blank>changes<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>seconds.<S2SV_blank>Saving..."" , sp -> changes , sp -> seconds ) ;rdbSaveBackground ( server . dbfilename ) ;break ;}}}if ( server . masterhost == NULL ) activeExpireCycle ( ) ;if ( vmCanSwapOut ( ) ) {while ( server . vm_enabled && zmalloc_used_memory ( ) >   server . vm_max_memory )  {",while ( server . vm_enabled && zmalloc_used_memory ( ) > server . vm_max_memory ) {,774
1071,"
","if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) {SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ;}",775
1072,"if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) {uv__write_int ( error_fd , - errno ) ;","if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) {uv__write_int ( error_fd , - errno ) ;",775
1073,"int ret , wo ;if ( 1 + wlen > MAX_XFER_SIZE ) {wo = ( rbuf == NULL || rlen == 0 ) ;mutex_lock ( & d -> data_mutex ) ;if ( wo )  ret = dvb_usb_generic_write ( d , st -> data , 1 + wlen ) ;else ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen ,  rbuf , rlen , 0 ) ;mutex_unlock ( & d -> data_mutex ) ;","int ret ;if ( 1 + wlen > MAX_XFER_SIZE ) {if ( rlen > MAX_XFER_SIZE ) {warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\\return - EOPNOTSUPP ;}mutex_lock ( & d -> data_mutex ) ;ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen , rbuf , rlen , 0 ) ;if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen ) ;mutex_unlock ( & d -> data_mutex ) ;",776
1074,"client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 ,  ( GSourceFunc ) _client_protocol_timeout , client ) ;","
",777
1075,for ( j = 0 ;j < book -> dim ;j ++ )  a [ i ++ ] += v [ j ] ;,for ( j = 0 ;j < book -> dim && i < n ;j ++ ) a [ i ++ ] += v [ j ] ;,778
1076,"void BezierCircle ( double r , char * action )  {outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\\}","void BezierCircle ( double r , char * action ) {char * outpos = outputbuffer ;outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\\sendClean ( outputbuffer ) ;}",779
1077,BUG_ON ( ret == - EEXIST ) ;if ( ret ) {,BUG_ON ( ret == - EEXIST || ret == - EOVERFLOW ) ;if ( ret ) {,780
1078,if ( s ) {struct unix_sock * u = unix_sk ( s ) ;spin_lock ( & unix_gc_lock ) ;spin_unlock ( & unix_gc_lock ) ;}},spin_lock ( & unix_gc_lock ) ;if ( s ) {struct unix_sock * u = unix_sk ( s ) ;}fp -> f_cred -> user -> unix_inflight -- ;spin_unlock ( & unix_gc_lock ) ;},781
1079,if ( map_info -> channel_map != NULL )  {size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ;free ( psf -> channel_map ) ;,"if ( map_info -> channel_map != NULL ) {size_t chanmap_size = SF_MIN ( psf -> sf . channels , layout_tag & 0xffff ) * sizeof ( psf -> channel_map [ 0 ] ) ;free ( psf -> channel_map ) ;",782
1080,"if ( ! check_scale_factors ( other_w , other_h , this_w , this_h ) ) {sf -> x_scale_fp = REF_INVALID_SCALE ;","# endif if ( ! valid_ref_frame_size ( other_w , other_h , this_w , this_h ) ) {sf -> x_scale_fp = REF_INVALID_SCALE ;",783
1081,sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve_copy ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve_avg ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_vert ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_vert ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg ;sf -> predict [ 1 ] [ 1 ] [ 0 ] = vp9_convolve8 ;sf -> predict [ 1 ] [ 1 ] [ 1 ] = vp9_convolve8_avg ;,sf -> predict [ 0 ] [ 0 ] [ 0 ] = vpx_convolve_copy ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vpx_scaled_vert ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ;sf -> predict [ 0 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ;sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ;sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ;}}if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) {sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ;sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ;}else {sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ;sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ;}# if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) {if ( sf -> x_step_q4 == 16 ) {if ( sf -> y_step_q4 == 16 ) {sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ;sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ;sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ;sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ;sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ;sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ;}else {sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ;sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ;sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ;sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ;sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ;}}else {if ( sf -> y_step_q4 == 16 ) {sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ;sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ;sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ;sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ;sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ;sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ;sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ;sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ;sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ;sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ;# endif },783
1082,int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ;if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ;,uint32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ;if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ;,784
1083,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;",785
1084,"if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 &&  unconditional ( & e -> ipv6 ) ) || visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",786
1085,"pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ;ver = 1 ;",pdf -> xrefs = safe_calloc ( sizeof ( xref_t ) * pdf -> n_xrefs ) ;ver = 1 ;,787
1086,if ( ! sock || ( count && ! buf ) )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! sock || ( count && ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,788
1087,"skb = xchg ( & np -> pktoptions , NULL ) ;opt = xchg ( & np -> opt , NULL ) ;if ( opt )   sock_kfree_s ( sk , opt , opt -> tot_len ) ;}","skb = xchg ( ( __force struct ipv6_txoptions * * ) & np -> pktoptions , NULL ) ;opt = xchg ( & np -> opt , NULL ) ;if ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}}",789
1088,"BIO * cmsbio = NULL , * tmpin = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;","BIO * cmsbio = NULL , * tmpin = NULL , * tmpout = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;",790
1089,"cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) )  goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {","if ( ! ( flags & SMIME_BINARY ) && dcont ) {tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ;goto err ;}cmsbio = CMS_dataInit ( cms , tmpout ) ;if ( ! cmsbio ) goto err ;}SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ;if ( flags & CMS_TEXT ) {if ( ! SMIME_text ( tmpout , out ) ) {CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ;goto err ;}}}else {cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) ) goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {",790
1090,"err :  if ( dcont && ( tmpin == dcont ) )  do_free_upto ( cmsbio , dcont ) ;if ( cms_certs )  sk_X509_pop_free ( cms_certs , X509_free ) ;","err : if ( ! ( flags & SMIME_BINARY ) && dcont ) {do_free_upto ( cmsbio , tmpout ) ;if ( tmpin != dcont ) BIO_free ( tmpin ) ;}else {if ( dcont && ( tmpin == dcont ) ) do_free_upto ( cmsbio , dcont ) ;}if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;if ( cms_certs ) sk_X509_pop_free ( cms_certs , X509_free ) ;",790
1091,"if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ;if ( get_user ( len , optlen ) ) return - EFAULT ;switch ( optname ) {case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ;if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ;val = sk -> sk_family ;break ;case MCAST_MSFILTER : {struct group_filter gsf ;int err ;if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ;if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ;if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ;lock_sock ( sk ) ;err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ;release_sock ( sk ) ;return err ;}case IPV6_2292PKTOPTIONS : {struct msghdr msg ;struct sk_buff * skb ;if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ;msg . msg_control = optval ;msg . msg_controllen = len ;msg . msg_flags = flags ;lock_sock ( sk ) ;skb = np -> pktoptions ;if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ;release_sock ( sk ) ;if ( ! skb ) {if ( np -> rxopt . bits . rxinfo ) {struct in6_pktinfo src_info ;src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ;src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ;put_cmsg ( & msg , SOL_IPV6 , IPV6_PKTINFO , sizeof ( src_info ) , & src_info ) ;}if ( np -> rxopt . bits . rxhlim ) {int hlim = np -> mcast_hops ;put_cmsg ( & msg , SOL_IPV6 , IPV6_HOPLIMIT , sizeof ( hlim ) , & hlim ) ;}if ( np -> rxopt . bits . rxtclass ) {int tclass = ( int ) ip6_tclass ( np -> rcv_flowinfo ) ;put_cmsg ( & msg , SOL_IPV6 , IPV6_TCLASS , sizeof ( tclass ) , & tclass ) ;}if ( np -> rxopt . bits . rxoinfo ) {struct in6_pktinfo src_info ;src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ;src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ;put_cmsg ( & msg , SOL_IPV6 , IPV6_2292PKTINFO , sizeof ( src_info ) , & src_info ) ;}if ( np -> rxopt . bits . rxohlim ) {int hlim = np -> mcast_hops ;put_cmsg ( & msg , SOL_IPV6 , IPV6_2292HOPLIMIT , sizeof ( hlim ) , & hlim ) ;}if ( np -> rxopt . bits . rxflow ) {__be32 flowinfo = np -> rcv_flowinfo ;put_cmsg ( & msg , SOL_IPV6 , IPV6_FLOWINFO , sizeof ( flowinfo ) , & flowinfo ) ;}}len -= msg . msg_controllen ;return put_user ( len , optlen ) ;}case IPV6_MTU : {struct dst_entry * dst ;val = 0 ;rcu_read_lock ( ) ;dst = __sk_dst_get ( sk ) ;if ( dst ) val = dst_mtu ( dst ) ;rcu_read_unlock ( ) ;if ( ! val ) return - ENOTCONN ;break ;}case IPV6_V6ONLY : val = sk -> sk_ipv6only ;break ;case IPV6_RECVPKTINFO : val = np -> rxopt . bits . rxinfo ;break ;case IPV6_2292PKTINFO : val = np -> rxopt . bits . rxoinfo ;break ;case IPV6_RECVHOPLIMIT : val = np -> rxopt . bits . rxhlim ;break ;case IPV6_2292HOPLIMIT : val = np -> rxopt . bits . rxohlim ;break ;case IPV6_RECVRTHDR : val = np -> rxopt . bits . srcrt ;break ;case IPV6_2292RTHDR : val = np -> rxopt . bits . osrcrt ;break ;case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : {lock_sock ( sk ) ;len = ipv6_getsockopt_sticky ( sk , np -> opt ,  optname , optval , len ) ;","if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , opt , optname , optval , len ) ;",791
1092,unregister_pernet_subsys ( & sctp_net_ops ) ;sctp_v6_protosw_exit ( ) ;sctp_v4_protosw_exit ( ) ;sctp_v6_pf_exit ( ) ;,unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ;sctp_v6_protosw_exit ( ) ;sctp_v4_protosw_exit ( ) ;unregister_pernet_subsys ( & sctp_defaults_ops ) ;sctp_v6_pf_exit ( ) ;,792
1093,},"add_bool_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ;hook_add_event ( ""nick_can_register"" ) ;hook_add_nick_can_register ( check_registration_keywords ) ;hook_add_event ( ""user_can_register"" ) ;hook_add_user_can_register ( check_registration_keywords ) ;}",793
1094,"struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ;struct netdev_notifier_info info ;netdev_notifier_info_init ( & info , dev ) ;return masq_device_event ( this , event , & info ) ;","struct in_device * idev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev ;struct netdev_notifier_info info ;if ( idev -> dead ) return NOTIFY_DONE ;netdev_notifier_info_init ( & info , idev -> dev ) ;return masq_device_event ( this , event , & info ) ;",794
1095,if ( current -> active_mm != mm )   goto out ;if ( ! current -> mm ) {goto out ;},if ( current -> active_mm != mm ) {smp_mb ( ) ;goto out ;}if ( ! current -> mm ) {smp_mb ( ) ;goto out ;},795
1096,"static void show_psnr ( struct stream_state * stream ) {int i ;ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 ,  ( double ) stream -> psnr_sse_total ) ;","static void show_psnr ( struct stream_state * stream , double peak ) {int i ;ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , peak , ( double ) stream -> psnr_sse_total ) ;",796
1097,char temp [ 500 ] ;int i = 0 ;,int temp_size = 500 ;char * temp = malloc ( temp_size ) ;int i = 0 ;,797
1098,temp [ i ] = fgetc ( fp ) ;if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == \'\\\\0\' || temp [ i ] == EOF ) ) {,"if ( i >= temp_size ) {temp_size *= 2 ;temp = realloc ( temp , temp_size ) ;}temp [ i ] = fgetc ( fp ) ;if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == \'\\\\0\' || temp [ i ] == EOF ) ) {",797
1099,if ( ! del_timer ( & task -> slow_task -> timer ) )  return ;,del_timer ( & task -> slow_task -> timer ) ;,798
1100,"dst_name = malloc ( strlen ( name ) * 2 + 16 ) ;sprintf ( dst_name , ""%s/%s"" , name , name ) ;","dst_name = safe_calloc ( strlen ( name ) * 2 + 16 ) ;sprintf ( dst_name , ""%s/%s"" , name , name ) ;",799
1101,"log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>chassis"" ) ;return - 1 ;}TAILQ_INIT ( & chassis -> c_mgmt ) ;if ( ( port = calloc ( 1 , sizeof ( struct lldpd_port ) ) ) == NULL ) {log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>port"" ) ;free ( chassis ) ;return - 1 ;}# ifdef ENABLE_DOT1 TAILQ_INIT ( & port -> p_vlans ) ;TAILQ_INIT ( & port -> p_ppvids ) ;TAILQ_INIT ( & port -> p_pids ) ;# endif # ifdef ENABLE_CUSTOM TAILQ_INIT ( & port -> p_custom_list ) ;# endif length = s ;pos = ( u_int8_t * ) frame ;if ( length < 2 * ETHER_ADDR_LEN + sizeof ( u_int16_t ) ) {log_warnx ( ""lldp"" , ""too<S2SV_blank>short<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( PEEK_CMP ( lldpaddr , ETHER_ADDR_LEN ) != 0 ) {log_info ( ""lldp"" , ""frame<S2SV_blank>not<S2SV_blank>targeted<S2SV_blank>at<S2SV_blank>LLDP<S2SV_blank>multicast<S2SV_blank>address<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_DISCARD ( ETHER_ADDR_LEN ) ;if ( PEEK_UINT16 != ETHERTYPE_LLDP ) {log_info ( ""lldp"" , ""non<S2SV_blank>LLDP<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}while ( length && ( ! gotend ) ) {if ( length < 2 ) {log_warnx ( ""lldp"" , ""tlv<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}tlv_size = PEEK_UINT16 ;tlv_type = tlv_size >> 9 ;tlv_size = tlv_size & 0x1ff ;( void ) PEEK_SAVE ( tlv ) ;if ( length < tlv_size ) {log_warnx ( ""lldp"" , ""frame<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}switch ( tlv_type ) {case LLDP_TLV_END : if ( tlv_size != 0 ) {log_warnx ( ""lldp"" , ""lldp<S2SV_blank>end<S2SV_blank>received<S2SV_blank>with<S2SV_blank>size<S2SV_blank>not<S2SV_blank>null<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( length ) log_debug ( ""lldp"" , ""extra<S2SV_blank>data<S2SV_blank>after<S2SV_blank>lldp<S2SV_blank>end<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;gotend = 1 ;break ;case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 2 , ""Port<S2SV_blank>Id"" ) ;tlv_subtype = PEEK_UINT8 ;if ( ( tlv_subtype == 0 ) || ( tlv_subtype > 7 ) ) {log_warnx ( ""lldp"" , ""unknown<S2SV_blank>subtype<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>id<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size - 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>id<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size - 1 ) ;if ( tlv_type == LLDP_TLV_PORT_ID ) {port -> p_id_subtype = tlv_subtype ;port -> p_id = b ;port -> p_id_len = tlv_size - 1 ;}else {chassis -> c_id_subtype = tlv_subtype ;chassis -> c_id = b ;chassis -> c_id_len = tlv_size - 1 ;}break ;case LLDP_TLV_TTL : CHECK_TLV_SIZE ( 2 , ""TTL"" ) ;chassis -> c_ttl = PEEK_UINT16 ;ttl_received = 1 ;break ;case LLDP_TLV_PORT_DESCR : case LLDP_TLV_SYSTEM_NAME : case LLDP_TLV_SYSTEM_DESCR : if ( tlv_size < 1 ) {log_debug ( ""lldp"" , ""empty<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;break ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size + 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>string<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size ) ;if ( tlv_type == LLDP_TLV_PORT_DESCR ) port -> p_descr = b ;else if ( tlv_type == LLDP_TLV_SYSTEM_NAME ) chassis -> c_name = b ;else chassis -> c_descr = b ;break ;case LLDP_TLV_SYSTEM_CAP : CHECK_TLV_SIZE ( 4 , ""System<S2SV_blank>capabilities"" ) ;chassis -> c_cap_available = PEEK_UINT16 ;chassis -> c_cap_enabled = PEEK_UINT16 ;break ;case LLDP_TLV_MGMT_ADDR : CHECK_TLV_SIZE ( 1 , ""Management<S2SV_blank>address"" ) ;addr_str_length = PEEK_UINT8 ;if ( addr_str_length > sizeof ( addr_str_buffer ) ) {log_warnx ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ;PEEK_BYTES ( addr_str_buffer , addr_str_length ) ;addr_length = addr_str_length - 1 ;addr_family = addr_str_buffer [ 0 ] ;addr_ptr = & addr_str_buffer [ 1 ] ;CHECK_TLV_SIZE ( 1 + addr_str_length + 5 , ""Management<S2SV_blank>address"" ) ;iface_subtype = PEEK_UINT8 ;iface_number = PEEK_UINT32 ;af = lldpd_af_from_lldp_proto ( addr_family ) ;if ( af == LLDPD_AF_UNSPEC ) break ;if ( iface_subtype == LLDP_MGMT_IFACE_IFINDEX ) iface = iface_number ;else iface = 0 ;mgmt = lldpd_alloc_mgmt ( af , addr_ptr , addr_length , iface ) ;if ( mgmt == NULL ) {assert ( errno == ENOMEM ) ;log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>""  ""for<S2SV_blank>management<S2SV_blank>address"" ) ;goto malformed ;}","if ( errno == ENOMEM ) ;log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>management<S2SV_blank>address"" ) ;else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;",800
1102,"case BPLIST_DATA :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_STRING :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_UNICODE : if ( size * 2 < size ) {if ( * object + size * 2 > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_SET : case BPLIST_ARRAY :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\","case BPLIST_DATA : if ( * object + size < * object || * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_STRING : if ( * object + size < * object || * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_UNICODE : if ( size * 2 < * object || * object + size < * object || * object + size * 2 < size ) {if ( * object + size * 2 > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\case BPLIST_SET : case BPLIST_ARRAY : if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\",801
1103,"case BPLIST_DICT :  if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\","case BPLIST_DICT : if ( * object + size > bplist -> offset_table ) {PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\\",801
1104,"TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\\\r\\\if ( ksz8851ReadReg ( interface , KSZ8851_REG_CIDER ) != KSZ8851_REV_A3_ID )  {","TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\\\r\\\if ( ksz8851ReadReg ( interface , KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) ) {",802
1105,"ksz8851WriteReg ( interface , KSZ8851_REG_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_REG_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_REG_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_REG_TXCR , TXCR_TXFCE | TXCR_TXPE | TXCR_TXCE ) ;ksz8851WriteReg ( interface , KSZ8851_REG_TXFDPR , TXFDPR_TXFPAI ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXPAFMA | RXCR1_RXFCE | RXCR1_RXBE | RXCR1_RXME | RXCR1_RXUE ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXCR2 , RXCR2_SRDBL2 | RXCR2_IUFFP | RXCR2_RXIUFCEZ ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXQCR , RXQCR_RXFCTE | RXQCR_ADRFE ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ;ksz8851WriteReg ( interface , KSZ8851_REG_RXFCTR , 1 ) ;ksz8851ClearBit ( interface , KSZ8851_REG_P1CR , P1CR_FORCE_DUPLEX ) ;ksz8851SetBit ( interface , KSZ8851_REG_P1CR , P1CR_RESTART_AN ) ;ksz8851SetBit ( interface , KSZ8851_REG_ISR , ISR_LCIS | ISR_TXIS |  ISR_RXIS | ISR_RXOIS | ISR_TXPSIS | ISR_RXPSIS | ISR_TXSAIS | ISR_RXWFDIS | ISR_RXMPDIS | ISR_LDIS | ISR_EDIS | ISR_SPIBEIS ) ;ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_TXIE | IER_RXIE ) ;ksz8851SetBit ( interface , KSZ8851_REG_TXCR , TXCR_TXE ) ;ksz8851SetBit ( interface , KSZ8851_REG_RXCR1 , RXCR1_RXE ) ;osSetEvent ( & interface -> nicTxEvent ) ;","ksz8851WriteReg ( interface , KSZ8851_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_MARL , htons ( interface -> macAddr . w [ 2 ] ) ) ;ksz8851WriteReg ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ;ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ;ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ;ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ;ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ;ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ;ksz8851WriteReg ( interface , KSZ8851_RXFCTR , 1 ) ;ksz8851ClearBit ( interface , KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX ) ;ksz8851SetBit ( interface , KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN ) ;ksz8851SetBit ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS ) ;ksz8851SetBit ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE ) ;ksz8851SetBit ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXE ) ;ksz8851SetBit ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE ) ;osSetEvent ( & interface -> nicTxEvent ) ;",802
1106,pch -> file . dead = 1 ;wake_up_interruptible ( & pch -> file . rwait ) ;,put_net ( pch -> chan_net ) ;pch -> chan_net = NULL ;pch -> file . dead = 1 ;wake_up_interruptible ( & pch -> file . rwait ) ;,803
1107,"struct btrfs_dir_item * di ;struct btrfs_root * root = BTRFS_I ( inode ) -> root ;if ( flags & XATTR_REPLACE ) {di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name ,  name_len , - 1 ) ;if ( IS_ERR ( di ) ) {ret = PTR_ERR ( di ) ;}ret = - ENODATA ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( ret ) goto out ;btrfs_release_path ( path ) ;if ( ! value ) goto out ;}else {di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ;if ( IS_ERR ( di ) ) {ret = PTR_ERR ( di ) ;goto out ;if ( flags & XATTR_CREATE )  goto out ;btrfs_release_path ( path ) ;di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;}else if ( ! di ) {btrfs_release_path ( path ) ;goto again ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( value ) {btrfs_release_path ( path ) ;goto again ;","struct btrfs_dir_item * di = NULL ;struct btrfs_root * root = BTRFS_I ( inode ) -> root ;path -> skip_release_on_error = 1 ;if ( ! value ) {di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;if ( ! di && ( flags & XATTR_REPLACE ) ) ret = - ENODATA ;else if ( di ) ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;}ret = - ENODATA ;ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ;if ( ret ) goto out ;btrfs_release_path ( path ) ;if ( ! value ) goto out ;if ( flags & XATTR_REPLACE ) {ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ;di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ;if ( flags & XATTR_CREATE ) goto out ;btrfs_release_path ( path ) ;di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ;btrfs_release_path ( path ) ;di = NULL ;}ret = btrfs_insert_xattr_item ( trans , root , path , di ) ;btrfs_extend_item ( root , path , data_size ) ;item = btrfs_item_nr ( slot ) ;ptr = btrfs_item_ptr ( leaf , slot , char ) ;ptr += btrfs_item_size ( leaf , item ) - data_size ;di = ( struct btrfs_dir_item * ) ptr ;btrfs_set_dir_data_len ( leaf , di , size ) ;data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ;write_extent_buffer ( leaf , value , data_ptr , size ) ;btrfs_mark_buffer_dirty ( leaf ) ;}else {",804
1108,if ( op -> op > 0xbf ) return 1 ;WasmOpDef * opdef = & opcodes [ op -> op ] ;,if ( op -> op > 0xbf ) {return 1 ;}WasmOpDef * opdef = & opcodes [ op -> op ] ;,805
1109,if ( ! ( n > 0 && n < buf_len ) ) goto err ;,if ( ! ( n > 0 && n < buf_len ) ) {goto err ;},805
1110,"if ( ! ( n > 0 && n < buf_len ) ) goto err ;if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ;int i = 0 ;if ( ! ( op -> len + n <= buf_len ) ) goto beach ;op -> len += n ;}if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ;op -> len += n ;for ( i = 0 ;i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ;snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ;}","if ( ! ( n > 0 && n < buf_len ) ) goto err ;if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) {) goto err ;}int i = 0 ;if ( ! ( op -> len + n <= buf_len ) ) {goto beach ;}op -> len += n ;}if ( ! ( n > 0 && n + op -> len < buf_len ) ) {goto beach ;}op -> len += n ;for ( i = 0 ;i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;}",805
1111,"client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ;g_clear_object ( & client -> proxy ) ;g_hash_table_destroy ( client -> rewrite_reply ) ;","client -> proxy ) ;g_byte_array_free ( client -> auth_buffer , TRUE -> clients = g_list_remove ( client -> proxy -> clients , client ) ;g_clear_object ( & client -> proxy ) ;g_hash_table_destroy ( client -> rewrite_reply ) ;",806
1112,"vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra ,  & arg ) ;","vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , vp9_encode_block_intra , & arg ) ;",807
1113,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  return - ENOKEY ;",if ( key_is_negative ( key ) ) return - ENOKEY ;,808
1114,NEED_IP ( 1 ) ;}copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS )  if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) {const unsigned char * ie = ip + t ;,"NEED_IP ( 1 , 0 ) ;}copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( t , 15 ) && HAVE_OP ( t , 15 ) ) ) {const unsigned char * ie = ip + t ;",809
1115,NEED_OP ( t ) ;NEED_IP ( t + 3 ) ;do {,"NEED_OP ( t , 0 ) ;NEED_IP ( t , 3 ) ;do {",809
1116,NEED_OP ( 2 ) ;op [ 0 ] = m_pos [ 0 ] ;,"NEED_OP ( 2 , 0 ) ;op [ 0 ] = m_pos [ 0 ] ;",809
1117,NEED_IP ( 1 ) ;}NEED_IP ( 2 ) ;},"NEED_IP ( 1 , 0 ) ;}NEED_IP ( 2 , 0 ) ;}",809
1118,NEED_IP ( 1 ) ;}NEED_IP ( 2 ) ;},"NEED_IP ( 1 , 0 ) ;}NEED_IP ( 2 , 0 ) ;}",809
1119,if ( likely ( HAVE_OP ( t + 15 ) ) ) {do {,"if ( likely ( HAVE_OP ( t , 15 ) ) ) {do {",809
1120,if ( HAVE_IP ( 6 ) ) {state = next ;,"if ( HAVE_IP ( 6 , 0 ) ) {state = next ;",809
1121,NEED_OP ( t ) ;do {,"NEED_OP ( t , 0 ) ;do {",809
1122,NEED_OP ( t ) ;op [ 0 ] = m_pos [ 0 ] ;,"NEED_OP ( t , 0 ) ;op [ 0 ] = m_pos [ 0 ] ;",809
1123,"# if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS )  if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) {COPY4 ( op , ip ) ;NEED_IP ( t + 3 ) ;NEED_OP ( t ) ;while ( t > 0 ) {","# if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( 6 , 0 ) && HAVE_OP ( 4 , 0 ) ) ) {COPY4 ( op , ip ) ;NEED_IP ( t , 3 ) ;NEED_OP ( t , 0 ) ;while ( t > 0 ) {",809
1124,"if ( fit_check_format ( fit , IMAGE_SIZE_INVAL ) ) {printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!\\\bootstage_error ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ;return - ENOEXEC ;}","ret = fit_check_format ( fit , IMAGE_SIZE_INVAL ) ;if ( ret ) {printf ( ""Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!<S2SV_blank>(err=%d)\\\if ( CONFIG_IS_ENABLED ( FIT_SIGNATURE ) && ret == - EADDRNOTAVAIL ) printf ( ""Signature<S2SV_blank>checking<S2SV_blank>prevents<S2SV_blank>use<S2SV_blank>of<S2SV_blank>unit<S2SV_blank>addresses<S2SV_blank>(@)<S2SV_blank>in<S2SV_blank>nodes\\\bootstage_error ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ;return ret ;}",810
1125,vpn_packet_t outpkt ;outpkt . len = len ;,vpn_packet_t outpkt ;if ( len > sizeof outpkt . data ) return ;outpkt . len = len ;,811
1126,if ( enable_apicv ) {for ( msr = 0x800 ;,for ( msr = 0x800 ;,812
1127,}if ( enable_ept ) {,if ( enable_ept ) {,812
1128,"end = ( char * ) defs + shdr -> sh_size ;sdb_set ( sdb , ""section_name"" , section_name , 0 ) ;sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;",end = ( char * ) defs > i ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;,813
1129,if ( vdaux < 1 ) {sdb_free ( sdb_verdef ) ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {sdb_free ( sdb_verdef ) ;if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) {sdb_free ( sdb_verdef ) ;,813
1130,if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) {sdb_free ( sdb_verdef ) ;,813
1131,"ioctl ( uinput_fd , UI_DEV_DESTROY ) ;close ( uinput_fd ) ;","TEMP_FAILURE_RETRY ( ioctl ( uinput_fd , UI_DEV_DESTROY ) ) ;close ( uinput_fd ) ;",814
1132,"# if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ?  ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) /  ( rc -> baseline_gf_interval + af_ratio - 1 ) :  ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) /  ( rc -> baseline_gf_interval + af_ratio - 1 ) ;# else  target = rc -> av_per_frame_bandwidth ;# endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ;","# if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval ) / ( rc -> baseline_gf_interval + af_ratio - 1 ) ;# else target = rc -> avg_frame_bandwidth ;# endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ;",815
1133,"i ++ )  if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 )  errx ( 1 , ""%s:<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>option"" , ""--allow-untrusted"" ) ;",i ++ ) check_option ( argv [ i ] ) ;,816
1134,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,817
1135,offset = tbl -> indent ;if ( cmd == HTML_DT ) {}if ( tbl -> indent > 0 ) {,if ( tbl -> indent < 0 ) tbl -> indent = 0 ;if ( offset < 0 ) offset = 0 ;offset = tbl -> indent ;if ( cmd == HTML_DT ) {}if ( tbl -> indent > 0 ) {,818
1136,"( void ) & line ;if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len )  return 0 ;DPRINTF ( ( ""%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%"" SIZE_T_FORMAT ""u"" ""<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>[%"" SIZE_T_FORMAT ""u<S2SV_blank>%"" SIZE_T_FORMAT ""u]\\\errno = EFTYPE ;","size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ;( void ) & line ;if ( e >= b && ( size_t ) ( e - b ) <= ss * sst -> sst_len ) return 0 ;DPRINTF ( ( ""%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%"" SIZE_T_FORMAT ""u"" ""<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>[%"" SIZE_T_FORMAT ""u<S2SV_blank>%"" SIZE_T_FORMAT ""u]\\\errno = EFTYPE ;",819
1137,"case 2 :  # line 106 ""hex_grammar.y""  {# line 1330 ""hex_grammar.c""  break ;case 3 :  # line 115 ""hex_grammar.y""  {# line 1338 ""hex_grammar.c""  break ;case 4 :  # line 119 ""hex_grammar.y""  {# line 1351 ""hex_grammar.c""  break ;case 5 :  # line 128 ""hex_grammar.y""  {RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;( yyval . re_node ) = NULL ;","case 2 : # line 113 ""hex_grammar.y"" {# line 1337 ""hex_grammar.c"" break ;case 3 : # line 122 ""hex_grammar.y"" {# line 1345 ""hex_grammar.c"" break ;case 4 : # line 126 ""hex_grammar.y"" {incr_ast_levels ( ) ;# line 1360 ""hex_grammar.c"" break ;case 5 : # line 137 ""hex_grammar.y"" {RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ;incr_ast_levels ( ) ;( yyval . re_node ) = NULL ;",820
1138,"# line 1413 ""hex_grammar.c""  break ;case 6 :  # line 190 ""hex_grammar.y""  {# line 1421 ""hex_grammar.c""  break ;case 7 :  # line 194 ""hex_grammar.y""  {# line 1434 ""hex_grammar.c""  break ;case 8 :  # line 207 ""hex_grammar.y""  {# line 1442 ""hex_grammar.c""  break ;case 9 :  # line 211 ""hex_grammar.y""  {# line 1451 ""hex_grammar.c""  break ;case 10 :  # line 220 ""hex_grammar.y""  {","# line 1424 ""hex_grammar.c"" break ;case 6 : # line 201 ""hex_grammar.y"" {# line 1432 ""hex_grammar.c"" break ;case 7 : # line 205 ""hex_grammar.y"" {incr_ast_levels ( ) ;# line 1447 ""hex_grammar.c"" break ;case 8 : # line 220 ""hex_grammar.y"" {# line 1455 ""hex_grammar.c"" break ;case 9 : # line 224 ""hex_grammar.y"" {# line 1464 ""hex_grammar.c"" break ;case 10 : # line 233 ""hex_grammar.y"" {",820
1139,"# line 1468 ""hex_grammar.c""  break ;case 11 :  # line 233 ""hex_grammar.y""  {# line 1476 ""hex_grammar.c""  break ;case 12 :  # line 237 ""hex_grammar.y""  {# line 1485 ""hex_grammar.c""  break ;case 13 :  # line 246 ""hex_grammar.y""  {","# line 1481 ""hex_grammar.c"" break ;case 11 : # line 246 ""hex_grammar.y"" {# line 1489 ""hex_grammar.c"" break ;case 12 : # line 250 ""hex_grammar.y"" {# line 1498 ""hex_grammar.c"" break ;case 13 : # line 259 ""hex_grammar.y"" {",820
1140,"# line 1512 ""hex_grammar.c""  break ;case 14 :  # line 269 ""hex_grammar.y""  {","# line 1525 ""hex_grammar.c"" break ;case 14 : # line 282 ""hex_grammar.y"" {",820
1141,"# line 1548 ""hex_grammar.c""  break ;case 15 :  # line 301 ""hex_grammar.y""  {","# line 1561 ""hex_grammar.c"" break ;case 15 : # line 314 ""hex_grammar.y"" {",820
1142,"# line 1574 ""hex_grammar.c""  break ;case 16 :  # line 323 ""hex_grammar.y""  {","# line 1587 ""hex_grammar.c"" break ;case 16 : # line 336 ""hex_grammar.y"" {",820
1143,"# line 1594 ""hex_grammar.c""  break ;case 17 :  # line 343 ""hex_grammar.y""  {# line 1602 ""hex_grammar.c""  break ;case 18 :  # line 347 ""hex_grammar.y""  {( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1617 ""hex_grammar.c""  break ;case 19 :  # line 361 ""hex_grammar.y""  {# line 1629 ""hex_grammar.c""  break ;case 20 :  # line 369 ""hex_grammar.y""  {","# line 1607 ""hex_grammar.c"" break ;case 17 : # line 356 ""hex_grammar.y"" {# line 1615 ""hex_grammar.c"" break ;case 18 : # line 360 ""hex_grammar.y"" {incr_ast_levels ( ) ;( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1631 ""hex_grammar.c"" break ;case 19 : # line 375 ""hex_grammar.y"" {# line 1643 ""hex_grammar.c"" break ;case 20 : # line 383 ""hex_grammar.y"" {",820
1144,"# line 1653 ""hex_grammar.c""  break ;# line 1657 ""hex_grammar.c""  default : break ;","# line 1667 ""hex_grammar.c"" break ;# line 1657 ""hex_grammar.c"" default : break ;",820
1145,"d = & mb -> e_mbd . block [ ib ] ;# if 0  vp8_strict_quantize_b ( b , d ) ;# endif dequant_ptr = d -> dequant ;",dequant_ptr = d -> dequant ;,821
1146,"strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ;# ifdef __WIN__ strncat ( buff , ""/"" , sizeof ( buff ) - strlen ( buff ) - 1 ) ;","memset ( buff , 0 , sizeof ( buff ) ) ;strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ;# ifdef __WIN__ strncat ( buff , ""/"" , sizeof ( buff ) - strlen ( buff ) - 1 ) ;",822
1147,"if ( ret < 0 ) return ret ;key -> expiry = prep -> expiry ;if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  zap = dereference_key_locked ( key ) ;",if ( key_is_positive ( key ) ) zap = dereference_key_locked ( key ) ;,823
1148,struct hci_filter * f = & hci_pi ( sk ) -> filter ;uf . type_mask = f -> type_mask ;,"struct hci_filter * f = & hci_pi ( sk ) -> filter ;memset ( & uf , 0 , sizeof ( uf ) ) ;uf . type_mask = f -> type_mask ;",824
1149,int n = ( int ) ( data_end - data ) ;if ( n > 10 ) n = 10 ;,"int n = ( int ) MIN ( sizeof ( clear_buffer ) , data_end - data ) ;",825
1150,"clear += 7 ;}vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ;vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ;}","}vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ;memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ;}",825
1151,"pc -> clamp_type = ( CLAMP_TYPE ) vp8_read_bit ( bc ) ;}xd -> segmentation_enabled = ( unsigned char ) vp8_read_bit ( bc ) ;if ( xd -> segmentation_enabled ) {vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;for ( i = 0 ;","memset ( xd -> segmentation_enabled ) {vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;for ( i = 0 ;",825
1152,"vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ;for ( i = 0 ;","memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ;for ( i = 0 ;",825
1153,"vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ;}","memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ;}",825
1154,"vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_decode_mode_mvs ( pbi ) ;# endif  vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ;pbi -> frame_corrupt_residual = 0 ;","memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_decode_mode_mvs ( pbi ) ;# endif memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ;pbi -> frame_corrupt_residual = 0 ;",825
1155,"vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ;pbi -> independent_partitions = prev_independent_partitions ;","memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ;pbi -> independent_partitions = prev_independent_partitions ;",825
1156,"gss_buffer_desc client_name , service_name ;OM_uint32 minor_stat ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;OM_uint32 minor_stat ;,826
1157,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",826
1158,"asoc -> peer . i = new -> peer . i ;sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ;","asoc -> peer . auth_capable = new -> peer . auth_capable ;asoc -> peer . i = new -> peer . i ;sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ;",827
1159,if ( ! capable ( CAP_SYS_ADMIN ) ) {,if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( ! capable ( CAP_SYS_ADMIN ) ) {,828
1160,if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) {rcode = - EINVAL ;,if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) ) {rcode = - EINVAL ;,828
1161,assert ( ( cc0 % rowsize ) == 0 ) ;while ( cc > 0 ) {,"if ( ( cc0 % rowsize ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ;return 0 ;}while ( cc > 0 ) {",829
1162,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_association_put ( asoc ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\out_unlock : bh_unlock_sock ( sk ) ;sctp_association_put ( asoc ) ;",830
1163,"int yr_re_exec ( uint8_t * re_code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {","int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",831
1164,"# define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3  # define prolog if ( bytes_matched >= max_bytes_matched ) {# define fail_if_error ( e ) switch ( e ) {if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ;input -= character_size ;input_incr = - input_incr ;max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ;max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ;","# define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 # define prolog {if ( ( bytes_matched >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) {}# define fail_if_error ( e ) {switch ( e ) {}if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ;max_bytes_matched = ( int ) yr_min ( input_forwards_size , RE_SCAN_LIMIT ) ;}input -= character_size ;input_incr = - input_incr ;else {max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ;max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ;",831
1165,match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ;,"match = _yr_re_is_word_char ( input , character_size ) ;",831
1166,match = IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;match = ! IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;,"match = IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;match = ! _yr_re_is_word_char ( input , character_size ) ;action = match ? ACTION_NONE : ACTION_KILL ;",831
1167,case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 &&  ! ( flags & RE_FLAGS_NOT_AT_START ) &&  ! ( flags & RE_FLAGS_BACKWARDS ) )  match = TRUE ;else if ( bytes_matched >= max_bytes_matched )  match = TRUE ;else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) )  match = TRUE ;else match = FALSE ;case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS )  kill = input_size > ( size_t ) bytes_matched ;else  kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS ||  input_size > ( size_t ) bytes_matched ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;,"case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && input_backwards_size < character_size ) {match = TRUE ;}else if ( bytes_matched >= max_bytes_matched ) {match = TRUE ;}else {assert ( input < input_data + input_forwards_size ) ;assert ( input >= input_data - input_backwards_size ) ;assert ( input - input_incr < input_data + input_forwards_size ) ;assert ( input - input_incr >= input_data - input_backwards_size ) ;match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ;}case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS ) kill = input_backwards_size > ( size_t ) bytes_matched ;else kill = input_backwards_size > 0 || ( bytes_matched != 0 ) ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || input_forwards_size > ( size_t ) bytes_matched ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;",831
1168,"}if ( flags & RE_FLAGS_WIDE && bytes_matched < max_bytes_matched && * ( input + 1 ) != 0 ) {_yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ;","
",831
1169,"void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate ,  int * returndistortion , int * returnintra )  {","void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate , int * returndistortion , int * returnintra , int mb_row , int mb_col ) {",832
1170,"# if CONFIG_TEMPORAL_DENOISING  unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ,   best_rd_sse = INT_MAX ;# endif mode_mv = mode_mv_sb [ sign_bias ] ;best_mode . yrd = INT_MAX ;best_mode . intra_rd = INT_MAX ;vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ;vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ;vpx_memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ;get_reference_search_order ( cpi , ref_frame_map ) ;if ( ref_frame_map [ 1 ] > 0 ) {sign_bias = vp8_find_near_mvs_bias ( & x -> e_mbd , x -> e_mbd . mode_info_context , mode_mv_sb , best_ref_mv_sb , mdcounts , ref_frame_map [ 1 ] , cpi -> common . ref_frame_sign_bias ) ;mode_mv = mode_mv_sb [ sign_bias ] ;best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ;}get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ;* returnintra = INT_MAX ;x -> mbs_tested_so_far ++ ;x -> skip = 0 ;for ( mode_index = 0 ;mode_index < MAX_MODES ;mode_index ++ ) {int this_rd = INT_MAX ;int disable_skip = 0 ;int other_cost = 0 ;int this_ref_frame = ref_frame_map [ vp8_ref_frame_order [ mode_index ] ] ;if ( best_mode . rd <= x -> rd_threshes [ mode_index ] ) continue ;if ( this_ref_frame < 0 ) continue ;rd . rate2 = 0 ;rd . distortion2 = 0 ;this_mode = vp8_mode_order [ mode_index ] ;x -> e_mbd . mode_info_context -> mbmi . mode = this_mode ;x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ;if ( cpi -> is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) {if ( this_mode != ZEROMV || x -> e_mbd . mode_info_context -> mbmi . ref_frame != ALTREF_FRAME ) continue ;}if ( x -> e_mbd . mode_info_context -> mbmi . ref_frame ) {x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ;x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ;x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ;if ( sign_bias != cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ) {sign_bias = cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ;mode_mv = mode_mv_sb [ sign_bias ] ;best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ;}}if ( x -> mode_test_hit_counts [ mode_index ] && ( cpi -> mode_check_freq [ mode_index ] > 1 ) ) {if ( x -> mbs_tested_so_far <= cpi -> mode_check_freq [ mode_index ] * x -> mode_test_hit_counts [ mode_index ] ) {x -> rd_thresh_mult [ mode_index ] += 4 ;if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ;x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ;continue ;}}x -> mode_test_hit_counts [ mode_index ] ++ ;if ( x -> zbin_mode_boost_enabled ) {if ( this_ref_frame == INTRA_FRAME ) x -> zbin_mode_boost = 0 ;else {if ( vp8_mode_order [ mode_index ] == ZEROMV ) {if ( this_ref_frame != LAST_FRAME ) x -> zbin_mode_boost = GF_ZEROMV_ZBIN_BOOST ;else x -> zbin_mode_boost = LF_ZEROMV_ZBIN_BOOST ;}else if ( vp8_mode_order [ mode_index ] == SPLITMV ) x -> zbin_mode_boost = 0 ;else x -> zbin_mode_boost = MV_ZBIN_BOOST ;}vp8_update_zbin_extra ( cpi , x ) ;}if ( ! uv_intra_done && this_ref_frame == INTRA_FRAME ) {rd_pick_intra_mbuv_mode ( x , & uv_intra_rate , & uv_intra_rate_tokenonly , & uv_intra_distortion ) ;uv_intra_mode = x -> e_mbd . mode_info_context -> mbmi . uv_mode ;for ( i = 16 ;i < 24 ;i ++ ) uv_intra_tteob += x -> e_mbd . eobs [ i ] ;uv_intra_done = 1 ;}switch ( this_mode ) {case B_PRED : {int tmp_rd ;int distortion ;tmp_rd = rd_pick_intra4x4mby_modes ( x , & rate , & rd . rate_y , & distortion , best_mode . yrd ) ;rd . rate2 += rate ;rd . distortion2 += distortion ;if ( tmp_rd < best_mode . yrd ) {rd . rate2 += uv_intra_rate ;rd . rate_uv = uv_intra_rate_tokenonly ;rd . distortion2 += uv_intra_distortion ;rd . distortion_uv = uv_intra_distortion ;}else {this_rd = INT_MAX ;disable_skip = 1 ;}}break ;case SPLITMV : {int tmp_rd ;int this_rd_thresh ;int distortion ;this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 1 ) ? x -> rd_threshes [ THR_NEW1 ] : x -> rd_threshes [ THR_NEW3 ] ;this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 2 ) ? x -> rd_threshes [ THR_NEW2 ] : this_rd_thresh ;tmp_rd = vp8_rd_pick_best_mbsegmentation ( cpi , x , & best_ref_mv , best_mode . yrd , mdcounts , & rate , & rd . rate_y , & distortion , this_rd_thresh ) ;rd . rate2 += rate ;rd . distortion2 += distortion ;if ( tmp_rd < best_mode . yrd ) {rd_inter4x4_uv ( cpi , x , & rd . rate_uv , & rd . distortion_uv , cpi -> common . full_pixel ) ;rd . rate2 += rd . rate_uv ;rd . distortion2 += rd . distortion_uv ;}else {this_rd = INT_MAX ;disable_skip = 1 ;}}break ;case DC_PRED : case V_PRED : case H_PRED : case TM_PRED : {int distortion ;x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ;vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ;macro_block_yrd ( x , & rd . rate_y , & distortion ) ;rd . rate2 += rd . rate_y ;rd . distortion2 += distortion ;rd . rate2 += x -> mbmode_cost [ x -> e_mbd . frame_type ] [ x -> e_mbd . mode_info_context -> mbmi . mode ] ;rd . rate2 += uv_intra_rate ;rd . rate_uv = uv_intra_rate_tokenonly ;rd . distortion2 += uv_intra_distortion ;rd . distortion_uv = uv_intra_distortion ;}break ;case NEWMV : {int thissme ;int bestsme = INT_MAX ;int step_param = cpi -> sf . first_step ;int further_steps ;int n ;int do_refine = 1 ;int sadpb = x -> sadperbit16 ;int_mv mvp_full ;int col_min = ( ( best_ref_mv . as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ;int row_min = ( ( best_ref_mv . as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ;int col_max = ( best_ref_mv . as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ;int row_max = ( best_ref_mv . as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ;int tmp_col_min = x -> mv_col_min ;int tmp_col_max = x -> mv_col_max ;int tmp_row_min = x -> mv_row_min ;int tmp_row_max = x -> mv_row_max ;if ( ! saddone ) {vp8_cal_sad ( cpi , xd , x , recon_yoffset , & near_sadidx [ 0 ] ) ;saddone = 1 ;}vp8_mv_pred ( cpi , & x -> e_mbd , x -> e_mbd . mode_info_context , & mvp , x -> e_mbd . mode_info_context -> mbmi . ref_frame , cpi -> common . ref_frame_sign_bias , & sr , & near_sadidx [ 0 ] ) ;mvp_full . as_mv . col = mvp . as_mv . col >> 3 ;mvp_full . as_mv . row = mvp . as_mv . row >> 3 ;if ( x -> mv_col_min < col_min ) x -> mv_col_min = col_min ;if ( x -> mv_col_max > col_max ) x -> mv_col_max = col_max ;if ( x -> mv_row_min < row_min ) x -> mv_row_min = row_min ;if ( x -> mv_row_max > row_max ) x -> mv_row_max = row_max ;if ( sr > step_param ) step_param = sr ;{bestsme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ;mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ;n = 0 ;further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ;n = num00 ;num00 = 0 ;if ( n > further_steps ) do_refine = 0 ;while ( n < further_steps ) {n ++ ;if ( num00 ) num00 -- ;else {thissme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param + n , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ;if ( num00 > ( further_steps - n ) ) do_refine = 0 ;if ( thissme < bestsme ) {bestsme = thissme ;mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ;}else {d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ;}}}}if ( do_refine == 1 ) {int search_range ;search_range = 8 ;thissme = cpi -> refining_search_sad ( x , b , d , & d -> bmi . mv , sadpb , search_range , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ;if ( thissme < bestsme ) {bestsme = thissme ;mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ;}else {d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ;}}x -> mv_col_min = tmp_col_min ;x -> mv_col_max = tmp_col_max ;x -> mv_row_min = tmp_row_min ;x -> mv_row_max = tmp_row_max ;if ( bestsme < INT_MAX ) {int dis ;unsigned int sse ;cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & dis , & sse ) ;}mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ;rd . rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , x -> mvcost , 96 ) ;}case NEARESTMV : case NEARMV : vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ;if ( ( ( this_mode == NEARMV ) || ( this_mode == NEARESTMV ) ) && ( mode_mv [ this_mode ] . as_int == 0 ) ) continue ;case ZEROMV : if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) continue ;vp8_set_mbmode_and_mvs ( x , this_mode , & mode_mv [ this_mode ] ) ;this_rd = evaluate_inter_mode_rd ( mdcounts , & rd , & disable_skip , cpi , x ) ;break ;default : break ;}this_rd = calculate_final_rd_costs ( this_rd , & rd , & other_cost , disable_skip , uv_intra_tteob , intra_rd_penalty , cpi , x ) ;if ( ( x -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) && ( this_rd < best_mode . intra_rd ) ) {best_mode . intra_rd = this_rd ;* returnintra = rd . distortion2 ;}# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) {unsigned int sse ;vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & sse , mode_mv [ this_mode ] ) ;if ( sse < best_rd_sse ) best_rd_sse = sse ;if ( this_mode == ZEROMV && sse < zero_mv_sse ) {zero_mv_sse = sse ;x -> best_zeromv_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ;}if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && sse < best_sse ) {best_sse = sse ;vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & best_sse , mode_mv [ this_mode ] ) ;x -> best_sse_inter_mode = NEWMV ;x -> best_sse_mv = x -> e_mbd . mode_info_context -> mbmi . mv ;x -> need_to_clamp_best_mvs = x -> e_mbd . mode_info_context -> mbmi . need_to_clamp_mvs ;x -> best_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ;}}# endif if ( this_rd < best_mode . rd || x -> skip ) {best_mode_index = mode_index ;* returnrate = rd . rate2 ;* returndistortion = rd . distortion2 ;if ( this_mode <= B_PRED ) {x -> e_mbd . mode_info_context -> mbmi . uv_mode = uv_intra_mode ;x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ;}update_best_mode ( & best_mode , this_rd , & rd , other_cost , x ) ;","# if CONFIG_TEMPORAL_DENOISING unsigned int zero_mv_sse = UINT_MAX , best_sse = INT_MAX , best_rd_sse = UINT_MAX ;# endif mode_mv = mode_mv_sb [ sign_bias ] ;memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ;vpx_memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ;memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ;memset ( & best_mode , this_rd , & rd , other_cost , x ) ;",832
1171,"if ( x -> best_sse_inter_mode == DC_PRED )  {vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse ,  recon_yoffset , recon_uvoffset ) ;if ( best_mode . mbmode . ref_frame == INTRA_FRAME && x -> best_zeromv_reference_frame != INTRA_FRAME ) {","int block_index = mb_row * cpi -> common . mb_cols + mb_col ;if ( x -> best_sse_inter_mode == DC_PRED ) {vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , recon_yoffset , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index ) ;if ( best_mode . mbmode . ref_frame == INTRA_FRAME && x -> best_zeromv_reference_frame != INTRA_FRAME ) {",832
1172,best_mode_index = mode_index ;* returnrate = rd . rate2 ;,best_mode_index = mode_index ;* returnrate = rd . rate2 ;,832
1173,"vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ;if ( best_mode . mbmode . mode == B_PRED ) {","vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ;if ( best_mode . mbmode . mode == B_PRED ) {",832
1174,"vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ;x -> e_mbd . mode_info_context -> mbmi . mv . as_int = x -> partition_info -> bmi [ 15 ] . mv . as_int ;","vpx_memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ;x -> e_mbd . mode_info_context -> mbmi . mv . as_int = x -> partition_info -> bmi [ 15 ] . mv . as_int ;",832
1175,"set_exception_intercept ( svm , MC_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;","set_exception_intercept ( svm , MC_VECTOR ) ;set_exception_intercept ( svm , AC_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;",833
1176,h -> size = statbuf . st_size ;if ( ! h -> writable ) {,"h -> size = statbuf . st_size ;if ( h -> size < 0x2000 ) {SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ;goto error ;}if ( ! h -> writable ) {",834
1177,"private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h ,  const cdf_stream_t * sst , const uint64_t clsid [ 2 ] )  {","private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , const cdf_stream_t * sst , const cdf_directory_t * root_storage ) {",835
1178,"str = cdf_clsid_to_mime ( clsid , clsid2desc ) ;if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 )  return - 2 ;}m = cdf_file_property_info ( ms , info , count , clsid ) ;free ( info ) ;","if ( root_storage ) {str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid , clsid2desc ) ;if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 ) return - 2 ;}}m = cdf_file_property_info ( ms , info , count , root_storage ) ;free ( info ) ;",835
1179,"UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ;UWORD16 i2_max_frm_num ;","UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 ;UWORD16 i2_max_frm_num ;",836
1180,"if ( ! u1_frm )  {u2_pic_ht <<= 1 ;ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ;","if ( ! u1_frm ) u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) {ps_dec -> u1_res_changed = 1 ;return IVD_RES_CHANGED ;}if ( ! u1_frm ) {u2_pic_ht <<= 1 ;ps_seq -> u1_mb_aff_flag = u1_mb_aff_flag ;COPYTHECONTEXT ( ""SPS:<S2SV_blank>mb_adaptive_frame_field_flag"" , ps_seq -> u1_mb_aff_flag ) ;",836
1181,"err |= get_user ( length , & up -> length ) ;up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ;","err |= get_user ( length , & up -> length ) ;if ( err ) return - EFAULT ;up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ;",837
1182,"static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {VP9_COMP * const cpi = ctx -> cpi ;vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ;if ( params == NULL )  return VPX_CODEC_INVALID_PARAM ;cpi -> svc . spatial_layer_id = params -> spatial_layer ;cpi -> svc . temporal_layer_id = params -> temporal_layer ;cpi -> lst_fb_idx = params -> lst_fb_idx ;cpi -> gld_fb_idx = params -> gld_fb_idx ;cpi -> alt_fb_idx = params -> alt_fb_idx ;if ( vp9_set_size_literal ( ctx -> cpi , params -> width , params -> height ) != 0 ) return VPX_CODEC_INVALID_PARAM ;ctx -> cfg . rc_max_quantizer = params -> max_quantizer ;ctx -> cfg . rc_min_quantizer = params -> min_quantizer ;set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;","static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , va_list args ) {VP9_COMP * const cpi = ctx -> cpi ;vpx_svc_extra_cfg_t * const params = va_arg ( args , vpx_svc_extra_cfg_t * ) ;if ( params == NULL ) return VPX_CODEC_INVALID_PARAM ;cpi -> svc . number_spatial_layers ;++ sl ) {for ( tl = 0 ;tl < cpi -> svc . number_temporal_layers ;++ tl ) {const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ;LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ;lc -> max_q = params -> max_quantizers [ sl ] ;lc -> min_q = params -> min_quantizers [ sl ] ;lc -> scaling_factor_num = params -> scaling_factor_num [ sl ] ;lc -> scaling_factor_den = params -> scaling_factor_den [ sl ] ;}}",838
1183,"found :  if ( prev ) {int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ;if ( i > 0 ) {offset += i ;while ( next && FRAG6_CB ( next ) -> offset < end ) {int i = end - FRAG6_CB ( next ) -> offset ;if ( i < next -> len ) {if ( ! pskb_pull ( next , i ) ) goto err ;FRAG6_CB ( next ) -> offset += i ;fq -> q . meat -= i ;if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ;break ;}else {struct sk_buff * free_it = next ;next = next -> next ;if ( prev ) prev -> next = next ;else fq -> q . fragments = next ;fq -> q . meat -= free_it -> len ;frag_kfree_skb ( fq -> q . net , free_it ) ;}}",found : if ( prev && ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset > 0 ) {offset += i ;while ( next && FRAG6_CB ( next ) -> offset < end ) goto discard_fq ;,839
1184,"err :  IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ;","discard_fq : fq_kill ( fq ) ;err : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ;",839
1185,"uint16 bitspersample , samplesperpixel ;uint16 input_compression , input_photometric ;copyFunc cf ;","uint16 bitspersample , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;copyFunc cf ;",840
1186,# if ! defined ( HAVE_LSTAT )  ( void ) a ;return ( ARCHIVE_OK ) ;# else char * pn ;char c ;int r ;struct stat st ;pn = a -> name ;if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) {,struct archive_string error_string ;int error_number ;int rc ;archive_string_init ( & error_string ) ;rc = check_symlinks_fsobj ( a -> path_safe ) ) > 0 ) {,841
1187,"r = lstat ( a -> name , & st ) ;if ( r != 0 ) {if ( errno == ENOENT ) {break ;}else {return ( ARCHIVE_FAILED ) ;}}else if ( S_ISLNK ( st . st_mode ) ) {if ( c == \'\\\\0\' ) {if ( unlink ( a -> name ) ) {archive_set_error ( & a -> archive , errno ,  ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ;}a -> pst = NULL ;if ( ! S_ISLNK ( a -> mode ) ) {archive_set_error ( & a -> archive , 0 , ""Removing<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ;","r = lstat ( a -> name , & error_number , & error_string , a -> flags ) ;if ( rc != ARCHIVE_OK ) {archive_set_error ( & a -> archive , errno , ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ;a -> pst = NULL ;if ( ! S_ISLNK ( a -> mode ) ) {archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ;}archive_string_free ( & error_string ) ;",841
1188,"else {archive_set_error ( & a -> archive , 0 , ""Cannot<S2SV_blank>extract<S2SV_blank>through<S2SV_blank>symlink<S2SV_blank>%s"" , a -> name ) ;pn [ 0 ] = c ;return ( ARCHIVE_FAILED ) ;}}pn [ 0 ] = c ;if ( pn [ 0 ] != \'\\\\0\' ) pn ++ ;}pn [ 0 ] = c ;archive_strcpy ( & a -> path_safe , a -> name ) ;return ( ARCHIVE_OK ) ;# endif }",return rc ;,841
1189,"if ( ret < 0 || ret >= MAXPATHLEN ) {ERROR ( ""Error<S2SV_blank>calculating<S2SV_blank>container<S2SV_blank>/dev<S2SV_blank>location"" ) ;return - 1 ;}if ( ! dir_exists ( path ) ) return 0 ;INFO ( ""Populating<S2SV_blank>container<S2SV_blank>/dev"" ) ;cmask = umask ( S_IXUSR | S_IXGRP | S_IXOTH ) ;for ( i = 0 ;i < sizeof ( lxc_devs ) / sizeof ( lxc_devs [ 0 ] ) ;i ++ ) {const struct lxc_devs * d = & lxc_devs [ i ] ;ret = snprintf ( path , MAXPATHLEN , ""%s/dev/%s"" , rootfs -> path ? rootfs -> mount : """" , d -> name ) ;if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ;ret = mknod ( path , d -> mode , makedev ( d -> maj , d -> min ) ) ;if ( ret && errno != EEXIST ) {char hostpath [ MAXPATHLEN ] ;FILE * pathfile ;ret = snprintf ( hostpath , MAXPATHLEN , ""/dev/%s"" , d -> name ) ;if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ;pathfile = fopen ( path , ""wb"" ) ;if ( ! pathfile ) {SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>device<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\\\'%s\\\'"" , path ) ;return - 1 ;}fclose ( pathfile ) ;if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) {SYSERROR ( ""Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container"" , d -> name ) ;","if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : NULL ) != 0 ) {SYSERROR ( ""Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container"" , d -> name ) ;",842
1190,"struct buffer_head * bh = NULL ;struct fileEntry * fe ;struct extendedFileEntry * efe ;uint16_t ident ;struct udf_inode_info * iinfo = UDF_I ( inode ) ;struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ;unsigned int link_count ;bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ;if ( ! bh ) {udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\\make_bad_inode ( inode ) ;return ;}if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) {udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\\brelse ( bh ) ;make_bad_inode ( inode ) ;return ;}fe = ( struct fileEntry * ) bh -> b_data ;efe = ( struct extendedFileEntry * ) bh -> b_data ;if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) {struct buffer_head * ibh ;ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ;if ( ident == TAG_IDENT_IE && ibh ) {struct buffer_head * nbh = NULL ;struct kernel_lb_addr loc ;if ( ie -> indirectICB . extLength &&   ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 ,  & ident ) ) ) {","struct kernel_lb_addr loc ;if ( ie -> indirectICB . extLength && ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , & ident ) ) ) {",843
1191,brelse ( nbh ) ;},brelse ( nbh ) ;},843
1192,"const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ;const int filter_level = get_filter_level ( lfi_n , mbmi ) ;","const TX_SIZE tx_size_uv = get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 ) ;const int filter_level = get_filter_level ( lfi_n , mbmi ) ;",844
1193,"vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ;index += 8 ;","memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ;index += 8 ;",844
1194,* above_y |= ( size_mask [ block_size ] & above_64x64_txform_mask [ tx_size_y ] ) << shift_y ;if ( tx_size_y == TX_4X4 )  * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ;if ( tx_size_uv == TX_4X4 ) * int_4x4_uv |= ( size_mask_uv [ block_size ] & 0xffff ) << shift_uv ;,* above_y |= ( size_mask [ block_size ] & 0xffffffffffffffffULL ) << shift_y ;if ( tx_size_y == TX_4X4 ) * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ;if ( tx_size_uv == TX_4X4 ) * int_4x4_uv |= ( size_mask_uv [ block_size ] & 0xffff ) << shift_uv ;,844
1195,"int namelen = strlen ( name ) ;int len ;while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) {len = ff_amf_tag_size ( data , data_end ) ;if ( len < 0 )  len = data_end - data ;data ++ ;for ( ;if ( ! size )  break ;if ( size < 0 || size >= data_end - data ) return - 1 ;if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) {switch ( * data ++ ) {case AMF_DATA_TYPE_NUMBER :  snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ;break ;case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ;break ;case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ;av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ;break ;default : return - 1 ;}return 0 ;}len = ff_amf_tag_size ( data , data_end ) ;if ( len < 0 || len >= data_end - data ) return - 1 ;data += len ;}return - 1 ;","GetByteContext gb ;if ( len < 0 ) len = data_end - data ;data ++ ;for ( ;if ( data >= data_end ) return - 1 ;if ( size == namelen && ! memcmp ( data - size , name , dst , dst_size ) ;",845
1196,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",846
1197,"spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;flush_rq -> tag = - 1 ;","struct blk_mq_hw_ctx * hctx ;spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ;blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq ) ;flush_rq -> tag = - 1 ;",847
1198,"k -> get_config ( vdev , vdev -> config ) ;if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ;","if ( addr + sizeof ( val ) > vdev -> config_len ) {return ( uint32_t ) - 1 ;}k -> get_config ( vdev , vdev -> config ) ;",848
1199,"return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ;}","return match ( prog -> start , sp , sp , prog -> flags | eflags , sub , 0 ) ;}",849
1200,"static void  swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horDiff16 ( tif , cp0 , cc ) ;TIFFSwabArrayOfShort ( wp , wc ) ;}","static int swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ! horDiff16 ( tif , cp0 , cc ) ) return 0 ;TIFFSwabArrayOfShort ( wp , wc ) ;return 1 ;}",850
1201,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",851
1202,int err ;if ( rt ) return 0 ;daddr = inet -> inet_daddr ;if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;,struct ip_options_rcu * inet_opt ;int err ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;rcu_read_unlock ( ) ;,852
1203,"void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType )  {","static void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {",853
1204,"pid_t pid ;memset ( s_path , 0 , sizeof ( s_path ) ) ;memset ( c_path , 0 , sizeof ( c_path ) ) ;pid = getpid ( ) ;","memset ( s_path , 0 , sizeof ( s_path ) ) ;memset ( c_path , 0 , sizeof ( c_path ) ) ;",854
1205,"sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix ,   hdl -> instance , ( long unsigned ) pid ) ;if ( * mgr_hdl == NULL ) {","sprintf ( c_path , ""%s%s%d_C_XXXXXX"" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ;if ( * mgr_hdl == NULL ) {",854
1206,case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) return - EINVAL ;,case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - ) return - EINVAL ;,855
1207,"if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL ||  * replySize < ( int ) sizeof ( effect_param_t ) ) {ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>args"" ) ;","if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL || * replySize < ( int ) sizeof ( effect_param_t ) ) {ALOGV ( ""fx_command()<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>args"" ) ;",855
1208,"( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;page_geometry = DestroyString ( page_geometry ) ;image = DestroyImage ( image ) ;",856
1209,"if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ;if ( get_user ( len , optlen ) ) return - EFAULT ;switch ( optname ) {case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ;if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ;val = sk -> sk_family ;break ;case MCAST_MSFILTER : {struct group_filter gsf ;int err ;if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ;if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ;if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ;lock_sock ( sk ) ;err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ;release_sock ( sk ) ;return err ;}case IPV6_2292PKTOPTIONS : {struct msghdr msg ;struct sk_buff * skb ;if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ;msg . msg_control = optval ;msg . msg_controllen = len ;msg . msg_flags = flags ;lock_sock ( sk ) ;skb = np -> pktoptions ;if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ;release_sock ( sk ) ;if ( ! skb ) {if ( np -> rxopt . bits . rxinfo ) {struct in6_pktinfo src_info ;src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ;src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ;put_cmsg ( & msg , SOL_IPV6 , IPV6_PKTINFO , sizeof ( src_info ) , & src_info ) ;}if ( np -> rxopt . bits . rxhlim ) {int hlim = np -> mcast_hops ;put_cmsg ( & msg , SOL_IPV6 , IPV6_HOPLIMIT , sizeof ( hlim ) , & hlim ) ;}if ( np -> rxopt . bits . rxtclass ) {int tclass = ( int ) ip6_tclass ( np -> rcv_flowinfo ) ;put_cmsg ( & msg , SOL_IPV6 , IPV6_TCLASS , sizeof ( tclass ) , & tclass ) ;}if ( np -> rxopt . bits . rxoinfo ) {struct in6_pktinfo src_info ;src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : np -> sticky_pktinfo . ipi6_ifindex ;src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ;put_cmsg ( & msg , SOL_IPV6 , IPV6_2292PKTINFO , sizeof ( src_info ) , & src_info ) ;}if ( np -> rxopt . bits . rxohlim ) {int hlim = np -> mcast_hops ;put_cmsg ( & msg , SOL_IPV6 , IPV6_2292HOPLIMIT , sizeof ( hlim ) , & hlim ) ;}if ( np -> rxopt . bits . rxflow ) {__be32 flowinfo = np -> rcv_flowinfo ;put_cmsg ( & msg , SOL_IPV6 , IPV6_FLOWINFO , sizeof ( flowinfo ) , & flowinfo ) ;}}len -= msg . msg_controllen ;return put_user ( len , optlen ) ;}case IPV6_MTU : {struct dst_entry * dst ;val = 0 ;rcu_read_lock ( ) ;dst = __sk_dst_get ( sk ) ;if ( dst ) val = dst_mtu ( dst ) ;rcu_read_unlock ( ) ;if ( ! val ) return - ENOTCONN ;break ;}case IPV6_V6ONLY : val = sk -> sk_ipv6only ;break ;case IPV6_RECVPKTINFO : val = np -> rxopt . bits . rxinfo ;break ;case IPV6_2292PKTINFO : val = np -> rxopt . bits . rxoinfo ;break ;case IPV6_RECVHOPLIMIT : val = np -> rxopt . bits . rxhlim ;break ;case IPV6_2292HOPLIMIT : val = np -> rxopt . bits . rxohlim ;break ;case IPV6_RECVRTHDR : val = np -> rxopt . bits . srcrt ;break ;case IPV6_2292RTHDR : val = np -> rxopt . bits . osrcrt ;break ;case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : {lock_sock ( sk ) ;len = ipv6_getsockopt_sticky ( sk , np -> opt ,  optname , optval , len ) ;","if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , opt , optname , optval , len ) ;",857
1210,currkvno = key_data [ i ] . key_data_kvno ;},if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ;},858
1211,"L3 = emitjump ( J , F , OP_JUMP ) ;}","emit ( J , F , OP_ENDTRY ) ;L3 = emitjump ( J , F , OP_JUMP ) ;}",859
1212,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,860
1213,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",860
1214,"
",LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;,860
1215,l_row -- ;l_column -- ;,l_row -- ;l_column -- ;,860
1216,"memcpy ( sbuf + 1 , crgram , crgram_len ) ;r = sc_transmit_apdu ( card , & apdu ) ;","if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ;memcpy ( sbuf + 1 , crgram , crgram_len ) ;r = sc_transmit_apdu ( card , & apdu ) ;",861
1217,"int length ;STREAM s ;RD_BOOL is_fastpath ;ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ;ber_parse_header ( s , BER_TAG_RESULT , & length ) ;","uint32 length ;STREAM s ;struct stream packet ;RD_BOOL is_fastpath ;packet = * s ;ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}ber_parse_header ( s , BER_TAG_RESULT , & length ) ;",862
1218,"mcs_parse_domain_params ( s ) ;ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ;","mcs_parse_domain_params ( s ) ;ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ;",862
1219,"cleanup :  assert ( status != NULL ) ;if ( reply_key ) krb5_free_keyblock ( kdc_context , reply_key ) ;","cleanup : if ( status == NULL ) status = ""UNKNOWN_REASON"" ;if ( reply_key ) krb5_free_keyblock ( kdc_context , reply_key ) ;",863
1220,"if ( ( ctxt -> options & XML_PARSE_OLD10 ) == 0 ) {if ( ( c == \'<S2SV_blank>\' ) || ( c == \'>\' ) || ( c == \'/\' ) || ( ! ( ( ( c >= \'a\' ) && ( c <= \'z\' ) ) || ( ( c >= \'A\' ) && ( c <= \'Z\' ) ) || ( c == \'_\' ) || ( c == \':\' ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) ) {return ( NULL ) ;len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;while ( ( c != \'<S2SV_blank>\' ) && ( c != \'>\' ) && ( c != \'/\' ) && ( ( ( c >= \'a\' ) && ( c <= \'z\' ) ) || ( ( c >= \'A\' ) && ( c <= \'Z\' ) ) || ( ( c >= \'0\' ) && ( c <= \'9\' ) ) || ( c == \'_\' ) || ( c == \':\' ) || ( c == \'-\' ) || ( c == \'.\' ) || ( c == 0xB7 ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x300 ) && ( c <= 0x36F ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x203F ) && ( c <= 0x2040 ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) {if ( count ++ > XML_PARSER_CHUNK_SIZE ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;}len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;}else {if ( ( c == \'<S2SV_blank>\' ) || ( c == \'>\' ) || ( c == \'/\' ) || ( ! IS_LETTER ( c ) && ( c != \'_\' ) && ( c != \':\' ) ) ) {len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;while ( ( c != \'<S2SV_blank>\' ) && ( c != \'>\' ) && ( c != \'/\' ) && ( ( IS_LETTER ( c ) ) || ( IS_DIGIT ( c ) ) || ( c == \'.\' ) || ( c == \'-\' ) || ( c == \'_\' ) || ( c == \':\' ) || ( IS_COMBINING ( c ) ) || ( IS_EXTENDER ( c ) ) ) ) {if ( count ++ > XML_PARSER_CHUNK_SIZE ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;}len += l ;NEXTL ( l ) ;c = CUR_CHAR ( l ) ;if ( c == 0 ) {count = 0 ;GROW ;if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ;c = CUR_CHAR ( l ) ;}}}if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) {xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ;return ( NULL ) ;","if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) {xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ;if ( ctxt -> input -> cur - ctxt -> input -> base < len ) {xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , ""unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"" ) ;return ( NULL ) ;",864
1221,"
",kfree ( ch ) ;,865
1222,goto err_free ;},goto err_free ;},865
1223,"if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Cherry<S2SV_blank>Cymotion<S2SV_blank>report<S2SV_blank>descriptor\\\","if ( * rsize >= 18 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Cherry<S2SV_blank>Cymotion<S2SV_blank>report<S2SV_blank>descriptor\\\",866
1224,"if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) )  goto out ;","if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) goto out ;",867
1225,"if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) {memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ;","ret = sort_idmaps ( & new_map ) ;if ( ret < 0 ) goto out ;if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) {memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ;",867
1226,},return - 1 ;},868
1227,smb_ofile_t * of = NULL ;uint16_t StructSize ;,uint16_t StructSize ;,869
1228,"of = sr -> fid_ofile ;if ( ( of -> f_node -> flags & NODE_FLAGS_WRITE_THROUGH ) == 0 ) ( void ) smb_fsop_commit ( sr , of -> f_cr , of -> f_node ) ;","smb_ofile_flush ( sr , sr -> fid_ofile ;if ( ( of -> f_node -> flags & NODE_FLAGS_WRITE_THROUGH ) == 0 ) ( void ) smb_fsop_commit ( sr , of -> f_cr , of -> f_node ) ;",869
1229,uchar * dataptr ;uint_fast32_t datacnt ;,jas_uchar * dataptr ;uint_fast32_t datacnt ;,870
1230,"vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;xd -> left_available = 0 ;","memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;xd -> left_available = 0 ;if ( xd -> mode_info_context -> mbmi . ref_frame >= LAST_FRAME ) {const MV_REFERENCE_FRAME ref = xd -> mode_info_context -> mbmi . ref_frame ;",871
1231,xd -> pre . y_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 0 ] + recon_yoffset ;xd -> pre . u_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 1 ] + recon_uvoffset ;xd -> pre . v_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 2 ] + recon_uvoffset ;xd -> corrupted |= ref_fb_corrupted [ xd -> mode_info_context -> mbmi . ref_frame ] ;,xd -> pre . y_buffer = ref_buffer [ ref ] [ 0 ] + recon_yoffset ;xd -> pre . u_buffer = ref_buffer [ ref ] [ 1 ] + recon_uvoffset ;xd -> pre . v_buffer = ref_buffer [ ref ] [ 2 ] + recon_uvoffset ;}else {xd -> pre . y_buffer = 0 ;xd -> pre . u_buffer = 0 ;xd -> pre . v_buffer = 0 ;}xd -> corrupted |= ref_fb_corrupted [ xd -> mode_info_context -> mbmi . ref_frame ] ;,871
1232,addr -> addrtype = TIPC_ADDR_ID ;addr -> addr . id . ref = msg_origport ( msg ) ;,"addr -> addrtype = TIPC_ADDR_ID ;memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) ) ;addr -> addr . id . ref = msg_origport ( msg ) ;",872
1233,if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) )  goto out ;,"if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size ) ) ) goto out ;",873
1234,}clone_info = CloneImageInfo ( image_info ) ;,}quantum_info = ( QuantumInfo * ) NULL ;clone_info = CloneImageInfo ( image_info ) ;,874
1235,"InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ;","if ( quantum_info != ( QuantumInfo * ) NULL ) InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ;",874
1236,quantum_info = DestroyQuantumInfo ( quantum_info ) ;END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ;,quantum_info = DestroyQuantumInfo ( quantum_info ) ;END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ;,874
1237,"if ( strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) {","if ( tmp_line_len >= 1 && strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) {",875
1238,if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ;,if ( tmp_line_len >= 1 && use_ssl && resource -> port == 0 ) resource -> port = 443 ;,875
1239,"if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""timeout"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_double_ex ( tmpzval ) ;timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ;timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ;}else {timeout . tv_sec = FG ( default_socket_timeout ) ;timeout . tv_usec = 0 ;}stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ;if ( stream ) {php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ;}if ( errstr ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""%s"" , errstr ) ;efree ( errstr ) ;errstr = NULL ;}efree ( transport_string ) ;if ( stream && use_proxy && use_ssl ) {smart_str header = {0 };if ( ! context || php_stream_context_get_option ( context , ""ssl"" , ""peer_name"" , & tmpzval ) == FAILURE ) {MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ;ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ;php_stream_context_set_option ( stream -> context , ""ssl"" , ""peer_name"" , ssl_proxy_peer_name ) ;}smart_str_appendl ( & header , ""CONNECT<S2SV_blank>"" , sizeof ( ""CONNECT<S2SV_blank>"" ) - 1 ) ;smart_str_appends ( & header , resource -> host ) ;smart_str_appendc ( & header , \':\' ) ;smart_str_append_unsigned ( & header , resource -> port ) ;smart_str_appendl ( & header , ""<S2SV_blank>HTTP/1.0\\\\r\\\if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) {char * s , * p ;if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) {HashPosition pos ;zval * * tmpheader = NULL ;for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ;SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ;zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) {if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) {s = Z_STRVAL_PP ( tmpheader ) ;do {while ( * s == \'<S2SV_blank>\' || * s == \'\\\\t\' ) s ++ ;p = s ;while ( * p != 0 && * p != \':\' && * p != \'\\\\r\' && * p != \'\\\if ( * p == \':\' ) {p ++ ;if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) {while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\smart_str_appendl ( & header , s , p - s ) ;smart_str_appendl ( & header , ""\\\\r\\\goto finish ;}else {while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\}}s = p ;while ( * s == \'\\\\r\' || * s == \'\\\}while ( * s != 0 ) ;}}}else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) {s = Z_STRVAL_PP ( tmpzval ) ;do {while ( * s == \'<S2SV_blank>\' || * s == \'\\\\t\' ) s ++ ;p = s ;while ( * p != 0 && * p != \':\' && * p != \'\\\\r\' && * p != \'\\\if ( * p == \':\' ) {p ++ ;if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) {while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\smart_str_appendl ( & header , s , p - s ) ;smart_str_appendl ( & header , ""\\\\r\\\goto finish ;}else {while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\}}s = p ;while ( * s == \'\\\\r\' || * s == \'\\\}while ( * s != 0 ) ;}}finish : smart_str_appendl ( & header , ""\\\\r\\\if ( php_stream_write ( stream , header . c , header . len ) != header . len ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ;php_stream_close ( stream ) ;stream = NULL ;}smart_str_free ( & header ) ;if ( stream ) {char header_line [ HTTP_HEADER_BLOCK_SIZE ] ;while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) {if ( header_line [ 0 ] == \'\\\break ;}}}if ( stream ) {if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ;php_stream_close ( stream ) ;stream = NULL ;}}}if ( stream == NULL ) goto out ;if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ;eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;php_stream_context_set ( stream , context ) ;php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ;if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""max_redirects"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_long_ex ( tmpzval ) ;redirect_max = Z_LVAL_PP ( tmpzval ) ;}if ( context && php_stream_context_get_option ( context , ""http"" , ""method"" , & tmpzval ) == SUCCESS ) {if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( ""GET"" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( ""HEAD"" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) {scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ;scratch = emalloc ( scratch_len ) ;strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ;strncat ( scratch , ""<S2SV_blank>"" , 1 ) ;}}}if ( context && php_stream_context_get_option ( context , ""http"" , ""protocol_version"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_double_ex ( tmpzval ) ;protocol_version_len = spprintf ( & protocol_version , 0 , ""%.1F"" , Z_DVAL_PP ( tmpzval ) ) ;}if ( ! scratch ) {scratch_len = strlen ( path ) + 29 + protocol_version_len ;scratch = emalloc ( scratch_len ) ;strncpy ( scratch , ""GET<S2SV_blank>"" , scratch_len ) ;}if ( ! request_fulluri && context && php_stream_context_get_option ( context , ""http"" , ""request_fulluri"" , & tmpzval ) == SUCCESS ) {zval ztmp = * * tmpzval ;zval_copy_ctor ( & ztmp ) ;convert_to_boolean ( & ztmp ) ;request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ;zval_dtor ( & ztmp ) ;}if ( request_fulluri ) {strcat ( scratch , path ) ;}else {if ( resource -> path && * resource -> path ) {strlcat ( scratch , resource -> path , scratch_len ) ;}else {strlcat ( scratch , ""/"" , scratch_len ) ;}if ( resource -> query ) {strlcat ( scratch , ""?"" , scratch_len ) ;strlcat ( scratch , resource -> query , scratch_len ) ;}}if ( protocol_version ) {strlcat ( scratch , ""<S2SV_blank>HTTP/"" , scratch_len ) ;strlcat ( scratch , protocol_version , scratch_len ) ;strlcat ( scratch , ""\\\\r\\\}else {strlcat ( scratch , ""<S2SV_blank>HTTP/1.0\\\\r\\\}php_stream_write ( stream , scratch , strlen ( scratch ) ) ;if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) {tmp = NULL ;if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) {HashPosition pos ;zval * * tmpheader = NULL ;smart_str tmpstr = {0 };for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ;SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ;zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) {if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) {smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ;smart_str_appendl ( & tmpstr , ""\\\\r\\\}}smart_str_0 ( & tmpstr ) ;if ( tmpstr . c ) {tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ;smart_str_free ( & tmpstr ) ;}}if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) {tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ;}if ( tmp && strlen ( tmp ) > 0 ) {char * s ;user_headers = estrdup ( tmp ) ;php_strtolower ( tmp , strlen ( tmp ) ) ;if ( ! header_init ) {strip_header ( user_headers , tmp , ""content-length:"" ) ;strip_header ( user_headers , tmp , ""content-type:"" ) ;}if ( ( s = strstr ( tmp , ""user-agent:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_USER_AGENT ;}if ( ( s = strstr ( tmp , ""host:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_HOST ;}if ( ( s = strstr ( tmp , ""from:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_FROM ;}if ( ( s = strstr ( tmp , ""authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_AUTH ;}if ( ( s = strstr ( tmp , ""content-length:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_CONTENT_LENGTH ;}if ( ( s = strstr ( tmp , ""content-type:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_TYPE ;}if ( ( s = strstr ( tmp , ""connection:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_CONNECTION ;}if ( use_proxy && use_ssl && ( s = strstr ( tmp , ""proxy-authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\char * p = s + sizeof ( ""proxy-authorization:"" ) - 1 ;while ( s > tmp && ( * ( s - 1 ) == \'<S2SV_blank>\' || * ( s - 1 ) == \'\\\\t\' ) ) s -- ;while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\while ( * p == \'\\\\r\' || * p == \'\\\if ( * p == 0 ) {if ( s == tmp ) {efree ( user_headers ) ;user_headers = NULL ;}else {while ( s > tmp && ( * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\user_headers [ s - tmp ] = 0 ;}}else {memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ;}}}if ( tmp ) {efree ( tmp ) ;}}if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) {php_url_decode ( resource -> user , strlen ( resource -> user ) ) ;strcpy ( scratch , resource -> user ) ;strcat ( scratch , "":"" ) ;if ( resource -> pass ) {php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ;strcat ( scratch , resource -> pass ) ;}tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ;if ( snprintf ( scratch , scratch_len , ""Authorization:<S2SV_blank>Basic<S2SV_blank>%s\\\\r\\\php_stream_write ( stream , scratch , strlen ( scratch ) ) ;php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;}efree ( tmp ) ;tmp = NULL ;}if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) {if ( snprintf ( scratch , scratch_len , ""From:<S2SV_blank>%s\\\\r\\\}if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) {if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) {if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s:%i\\\\r\\\}else {if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s\\\\r\\\php_stream_write ( stream , scratch , strlen ( scratch ) ) ;}}}if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) {php_stream_write_string ( stream , ""Connection:<S2SV_blank>close\\\\r\\\}if ( context && php_stream_context_get_option ( context , ""http"" , ""user_agent"" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) {ua_str = Z_STRVAL_PP ( ua_zval ) ;}else if ( FG ( user_agent ) ) {ua_str = FG ( user_agent ) ;}if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) {# define _UA_HEADER ""User-Agent:<S2SV_blank>%s\\\\r\\\size_t ua_len ;ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ;if ( ua_len > sizeof ( _UA_HEADER ) ) {ua = emalloc ( ua_len + 1 ) ;if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) {ua [ ua_len ] = 0 ;php_stream_write ( stream , ua , ua_len ) ;}else {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Cannot<S2SV_blank>construct<S2SV_blank>User-agent<S2SV_blank>header"" ) ;}if ( ua ) {efree ( ua ) ;}}}if ( user_headers ) {if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\\\r\\\php_stream_write ( stream , scratch , scratch_len ) ;have_header |= HTTP_HEADER_CONTENT_LENGTH ;}php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ;php_stream_write ( stream , ""\\\\r\\\efree ( user_headers ) ;}if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) {scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\\\r\\\php_stream_write ( stream , scratch , scratch_len ) ;}if ( ! ( have_header & HTTP_HEADER_TYPE ) ) {php_stream_write ( stream , ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\\\r\\\php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Content-type<S2SV_blank>not<S2SV_blank>specified<S2SV_blank>assuming<S2SV_blank>application/x-www-form-urlencoded"" ) ;}php_stream_write ( stream , ""\\\\r\\\php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ;}else {php_stream_write ( stream , ""\\\\r\\\}location [ 0 ] = \'\\\\0\' ;if ( ! EG ( active_symbol_table ) ) {zend_rebuild_symbol_table ( TSRMLS_C ) ;}if ( header_init ) {zval * ztmp ;MAKE_STD_ZVAL ( ztmp ) ;array_init ( ztmp ) ;ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , ""http_response_header"" , ztmp ) ;}{zval * * rh ;if ( zend_hash_find ( EG ( active_symbol_table ) , ""http_response_header"" , sizeof ( ""http_response_header"" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>http_response_header<S2SV_blank>overwritten"" ) ;goto out ;}response_header = * rh ;Z_ADDREF_P ( response_header ) ;}if ( ! php_stream_eof ( stream ) ) {size_t tmp_line_len ;if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) {zval * http_response ;if ( tmp_line_len > 9 ) {response_code = atoi ( tmp_line + 9 ) ;}else {response_code = 0 ;}if ( context && SUCCESS == php_stream_context_get_option ( context , ""http"" , ""ignore_errors"" , & tmpzval ) ) {ignore_errors = zend_is_true ( * tmpzval ) ;}if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) {reqok = 1 ;}if ( response_code >= 100 && response_code < 200 ) {while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( ""HTTP/1"" ) - 1 || strncasecmp ( tmp_line , ""HTTP/1"" , sizeof ( ""HTTP/1"" ) - 1 ) ) ) ;if ( tmp_line_len > 9 ) {response_code = atoi ( tmp_line + 9 ) ;}else {response_code = 0 ;}}if ( response_code >= 200 && response_code < 400 ) {reqok = 1 ;}else {switch ( response_code ) {case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ;break ;default : if ( ! tmp_line_len ) {tmp_line [ 0 ] = \'\\\\0\' ;}php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ;}}if ( tmp_line [ tmp_line_len - 1 ] == \'\\\-- tmp_line_len ;if ( tmp_line [ tmp_line_len - 1 ] == \'\\\\r\' ) {-- tmp_line_len ;}}MAKE_STD_ZVAL ( http_response ) ;ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ;zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ;}}else {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>socket!"" ) ;goto out ;}http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ;while ( ! body && ! php_stream_eof ( stream ) ) {size_t http_header_line_length ;if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != \'\\\char * e = http_header_line + http_header_line_length - 1 ;if ( * e != \'\\\do {if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>HTTP<S2SV_blank>headers"" ) ;goto out ;}e = http_header_line + http_header_line_length - 1 ;}while ( * e != \'\\\continue ;}while ( * e == \'\\\e -- ;}http_header_line_length = e - http_header_line + 1 ;http_header_line [ http_header_line_length ] = \'\\\\0\' ;if ( ! strncasecmp ( http_header_line , ""Location:<S2SV_blank>"" , 10 ) ) {if ( context && php_stream_context_get_option ( context , ""http"" , ""follow_location"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_long_ex ( tmpzval ) ;follow_location = Z_LVAL_PP ( tmpzval ) ;}else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) {follow_location = 0 ;}strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ;}else if ( ! strncasecmp ( http_header_line , ""Content-Type:<S2SV_blank>"" , 14 ) ) {php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ;}else if ( ! strncasecmp ( http_header_line , ""Content-Length:<S2SV_blank>"" , 16 ) ) {file_size = atoi ( http_header_line + 16 ) ;php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ;}else if ( ! strncasecmp ( http_header_line , ""Transfer-Encoding:<S2SV_blank>chunked"" , sizeof ( ""Transfer-Encoding:<S2SV_blank>chunked"" ) ) ) {if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) {long decode = 1 ;if ( context && php_stream_context_get_option ( context , ""http"" , ""auto_decode"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_boolean ( * tmpzval ) ;decode = Z_LVAL_PP ( tmpzval ) ;}if ( decode ) {transfer_encoding = php_stream_filter_create ( ""dechunk"" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ;if ( transfer_encoding ) {continue ;}}}}if ( http_header_line [ 0 ] == \'\\\\0\' ) {body = 1 ;}else {zval * http_header ;MAKE_STD_ZVAL ( http_header ) ;ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ;zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ;}}else {break ;}}if ( ! reqok || ( location [ 0 ] != \'\\\\0\' && follow_location ) ) {if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) {goto out ;}if ( location [ 0 ] != \'\\\\0\' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ;php_stream_close ( stream ) ;stream = NULL ;if ( location [ 0 ] != \'\\\\0\' ) {char new_path [ HTTP_HEADER_BLOCK_SIZE ] ;char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ;* new_path = \'\\\\0\' ;if ( strlen ( location ) < 8 || ( strncasecmp ( location , ""http://"" , sizeof ( ""http://"" ) - 1 ) && strncasecmp ( location , ""https://"" , sizeof ( ""https://"" ) - 1 ) && strncasecmp ( location , ""ftp://"" , sizeof ( ""ftp://"" ) - 1 ) && strncasecmp ( location , ""ftps://"" , sizeof ( ""ftps://"" ) - 1 ) ) ) {if ( * location != \'/\' ) {if ( * ( location + 1 ) != \'\\\\0\' && resource -> path ) {char * s = strrchr ( resource -> path , \'/\' ) ;if ( ! s ) {s = resource -> path ;if ( ! s [ 0 ] ) {efree ( s ) ;s = resource -> path = estrdup ( ""/"" ) ;}else {* s = \'/\' ;}}s [ 1 ] = \'\\\\0\' ;if ( resource -> path && * ( resource -> path ) == \'/\' && * ( resource -> path + 1 ) == \'\\\\0\' ) {snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s%s"" , resource -> path , location ) ;}else {snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s/%s"" , resource -> path , location ) ;}}else {snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""/%s"" , location ) ;}}else {strlcpy ( loc_path , location , sizeof ( loc_path ) ) ;}if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) {snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s:%d%s"" , resource -> scheme , resource -> host , resource -> port , loc_path ) ;}else {snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s%s"" , resource -> scheme , resource -> host , loc_path ) ;}}else {strlcpy ( new_path , location , sizeof ( new_path ) ) ;}php_url_free ( resource ) ;if ( ( resource = php_url_parse ( new_path ) ) == NULL ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ;goto out ;}# define CHECK_FOR_CNTRL_CHARS ( val ) {if ( val ) {unsigned char * s , * e ;int l ;l = php_url_decode ( val , strlen ( val ) ) ;s = ( unsigned char * ) val ;e = s + l ;while ( s < e ) {if ( iscntrl ( * s ) ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ;goto out ;}s ++ ;}}}if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) {","\\\\\if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) {",875
1240,PyObject * u ;char * buf ;const char * end ;if ( len > SIZE_MAX / 6 ) return NULL ;,"PyObject * v , * u ;char * buf ;const char * end ;const char * first_invalid_escape ;if ( s >= end || len > SIZE_MAX / 6 ) return NULL ;",876
1241,"if ( * s & 0x80 ) {strcpy ( p , ""u005c"" ) ;p += 5 ;}","if ( * s & 0x80 ) {strcpy ( p , ""u005c"" ) ;p += 5 ;if ( s >= end ) break ;}",876
1242,assert ( p - buf <= Py_SIZE ( u ) ) ;Py_DECREF ( w ) ;,assert ( p - buf <= PyBytes_GET_SIZE ( u ) ) ;Py_DECREF ( w ) ;,876
1243,"return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ;}","v = _PyUnicode_DecodeUnicodeEscape ( s , len , NULL , & first_invalid_escape ) ;if ( v != NULL && first_invalid_escape != NULL ) {if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) {Py_XDECREF ( u ) ;Py_DECREF ( v ) ;return NULL ;}}Py_XDECREF ( u ) ;return v ;}",876
1244,"byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ;","byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_offset ] ) , size_copy ) ;",877
1245,"
","if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) {libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ;goto on_error ;}if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) {libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ;goto on_error ;}",877
1246,"
","if ( data_size > ( ( record_data_size - 4 ) - record_data_offset ) ) {libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , ""%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" , function ) ;goto on_error ;}",877
1247,"if ( libfvalue_value_type_initialize (  & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) {","if ( libfvalue_value_type_initialize ( & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) {",877
1248,if ( strings_size != 0 )  {# if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {,if ( strings_size != 0 ) {# if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {,877
1249,"# if defined ( HAVE_DEBUG_OUTPUT )  if ( libcnotify_verbose != 0 ) {libcnotify_print_data (  & ( record_data [ data_offset ] ) ,  ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;","# if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {libcnotify_print_data ( & ( record_data [ data_offset ] ) , ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;",877
1250,uint32_t bcount ;infilesize = DoGetFileSize ( infile ) ;,int format_chunk = 0 ;uint32_t bcount ;infilesize = DoGetFileSize ( infile ) ;,878
1251,"int supported = TRUE , format ;chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ;","int supported = TRUE , format ;if ( format_chunk ++ ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ;",878
1252,uint32_t sampleRate ;while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) {,uint32_t sampleRate = 0 ;while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) {,879
1253,config -> num_channels = numChannels ;,config -> num_channels || ! config -> sample_rate = numChannels ;,879
1254,"if ( ! config -> num_channels ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;","if ( ! config -> num_channels ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;",879
1255,"if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""\\\mgmtd_len = * ( tptr + 3 ) ;if ( mgmtd_len < 1 || mgmtd_len > 32 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ;return ;}fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ;tptr += VTP_HEADER_LEN ;switch ( type ) {case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ;ND_PRINT ( ( ndo , ""\\\tptr += 8 ;ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ;tptr += VTP_UPDATE_TIMESTAMP_LEN ;ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ;tptr += VTP_MD5_DIGEST_LEN ;break ;case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ;tptr += 4 ;while ( tptr < ( pptr + length ) ) {ND_TCHECK_8BITS ( tptr ) ;len = * tptr ;if ( len == 0 ) break ;ND_TCHECK2 ( * tptr , len ) ;vtp_vlan = ( const struct vtp_vlan_ * ) tptr ;ND_TCHECK ( * vtp_vlan ) ;ND_PRINT ( ( ndo , ""\\\fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ;len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;while ( len > 0 ) {type = * tptr ;tlv_len = * ( tptr + 1 ) ;if ( type == 0 || tlv_len == 0 ) {return ;ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;tlv_value = EXTRACT_16BITS ( tptr + 2 ) ;","len -= VTP_VLAN_INFO_FIXED_PART_LEN ;tptr += VTP_VLAN_INFO_FIXED_PART_LEN ;if ( len < 4 * ( ( vtp_vlan -> name_len , NULL ) ;len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += 4 * ( ( vtp_vlan -> name_len , NULL ) ;len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ;while ( len > 0 ) {if ( len < 2 ) goto trunc ;ND_TCHECK2 ( * tptr , 2 ) ;if ( tlv_len != 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)"" , tlv_len ) ) ;else {type = * tptr ;tlv_len = * ( tptr + 1 ) ;if ( type == 0 || tlv_len == 0 ) {return ;ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ;tlv_value = EXTRACT_16BITS ( tptr + 2 ) ;",880
1256,len -= 2 + tlv_len * 2 ;tptr += 2 + tlv_len * 2 ;,}len -= 2 + tlv_len * 2 ;tptr += 2 + tlv_len * 2 ;,880
1257,"spin_unlock_irqrestore ( & slave_active_lock , flags ) ;}","list_del_init ( & timeri -> ack_list ) ;list_del_init ( & timeri -> active_list ) ;spin_unlock_irqrestore ( & slave_active_lock , flags ) ;}",881
1258,"struct stat stb ;enum {YES , NO , DISPLAYED }wrerr ;",struct stat stb ;,882
1259,"int setimes , targisdir , wrerrno = 0 ;char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ;","int setimes , targisdir , wrerr ;char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ;",882
1260,wrerr = NO ;statbytes = 0 ;,wrerr = 0 ;statbytes = 0 ;,882
1261,"if ( wrerr == NO ) {if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) {wrerr = YES ;wrerrno = errno ;","if ( ! wrerr ) {if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) {note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ;wrerr = 1 ;",882
1262,"if ( count != 0 && wrerr == NO &&  atomicio ( vwrite , ofd , bp -> buf , count ) != count ) {wrerr = YES ;wrerrno = errno ;}if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) &&  ftruncate ( ofd , size ) != 0 ) {run_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ;wrerr = DISPLAYED ;}# endif  run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" ,   np , strerror ( errno ) ) ;wrerr = DISPLAYED ;# endif  run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" ,   np , strerror ( errno ) ) ;wrerr = DISPLAYED ;}if ( close ( ofd ) == - 1 ) {wrerr = YES ;wrerrno = errno ;if ( setimes && wrerr == NO ) {setimes = 0 ;run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" ,  np , strerror ( errno ) ) ;wrerr = DISPLAYED ;}switch ( wrerr ) {case YES : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( wrerrno ) ) ;case NO : ( void ) atomicio ( vwrite , remout , """" , 1 ) ;break ;case DISPLAYED : break ;","if ( count != 0 && ! wrerr && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) {note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ;wrerr = 1 ;}if ( ! wrerr && ( ! exists || S_ISREG ( stb . st_mode ) ) && ftruncate ( ofd , size ) != 0 ) note_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ;# endif note_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ;# endif note_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ;if ( close ( ofd ) == - 1 ) note_err ( np , ""%s:<S2SV_blank>close:<S2SV_blank>%s"" , np , strerror ( errno ) ) ;if ( setimes && ! wrerr ) {setimes = 0 ;note_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , np , strerror ( errno ) ) ;}if ( note_err ( NULL ) == 0 ) ( void ) atomicio ( vwrite , remout , """" , 1 ) ;case DISPLAYED : break ;",882
1263,"else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL )  {else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL )  {","else if ( anope_flags_compat && ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) {else if ( anope_flags_compat && ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) {",883
1264,"else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL )  {","else if ( anope_flags_compat && ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL ) {",883
1265,"ghash_flush ( ctx , dctx ) ;memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ;","if ( ! ctx -> gf128 ) return - ENOKEY ;ghash_flush ( ctx , dctx ) ;memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ;",884
1266,"
","if ( strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ;",885
1267,if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) )  goto error ;,if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) goto error ;,885
1268,"int need_error_free = 0 ;int local_rcache = 0 , local_authcon = 0 ;if ( strcmp ( inbuf . data , sendauth_version ) ) {problem = KRB5_SENDAUTH_BADAUTHVERS ;","krb5_data d ;int need_error_free = 0 ;int local_rcache = 0 , local_authcon = 0 ;d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ;if ( ! data_eq ( inbuf , d ) ) {problem = KRB5_SENDAUTH_BADAUTHVERS ;",886
1269,"if ( appl_version && strcmp ( inbuf . data , appl_version ) ) {if ( ! problem ) {","if ( appl_version != NULL && ! problem ) {d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ;if ( ! data_eq ( inbuf , d ) ) {",886
1270,"static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) {vp9_write_literal ( w , word >= test , 1 ) ;return word >= test ;","static INLINE int write_bit_gte ( vpx_writer * w , int word , int test ) {vpx_write_literal ( w , word >= test , 1 ) ;return word >= test ;",887
1271,"ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( ret < 0 ) return ret ;case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EINVAL : 0 ;name = XATTR_NAME_POSIX_ACL_DEFAULT ;break ;default : return - EINVAL ;}if ( acl ) {size = posix_acl_xattr_size ( acl -> a_count ) ;value = kmalloc ( size , GFP_KERNEL ) ;if ( ! value ) {ret = - ENOMEM ;goto out ;","ret = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( ret < 0 ) return ret ;case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode , & acl ) ;if ( ret ) return ret ;",888
1272,"case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ;* dptr ++ = lci2 ;* dptr ++ = frametype ;* dptr ++ = 0xAA ;memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;","case ROSE_CALL_REQUEST : * dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL ;memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ;",889
1273,if ( new_fs ) {if ( & p -> mnt == new_fs -> root . mnt ) {,new_ns -> mounts ++ ;if ( new_fs ) {if ( & p -> mnt == new_fs -> root . mnt ) {,890
1274,"i < NUM_YV12_BUFFERS ;i ++ ) {oci -> fb_idx_ref_cnt [ i ] = 0 ;oci -> yv12_fb [ i ] . flags = 0 ;if ( vp8_yv12_alloc_frame_buffer ( & oci -> yv12_fb [ i ] , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ;","memset ( & oci -> yv12_fb [ i ] , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ;",891
1275,"if ( ! oci -> mip ) goto allocation_fail ;oci -> mi = oci -> mip + oci -> mode_info_stride + 1 ;oci -> above_context = vpx_calloc ( sizeof ( ENTROPY_CONTEXT_PLANES ) * oci -> mb_cols , 1 ) ;if ( ! oci -> above_context ) goto allocation_fail ;# if CONFIG_POSTPROC if ( vp8_yv12_alloc_frame_buffer ( & oci -> post_proc_buffer , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ;oci -> post_proc_buffer_int_used = 0 ;vpx_memset ( & oci -> postproc_state , 0 , sizeof ( oci -> postproc_state ) ) ;vpx_memset ( oci -> post_proc_buffer . buffer_alloc , 128 ,  oci -> post_proc_buffer . frame_size ) ;","memset ( oci -> postproc_state ) ) ;vpx_memset ( oci -> post_proc_buffer . buffer_alloc , 128 , oci -> post_proc_buffer . frame_size ) ;",891
1276,zip_object_handlers . get_properties = php_zip_get_properties ;zip_object_handlers . read_property = php_zip_read_property ;,zip_object_handlers . get_gc = php_zip_get_gc ;zip_object_handlers . get_properties = php_zip_get_properties ;zip_object_handlers . read_property = php_zip_read_property ;,892
1277,case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR :  return ( ( iova < mem -> iova ) ||   ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ?  - EFAULT : 0 ;,case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : if ( iova < mem -> iova ) || ( ( iova + length ) > ( mem -> iova + mem -> length - length ) return - EFAULT ;return 0 ;,893
1278,"ni6 = ( const struct icmp6_nodeinfo * ) dp ;ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ;","ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ;ni6 = ( const struct icmp6_nodeinfo * ) dp ;ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ;",894
1279,cp = ( const u_char * ) ( ni6 + 1 ) + 4 ;if ( cp [ 0 ] == ep - cp - 1 ) {,cp = ( const u_char * ) ( ni6 + 1 ) + 4 ;ND_TCHECK ( cp [ 0 ] ) ;if ( cp [ 0 ] == ep - cp - 1 ) {,894
1280,"static void finish_object ( struct object * obj ,  struct strbuf * path , const char * name ,  void * cb_data ) {","static void finish_object ( struct object * obj , const char * name , void * cb_data ) {",895
1281,* sent = 0 ;if ( ssocket == NULL ) return - ENOTSOCK ;,* sent = 0 ;,896
1282,"static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe ,  struct pipe_buffer * buf ) {ref -> ref ++ ;}","static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {if ( ref -> ref > INT_MAX / 2 ) return false ;ref -> ref ++ ;return true ;}",897
1283,"if ( cluster != fs -> clusters - 1 )  get_fat ( & subseqEntry , fs -> fat , cluster + 1 , fs ) ;","if ( cluster != fs -> clusters + 1 ) get_fat ( & subseqEntry , fs -> fat , cluster + 1 , fs ) ;",898
1284,"if ( ! x -> e_mbd . left_context ) return ;vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",899
1285,sock_put ( sk ) ;isk -> inet_num = 0 ;,sk_nulls_node_init ( & sk -> sk_nulls_node ) ;sock_put ( sk ) ;isk -> inet_num = 0 ;,900
1286,}if ( prev_slice_err == 1 ) {,}ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ;if ( prev_slice_err == 1 ) {,901
1287,if ( ! mm )  return 0 ;,if ( ! mm || ! mm -> env_end ) return 0 ;,902
1288,"int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode )  {int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ;if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) {result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ;}","int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode , int relocated ) {int flags = relocated ? RR_RELOC_DE : 0 ;int result = parse_rock_ridge_inode_internal ( de , inode , flags ) ;if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) {result = parse_rock_ridge_inode_internal ( de , inode , flags | RR_REGARD_XA ) ;}",903
1289,"static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events )  {spin_lock_init ( & group -> inotify_data . idr_lock ) ;idr_init ( & group -> inotify_data . idr ) ;group -> inotify_data . user = user ;group -> inotify_data . fa = NULL ;return group ;",static struct fsnotify_group * inotify_new_group ( unsigned int max_events ) {spin_lock_init ( & group -> inotify_data . fa = NULL ;group -> inotify_data . user = user ;group -> inotify_data . user = get_current_user ( ) ;if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) {fsnotify_put_group ( group ) ;return ERR_PTR ( - EMFILE ) ;}return group ;,904
1290,for ( p = 0 ;p < 4 && in -> data [ p ] ;int w = inlink -> w ;,for ( p = 0 ;p < 4 && in -> data [ p ] && in -> linesize [ p ] ;int w = inlink -> w ;,905
1291,pairs = palloc ( pcount * sizeof ( Pairs ) ) ;for ( i = 0 ;,"if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;pairs = palloc ( pcount * sizeof ( Pairs ) ) ;for ( i = 0 ;",906
1292,"if ( screen -> buffers [ 1 ] )  vterm_allocator_free ( screen -> vt , screen -> buffers [ 1 ] ) ;","vterm_allocator_free ( screen -> vt , screen -> buffers [ 1 ] ) ;",907
1293,"regs [ value_regno ] . id = 0 ;regs [ value_regno ] . off = 0 ;regs [ value_regno ] . range = 0 ;regs [ value_regno ] . type = reg_type ;}}else if ( reg -> type == PTR_TO_STACK ) {if ( ! tnum_is_const ( reg -> var_off ) ) {char tn_buf [ 48 ] ;tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ;verbose ( env , ""variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , tn_buf , off , size ) ;return - EACCES ;}off += reg -> var_off . value ;if ( off >= 0 || off < - MAX_BPF_STACK ) {verbose ( env , ""invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\\return - EACCES ;}if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ;if ( t == BPF_WRITE ) err = check_stack_write ( env , state , off , size , value_regno ) ;else err = check_stack_read ( env , state , off , size , value_regno ) ;","regs [ value_regno ] , size ) ;",908
1294,"regs [ value_regno ] . var_off =  tnum_cast ( regs [ value_regno ] . var_off , size ) ;","coerce_reg_to_size ( & regs [ value_regno ] . var_off = tnum_cast ( regs [ value_regno ] . var_off , size ) ;",908
1295,"uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ;uint32 stripsize = TIFFStripSize ( in ) ;","uint32 strip , nstrips = TIFFNumberOfStrips ( in ) ;uint32 stripsize = TIFFStripSize ( in ) ;",909
1296,const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ;struct search_domain * dom ;for ( dom = state -> head ;,char need_to_append_dot ;struct search_domain * dom ;if ( ! base_len ) return NULL ;need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ;for ( dom = state -> head ;,910
1297,"err = nanosleep ( & delay , & delay ) ;}","err = TEMP_FAILURE_RETRY ( nanosleep ( & delay , & delay ) ) ;}",911
1298,msg -> msg_namelen = 0 ;err = - EAGAIN ;,err = - EAGAIN ;,912
1299,"size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one ,  offset ,  pixel_info_length ;ssize_t count , y ;if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;","size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ;ssize_t count , offset , y ;if ( ( offset < 0 ) || ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;",913
1300,if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  {,if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,913
1301,if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ;,if ( ( offset < 0 ) || ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ;,913
1302,if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  {,if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,913
1303,"static void nsc_rle_decompress_data ( NSC_CONTEXT * context )  {rle = context -> Planes ;for ( i = 0 ;if ( planeSize == 0 )  FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ;else if ( planeSize < originalSize )   nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ;else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ;rle += planeSize ;}}","static BOOL nsc_rle_decompress_data ( NSC_CONTEXT * context ) {if ( ! context ) return FALSE ;rle = context -> Planes ;for ( i = 0 ;if ( planeSize == 0 ) {if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ;FillMemory ( context -> priv -> PlaneBuffers [ i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ;}else {if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ;CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ;}rle += planeSize ;}return TRUE ;}",914
1304,"int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy )  {if ( policy -> version != 0 ) return - EINVAL ;","int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy ) {if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;if ( policy -> version != 0 ) return - EINVAL ;",915
1305,"httpSetHostDefaultRoute ( state -> host , state -> route ) ;if ( value ) {httpSetHostName ( state -> host , stok ( sclone ( value ) , ""<S2SV_blank>\\\\t,"" , NULL ) ) ;httpSetRouteName ( state -> route , sfmt ( ""default-%s"" , state -> host -> name ) ) ;","httpSetHostDefaultRoute ( state -> host , ssplit ( sclone ( value ) , ""<S2SV_blank>\\\\t,"" , NULL ) ) ;httpSetRouteName ( state -> route , sfmt ( ""default-%s"" , state -> host -> name ) ) ;",916
1306,". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = type -> match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",917
1307,if ( flags & MSG_OOB )  return - EOPNOTSUPP ;if ( addr_len ) * addr_len = sizeof ( * sin6 ) ;,if ( flags & MSG_OOB ) return - EOPNOTSUPP ;if ( addr_len ) * addr_len = sizeof ( * sin6 ) ;,918
1308,"sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;}","sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ;* addr_len = sizeof ( * sin6 ) ;}",918
1309,"if ( ! arr || ! json_is_array ( arr ) ) goto out ;merkles = json_array_size ( arr ) ;job_id = json_array_string ( val , 0 ) ;prev_hash = __json_array_string ( val , 1 ) ;coinbase1 = json_array_string ( val , 2 ) ;coinbase2 = json_array_string ( val , 3 ) ;bbversion = __json_array_string ( val , 5 ) ;nbit = __json_array_string ( val , 6 ) ;ntime = __json_array_string ( val , 7 ) ;clean = json_is_true ( json_array_get ( val , 8 ) ) ;if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) {if ( job_id )  free ( job_id ) ;",if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) {free ( job_id ) free ( job_id ) ;,919
1310,"ssize_t ret = write ( fd , data + transmitted_length , length ) ;switch ( ret ) {","ssize_t ret = TEMP_FAILURE_RETRY ( write ( fd , data + transmitted_length , length ) ) ;switch ( ret ) {",920
1311,"void * ptr = malloc ( num * size ) ;if ( ptr ) {memset ( ptr , '\\\\0' , ( num * size ) ) ;}","size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;void * ptr ;ptr = malloc ( res ) ;if ( ptr ) {memset ( ptr , '\\\\0' , ( res ) ) ;}",921
1312,put_io_context ( ioc ) ;}},}put_io_context ( ioc ) ;},922
1313,"PyObject * res ;_Py_IDENTIFIER ( __dict__ ) ;PyObject * dict = _PyObject_GetAttrId ( self , & PyId___dict__ ) ;if ( dict == NULL ) {if ( PyErr_ExceptionMatches ( PyExc_AttributeError ) ) PyErr_Clear ( ) ;else return NULL ;res = Py_BuildValue ( ""O()O"" , Py_TYPE ( self ) , dict ) ;Py_DECREF ( dict ) ;return res ;","_Py_IDENTIFIER ( __dict__ ) ;PyObject * dict = _PyObject_GetAttrId ( self , & PyId___dict__ , & dict ) < 0 ) {return NULL ;res = Py_BuildValue ( ""O()O"" , Py_TYPE ( self ) , dict ) ;",923
1314,"err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) ,  USB_DT_OTG , ( void * * ) & desc ) ;if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ;","err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , USB_DT_OTG , ( void * * ) & desc , sizeof ( * desc ) ) ;if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ;",924
1315,"void ( * func ) ( struct perf_event * ) ;u32 flags = arg ;switch ( cmd ) {case PERF_EVENT_IOC_ENABLE : func = perf_event_enable ;break ;case PERF_EVENT_IOC_DISABLE : func = perf_event_disable ;break ;case PERF_EVENT_IOC_RESET : func = perf_event_reset ;break ;case PERF_EVENT_IOC_REFRESH : return perf_event_refresh ( event , arg ) ;case PERF_EVENT_IOC_PERIOD :   return perf_event_period ( event , ( u64 __user * ) arg ) ;case PERF_EVENT_IOC_ID : {","struct perf_event_context * ctx ;long ret ;ctx = perf_event_ctx_lock ( event ) ;ret = _perf_ioctl ( event , cmd , arg ) ;case PERF_EVENT_IOC_PERIOD : return perf_event_period ( event , ( u64 __user * ) arg ) ;case PERF_EVENT_IOC_ID : {",925
1316,"case PERF_EVENT_IOC_SET_FILTER :  return perf_event_set_filter ( event , ( void __user * ) arg ) ;default : return - ENOTTY ;}if ( flags & PERF_IOC_FLAG_GROUP ) perf_event_for_each ( event , func ) ;","case PERF_EVENT_IOC_SET_FILTER : return perf_event_set_filter ( event , ( void __user * ) arg ) ;perf_event_ctx_unlock ( event , func ) ;",925
1317,tp -> prr_delivered += newly_acked_sacked ;if ( delta < 0 ) {,if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;tp -> prr_delivered += newly_acked_sacked ;if ( delta < 0 ) {,926
1318,"static MB_PREDICTION_MODE read_intra_mode_uv ( VP9_COMMON * cm , vp9_reader * r ,   MB_PREDICTION_MODE y_mode ) {const MB_PREDICTION_MODE uv_mode = read_intra_mode ( r ,   cm -> fc . uv_mode_prob [ y_mode ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . uv_mode [ y_mode ] [ uv_mode ] ;","static PREDICTION_MODE read_intra_mode_uv ( VP9_COMMON * cm , MACROBLOCKD * xd , vpx_reader * r , PREDICTION_MODE y_mode ) {const MB_PREDICTION_MODE uv_mode = read_intra_mode ( r , cm -> fc -> uv_mode_prob [ y_mode ] ) ;FRAME_COUNTS * counts = xd -> counts ;if ( counts ) ++ counts -> uv_mode [ y_mode ] [ uv_mode ] ;",927
1319,"return crypto_alloc_skcipher ( name , type , mask ) ;}","struct skcipher_tfm * tfm ;struct crypto_skcipher * skcipher ;tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ;if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ;skcipher = crypto_alloc_skcipher ( name , type , mask ) ;if ( IS_ERR ( skcipher ) ) {kfree ( tfm ) ;return ERR_CAST ( skcipher ) ;}tfm -> skcipher = skcipher ;return tfm ;}",928
1320,default : return - EINVAL ;,default : kfree ( hmac_buf ) ;return - EINVAL ;,929
1321,"if ( sha -> src_len && ! sha -> src ) return - EINVAL ;memset ( & op , 0 , sizeof ( op ) ) ;op . cmd_q = cmd_q ;op . jobid = CCP_NEW_JOBID ( cmd_q -> ccp ) ;op . sb_ctx = cmd_q -> sb_ctx ;op . u . sha . type = sha -> type ;op . u . sha . msg_bits = sha -> msg_bits ;ret = ccp_init_dm_workarea ( & ctx , cmd_q , sb_count * CCP_SB_BYTES , DMA_BIDIRECTIONAL ) ;if ( ret ) return ret ;if ( sha -> first ) {switch ( sha -> type ) {case CCP_SHA_TYPE_1 : case CCP_SHA_TYPE_224 : case CCP_SHA_TYPE_256 : memcpy ( ctx . address + ioffset , init , ctx_size ) ;break ;case CCP_SHA_TYPE_384 : case CCP_SHA_TYPE_512 : memcpy ( ctx . address + ctx_size / 2 , init , ctx_size / 2 ) ;memcpy ( ctx . address , init + ctx_size / 2 , ctx_size / 2 ) ;break ;default : ret = - EINVAL ;goto e_ctx ;}}else {ret = ccp_set_dm_area ( & ctx , 0 , sha -> ctx , 0 , sb_count * CCP_SB_BYTES ) ;if ( ret ) goto e_ctx ;}ret = ccp_copy_to_sb ( cmd_q , & ctx , op . jobid , op . sb_ctx , CCP_PASSTHRU_BYTESWAP_256BIT ) ;if ( ret ) {cmd -> engine_error = cmd_q -> cmd_error ;goto e_ctx ;}if ( sha -> src ) {ret = ccp_init_data ( & src , cmd_q , sha -> src , sha -> src_len , block_size , DMA_TO_DEVICE ) ;if ( ret ) goto e_ctx ;while ( src . sg_wa . bytes_left ) {ccp_prepare_data ( & src , NULL , & op , block_size , false ) ;if ( sha -> final && ! src . sg_wa . bytes_left ) op . eom = 1 ;ret = cmd_q -> ccp -> vdata -> perform -> sha ( & op ) ;if ( ret ) {cmd -> engine_error = cmd_q -> cmd_error ;goto e_data ;}ccp_process_data ( & src , NULL , & op ) ;}}else {op . eom = 1 ;ret = cmd_q -> ccp -> vdata -> perform -> sha ( & op ) ;if ( ret ) {cmd -> engine_error = cmd_q -> cmd_error ;goto e_data ;}}ret = ccp_copy_from_sb ( cmd_q , & ctx , op . jobid , op . sb_ctx , CCP_PASSTHRU_BYTESWAP_256BIT ) ;if ( ret ) {cmd -> engine_error = cmd_q -> cmd_error ;goto e_data ;}if ( sha -> final ) {switch ( sha -> type ) {case CCP_SHA_TYPE_1 : case CCP_SHA_TYPE_224 : case CCP_SHA_TYPE_256 : ccp_get_dm_area ( & ctx , ooffset , sha -> ctx , 0 , digest_size ) ;break ;case CCP_SHA_TYPE_384 : case CCP_SHA_TYPE_512 : ccp_get_dm_area ( & ctx , 0 , sha -> ctx , LSB_ITEM_SIZE - ooffset , LSB_ITEM_SIZE ) ;ccp_get_dm_area ( & ctx , LSB_ITEM_SIZE + ooffset , sha -> ctx , 0 , LSB_ITEM_SIZE - ooffset ) ;break ;default : ret = - EINVAL ;goto e_ctx ;}}else {ccp_get_dm_area ( & ctx , 0 , sha -> ctx , 0 , sb_count * CCP_SB_BYTES ) ;}if ( sha -> final && sha -> opad ) {struct ccp_cmd hmac_cmd ;struct scatterlist sg ;u8 * hmac_buf ;if ( sha -> opad_len != block_size ) {ret = - EINVAL ;goto e_data ;}hmac_buf = kmalloc ( block_size + digest_size , GFP_KERNEL ) ;if ( ! hmac_buf ) {ret = - ENOMEM ;goto e_data ;}sg_init_one ( & sg , hmac_buf , block_size + digest_size ) ;scatterwalk_map_and_copy ( hmac_buf , sha -> opad , 0 , block_size , 0 ) ;switch ( sha -> type ) {case CCP_SHA_TYPE_1 : case CCP_SHA_TYPE_224 : case CCP_SHA_TYPE_256 : memcpy ( hmac_buf + block_size , ctx . address + ooffset , digest_size ) ;break ;case CCP_SHA_TYPE_384 : case CCP_SHA_TYPE_512 : memcpy ( hmac_buf + block_size , ctx . address + LSB_ITEM_SIZE + ooffset , LSB_ITEM_SIZE ) ;memcpy ( hmac_buf + block_size + ( LSB_ITEM_SIZE - ooffset ) , ctx . address , LSB_ITEM_SIZE ) ;break ;default :  ret = - EINVAL ;goto e_ctx ;}","
",929
1322,"if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) {c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ;aligned_height = FFALIGN ( c -> tile_height , 16 ) ;","if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width , 16 ) * 3 ;aligned_height = FFALIGN ( c -> tile_height , 16 ) ;",930
1323,return Qnil ;},"rb_ivar_set ( self , id_key_set , Qtrue ) ;return Qnil ;}",931
1324,"qemu_format_nic_info_str ( qemu_get_queue ( s -> nic ) , s -> conf . macaddr . a ) ;stellaris_enet_reset ( s ) ;register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 ,  stellaris_enet_save , stellaris_enet_load , s ) ;","
",932
1325,"register u_int length = h -> len ;register u_int caplen = h -> caplen ;if ( caplen < CHDLC_HDRLEN ) {ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ;return ( caplen ) ;return ( chdlc_print ( ndo , p , length ) ) ;}","return chdlc_print ( ndo , p , length ) ) ;",933
1326,"remote_path_check :  if ( ! rc && cifs_sb -> prepathlen && tcon ) {full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ;","remote_path_check : if ( ! rc && tcon ) {full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ;",934
1327,"if ( skb_is_err_queue ( skb ) && skb -> len &&  ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) )  put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ;","if ( skb_is_err_queue ( skb ) && skb -> len && SKB_EXT_ERR ( skb ) -> opt_stats ) put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ;",935
1328,"if ( rdf_parser -> uri_filter )  raptor_sax2_set_uri_filter ( rdf_xml_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;","raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;if ( rdf_parser -> uri_filter ) raptor_sax2_set_uri_filter ( rdf_xml_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;",936
1329,"
","if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) {al = SSL_AD_UNEXPECTED_MESSAGE ;SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ;goto f_err ;}",937
1330,if ( ( rsa = RSA_new ( ) ) == NULL )  {,if ( ( rsa = RSA_new ( ) ) == NULL ) {,937
1331,return SECURE_ELEMENT_ERROR_NPE ;},return SECURE_ELEMENT_ERROR_NPE ;}if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) {return SECURE_ELEMENT_ERROR_BUF_SIZE ;},938
1332,"
",if ( session -> obq_flood_counter_ >= session -> max_outbound_ack && ! ( iframe -> frame . hd . flags & NGHTTP2_FLAG_ACK ) ) {return NGHTTP2_ERR_FLOODED ;},939
1333,iframe -> state = NGHTTP2_IB_READ_SETTINGS ;if ( iframe -> payloadleft ) {,iframe -> state = NGHTTP2_IB_READ_SETTINGS ;if ( iframe -> payloadleft ) {,939
1334,return new_ns ;},new_ns -> mounts = 0 ;new_ns -> pending_mounts = 0 ;return new_ns ;},940
1335,}return opt2 ;,"atomic_set ( & opt2 -> refcnt , 1 ) ;}return opt2 ;",941
1336,x86_pmu . extra_regs = intel_snb_extra_regs ;x86_pmu . er_flags |= ERF_HAS_RSP_1 ;,if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ;else x86_pmu . extra_regs = intel_snb_extra_regs ;x86_pmu . er_flags |= ERF_HAS_RSP_1 ;,942
1337,x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;x86_pmu . extra_regs = intel_snb_extra_regs ;,x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ;else x86_pmu . extra_regs = intel_snb_extra_regs ;,942
1338,int n_read = r -> end - r -> begin ;int part_read = n_read / r -> part_size ;,unsigned int actual_size = rtype == 2 ? n * 2 : n ;unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ;unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ;int n_read = limit_r_end - limit_r_begin ;int part_read = n_read / r -> part_size ;,943
1339,"u32 now ;if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ;challenge_timestamp = now ;challenge_count = 0 ;}if ( ++ challenge_count <= sysctl_tcp_challenge_ack_limit ) {","u32 count , now ;if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ;u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ;challenge_timestamp = now ;WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ;}count = READ_ONCE ( challenge_count ) ;if ( count > 0 ) {WRITE_ONCE ( challenge_count , count - 1 ) ;",944
1340,struct llc_pktinfo info ;info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ;,"struct llc_pktinfo info ;memset ( & info , 0 , sizeof ( info ) ) ;info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ;",945
1341,"static void pack_mb_tokens ( vp9_writer * w ,   TOKENEXTRA * * tp , const TOKENEXTRA * stop ) {TOKENEXTRA * p = * tp ;const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ;int i = 0 ;int v = a -> value ;if ( p -> skip_eob_node ) {","static void pack_mb_tokens ( vpx_writer * w , TOKENEXTRA * * tp , const TOKENEXTRA * const stop , vpx_bit_depth_t bit_depth ) {TOKENEXTRA * p = * tp ;int i = 0 ;int v = a -> value ;# if CONFIG_VP9_HIGHBITDEPTH const vp9_extra_bit * b ;if ( bit_depth == VPX_BITS_12 ) b = & vp9_extra_bits_high12 [ t ] ;# else const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ;( void ) bit_depth ;# endif if ( p -> skip_eob_node ) {",946
1342,"vp9_write ( w , bb , pb [ i >> 1 ] ) ;i = b -> tree [ i + bb ] ;vp9_write_bit ( w , e & 1 ) ;}","vpx_write ( w , bb , pb [ i >> 1 ] ) ;i = b -> tree [ i + bb ] ;vpx_write_bit ( w , e & 1 ) ;}",946
1343,"struct vp9_write_bit_buffer wb = {struct vp9_write_bit_buffer saved_wb ;write_uncompressed_header ( cpi , & wb ) ;vp9_wb_write_literal ( & wb , 0 , 16 ) ;uncompressed_hdr_size = vp9_rb_bytes_written ( & wb ) ;data += uncompressed_hdr_size ;vp9_compute_update_table ( ) ;vp9_clear_system_state ( ) ;vp9_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ;data += encode_tiles ( cpi , data ) ;","struct vpx_write_bit_buffer wb = {struct vpx_write_bit_buffer saved_wb ;write_uncompressed_header ( cpi , & wb ) ;vpx_wb_write_literal ( & wb , 0 , 16 ) ;uncompressed_hdr_size = vpx_wb_bytes_written ( & wb ) ;data += uncompressed_hdr_size ;vpx_clear_system_state ( ) ;vp9_clear_system_state ( ) ;vpx_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ;data += encode_tiles ( cpi , data ) ;",947
1344,"static int dev_get_valid_name ( struct net * net ,  struct net_device * dev , const char * name ) {","int dev_get_valid_name ( struct net * net , struct net_device * dev , const char * name ) {",948
1345,"int ret , n ;quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ;","int ret , n ;int num_descriptors ;size_t offset = offsetof ( struct hid_descriptor , desc ) ;quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ;",949
1346,hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ;hid -> country = hdesc -> bCountryCode ;for ( n = 0 ;n < hdesc -> bNumDescriptors ;n ++ )  if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;,"if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) {dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\\return - EINVAL ;}hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ;hid -> country = hdesc -> bCountryCode ;num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) ;for ( n = 0 ;n < num_descriptors ;n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;",949
1347,"struct ikev2_id id ;int id_len , idtype_len , i ;ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ;","const struct ikev2_id * idp ;struct ikev2_id id ;int id_len , idtype_len , i ;idp = ( const struct ikev2_id * ) ext ;ND_TCHECK ( * idp ) ;UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ;",950
1348,"if ( unlikely ( in_interrupt ( ) ) ) panic ( ""Aiee,<S2SV_blank>killing<S2SV_blank>interrupt<S2SV_blank>handler!"" ) ;if ( unlikely ( ! tsk -> pid ) ) panic ( ""Attempted<S2SV_blank>to<S2SV_blank>kill<S2SV_blank>the<S2SV_blank>idle<S2SV_blank>task!"" ) ;tracehook_report_exit ( & code ) ;if ( unlikely ( tsk -> flags & PF_EXITING ) ) {printk ( KERN_ALERT ""Fixing<S2SV_blank>recursive<S2SV_blank>fault<S2SV_blank>but<S2SV_blank>reboot<S2SV_blank>is<S2SV_blank>needed!\\\tsk -> flags |= PF_EXITPIDONE ;if ( tsk -> io_context ) exit_io_context ( ) ;set_current_state ( TASK_UNINTERRUPTIBLE ) ;schedule ( ) ;}exit_signals ( tsk ) ;smp_mb ( ) ;spin_unlock_wait ( & tsk -> pi_lock ) ;if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO ""note:<S2SV_blank>%s[%d]<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>preempt_count<S2SV_blank>%d\\\acct_update_integrals ( tsk ) ;if ( tsk -> mm ) {update_hiwater_rss ( tsk -> mm ) ;update_hiwater_vm ( tsk -> mm ) ;}group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ;if ( group_dead ) {hrtimer_cancel ( & tsk -> signal -> real_timer ) ;exit_itimers ( tsk -> signal ) ;}acct_collect ( code , group_dead ) ;# ifdef CONFIG_FUTEX   if ( unlikely ( tsk -> robust_list ) )  exit_robust_list ( tsk ) ;# ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ;# endif # endif if ( group_dead ) tty_audit_exit ( ) ;if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ;tsk -> exit_code = code ;taskstats_exit ( tsk , group_dead ) ;exit_mm ( tsk ) ;if ( group_dead ) acct_process ( ) ;trace_sched_process_exit ( tsk ) ;exit_sem ( tsk ) ;exit_files ( tsk ) ;exit_fs ( tsk ) ;check_stack_usage ( ) ;exit_thread ( ) ;cgroup_exit ( tsk , 1 ) ;exit_keys ( tsk ) ;if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ;module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ;if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ;proc_exit_connector ( tsk ) ;exit_notify ( tsk , group_dead ) ;# ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ;tsk -> mempolicy = NULL ;# endif # ifdef CONFIG_FUTEX if ( unlikely ( ! list_empty ( & tsk -> pi_state_list ) ) ) exit_pi_state_list ( tsk ) ;",if ( unlikely ( ! list_empty ( & tsk -> pi_state_list ) ) ) exit_pi_state_list ( tsk ) ;,951
1349,"static void show_object ( struct object * obj ,  struct strbuf * path , const char * last ,  void * data ) {char * name = path_name ( path , last ) ;add_preferred_base_object ( name ) ;free ( ( char * ) name ) ;}","static void show_object ( struct object * obj , const char * last , void * data ) {char * name = path_name ( path , last ) ;add_preferred_base_object ( name ) ;}",952
1350,jas_tvparser_destroy ( tvp ) ;if ( ! cmpt -> sampperx || ! cmpt -> samppery ) {return 0 ;error : if ( cmpt ) {,if ( ! cmpt -> sampperx || ! cmpt -> samppery ) {jas_tvparser_destroy ( tvp ) ;return 0 ;error : if ( cmpt ) {,953
1351,ret = - EINVAL ;goto err_free_urb_to_pipe ;,usb_free_urb ( urb ) ;ret = - EINVAL ;goto err_free_urb_to_pipe ;,954
1352,"WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ;WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ;WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ;","WORD64 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ;WORD64 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ;WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ;",955
1353,"xh0_0 = x_0 + x_l1_0 ;xl0_0 = x_0 - x_l1_0 ;xh20_0 = x_h2_0 + x_l2_0 ;xl20_0 = x_h2_0 - x_l2_0 ;x [ 0 ] = xh0_0 + xh20_0 ;xt0_0 = xh0_0 - xh20_0 ;x_1 = x [ 1 ] ;xh1_0 = x_1 + x_l1_1 ;xl1_0 = x_1 - x_l1_1 ;xh21_0 = x_h2_1 + x_l2_1 ;xl21_0 = x_h2_1 - x_l2_1 ;x [ 1 ] = xh1_0 + xh21_0 ;yt0_0 = xh1_0 - xh21_0 ;xt1_0 = xl0_0 + xl21_0 ;xt2_0 = xl0_0 - xl21_0 ;yt2_0 = xl1_0 + xl20_0 ;yt1_0 = xl1_0 - xl20_0 ;mul_11 = ixheaacd_mult64 ( xt2_0 , co30 ) ;","xh0_0 = ( WORD64 ) x_0 + ( WORD64 ) x_l1_0 ;xl0_0 = ( WORD64 ) x_0 - ( WORD64 ) x_l1_0 ;xh20_0 = ( WORD64 ) x_h2_0 + ( WORD64 ) x_l2_0 ;xl20_0 = ( WORD64 ) x_h2_0 - ( WORD64 ) x_l2_0 ;x [ 0 ] = ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) ;xt0_0 = ( WORD64 ) xh0_0 - ( WORD64 ) xh20_0 ;x_1 = x [ 1 ] ;xh1_0 = ( WORD64 ) x_1 + ( WORD64 ) x_l1_1 ;xl1_0 = ( WORD64 ) x_1 - ( WORD64 ) x_l1_1 ;xh21_0 = ( WORD64 ) x_h2_1 + ( WORD64 ) x_l2_1 ;xl21_0 = ( WORD64 ) x_h2_1 - ( WORD64 ) x_l2_1 ;x [ 1 ] = ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) ;yt0_0 = ( WORD64 ) xh1_0 - ( WORD64 ) xh21_0 ;xt1_0 = ( WORD64 ) xl0_0 + ( WORD64 ) xl21_0 ;xt2_0 = ( WORD64 ) xl0_0 - ( WORD64 ) xl21_0 ;yt2_0 = ( WORD64 ) xl1_0 + ( WORD64 ) xl20_0 ;yt1_0 = ( WORD64 ) xl1_0 - ( WORD64 ) xl20_0 ;mul_11 = ixheaacd_mult64 ( xt2_0 , co30 ) ;",955
1354,if ( tag == 0 ) {if ( data [ dp ++ ] != 0 ) goto invalid_eoc ;,if ( tag == ASN1_EOC ) {if ( data [ dp ++ ] != 0 ) goto invalid_eoc ;,956
1355,if ( len <= 0x7f ) {dp += len ;goto next_tag ;}if ( unlikely ( n > sizeof ( size_t ) - 1 ) )  goto length_too_long ;for ( len = 0 ;len <<= 8 ;dp += len ;goto next_tag ;,if ( len <= 0x7f ) goto check_length ;if ( unlikely ( n > sizeof ( len ) - 1 ) ) goto length_too_long ;len = 0 ;for ( ;len <<= 8 ;check_length : if ( len > datalen - dp ) goto data_overrun_error ;dp += len ;goto next_tag ;,956
1356,"if ( flags & __GFP_ZERO )  memset ( ptr , 0 , size ) ;","memset ( ptr , 0 , size ) ;",957
1357,"return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ;}","return mount_entry_on_generic ( mntent , mntent -> mnt_dir , NULL ) ;}",958
1358,PHP_SHA512Init ( & context ) ;read_len = end_of_phar ;,"if ( sig_len < sizeof ( digest ) ) {if ( error ) {spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ;}return FAILURE ;}PHP_SHA512Init ( & context ) ;read_len = end_of_phar ;",959
1359,PHP_SHA256Init ( & context ) ;read_len = end_of_phar ;,"if ( sig_len < sizeof ( digest ) ) {if ( error ) {spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ;}return FAILURE ;}PHP_SHA256Init ( & context ) ;read_len = end_of_phar ;",959
1360,PHP_SHA1Init ( & context ) ;read_len = end_of_phar ;,"if ( sig_len < sizeof ( digest ) ) {if ( error ) {spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ;}return FAILURE ;}PHP_SHA1Init ( & context ) ;read_len = end_of_phar ;",959
1361,PHP_MD5Init ( & context ) ;read_len = end_of_phar ;,"if ( sig_len < sizeof ( digest ) ) {read_size = sizeof ( buf ) ;}else {read_size = ( int ) read_len ;}while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) {PHP_MD5Update ( & context , buf , len ) ;read_len -= ( zend_off_t ) len ;if ( read_len < read_size ) {read_size = ( int ) read_len ;}}PHP_MD5Final ( digest , & context ) ;if ( memcmp ( digest , sig , sizeof ( digest ) ) ) {if ( error ) {spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ;}return FAILURE ;}PHP_MD5Init ( & context ) ;read_len = end_of_phar ;",959
1362,"* signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ;break ;","* signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ;break ;",959
1363,if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) &&  value [ n ] >= min && value [ n ] <= max &&  field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ;,if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && value [ n ] >= min && value [ n ] <= max && value [ n ] - min < field -> maxusage && field -> value [ n ] - min < field -> maxusage && field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ;,960
1364,"if ( field -> value [ n ] >= min && field -> value [ n ] <= max  && field -> usage [ field -> value [ n ] - min ] . hid  && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ;if ( value [ n ] >= min && value [ n ] <= max  && field -> usage [ value [ n ] - min ] . hid  && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ;","if ( field -> value [ n ] >= min && field -> value [ n ] <= max && value [ n ] - min < field -> maxusage && field -> usage [ field -> value [ n ] - min ] . hid && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ;if ( value [ n ] >= min && value [ n ] <= max && field -> usage [ value [ n ] - min ] . hid && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ;",960
1365,"static void write_display_size ( const VP9_COMMON * cm ,  struct vp9_write_bit_buffer * wb ) {const int scaling_active = cm -> width != cm -> display_width || cm -> height != cm -> display_height ;vp9_wb_write_bit ( wb , scaling_active ) ;if ( scaling_active ) {vp9_wb_write_literal ( wb , cm -> display_width - 1 , 16 ) ;vp9_wb_write_literal ( wb , cm -> display_height - 1 , 16 ) ;}","static void write_display_size ( const VP9_COMMON * cm , struct vpx_write_bit_buffer * wb ) {const int scaling_active = cm -> width != cm -> display_width || cm -> height != cm -> display_height ;vpx_wb_write_bit ( wb , scaling_active ) ;if ( scaling_active ) {vpx_wb_write_literal ( wb , cm -> display_width - 1 , 16 ) ;vpx_wb_write_literal ( wb , cm -> display_height - 1 , 16 ) ;}",961
1366,if ( argReg >= regsz ) {},if ( argReg > regsz ) {return ;},962
1367,"rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ;rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ;","rb_hash_aset ( env , remote_addr_val , req_remote_addr ( req ) ) ;rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ;rb_hash_aset ( env , server_name_val , req_server_name ( req ) ) ;rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ;",963
1368,valuelen = be16_to_cpu ( name_loc -> valuelen ) ;,"args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , valuelen ) ;",964
1369,"memcpy ( args -> value , & name_loc -> nameval [ args -> namelen ] , valuelen ) ;else {name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ;ASSERT ( name_rmt -> namelen == args -> namelen ) ;ASSERT ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) == 0 ) ;valuelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount ,  valuelen ) ;if ( args -> flags & ATTR_KERNOVAL ) {args -> valuelen = valuelen ;return 0 ;}if ( args -> valuelen < valuelen ) {args -> valuelen = valuelen ;return XFS_ERROR ( ERANGE ) ;}args -> valuelen = valuelen ;}","
",964
1370,size_t sz = sizeof ( * info ) + size ;if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ;,size_t sz = sizeof ( * info ) + size ;if ( sz < sizeof ( * info ) ) return NULL ;if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ;,965
1371,"# endif # endif  int col_type , prepare_retval ;MYSQL_BIND * bind , * bind_end ;","# endif # endif int prepare_retval ;MYSQL_BIND * bind , * bind_end ;",966
1372,"if ( imp_sth -> stmt ) fprintf ( stderr ,  ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\\\imp_sth -> stmt = mysql_stmt_init ( imp_dbh -> pmysql ) ;if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) ,  ""\\\\t\\\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\\\","if ( imp_sth -> stmt ) fprintf ( stderr , ""ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\\\imp_sth -> stmt = mysql_stmt_init ( imp_dbh -> pmysql ) ;if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\\\t\\\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\\\",966
1373,int has_statement_fields = imp_sth -> stmt -> fields != 0 ;imp_sth -> bind = alloc_bind ( DBIc_NUM_PARAMS ( imp_sth ) ) ;col_type = ( has_statement_fields ?  imp_sth -> stmt -> fields [ i ] . type : MYSQL_TYPE_STRING ) ;,imp_sth -> bind = alloc_bind ( DBIc_NUM_PARAMS ( imp_sth ) ) ;bind -> buffer_type = MYSQL_TYPE_STRING ;,966
1374,if ( key -> type -> destroy )  key -> type -> destroy ( key ) ;,"if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ;",967
1375,"commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;query = ( ltxtquery * ) palloc ( commonlen ) ;","if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;query = ( ltxtquery * ) palloc ( commonlen ) ;",968
1376,int need = 0 ;Char * line ;,int need = 0 ;size_t have = 0 ;Char * line ;,969
1377,"need *= 4 ;}) ;if ( need < 0 ) return ;if ( scp -> data_limit <= ( unsigned ) need ) {if ( ( line = ( Char * ) malloc ( ( size_t ) need + 1 ) ) == 0 ) SysError ( ERROR_BMALLOC2 ) ;free ( scp -> data_buffer ) ;scp -> data_buffer = line ;scp -> data_limit = ( size_t ) ( need + 1 ) ;}else {line = scp -> data_buffer ;if ( line == 0 ) return ;line [ need ] = \'\\\\0\' ;lp = line ;if ( isSameRow ( & last , & first ) ) {lp = SaveText ( screen , last . row , first . col , last . col , lp , & eol ) ;else {lp = SaveText ( screen , first . row , first . col , screen -> max_col , lp , & eol ) ;if ( eol ) * lp ++ = \'\\\for ( i = first . row + 1 ;i < last . row ;i ++ ) {lp = SaveText ( screen , i , 0 , screen -> max_col , lp , & eol ) ;if ( eol ) * lp ++ = \'\\\}if ( last . col >= 0 ) lp = SaveText ( screen , last . row , 0 , last . col , lp , & eol ) ;* lp = \'\\\\0\' ;TRACE ( ( ""Salted<S2SV_blank>TEXT:%u:%s\\\scp -> data_length = ( size_t ) ( lp - line ) ;}","if ( need > 0 ) {if ( screen -> max_combining > 0 ) need += screen -> max_combining ;need *= 6 ;) ;if ( need < 0 ) return ;if ( scp -> data_limit <= ( unsigned ) have , visibleChars ( line , ( unsigned ) ( lp - line ) ) ) ) ;scp -> data_length = have ;",969
1378,"if ( handle && ! ext4_handle_valid ( handle ) )  return 0 ;if ( list_empty ( & ei -> i_orphan ) ) goto out ;ino_next = NEXT_ORPHAN ( inode ) ;prev = ei -> i_orphan . prev ;sbi = EXT4_SB ( inode -> i_sb ) ;jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\\list_del_init ( & ei -> i_orphan ) ;if ( sbi -> s_journal && ! handle )  goto out ;",if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) return 0 ;if ( ! handle ) goto out ;,970
1379,"void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) {const JsVarFloat stopAtError = 0.0000001 ;if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ;else if ( ! isfinite ( val ) ) {if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ;else strncpy ( str , ""Infinity"" , len ) ;}","void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) {assert ( len > 9 ) ;const JsVarFloat stopAtError = 0.0000001 ;if ( isnan ( val ) ) strcpy ( str , ""NaN"" , len ) ;else if ( ! isfinite ( val ) ) {if ( val < 0 ) strcpy ( str , ""-Infinity"" , len ) ;else strcpy ( str , ""Infinity"" , len ) ;}",971
1380,"fseek ( f , 0 , SEEK_SET ) ;if ( fscanf ( f , ""PG%[<S2SV_blank>\\\\t]%c%c%[<S2SV_blank>\\\\t+-]%d%[<S2SV_blank>\\\\t]%d%[<S2SV_blank>\\\\t]%d"" , temp , & endian1 ,  & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) {","fseek ( f , ""PG%31[<S2SV_blank>\\\\t]%c%c%31[<S2SV_blank>\\\\t+-]%d%31[<S2SV_blank>\\\\t]%d%31[<S2SV_blank>\\\\t]%d"" , temp , & endian1 , & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) {",972
1381,if ( size < 6 )  ASSERT ( result != buf ) ;},"if ( size < 5 + 1 ) ASSERT ( result != buf ) ;for ( size = 0 ;size <= 8 ;size ++ ) {size_t length ;char * result ;memcpy ( buf , ""DEADBEEF"" , 8 ) ;length = size ;result = my_asnprintf ( buf , & length , ""%2.0f"" , 1.6314159265358979e+125 ) ;ASSERT ( result != NULL ) ;ASSERT ( strcmp ( result , ""163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208"" ) == 0 ) ;ASSERT ( length == 126 ) ;if ( size < 126 + 1 ) ASSERT ( result != buf ) ;ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ;if ( result != buf ) free ( result ) ;}}",973
1382,"if ( unlikely ( crng_init == 0 ) ) {if ( ( fast_pool -> count >= 64 ) && crng_fast_load ( ( char * ) fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ) {","this_cpu_add ( net_rand_state . s1 , fast_pool -> pool [ cycles & 3 ] ) ;if ( unlikely ( crng_init == 0 ) ) {if ( ( fast_pool -> count >= 64 ) && crng_fast_load ( ( char * ) fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ) {",974
1383,"strncpy ( str , ""ID:"" , len ) ;strncat ( str , jslGetTokenValueAsString ( ) , len ) ;}else if ( lex -> tk == LEX_STR ) {strncpy ( str , ""String:\\\'"" , len ) ;strncat ( str , jslGetTokenValueAsString ( ) , len ) ;strncat ( str , ""\\\'"" , len ) ;","espruino_snprintf ( str , ""ID:"" , len ) ;strncat ( str , len , ""ID:%s"" , jslGetTokenValueAsString ( ) , len ) ;strncat ( str , ""\\\'"" , len ) ;",975
1384,"char * to , * repl ;to = g . inf ;if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {to = g . hname ;len = strlen ( g . hname ) ;}repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ;g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ;if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ;memcpy ( g . outf , to , len ) ;strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ;g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ;","char * to = g . inf , * sufx = """" ;size_t pre = 0 ;if ( g . decode ) {if ( ( g . headis & 1 ) != 0 && g . hname != NULL ) {pre = justname ( g . inf ) - g . inf ;to = justname ( g . hname ) ;len = strlen ( to ) ;}else if ( strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ;g . outf = MALLOC ( pre + len + strlen ( sufx ) + 1 ) ;if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ;memcpy ( g . outf , g . inf , pre ) ;memcpy ( g . outf + pre , to , len ) ;strcpy ( g . outf + pre + len , sufx ) ;g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ;",976
1385,int  c ;,MagickBooleanType status ;int c ;,977
1386,"for ( i = 2 ;# if 0 fprintf ( stderr , ""DEBUG:<S2SV_blank>Concatenate<S2SV_blank>Image:<S2SV_blank>\\\\""%s\\\\""\\\# endif input = fopen_utf8 ( argv [ i ] , ""rb"" ) ;c = fgetc ( input ) )  ( void ) fputc ( ( char ) c , output ) ;( void ) fclose ( input ) ;( void ) remove_utf8 ( argv [ i ] ) ;return ( MagickTrue ) ;}","status = MagickTrue ;for ( i = 2 ;input = fopen_utf8 ( argv [ i ] , ""rb"" ) ;c = fgetc ( input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ;( void ) fclose ( input ) ;( void ) fclose ( input ) ;( void ) remove_utf8 ( argv [ i ] ) ;return ( MagickTrue ) ;}",977
1387,SvcInternal * const si = get_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || options == NULL || si == NULL ) {,SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;if ( svc_ctx == NULL || options == NULL || si == NULL ) {,978
1388,"fail :  ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" ,  __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ;","fail : ext3_msg ( sb , KERN_ERR , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ;",979
1389,"int setpwnam ( struct passwd * pwd )  {int save_errno ;int found ;int namelen ;int buflen = 256 ;int contlen , rc ;char * linebuf = NULL ;char * tmpname = NULL ;char * atomic_dir = ""/etc"" ;pw_init ( ) ;if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL )  return - 1 ;","int setpwnam ( struct passwd * pwd , const char * prefix ) {pw_init ( ) ;if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) return - 1 ;",980
1390,"static unsigned int convert_distribution ( unsigned int i , vp9_tree tree ,  unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) {","static unsigned int convert_distribution ( unsigned int i , vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) {",981
1391,"return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ;}","const size_t s1_len = strlen ( s1 ) ;const size_t s2_len = strlen ( s2 ) ;const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ;return pure_memcmp ( s1 , s2 , len + 1 ) ;}",982
1392,"
","Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ;const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ;Jid * msg_jid = jid_create ( stanza_from ) ;if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) {log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ;return TRUE ;}",983
1393,const gchar * to = xmpp_stanza_get_to ( message ) ;const gchar * from = xmpp_stanza_get_from ( message ) ;Jid * jid_to = jid_create ( to ) ;Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ;,const gchar * to = xmpp_stanza_get_to ( message ) ;const gchar * from = xmpp_stanza_get_from ( message ) ;Jid * jid_to = jid_create ( to ) ;,983
1394,"config_set_special_field ( ""dbfilename"" ) {if ( ! pathIsBaseName ( o -> ptr ) ) {addReplyError ( c , ""dbfilename<S2SV_blank>can\\\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ) ;return ;}zfree ( server . rdb_filename ) ;server . rdb_filename = zstrdup ( o -> ptr ) ;}config_set_special_field ( ""requirepass"" ) {if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ;zfree ( server . requirepass ) ;server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ;}config_set_special_field ( ""masterauth"" ) {zfree ( server . masterauth ) ;server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ;}config_set_special_field ( ""cluster-announce-ip"" ) {zfree ( server . cluster_announce_ip ) ;server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ;}config_set_special_field ( ""maxclients"" ) {int orig_value = server . maxclients ;if ( getLongLongFromObject ( o , & ll ) == C_ERR || ll < 1 ) goto badfmt ;server . maxclients = ll ;if ( ll > orig_value ) {adjustOpenFilesLimit ( ) ;if ( server . maxclients != ll ) {addReplyErrorFormat ( c , ""The<S2SV_blank>operating<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients,<S2SV_blank>try<S2SV_blank>with<S2SV_blank>%d"" , server . maxclients ) ;server . maxclients = orig_value ;return ;}if ( ( unsigned int ) aeGetSetSize ( server . el ) < server . maxclients + CONFIG_FDSET_INCR ) {if ( aeResizeSetSize ( server . el , server . maxclients + CONFIG_FDSET_INCR ) == AE_ERR ) {addReplyError ( c , ""The<S2SV_blank>event<S2SV_blank>loop<S2SV_blank>API<S2SV_blank>used<S2SV_blank>by<S2SV_blank>Redis<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients"" ) ;server . maxclients = orig_value ;return ;}}}}config_set_special_field ( ""appendonly"" ) {int enable = yesnotoi ( o -> ptr ) ;if ( enable == - 1 ) goto badfmt ;if ( enable == 0 && server . aof_state != AOF_OFF ) {stopAppendOnly ( ) ;}else if ( enable && server . aof_state == AOF_OFF ) {if ( startAppendOnly ( ) == C_ERR ) {addReplyError ( c , ""Unable<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>on<S2SV_blank>AOF.<S2SV_blank>Check<S2SV_blank>server<S2SV_blank>logs."" ) ;return ;}}}config_set_special_field ( ""save"" ) {int vlen , j ;sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , ""<S2SV_blank>"" , 1 , & vlen ) ;if ( vlen & 1 ) {for ( j = 0 ;j < vlen ;j ++ ) {char * eptr ;long val ;val = strtoll ( v [ j ] , & eptr , 10 ) ;if ( eptr [ 0 ] != \'\\\\0\' || ( ( j & 1 ) == 0 && val < 1 ) || ( ( j & 1 ) == 1 && val < 0 ) ) {sdsfreesplitres ( v , vlen ) ;goto badfmt ;}}resetServerSaveParams ( ) ;for ( j = 0 ;j < vlen ;j += 2 ) {time_t seconds ;int changes ;seconds = strtoll ( v [ j ] , NULL , 10 ) ;changes = strtoll ( v [ j + 1 ] , NULL , 10 ) ;appendServerSaveParams ( seconds , changes ) ;}sdsfreesplitres ( v , vlen ) ;}config_set_special_field ( ""dir"" ) {if ( chdir ( ( char * ) o -> ptr ) == - 1 ) {addReplyErrorFormat ( c , ""Changing<S2SV_blank>directory:<S2SV_blank>%s"" , strerror ( errno ) ) ;return ;}}config_set_special_field ( ""client-output-buffer-limit"" ) {int vlen , j ;sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , ""<S2SV_blank>"" , 1 , & vlen ) ;if ( vlen % 4 ) {sdsfreesplitres ( v , vlen ) ;goto badfmt ;}for ( j = 0 ;j < vlen ;j ++ ) {long val ;if ( ( j % 4 ) == 0 ) {if ( getClientTypeByName ( v [ j ] ) == - 1 ) {sdsfreesplitres ( v , vlen ) ;goto badfmt ;}",int class = getClientTypeByName ( v [ j ] ) ;if ( class == - 1 || class == CLIENT_TYPE_MASTER ) {,984
1395,"static int dev_get_valid_name ( struct net * net ,  struct net_device * dev , const char * name ) {","int dev_get_valid_name ( struct net * net , struct net_device * dev , const char * name ) {",985
1396,"parse_global_option ( CMD_PRINT_HELP , NULL , NULL ) ;parse_service_option ( CMD_PRINT_HELP , NULL , NULL , NULL ) ;parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ;parse_service_option ( CMD_PRINT_DEFAULTS , NULL , NULL , NULL ) ;","parse_global_option ( CMD_PRINT_HELP , NULL , NULL , NULL ) ;parse_service_option ( CMD_PRINT_HELP , NULL , NULL , NULL ) ;parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL , NULL ) ;parse_service_option ( CMD_PRINT_DEFAULTS , NULL , NULL , NULL ) ;",986
1397,if ( flags & MSG_OOB )  return - EOPNOTSUPP ;msg -> msg_namelen = 0 ;,if ( flags & MSG_OOB ) return - EOPNOTSUPP ;,987
1398,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,988
1399,"loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>ignored<S2SV_blank>because<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>payload<S2SV_blank>type<S2SV_blank>(%s)<S2SV_blank>unexpected<S2SV_blank>by<S2SV_blank>state<S2SV_blank>%s"" , excuse , enum_show ( & ikev1_payload_names , np ) ,  st -> st_state -> name ) ;if ( ! md -> encrypted ) {","loglog ( RC_LOG_SERIOUS , ""%smessage<S2SV_blank>ignored<S2SV_blank>because<S2SV_blank>it<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>payload<S2SV_blank>type<S2SV_blank>(%s)<S2SV_blank>unexpected<S2SV_blank>by<S2SV_blank>state<S2SV_blank>%s"" , excuse , enum_show ( & ikev1_payload_names , np ) , finite_states [ smc -> state ] -> name ) ;if ( ! md -> encrypted ) {",989
1400,"
",if ( 0 == ps_dec -> u4_frm_buf_stride ) {ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ;},990
1401,ps_dec -> u2_header_done = 1 ;},ps_dec -> u2_header_done = 1 ;},990
1402,"int x , y , i ;old_width = s_map -> layers [ layer ] . width ;if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) )  return false ;","size_t tilemap_size ;int x , y , i ;old_width = s_map -> layers [ layer ] . width ;tilemap_size = x_size * y_size * sizeof ( struct map_tile ) ;if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size ) ) ) return false ;",991
1403,"static void  ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ;}if ( ( length + 1 ) & 3 )  ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ;ptr = cp [ 2 ] - 1 ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ;if ( ptr > len ) ND_PRINT ( ( ndo , "","" ) ) ;}}","static int ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ( 0 ) ;}if ( ( length + 1 ) & 3 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]"" , length ) ) ;ND_TCHECK ( cp [ 2 ] ) ;ptr = cp [ 2 ] - 1 ;ND_TCHECK2 ( cp [ len ] , 4 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ;if ( ptr > len ) ND_PRINT ( ( ndo , "","" ) ) ;}return ( 0 ) ;trunc : return ( - 1 ) ;}",992
1404,static char * print_string ( cJSON * item )  {return print_string_ptr ( item -> valuestring ) ;},"static char * print_string ( cJSON * item , printbuffer * p ) {return print_string_ptr ( item -> valuestring , p ) ;}",993
1405,"if ( num_enc == 1 )  res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts ,  duration , flags , deadline ) ;","if ( num_enc == 1 ) res = ctx -> iface -> enc . encode ( get_alg_priv ( ctx ) , img , pts , duration , flags , deadline ) ;",994
1406,"if ( ( res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts ,  duration , flags , deadline ) ) ) break ;","if ( ( res = ctx -> iface -> enc . encode ( get_alg_priv ( ctx ) , img , pts , duration , flags , deadline ) ) ) break ;",994
1407,char buf [ L_BUF_SIZE ] ;l_uint8 * allheaders ;,char buf [ L_BUFSIZE ] ;l_uint8 * allheaders ;,995
1408,"ret = sscanf ( argv [ i ] + 1 , ""prestring=%s"" , buf ) ;if ( ret != 1 ) {if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) {L_WARNING ( ""prestring<S2SV_blank>too<S2SV_blank>large;","ret = sscanf ( argv [ i ] + 1 , ""prestring=%490s"" , buf ) ;if ( ret != 1 ) {if ( ( len = strlen ( buf ) ) > L_BUFSIZE - 3 ) {L_WARNING ( ""prestring<S2SV_blank>too<S2SV_blank>large;",995
1409,"ret = sscanf ( argv [ i ] + 1 , ""protos=%s"" , buf ) ;if ( ret != 1 ) {","ret = sscanf ( argv [ i ] + 1 , ""protos=%490s"" , buf ) ;if ( ret != 1 ) {",995
1410,"snprintf ( buf , L_BUF_SIZE ,  ""<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\\\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s"" , version ) ;","snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\\\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s"" , version ) ;",995
1411,"snprintf ( buf , L_BUF_SIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" ,  filein , tempfile ) ;","snprintf ( buf , L_BUFSIZE , ""cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"" , filein , tempfile ) ;",995
1412,if ( chunk_num > chm -> num_chunks ) return NULL ;if ( ! chm -> chunk_cache ) {,if ( chunk_num >= chm -> num_chunks ) return NULL ;if ( ! chm -> chunk_cache ) {,996
1413,"if ( ! validate_event ( & fake_pmu , leader ) )  return - EINVAL ;if ( ! validate_event ( & fake_pmu , sibling ) )  return - EINVAL ;if ( ! validate_event ( & fake_pmu , event ) )  return - EINVAL ;","if ( ! validate_event ( event -> pmu , & fake_pmu , leader ) ) return - EINVAL ;if ( ! validate_event ( event -> pmu , & fake_pmu , sibling ) ) return - EINVAL ;if ( ! validate_event ( event -> pmu , & fake_pmu , event ) ) return - EINVAL ;",997
1414,"
",usleep ( 1000 ) ;,998
1415,"}when 10 : if ( term . csi_argc != 2 ) return ;else if ( arg1 == 1 || arg1 == 0 )  win_maximise ( arg1 ? 2 : 0 ) ;when 11 : child_write ( win_is_iconic ( ) ? ""\\\\e[2t"" : ""\\\\e[1t"" , 4 ) ;","}when 10 : if ( term . csi_argc != 2 ) return ;else if ( arg1 == 1 || arg1 == 0 ) win_maximise ( arg1 ? 2 : 0 ) ;usleep ( 1000 ) ;when 11 : child_write ( win_is_iconic ( ) ? ""\\\\e[2t"" : ""\\\\e[1t"" , 4 ) ;",998
1416,"avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\\return AVERROR_PATCHWELCOME ;}s -> avctx -> profile = profile ;s -> avctx -> level = level ;}else if ( startcode == VISUAL_OBJ_STARTCODE ) {if ( s -> studio_profile ) {if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ;}else mpeg4_decode_visual_object ( s , gb ) ;}else if ( startcode == VOP_STARTCODE ) {break ;}align_get_bits ( gb ) ;startcode = 0xff ;}end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ;s -> avctx -> has_b_frames = ! s -> low_delay ;if ( s -> studio_profile ) {av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;if ( ! s -> avctx -> bits_per_raw_sample ) {",if ( ! s -> avctx -> bits_per_raw_sample ) {,999
1417,if ( nsops < 1 )  return - EINVAL ;,if ( nsops < 1 || nsops > SEMOPM ) return - EINVAL ;,1000
1418,for ( i = - 8 ;i < 0 ;i ++ ) s [ i ] = s [ 0 ] ;for ( i = cols ;i ++ )  s [ i ] = s [ cols - 1 ] ;,for ( i = 0 ;i < 17 ;i ++ ) s [ i + cols ] = s [ 0 ] ;for ( i = cols ;i ++ ) s [ i ] = s [ cols - 1 ] ;,1001
1419,if ( fileblock < INDIRECT_BLOCKS )  blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ;else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 )  {,if ( fileblock < INDIRECT_BLOCKS ) {blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ;}else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) {,1002
1420,"WritePixel ( i , & context , casspecial ) ;}act_code = old_code ;}while ( act_code > clr ) {* ( -- stackp ) = ab_suffx [ act_code ] ;act_code = ab_prfx [ act_code ] ;}casspecial = ( u8 ) act_code ;* ( -- stackp ) = casspecial ;WritePixels ( i , & context , stackp , stack_top - stackp ) ;npix -= ( stack_top - stackp ) ;","if ( npix > 0 ) WritePixel ( i , & context , casspecial ) ;}if ( npix >= ( stack_top - stackp ) ;npix -= ( stack_top - stackp ) ;",1003
1421,"size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;","size_t tail = ( i << 1 ) + 1 ;if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ;size_t ofs = CDF_GETUINT32 ( p , tail ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;",1004
1422,next_input = input + i * input_incr ;if ( bytes_matched + i >= max_bytes_matched )  break ;if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) {,if ( bytes_matched + i >= max_bytes_matched ) break ;next_input = input + i * input_incr ;if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) {,1005
1423,ip = next_opcode ;break ;,"bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;ip = next_opcode ;break ;",1005
1424,"void jslTokenAsString ( int token , char * str , size_t len ) {if ( token > 32 && token < 128 ) {","void jslTokenAsString ( int token , char * str , size_t len ) {assert ( len > 28 ) ;if ( token > 32 && token < 128 ) {",1006
1425,"case LEX_EOF : strncpy ( str , ""EOF"" , len ) ;case LEX_ID : strncpy ( str , ""ID"" , len ) ;case LEX_INT : strncpy ( str , ""INT"" , len ) ;case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ;case LEX_STR : strncpy ( str , ""STRING"" , len ) ;case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ;case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ;case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ;case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ;}","case LEX_EOF : strcpy ( str , ""EOF"" , len ) ;case LEX_ID : strcpy ( str , ""ID"" , len ) ;case LEX_INT : strcpy ( str , ""INT"" , len ) ;case LEX_FLOAT : strcpy ( str , ""FLOAT"" , len ) ;case LEX_STR : strcpy ( str , ""STRING"" , len ) ;case LEX_UNFINISHED_STR : strcpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ;case LEX_TEMPLATE_LITERAL : strcpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_REGEX : strcpy ( str , ""REGEX"" , len ) ;case LEX_UNFINISHED_REGEX : strcpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ;case LEX_UNFINISHED_COMMENT : strcpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ;}",1006
1426,"strncpy ( str , & tokenNames [ p ] , len ) ;return ;assert ( len >= 10 ) ;espruino_snprintf ( str , len , ""?[%d]"" , token ) ;","strcpy ( str , & tokenNames [ p ] ) ;return ;assert ( len >= 10 ) ;espruino_snprintf ( str , len , ""?[%d]"" , token ) ;",1006
1427,unlock_mount_hash ( ) ;if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) {,"if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) {struct mount * p , * tmp ;list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) {umount_mnt ( p ) ;}}unlock_mount_hash ( ) ;if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) {",1007
1428,"static void encode_term_subexp ( vp9_writer * w , int word ) {if ( ! write_bit_gte ( w , word , 16 ) ) {vp9_write_literal ( w , word , 4 ) ;}vp9_write_literal ( w , word - 16 , 4 ) ;}vp9_write_literal ( w , word - 32 , 5 ) ;}","static void encode_term_subexp ( vpx_writer * w , int word ) {if ( ! write_bit_gte ( w , word , 16 ) ) {vpx_write_literal ( w , word , 4 ) ;}vpx_write_literal ( w , word - 16 , 4 ) ;}vpx_write_literal ( w , word - 32 , 5 ) ;}",1008
1429,if ( ! e || e == p )  goto not_found ;,if ( ! e || e == p ) goto not_found ;if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;,1009
1430,int err = - EIO ;unsigned char * p = kmap ( page ) ;uint32_t pos ;iinfo = UDF_I ( inode ) ;,int err ;unsigned char * p = kmap ( page ) ;uint32_t pos ;if ( inode -> i_size > inode -> i_sb -> s_blocksize ) {err = - ENAMETOOLONG ;goto out_unmap ;}iinfo = UDF_I ( inode ) ;,1010
1431,if ( ! bh )  goto out ;,if ( ! bh ) {err = - EIO ;goto out_unlock_inode ;},1010
1432,out :  up_read ( & iinfo -> i_data_sem ) ;kunmap ( page ) ;unlock_page ( page ) ;,out_unlock_inode : up_read ( & iinfo -> i_data_sem ) ;out_unmap : kunmap ( page ) ;unlock_page ( page ) ;,1010
1433,else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) {if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode_x2apic ;,else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) ) {if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode_x2apic ;,1011
1434,"if ( ent != NULL ) {if ( ( st = populate_policy ( context , ld , ent , pol_name , * policy ) ) != 0 ) goto cleanup ;cleanup :  ldap_msgfree ( result ) ;","if ( ent == NULL ) {st = KRB5_KDB_NOENTRY ;goto cleanup ;st = populate_policy ( context , ld , ent , pol_name , * policy ) ;cleanup : ldap_msgfree ( result ) ;",1012
1435,"UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ;ps_pps -> i1_num_tile_columns = value + 1 ;if ( ( ps_pps -> i1_num_tile_columns < 1 ) ||  ( ps_pps -> i1_num_tile_columns > ps_sps -> i2_pic_wd_in_ctb ) ||  ( ps_pps -> i1_num_tile_rows < 1 ) ||  ( ps_pps -> i1_num_tile_rows > ps_sps -> i2_pic_ht_in_ctb ) )  return IHEVCD_INVALID_HEADER ;","WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ;WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ;WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ;WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ;UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ;ps_pps -> i1_num_tile_columns = value + 1 ;if ( ( ps_pps -> i1_num_tile_columns < 1 ) || ( ps_pps -> i1_num_tile_columns > max_tile_cols ) || ( ps_pps -> i1_num_tile_rows < 1 ) || ( ps_pps -> i1_num_tile_rows > max_tile_rows ) ) return IHEVCD_INVALID_HEADER ;",1013
1436,"struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;u64 bn , dblock = 0 ;const unsigned end_of_metadata = height - 1 ;int eob = 0 ;","struct super_block * sb = sdp -> sd_vfs ;struct buffer_head * dibh = mp -> mp_bh [ 0 ] ;u64 bn , dblock = 0 ;const unsigned end_of_metadata = height - 1 ;int ret ;int eob = 0 ;",1014
1437,"
","if ( buffer_zeronew ( bh_map ) ) {ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ;if ( ret ) {fs_err ( sdp , ""Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\\clear_buffer_zeronew ( bh_map ) ;}}",1014
1438,break ;},break ;},1014
1439,"while ( ( c = * format ++ ) )  {switch ( c )  {case \'<S2SV_blank>\' : break ;case \'e\' : psf -> rwf_endian = SF_ENDIAN_LITTLE ;break ;case \'E\' : psf -> rwf_endian = SF_ENDIAN_BIG ;break ;case \'t\' : trunc_8to4 = SF_TRUE ;break ;case \'T\' : trunc_8to4 = SF_FALSE ;break ;case \'m\' : data = va_arg ( argptr , unsigned int ) ;header_put_marker ( psf , data ) ;count += 4 ;break ;case \'1\' : data = va_arg ( argptr , unsigned int ) ;header_put_byte ( psf , data ) ;count += 1 ;break ;case \'2\' : data = va_arg ( argptr , unsigned int ) ;if ( psf -> rwf_endian == SF_ENDIAN_BIG ) {header_put_be_short ( psf , data ) ;}else {header_put_le_short ( psf , data ) ;};count += 2 ;break ;case \'3\' : data = va_arg ( argptr , unsigned int ) ;if ( psf -> rwf_endian == SF_ENDIAN_BIG ) {header_put_be_3byte ( psf , data ) ;}else {header_put_le_3byte ( psf , data ) ;};count += 3 ;break ;case \'4\' : data = va_arg ( argptr , unsigned int ) ;if ( psf -> rwf_endian == SF_ENDIAN_BIG ) {header_put_be_int ( psf , data ) ;}else {header_put_le_int ( psf , data ) ;};count += 4 ;break ;case \'8\' : countdata = va_arg ( argptr , sf_count_t ) ;if ( psf -> rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE ) {header_put_be_8byte ( psf , countdata ) ;count += 8 ;}else if ( psf -> rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE ) {header_put_le_8byte ( psf , countdata ) ;count += 8 ;}else if ( psf -> rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE ) {longdata = countdata & 0xFFFFFFFF ;header_put_be_int ( psf , longdata ) ;count += 4 ;}else if ( psf -> rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE ) {longdata = countdata & 0xFFFFFFFF ;header_put_le_int ( psf , longdata ) ;count += 4 ;}break ;case \'f\' : floatdata = ( float ) va_arg ( argptr , double ) ;if ( psf -> rwf_endian == SF_ENDIAN_BIG )  float32_be_write ( floatdata , psf -> header + psf -> headindex ) ;else  float32_le_write ( floatdata , psf -> header + psf -> headindex ) ;psf -> headindex += 4 ;if ( psf -> rwf_endian == SF_ENDIAN_BIG )  double64_be_write ( doubledata , psf -> header + psf -> headindex ) ;else  double64_le_write ( doubledata , psf -> header + psf -> headindex ) ;psf -> headindex += 8 ;size += ( size & 1 ) ;if ( psf -> rwf_endian == SF_ENDIAN_BIG ) header_put_be_int ( psf , size ) ;memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ;psf -> headindex += size ;psf -> header [ psf -> headindex - 1 ] = 0 ;count += 4 + size ;if ( psf -> rwf_endian == SF_ENDIAN_BIG )  header_put_be_int ( psf , size ) ;memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ;size += ( size & 1 ) ;psf -> headindex += size ;psf -> header [ psf -> headindex ] = 0 ;count += 4 + size ;header_put_byte ( psf , size ) ;memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ;psf -> headindex += size ;count += 1 + size ;if ( psf -> headindex + size < sizeof ( psf -> header ) )   {psf -> headindex += size ;","while ( ( c = * format ++ ) ) {if ( psf -> header . ptr + psf -> header . indx ) ;else float32_le_write ( floatdata , psf -> header + psf -> headindex ) ;psf -> headindex += 4 ;if ( psf -> rwf_endian == SF_ENDIAN_BIG ) double64_be_write ( doubledata , psf -> header + psf -> headindex ) ;else double64_le_write ( doubledata , psf -> header + psf -> headindex ) ;psf -> headindex += 8 ;size += ( size & 1 ) ;if ( psf -> rwf_endian == SF_ENDIAN_BIG ) header_put_be_int ( psf , size ) ;memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ;psf -> headindex += size ;psf -> header [ psf -> headindex - 1 ] = 0 ;count += 4 + size ;if ( psf -> rwf_endian == SF_ENDIAN_BIG ) header_put_be_int ( psf , size ) ;memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size + 1 ) ;size += ( size & 1 ) ;psf -> headindex += size ;psf -> header [ psf -> headindex ] = 0 ;count += 4 + size ;header_put_byte ( psf , size ) ;memcpy ( & ( psf -> header [ psf -> headindex ] ) , strptr , size ) ;psf -> headindex += size ;count += 1 + size ;if ( psf -> headindex + size < sizeof ( psf -> header ) ) {psf -> headindex += size ;",1015
1440,"psf -> header [ psf -> headindex ] = 0 ;psf -> headindex ++ ;size -- ;};break ;case \'h\' : bindata = va_arg ( argptr , void * ) ;memcpy ( & ( psf -> header [ psf -> headindex ] ) , bindata , 16 ) ;psf -> headindex += 16 ;count += 16 ;psf -> headindex += size ;count += size ;if ( size < sizeof ( psf -> header ) )  {psf -> headindex = size ;count = 0 ;};","psf -> header [ psf -> header . indx ] ) , bindata , 16 ) ;psf -> headindex += 16 ;count += 16 ;psf -> headindex += size ;count += size ;if ( ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ;psf -> header . indx = size ;",1015
1441,"if ( debug ) {printk ( KERN_INFO ""cx24116:<S2SV_blank>%s("" , __func__ ) ;printk ( "")<S2SV_blank>toneburst=%d\\\}if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) )  return - EINVAL ;","if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ;if ( debug ) {printk ( KERN_INFO ""cx24116:<S2SV_blank>%s("" , __func__ ) ;",1016
1442,"
","memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;",1017
1443,"cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ;memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ;","cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ;memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ;",1017
1444,"if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ;if ( sun_info . depth < 24 ) {size_t one ;image -> colors = sun_info . maplength ;one = 1 ;if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ;if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}case RMT_RAW : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ;if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ;image -> columns = sun_info . width ;image -> rows = sun_info . height ;if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) &&   ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = sun_info . depth ) > ( 8 * sun_info . length ) * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1018
1445,"length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;","length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;",1018
1446,"pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , 0600 ) ;if ( rv )  fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\fs_logger2 ( ""clone"" , dest ) ;}","copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0600 ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\fs_logger2 ( ""clone"" , dest ) ;}",1019
1447,"guint pkt_len ;int pktnum , hr , min , sec , csec ;","int pkt_len , pktnum , hr , min , sec , csec ;",1020
1448,"num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {* err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\\\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ;return FALSE ;","num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {* err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\\\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ;return FALSE ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;",1020
1449,int err = 0 ;if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ;,int err = 0 ;msg -> msg_namelen = 0 ;if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ;,1021
1450,"if ( ! php_var_unserialize ( & key , p , max , NULL TSRMLS_CC ) ) {zval_dtor ( key ) ;FREE_ZVAL ( key ) ;return 0 ;}if ( Z_TYPE_P ( key ) != IS_LONG && Z_TYPE_P ( key ) != IS_STRING ) {zval_dtor ( key ) ;FREE_ZVAL ( key ) ;return 0 ;}ALLOC_INIT_ZVAL ( data ) ;if ( ! php_var_unserialize ( & data , p , max , var_hash TSRMLS_CC ) ) {zval_dtor ( key ) ;FREE_ZVAL ( key ) ;zval_dtor ( data ) ;FREE_ZVAL ( data ) ;return 0 ;}if ( ! objprops ) {switch ( Z_TYPE_P ( key ) ) {case IS_LONG : if ( zend_hash_index_find ( ht , Z_LVAL_P ( key ) , ( void * * ) & old_data ) == SUCCESS ) {","if ( zend_hash_find ( ht , Z_LVAL_P ( key ) , ( void * * ) & old_data ) == SUCCESS ) {",1022
1451,"if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) {var_push_dtor ( var_hash , old_data ) ;","if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) {var_push_dtor ( var_hash , old_data ) ;",1022
1452,"strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ;return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ;","nla_strlcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME ) ;return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ;",1023
1453,io -> io_cleanup = mem_cleanup ;switch ( io -> regsize ) {,switch ( io -> regsize ) {,1024
1454,"
",io -> io_cleanup = mem_cleanup ;,1024
1455,return 0 ;},return 0 ;},1024
1456,"pipe_buf_get ( ipipe , ibuf ) ;* obuf = * ibuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}* obuf = * ibuf ;",1025
1457,assert ( p -> tokenpos <= p -> tokenlen ) ;if ( p -> tokenpos == p -> tokenlen ) {p -> tokenlen = p -> tokenlen * 2 + 256 ;,assert ( p -> tokenpos >= ( p -> tokenlen - 1 ) ) ;if ( p -> tokenpos == p -> tokenlen ) {p -> tokenlen = p -> tokenlen * 2 + 256 ;,1026
1458,static vp9_variance_fn_t get_block_variance_fn ( BLOCK_SIZE bsize ) {switch ( bsize ) {case BLOCK_8X8 :  return vp9_mse8x8 ;case BLOCK_16X8 :  return vp9_mse16x8 ;case BLOCK_8X16 :  return vp9_mse8x16 ;default :  return vp9_mse16x16 ;},static vpx_variance_fn_t get_block_variance_fn ( BLOCK_SIZE bsize ) {switch ( bsize ) {case BLOCK_8X8 : return vpx_mse8x8 ;case BLOCK_16X8 : return vp9_mse16x8 ;case BLOCK_8X16 : return vpx_mse8x16 ;default : return vp9_mse16x16 ;},1027
1459,dev -> header_ops = NULL ;dev -> netdev_ops = & isdn_netdev_ops ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> header_ops = NULL ;dev -> netdev_ops = & isdn_netdev_ops ;,1028
1460,for ( i = 0 ;i ++ )   chunk_size [ i ] = avio_rl32 ( pb ) ;for ( i = 0 ;i ++ )   chunk_offset [ i ] = avio_rl32 ( pb ) ;for ( i = 0 ;i ++ )  audio_size [ i ] = avio_rl32 ( pb ) & 0xFFFF ;for ( i = 0 ;if ( chunk_size [ i ] < 0 || audio_size [ i ] > chunk_size [ i ] ) {,for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;chunk_size [ i ] = avio_rl32 ( pb ) ;}for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;chunk_offset [ i ] = avio_rl32 ( pb ) ;}for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;audio_size [ i ] = avio_rl32 ( pb ) & 0xFFFF ;}for ( i = 0 ;if ( chunk_size [ i ] < 0 || audio_size [ i ] > chunk_size [ i ] ) {,1029
1461,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},1030
1462,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,1030
1463,if ( rep == NULL ) {,if ( rep != NULL && rep == NULL ) {,1031
1464,dhkey_info . subjectPublicKey . data = dh_pubkey ;,dhkey_info . subjectPublicKey . data = ( char * ) dh_pubkey ;,1031
1465,if ( rep -> u . dh_Info . kdfID ) {secret . data = server_key ;secret . length = server_key_len ;,if ( rep -> u . dh_Info . kdfID ) {secret . data = server_key ;secret . length = server_key_len ;,1031
1466,"if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse )  return ( ( void * ) NULL ) ;","if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) return ( ( void * ) NULL ) ;",1032
1467,"sprintf ( address , ""%s:%s"" , url , port ) ;if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ;","snprintf ( address , 254 , ""%s:%s"" , url , port ) ;if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ;",1033
1468,"if ( page && ( access ( page , R_OK ) == 0 ) )  {file_write ( page , wikitext ) ;http_response_printf ( res , ""success"" ) ;return ;}if ( page && ( unlink ( page ) > 0 ) )  {","if ( page && page_name_is_good ( page ) && ( access ( page , R_OK ) == 0 ) ) {if ( page_name_is_good ( page ) ) {}file_write ( page , wikitext ) ;http_response_printf ( res , ""success"" ) ;return ;}if ( page && page_name_is_good ( page ) && ( unlink ( page ) > 0 ) ) {",1034
1469,"if ( page == NULL ) page = http_request_get_query_string ( req ) ;if ( page && ( access ( page , R_OK ) == 0 ) )  {","if ( page && page_name_is_good ( page ) == NULL ) page = http_request_get_query_string ( req ) ;if ( page && ( access ( page , R_OK ) == 0 ) ) {",1034
1470,"
",unsigned int actual_size = f -> blocksize_1 / 2 ;unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ;unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ;,1035
1471,int n_read = r -> end - r -> begin ;int part_read = n_read / r -> part_size ;,int n_read = limit_r_end - limit_r_begin ;int part_read = n_read / r -> part_size ;,1035
1472,hdr = ( void * ) p - head -> iov_base ;dlen = head -> iov_len + rqstp -> rq_arg . page_len - hdr ;,hdr = ( void * ) p - head -> iov_base ;if ( hdr > head -> iov_len ) return 0 ;dlen = head -> iov_len + rqstp -> rq_arg . page_len - hdr ;,1036
1473,struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;unsigned long tmp ;write_lock ( & cluster -> cl_nodes_lock ) ;if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ;,struct o2nm_cluster * cluster ;unsigned long tmp ;o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {o2nm_unlock_subsystem ( ) ;return - EINVAL ;}write_lock ( & cluster -> cl_nodes_lock ) ;o2nm_unlock_subsystem ( ) ;if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ;,1037
1474,if ( ret )  return ret ;,if ( ret ) return ret ;,1037
1475,"v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ;if ( ! vb ) {dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\\return ;}","if ( ! vb ) {dev_dbg ( & dev -> pci -> dev , ""vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\\return ;}v4l2_buf = to_vb2_v4l2_buffer ( & vb -> vb . vb2_buf ) ;",1038
1476,"void * zcalloc ( size_t size ) {void * ptr = calloc ( 1 , size + PREFIX_SIZE ) ;","void * zcalloc ( size_t size ) {ASSERT_NO_SIZE_OVERFLOW ( size ) ;void * ptr = calloc ( 1 , size + PREFIX_SIZE ) ;",1039
1477,"ssize_t count ;if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ;","ssize_t count ;if ( bytes == 0 || items == 0 ) return 0 ;if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ;",1040
1478,if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip &&  rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) &&  rxent -> dport == sport ) {,if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && rxent -> serviceId == EXTRACT_16BITS ( & rxh -> serviceId ) && rxent -> dport == sport ) {,1041
1479,"ret = key_permission ( key_ref , KEY_NEED_READ ) ;if ( ret == 0 ) goto can_read_key ;","if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}ret = key_permission ( key_ref , KEY_NEED_READ ) ;if ( ret == 0 ) goto can_read_key ;",1042
1480,"memset ( adhoc_start -> ssid , 0 , IEEE80211_MAX_SSID_LEN ) ;memcpy ( adhoc_start -> ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ;","memset ( adhoc_start -> ssid , 0 , IEEE80211_MAX_SSID_LEN ) ;if ( req_ssid -> ssid_len > IEEE80211_MAX_SSID_LEN ) req_ssid -> ssid_len = IEEE80211_MAX_SSID_LEN ;memcpy ( adhoc_start -> ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ;",1043
1481,if ( error ) return error ;,if ( error ) {kmem_free ( sbuf ) ;return error ;},1044
1482,if ( error )  return error ;if ( context -> seen_enough )  break ;,if ( error ) return error ;if ( context -> seen_enough ) break ;,1044
1483,"int X509_verify ( X509 * a , EVP_PKEY * r )  {return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;","int X509_verify ( X509 * a , EVP_PKEY * r ) {if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;",1045
1484,"hrtimer_cancel ( & stime -> hrt ) ;hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ;","hrtimer_try_to_cancel ( & stime -> hrt ) ;hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ;",1046
1485,"while ( p < q ) p += enclen ( reg -> enc , p ) ;}","if ( q >= end ) return 0 ;while ( p < q ) p += enclen ( reg -> enc , p ) ;}",1047
1486,"struct l2cap_conf_rfc rfc = {. mode = L2CAP_MODE_BASIC }void * ptr = req -> data ;switch ( pi -> mode ) {case L2CAP_MODE_BASIC : if ( pi -> imtu != L2CAP_DEFAULT_MTU ) l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> imtu ) ;rfc . txwin_size = L2CAP_DEFAULT_RX_WINDOW ;rfc . max_transmit = L2CAP_DEFAULT_MAX_RECEIVE ;rfc . retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ;rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ;rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ;","struct l2cap_conf_rfc rfc = {. mode = L2CAP_MODE_ERTM }void * ptr = req -> data ;if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ;switch ( pi -> mode ) {case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ;if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) {struct l2cap_disconn_req req ;req . dcid = cpu_to_le16 ( pi -> dcid ) ;req . scid = cpu_to_le16 ( pi -> scid ) ;l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ;}break ;default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ;break ;}done : switch ( pi -> mode ) {case L2CAP_MODE_BASIC : if ( pi -> imtu != L2CAP_DEFAULT_MTU ) l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> imtu ) ;rfc . txwin_size = L2CAP_DEFAULT_TX_WINDOW ;rfc . max_transmit = L2CAP_DEFAULT_MAX_RECEIVE ;rfc . retrans_timeout = 0 ;rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ;rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ;",1048
1487,"do ret = recv ( sock_fd , buf , r , MSG_WAITALL ) ;while ( ret < 0 && errno == EINTR ) ;","do ret = TEMP_FAILURE_RETRY ( recv ( sock_fd , buf , r , MSG_WAITALL ) ) ;while ( ret < 0 && errno == EINTR ) ;",1049
1488,s -> chunksize = - 1 ;for ( ;,s -> chunksize = UINT64_MAX ;for ( ;,1050
1489,"if ( pu1_buf ) {if ( u4_length ) {ps_dec_op -> u4_frame_decoded_flag = 0 ;ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ;SWITCHOFFTRACE ;u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ;if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) {H264_DEC_DEBUG_PRINT ( ""\\\}u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ;if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ps_dec -> u1_pic_decode_done != 1 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) {return ERROR_INCOMPLETE_FRAME ;}ps_dec -> u1_nal_unit_type = u1_nal_unit_type ;u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ;switch ( u1_nal_unit_type ) {case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ;break ;case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( ""Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\\if ( ! ps_dec -> i4_decode_header ) {if ( ps_dec -> i4_header_decoded == 3 ) {ps_dec -> u4_slice_start_code_found = 1 ;ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ;i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ;if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) &&  ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) {ps_dec -> u4_first_slice_in_pic = 1 ;}","
",1051
1490,"while ( pair != 0 ) {mprAddItem ( app -> formData , sclone ( pair ) ) ;","while ( pair ) {mprAddItem ( app -> formData , sclone ( pair ) ) ;",1052
1491,"err = tfm -> seed ( tfm , seed , slen ) ;kfree ( buf ) ;","err = crypto_rng_alg ( tfm ) -> seed ( tfm , seed , slen ) ;kfree ( buf ) ;",1053
1492,"atomic_set ( & new -> count , 0 ) ;spin_lock_irq ( & ucounts_lock ) ;","new -> count , 0 ) ;spin_lock_irq ( & ucounts_lock ) ;",1054
1493,"if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) )  ucounts = NULL ;","if ( ucounts -> count , 1 , INT_MAX ) ) ucounts = NULL ;",1054
1494,"out_put :  fput_light ( sock -> file , fput_needed ) ;if ( err == 0 )  return datagrams ;if ( datagrams != 0 ) {return datagrams ;}return err ;}","if ( err == 0 ) goto out_put ;if ( datagrams == 0 ) return datagrams ;if ( datagrams != 0 ) {out_put : fput_light ( sock -> file , fput_needed ) ;return datagrams ;}",1055
1495,void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields )  {,static void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {,1056
1496,"static void prefetch_table ( const volatile byte * tab , size_t len )  {for ( i = 0 ;i < len ;i += 8 * 32 )  {","static inline void prefetch_table ( const volatile byte * tab , size_t len ) {for ( i = 0 ;len - i >= 8 * 32 ;i += 8 * 32 ) {",1057
1497,( void ) tab [ len - 1 ] ;},for ( ;i < len ;i += 32 ) {( void ) tab [ i ] ;}( void ) tab [ len - 1 ] ;},1057
1498,if ( cache_type ) {,if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) {,1058
1499,"
",if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;,1058
1500,if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {if ( io ) io -> flag = EXT4_IO_UNWRITTEN ;}},if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {if ( io ) io -> flag = EXT4_IO_UNWRITTEN ;}},1058
1501,"static int update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , nfs4_stateid * delegation , int open_flags )  {open_flags &= ( FMODE_READ | FMODE_WRITE ) ;rcu_read_lock ( ) ;if ( nfsi -> delegation != deleg_cur ||  ( deleg_cur -> type & open_flags ) != open_flags )  goto no_delegation_unlock ;__update_open_stateid ( state , open_stateid , & deleg_cur -> stateid , open_flags ) ;ret = 1 ;__update_open_stateid ( state , open_stateid , NULL , open_flags ) ;ret = 1 ;","static int update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , nfs4_stateid * delegation , fmode_t fmode ) {fmode &= ( FMODE_READ | FMODE_WRITE ) ;rcu_read_lock ( ) ;if ( nfsi -> delegation != deleg_cur || ( deleg_cur -> type & fmode ) != fmode ) goto no_delegation_unlock ;__update_open_stateid ( state , open_stateid , & deleg_cur -> stateid , fmode ) ;ret = 1 ;__update_open_stateid ( state , open_stateid , NULL , fmode ) ;ret = 1 ;",1059
1502,"if ( global_colormap == ( unsigned char * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) {","if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap ) ) ;if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) {",1060
1503,"return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;}","return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ;}",1061
1504,"static void oidc_scrub_headers ( request_rec * r ) {oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ;","void oidc_scrub_headers ( request_rec * r ) {oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ;",1062
1505,"static void model_rd_for_sb ( VP9_COMP * cpi , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd ,  int * out_rate_sum , int64_t * out_dist_sum ) {int i ;for ( i = 0 ;struct macroblock_plane * const p = & x -> plane [ i ] ;( void ) cpi -> fn_ptr [ bs ] . vf ( p -> src . buf , p -> src . stride ,   pd -> dst . buf , pd -> dst . stride , & sse ) ;if ( i == 0 )   x -> pred_sse [ ref ] = sse ;if ( cpi -> speed > 4 ) {int64_t rate ;int64_t dist ;int64_t square_error = sse ;int quantizer = ( pd -> dequant [ 1 ] >> 3 ) ;if ( quantizer < 120 ) rate = ( square_error * ( 280 - quantizer ) ) >> 8 ;int rate ;int64_t dist ;vp9_model_rd_from_var_lapndz ( sse , 1 << num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> 3 , & rate , & dist ) ;* out_rate_sum = ( int ) rate_sum ;* out_dist_sum = dist_sum << 4 ;","static void model_rd_for_sb ( VP9_COMP * cpi , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd , int * out_rate_sum , int64_t * out_dist_sum , int * skip_txfm_sb , int64_t * skip_sse_sb ) {int i ;unsigned int var = 0 ;unsigned int sum_sse = 0 ;int64_t total_sse = 0 ;int skip_flag = 1 ;const int shift = 6 ;int rate ;int64_t dist ;const int dequant_shift = # if CONFIG_VP9_HIGHBITDEPTH ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd - 5 : # endif 3 ;x -> pred_sse [ ref ] = 0 ;for ( i = 0 ;struct macroblock_plane * const p = & x -> plane [ i ] ;const TX_SIZE max_tx_size = max_txsize_lookup [ bs ] . vf ( p -> src . buf + ( idy * p -> src . stride << lh ) + ( idx << lw ) ;uint8_t * dst = pd -> dst . buf + ( idy * pd -> dst . stride << lh ) + ( idx << lh ) ;int block_idx = ( idy << 1 ) + idx ;int low_err_skip = 0 ;var = cpi -> fn_ptr [ unit_size ] . vf ( src , p -> src . stride , dst , pd -> dst . stride , & sse ) ;x -> bsse [ ( i << 2 ) + block_idx ] = sse ;sum_sse += sse ;x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_NONE ;if ( ! x -> select_tx_size ) {if ( var < ac_thr || var == 0 ) {x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_ONLY ;if ( sse - var < dc_thr || sse == var ) {x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_DC ;if ( ! sse || ( var < low_ac_thr && sse - var < low_dc_thr ) ) low_err_skip = 1 ;}}}if ( skip_flag && ! low_err_skip ) skip_flag = 0 ;if ( i == 0 ) x -> pred_sse [ ref ] += sse ;}}total_sse += sum_sse ;if ( cpi -> sf . simple_model_rd_from_var ) {int64_t rate ;int64_t dist ;int64_t square_error = sum_sse ;int quantizer = ( pd -> dequant [ 1 ] >> dequant_shift ) ;if ( quantizer < 120 ) rate = ( square_error * ( 280 - quantizer ) ) >> 8 ;vp9_model_rd_from_var_lapndz ( sum_sse , num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> dequant_shift , & rate , & dist ) ;* skip_txfm_sb = skip_flag ;* skip_sse_sb = total_sse << 4 ;* out_rate_sum = ( int ) rate_sum ;* out_dist_sum = dist_sum << 4 ;",1063
1506,"if ( pmd_none_or_clear_bad ( pmd ) )  mincore_unmapped_range ( vma , addr , next , vec ) ;","if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) mincore_unmapped_range ( vma , addr , next , vec ) ;",1064
1507,"ND_TCHECK ( * esis_header ) ;li = esis_header -> length_indicator ;optr = pptr ;if ( esis_header -> nlpid != NLPID_ESIS ) {ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ;return ;}if ( esis_header -> version != ESIS_VERSION ) {ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ;return ;}if ( li > length ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ;return ;}if ( li < sizeof ( struct esis_header_t ) + 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ;while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ;return ;}esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ;if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ;return ;}else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\\",ND_TCHECK ( * tptr ) ;,1065
1508,"ND_TCHECK ( * pptr ) ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ;","ND_TCHECK ( * pptr ) ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ;",1065
1509,trunc :  return ;},"trunc : ND_PRINT ( ( ndo , ""[|esis]"" ) ) ;}",1065
1510,"while ( ( * ptr == '<S2SV_blank>' ) || ( * ptr == '\\\\t' ) ) ptr ++ ;if ( * ptr == '\\\\0' ) {return ( PAM_BUF_ERR ) ;while ( * ptr != '\\\\0' ) {if ( ( * ptr == '<S2SV_blank>' ) || ( * ptr == '\\\\t' ) )  break ;if ( ( * ret_username = malloc ( index + 1 ) ) == NULL )  return ( PAM_BUF_ERR ) ;( void ) strcpy ( * ret_username , username ) ;return ( PAM_SUCCESS ) ;",while ( ( * ptr == '<S2SV_blank>' ) || ( * ptr == '\\\\t' ) || ( index >= PAM_MAX_RESP_SIZE ) ) {break ;if ( index >= PAM_MAX_RESP_SIZE || ( * ret_username = malloc ( index + 1 ) ) == NULL ) return ( PAM_BUF_ERR ) ;return ( PAM_SUCCESS ) ;,1066
1511,"static int read_segment_id ( vp9_reader * r , const struct segmentation * seg ) {return vp9_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ;}","static int read_segment_id ( vpx_reader * r , const struct segmentation * seg ) {return vpx_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ;}",1067
1512,uint32_t backup_handle ;if ( req -> multisample_count != 0 ) return - EINVAL ;,uint32_t backup_handle = 0 ;if ( req -> multisample_count != 0 ) return - EINVAL ;,1068
1513,if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE <  res -> backup_size ) {goto out_unlock ;},if ( ret == 0 ) {if ( res -> backup -> base . num_pages * PAGE_SIZE < res -> backup_size ) {goto out_unlock ;}else {backup_handle = req -> buffer_handle ;}},1068
1514,static struct desc_struct * get_desc ( unsigned short sel )  {struct desc_struct * desc = NULL ;struct ldt_struct * ldt ;if ( ldt && sel < ldt -> nr_entries )   desc = & ldt -> entries [ sel ] ;mutex_unlock ( & current -> active_mm -> context . lock ) ;return desc ;}if ( desc_base > gdt_desc . size )  return NULL ;return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ;},"static bool get_desc ( struct desc_struct * out , unsigned short sel ) {bool success = false ;struct ldt_struct * ldt ;if ( ldt && sel < ldt -> nr_entries ) {* out = ldt -> entries [ sel ] ;success = true ;}mutex_unlock ( & current -> active_mm -> context . lock ) ;return success ;}if ( desc_base > gdt_desc . size ) return false ;* out = * ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ;return true ;}",1069
1515,"vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ;vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ;src_ptr1 += src_stride ;","memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ;memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ;src_ptr1 += src_stride ;",1070
1516,"vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ;dst_ptr1 += src_stride ;vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ;dst_ptr2 += src_stride ;","memcpy ( dst_ptr1 , src_ptr1 , linesize ) ;dst_ptr1 += src_stride ;memcpy ( dst_ptr2 , src_ptr2 , linesize ) ;dst_ptr2 += src_stride ;",1070
1517,struct sctp_sockaddr_entry * laddr ;union sctp_addr * baddr = NULL ;__u8 matchlen = 0 ;__u8 bmatchlen ;,"struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct sctp_sockaddr_entry * laddr ;union sctp_addr * baddr = NULL ;struct in6_addr * final_p , final ;__u8 matchlen = 0 ;__u8 bmatchlen ;",1071
1518,"dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ;if ( ! asoc || saddr ) goto out ;","final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , fl6 , final_p , false ) ;if ( ! asoc || saddr ) goto out ;",1071
1519,"dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ;}","final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , fl6 , final_p , false ) ;}",1071
1520,"static void kgdb_hw_overflow_handler ( struct perf_event * event , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","static void kgdb_hw_overflow_handler ( struct perf_event * event , struct perf_sample_data * data , struct pt_regs * regs ) {",1072
1521,"buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ;depth -- ;","if ( depth == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ;else buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ;depth -- ;",1073
1522,if ( client -> priv -> protocol_timeout ) {g_source_remove ( client -> priv -> protocol_timeout ) ;client -> priv -> protocol_timeout = 0 ;},"
",1074
1523,"while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) {const struct id_off * io , * ie ;for ( ie = io + ps -> nid ;io < ie && ! ND_TTEST ( * io ) ;ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ;","while ( -- n >= 0 && ND_TTEST ( * ps ) ) {const struct id_off * io , * ie ;for ( ie = io + ps -> nid ;io < ie && ND_TTEST ( * io ) ;ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ;",1075
1524,"n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ;if ( n < ( length + 8 ) ) {header . controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID ) ) ;header . byteCount = htole16 ( length ) ;ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ;ksz8851WriteFifo ( interface , ( uint8_t * ) & header , sizeof ( Ksz8851TxHeader ) ) ;ksz8851WriteFifo ( interface , context -> txBuffer , length ) ;ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ;ksz8851SetBit ( interface , KSZ8851_REG_TXQCR , TXQCR_METFE ) ;n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ;if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) {","n = ksz8851ReadReg ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA ;if ( n < ( length + 8 ) ) {header . controlWord = htole16 ( KSZ8851_TX_CTRL_TXIC | ( context -> frameId ++ & KSZ8851_TX_CTRL_TXFID ) ) ;header . byteCount = htole16 ( length ) ;ksz8851SetBit ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA ) ;ksz8851WriteFifo ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA ) ;ksz8851SetBit ( interface , KSZ8851_REG_TXQCR , TXQCR_METFE ) ;n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ;if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) {",1076
1525,return key ;},"rb_ivar_set ( self , id_key_set , Qtrue ) ;return key ;}",1077
1526,goto present_leaves_cluster_but_not_new_leaf ;},"pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\\}",1078
1527,"return true ;present_leaves_cluster_but_not_new_leaf :  pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\\new_n0 -> back_pointer = node -> back_pointer ;new_n0 -> parent_slot = node -> parent_slot ;new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ;new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ;new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ;new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ;edit -> adjust_count_on = new_n0 ;for ( i = 0 ;i < ASSOC_ARRAY_FAN_OUT ;i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ;new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ;edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ;edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ;edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ;edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ;pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\\","
",1078
1528,settings . udpport = 11211 ;settings . inter = NULL ;,settings . udpport = 0 ;settings . inter = NULL ;,1079
1529,# endif mono_console_handle_async_ops ( ) ;# endif  if ( domains_to_finalize ) {,# endif reference_queue_proccess_all ( ) ;mono_console_handle_async_ops ( ) ;# endif if ( domains_to_finalize ) {,1080
1530,"WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ;WORD32 n00 , n10 , n20 , n30 , n01 , n11 , n21 , n31 ;WORD32 n02 , n12 , n22 , n32 , n03 , n13 , n23 , n33 ;","WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ;",1081
1531,x_1 = * x0 ++ ;x_2 = * x0 ++ ;x_3 = * x0 ++ ;x_4 = * x0 ++ ;x_5 = * x0 ++ ;x_6 = * x0 ++ ;x_7 = * x0 ++ ;n00 = x_0 + x_2 ;n01 = x_1 + x_3 ;n20 = x_0 - x_2 ;n21 = x_1 - x_3 ;n10 = x_4 + x_6 ;n11 = x_5 + x_7 ;n30 = x_4 - x_6 ;n31 = x_5 - x_7 ;y0 [ h2 ] = n00 ;y0 [ h2 + 1 ] = n01 ;y1 [ h2 ] = n10 ;y1 [ h2 + 1 ] = n11 ;y2 [ h2 ] = n20 ;y2 [ h2 + 1 ] = n21 ;y3 [ h2 ] = n30 ;y3 [ h2 + 1 ] = n31 ;x_8 = * x2 ++ ;,"y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ;y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ;y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ;y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ;y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ;y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ;y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ;y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ;x_8 = * x2 ++ ;",1081
1532,n02 = x_8 + x_a ;n03 = x_9 + x_b ;n22 = x_8 - x_a ;n23 = x_9 - x_b ;n12 = x_c + x_e ;n13 = x_d + x_f ;n32 = x_c - x_e ;n33 = x_d - x_f ;y0 [ h2 + 2 ] = n02 ;y0 [ h2 + 3 ] = n03 ;y1 [ h2 + 2 ] = n12 ;y1 [ h2 + 3 ] = n13 ;y2 [ h2 + 2 ] = n22 ;y2 [ h2 + 3 ] = n23 ;y3 [ h2 + 2 ] = n32 ;y3 [ h2 + 3 ] = n33 ;,"y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ;y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) ;y1 [ h2 + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) ;y1 [ h2 + 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ;y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ;y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) ;y3 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) ;y3 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) ;",1081
1533,"
",if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) {ret = - EINVAL ;goto out_err1 ;},1082
1534,"clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ;if ( ! clips ) {","clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ;if ( ! clips ) {",1082
1535,if ( unlikely ( pmd_trans_huge ( * pmd ) ) )  continue ;if ( pmd_none_or_clear_bad ( pmd ) ) continue ;,if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) continue ;,1083
1536,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;",1084
1537,j < size ;,j < minsz ;,1085
1538,"for ( j = 0 ;r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ;}if ( op . val != UT64_MAX )  printline ( ""val"" , ""0x%08"" PFMT64x ""\\\if ( op . ptr != UT64_MAX )   printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\\if ( op . refptr != - 1 )   printline ( ""refptr"" , ""%d\\\printline ( ""size"" , ""%d\\\","int minsz = R_MIN ( len , size ) ;minsz = R_MAX ( minsz , 0 ) ;for ( j = 0 ;ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : buf [ j + idx ] ;r_cons_printf ( ""%02x"" , ch ) ;}if ( op . val != UT64_MAX ) {printline ( ""val"" , ""0x%08"" PFMT64x ""\\\}if ( op . ptr != UT64_MAX ) {printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\\}if ( op . refptr != - 1 ) {printline ( ""refptr"" , ""%d\\\}printline ( ""size"" , ""%d\\\",1085
1539,"int width , height , target_width , target_height ;if ( argc < 5 ) {usage ( argv [ 0 ] ) ;return 1 ;usage ( argv [ 0 ] ) ;return 1 ;usage ( argv [ 0 ] ) ;return 1 ;usage ( argv [ 0 ] ) ;return 1 ;usage ( argv [ 0 ] ) ;return 1 ;","int width , height , target_width , target_height ;exec_name = argv [ 0 ] ;if ( argc < 5 ) {usage ( ) ;return 1 ;usage ( ) ;return 1 ;usage ( ) ;return 1 ;usage ( ) ;return 1 ;usage ( ) ;return 1 ;",1086
1540,"while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) {u16 wTmp ;snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ) ) ;wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ;if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) )  writew ( 0 , chip -> DSPQ + JQS_wHead ) ;}inb ( chip -> io + HP_RXL ) ;","u16 head , tail , size ;head = readw ( chip -> DSPQ + JQS_wHead ) + 1 ;if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) writew ( 0 , chip -> DSPQ + JQS_wHead ) ;}inb ( chip -> io + HP_RXL ) ;",1087
1541,OPCODE_DESC * opcode_desc ;ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ;,OPCODE_DESC * opcode_desc ;if ( len < 2 ) {return NULL ;}ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ;,1088
1542,ACPI_FUNCTION_TRACE ( ns_terminate ) ;# ifdef ACPI_EXEC_APP {union acpi_operand_object * next ;next = acpi_gbl_module_code_list ;}# endif acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ;,union acpi_operand_object * next ;ACPI_FUNCTION_TRACE ( ns_terminate ) ;next = acpi_gbl_module_code_list ;acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ;,1089
1543,data -> l_head = NULL ;data -> portListing = NULL ;data -> portListingLength = 0 ;,"memset ( data , 0 , sizeof ( struct NameValueParserData ) ) ;",1090
1544,"strcpy ( the_url , url_arg ) ;ext = strrchr ( the_url , \'.\' ) ;","if ( strlen ( url_arg ) >= sizeof ( the_url ) ) {fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\\strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ;the_url [ sizeof ( the_url ) - 1 ] = 0 ;}else {strcpy ( the_url , url_arg ) ;}ext = strrchr ( the_url , \'.\' ) ;",1091
1545,"if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ;gf_dm_sess_del ( sess ) ;","if ( ! e ) {strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ;the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;}gf_dm_sess_del ( sess ) ;",1091
1546,"strcpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ;gf_term_connect ( term , str ) ;","strncpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ;gf_term_connect ( term , str ) ;",1091
1547,"int i , result ;_Py_IDENTIFIER ( _attributes ) ;","int i , result ;",1092
1548,". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = type -> match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , }",1093
1549,"struct vpx_codec_alg_priv * priv ;vpx_codec_enc_cfg_t * cfg ;unsigned int i ;struct VP8_COMP * optr ;priv = calloc ( 1 , sizeof ( struct vpx_codec_alg_priv ) ) ;if ( ! priv ) {ctx -> priv = & priv -> base ;ctx -> priv -> sz = sizeof ( * ctx -> priv ) ;ctx -> priv -> alg_priv -> cfg = * ctx -> config . enc ;ctx -> config . enc = & ctx -> priv -> alg_priv -> cfg ;}cfg = & ctx -> priv -> alg_priv -> cfg ;for ( i = 0 ;extracfg_map [ i ] . usage && extracfg_map [ i ] . usage != cfg -> g_usage ;i ++ ) ;priv -> vp8_cfg = extracfg_map [ i ] . cfg ;priv -> vp8_cfg . pkt_list = & priv -> pkt_list . head ;","vpx_dsp_rtcd ( ) ;vpx_scale_rtcd ( ) ;struct vpx_codec_alg_priv * priv = ( struct vpx_codec_alg_priv * ) vpx_calloc ( 1 , sizeof ( * priv ) ) ;if ( ! priv ) {ctx -> priv = & priv -> base ;ctx -> priv -> sz = sizeof ( * ctx -> priv ) ;priv -> cfg = * ctx -> config . enc ;ctx -> config . enc = & priv -> cfg ;}priv -> vp8_cfg = extracfg_map [ i ] . cfg ;priv -> vp8_cfg . pkt_list = & priv -> pkt_list . head ;",1094
1550,"set_vp8e_config ( & ctx -> priv -> alg_priv -> oxcf ,   ctx -> priv -> alg_priv -> cfg ,  ctx -> priv -> alg_priv -> vp8_cfg , mr_cfg ) ;optr = vp8_create_compressor ( & ctx -> priv -> alg_priv -> oxcf ) ;if ( ! optr )  res = VPX_CODEC_MEM_ERROR ;else  ctx -> priv -> alg_priv -> cpi = optr ;","set_vp8e_config ( & priv -> oxcf , ctx -> priv -> alg_priv -> cfg , ctx -> priv -> alg_priv -> vp8_cfg , mr_cfg ) ;priv -> cpi = vp8_create_compressor ( & priv -> oxcf ) ;if ( ! optr ) res = VPX_CODEC_MEM_ERROR ;",1094
1551,"if ( error == - EIO ) goto out ;xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ;memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ;goto out ;}ASSERT ( blkno == 0 ) ;error = xfs_attr3_leaf_create ( args , blkno , & bp ) ;if ( error ) {error = xfs_da_shrink_inode ( args , 0 , bp ) ;bp = NULL ;","if ( bp && ( xfs_da_shrink_inode ( args , 0 , bp ) ;bp = NULL ;",1095
1552,"if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 )  return ret ;","if ( x >= 16 || c >= 256 ) {return AVERROR_INVALIDDATA ;}if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) return ret ;",1096
1553,"list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head ,  open_list ) {spin_lock_irq ( & slave_active_lock ) ;_snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ;spin_unlock_irq ( & slave_active_lock ) ;}mutex_unlock ( & register_mutex ) ;","spin_lock_irq ( & slave_active_lock ) ;spin_lock ( & timer -> lock ) ;list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) {list_del_init ( & slave -> ack_list ) ;list_del_init ( & slave -> active_list ) ;}spin_unlock ( & timer -> lock ) ;spin_unlock_irq ( & slave_active_lock ) ;mutex_unlock ( & register_mutex ) ;",1097
1554,"err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX ,   attrs [ TIPC_NLA_SOCK ] ,  tipc_nl_sock_policy ) ;tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ;}lock_sock ( & tsk -> sk ) ;err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ;","if ( ! attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ;err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ;if ( err ) return err ;if ( ! sock [ TIPC_NLA_SOCK_REF ] ) return - EINVAL ;tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ;}lock_sock ( & tsk -> sk ) ;err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ;",1098
1555,"vpx_memset ( ( void * ) ctx -> fragments . ptrs , 0 , sizeof ( ctx -> fragments . ptrs ) ) ;vpx_memset ( ctx -> fragments . sizes , 0 , sizeof ( ctx -> fragments . sizes ) ) ;}if ( ctx -> fragments . enabled && ! ( data == NULL && data_sz == 0 ) ) {","memset ( ( void * ) ctx -> fragments . ptrs , 0 , sizeof ( ctx -> fragments . ptrs ) ) ;memset ( ctx -> fragments . sizes , 0 , sizeof ( ctx -> fragments . sizes ) ) ;}if ( ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) {return 0 ;}if ( ! ctx -> fragments . enabled && ! ( data == NULL && data_sz == 0 ) ) {",1099
1556,if ( ! ctx -> fragments . enabled )  {,if ( ! ctx -> fragments . enabled ) {,1099
1557,"vma_stop ( priv , vma ) ;if ( priv -> task ) put_task_struct ( priv -> task ) ;","if ( ! IS_ERR ( vma ) ) vma_stop ( priv , vma ) ;if ( priv -> task ) put_task_struct ( priv -> task ) ;",1100
1558,"ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ;if ( ret < total_len ) {dev_err ( ddev , ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor<S2SV_blank>set\\\if ( ret >= 0 ) ret = - ENOMSG ;goto err ;}total_len -= length ;for ( i = 0 ;i < num ;i ++ ) {buffer += length ;cap = ( struct usb_dev_cap_header * ) buffer ;length = cap -> bLength ;if ( total_len < length ) break ;",if ( total_len < sizeof ( * cap ) || total_len < cap -> bLength ;if ( total_len < length ) break ;,1101
1559,struct task_struct * task = current ;file_sb_list_del ( file ) ;,struct task_struct * task = current ;,1102
1560,switch ( fe -> icbTag . fileType ) {case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ;,if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) {if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ;if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ;}switch ( fe -> icbTag . fileType ) {case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ;,1103
1561,"enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MIWRL , LSB ( data ) ) ;enc28j60WriteReg ( interface , ENC28J60_REG_MIWRH , MSB ( data ) ) ;while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 )  {","enc28j60WriteReg ( interface , ENC28J60_MIREGADR , address & REG_ADDR_MASK ) ;enc28j60WriteReg ( interface , ENC28J60_MIWRL , LSB ( data ) ) ;enc28j60WriteReg ( interface , ENC28J60_MIWRH , MSB ( data ) ) ;while ( ( enc28j60ReadReg ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY ) != 0 ) {",1104
1562,static int bad_format_imginfo (  char * fmt ) {char * ptr ;int n = 0 ;ptr = fmt ;while ( * ptr != \'\\\\0\' ) if ( * ptr ++ == \'%\' ) {if ( * ptr == \'\\\\0\' ) return 1 ;if ( * ptr == \'%\' ) ptr ++ ;else if ( * ptr == \'s\' || * ptr == \'S\' ) {n = 1 ;ptr ++ ;}else {if ( * ptr == \'<S2SV_blank>\' ) ptr ++ ;while ( * ptr >= \'0\' && * ptr <= \'9\' ) ptr ++ ;if ( * ptr ++ != \'l\' ) return 1 ;if ( * ptr == \'u\' ) ptr ++ ;else return 1 ;n ++ ;}}return ( n != 3 ) ;,"int bad_format_imginfo ( char * fmt ) {return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt ) ;",1105
1563,"kfree ( inet -> opt ) ;dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ;","kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) ) ;dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ;",1106
1564,"if ( likely ( walk . nbytes == nbytes ) )  {salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ;return blkcipher_walk_done ( desc , & walk , 0 ) ;}","
",1107
1565,if ( ! saw_digit )   goto invalid ;break ;,if ( ! saw_digit ) {bp ++ ;goto invalid ;}break ;,1108
1566,if ( * bp != '\\\\r' )   goto invalid ;bp ++ ;if ( * bp != '\\\bp ++ ;,if ( * bp != '\\\\r' ) {bp ++ ;goto invalid ;}bp ++ ;if ( * bp != '\\\bp ++ ;goto invalid ;}bp ++ ;,1108
1567,trunc :  return ( - 2 ) ;invalid :  return ( - 5 ) ;},trunc : * endp = bp ;return ( - 2 ) ;invalid : * endp = bp ;return ( - 5 ) ;},1108
1568,"args -> index = probe ;else {name_rmt = xfs_attr3_leaf_name_remote ( leaf , probe ) ;if ( name_rmt -> namelen != args -> namelen ) continue ;if ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) != 0 ) continue ;if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ;args -> index = probe ;args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount ,  args -> valuelen ) ;return XFS_ERROR ( EEXIST ) ;}","args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , args -> valuelen ) ;",1109
1569,# endif  },"UtRegisterTest ( ""DefragTestBadProto"" , DefragTestBadProto ) ;# endif }",1110
1570,if ( object_data ) {new_object . data = malloc ( object_length + add_v1_record ) ;,"if ( coolkey_find_object_by_id ( & priv -> objects_list , object_id ) != NULL ) {return SC_ERROR_INTERNAL ;}if ( object_data ) {new_object . data = malloc ( object_length + add_v1_record ) ;",1111
1571,char key [ 32 ] = {Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;,size_t vstart_off = i ;char key [ 32 ] = {Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;,1112
1572,if ( vdaux < 1 || vstart + vdaux < vstart ) {sdb_free ( sdb_verdef ) ;vstart += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {,if ( vdaux < 1 || shdr -> sh_size - vstart_off < vdaux ) {sdb_free ( sdb_verdef ) ;vstart += vdaux ;vstart_off += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {,1112
1573,if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,vstart_off += aux . vda_next ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,1112
1574,"separator = strchr ( token , \'=\' ) ;if ( separator != NULL ) {","separator = osStrchr ( token , \'=\' ) ;if ( separator != NULL ) {",1113
1575,if ( j >= length ) return - 1 ;GET8 ( label_len ) ;,GET8 ( label_len ) ;,1114
1576,"
",if ( j + label_len > length ) return - 1 ;,1114
1577,"memcpy ( cp , packet + j , label_len ) ;cp += label_len ;","memcpy ( cp , packet + j , label_len ) ;cp += label_len ;",1114
1578,"static void  fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( bps * stride ) ) == 0 ) ;if ( ! tmp )  return ;while ( count > stride ) {","static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( cc % ( bps * stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ;return 0 ;}if ( ! tmp ) return 0 ;while ( count > stride ) {",1115
1579,},return 1 ;},1115
1580,"if ( vma -> vm_ops ) {if ( likely ( vma -> vm_ops -> fault ) ) return do_fault ( mm , vma , address , pte ,  pmd , flags , entry ) ;}return do_anonymous_page ( mm , vma , address ,  pte , pmd , flags ) ;}","if ( vma -> vm_ops ) return do_fault ( mm , vma , address , pte , pmd , flags , entry ) ;}return do_anonymous_page ( mm , vma , address , pte , pmd , flags ) ;}",1116
1581,"char * r = pool_alloc ( strlen ( s ) + 1 ) ;strcpy ( r , s ) ;return r ;","size_t len = strlen ( s ) + 1 ;char * r = pool_alloc ( len ) ;memcpy ( r , s , len ) ;return r ;",1117
1582,"if ( key_is_instantiated ( key ) )  seq_printf ( m , "":<S2SV_blank>%u"" , key -> datalen ) ;","if ( key_is_positive ( key ) ) seq_printf ( m , "":<S2SV_blank>%u"" , key -> datalen ) ;",1118
1583,"if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) )  goto out ;","if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) goto out ;",1119
1584,"sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ;}cu -> dies [ cu -> length ] . length ++ ;","if ( name > 1024 ) {sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ;}else {eprintf ( ""Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\\}}cu -> dies [ cu -> length ] . length ++ ;",1120
1585,p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ;if ( ! p_enc -> fmt_out . p_extra ) return NULL ;,if ( len > UINT32_MAX - sizeof ( eos ) ) return NULL ;p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ;if ( ! p_enc -> fmt_out . p_extra ) return NULL ;,1121
1586,"mp_info ( log , ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>indirect<S2SV_blank>filelist\\\}if ( strchr ( filename , \',\' ) ) {mp_info ( log , ""filelist:<S2SV_blank>%s\\\bstr bfilename = bstr0 ( filename ) ;while ( bfilename . len ) {bstr bfname ;bstr_split_tok ( bfilename , "","" , & bfname , & bfilename ) ;char * fname2 = bstrdup0 ( mf , bfname ) ;if ( ! mp_path_exists ( fname2 ) ) mp_verbose ( log , ""file<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>\\\'%s\\\'\\\else {mf_add ( mf , fname2 ) ;}talloc_free ( fname2 ) ;}mp_info ( log , ""number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d\\\goto exit_mf ;}char * fname = talloc_size ( mf , strlen ( filename ) + 32 ) ;# if HAVE_GLOB if ( ! strchr ( filename , \'%\' ) ) {","size_t fname_avail = strlen ( filename ) + 32 ;char * fname = talloc_size ( mf , fname_avail ) ;# if HAVE_GLOB if ( ! strchr ( filename , \'%\' ) ) {",1122
1587,"# endif  mp_info ( log , ""search<S2SV_blank>expr:<S2SV_blank>%s\\\while ( error_count < 5 ) {sprintf ( fname , filename , count ++ ) ;if ( ! mp_path_exists ( fname ) ) {","# endif const char * f = filename ;int MAXDIGS = 3 , nspec = 0 , bad_spec = 0 , c ;while ( nspec < 2 && ( c = * f ++ ) ) {if ( c != \'%\' ) continue ;if ( * f != \'%\' ) {nspec ++ ;if ( * f == \'.\' ) f ++ ;for ( int ndig = 0 ;mp_isdigit ( * f ) && ndig < MAXDIGS ;ndig ++ , f ++ ) ;if ( * f != \'d\' ) {bad_spec ++ ;break ;}}f ++ ;}if ( bad_spec || nspec != 1 ) {mp_err ( log , ""unsupported<S2SV_blank>expr<S2SV_blank>format:<S2SV_blank>\\\'%s\\\'\\\goto exit_mf ;}mp_info ( log , ""search<S2SV_blank>expr:<S2SV_blank>%s\\\while ( error_count < 5 ) {if ( snprintf ( fname , fname_avail , filename , count ++ ) >= fname_avail ) {mp_err ( log , ""format<S2SV_blank>result<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\\\'%s\\\'\\\goto exit_mf ;}if ( ! mp_path_exists ( fname ) ) {",1122
1588,cp += advance ;len -= advance ;,if ( len < ( u_int ) advance ) goto trunc ;cp += advance ;len -= advance ;,1123
1589,"nh = * cp ;return ;case IPPROTO_ROUTING :  advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ;nh = * cp ;break ;","if ( advance < 0 ) return ;nh = * cp ;return ;case IPPROTO_ROUTING : ND_TCHECK ( * cp ) ;advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ;if ( advance < 0 ) return ;nh = * cp ;break ;",1123
1590,"case IPPROTO_AH :  advance = ah_print ( ndo , cp ) ;nh = * cp ;nh = enh & 0xff ;len -= padlen ;","case IPPROTO_AH : advance = ah_print ( ndo , cp ) ;if ( advance < 0 ) return ;nh = * cp ;if ( advance < 0 ) return ;nh = enh & 0xff ;len -= padlen ;",1123
1591,"uint32 num_properties = GETINT32 ( buf + idx ) ;MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ;","uint32 num_properties = GETINT32 ( buf + idx ) ;assert ( ( num_properties + 1 ) != 0 ) ;MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ;",1124
1592,"
",assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ;,1124
1593,"
",assert ( v -> len + idx <= len ) ;,1124
1594,for ( j = 0 ;j ++ )  a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ;,for ( j = 0 ;j ++ ) a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ;,1124
1595,"if ( a -> type == szMAPI_UNICODE_STRING )  {v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;}","if ( a -> type == szMAPI_UNICODE_STRING ) {assert ( v -> len != 0 ) ;v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;}",1124
1596,switch ( fe -> icbTag . fileType ) {case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ;,if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) {if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ;if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ;}switch ( fe -> icbTag . fileType ) {case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ;,1125
1597,"vma = find_vma_prev ( mm , start , & prev ) ;if ( ! vma ) goto out_unlock ;","if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;vma = find_vma_prev ( mm , start , & prev ) ;if ( ! vma ) goto out_unlock ;",1126
1598,"act = vp8_variance16x16 ( x -> src . y_buffer ,  x -> src . y_stride , VP8_VAR_OFFS , 0 , & sse ) ;","( void ) cpi ;act = vpx_variance16x16 ( x -> src . y_buffer , x -> src . y_stride , VP8_VAR_OFFS , 0 , & sse ) ;",1127
1599,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",1128
1600,"static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vp9_ref_frame_t * data = va_arg ( args , vp9_ref_frame_t * ) ;if ( data ) {YV12_BUFFER_CONFIG * fb ;vp9_get_reference_dec ( ctx -> pbi , data -> idx , & fb ) ;yuvconfig2image ( & data -> img , fb , NULL ) ;","static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vp9_ref_frame_t * data = va_arg ( args , vp9_ref_frame_t * ) ;if ( ctx -> frame_parallel_decode ) {set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ;return VPX_CODEC_INCAPABLE ;}if ( data ) {YV12_BUFFER_CONFIG * fb ;VPxWorker * const worker = ctx -> frame_workers ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;fb = get_ref_frame ( & frame_worker_data -> pbi -> common , data -> idx ) ;if ( fb == NULL ) return VPX_CODEC_ERROR ;yuvconfig2image ( & data -> img , fb , NULL ) ;",1129
1601,"ops -> get_msr ( ctxt , MSR_EFER , & efer ) ;setup_syscalls_segments ( ctxt , & cs , & ss ) ;ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ;","if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ;ops -> get_msr ( ctxt , MSR_EFER , & efer ) ;setup_syscalls_segments ( ctxt , & cs , & ss ) ;if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt ) ;ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ;",1130
1602,data_ref = NULL ;data = av_malloc ( end - start + AV_INPUT_BUFFER_PADDING_SIZE ) ;,if ( length > end - start ) return AVERROR_INVALIDDATA ;data_ref = NULL ;data = av_malloc ( end - start + AV_INPUT_BUFFER_PADDING_SIZE ) ;,1131
1603,"if ( NCH ( n ) == 1 ) {expr_ty e = ast_for_testlist ( c , CHILD ( n , 0 ) ) ;","int num = NCH ( n ) ;if ( num == 1 ) {expr_ty e = ast_for_testlist ( c , CHILD ( n , 0 ) ) ;",1132
1604,"int i ;asdl_seq * targets ;REQ ( CHILD ( n , 1 ) , EQUAL ) ;targets = _Py_asdl_seq_new ( NCH ( n ) / 2 , c -> c_arena ) ;if ( ! targets ) return NULL ;for ( i = 0 ;i < NCH ( n ) - 2 ;expr_ty e ;node * ch = CHILD ( n , i ) ;if ( TYPE ( ch ) == yield_expr ) {ast_error ( c , ch , ""assignment<S2SV_blank>to<S2SV_blank>yield<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>possible"" ) ;return NULL ;}e = ast_for_testlist ( c , ch ) ;if ( ! e ) return NULL ;if ( ! set_context ( c , e , Store , CHILD ( n , i ) ) ) return NULL ;asdl_seq_SET ( targets , i / 2 , e ) ;}value = CHILD ( n , NCH ( n ) - 1 ) ;if ( TYPE ( value ) == testlist_star_expr ) expression = ast_for_testlist ( c , value ) ;return Assign ( targets , expression , LINENO ( n ) , n -> n_col_offset ,  n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ;","int i , nch_minus_type , has_type_comment ;asdl_seq * targets ;string type_comment ;REQ ( CHILD ( n , 1 ) , EQUAL ) ;has_type_comment = TYPE ( CHILD ( n , num - 1 ) ) == TYPE_COMMENT ;nch_minus_type = num - has_type_comment ;targets = _Py_asdl_seq_new ( nch_minus_type / 2 , c -> c_arena ) ;if ( ! targets ) return NULL ;for ( i = 0 ;i < nch_minus_type - 2 ;expr_ty e ;node * ch = CHILD ( n , nch_minus_type - 1 ) ;if ( TYPE ( value ) == testlist_star_expr ) expression = ast_for_testlist ( c , value ) ;if ( has_type_comment ) {type_comment = NEW_TYPE_COMMENT ( CHILD ( n , nch_minus_type ) ) ;if ( ! type_comment ) return NULL ;}else type_comment = NULL ;return Assign ( targets , expression , type_comment , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ;",1132
1605,"int vp8_denoiser_filter_c ( YV12_BUFFER_CONFIG * mc_running_avg ,  YV12_BUFFER_CONFIG * running_avg , MACROBLOCK * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) {unsigned char * sig = signal -> thismb ;unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ;int mc_avg_y_stride = mc_running_avg -> y_stride ;unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ;int avg_y_stride = running_avg -> y_stride ;int r , c , i ;int sum_diff = 0 ;int adj_val [ 3 ] = {if ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) {for ( i = 0 ;i < 3 ;i ++ )  adj_val [ i ] += 1 ;","int vp8_denoiser_filter_c ( unsigned char * sig = signal -> thismb ;unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ;int mc_avg_y_stride = mc_running_avg -> y_stride ;unsigned char * running_avg_y , int avg_y_stride , unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) {unsigned char * running_avg_y_start = running_avg_y ;unsigned char * sig_start = sig ;int sum_diff_thresh ;int r , c ;int sum_diff = 0 ;int adj_val [ 3 ] = {int shift_inc1 = 0 ;int shift_inc2 = 1 ;int col_sum [ 16 ] = {0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 };if ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) {if ( increase_denoising ) {shift_inc1 = 1 ;shift_inc2 = 2 ;}adj_val [ 0 ] += shift_inc2 ;adj_val [ 1 ] += shift_inc2 ;adj_val [ 2 ] += shift_inc2 ;",1133
1606,"absdiff = abs ( diff ) ;if ( absdiff <= 3 )  {running_avg_y [ c ] = mc_running_avg_y [ c ] ;sum_diff += diff ;}if ( absdiff >= 4 && absdiff <= 7 )  adjustment = adj_val [ 0 ] ;sum_diff += adjustment ;}if ( ( sig [ c ] - adjustment ) < 0 ) running_avg_y [ c ] = 0 ;else  running_avg_y [ c ] = sig [ c ] - adjustment ;sum_diff -= adjustment ;if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD )  return COPY_BLOCK ;vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride ,   signal -> thismb , sig_stride ) ;return FILTER_BLOCK ;","col_sum [ c ] += diff ;}if ( absdiff >= 4 + shift_inc1 && absdiff <= 7 ) adjustment = adj_val [ 0 ] ;col_sum [ c ] += adjustment ;}if ( ( sig [ c ] - sig [ c ] ;int adjustment = abs ( diff ) ;if ( adjustment > delta ) adjustment = delta ;if ( diff > 0 ) {if ( running_avg_y [ c ] - adjustment < 0 ) running_avg_y [ c ] = 0 ;else running_avg_y [ c ] = running_avg_y [ c ] - adjustment ;col_sum [ c ] -= adjustment ;else if ( diff < 0 ) {if ( running_avg_y [ c ] + adjustment > 255 ) running_avg_y [ c ] = 255 ;else running_avg_y [ c ] = running_avg_y [ c ] + adjustment ;col_sum [ c ] += adjustment ;sum_diff = 0 ;for ( c = 0 ;c < 16 ;++ c ) {if ( col_sum [ c ] >= 128 ) {col_sum [ c ] = 127 ;}sum_diff += col_sum [ c ] ;}if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) return COPY_BLOCK ;vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride , signal -> thismb , sig_stride ) ;return FILTER_BLOCK ;",1133
1607,"Ns_Log ( Warning , ""request<S2SV_blank>line<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%d<S2SV_blank>bytes)"" , ( int ) ( e - s ) ) ;}else {sockPtr -> flags = NS_CONN_LINETOOLONG ;Ns_Log ( Warning , ""request<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%d<S2SV_blank>bytes)"" , ( int ) ( e - s ) ) ;}}cnt = ( size_t ) ( e - s ) + 1u ;reqPtr -> roff += cnt ;reqPtr -> avail -= cnt ;if ( likely ( e > s ) && likely ( * ( e - 1 ) == \'\\\\r\' ) ) {-- e ;}if ( unlikely ( e == s ) && ( reqPtr -> coff == 0u ) ) {reqPtr -> coff = EndOfHeader ( sockPtr ) ;if ( ( sockPtr -> flags & NS_CONN_CONTINUE ) != 0u ) {Ns_Log ( Ns_LogRequestDebug , ""honoring<S2SV_blank>100-continue"" ) ;if ( ( sockPtr -> flags & NS_CONN_ENTITYTOOLARGE ) != 0u ) {Ns_Log ( Ns_LogRequestDebug , ""100-continue:<S2SV_blank>entity<S2SV_blank>too<S2SV_blank>large"" ) ;return SOCK_ENTITYTOOLARGE ;}else {struct iovec iov [ 1 ] ;ssize_t sent ;Ns_Log ( Ns_LogRequestDebug , ""100-continue:<S2SV_blank>reply<S2SV_blank>CONTINUE"" ) ;iov [ 0 ] . iov_base = ( char * ) ""HTTP/1.1<S2SV_blank>100<S2SV_blank>Continue\\\\r\\\iov [ 0 ] . iov_len = strlen ( iov [ 0 ] . iov_base ) ;sent = Ns_SockSendBufs ( ( Ns_Sock * ) sockPtr , iov , 1 , NULL , 0u ) ;if ( sent != ( ssize_t ) iov [ 0 ] . iov_len ) {Ns_Log ( Warning , ""could<S2SV_blank>not<S2SV_blank>deliver<S2SV_blank>response:<S2SV_blank>100<S2SV_blank>Continue"" ) ;}}}}else {save = * e ;* e = \'\\\\0\' ;if ( unlikely ( reqPtr -> request . line == NULL ) ) {Ns_Log ( DriverDebug , ""SockParse<S2SV_blank>(%d):<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>line<S2SV_blank><%s>"" , sockPtr -> sock , s ) ;if ( Ns_ParseRequest ( & reqPtr -> request , s ) == NS_ERROR ) {return SOCK_BADREQUEST ;}if ( unlikely ( reqPtr -> request . version < 1.0 ) ) {reqPtr -> coff = reqPtr -> roff ;Ns_Log ( Notice , ""pre-HTTP/1.0<S2SV_blank>request<S2SV_blank><%s>"" , reqPtr -> request . line ) ;}}else if ( Ns_ParseHeader ( reqPtr -> headers , s , Preserve ) != NS_OK ) {return SOCK_BADHEADER ;}else {if ( unlikely ( Ns_SetSize ( reqPtr -> headers ) > ( size_t ) drvPtr -> maxheaders ) ) {Ns_Log ( DriverDebug , ""SockParse<S2SV_blank>(%d):<S2SV_blank>maxheaders<S2SV_blank>reached<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , sockPtr -> sock , drvPtr -> maxheaders ) ;return SOCK_TOOMANYHEADERS ;}}* e = save ;}}if ( unlikely ( reqPtr -> request . line == NULL ) ) {return SOCK_BADREQUEST ;}assert ( reqPtr -> coff > 0u ) ;assert ( reqPtr -> request . line != NULL ) ;Ns_Log ( Dev , ""===<S2SV_blank>length<S2SV_blank><<S2SV_blank>avail<S2SV_blank>(length<S2SV_blank>%"" PRIuz  "",<S2SV_blank>avail<S2SV_blank>%"" PRIuz "")<S2SV_blank>tfd<S2SV_blank>%d<S2SV_blank>tfile<S2SV_blank>%p<S2SV_blank>chunkStartOff<S2SV_blank>%"" PRIuz , reqPtr -> length , reqPtr -> avail , sockPtr -> tfd , ( void * ) sockPtr -> tfile , reqPtr -> chunkStartOff ) ;bool complete ;size_t currentContentLength ;complete = ChunkedDecode ( reqPtr , NS_TRUE ) ;currentContentLength = reqPtr -> chunkWriteOff - reqPtr -> coff ;if ( ( ! complete )  || ( reqPtr -> expectedLength != 0u && currentContentLength < reqPtr -> expectedLength ) ) {}reqPtr -> length = ( size_t ) currentContentLength ;","Ns_Log ( Debug , ""===<S2SV_blank>length<S2SV_blank><<S2SV_blank>avail<S2SV_blank>(length<S2SV_blank>%"" PRIuz "",<S2SV_blank>avail<S2SV_blank>%"" PRIuz "")<S2SV_blank>tfd<S2SV_blank>%d<S2SV_blank>tfile<S2SV_blank>%p<S2SV_blank>chunkStartOff<S2SV_blank>%"" PRIuz , reqPtr -> length , reqPtr -> avail , sockPtr -> tfd , ( void * ) sockPtr -> tfile , reqPtr -> chunkStartOff ) ;bool complete ;size_t currentContentLength ;complete = ChunkedDecode ( reqPtr , NS_TRUE ) ;currentContentLength = reqPtr -> chunkWriteOff - reqPtr -> coff ;if ( ( ! complete ) || ( reqPtr -> expectedLength != 0u && currentContentLength < reqPtr -> expectedLength ) ) {}else if ( chunkState != SOCK_READY ) {return chunkState ;}reqPtr -> length = ( size_t ) currentContentLength ;",1134
1608,int ret = 0 ;# if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ;,"int ret = 0 ;if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT ;# if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ;",1135
1609,message -> srcIpAddr = queueItem -> srcIpAddr ;message -> srcPort = queueItem -> srcPort ;,message -> interface = queueItem -> interface ;message -> srcIpAddr = queueItem -> srcIpAddr ;message -> srcPort = queueItem -> srcPort ;,1136
1610,"struct se_device * remote_dev ;if ( xop -> op_origin == XCOL_SOURCE_RECV_OP )  remote_dev = xop -> dst_dev ;else  remote_dev = xop -> src_dev ;pr_debug ( ""Calling<S2SV_blank>configfs_undepend_item<S2SV_blank>for"" ""<S2SV_blank>remote_dev:<S2SV_blank>%p<S2SV_blank>remote_dev->dev_group:<S2SV_blank>%p\\\target_undepend_item ( & remote_dev -> dev_group . cg_item ) ;","if ( xop -> op_origin == XCOL_SOURCE_RECV_OP ) remote_dev = xop -> dst_dev ) ;else pr_debug ( ""putting<S2SV_blank>src<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\\percpu_ref_put ( xop -> remote_lun_ref ) ;",1137
1611,"err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ;err = - errno ;","err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ;err = - errno ;goto close_sock ;}val = 1 ;ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ;if ( ret == - 1 ) {err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."" ) ;err = - errno ;",1138
1612,"if ( header ) {new_bh = ext2_xattr_cache_find ( inode , header ) ;if ( new_bh == old_bh ) {ea_bdebug ( new_bh , ""keeping<S2SV_blank>this<S2SV_blank>block"" ) ;}else {ea_bdebug ( new_bh , ""reusing<S2SV_blank>block"" ) ;error = dquot_alloc_block ( inode , 1 ) ;if ( error ) {unlock_buffer ( new_bh ) ;goto cleanup ;}le32_add_cpu ( & HDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( new_bh ) -> h_refcount ) ) ;}unlock_buffer ( new_bh ) ;}else if ( old_bh && header == HDR ( old_bh ) ) {new_bh = old_bh ;get_bh ( new_bh ) ;ext2_xattr_cache_insert ( new_bh ) ;}else {ext2_fsblk_t goal = ext2_group_first_block_no ( sb , EXT2_I ( inode ) -> i_block_group ) ;int block = ext2_new_block ( inode , goal , & error ) ;if ( error ) goto cleanup ;ea_idebug ( inode , ""creating<S2SV_blank>block<S2SV_blank>%d"" , block ) ;new_bh = sb_getblk ( sb , block ) ;if ( unlikely ( ! new_bh ) ) {ext2_free_blocks ( inode , block , 1 ) ;mark_inode_dirty ( inode ) ;error = - ENOMEM ;goto cleanup ;}lock_buffer ( new_bh ) ;memcpy ( new_bh -> b_data , header , new_bh -> b_size ) ;set_buffer_uptodate ( new_bh ) ;unlock_buffer ( new_bh ) ;ext2_xattr_cache_insert ( new_bh ) ;ext2_xattr_update_super_block ( sb ) ;}mark_buffer_dirty ( new_bh ) ;if ( IS_SYNC ( inode ) ) {sync_dirty_buffer ( new_bh ) ;error = - EIO ;if ( buffer_req ( new_bh ) && ! buffer_uptodate ( new_bh ) ) goto cleanup ;}}EXT2_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ;inode -> i_ctime = CURRENT_TIME_SEC ;if ( IS_SYNC ( inode ) ) {error = sync_inode_metadata ( inode , 1 ) ;if ( error && error != - ENOSPC ) {if ( new_bh && new_bh != old_bh ) {dquot_free_block_nodirty ( inode , 1 ) ;mark_inode_dirty ( inode ) ;}goto cleanup ;}}else mark_inode_dirty ( inode ) ;error = 0 ;if ( old_bh && old_bh != new_bh ) {struct mb_cache_entry * ce ;ce = mb_cache_entry_get ( ext2_xattr_cache , old_bh -> b_bdev , old_bh -> b_blocknr ) ;if ( ce )  mb_cache_entry_free ( ce ) ;","struct mb2_cache * ext2_mb_cache = EXT2_SB ( sb ) -> s_mb_cache ;if ( header ) {new_bh = ext2_xattr_cache_find ( inode , header ) ;if ( ce ) mb_cache_entry_free ( ce ) ;",1139
1613,if ( ce )  mb_cache_entry_release ( ce ) ;,if ( ce ) mb_cache_entry_release ( ce ) ;,1139
1614,"snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;","strncpy ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;",1140
1615,"static vpx_codec_err_t ctrl_set_active_map ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vpx_active_map_t * const map = va_arg ( args , vpx_active_map_t * ) ;if ( ! vp9_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) )  return VPX_CODEC_OK ;","static vpx_codec_err_t ctrl_set_active_map ( vpx_codec_alg_priv_t * ctx , va_list args ) {vpx_active_map_t * const map = va_arg ( args , vpx_active_map_t * ) ;if ( ! vp9_set_active_map ( ctx -> cpi , map -> active_map , ( int ) map -> rows , ( int ) map -> cols ) ) return VPX_CODEC_OK ;",1141
1616,"rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( rc < 0 )  return rc ;inode -> i_ctime = CURRENT_TIME ;if ( rc == 0 ) acl = NULL ;","rc = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ;if ( rc ) return rc ;inode -> i_ctime = CURRENT_TIME ;",1142
1617,return ( ( Image * ) NULL ) ;,if ( GetNextImageInList ( image ) != ( Image * ) NULL ) return ( ( Image * ) NULL ) ;,1143
1618,DestroyImage ( RemoveFirstImageFromList ( & image ) ) ;if ( image_type == GIMP_GRAY ) image -> type = GrayscaleType ;,DestroyImage ( RemoveFirstImageFromList ( & image ) ) ;if ( image_type == GIMP_GRAY ) image -> type = GrayscaleType ;,1143
1619,"ret = perf_output_begin ( & handle , event ,  task_event -> event_id . header . size , 0 , 0 ) ;if ( ret ) goto out ;","ret = perf_output_begin ( & handle , event , task_event -> event_id . header . size , 0 ) ;if ( ret ) goto out ;",1144
1620,"size_t maxlen = 3 * len ;struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ;","size_t maxlen = 3 * len + 8 ;struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ;",1145
1621,"SEPARATE_ZVAL ( ( var ) ) ;convert_to_long ( * var ) ;points [ i ] . x = Z_LVAL_PP ( var ) ;}SEPARATE_ZVAL ( var ) ;convert_to_long ( * var ) ;points [ i ] . y = Z_LVAL_PP ( var ) ;}if ( filled ) {gdImageFilledPolygon ( im , points , npoints , col ) ;","if ( Z_TYPE_PP ( var ) != IS_LONG ) {zval lval ;lval = * * var ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;points [ i ] . x = Z_LVAL ( lval ) ;}else {points [ i ] . x = Z_LVAL_PP ( var ) ;}}if ( Z_TYPE_PP ( var ) != IS_LONG ) {zval lval ;lval = * * var ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;points [ i ] . y = Z_LVAL ( lval ) ;}else {points [ i ] . y = Z_LVAL_PP ( var ) ;}}if ( filled ) {gdImageFilledPolygon ( im , points , npoints , col ) ;",1146
1622,sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;iv = timr -> it_interval ;,sig_none = timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;iv = timr -> it_interval ;,1147
1623,"imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ;if ( imbuf == NULL ) {","imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx , imsy ) ;if ( imbuf == NULL ) {",1148
1624,"( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ;while ( * p != '\\\\0' ) {","( void ) ResetMagickMemory ( imbuf , background_color_index , ( size_t ) imsx * imsy ) ;while ( * p != '\\\\0' ) {",1148
1625,"dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ;if ( dmbuf == ( unsigned char * ) NULL ) {( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ;for ( y = 0 ;( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ;}","dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy ) ;if ( dmbuf == ( unsigned char * ) NULL ) {( void ) ResetMagickMemory ( dmbuf , background_color_index , ( size_t ) dmsx * dmsy ) ;for ( y = 0 ;( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + ( size_t ) imsx * y , imsx ) ;}",1148
1626,"dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ;if ( dmbuf == ( unsigned char * ) NULL ) {( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ;for ( y = 0 ;( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + imsx * y , imsx ) ;}","dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy ) ;if ( dmbuf == ( unsigned char * ) NULL ) {( void ) ResetMagickMemory ( dmbuf , background_color_index , ( size_t ) dmsx * dmsy ) ;for ( y = 0 ;( void ) CopyMagickMemory ( dmbuf + dmsx * y , imbuf + ( size_t ) imsx * y , imsx ) ;}",1148
1627,"( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ;}","( void ) ResetMagickMemory ( imbuf + ( size_t ) imsx * y + posision_x , color_index , repeat_count ) ;}",1148
1628,"if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) {imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ;","if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy ) ) == NULL ) {imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ;",1148
1629,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",1149
1630,"static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ;if ( data ) {image2yuvconfig ( & frame -> img , & sd ) ;return vp9_copy_reference_dec ( ctx -> pbi ,  ( VP9_REFFRAME ) frame -> frame_type , & sd ) ;","static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ;if ( ctx -> frame_parallel_decode ) {set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ;return VPX_CODEC_INCAPABLE ;}if ( data ) {VPxWorker * const worker = ctx -> frame_workers ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;image2yuvconfig ( & frame -> img , & sd ) ;return vp9_copy_reference_dec ( frame_worker_data -> pbi , ( VP9_REFFRAME ) frame -> frame_type , & sd ) ;",1150
1631,"pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ;if ( ! pop3c -> mailbox )  return CURLE_OUT_OF_MEMORY ;return CURLE_OK ;","return Curl_urldecode ( data , path , 0 , NULL ) ;if ( ! pop3c -> mailbox , NULL , TRUE ) ;",1151
1632,facilities_len -= len + 1 ;p += len + 1 ;facilities_len -= len + 1 ;p += len + 1 ;,if ( len < 0 ) return 0 ;facilities_len -= len + 1 ;p += len + 1 ;if ( len < 0 ) return 0 ;facilities_len -= len + 1 ;p += len + 1 ;,1152
1633,sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ;if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) {,"sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ;if ( s -> ref && sh -> first_slice_in_pic_flag ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\\return 1 ;}if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) {",1153
1634,"ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ;if ( ! ps_dec -> u1_first_slice_in_stream ) {ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ;ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ;}{WORD32 i , j , poc = 0 ;ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ;ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ;ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ;ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ;if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ;j = 0 ;for ( i = 0 ;i < MAX_NUM_PIC_PARAMS ;i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ;{ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ;ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ;","
",1154
1635,"UWORD32 u4_x_dst_offset = 0 ;UWORD32 u4_y_dst_offset = 0 ;if ( ps_dec -> e_pic_type == B_PIC )  impeg2d_dec_pnb_mb_params ( ps_dec ) ;else  impeg2d_dec_p_mb_params ( ps_dec ) ;IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ;","WORD32 ret ;UWORD32 u4_x_dst_offset = 0 ;UWORD32 u4_y_dst_offset = 0 ;if ( ps_dec -> e_pic_type == B_PIC ) ret = impeg2d_dec_pnb_mb_params ( ps_dec ) ;else ret = impeg2d_dec_p_mb_params ( ps_dec ) ;if ( ret ) return IMPEG2D_MB_TEX_DECODE_ERR ;IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ;",1155
1636,"const YV12_BUFFER_CONFIG * const cfg =   & cm -> frame_bufs [ cm -> ref_frame_map [ 0 ] ] . buf ;if ( ! equal_dimensions ( cfg , sd ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Incorrect<S2SV_blank>buffer<S2SV_blank>dimensions"" ) ;","const YV12_BUFFER_CONFIG * const cfg = get_ref_frame ( cm , 0 ) ;if ( cfg == NULL ) {vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""No<S2SV_blank>\\\'last\\\'<S2SV_blank>reference<S2SV_blank>frame"" ) ;return VPX_CODEC_ERROR ;}if ( ! equal_dimensions ( cfg , sd ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Incorrect<S2SV_blank>buffer<S2SV_blank>dimensions"" ) ;",1156
1637,int i ;int j ;int rowstep ;jas_seqent_t * data ;,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;jas_seqent_t * data ;,1157
1638,"const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi )  : mbmi -> tx_size ;int i ;if ( xd -> mb_to_right_edge < 0 || xd -> mb_to_bottom_edge < 0 ) {int r , c ;int max_blocks_wide = num_4x4_w ;int max_blocks_high = num_4x4_h ;if ( xd -> mb_to_right_edge < 0 ) max_blocks_wide += ( xd -> mb_to_right_edge >> ( 5 + pd -> subsampling_x ) ) ;if ( xd -> mb_to_bottom_edge < 0 )  max_blocks_high += ( xd -> mb_to_bottom_edge >> ( 5 + pd -> subsampling_y ) ) ;i = 0 ;for ( r = 0 ;r < num_4x4_h ;r += ( 1 << tx_size ) ) {for ( c = 0 ;c < num_4x4_w ;c += ( 1 << tx_size ) ) {if ( r < max_blocks_high && c < max_blocks_wide )  visit ( plane , i , plane_bsize , tx_size , arg ) ;}}","const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , pd ) : mbmi -> tx_size ;int i = 0 , r , c ;const int max_blocks_wide = num_4x4_w + ( xd -> mb_to_right_edge >= 0 ? 0 : xd -> mb_to_right_edge < 0 ) max_blocks_wide += ( xd -> mb_to_right_edge >> ( 5 + pd -> subsampling_x ) ) ;if ( xd -> mb_to_bottom_edge < 0 ) max_blocks_high += ( xd -> mb_to_bottom_edge >> ( 5 + pd -> subsampling_y ) ) ;const int extra_step = ( ( num_4x4_w - max_blocks_wide ) >> tx_size ) * step ;for ( r = 0 ;r < max_blocks_high && c < max_blocks_wide ) visit ( plane , i , plane_bsize , tx_size , arg ) ;}}",1158
1639,mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ;if ( mmap_is_legacy ( ) ) {,mm -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor ;if ( mmap_is_legacy ( ) ) {,1159
1640,# if ! ( CONFIG_FAST_UNALIGNED )  dst [ 0 ] = src [ 0 ] ;dst [ 1 ] = src [ 1 ] ;dst [ 2 ] = src [ 2 ] ;dst [ 3 ] = src [ 3 ] ;dst [ 4 ] = src [ 4 ] ;dst [ 5 ] = src [ 5 ] ;dst [ 6 ] = src [ 6 ] ;dst [ 7 ] = src [ 7 ] ;# else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ;( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ;# endif src += src_stride ;,"memcpy ( dst , src , 8 ) ;src += src_stride ;",1160
1641,"case \'c\' : return getnum ( L , fmt , 1 ) ;case \'i\' : case \'I\' : {int sz = getnum ( L , fmt , sizeof ( int ) ) ;if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ;","case \'c\' : return getnum ( fmt , 1 ) ;case \'i\' : case \'I\' : {int sz = getnum ( fmt , sizeof ( int ) ) ;if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ;",1161
1642,"rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ;nrow = ( row + rowstoread > h ? h - row : rowstoread ) ;if ( buf == NULL )  {if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , ( void * * ) & buf , bufsize ,  ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 )  && ( buf == NULL || img -> stoponerr ) ) {","uint32 temp ;rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ;nrow = ( row + rowstoread > h ? h - row : rowstoread ) ;temp = ( row + img -> row_offset ) % rowsperstrip + nrow ;if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) {TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripSeparate"" ) ;return 0 ;}if ( buf == NULL ) {if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , ( void * * ) & buf , bufsize , temp * scanline ) == ( tmsize_t ) ( - 1 ) && ( buf == NULL || img -> stoponerr ) ) {",1162
1643,"else if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) ,  p0 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 )  && img -> stoponerr ) {if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 1 ) ,  p1 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 )  && img -> stoponerr ) {if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 2 ) ,  p2 , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 )  && img -> stoponerr ) {if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , colorchannels ) ,  pa , ( ( row + img -> row_offset ) % rowsperstrip + nrow ) * scanline ) == ( tmsize_t ) ( - 1 )  && img -> stoponerr ) {","else if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 0 ) , p0 , temp * scanline ) == ( tmsize_t ) ( - 1 ) && img -> stoponerr ) {if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 1 ) , p1 , temp * scanline ) == ( tmsize_t ) ( - 1 ) && img -> stoponerr ) {if ( colorchannels > 1 && TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , 2 ) , p2 , temp * scanline ) == ( tmsize_t ) ( - 1 ) && img -> stoponerr ) {if ( TIFFReadEncodedStrip ( tif , TIFFComputeStrip ( tif , offset_row , colorchannels ) , pa , temp * scanline ) == ( tmsize_t ) ( - 1 ) && img -> stoponerr ) {",1162
1644,assert ( 0 ) ;return 0 ;,abort ( ) ;,1163
1645,"static inline void header_put_be_short ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 )   {psf -> header [ psf -> headindex ++ ] = x ;};}","static inline void header_put_be_short ( SF_PRIVATE * psf , int x ) {psf -> header ) - 2 ) {psf -> header . indx ++ ] = x ;}",1164
1646,if ( upid == - 1 )  type = PIDTYPE_MAX ;,if ( upid == INT_MIN ) return - ESRCH ;if ( upid == - 1 ) type = PIDTYPE_MAX ;,1165
1647,"if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;","if ( NULL == siocb -> scm , false ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;",1166
1648,if ( num & ( 1 << ( number - 1 ) ) )  return num - ( 1 << number ) ;,if ( number && num & ( 1 << ( number - 1 ) ) ) return num - ( 1 << number ) ;,1167
1649,"const int w = vpx_img_plane_width ( img , plane ) ;const int h = vpx_img_plane_height ( img , plane ) ;if ( fread ( buf , 1 , w , file ) != w )  return 0 ;","const int w = vpx_img_plane_width ( img , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ;const int h = vpx_img_plane_height ( img , plane ) ;if ( fread ( buf , 1 , w , file ) != ( size_t ) w ) return 0 ;",1168
1650,"uint16_t attr_len ;uint16_t orig_attr_len ;if ( avp -> length < sizeof ( struct l2tp_avp_t ) + 2 ) {log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>hidden<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type<S2SV_blank>%hu):"" ""<S2SV_blank>length<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%hu<S2SV_blank>bytes)\\\return - 1 ;attr_len = avp -> length - sizeof ( struct l2tp_avp_t ) ;MD5_Init ( & md5_ctx ) ;","uint16_t avp_len ;uint16_t attr_len ;uint16_t orig_attr_len ;avp_len = avp -> flags & L2TP_AVP_LEN_MASK ;if ( avp_len < sizeof ( struct l2tp_avp_t ) + 2 ) {log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>hidden<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type<S2SV_blank>%hu):"" ""<S2SV_blank>length<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%hu<S2SV_blank>bytes)\\\return - 1 ;attr_len = avp_len - sizeof ( struct l2tp_avp_t ) ;MD5_Init ( & md5_ctx ) ;",1169
1651,"return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ;}","struct dm_dev * dev = lc -> dev ;int r = 0 ;if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ;}",1170
1652,"len -= POLY1305_BLOCK_SIZE ;memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;","if ( len < POLY1305_BLOCK_SIZE ) return 0 ;len -= POLY1305_BLOCK_SIZE ;memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;",1171
1653,"request_module ( ""%s"" , name ) ;if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) )  request_module ( ""%s-all"" , name ) ;alg = crypto_alg_lookup ( name , type , mask ) ;","request_module ( ""crypto-%s"" , name ) ;if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) request_module ( ""crypto-%s-all"" , name ) ;alg = crypto_alg_lookup ( name , type , mask ) ;",1172
1654,"int size = comm_event -> event_id . header . size ;int ret ;perf_event_header__init_id ( & comm_event -> event_id . header , & sample , event ) ;ret = perf_output_begin ( & handle , event ,  comm_event -> event_id . header . size , 0 , 0 ) ;if ( ret ) goto out ;","int size = comm_event -> event_id . header . size , 0 ) ;if ( ret ) goto out ;",1173
1655,},unlink ( RUN_LIB_FILE ) ;},1174
1656,"if ( key_is_instantiated ( key ) )  seq_printf ( m , "":<S2SV_blank>%u"" , key -> datalen ) ;","if ( key_is_positive ( key ) ) seq_printf ( m , "":<S2SV_blank>%u"" , key -> datalen ) ;",1175
1657,"BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;sa -> rc_family = AF_BLUETOOTH ;","BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;memset ( sa , 0 , sizeof ( * sa ) ) ;sa -> rc_family = AF_BLUETOOTH ;",1176
1658,"memcpy ( pass_salt , cpkt . data , cpkt . length ) ;send_auth ( username , password ) ;","if ( cpkt . length != 16 ) {fprintf ( stderr , _ ( ""Invalid<S2SV_blank>salt<S2SV_blank>length:<S2SV_blank>%d<S2SV_blank>(instead<S2SV_blank>of<S2SV_blank>16)<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\\}memcpy ( pass_salt , cpkt . data , 16 ) ;send_auth ( username , password ) ;",1177
1659,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |  NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ;if ( ses -> server -> sign ) {flags |= NTLMSSP_NEGOTIATE_SIGN ;}tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ;,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL ;if ( ses -> server -> sign ) flags |= NTLMSSP_NEGOTIATE_SIGN ;tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ;,1178
1660,"# ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) {enum QuadOption ans ;if ( C_SslForceTls ) ans = MUTT_YES ;else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == MUTT_ABORT ) {goto err_close_conn ;}","
",1179
1661,goto err_close_conn ;},goto err_close_conn ;},1179
1662,"goto err_close_conn ;}# endif }else if ( mutt_istr_startswith ( adata -> buf , ""*<S2SV_blank>PREAUTH"" ) ) {# ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && C_SslForceTls ) {mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ;goto err_close_conn ;}# endif adata -> state = IMAP_AUTHENTICATED ;if ( check_capabilities ( adata ) != 0 ) goto bail ;FREE ( & adata -> capstr ) ;# ifdef USE_SSL  err_close_conn : imap_close_connection ( adata ) ;# endif  bail : FREE ( & adata -> capstr ) ;",goto bail ;# ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ;# endif bail : FREE ( & adata -> capstr ) ;,1179
1663,"strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ;","strncpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ;",1180
1664,"static void  horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % stride ) == 0 ) ;if ( cc > stride ) {","static int horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%stride)!=0"" ) ;return 0 ;}if ( cc > stride ) {",1181
1665,},return 1 ;},1181
1666,if ( g -> sect <= 0 ||  g -> head <= 0 ||  g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,if ( g -> sect <= 0 || g -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,1182
1667,"if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ;","if ( recv ( gpsd_sock , line , sizeof ( line ) - pos - 1 , 0 ) <= 0 ) return ;",1183
1668,"if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 )  return ;","if ( recv ( gpsd_sock , line + pos , sizeof ( line ) - 1 , 0 ) <= 0 ) return ;",1183
1669,"ret = get_tag ( ( uint8_t * ) code -> data , code -> length , & t , & contents ,  & clen , & remainder , & rlen ) ;if ( ret ) return ret ;","ret = get_tag ( ( uint8_t * ) code -> data , code -> length , & t , & contents , & clen , & remainder , & rlen , 0 ) ;if ( ret ) return ret ;",1184
1670,"read_userfile ( ) ;if ( ( user = find_user ( curconn -> username ) ) != NULL ) {# endif  md5data [ 0 ] = 0 ;strncpy ( md5data + 1 , user -> password , 82 ) ;memcpy ( md5data + 1 + strlen ( user -> password ) , curconn -> pass_salt , 16 ) ;md5_init ( & state ) ;md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( user -> password ) + 17 ) ;md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ;","int act_pass_len ;read_userfile ( ) ;if ( ( user = find_user ( curconn -> username ) ) != NULL ) {# endif act_pass_len = strlen ( user -> password ) ;act_pass_len = act_pass_len <= 82 ? act_pass_len : 82 ;md5data [ 0 ] = 0 ;memcpy ( md5data + 1 , user -> password , act_pass_len ) ;memcpy ( md5data + 1 + act_pass_len , curconn -> pass_salt , 16 ) ;md5_init ( & state ) ;md5_append ( & state , ( const md5_byte_t * ) md5data , 1 + act_pass_len + 16 ) ;md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ;",1185
1671,"return mount_entry_on_generic ( mntent , path ) ;}","return mount_entry_on_generic ( mntent , path , rootfs -> mount ) ;}",1186
1672,"if ( PyUnicode_CompareWithASCIIString ( name , ""__debug__"" ) == 0 ) {ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ;","if ( _PyUnicode_EqualToASCIIString ( name , ""__debug__"" ) == 0 ) {ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ;",1187
1673,"if ( PyUnicode_CompareWithASCIIString ( name , * p ) == 0 ) {ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ;","if ( _PyUnicode_EqualToASCIIString ( name , * p ) ) {ast_error ( c , n , ""assignment<S2SV_blank>to<S2SV_blank>keyword"" ) ;",1187
1674,if ( len <= 0 )  break ;len -= bytes ;offset = 0 ;,unsigned short prev_bi_vcnt = bio -> bi_vcnt ;if ( len <= 0 ) break ;if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;len -= bytes ;offset = 0 ;,1188
1675,assert ( numcolors <= RAS_CMAP_MAXSIZ ) ;actualnumcolors = hdr -> maplength / 3 ;,if ( numcolors > RAS_CMAP_MAXSIZ ) {return - 1 ;}actualnumcolors = hdr -> maplength / 3 ;,1189
1676,const char * path = conn -> data -> state . path ;int len ;,const char * path = conn -> data -> state . path ;,1190
1677,"smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ;if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ;","result = Curl_urldecode ( conn -> data , path , 0 , & smtpc -> domain , NULL , TRUE ) ;if ( result ) return result ;",1190
1678,"strncpy ( str , ""ID:"" , len ) ;strncat ( str , jslGetTokenValueAsString ( ) , len ) ;}else if ( lex -> tk == LEX_STR ) {strncpy ( str , ""String:\\\'"" , len ) ;strncat ( str , jslGetTokenValueAsString ( ) , len ) ;strncat ( str , ""\\\'"" , len ) ;","espruino_snprintf ( str , ""ID:"" , len ) ;strncat ( str , len , ""ID:%s"" , jslGetTokenValueAsString ( ) , len ) ;strncat ( str , ""\\\'"" , len ) ;",1191
1679,for ( i = j = 0 ;i < sizeof ( buf ) - 1 && str [ i ] ;if ( str [ j ] == '#' ) {,for ( i = j = 0 ;i < sizeof ( buf ) - 1 && str [ j ] ;if ( str [ j ] == '#' ) {,1192
1680,uchar buf [ 2 ] ;int i ;,jas_uchar buf [ 2 ] ;int i ;,1193
1681,return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;},"scat = & rm -> data . op_sg [ sg ] ;ret = sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ;return ret ;}",1194
1682,"priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ;if ( ! priv -> base ) {","if ( ! r ) return - EINVAL ;priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ;if ( ! priv -> base ) {",1195
1683,return FALSE ;},transport -> credssp = NULL ;return FALSE ;},1196
1684,"r_cons_printf ( ""["" ) ;}else if ( IS_MODE_SET ( mode ) ) {r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ;}else if ( ! at && exponly ) {if ( IS_MODE_RAD ( mode ) ) {r_cons_printf ( ""fs<S2SV_blank>exports\\\}else if ( IS_MODE_NORMAL ( mode ) ) {r_cons_printf ( printHere ? """" : ""[Exports]\\\}}else if ( ! at && ! exponly ) {if ( IS_MODE_RAD ( mode ) ) {r_cons_printf ( ""fs<S2SV_blank>symbols\\\}else if ( IS_MODE_NORMAL ( mode ) ) {r_cons_printf ( printHere ? """" : ""[Symbols]\\\}}if ( IS_MODE_NORMAL ( mode ) ) {r_cons_printf ( ""Num<S2SV_blank>Paddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vaddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Bind<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Size<S2SV_blank>Name\\\}size_t count = 0 ;r_list_foreach ( symbols , iter , symbol ) {if ( ! symbol -> name ) {continue ;}char * r_symbol_name = r_str_escape_utf8 ( symbol -> name , false , true ) ;ut64 addr = compute_addr ( r -> bin , symbol -> paddr , symbol -> vaddr , va ) ;int len = symbol -> size ? symbol -> size : 32 ;SymName sn = {0 };if ( exponly && ! isAnExport ( symbol ) ) {free ( r_symbol_name ) ;continue ;}if ( name && strcmp ( r_symbol_name , name ) ) {free ( r_symbol_name ) ;continue ;}if ( at && ( ! symbol -> size || ! is_in_range ( at , addr , symbol -> size ) ) ) {free ( r_symbol_name ) ;continue ;}if ( ( printHere && ! is_in_range ( r -> offset , symbol -> paddr , len ) ) && ( printHere && ! is_in_range ( r -> offset , addr , len ) ) ) {free ( r_symbol_name ) ;continue ;}count ++ ;snInit ( r , & sn , symbol , lang ) ;if ( IS_MODE_SET ( mode ) && ( is_section_symbol ( symbol ) || is_file_symbol ( symbol ) ) ) {}else if ( IS_MODE_SET ( mode ) && is_special_symbol ( symbol ) ) {if ( is_arm ) {handle_arm_special_symbol ( r , symbol , va ) ;}}else if ( IS_MODE_SET ( mode ) ) {if ( is_arm ) {handle_arm_symbol ( r , symbol , info , va ) ;}select_flag_space ( r , symbol ) ;if ( sn . classname ) {RFlagItem * fi = r_flag_get ( r -> flags , sn . methflag ) ;if ( r -> bin -> prefix ) {char * prname = r_str_newf ( ""%s.%s"" , r -> bin -> prefix , sn . methflag ) ;r_name_filter ( sn . methflag , - 1 ) ;free ( sn . methflag ) ;sn . methflag = prname ;}if ( fi ) {r_flag_item_set_realname ( fi , sn . methname ) ;if ( ( fi -> offset - r -> flags -> base ) == addr ) {r_flag_unset ( r -> flags , fi ) ;}}else {fi = r_flag_set ( r -> flags , sn . methflag , addr , symbol -> size ) ;char * comment = fi -> comment ? strdup ( fi -> comment ) : NULL ;if ( comment ) {r_flag_item_set_comment ( fi , comment ) ;R_FREE ( comment ) ;}}}else {const char * n = sn . demname ? sn . demname : sn . name ;const char * fn = sn . demflag ? sn . demflag : sn . nameflag ;char * fnp = ( r -> bin -> prefix ) ? r_str_newf ( ""%s.%s"" , r -> bin -> prefix , fn ) : strdup ( fn ) ;RFlagItem * fi = r_flag_set ( r -> flags , fnp , addr , symbol -> size ) ;if ( fi ) {r_flag_item_set_realname ( fi , n ) ;fi -> demangled = ( bool ) ( size_t ) sn . demname ;}else {if ( fn ) {eprintf ( ""[Warning]<S2SV_blank>Can\\\'t<S2SV_blank>find<S2SV_blank>flag<S2SV_blank>(%s)\\\}}free ( fnp ) ;}if ( sn . demname ) {r_meta_add ( r -> anal , R_META_TYPE_COMMENT , addr , symbol -> size , sn . demname ) ;}r_flag_space_pop ( r -> flags ) ;}else if ( IS_MODE_JSON ( mode ) ) {char * str = r_str_escape_utf8_for_json ( r_symbol_name , - 1 ) ;r_cons_printf ( ""%s{\\\\""name\\\\"":\\\\""%s\\\\"","" ""\\\\""demname\\\\"":\\\\""%s\\\\"","" ""\\\\""flagname\\\\"":\\\\""%s\\\\"","" ""\\\\""ordinal\\\\"":%d,"" ""\\\\""bind\\\\"":\\\\""%s\\\\"","" ""\\\\""size\\\\"":%d,"" ""\\\\""type\\\\"":\\\\""%s\\\\"","" ""\\\\""vaddr\\\\"":%"" PFMT64d "","" ""\\\\""paddr\\\\"":%"" PFMT64d ""}"" , ( ( exponly && firstexp ) || printHere ) ? """" : ( iter -> p ? "","" : """" ) , str , sn . demname ? sn . demname : """" , sn . nameflag , symbol -> ordinal , symbol -> bind , ( int ) symbol -> size , symbol -> type , ( ut64 ) addr , ( ut64 ) symbol -> paddr ) ;free ( str ) ;}else if ( IS_MODE_SIMPLE ( mode ) ) {const char * name = sn . demname ? sn . demname : r_symbol_name ;r_cons_printf ( ""0x%08"" PFMT64x ""<S2SV_blank>%d<S2SV_blank>%s\\\}else if ( IS_MODE_SIMPLEST ( mode ) ) {const char * name = sn . demname ? sn . demname : r_symbol_name ;r_cons_printf ( ""%s\\\}else if ( IS_MODE_RAD ( mode ) ) {if ( is_special_symbol ( symbol ) ) {goto next ;}RBinFile * binfile ;RBinPlugin * plugin ;const char * name = sn . demname ? sn . demname : r_symbol_name ;if ( ! name ) {goto next ;}if ( ! strncmp ( name , ""imp."" , 4 ) ) {if ( lastfs != \'i\' ) {r_cons_printf ( ""fs<S2SV_blank>imports\\\}lastfs = \'i\' ;}else {if ( lastfs != \'s\' ) {const char * fs = exponly ? ""exports"" : ""symbols"" ;r_cons_printf ( ""fs<S2SV_blank>%s\\\}lastfs = \'s\' ;}if ( r -> bin -> prefix || * name ) {char * flagname = construct_symbol_flagname ( ""sym"" , name , MAXFLAG_LEN_DEFAULT ) ;if ( ! flagname ) {goto next ;}r_cons_printf ( ""\\\\""f<S2SV_blank>%s%s%s<S2SV_blank>%u<S2SV_blank>0x%08"" PFMT64x ""\\\\""\\\free ( flagname ) ;}binfile = r_bin_cur ( r -> bin ) ;plugin = r_bin_file_cur_plugin ( binfile ) ;if ( plugin && plugin -> name ) {if ( r_str_startswith ( plugin -> name , ""pe"" ) ) {char * module = strdup ( r_symbol_name ) ;char * p = strstr ( module , "".dll_"" ) ;if ( p && strstr ( module , ""imp."" ) ) {char * symname = __filterShell ( p + 5 ) ;char * m = __filterShell ( module ) ;* p = 0 ;if ( r -> bin -> prefix ) {r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\\r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s\\\","r_cons_printf ( ""\\\\""k<S2SV_blank>bin/pe/%s/%d=%s.%s\\\\""\\\r_cons_printf ( ""k<S2SV_blank>bin/pe/%s/%d=%s\\\",1197
1685,"status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ;out : return status ;","status = decode_getacl ( xdr , rqstp , res ) ;out : return status ;",1198
1686,"return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ;}","return mount_entry_on_generic ( mntent , mntent -> mnt_dir , NULL ) ;}",1199
1687,return Qnil ;},"rb_ivar_set ( self , id_key_set , Qtrue ) ;return Qnil ;}",1200
1688,"return KRB5KDC_ERR_BADOPTION ;}if ( ! krb5_principal_compare ( kdc_context , server -> princ ,  server_princ ) ) {return KRB5KDC_ERR_SERVER_NOMATCH ;","* status = ""INVALID_S4U2PROXY_OPTIONS"" ;return KRB5KDC_ERR_BADOPTION ;}if ( ! krb5_principal_compare ( kdc_context , server -> princ , server_princ ) ) {* status = ""EVIDENCE_TICKET_MISMATCH"" ;return KRB5KDC_ERR_SERVER_NOMATCH ;",1201
1689,"if ( clone_flags & CLONE_SETTLS )  thread -> tp_value = childregs -> ARM_r3 ;thread_notify ( THREAD_NOTIFY_COPY , thread ) ;","if ( clone_flags & CLONE_SETTLS ) thread -> tp_value [ 0 ] = childregs -> ARM_r3 ;thread -> tp_value [ 1 ] = get_tpuser ( ) ;thread_notify ( THREAD_NOTIFY_COPY , thread ) ;",1202
1690,"jas_stream_t * stream ;jas_stream_memobj_t * obj ;if ( ! ( stream = jas_stream_create ( ) ) ) {return 0 ;}stream -> openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY ;jas_stream_initbuf ( stream , JAS_STREAM_FULLBUF , 0 , 0 ) ;stream -> ops_ = & jas_stream_memops ;if ( ! ( obj = jas_malloc ( sizeof ( jas_stream_memobj_t ) ) ) ) {jas_stream_destroy ( stream ) ;return 0 ;stream -> obj_ = ( void * ) obj ;obj -> myalloc_ = 0 ;obj -> buf_ = 0 ;obj -> bufsize_ = 1024 ;obj -> growable_ = 1 ;obj -> bufsize_ = bufsize ;obj -> growable_ = 0 ;}","char * new_buf ;size_t new_bufsize ;if ( bufsize < 0 ) {jas_deprecated ( ""negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen"" ) ;}if ( buf && bufsize <= 0 ) {jas_eprintf ( ""Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\\jas_deprecated ( ""A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>"" ""jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\\obj -> bufsize_ = 1024 ;obj -> growable_ = 1 ;obj -> bufsize_ = bufsize ;obj -> growable_ = 0 ;}",1203
1691,"struct sshbuf * b ;struct sshkey * key = NULL ;char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;u_char * pkblob , * sig , have_sig ;size_t blen , slen ;if ( ! authctxt -> valid ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;return 0 ;}","struct sshbuf * b = NULL ;struct sshkey * key = NULL ;char * pkalg = NULL , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;u_char * pkblob = NULL , * sig = NULL , have_sig ;size_t blen , slen ;}if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;",1204
1692,"if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" ,  __func__ , ssh_err ( r ) ) ;}","if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;}",1204
1693,"free ( sig ) ;auth2_record_key ( authctxt , authenticated , key ) ;if ( ( r = sshpkt_get_end ( ssh ) ) != 0 )  fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) {","auth2_record_key ( authctxt , authenticated , key ) ;if ( ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ;if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;}if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) {",1204
1694,return authenticated ;},free ( sig ) ;return authenticated ;},1204
1695,uint32_t bcount ;infilesize = DoGetFileSize ( infile ) ;,uint32_t bcount ;CLEAR ( WaveHeader ) ;infilesize = DoGetFileSize ( infile ) ;,1205
1696,"if ( iov_iter_rw ( iter ) == READ )  get_block = ocfs2_get_block ;else  get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;","if ( iov_iter_rw ( iter ) == READ ) get_block = ocfs2_lock_get_block ;else get_block = ocfs2_dio_get_block ;return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ;",1206
1697,"_sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) ;if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {_sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\\\'t<S2SV_blank>offer"" , mech ) ;","_sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK ;if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {_sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\\\'t<S2SV_blank>offer"" , mech ) ;",1207
1698,}off = regs [ regno ] . off + regs [ regno ] . var_off . value ;,return - EACCES ;}off = regs [ regno ] . off + regs [ regno ] . var_off . value ;,1208
1699,"if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;","memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteFujiEntry ) ) ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;",1209
1700,sb -> s_op = & ext2_sops ;sb -> s_export_op = & ext2_export_ops ;,"# ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ;if ( ! sbi -> s_mb_cache ) {ext2_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ;goto failed_mount3 ;}# endif sb -> s_op = & ext2_sops ;sb -> s_export_op = & ext2_export_ops ;",1210
1701,failed_mount3 :  percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ;,failed_mount3 : if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ;,1210
1702,static int remove_bond ( const bt_bdaddr_t * bd_addr )  {if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ;,static int remove_bond ( const bt_bdaddr_t * bd_addr ) {if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ;if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ;,1211
1703,if ( len < tcp_hdrlen )  return - 1 ;,if ( len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) ) return - 1 ;if ( tcp_hdrlen >= 15 * 4 ) return 0 ;,1212
1704,"if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ;","if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) {if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ;",1212
1705,"if ( numrows < 0 || numcols < 0 ) {return 0 ;}return 0 ;}matrix -> datasize_ = numrows * numcols ;if ( matrix -> maxrows_ > 0 ) {if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) {jas_matrix_destroy ( matrix ) ;return 0 ;jas_matrix_destroy ( matrix ) ;return 0 ;","size_t size ;matrix = 0 ;if ( numrows < 0 || numcols < 0 ) {goto error ;}goto error ;}matrix -> datasize_ = 0 ;if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) {goto error ;jas_matrix_destroy ( matrix ) ;return 0 ;",1213
1706,},error : if ( matrix ) {jas_matrix_destroy ( matrix ) ;}return 0 ;},1213
1707,ipv6_select_ident ( fh ) ;fh -> nexthdr = nexthdr ;,"ipv6_select_ident ( fh , rt ) ;fh -> nexthdr = nexthdr ;",1214
1708,ipv6_select_ident ( fh ) ;frag_id = fh -> identification ;,"ipv6_select_ident ( fh , rt ) ;frag_id = fh -> identification ;",1214
1709,"static void  ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh )  {struct mb_cache_entry * ce ;int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;error = 0 ;}else {ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;mb_cache_entry_release ( ce ) ;}","static void ext4_xattr_cache_insert ( struct mb2_cache * ext4_mb_cache , struct buffer_head * bh ) {int error ;ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ;if ( ! ce ) {error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) ea_bdebug ( bh , ""already<S2SV_blank>in<S2SV_blank>cache"" ) ;else ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]"" , ( int ) hash ) ;",1215
1710,"SCSIDiskReq * r ;req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ;r = DO_UPCAST ( SCSIDiskReq , req , req ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ;","req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ;",1216
1711,int avail ;int expect ;avail = buf -> len - buf -> cursor ;expect = 8 + 8 + nxip * 8 ;if ( nxip < 0 || nxip > avail || expect > avail )  goto bad_format ;,if ( nxip < 0 || nxip > avail || expect > avail ) goto bad_format ;,1217
1712,"static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;};}","static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x ) {psf -> header ) - 3 ) {psf -> header . ptr [ psf -> header . ptr [ psf -> headindex ++ ] = ( x >> 16 ) ;}",1218
1713,if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA )  ret = - EADDRNOTAVAIL ;,if ( ret || ! cm_id -> device || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) ret = - EADDRNOTAVAIL ;,1219
1714,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;struct xfrm_dump_info info ;BUILD_BUG_ON ( sizeof ( struct xfrm_policy_walk ) > sizeof ( cb -> args ) - sizeof ( cb -> args [ 0 ] ) ) ;if ( ! cb -> args [ 0 ] ) {cb -> args [ 0 ] = 1 ;,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ;struct xfrm_dump_info info ;if ( ! cb -> args [ 0 ] ) {cb -> args [ 0 ] = 1 ;,1220
1715,"epoll_t * epoll = _cast_epoll ( epoll_ ) ;oe_errno = 0 ;if ( oe_syscall_write_ocall ( & ret , epoll -> host_fd , buf , count ) != OE_OK )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;","epoll_t * file = _cast_epoll ( epoll_ ) ;oe_errno = 0 ;if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_write_ocall ( & ret , file -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;",1221
1716,struct dentry * upper = ovl_dentry_upper ( dentry ) ;int err ;err = - ESTALE ;if ( upper -> d_parent == upperdir ) {dget ( upper ) ;dput ( upper ) ;ovl_dentry_version_inc ( dentry -> d_parent ) ;}if ( ! err ) d_drop ( dentry ) ;inode_unlock ( dir ) ;return err ;,"struct dentry * upper ;int err ;upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ;err = PTR_ERR ( upper ) ;if ( IS_ERR ( upper ) ) goto out_unlock ;err = - ESTALE ;if ( upper == ovl_dentry_upper ( dentry ) ) {ovl_dentry_version_inc ( dentry -> d_parent ) ;}dput ( upper ) ;if ( ! err ) d_drop ( dentry ) ;out_unlock : inode_unlock ( dir ) ;return err ;",1222
1717,"errstr = parse_global_option ( CMD_INITIALIZE , NULL , NULL ) ;if ( errstr ) {if ( * section_ptr == & new_service_options )  s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ;else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , ( * section_ptr ) -> servname ) ;","errstr = parse_global_option ( CMD_INITIALIZE , & new_global_options , NULL , NULL ) ;if ( errstr ) {",1223
1718,if ( ! * ptrptr && ! ( nmemb && size ) )  return AVERROR ( ENOMEM ) ;,if ( ! * ptrptr && nmemb && size ) ) return AVERROR ( ENOMEM ) ;,1224
1719,if ( a -> name == MAPI_BODY_HTML )  {else if ( a -> name == MAPI_RTF_COMPRESSED )  {,if ( a -> type == szMAPI_BINARY && a -> name == MAPI_BODY_HTML ) {else if ( a -> type == szMAPI_BINARY && a -> name == MAPI_RTF_COMPRESSED ) {,1225
1720,"WritePixel ( i , & context , casspecial ) ;}act_code = old_code ;}while ( act_code > clr ) {* ( -- stackp ) = ab_suffx [ act_code ] ;act_code = ab_prfx [ act_code ] ;}casspecial = ( u8 ) act_code ;* ( -- stackp ) = casspecial ;WritePixels ( i , & context , stackp , stack_top - stackp ) ;npix -= ( stack_top - stackp ) ;","if ( npix > 0 ) WritePixel ( i , & context , casspecial ) ;}if ( npix >= ( stack_top - stackp ) ;npix -= ( stack_top - stackp ) ;",1226
1721,default :  errno = EINVAL ;,case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ;return 0 ;default : errno = EINVAL ;,1227
1722,"jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\\goto error ;}if ( box -> type != JP2_BOX_JP ) {jas_eprintf ( ""error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\\goto error ;}if ( box -> data . jp . magic != JP2_JP_MAGIC ) {jas_eprintf ( ""incorrect<S2SV_blank>magic<S2SV_blank>number\\\goto error ;}jp2_box_destroy ( box ) ;box = 0 ;if ( ! ( box = jp2_box_get ( in ) ) ) {goto error ;if ( box -> type != JP2_BOX_FTYP ) {jas_eprintf ( ""expecting<S2SV_blank>file<S2SV_blank>type<S2SV_blank>box\\\goto error ;}jp2_box_destroy ( box ) ;box = 0 ;found = 0 ;while ( ( box = jp2_box_get ( in ) ) ) {if ( jas_getdbglevel ( ) >= 1 ) {jas_eprintf ( ""box<S2SV_blank>type<S2SV_blank>%s\\\}","jas_eprintf ( ""got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\\",1228
1723,"err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ;if ( err < 0 ) return err ;","err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf + p , c , 0 ) ;if ( err < 0 ) return err ;",1229
1724,journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ;if ( offset == 0 ) ClearPageChecked ( page ) ;,"journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ;if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset ) ;if ( offset == 0 ) ClearPageChecked ( page ) ;",1230
1725,"trak = gf_isom_get_track ( movie -> moov , i + 1 ) ;GF_SAFEALLOC ( writer , TrackWriter ) ;if ( ! writer ) goto exit ;","GF_SampleTableBox * stbl ;trak = gf_isom_get_track ( movie -> moov , i + 1 ) ;stbl = ( trak -> Media && trak -> Media -> information ) ? trak -> Media -> information -> sampleTable : NULL ;if ( ! stbl || ! stbl -> SampleSize || ! stbl -> ChunkOffset || ! stbl -> SampleToChunk ) {return GF_ISOM_INVALID_FILE ;}GF_SAFEALLOC ( writer , TrackWriter ) ;if ( ! writer ) goto exit ;",1231
1726,"static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize )  {","static UINT32 nsc_rle_encode ( const BYTE * in , BYTE * out , UINT32 originalSize ) {",1232
1727,"unsigned short height = 0 ;char * terminal = getenv ( ""TERM"" ) ;char md5data [ 100 ] ;unsigned char md5sum [ 17 ] ;int plen ;md5_state_t state ;# if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( md5data , sizeof ( md5data ) ) ;mlock ( md5sum , sizeof ( md5data ) ) ;# endif  md5data [ 0 ] = 0 ;strncpy ( md5data + 1 , password , 82 ) ;md5data [ 83 ] = \'\\\\0\' ;memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ;md5_init ( & state ) ;md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ;md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ;","memcpy ( md5data + 1 , password , 82 ) ;md5data [ 83 ] = \'\\\\0\' ;memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ;md5_init ( & state ) ;md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ;md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ;",1233
1728,"void * dllhandle ;if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\","void * dllhandle ;if ( COM_CompareExtension ( name , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , name ) ;return NULL ;}if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\",1234
1729,if ( tree_top ) {if ( tree_top -> label ) SNMP_FREE ( tree_top -> label ) ;SNMP_FREE ( tree_top ) ;}tree_head = NULL ;Mib = NULL ;if ( _mibindexes ) {int i ;for ( i = 0 ;i < _mibindex ;++ i ) SNMP_FREE ( _mibindexes [ i ] ) ;free ( _mibindexes ) ;_mibindex = 0 ;_mibindex_max = 0 ;_mibindexes = NULL ;},+ i ) SNMP_FREE ( _mibindexes [ i ] ) ;,1235
1730,# define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL )  # define PCDGetBits ( n ) {,# define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) # define PCDGetBits ( n ) \\\\\,1236
1731,}typedef struct PCDTable {,\\\\\typedef struct PCDTable {,1236
1732,"ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" ,  image -> filename ) ;","for ( j = 0 ;j < i ;j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ;ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;",1236
1733,buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;return ( MagickFalse ) ;,buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ;for ( j = 0 ;j <= i ;j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ;return ( MagickFalse ) ;,1236
1734,if ( kwonlyargs == NULL ) {,if ( i < NCH ( n ) && kwonlyargs == NULL ) {,1237
1735,"if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;","if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",1237
1736,"
","g_hash_table_remove_all ( headers ) ;g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""cockpit=d"" ) ) ;if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ;",1238
1737,g_hash_table_destroy ( headers ) ;},g_hash_table_destroy ( headers ) ;},1238
1738,"# ifdef HAVE_IPV6  char * p ;if ( * ( str ) == \'[\' && str_len > 1 ) {p = memchr ( str + 1 , \']\' , str_len - 2 ) ;if ( ! p || * ( p + 1 ) != \':\' ) {* portno = atoi ( p + 2 ) ;return estrndup ( str + 1 , p - str - 1 ) ;","# ifdef HAVE_IPV6 if ( * ( str ) == \'[\' && str_len > 1 ) {char * p = memchr ( str + 1 , \']\' , str_len - 2 ) , * e = NULL ;if ( ! p || * ( p + 1 ) != \':\' ) {* portno = strtol ( p + 2 ) ;return estrndup ( str + 1 , p - str - 1 ) ;",1239
1739,"* portno = atoi ( colon + 1 ) ;host = estrndup ( str , colon - str ) ;}else {if ( get_err ) {return host ;}","char * e = NULL ;* portno = strtol ( colon + 1 , & e , 10 ) ;if ( ! e || ! * e ) {return estrndup ( str , colon - str ) ;}}if ( get_err ) {",1239
1740,\\\},\\\},1240
1741,"for ( row = 0 ;vpx_memcpy ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;","# if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) {const uint16_t * src16 = CONVERT_TO_SHORTPTR ( src ) ;uint16_t * dst16 = CONVERT_TO_SHORTPTR ( dst ) ;for ( row = 0 ;memcpy ( dst16 , src16 , src_ybc -> y_width * sizeof ( uint16_t ) ) ;src16 += src_ybc -> y_stride ;dst16 += dst_ybc -> y_stride ;}return ;}# endif for ( row = 0 ;row < src_ybc -> y_height ;++ row ) {memcpy ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;",1241
1742,"
","if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) {avpriv_request_sample ( s -> avctx , ""cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64"" ) ;return AVERROR_PATCHWELCOME ;}",1242
1743,c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;if ( c -> cblk_style != 0 ) {,c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ;if ( c -> cblk_style != 0 ) {,1242
1744,if ( '%' == * ptr ) {if ( '%' == ptr [ 1 ] ) {,if ( '%' == * ptr && ptr [ 1 ] ) {if ( '%' == ptr [ 1 ] ) {,1243
1745,"static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , TOKENEXTRA * * tp ) {MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {int dummy_rate ;int64_t dummy_dist ;BLOCK_SIZE i ;MACROBLOCK * x = & cpi -> mb ;for ( i = BLOCK_4X4 ;const int num_4x4_w = num_4x4_blocks_wide_lookup [ i ] ;const int num_4x4_h = num_4x4_blocks_high_lookup [ i ] ;const int num_4x4_blk = MAX ( 4 , num_4x4_w * num_4x4_h ) ;for ( x -> sb_index = 0 ;x -> sb_index < 4 ;++ x -> sb_index ) for ( x -> mb_index = 0 ;x -> mb_index < 4 ;++ x -> mb_index ) for ( x -> b_index = 0 ;x -> b_index < 16 / num_4x4_blk ;++ x -> b_index ) get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ;}}vp9_zero ( cpi -> mb . pred_mv ) ;if ( ( sf -> partition_search_type == SEARCH_PARTITION &&  sf -> use_lastframe_partitioning ) || sf -> partition_search_type == FIXED_PARTITION ||  sf -> partition_search_type == VAR_BASED_PARTITION ||  sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) {const int idx_str = cm -> mi_stride * mi_row + mi_col ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ;MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ;cpi -> mb . source_variance = UINT_MAX ;if ( sf -> partition_search_type == FIXED_PARTITION ) {set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , sf -> always_this_block_size ) ;rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 ,  & dummy_rate , & dummy_dist , 1 ) ;}","static void encode_rd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) {TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;memset ( & xd -> left_context ) ) ;memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ;for ( mi_col = tile_info -> mi_col_start ;mi_col += MI_BLOCK_SIZE ) {const struct segmentation * const seg = & cm -> seg ;int dummy_rate ;int64_t dummy_dist ;RD_COST dummy_rdc ;int i ;int seg_skip = 0 ;const int idx_str = cm -> mi_stride * mi_row + mi_col ;MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ;for ( i = 0 ;++ i ) td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ;for ( i = 0 ;i < 64 ;+ x -> sb_index ) for ( x -> mb_index = 0 ;+ x -> mb_index ) for ( x -> b_index = 0 ;+ x -> b_index ) get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ;td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ;td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ;td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ;td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ;}}vp9_zero ( x -> pred_mv ) ;td -> pc_root -> index = 0 ;if ( seg -> enabled ) {const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ;int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ;seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ;}x -> source_variance = UINT_MAX ;if ( sf -> partition_search_type == SEARCH_PARTITION && sf -> use_lastframe_partitioning ) || sf -> partition_search_type == FIXED_PARTITION || seg_skip ) {const BLOCK_SIZE bsize = seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ;set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ;set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ;rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ;}else if ( cpi -> partition_search_skippable_frame ) {BLOCK_SIZE bsize ;set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ;bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ;set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ;rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ;}else if ( sf -> partition_search_type == VAR_BASED_PARTITION && cm -> frame_type != KEY_FRAME ) {choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ;rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ;}else {if ( sf -> auto_min_max_partition_size ) {set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ;rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , & x -> min_partition_size , & x -> max_partition_size ) ;}rd_pick_partition ( cpi , td , tile_data , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rdc , INT64_MAX , td -> pc_root ) ;}",1244
1746,int hexdump ;u_int offset ;,"int hexdump , ret ;u_int offset ;",1245
1747,"return ;}if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ;return ;}tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ;ND_PRINT ( ( ndo , ""\\\if ( tlen < sizeof ( const struct lmp_common_header ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ;return ;}if ( tlen > len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ;tlen = len ;}tptr += sizeof ( const struct lmp_common_header ) ;tlen -= sizeof ( const struct lmp_common_header ) ;while ( tlen > 0 ) {ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ;lmp_obj_header = ( const struct lmp_object_header * ) tptr ;lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ;lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ;ND_PRINT ( ( ndo , ""\\\if ( lmp_obj_len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ;return ;}if ( ( lmp_obj_len % 4 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ;return ;}obj_tptr = tptr + sizeof ( struct lmp_object_header ) ;obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ;ND_TCHECK2 ( * tptr , lmp_obj_len ) ;hexdump = FALSE ;switch ( lmp_obj_header -> class_num ) {case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_1 : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_2 : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) {case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) {case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) {case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;default : hexdump = TRUE ;}break ;case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) {case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ;","ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ;if ( ret == - 1 ) goto trunc ;if ( ret == TRUE ) hexdump = TRUE ;",1245
1748,"if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) )  hexdump = TRUE ;","if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) hexdump = TRUE ;",1245
1749,"if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) )  hexdump = TRUE ;","if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ;",1245
1750,"static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] ,  nmv_context_counts * counts ) {const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ;const MV diff = {","static void inc_mvs ( const MB_MODE_INFO * mbmi , const MB_MODE_INFO_EXT * mbmi_ext , const int_mv mvs [ 2 ] , nmv_context_counts * counts ) {const MV * ref = & mbmi_ext -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ;const MV diff = {",1246
1751,"printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ;if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ;","printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ;if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ;",1247
1752,"if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;","if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;",1247
1753,"encode_frame ( & codec , & raw , frame_count ++ , writer ) ;encode_frame ( & codec , NULL , - 1 , writer ) ;printf ( ""\\\","while ( encode_frame ( & codec , & raw , frame_count ++ , writer ) ) {printf ( ""\\\",1247
1754,"if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) {kfree_skb ( skb_out ) ;","if ( pskb_expand_head ( skb_out , 0 , size - skb_out -> len , GFP_ATOMIC ) < 0 ) {kfree_skb ( skb_out ) ;",1248
1755,"spin_lock_init ( & sta -> lock ) ;INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ;","spin_lock_init ( & sta -> lock ) ;spin_lock_init ( & sta -> ps_lock ) ;INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ;",1249
1756,if ( ftrace_event_is_function ( tp_event ) &&  perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) )  return - EPERM ;,if ( ftrace_event_is_function ( tp_event ) && perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ;,1250
1757,unregister_pernet_subsys ( & sctp_net_ops ) ;sctp_v6_protosw_exit ( ) ;sctp_v4_protosw_exit ( ) ;sctp_v6_pf_exit ( ) ;,unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ;sctp_v6_protosw_exit ( ) ;sctp_v4_protosw_exit ( ) ;unregister_pernet_subsys ( & sctp_defaults_ops ) ;sctp_v6_pf_exit ( ) ;,1251
1758,"control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;goto skip_normal_probe ;","control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;if ( ! data_interface || ! control_interface ) return - ENODEV ;goto skip_normal_probe ;",1252
1759,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;",1253
1760,"netsnmp_init_mib_internals ( ) ;netsnmp_fixup_mib_directory ( ) ;env_var = strdup ( netsnmp_get_mib_directory ( ) ) ;if ( ! env_var ) return ;netsnmp_mibindex_load ( ) ;DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBDIRS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\\\'%s\\\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>dirs<S2SV_blank>...\\\","DEBUGMSGTL ( ( ""init_mib"" , ""Seen<S2SV_blank>MIBDIRS:<S2SV_blank>Looking<S2SV_blank>in<S2SV_blank>\\\'%s\\\'<S2SV_blank>for<S2SV_blank>mib<S2SV_blank>dirs<S2SV_blank>...\\\",1254
1761,"add_mibfile ( entry , NULL , NULL ) ;entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ;","add_mibfile ( entry , NULL ) ;entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ;",1254
1762,"struct list_head tmplist ;newsk -> sk_sndbuf = oldsk -> sk_sndbuf ;if ( oldsp -> do_auto_asconf ) {memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ;inet_sk_copy_descendant ( newsk , oldsk ) ;","newsk -> sk_sndbuf = oldsk -> sk_sndbuf ;sctp_copy_descendant ( newsk , oldsk ) ;",1255
1763,"fd = open ( uinput_dev_path [ x ] , O_RDWR ) ;if ( fd < 0 ) continue ;memset ( & dev , 0 , sizeof ( dev ) ) ;if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) {BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information"" , __FUNCTION__ ) ;ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ;ioctl ( fd , UI_SET_EVBIT , EV_REL ) ;ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ;for ( x = 0 ;x ++ )  ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ;if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) {BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device"" , __FUNCTION__ ) ;","fd = TEMP_FAILURE_RETRY ( open ( uinput_dev_path [ x ] , O_RDWR ) ) ;if ( TEMP_FAILURE_RETRY ( fd < 0 ) continue ;memset ( & dev , 0 , sizeof ( dev ) ) ) ;if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) {BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information"" , __FUNCTION__ ) ;TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ) ;TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_REL ) ) ;TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ) ;for ( x = 0 ;x ++ ) TEMP_FAILURE_RETRY ( ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ) ;if ( TEMP_FAILURE_RETRY ( ioctl ( fd , UI_DEV_CREATE , NULL ) ) < 0 ) {BTIF_TRACE_ERROR ( ""%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device"" , __FUNCTION__ ) ;",1256
1764,"struct desc_struct * desc ;short sel ;desc = get_desc ( sel ) ;if ( ! desc )  return - EINVAL ;if ( ! ( desc -> type & BIT ( 3 ) ) )  return - EINVAL ;switch ( ( desc -> l << 1 ) | desc -> d ) {case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ;","struct desc_struct desc ;short sel ;if ( ! desc ) return - EINVAL ;if ( ! ( desc . type & BIT ( 3 ) ) ) return - EINVAL ;switch ( ( desc . l << 1 ) | desc . d ) {case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ;",1257
1765,i ++ )  vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ;free ( ctx -> buf ) ;,i ++ ) vpx_free_frame_buffer ( & ctx -> buf [ i ] . img ) ;free ( ctx -> buf ) ;,1258
1766,"const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ;if ( mask & 1 ) {if ( mask_16x16 & 1 ) {vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ;}vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;}vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;}","vpx_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ;}vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;}vpx_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ;}",1259
1767,atomic_dec ( & user -> inotify_devs ) ;out_free_uid : free_uid ( user ) ;,fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;out_free_uid : free_uid ( user ) ;,1260
1768,static krb5_error_code  iakerb_alloc_context ( iakerb_ctx_id_t * pctx )  {,"static krb5_error_code iakerb_alloc_context ( iakerb_ctx_id_t * pctx , int initiate ) {",1261
1769,code = krb5_gss_init_context ( & ctx -> k5c ) ;if ( code != 0 ) goto cleanup ;,ctx -> initiate = initiate ;ctx -> established = 0 ;code = krb5_gss_init_context ( & ctx -> k5c ) ;if ( code != 0 ) goto cleanup ;,1261
1770,dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {,if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}dst_known = tnum_is_const ( dst_reg -> var_off ) ;switch ( opcode ) {,1262
1771,"status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ;if ( status == MagickFalse ) {if ( image == ( Image * ) NULL )  image = screen ;else AppendImageToList ( & image , screen ) ;","if ( image == ( Image * ) NULL ) image = screen ;else AppendImageToList ( & image , screen ) ;status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ;if ( status == MagickFalse ) {",1263
1772,"while ( u4_start_code == USER_DATA_START_CODE ) {while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX )  {","while ( ( u4_start_code == USER_DATA_START_CODE ) {while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) {",1264
1773,"if ( strcmp ( dentry -> d_name . name , ""ipc_flood_count"" ) && strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) )  return - EINVAL ;if ( ! strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) flood_duration_test = true ;","if ( strcmp ( dentry -> d_name . name , ""ipc_flood_count"" ) && strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) {ret = - EINVAL ;goto out ;}if ( ! strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) flood_duration_test = true ;",1265
1774,"
","if ( ! mono_verifier_is_method_valid_generic_instantiation ( inflated ) ) mono_raise_exception ( mono_get_exception_argument ( ""typeArguments"" , ""Invalid<S2SV_blank>generic<S2SV_blank>arguments"" ) ) ;",1266
1775,"return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ;}","return mono_method_get_object ( mono_object_domain ( rmethod ) , inflated , NULL ) ;}",1266
1776,"int tmp ;if ( copy_from_user ( buf , buffer , count ) )  return - EFAULT ;","size_t size ;int tmp ;size = min ( count , sizeof ( buf ) ) ;if ( copy_from_user ( buf , buffer , size ) ) return - EFAULT ;",1267
1777,"xmlGenericError ( xmlGenericErrorContext ,  ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\\}","xmlGenericError ( xmlGenericErrorContext , ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\\}if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) {xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ;while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ;return ( - 1 ) ;}",1268
1778,"
","if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) {f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ;return 1 ;}",1269
1779,"if ( sanity_check_area_boundary ( sbi , bh ) )  return 1 ;","if ( sanity_check_area_boundary ( sbi , bh ) ) return 1 ;",1269
1780,"char * last_elem , * wp ;last_elem = wp = result ;if ( ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 )   || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) )  && ( name [ len ] == \'\\\\0\' || name [ len ] == \'/\' || ( is_path && name [ len ] == \':\' ) ) ) || ( name [ 1 ] == \'{repl = ( ( len == 7 || name [ 2 ] == \'O\' )  ? ( __libc_enable_secure ? NULL : l -> l_origin )  : _dl_platform ) ;","const char * const start = name ;char * last_elem , * wp ;last_elem = wp = result ;if ( ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( len = 7 ) != 0 ) || ( strncmp ( & name [ 1 ] , ""PLATFORM}"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == \'\\\\0\' || name [ len ] == \'/\' || ( is_path && name [ len ] == \':\' ) ) ) || ( name [ 1 ] == \'{repl = ( ( len == 7 || name [ 2 ] == \'O\' ) ? ( __libc_enable_secure && ( ( name [ len ] != \'\\\\0\' && ( ! is_path || name [ len ] != \':\' ) ) || ( name != start && ( ! is_path || name [ - 1 ] != \':\' ) ) ) ? NULL : l -> l_origin ) : _dl_platform ) ;",1270
1781,pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ;if ( pDecCont == NULL ) {,"pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) , 1 ) ;if ( pDecCont == NULL ) {",1271
1782,"static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len )  {struct ipv6_txoptions opt_space ;","static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) {struct ipv6_txoptions * opt_to_free = NULL ;struct ipv6_txoptions opt_space ;",1272
1783,"if ( ! opt )  opt = np -> opt ;if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;","if ( ! opt ) {opt = txopt_get ( np ) ;opt_to_free = opt ;}if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;",1272
1784,return err < 0 ? err : len ;do_confirm : dst_confirm ( dst ) ;,txopt_put ( opt_to_free ) ;return err < 0 ? err : len ;do_confirm : dst_confirm ( dst ) ;,1272
1785,"if ( iph -> ihl == 5 ) {memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ;return 0 ;}opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ;","memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ;if ( iph -> ihl == 5 ) return 0 ;}opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ;",1273
1786,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",1274
1787,"if ( rtm -> rtm_flags & RTM_F_FIB_MATCH )  err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid ,  nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ;else err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ;rcu_read_unlock ( ) ;err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ;","if ( rtm -> rtm_flags & RTM_F_FIB_MATCH ) {if ( ! res . fi ) {err = fib_props [ res . type ] . error ;if ( ! err ) err = - EHOSTUNREACH ;goto errout_free ;}err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ;}else {err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ;}rcu_read_unlock ( ) ;err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ;",1275
1788,"pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns ,  4 * sizeof ( * pixels ) ) ;","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ;",1276
1789,"
",int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ;if ( info -> begin > info -> end || info -> end > limit ) {goto errout ;},1277
1790,return 0 ;errout : res_clear_info ( info ) ;,return 0 ;errout : res_clear_info ( info ) ;,1277
1791,"if ( ! js_regexec ( re -> prog , text , & m , 0 ) )  js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;","if ( ! js_doregexec ( J , re -> prog , text , & m , 0 ) ) js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ;",1278
1792,"used = recv_actor ( desc , skb , offset , len ) ;if ( used < 0 ) {if ( ! copied ) copied = used ;break ;}else if ( used <= len ) {seq += used ;copied += used ;offset += used ;}skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ;if ( ! skb || ( offset + 1 != skb -> len ) ) break ;}if ( tcp_hdr ( skb ) -> fin ) {sk_eat_skb ( sk , skb , 0 ) ;++ seq ;break ;}sk_eat_skb ( sk , skb , 0 ) ;if ( ! desc -> count ) break ;}tp -> copied_seq = seq ;tcp_rcv_space_adjust ( sk ) ;if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ;","tp -> copied_seq = seq ;+ seq ;tp -> copied_seq = seq ;tcp_rcv_space_adjust ( sk ) ;if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ;",1279
1793,"krb5_key_data * key_data ;if ( n_key_data <= 0 ) return NULL ;if ( key_data_in == NULL )  goto cleanup ;i < n_key_data ;i ++ ) {if ( key_data [ i ] . key_data_ver == 1 ) {key_data [ i ] . key_data_ver = 2 ;key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ;key_data [ i ] . key_data_length [ 1 ] = 0 ;key_data [ i ] . key_data_contents [ 1 ] = NULL ;}}for ( i = 0 ;i < n_key_data - 1 ;i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;if ( ret == NULL ) {err = ENOMEM ;goto cleanup ;}for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ;i < n_key_data ;i ++ ) {krb5_data * code ;if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) {ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ;if ( ret [ j ] == NULL ) goto cleanup ;err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;if ( err ) goto cleanup ;ret [ j ] -> bv_len = code -> length ;ret [ j ] -> bv_val = code -> data ;free ( code ) ;j ++ ;last = i + 1 ;if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ;}}ret [ num_versions ] = NULL ;cleanup : free ( key_data ) ;if ( err != 0 ) {if ( ret != NULL ) {for ( i = 0 ;i <= num_versions ;i ++ )   if ( ret [ i ] != NULL )  free ( ret [ i ] ) ;",krb5_key_data * key_data = NULL ;if ( n_key_data < 0 ) return NULL ;if ( key_data == NULL ) goto cleanup ;ret [ i ] != NULL ;i ++ ) free ( ret [ i ] ) ;,1280
1794,"static int  _Unpickler_MemoPut ( UnpicklerObject * self , Py_ssize_t idx , PyObject * value )  {","static int _Unpickler_MemoPut ( UnpicklerObject * self , size_t idx , PyObject * value ) {",1281
1795,pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ;if ( pCsr -> zInput == 0 ) {,pCsr -> zInput = sqlite3_malloc64 ( nByte + 1 ) ;if ( pCsr -> zInput == 0 ) {,1282
1796,sock_release ( SOCKET_I ( inode ) ) ;return 0 ;,"__sock_release ( SOCKET_I ( inode ) , inode ) ;return 0 ;",1283
1797,"stmt_ty  AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int  lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {","stmt_ty AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",1284
1798,p -> v . AsyncFor . orelse = orelse ;p -> lineno = lineno ;,p -> v . AsyncFor . orelse = orelse ;p -> v . AsyncFor . type_comment = type_comment ;p -> lineno = lineno ;,1284
1799,"int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name )  {","int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name , my_bool no_copy_stat ) {",1285
1800,"if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) {","if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , no_copy_stat ? MYF ( MY_REDEL_NO_COPY_STAT ) : 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) {",1285
1801,"if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT ,  MYF ( 0 ) ) ||  mi_open_keyfile ( share ) ) goto err2 ;","if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT , MYF ( 0 ) ) || mi_open_keyfile ( share ) ) goto err2 ;",1285
1802,"opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ;sk_dst_reset ( sk ) ;","opt = xchg ( ( __force struct ipv6_txoptions * * ) & inet6_sk ( sk ) -> opt , opt ) ;sk_dst_reset ( sk ) ;",1286
1803,case DB_VECTOR :  dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ;,"case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ;return 1 ;case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ;",1287
1804,"default :  return ""Unknown<S2SV_blank>error<S2SV_blank>code"" ;","case NGHTTP2_ERR_TOO_MANY_SETTINGS : return ""SETTINGS<S2SV_blank>frame<S2SV_blank>contained<S2SV_blank>more<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>entries"" ;default : return ""Unknown<S2SV_blank>error<S2SV_blank>code"" ;",1288
1805,"Stream_Read_UINT16 ( s , eventId ) ;Stream_Read_UINT32 ( s , pduLength ) ;","if ( Stream_GetRemainingLength ( s ) < 6 ) return ERROR_INVALID_DATA ;Stream_Read_UINT16 ( s , eventId ) ;Stream_Read_UINT32 ( s , pduLength ) ;",1289
1806,"if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ( char * ) pData -> identity ) ;if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> sndBuf ) ;","if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ""%s"" , ( char * ) pData -> identity ) ;if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , ""%s"" , pData -> sndBuf ) ;",1290
1807,"if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) {errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ;if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) {errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ;","if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) {errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ;if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) {errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ;",1290
1808,"if ( chg < 0 )  return chg ;if ( hugepage_subpool_get_pages ( spool , chg ) )  return - ENOSPC ;ret = hugetlb_acct_memory ( h , chg ) ;if ( ret < 0 ) {hugepage_subpool_put_pages ( spool , chg ) ;return ret ;}}","if ( chg < 0 ) {ret = chg ;goto out_err ;}if ( hugepage_subpool_get_pages ( spool , chg ) ) {ret = - ENOSPC ;goto out_err ;}ret = hugetlb_acct_memory ( h , chg ) ;goto out_err ;}out_err : resv_map_put ( vma ) ;return ret ;}",1291
1809,"struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;fl6 . flowi6_proto = sk -> sk_protocol ;fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ;fl6 . saddr = transport -> saddr . v6 . sin6_addr ;fl6 . flowlabel = np -> flow_label ;IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ;if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ;else fl6 . flowi6_oif = sk -> sk_bound_dev_if ;if ( np -> opt && np -> opt -> srcrt ) {struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ;fl6 . daddr = * rt0 -> addr ;pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\\SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;}","struct flowi6 * fl6 = & transport -> fl . u . ip6 ;pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\\SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;",1292
1810,"inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;rc = PTR_ERR ( inode ) ;","s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ;rc = - EINVAL ;if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) {pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\\goto out_free ;}inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;rc = PTR_ERR ( inode ) ;",1293
1811,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;switch ( rd ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;switch ( rd ) {",1294
1812,"
","if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1295
1813,"break ;default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ;","break ;default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ;",1295
1814,"void nego_process_negotiation_failure ( rdpNego * nego , wStream * s )  {WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ;Stream_Read_UINT8 ( s , flags ) ;","BOOL nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) {WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ;if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE ;Stream_Read_UINT8 ( s , flags ) ;",1296
1815,},return TRUE ;},1296
1816,"int ret , last_pwd ;krb5_boolean have_pol = FALSE ;","int ret , last_pwd , n_new_keys ;krb5_boolean have_pol = FALSE ;",1297
1817,"if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) {if ( keepold ) return KADM5_PROTECT_PRINCIPAL ;new_n_ks_tuple = 1 ;}ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ;if ( ret ) goto done ;ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ;if ( ret ) goto done ;ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;if ( ret ) goto done ;kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ;ret = krb5_timeofday ( handle -> context , & now ) ;if ( ret ) goto done ;if ( ( adb . aux_attributes & KADM5_POLICY ) ) {ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ;if ( ret ) goto done ;}if ( have_pol ) {ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ;if ( ret ) goto done ;# if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) {ret = KADM5_PASS_TOOSOON ;goto done ;}# endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ;else kdb -> pw_expiration = 0 ;}else {kdb -> pw_expiration = 0 ;}ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ;if ( ret ) goto done ;kdb -> fail_auth_count = 0 ;if ( keyblocks ) {ret = decrypt_key_data ( handle -> context ,   kdb -> n_key_data , kdb -> key_data ,  keyblocks , n_keys ) ;","if ( krb5_principal_compare ( handle -> context , n_new_keys , kdb -> key_data ) ;ret = decrypt_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data , keyblocks , n_keys ) ;",1297
1818,"int len , result = RLC_OK ;bn_t t ;","int len , result = RLC_ERR ;bn_t t ;result = RLC_OK ;",1298
1819,break ;case RSA_DEC : m_len = k_len - 1 ;if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;}if ( pad != RSA_PUB ) {result = RLC_ERR ;},break ;case RSA_DEC : m_len = k_len - 1 ;if ( bn_is_zero ( t ) ) {result = RLC_ERR ;}if ( pad != RSA_PUB ) {result = RLC_ERR ;},1298
1820,"break ;case RSA_SIG : id = hash_id ( MD_MAP , & len ) ;","break ;case RSA_SIG : id = hash_id ( MD_MAP , & len ) ;",1298
1821,result = RLC_ERR ;if ( pad != RSA_PRV ) {result = RLC_ERR ;}while ( pad != 0 && m_len > 0 ) ;if ( m_len == 0 ) {result = RLC_ERR ;},"* p_len = k_len - m_len ;bn_mod_2b ( m , m , m_len * 8 ) ;result = ( r == 0 ? RLC_OK : RLC_ERR ) ;}break ;case RSA_SIG : id = hash_id ( MD_MAP , & len ) ;bn_zero ( m ) ;bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PRV ) ;* p_len = k_len - 3 - m_len - len ;for ( int i = 0 ;i < * p_len ;i ++ ) {bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PAD ) ;}bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , 0 ) ;bn_lsh ( m , m , 8 * len ) ;bn_read_bin ( t , id , len ) ;bn_add ( m , m , t ) ;bn_lsh ( m , m , m_len * 8 ) ;result = RLC_OK ;break ;case RSA_SIG_HASH : bn_zero ( m ) ;bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PRV ) ;* p_len = k_len - 3 - m_len ;for ( int i = 0 ;i < * p_len ;i ++ ) {bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PAD ) ;}bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , 0 ) ;bn_lsh ( m , m , m_len * 8 ) ;result = RLC_OK ;break ;case RSA_VER : m_len = k_len - 1 ;bn_rsh ( t , m , 8 * m_len ) ;if ( bn_is_zero ( t ) ) {if ( pad == RSA_PRV ) {int counter = 0 ;counter ++ ;while ( pad == RSA_PAD && m_len > 0 ) ;",1298
1822,r |= pad - id [ len - i - 1 ] ;result = ( r == 0 ? RLC_OK : RLC_ERR ) ;break ;case RSA_VER_HASH : m_len = k_len - 1 ;if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;}if ( pad != RSA_PRV ) {result = RLC_ERR ;}}while ( pad != 0 && m_len > 0 ) ;if ( m_len == 0 ) {result = RLC_ERR ;},r |= pad ^ id [ len - i - 1 ] ;if ( r && m_len > 0 && counter >= 8 ) {result = RLC_OK ;}}}break ;case RSA_VER_HASH : m_len = k_len - 1 ;if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;}if ( pad != RSA_PRV ) {int counter = 0 ;counter ++ ;}while ( pad == RSA_PAD && m_len > 0 ) ;if ( m_len > 0 && counter >= 8 ) {result = RLC_OK ;}}},1298
1823,"r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ;","r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . ss -> c_string , r2 . ss -> length ) != NULL ;",1299
1824,"r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length ,  r2 . re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) >= 0 ;","r1 . i = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL ) >= 0 ;",1299
1825,"static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",1300
1826,"rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ;if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ;","rq = hctx -> tags , off + bit ) ;if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ;",1301
1827,"if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL )  {",if ( ( psf = psf_allocate ( ) ) == NULL ) {,1302
1828,static void fix_interp_filter ( VP9_COMMON * cm ) {if ( cm -> interp_filter == SWITCHABLE ) {,"static void fix_interp_filter ( VP9_COMMON * cm , FRAME_COUNTS * counts ) {if ( cm -> interp_filter == SWITCHABLE ) {",1303
1829,++ j )  count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ;c += ( count [ i ] > 0 ) ;,+ j )  count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ;++ j ) count [ i ] += counts -> switchable_interp [ j ] [ i ] ;c += ( count [ i ] > 0 ) ;,1303
1830,token ++ ;},"token ++ ;}if ( operand >= MAX_OPERANDS ) {eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\\return false ;}",1304
1831,"MACROBLOCK * const x = & cpi -> mb ;VP9_COMMON * const cm = & cpi -> common ;x -> act_zbin_adj = 0 ;vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ;vp9_setup_pre_planes ( xd , 0 , get_ref_frame_buffer ( cpi , LAST_FRAME ) , 0 , 0 , NULL ) ;xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ;xd -> mi [ 0 ] -> mbmi . uv_mode = DC_PRED ;vpx_memset ( xd -> above_context [ 0 ] , 0 , sizeof ( * xd -> above_context [ 0 ] ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ;vpx_memset ( xd -> above_seg_context , 0 ,  sizeof ( * xd -> above_seg_context ) * aligned_mi_cols ) ;","MACROBLOCK * const x = & cpi -> td . mb ;VP9_COMMON * const cm = & cpi -> common ;vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ;vp9_setup_pre_planes ( xd , 0 , get_ref_frame_buffer ( cpi , LAST_FRAME ) , 0 , 0 , NULL ) ;memset ( xd -> above_context [ 0 ] , 0 , sizeof ( * xd -> above_context [ 0 ] ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ;vpx_memset ( xd -> above_seg_context , 0 , sizeof ( * xd -> above_seg_context ) * aligned_mi_cols ) ;",1305
1832,"dst_name = malloc ( strlen ( name ) * 2 + 16 ) ;sprintf ( dst_name , ""%s/%s"" , name , name ) ;","dst_name = safe_calloc ( strlen ( name ) * 2 + 16 ) ;sprintf ( dst_name , ""%s/%s"" , name , name ) ;",1306
1833,"retval = http_splitline ( sp -> wrk , sp -> fd , hp , htc , HTTP_HDR_REQ , HTTP_HDR_URL , HTTP_HDR_PROTO ) ;if ( retval != 0 ) {WSPR ( sp , SLT_HttpGarbage , htc -> rxbuf ) ;retval = htc_request_check_host_hdr ( hp ) ;if ( retval != 0 ) {WSP ( sp , SLT_Error , ""Duplicated<S2SV_blank>Host<S2SV_blank>header"" ) ;return ( retval ) ;return ( retval ) ;}","retval = htc_request_check_hdrs ( sp , SLT_HttpGarbage , htc -> rxbuf ) ;retval = htc_request_check_host_hdr ( hp ) ;if ( retval != 0 ) {WSP ( sp , hp ) ;return ( retval ) ;",1307
1834,# define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07  char  magick [ 12 ] ;,"# define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\\\if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( ( exception ) , ( message ) ) ;colormap = ( unsigned char * ) NULL ;pixel_info = ( MemoryInfo * ) NULL ;\\\\\char magick [ 12 ] ;",1308
1835,"if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;assert ( exception != ( ExceptionInfo * ) NULL ) ;assert ( exception -> signature == MagickSignature ) ;image = AcquireImage ( image_info ) ;status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;if ( ( count != 2 ) || ( memcmp ( magick , ""\\\\122\\\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;do {image -> page . x = ReadBlobLSBShort ( image ) ;image -> page . y = ReadBlobLSBShort ( image ) ;image -> columns = ReadBlobLSBShort ( image ) ;image -> rows = ReadBlobLSBShort ( image ) ;flags = ( MagickStatusType ) ReadBlobByte ( image ) ;image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ;number_planes = ( size_t ) ReadBlobByte ( image ) ;bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ;number_colormaps = ( size_t ) ReadBlobByte ( image ) ;map_length = ( unsigned char ) ReadBlobByte ( image ) ;if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;one = 1 ;map_length = one << map_length ;","if ( image_info -> debug != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;one = 1 ;map_length = one << map_length ;",1308
1836,"if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;",1308
1837,x ++ )  * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum (   ReadBlobLSBShort ( image ) ) ) ;},x ++ ) * p ++ = ( unsigned char ) ScaleQuantumToChar ( ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ) ;},1308
1838,"if ( EOFBlob ( image ) != MagickFalse )  {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ,  image -> filename ) ;break ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( image -> matte != MagickFalse ) number_planes ++ ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ;if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {ssize_t j ;p = pixels ;for ( i = 0 ;i < ( ssize_t ) number_pixels ;i ++ ) {if ( image -> matte == MagickFalse ) for ( j = 0 ;j < ( ssize_t ) number_planes ;j ++ ) * p ++ = background_color [ j ] ;else {for ( j = 0 ;j < ( ssize_t ) ( number_planes - 1 ) ;j ++ ) * p ++ = background_color [ j ] ;* p ++ = 0 ;}}}plane = 0 ;x = 0 ;y = 0 ;opcode = ReadBlobByte ( image ) ;do  {switch ( opcode & 0x3f ) {case SkipLinesOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x = 0 ;y += operand ;break ;}case SetColorOp : {operand = ReadBlobByte ( image ) ;plane = ( unsigned char ) operand ;if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ;x = 0 ;break ;}case SkipPixelsOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;x += operand ;break ;}case ByteDataOp : {operand = ReadBlobByte ( image ) ;if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;operand ++ ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ) ;colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;",1308
1839,if ( opcode & 0x40 )   operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x *   number_planes + plane ;if ( ( offset < 0 ) ||  ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) )  {,if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ;pixel = ( unsigned char ) ReadBlobByte ( image ) ;offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ;if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,1308
1840,}if ( number_colormaps != 0 ) {,}if ( number_colormaps != 0 ) {,1308
1841,"if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) ==  MagickFalse ) break ;","if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ;",1308
1842,"if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length +  ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ;","{if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ;",1308
1843,"
","if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}",1308
1844,"if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ;if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ;if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) ==  MagickFalse ) break ;","if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ;if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ;if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == MagickFalse ) break ;",1308
1845,"ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;( void ) ReadBlobByte ( image ) ;count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ;","ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}",1308
1846,INIT_LIST_HEAD ( & card -> controls ) ;INIT_LIST_HEAD ( & card -> ctl_files ) ;,mutex_init ( & card -> user_ctl_lock ) ;INIT_LIST_HEAD ( & card -> controls ) ;INIT_LIST_HEAD ( & card -> ctl_files ) ;,1309
1847,s += padlen + 3 ;( * psig ) = s ;return NULL ;,"( * psig ) = s + padlen + 3 ;{const u_char * p ;size_t cnt_ffs = 0 ;for ( p = s + 2 ;p < s + padlen + 2 ;p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ;if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ;}return NULL ;",1310
1848,"int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ;BTIF_TRACE_DEBUG ( ""ret:%d"" , ret ) ;","int ret = TEMP_FAILURE_RETRY ( write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ) ;BTIF_TRACE_DEBUG ( ""ret:%d"" , ret ) ;",1311
1849,ps_dec -> i1_next_ctxt_idx = 0 ;ps_dec -> u4_nmb_deblk = 0 ;if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ;if ( ps_seq -> u1_mb_aff_flag == 1 ) {,{,1312
1850,if ( ps_dec -> u1_first_slice_in_stream )  {,if ( ps_dec -> u1_first_slice_in_stream ) {,1312
1851,return ( 0 ) ;,if ( rdata -> rbuf . buf != NULL ) return ( 0 ) ;,1313
1852,OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( 0 ) ;}OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( 0 ) ;},OPENSSL_free ( rdata -> rbuf . buf ) ;OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( - 1 ) ;}if ( rdata -> rbuf . buf != NULL ) OPENSSL_free ( rdata -> rbuf . buf ) ;OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( - 1 ) ;},1313
1853,"struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;fl6 . flowi6_proto = sk -> sk_protocol ;fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ;fl6 . saddr = transport -> saddr . v6 . sin6_addr ;fl6 . flowlabel = np -> flow_label ;IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ;if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ;else fl6 . flowi6_oif = sk -> sk_bound_dev_if ;if ( np -> opt && np -> opt -> srcrt ) {struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ;fl6 . daddr = * rt0 -> addr ;pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\\SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;}","struct flowi6 * fl6 = & transport -> fl . u . ip6 ;pr_debug ( ""%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\\SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ;SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ;return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;",1314
1854,"if ( args -> buffer_count < 1 ) {DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\\","if ( args -> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ) ) {DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\\",1315
1855,"static int  mptctl_getiocinfo ( unsigned long arg , unsigned int data_size )  {MPT_ADAPTER * ioc ;struct pci_dev * pdev ;int iocnum ;","static int mptctl_getiocinfo ( MPT_ADAPTER * ioc , unsigned long arg , unsigned int data_size ) {struct pci_dev * pdev ;int iocnum ;",1316
1856,"if ( IS_ERR ( karg ) ) {printk ( KERN_ERR MYNAM ""%s@%d::mpt_ioctl_iocinfo()<S2SV_blank>-<S2SV_blank>memdup_user<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>[%ld]\\\return PTR_ERR ( karg ) ;}",if ( IS_ERR ( karg ) ;},1316
1857,"lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_unpack_full"" ) ;lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ;lua_insert ( L , 2 ) ;",1317
1858,"static inline int mount_entry_on_generic ( struct mntent * mntent ,  const char * path )  {","static inline int mount_entry_on_generic ( struct mntent * mntent , const char * path , const char * rootfs ) {",1318
1859,"ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type ,  mntflags , mntdata , optional ) ;free ( mntdata ) ;","ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , mntflags , mntdata , optional , rootfs ) ;free ( mntdata ) ;",1318
1860,"pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 *  sizeof ( * pixels ) ) ;","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 * sizeof ( * pixels ) ) ;",1319
1861,"int i , len ;size_t len_sent = 0 ;const char __user * p ;char * buf ;p = ( const char __user * ) current -> mm -> arg_start ;audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;if ( ! buf ) {audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ;for ( i = 0 ;i < context -> execve . argc ;i ++ ) {len = audit_log_single_execve_arg ( context , ab , i , & len_sent , p , buf ) ;if ( len <= 0 ) break ;p += len ;kfree ( buf ) ;","long len_max ;long len_rem ;long len_full ;long len_buf ;long len_abuf ;long len_tmp ;bool require_data ;bool encode ;unsigned int iter ;unsigned int arg ;char * buf_head ;char * buf ;const char __user * p = ( const char __user * ) current -> mm -> arg_start ;char abuf [ 96 ] ;WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ;len_max = MAX_EXECVE_AUDIT_LEN ;buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;if ( ! buf_head ) {audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ;buf = buf_head ;audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;len_rem = len_max ;len_buf = 0 ;len_full = 0 ;require_data = true ;encode = false ;iter = 0 ;arg = 0 ;do {if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ;if ( require_data ) {if ( buf != buf_head ) {memmove ( buf_head , buf , len_buf ) ;buf = buf_head ;len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ;if ( len_tmp == - EFAULT ) {send_sig ( SIGKILL , current , 0 ) ;goto out ;}else if ( len_tmp == ( len_max - len_buf ) ) {require_data = true ;encode = true ;len_full = len_full * 2 ;p += len_tmp ;}else {require_data = false ;if ( ! * ab ) goto out ;}len_tmp = 0 ;if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) {if ( iter == 0 ) {len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d_len=%lu"" , arg , len_full ) ;}len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d[%d]="" , arg , iter ++ ) ;}else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d="" , arg ) ;WARN_ON ( len_tmp >= sizeof ( abuf ) ) ;abuf [ sizeof ( abuf ) - 1 ] = \'\\\\0\' ;audit_log_format ( * ab , ""%s"" , abuf ) ;len_rem -= len_tmp ;len_tmp = len_buf ;if ( encode ) {if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ;audit_log_n_hex ( * ab , buf , len_tmp ) ;len_rem -= len_tmp * 2 ;len_abuf -= len_tmp * 2 ;}else {if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ;audit_log_n_string ( * ab , buf , len_tmp ) ;len_rem -= len_tmp + 2 ;len_abuf -= len_tmp ;}len_buf -= len_tmp ;buf += len_tmp ;}if ( ( len_buf == 0 ) && ! require_data ) {arg ++ ;iter = 0 ;len_full = 0 ;require_data = true ;encode = false ;}}while ( arg < context -> execve . argc ) ;out : kfree ( buf_head ) ;",1320
1862,"fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ;if ( fd < 0 ) return - errno ;","fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode ) ;if ( fd < 0 ) return - errno ;",1321
1863,"int pkt_len ;char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) {* err = file_error ( wth -> random_fh , err_info ) ;if ( * err == 0 ) {* err = WTAP_ERR_SHORT_READ ;}return FALSE ;}pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;if ( pkt_len == - 1 )  return FALSE ;if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ;return TRUE ;","char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;return parse_netscreen_packet ( wth -> random_fh , phdr , buf , line , cap_int , & cap_dir , cap_dst , err , err_info ) ;",1322
1864,inline void update_rq_clock ( struct rq * rq )  {if ( ! rq -> skip_clock_update ) {u64 irq_time ;rq -> clock = sched_clock_cpu ( cpu ) ;},inline void update_rq_clock ( struct rq * rq ) {u64 irq_time ;if ( rq -> skip_clock_update ) return ;rq -> clock = sched_clock_cpu ( cpu ) ;,1323
1865,"
",CheckNumberCompactPixels ;,1324
1866,}continue ;}length ++ ;for ( j = 0 ;j < ( ssize_t ) length ;j ++ ) {switch ( depth )  {case 1 : {CheckNumberPixels ( 8 ) ;* pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ;* pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ;break ;}case 2 : {CheckNumberPixels ( 4 ) ;* pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ;* pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ;* pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ;* pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ;break ;}case 4 : {CheckNumberPixels ( 2 ) ;* pixels ++ = ( * compact_pixels >> 4 ) & 0xff ;* pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ;break ;}default : {CheckNumberPixels ( 1 ) ;* pixels ++ = ( * compact_pixels ) ;break ;}}CheckNumberCompactPixels ;compact_pixels ++ ;,compact_pixels ++ ;,1324
1867,"raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;}","raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" , * argv ) ;}",1325
1868,"raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%s"" , * argv ) ;}","raw_printf ( ""Unknown<S2SV_blank>option:<S2SV_blank>%.60s"" , * argv ) ;}",1325
1869,"struct blkif_response resp ;unsigned long flags ;resp . id = id ;resp . operation = op ;resp . status = st ;case BLKIF_PROTOCOL_NATIVE :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;case BLKIF_PROTOCOL_X86_32 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;case BLKIF_PROTOCOL_X86_64 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;}blk_rings -> common . rsp_prod_pvt ++ ;","struct blkif_response * resp ;unsigned long flags ;case BLKIF_PROTOCOL_NATIVE : resp = RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ;case BLKIF_PROTOCOL_X86_32 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ;case BLKIF_PROTOCOL_X86_64 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ;}resp -> id = id ;resp -> operation = op ;resp -> status = st ;blk_rings -> common . rsp_prod_pvt ++ ;",1326
1870,if ( ! ( mask & KADM5_ATTRIBUTES ) ||  ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;,if ( password == NULL || ! ( mask & KADM5_ATTRIBUTES ) || ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;,1327
1871,"if ( ! n || ! buf || ! buf_size ) {datao = 6 + n -> offset ;if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;return ;}if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) ||  ( datao + 2 > buf_size ) ) {","if ( CHECKOVERFLOW ( datao , buf_size , 12 ) ) {if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) {",1328
1872,"if ( ! n -> entries ) {EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ;return ;}tcount = 0 ;for ( i = c , o = datao ;i ;-- i , o += 12 ) {size_t s ;if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;if ( s ) {size_t dataofs = o + 8 ;if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ;if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s >= buf_size ) ) {","if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;}n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ;if ( exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ;continue ;}n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ;if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) {",1328
1873,"
","continue ;}memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ;",1328
1874,"if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ;if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ;if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ;if ( thumbwidth < MIN_THUMB_WIDTH ) {L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\\thumbwidth = MIN_THUMB_WIDTH ;}if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ;if ( viewwidth < MIN_VIEW_WIDTH ) {L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\\viewwidth = MIN_VIEW_WIDTH ;}# ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ;ret = system ( charbuf ) ;# else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ;# endif if ( ret ) {L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\\return 1 ;}if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ;sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ;mainname = stringNew ( charbuf ) ;sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;linkname = stringNew ( charbuf ) ;","snprintf ( charbuf , sizeof ( charbuf ) , ""%s/%s.html"" , dirout , rootname ) ;mainname = stringNew ( charbuf ) ;sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;linkname = stringNew ( charbuf ) ;",1329
1875,"sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ;sarrayAddString ( sathumbs , charbuf , L_COPY ) ;","snprintf ( charbuf , sizeof ( charbuf ) , ""%s_thumb_%03d"" , rootname , index ) ;sarrayAddString ( sathumbs , charbuf , L_COPY ) ;",1329
1876,"snapend_save = ndo -> ndo_snapend ;ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ;","snapend_save = ndo -> ndo_snapend ;ND_TCHECK_16BITS ( & ip -> ip_len ) ;ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ;",1330
1877,struct dentry * dir ;struct fscrypt_info * ci ;,struct dentry * dir ;,1331
1878,ci = d_inode ( dir ) -> i_crypt_info ;if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ;dir_has_key = ( ci != NULL ) ;dput ( dir ) ;,dir_has_key = ( ci != NULL ) ;dput ( dir ) ;,1331
1879,void unbind_ports ( void ) {SERVICE_OPTIONS * opt ;CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ;opt = service_options . next ;service_options . next = NULL ;service_free ( & service_options ) ;,NOEXPORT void unbind_ports ( void ) {SERVICE_OPTIONS * opt ;for ( opt = service_options . next ;service_options . next = NULL ;service_free ( & service_options ) ;,1332
1880,"if ( opt -> ctx )  SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ;{SERVICE_OPTIONS * garbage = opt ;opt = opt -> next ;garbage -> next = NULL ;service_free ( garbage ) ;CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;}","
",1332
1881,"numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;if ( argc > MAX_PACK_ARGS ) {archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ;return ARCHIVE_WARN ;}","if ( argc >= MAX_PACK_ARGS ) {archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ;return ARCHIVE_WARN ;}numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;",1333
1882,context . Xtogo = i -> width ;context . curY = i -> posY ;,"if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\\# endif return - 1 ;}if ( ( i -> posX + i -> width ) > i -> parent -> width ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\\# endif i -> posX = i -> parent -> width - i -> width ;}if ( ( i -> posY + i -> height ) > i -> parent -> height ) {# if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\\# endif i -> posY = i -> parent -> height - i -> height ;}context . Xtogo = i -> width ;context . curY = i -> posY ;",1334
1883,"if ( n < 0 ) {if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ;syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ;goto error ;}if ( n == 0 ) {syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ;goto error ;}t = time ( NULL ) ;type = buf [ 0 ] ;p = buf + 1 ;DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ;","if ( l > ( unsigned ) ( buf + n - p ) ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ;",1335
1884,"if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) {syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ;goto error ;}break ;case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ;while ( d && ( nrep < 255 ) ) {if ( d -> t < t ) {syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ;}else {if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ;if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) {m = d -> headers [ HEADER_LOCATION ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ;rp += d -> headers [ HEADER_LOCATION ] . l ;m = d -> headers [ HEADER_NT ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ;rp += d -> headers [ HEADER_NT ] . l ;m = d -> headers [ HEADER_USN ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ;rp += d -> headers [ HEADER_USN ] . l ;nrep ++ ;}}d = d -> next ;}for ( serv = servicelisthead . lh_first ;serv && ( nrep < 255 ) ;serv = serv -> entries . le_next ) {if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ;if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) {m = strlen ( serv -> location ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> location , m ) ;rp += m ;m = strlen ( serv -> st ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> st , m ) ;rp += m ;m = strlen ( serv -> usn ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> usn , m ) ;rp += m ;nrep ++ ;}}rbuf [ 0 ] = nrep ;syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ;if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) {syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ;goto error ;}break ;case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ;if ( ! newserv ) {syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ;goto error ;}memset ( newserv , 0 , sizeof ( struct service ) ) ;if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;goto error ;}newserv -> st = malloc ( l + 1 ) ;if ( ! newserv -> st ) {syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ;goto error ;}memcpy ( newserv -> st , p , l ) ;newserv -> st [ l ] = \'\\\\0\' ;p += l ;if ( p >= buf + n ) {DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( l > ( unsigned ) ( buf + n - p ) ) {DECODELENGTH_CHECKLIMIT ( l , p , buf + n - p ) ) ;if ( p + l > buf + n - p ) ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",1335
1885,"if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",1335
1886,"if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",1335
1887,"RAnalOp next_op ;avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;","RAnalOp next_op = {0 };avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;",1336
1888,"# define ThrowDCMException ( exception , message ) {","# define ThrowDCMException ( exception , message ) \\\\\",1337
1889,"}char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;","\\\\\char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;",1337
1890,"
","if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",1337
1891,if ( tag == 0xFFFEE0DD )  break ;,if ( tag == 0xFFFEE0DD ) break ;,1337
1892,void recovery_delete_character ( void )  {if ( strlen ( mnemonic ) > 0 ) {,"void recovery_delete_character ( void ) {if ( ! recovery_started ) {recovery_abort ( ) ;fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ;layoutHome ( ) ;return ;}if ( strlen ( mnemonic ) > 0 ) {",1338
1893,"enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ;TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\return NO_ERROR ;","enc624j600WriteReg ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ;enc624j600WriteReg ( interface , ENC624J600_EHT3 , hashTable [ 0 ] ) ;enc624j600WriteReg ( interface , ENC624J600_EHT4 , hashTable [ 1 ] ) ;enc624j600WriteReg ( interface , ENC624J600_EHT1 ) ) ;TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\\\r\\\return NO_ERROR ;",1339
1894,"pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows *  sizeof ( * pixels ) ) ;","pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 257UL , image -> rows * sizeof ( * pixels ) ) ;",1340
1895,"
","memset ( newserv , 0 , sizeof ( struct service ) ) ;",1341
1896,"if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;","if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;",1341
1897,WORD32 i ;WORD32 st_rps_idx ;,"WORD32 i , j ;WORD32 st_rps_idx ;",1342
1898,for ( i = 0 ;i < num_neg_pics ;i ++ ) {,for ( j = 0 ;j < ps_codec -> i4_max_dpb_size ;j ++ ) {,1342
1899,"for ( i = 0 ;i ++ )  {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ;break ;","for ( i = 0 ;i ++ ) {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , j , BUF_MGR_REF ) ;break ;",1342
1900,"# endif case PTRACE_GET_THREAD_AREA :  ret = put_user ( task_thread_info ( child ) -> tp_value ,  datap ) ;","# endif case PTRACE_GET_THREAD_AREA : ret = put_user ( task_thread_info ( child ) -> tp_value [ 0 ] , datap ) ;",1343
1901,goto fail ;},ret = - EINVAL ;goto fail ;},1344
1902,"static char * print_object ( cJSON * item , int depth , int fmt )  {while ( child ) {++ numentries ;if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ;if ( ! ( names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) {++ depth ;while ( child ) {names [ i ] = str = print_string_ptr ( child -> string ) ;entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ;if ( str && ret ) len += strlen ( ret ) + strlen ( str ) + 2 + ( fmt ? 2 + depth : 0 ) ;else fail = 1 ;child = child -> next ;}if ( ! fail ) {out = ( char * ) cJSON_malloc ( len ) ;}if ( fail ) {for ( i = 0 ;if ( names [ i ] ) cJSON_free ( names [ i ] ) ;","static char * print_object ( cJSON * item , int depth , int fmt , printbuffer * p ) {size_t tmplen = 0 ;+ numentries ;while ( child ) numentries ++ , child = child -> next ;if ( ! numentries ) {if ( p ) out = ensure ( p , fmt ? depth + 4 : 3 ) ;else out = ( char * ) cJSON_malloc ( fmt ? depth + 4 : 3 ) ;if ( ! out ) return 0 ;ptr = out ;* ptr ++ = '{' ;if ( fmt ) {* ptr ++ = '\\\for ( i = 0 ;i < depth ;i ++ ) * ptr ++ = '\\\\t' ;}* ptr ++ = '}' ;* ptr ++ = 0 ;return out ;}if ( p ) {i = p -> offset ;len = fmt ? 2 : 1 ;ptr = ensure ( p , len + 1 ) ;if ( ! ptr ) return 0 ;* ptr ++ = '{' ;if ( fmt ) * ptr ++ = '\\\* ptr = 0 ;p -> offset += len ;child = item -> child ;depth ++ ;while ( child ) {if ( fmt ) {ptr = ensure ( p , depth ) ;if ( ! ptr ) return 0 ;for ( j = 0 ;j < depth ;j ++ ) * ptr ++ = '\\\\t' ;p -> offset += depth ;}print_string_ptr ( child -> string , 0 , p ) ;p -> offset = update ( p ) ;len = fmt ? 2 : 1 ;ptr = ensure ( p , len ) ;if ( ! ptr ) return 0 ;* ptr ++ = ':' ;if ( fmt ) * ptr ++ = '\\\\t' ;p -> offset += len ;print_value ( child , depth , fmt , 0 , p ) ;p -> offset = update ( p ) ;len = ( fmt ? 1 : 0 ) + ( child -> next ? 1 : 0 ) ;ptr = ensure ( p , len + 1 ) ;if ( ! ptr ) return 0 ;if ( child -> next ) * ptr ++ = ',' ;if ( fmt ) * ptr ++ = '\\\* ptr = 0 ;p -> offset += len ;ptr = ensure ( p , fmt ? ( depth + 1 ) : 2 ) ;if ( ! ptr ) return 0 ;if ( fmt ) for ( i = 0 ;i < depth - 1 ;i ++ ) * ptr ++ = '\\\\t' ;* ptr ++ = '}' ;* ptr = 0 ;out = ( p -> buffer ) + i ;}else {entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ;if ( ! entries ) return 0 ;names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ;if ( ! names ) {+ depth ;depth ++ ;while ( child && ! fail ) out = ( char * ) cJSON_malloc ( len ) ;}if ( fail ) {for ( i = 0 ;if ( names [ i ] ) cJSON_free ( names [ i ] ) ;",1345
1903,"if ( fmt )  * ptr ++ = '\\\for ( i = 0 ;++ i ) {if ( fmt )  for ( j = 0 ;++ j )  * ptr ++ = '\\\\t' ;strcpy ( ptr , names [ i ] ) ;ptr += strlen ( names [ i ] ) ;* ptr ++ = ':' ;if ( fmt )  * ptr ++ = '\\\\t' ;strcpy ( ptr , entries [ i ] ) ;ptr += strlen ( entries [ i ] ) ;if ( i != numentries - 1 ) * ptr ++ = ',' ;if ( fmt ) * ptr ++ = '\\\if ( fmt )  for ( i = 0 ;++ i )  * ptr ++ = '\\\\t' ;* ptr ++ = 0 ;return out ;","if ( fmt ) * ptr ++ = '\\\for ( i = 0 ;+ i ) {i ++ ) {if ( fmt ) for ( j = 0 ;+ j )  * ptr ++ = '\\\\t' ;j ++ ) * ptr ++ = '\\\\t' ;tmplen = strlen ( names [ i ] ) ;memcpy ( ptr , names [ i ] ) ;* ptr ++ = ':' ;if ( fmt ) * ptr ++ = '\\\\t' ;strcpy ( ptr , entries [ i ] , tmplen ) ;ptr += tmplen ;if ( fmt ) for ( i = 0 ;+ i )  * ptr ++ = '\\\\t' ;i ++ ) * ptr ++ = '\\\\t' ;* ptr ++ = 0 ;}return out ;",1345
1904,"struct ikev2_id id ;int id_len , idtype_len , i ;ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ;","const struct ikev2_id * idp ;struct ikev2_id id ;int id_len , idtype_len , i ;idp = ( const struct ikev2_id * ) ext ;ND_TCHECK ( * idp ) ;UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ;",1346
1905,"RD_BOOL  ber_parse_header ( STREAM s , int tagval , int * length )  {","RD_BOOL ber_parse_header ( STREAM s , int tagval , uint32 * length ) {",1347
1906,"other = unix_peer_get ( sk ) ;if ( other ) {if ( unix_peer ( other ) != sk ) {sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ;if ( unix_recvq_full ( other ) )  writable = 0 ;}sock_put ( other ) ;","if ( writable ) {unix_state_lock ( sk ) ;other = unix_peer ( sk ) ;if ( other && unix_peer ( other ) != sk && unix_recvq_full ( other ) && unix_dgram_peer_wake_me ( sk , other ) ) writable = 0 ;}sock_put ( other ) ;",1348
1907,size_t  value ;,unsigned int value ;,1349
1908,value = ( size_t ) ( buffer [ 0 ] << 24 ) ;value |= buffer [ 1 ] << 16 ;value |= buffer [ 2 ] << 8 ;value |= buffer [ 3 ] ;quantum . unsigned_value = ( value & 0xffffffff ) ;return ( quantum . signed_value ) ;,value = ( unsigned int ) buffer [ 0 ] << 24 ;value |= ( unsigned int ) buffer [ 1 ] << 16 ;value |= ( unsigned int ) buffer [ 2 ] << 8 ;value |= ( unsigned int ) buffer [ 3 ] ;quantum . unsigned_value = value & 0xffffffff ) ;return ( quantum . signed_value ) ;,1349
1909,"outpos += sprintf ( outpos , ""\\\}","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",1350
1910,"if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) {kfree_skb ( skb_out ) ;","if ( pskb_expand_head ( skb_out , 0 , size - skb_out -> len , GFP_ATOMIC ) < 0 ) {kfree_skb ( skb_out ) ;",1351
1911,void exit_io_context ( void )  {task_lock ( current ) ;ioc = current -> io_context ;current -> io_context = NULL ;task_unlock ( current ) ;if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) {,void exit_io_context ( struct task_struct * task ) {task_lock ( task ) ;ioc = current -> io_context ;task -> io_context = NULL ;task_unlock ( task ) ;if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) {,1352
1912,int ret = 0 ;# if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ;,"int ret = 0 ;if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT ;# if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ;",1353
1913,* minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ;return GSS_S_DEFECTIVE_TOKEN ;if ( header -> buffer . length < token_wrapper_len + 14 ) {* minor_status = 0 ;,* minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ;return GSS_S_DEFECTIVE_TOKEN ;if ( ctx -> seq == NULL ) {* minor_status = 0 ;return GSS_S_DEFECTIVE_TOKEN ;}if ( header -> buffer . length < token_wrapper_len + 22 ) {* minor_status = 0 ;,1354
1914,"int i ;int ret ;ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ;if ( ! pci_is_enabled ( dev ) ) return ret ;if ( dev -> resource [ i ] . flags & IORESOURCE_IO )  * value |= PCI_COMMAND_IO ;if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ;}","int ret = pci_read_config_word ( dev , offset , value , data ) ;if ( ! pci_is_enabled ( dev ) ) return ret ;if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) * value |= cmd -> val & ~ PCI_COMMAND_GUEST ;",1355
1915,"static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ;if ( frame != NULL ) {YV12_BUFFER_CONFIG * fb ;vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ;yuvconfig2image ( & frame -> img , fb , NULL ) ;","static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vp9_ref_frame_t * const frame = va_arg ( args , vp9_ref_frame_t * ) ;if ( frame != NULL ) {YV12_BUFFER_CONFIG * fb = get_ref_frame ( & ctx -> cpi -> common , frame -> idx ) ;if ( fb == NULL ) return VPX_CODEC_ERROR ;yuvconfig2image ( & frame -> img , fb , NULL ) ;",1356
1916,kfree ( fpl ) ;},free_uid ( fpl -> user ) ;kfree ( fpl ) ;},1357
1917,kiocb_batch_free ( & batch ) ;put_ioctx ( ctx ) ;,"kiocb_batch_free ( ctx , & batch ) ;put_ioctx ( ctx ) ;",1358
1918,"req -> started = false ;list_del ( & req -> list ) ;req -> remaining = 0 ;if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ;if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ;req -> trb = NULL ;trace_dwc3_gadget_giveback ( req ) ;usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ;spin_lock ( & dwc -> lock ) ;if ( dep -> number > 1 )  pm_runtime_put ( dwc -> dev ) ;","dwc3_gadget_del_and_unmap_request ( dep , req , status ) ;",1359
1919,"char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;if ( prefix != \'+\' && prefix != \'-\' && prefix != \'=\' ) {yyerror ( ""Logconfig<S2SV_blank>prefix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\\\'+\\\',<S2SV_blank>\\\'-\\\'<S2SV_blank>or<S2SV_blank>\\\'=\\\'\\\}else ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ;}case 216 : # line 1012 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;break ;case 217 : # line 1017 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;case 227 : # line 1048 ""ntp_parser.y""  {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;break ;case 228 : # line 1049 ""ntp_parser.y""  {( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ;break ;case 229 : # line 1054 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ;case 230 : # line 1056 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ;case 231 : # line 1061 ""ntp_parser.y"" {case 233 : # line 1067 ""ntp_parser.y"" {case 234 : # line 1071 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ;case 235 : # line 1072 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;case 236 : # line 1076 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ;case 237 :  # line 1077 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Address_node ) ) ;case 238 :  # line 1082 ""ntp_parser.y""  {","char prefix ;char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ) {case \'+\' : case \'-\' : case \'=\' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;default : prefix = \'=\' ;type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ;( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;case 235 : # line 1082 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;break ;case 236 : # line 1086 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;break ;case 228 : # line 1059 ""ntp_parser.y"" {( yyval . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ;case 237 : # line 1087 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ;case 231 : # line 1071 ""ntp_parser.y"" {case 233 : # line 1077 ""ntp_parser.y"" {case 234 : # line 1081 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ;case 216 : # line 1012 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;case 217 : # line 1017 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;}break ;case 227 : # line 1048 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;case 228 : # line 1049 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ;case 238 : # line 1082 ""ntp_parser.y"" {",1360
1920,"case 239 :  # line 1090 ""ntp_parser.y""  {case 240 :  # line 1091 ""ntp_parser.y""  {case 241 :  # line 1095 ""ntp_parser.y""  {case 243 :  # line 1106 ""ntp_parser.y""  {case 244 :  # line 1120 ""ntp_parser.y""  {case 245 :  # line 1124 ""ntp_parser.y""  {case 246 :  # line 1125 ""ntp_parser.y""  {case 247 :  # line 1129 ""ntp_parser.y""  {case 248 :  # line 1130 ""ntp_parser.y""  {case 249 :  # line 1134 ""ntp_parser.y""  {case 250 :  # line 1135 ""ntp_parser.y""  {case 251 :  # line 1140 ""ntp_parser.y""  {case 252 :  # line 1144 ""ntp_parser.y""  {case 253 :  # line 1148 ""ntp_parser.y""  {case 254 :  # line 1152 ""ntp_parser.y""  {case 255 :  # line 1153 ""ntp_parser.y""  {case 256 :  # line 1158 ""ntp_parser.y""  {case 257 :  # line 1162 ""ntp_parser.y""  {case 258 :  # line 1163 ""ntp_parser.y""  {case 259 :  # line 1168 ""ntp_parser.y""  {case 260 :  # line 1170 ""ntp_parser.y""  {case 261 :  # line 1172 ""ntp_parser.y""  {case 262 :  # line 1174 ""ntp_parser.y""  {case 263 :  # line 1176 ""ntp_parser.y""  {# line 3826 ""ntp_parser.c""  default : break ;","case 239 : # line 1090 ""ntp_parser.y"" {case 240 : # line 1091 ""ntp_parser.y"" {case 241 : # line 1095 ""ntp_parser.y"" {case 243 : # line 1106 ""ntp_parser.y"" {case 244 : # line 1120 ""ntp_parser.y"" {case 245 : # line 1124 ""ntp_parser.y"" {case 246 : # line 1125 ""ntp_parser.y"" {case 247 : # line 1129 ""ntp_parser.y"" {case 248 : # line 1100 ""ntp_parser.y"" {case 249 : # line 1101 ""ntp_parser.y"" {case 250 : # line 1105 ""ntp_parser.y"" {case 251 : # line 1134 ""ntp_parser.y"" {case 252 : # line 1135 ""ntp_parser.y"" {case 253 : # line 1139 ""ntp_parser.y"" {case 254 : # line 1140 ""ntp_parser.y"" {case 255 : # line 1144 ""ntp_parser.y"" {case 256 : # line 1145 ""ntp_parser.y"" {case 257 : # line 1150 ""ntp_parser.y"" {case 258 : # line 1154 ""ntp_parser.y"" {case 259 : # line 1158 ""ntp_parser.y"" {case 260 : # line 1162 ""ntp_parser.y"" {case 261 : # line 1163 ""ntp_parser.y"" {case 262 : # line 1168 ""ntp_parser.y"" {case 263 : # line 1172 ""ntp_parser.y"" {# line 3836 ""ntp_parser.c"" default : break ;",1360
1921,"[ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain ,  [ DISCE_PROBE ] = sas_probe_devices ,  [ DISCE_SUSPEND ] = sas_suspend_devices ,  [ DISCE_RESUME ] = sas_resume_devices ,  [ DISCE_DESTRUCT ] = sas_destruct_devices , }","[ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , [ DISCE_SUSPEND ] = sas_suspend_devices , [ DISCE_RESUME ] = sas_resume_devices , [ DISCE_DESTRUCT ] = sas_destruct_devices , }",1361
1922,"int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info ,  const char * name , int rep_quick )  {","int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick , my_bool no_copy_stat ) {",1362
1923,"if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {mi_check_print_error ( param , ""Can\\\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\\\'%s\\\'"" , param -> temp_filename ) ;goto err ;}if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ;if ( param -> testflag & T_UNPACK ) {share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;mi_int2store ( share -> state . header . options , share -> options ) ;}share -> state . dellink = HA_OFFSET_ERROR ;info -> rec_cache . file = new_file ;}info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;mi_drop_all_indexes ( param , info , FALSE ) ;key_map = share -> state . key_map ;if ( param -> testflag & T_CREATE_MISSING_KEYS ) {key_map = ~ key_map ;}sort_info . info = info ;sort_info . param = param ;set_data_file_type ( & sort_info , share ) ;sort_param . filepos = new_header_length ;sort_info . dupp = 0 ;sort_info . buff = 0 ;param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ;sort_param . wordlist = NULL ;init_alloc_root ( & sort_param . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ;if ( share -> data_file_type == DYNAMIC_RECORD ) length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ;else if ( share -> data_file_type == COMPRESSED_RECORD ) length = share -> base . min_block_length ;else length = share -> base . pack_reclength ;sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records : ( ha_rows ) ( sort_info . filelength / length + 1 ) ) ;sort_param . key_cmp = sort_key_cmp ;sort_param . lock_in_memory = lock_memory ;sort_param . tmpdir = param -> tmpdir ;sort_param . sort_info = & sort_info ;sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ;sort_param . master = 1 ;del = info -> state -> del ;param -> glob_crc = 0 ;if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ;rec_per_key_part = param -> rec_per_key_part ;for ( sort_param . key = 0 ;sort_param . key < share -> base . keys ;rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) {sort_param . read_cache = param -> read_cache ;sort_param . keyinfo = share -> keyinfo + sort_param . key ;sort_param . seg = sort_param . keyinfo -> seg ;if ( ! mi_is_key_active ( key_map , sort_param . key ) ) {memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;DBUG_PRINT ( ""repair"" , ( ""skipping<S2SV_blank>seemingly<S2SV_blank>disabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ;continue ;}if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\\sort_param . max_pos = sort_param . pos = share -> pack . header_length ;keyseg = sort_param . seg ;bzero ( ( char * ) sort_param . unique , sizeof ( sort_param . unique ) ) ;sort_param . key_length = share -> rec_reflength ;for ( i = 0 ;keyseg [ i ] . type != HA_KEYTYPE_END ;i ++ ) {sort_param . key_length += keyseg [ i ] . length ;if ( keyseg [ i ] . flag & HA_SPACE_PACK ) sort_param . key_length += get_pack_length ( keyseg [ i ] . length ) ;if ( keyseg [ i ] . flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param . key_length += 2 + test ( keyseg [ i ] . length >= 127 ) ;if ( keyseg [ i ] . flag & HA_NULL_PART ) sort_param . key_length ++ ;}info -> state -> records = info -> state -> del = share -> state . split = 0 ;info -> state -> empty = 0 ;if ( sort_param . keyinfo -> flag & HA_FULLTEXT ) {uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param . keyinfo -> seg -> charset -> mbmaxlen ;sort_param . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ;if ( sort_param . keyinfo -> parser == & ft_default_parser ) {sort_info . max_records = ( ha_rows ) ( sort_info . filelength / ft_min_word_len + 1 ) ;}else {sort_info . max_records = 10 * max ( param -> sort_buffer_length , MIN_SORT_BUFFER ) / sort_param . key_length ;}sort_param . key_read = sort_ft_key_read ;sort_param . key_write = sort_ft_key_write ;}else {sort_param . key_read = sort_key_read ;sort_param . key_write = sort_key_write ;}if ( _create_index_by_sort ( & sort_param , ( my_bool ) ( ! ( param -> testflag & T_VERBOSE ) ) , param -> sort_buffer_length ) ) {param -> retry_repair = 1 ;goto err ;}sort_param . calc_checksum = 0 ;free_root ( & sort_param . wordroot , MYF ( 0 ) ) ;sort_info . max_records = ( ha_rows ) info -> state -> records ;if ( param -> testflag & T_STATISTICS ) update_key_parts ( sort_param . keyinfo , rec_per_key_part , sort_param . unique , param -> stats_method == MI_STATS_METHOD_IGNORE_NULLS ? sort_param . notnull : NULL , ( ulonglong ) info -> state -> records ) ;mi_set_key_active ( share -> state . key_map , sort_param . key ) ;DBUG_PRINT ( ""repair"" , ( ""set<S2SV_blank>enabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ;if ( sort_param . fix_datafile ) {param -> read_cache . end_of_file = sort_param . filepos ;if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ;if ( param -> testflag & T_SAFE_REPAIR ) {if ( info -> state -> records + 1 < start_records ) {info -> state -> records = start_records ;goto err ;}}share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ;share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;info -> dfile = new_file ;share -> data_file_type = sort_info . new_data_file_type ;share -> pack . header_length = ( ulong ) new_header_length ;sort_param . fix_datafile = 0 ;}else info -> state -> data_file_length = sort_param . max_pos ;param -> read_cache . file = info -> dfile ;reinit_io_cache ( & param -> read_cache , READ_CACHE , share -> pack . header_length , 1 , 1 ) ;}if ( param -> testflag & T_WRITE_LOOP ) {( void ) fputs ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\\\r"" , stdout ) ;( void ) fflush ( stdout ) ;}if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {mi_check_print_error ( param , ""Couldn\\\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ;mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ;got_error = 1 ;param -> retry_repair = 1 ;param -> testflag |= T_RETRY_WITHOUT_QUICK ;goto err ;}if ( rep_quick & T_FORCE_UNIQUENESS ) {my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ;# ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ;# endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;}if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\\\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ;if ( ! ( param -> testflag & T_SILENT ) ) {if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\\if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ;}got_error = 0 ;if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;( void ) end_io_cache ( & info -> rec_cache ) ;if ( ! got_error ) {if ( new_file >= 0 ) {mysql_file_close ( new_file , MYF ( 0 ) ) ;info -> dfile = new_file = - 1 ;if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT ,  ( param -> testflag & T_BACKUP_DATA ?  MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;","if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;",1362
1924,# if uECC_VLI_NATIVE_LITTLE_ENDIAN  uECC_word_t * p = ( uECC_word_t * ) signature ;,uECC_word_t * initial_Z = 0 ;# if uECC_VLI_NATIVE_LITTLE_ENDIAN uECC_word_t * p = ( uECC_word_t * ) signature ;,1363
1925,"EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ;if ( uECC_vli_isZero ( p , num_words ) ) {","if ( g_rng_function ) {if ( ! uECC_generate_random_int ( k2 [ carry ] , initial_Z , num_n_bits + 1 , curve ) ;if ( uECC_vli_isZero ( p , num_words ) ) {",1363
1926,"dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ;bp += DAGID_LEN ;length -= DAGID_LEN ;}ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ;return ;","dagid_str = ip6addr_string ( ndo , ""%s"" , rpl_tstr ) ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ;return ;",1364
1927,"int family = sk -> sk_family ;struct sockaddr_in * sin ;struct sockaddr_in6 * sin6 ;if ( addr_len ) {if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ;else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ;}return ip_recv_error ( sk , msg , len ) ;","int family = sk -> sk_family ;struct sockaddr_in * return ip_recv_error ( sk , msg , len ) ;",1365
1928,"if ( family == AF_INET ) {sin = ( struct sockaddr_in * ) msg -> msg_name ;sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ;memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ;# if IS_ENABLED ( CONFIG_IPV6 ) }else if ( family == AF_INET6 ) {struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ;sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr ,  IP6CB ( skb ) -> iif ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;","struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ;* addr_len = sizeof ( * sin6 ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;",1365
1929,"flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |  EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ;if ( mode & FALLOC_FL_KEEP_SIZE )  flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;mutex_lock ( & inode -> i_mutex ) ;if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) {","mutex_lock ( & inode -> i_mutex ) ;if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) {",1366
1930,"if ( max_blocks > 0 ) {truncate_pagecache_range ( inode , start , end - 1 ) ;","}flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ;if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;if ( partial_begin || partial_end ) {ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ;if ( ret ) goto out_mutex ;}if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) {new_size = offset + len ;ret = inode_newsize_ok ( inode , new_size ) ;if ( ret ) goto out_mutex ;if ( max_blocks > 0 ) {flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;truncate_pagecache_range ( inode , start , end - 1 ) ;",1366
1931,}else {uint32_t new_free_total = pool -> free_total * 2 ;,}else if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) {uint32_t new_free_total = pool -> free_total * 2 ;,1367
1932,}},}else {free ( buf ) ;}},1367
1933,"bpf_map_inc ( map , true ) ;fdput ( f ) ;","map = bpf_map_inc ( map , true ) ;fdput ( f ) ;",1368
1934,"while ( * cp ) {int cval = 0 , meta = 0 ;if ( * cp == \'\\\\\\\\\' && cp [ 1 ] && index ( ""mM"" , cp [ 1 ] ) && cp [ 2 ] ) {meta = 1 ;cp += 2 ;}if ( * cp == \'\\\\\\\\\' && cp [ 1 ] && index ( ""0123456789xXoO"" , cp [ 1 ] ) && cp [ 2 ] ) {NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ;const char * dp ;int dcount = 0 ;cp ++ ;if ( * cp == \'x\' || * cp == \'X\' )   for ( ++ cp ;cp ++ )  cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ;else if ( * cp == \'o\' || * cp == \'O\' )  for ( ++ cp ;* cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ;cp ++ ) cval = ( cval * 8 ) + ( * cp - \'0\' ) ;else for ( ;* cp && ( index ( ""0123456789"" , * cp ) ) && ( dcount ++ < 3 ) ;cp ++ ) cval = ( cval * 10 ) + ( * cp - \'0\' ) ;else if ( * cp == \'\\\\\\\\\' && cp [ 1 ] ) {","static NEARDATA const char oct [ ] = ""01234567"" , dec [ ] = ""0123456789"" , hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ;const char * dp ;int dcount = 0 ;cp ++ ;if ( * cp == \'x\' || * cp == \'X\' ) for ( ++ cp ;cp ++ ) cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ;}while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ;else {",1369
1935,cp ++ ;}* tp ++ = cval ;},cp ++ ;}* tp ++ = ( char ) cval ;},1369
1936,"int file_is_y4m ( const char detect [ 4 ] ) {if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) {","static int file_is_y4m ( const char detect [ 4 ] ) {if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) {",1370
1937,"if ( size_left && size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;","if ( size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;",1371
1938,"PIX * pixc , * pixm , * pixg , * pixd ;PIXCMAP * cmap , * cmapd ;","PIX * pix1 , * pixc , * pixm , * pixg , * pixd ;PIXCMAP * cmap , * cmapd ;",1372
1939,"if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL )   return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ;cmap = pixGetColormap ( pixc ) ;","if ( ( pix1 = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ;pixc = pixConvertTo8 ( pix1 , 1 ) ;pixDestroy ( & pix1 ) ;cmap = pixGetColormap ( pixc ) ;",1372
1940,"int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) ,  top = p -> top ;",int i ;int ubits = BN_num_bits ( u ) ;int vbits = BN_num_bits ( v ) ;int top = p -> top ;,1373
1941,if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 )   break ;if ( ubits < vbits ) {,if ( ubits <= BN_BITS2 ) {if ( udp [ 0 ] == 0 ) goto err ;if ( udp [ 0 ] == 1 ) break ;}if ( ubits < vbits ) {,1373
1942,v_fn_ptr . vf = vp8_mse16x16 ;xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ;,v_fn_ptr . vf = vpx_mse16x16 ;xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ;,1374
1943,"strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ;","strncpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ;",1375
1944,int strindex = 0 ;size_t length ;,size_t strindex = 0 ;size_t length ;,1376
1945,value = 0 ;if ( bits < 0 ) {if ( msg -> oob ) {if ( bits == 8 ) {,if ( msg -> readcount > msg -> cursize ) {return 0 ;}value = 0 ;if ( bits < 0 ) {if ( msg -> oob ) {if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}if ( bits == 8 ) {,1377
1946,nbits = bits & 7 ;for ( i = 0 ;,"nbits = bits & 7 ;if ( msg -> bit , msg -> cursize << 3 + nbits > msg -> cursize << 3 ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}for ( i = 0 ;",1377
1947,"Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;value |= ( get << ( i + nbits ) ) ;}","Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;value |= ( get << ( i + nbits ) ) ;if ( msg -> bit > msg -> cursize << 3 ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}}",1377
1948,int err = - EINVAL ;if ( ! kcontrol ) return err ;,unsigned int count ;int err = - EINVAL ;if ( ! kcontrol ) return err ;,1378
1949,"up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",1378
1950,out1 :  free_netdev ( net ) ;out : return status ;,out1 : cancel_work_sync ( & dev -> kevent ) ;del_timer_sync ( & dev -> delay ) ;free_netdev ( net ) ;out : return status ;,1379
1951,"int overhead = 16 + 4 + strlen ( ns ) + 1 ;int size = overhead ;if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ;","size_t overhead = 16 + 4 + strlen ( ns ) + 1 ;size_t size = overhead ;if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ;",1380
1952,"if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK )  save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;gtk_widget_destroy ( textview ) ;","if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK ) {save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;}gtk_widget_destroy ( textview ) ;",1381
1953,last_id = ntohs ( * pid ) ;if ( last_id > 20000 ) wrap = 1 ;,if ( plen < 0 ) return 0 ;last_id = ntohs ( * pid ) ;if ( last_id > 20000 ) wrap = 1 ;,1382
1954,"retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ;}}else acl = NULL ;switch ( handler -> flags ) {case ACL_TYPE_ACCESS : if ( acl ) {umode_t mode = inode -> i_mode ;retval = posix_acl_equiv_mode ( acl , & mode ) ;if ( retval < 0 ) goto err_out ;else {struct iattr iattr ;if ( retval == 0 ) {acl = NULL ;iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ;}}","struct iattr iattr ;retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ;if ( ! acl ) {}}",1383
1955,if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) {continue ;,if ( bin -> methods [ i ] . class_id > bin -> header . types_size ) {continue ;,1384
1956,case NPPVpluginNameString : case NPPVpluginDescriptionString :  case NPPVformValue :  type = RPC_TYPE_STRING ;case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory :  type = RPC_TYPE_BOOLEAN ;break ;,case NPPVpluginNameString : case NPPVpluginDescriptionString : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId : type = RPC_TYPE_STRING ;case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ;break ;,1385
1957,int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ;char * ns = malloc ( alloc ) ;unsigned char in ;int strindex = 0 ;unsigned long hex ;CURLcode res ;if ( ! ns ) return NULL ;,char * str = NULL ;size_t inputlen = length ;size_t outputlen ;CURLcode res ;if ( ! ns ) return NULL ;,1386
1958,"res = Curl_convert_from_network ( handle , & in , 1 ) ;if ( res ) {free ( ns ) ;return NULL ;}string += 2 ;alloc -= 2 ;}ns [ strindex ++ ] = in ;string ++ ;}ns [ strindex ] = 0 ;if ( olen )  * olen = strindex ;return ns ;","res = Curl_convert_from_network ( handle , string , inputlen , & str , & outputlen , FALSE ) ;if ( res ) return NULL ;if ( olen ) * olen = curlx_uztosi ( outputlen ) ;return str ;",1386
1959,"void nego_process_negotiation_response ( rdpNego * nego , wStream * s )  {return ;}}","BOOL nego_process_negotiation_response ( rdpNego * nego , wStream * s ) {return FALSE ;}return TRUE ;}",1387
1960,"int i , target_bits_per_mb ;const double correction_factor = get_rate_correction_factor ( cpi ) ;const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i ,   correction_factor ) ;if ( bits_per_mb_at_this_q <= target_bits_per_mb ) {","int i , target_bits_per_mb , bits_per_mb_at_this_q ;const double correction_factor = get_rate_correction_factor ( cpi ) ;if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) {bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor , cm -> bit_depth ) ;}if ( bits_per_mb_at_this_q <= target_bits_per_mb ) {",1388
1961,return q ;},"if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) {q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ;}return q ;}",1388
1962,"value |= TJA1101_EXTENDED_CTRL_CONFIG_EN ;value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ;tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ;","value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT ;value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ;tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ;",1389
1963,"strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;rcipher . blocksize = alg -> cra_blocksize ;","strncpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;rcipher . blocksize = alg -> cra_blocksize ;",1390
1964,if ( len < sizeof ( * prep ) ) {return ( - 1 ) ;}n = EXTRACT_32BITS ( & prep -> pp_n ) ;,if ( len < sizeof ( * prep ) || ! ND_TTEST ( * prep ) ) return ( - 1 ) ;n = EXTRACT_32BITS ( & prep -> pp_n ) ;,1391
1965,"mark_object ( & c -> object , NULL , NULL , data ) ;}","mark_object ( & c -> object , NULL , data ) ;}",1392
1966,"freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;if ( ! freq_reg ) return - ENOMEM ;","if ( ! res ) return - EINVAL ;freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ;if ( ! freq_reg ) return - ENOMEM ;",1393
1967,if ( TYPE ( n ) == parameters ) {,if ( i < NCH ( n ) && TYPE ( n ) == parameters ) {,1394
1968,"if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;","if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",1394
1969,"static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride ,  MB_PREDICTION_MODE mode , TX_SIZE tx_size ,  int up_available , int left_available , int right_available , int x , int y , int plane ) {DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ;DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ;once ( init_intra_pred_fn_ptrs ) ;if ( plane == 0 ) {","static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , PREDICTION_MODE mode , TX_SIZE tx_size , int up_available , int left_available , int right_available , int x , int y , int plane ) {DECLARE_ALIGNED ( 16 , uint8_t , left_col [ 32 ] ) ;DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] ) ;if ( plane == 0 ) {",1395
1970,"vpx_memset ( left_col , 129 , 64 ) ;if ( left_available ) {",if ( extend_modes [ mode ] & NEED_LEFT ) {if ( left_available ) {,1395
1971,"}if ( up_available ) {if ( x0 + 2 * bs <= frame_width ) {if ( right_available && bs == 4 ) {vpx_memcpy ( above_row , above_ref , 2 * bs ) ;","memset ( left_col , 129 , bs ) ;}}if ( extend_modes [ mode ] & NEED_ABOVE ) {else {}if ( up_available ) {if ( x0 + bs <= frame_width ) {if ( right_available && bs == 4 ) {vpx_memcpy ( above_row , above_ref , 2 * bs ) ;",1395
1972,"const int r = frame_width - x0 ;if ( right_available && bs == 4 ) {vpx_memcpy ( above_row , above_ref , r ) ;vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ;}else {vpx_memcpy ( above_row , above_ref , bs ) ;vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}","memcpy ( above_row , above_ref , bs ) ;",1395
1973,"vpx_memcpy ( above_row , above_ref , bs ) ;if ( bs == 4 && right_available )  vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ;else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}}vpx_memset ( above_row , 127 , bs * 2 ) ;above_row [ - 1 ] = 127 ;}","memcpy ( above_row , above_ref , bs ) ;}}above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ;}else {memset ( above_row , 127 , bs ) ;above_row [ - 1 ] = 127 ;}}if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) {if ( up_available ) {const uint8_t * above_ref = ref - ref_stride ;if ( xd -> mb_to_right_edge < 0 ) {if ( x0 + 2 * bs <= frame_width ) {if ( right_available && bs == 4 ) {memcpy ( above_row , above_ref , 2 * bs ) ;}else {memcpy ( above_row , above_ref , bs ) ;memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}}else if ( x0 + bs <= frame_width ) {const int r = frame_width - x0 ;if ( right_available && bs == 4 ) {memcpy ( above_row , above_ref , r ) ;memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ;}else {memcpy ( above_row , above_ref , bs ) ;memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}}else if ( x0 <= frame_width ) {const int r = frame_width - x0 ;memcpy ( above_row , above_ref , r ) ;memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ;}}else {memcpy ( above_row , above_ref , bs ) ;if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ;else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ;}}memset ( above_row , 127 , bs * 2 ) ;above_row [ - 1 ] = 127 ;}}",1395
1974,end ++ ;},if ( pattern [ end ] == 0 ) break ;end ++ ;},1396
1975,"void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) {const JsVarFloat stopAtError = 0.0000001 ;if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ;else if ( ! isfinite ( val ) ) {if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ;else strncpy ( str , ""Infinity"" , len ) ;}","void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) {assert ( len > 9 ) ;const JsVarFloat stopAtError = 0.0000001 ;if ( isnan ( val ) ) strcpy ( str , ""NaN"" , len ) ;else if ( ! isfinite ( val ) ) {if ( val < 0 ) strcpy ( str , ""-Infinity"" , len ) ;else strcpy ( str , ""Infinity"" , len ) ;}",1397
1976,"jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len )  {","jas_iccprof_t * jas_iccprof_createfrombuf ( jas_uchar * buf , int len ) {",1398
1977,ei -> cur_aio_dio = NULL ;ei -> i_sync_tid = 0 ;,spin_lock_init ( & ei -> i_completed_io_lock ) ;ei -> cur_aio_dio = NULL ;ei -> i_sync_tid = 0 ;,1399
1978,"BUG_ON ( ! thresholds ) ;usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ;","BUG_ON ( ! thresholds ) ;if ( ! thresholds -> primary ) goto unlock ;usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ;",1400
1979,mutex_unlock ( & memcg -> thresholds_lock ) ;},unlock : mutex_unlock ( & memcg -> thresholds_lock ) ;},1400
1980,"static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client ,  int id ) {handle = idr_find ( & client -> idr , id ) ;if ( handle ) ion_handle_get ( handle ) ;return handle ? handle : ERR_PTR ( - EINVAL ) ;}","struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , int id ) {handle = ion_handle_get_by_id_nolock ( client , id ) ;return handle ;}",1401
1981,"static void write_uncompressed_header ( VP9_COMP * cpi ,  struct vp9_write_bit_buffer * wb ) {VP9_COMMON * const cm = & cpi -> common ;vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ;write_profile ( cm -> profile , wb ) ;vp9_wb_write_bit ( wb , 0 ) ;vp9_wb_write_bit ( wb , cm -> frame_type ) ;vp9_wb_write_bit ( wb , cm -> show_frame ) ;vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ;if ( cm -> frame_type == KEY_FRAME ) {const COLOR_SPACE cs = UNKNOWN ;write_sync_code ( wb ) ;if ( cm -> profile > PROFILE_1 ) {assert ( cm -> bit_depth > BITS_8 ) ;vp9_wb_write_bit ( wb , cm -> bit_depth - BITS_10 ) ;}vp9_wb_write_literal ( wb , cs , 3 ) ;if ( cs != SRGB ) {vp9_wb_write_bit ( wb , 0 ) ;if ( cm -> profile >= PROFILE_1 ) {vp9_wb_write_bit ( wb , cm -> subsampling_x ) ;vp9_wb_write_bit ( wb , cm -> subsampling_y ) ;vp9_wb_write_bit ( wb , 0 ) ;assert ( cm -> profile == PROFILE_1 ) ;vp9_wb_write_bit ( wb , 0 ) ;","static void write_uncompressed_header ( VP9_COMP * cpi , struct vpx_write_bit_buffer * wb ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ;vpx_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ;write_profile ( cm -> profile , wb ) ;vpx_wb_write_bit ( wb , 0 ) ;vpx_wb_write_bit ( wb , cm -> frame_type ) ;vpx_wb_write_bit ( wb , cm -> show_frame ) ;vpx_wb_write_bit ( wb , cm -> error_resilient_mode ) ;if ( cm -> frame_type == KEY_FRAME ) {write_sync_code ( wb ) ;write_bitdepth_colorspace_sampling ( cm , wb ) ;write_frame_size ( cm , wb ) ;else {if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ;if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ;if ( cm -> intra_only ) {write_sync_code ( wb ) ;if ( cm -> profile > PROFILE_0 ) {write_bitdepth_colorspace_sampling ( cm , wb ) ;}vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;write_frame_size ( cm , wb ) ;assert ( cm -> profile == PROFILE_1 ) ;vp9_wb_write_bit ( wb , 0 ) ;",1402
1982,"vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;for ( ref_frame = LAST_FRAME ;vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) ,  REF_FRAMES_LOG2 ) ;vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ;}vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ;fix_interp_filter ( cm ) ;write_interp_filter ( cm -> interp_filter , wb ) ;vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ;vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ;}vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ;encode_loopfilter ( & cm -> lf , wb ) ;encode_segmentation ( cpi , wb ) ;write_tile_info ( cm , wb ) ;","vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ;for ( ref_frame = LAST_FRAME ;assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ;vpx_wb_write_literal ( wb , get_ref_frame_map_idx ( cpi , ref_frame ) , REF_FRAMES_LOG2 ) ;vpx_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ;}vpx_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ;fix_interp_filter ( cm , cpi -> td . counts ) ;write_interp_filter ( cm -> interp_filter , wb ) ;vpx_wb_write_bit ( wb , cm -> refresh_frame_context ) ;vpx_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ;}vpx_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ;encode_loopfilter ( & cm -> lf , wb ) ;encode_segmentation ( cm , xd , wb ) ;write_tile_info ( cm , wb ) ;",1402
1983,"case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) {im -> legendposition = NORTH ;}else if ( strcmp ( optarg , ""west"" ) == 0 ) {im -> legendposition = WEST ;}else if ( strcmp ( optarg , ""south"" ) == 0 ) {im -> legendposition = SOUTH ;}else if ( strcmp ( optarg , ""east"" ) == 0 ) {im -> legendposition = EAST ;}else {rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\\\'%s\\\'"" , optarg ) ;",case 1005 : if ( bad_format_axis ( optarg ) ) {,1403
1984,"case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) {rrd_set_error ( ""--units<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>once!"" ) ;",case LONGOPT_UNITS_SI : if ( bad_format_axis ( optarg ) ) {,1403
1985,"case 1004 :  if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;case 1010 :  if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;","case 1004 : if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;case 1010 : if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;",1403
1986,"p = strchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;q = strchr ( p + 1 , \'<S2SV_blank>\' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;","p = osStrchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;q = osStrchr ( p + 1 , \'<S2SV_blank>\' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;",1404
1987,if ( kwonlyargs == NULL ) {,if ( i < NCH ( n ) && kwonlyargs == NULL ) {,1405
1988,"if ( TYPE ( CHILD ( n , i ) ) == COMMA )  i += 1 ;","if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;",1405
1989,"vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;vp8_init_mbmode_probs ( pc ) ;vp8_default_coef_probs ( pc ) ;vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ;vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ;vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ;pc -> refresh_golden_frame = 1 ;","memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;vp8_init_mbmode_probs ( pc ) ;memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ;xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ;memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ;memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ;pc -> refresh_golden_frame = 1 ;",1406
1990,"uint16_t n ;uint32_t status ;Enc624j600Context * context ;context = ( Enc624j600Context * ) interface -> nicContext ;if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT )  {enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA ,  ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ;context -> nextPacket = letoh16 ( context -> nextPacket ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ;n = letoh16 ( n ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & status , sizeof ( uint32_t ) ) ;status = letoh32 ( status ) ;if ( ( status & RSV_RECEIVED_OK ) != 0 )  {n = MIN ( n , ETH_MAX_FRAME_SIZE ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ;error = NO_ERROR ;enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;}enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ;}enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ;}nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ;}","uint16_t length ;uint32_t status ;uint8_t header [ 8 ] ;Enc624j600Context * context ;context = ( Enc624j600Context * ) interface -> nicContext ;if ( enc624j600ReadReg ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT ) {enc624j600WriteReg ( interface , ENC624J600_ERXRDPT , context -> nextPacket ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , header , sizeof ( uint16_t ) ) ;context -> nextPacket = letoh16 ( context -> nextPacket ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( header ) ) ;context -> nextPacket = LOAD16LE ( header ) ;length = LOAD16LE ( header + 2 ) ;status = LOAD32LE ( header + 4 ) ;if ( ( status & RSV_RECEIVED_OK ) != 0 ) {length = MIN ( n , ETH_MAX_FRAME_SIZE ) ;enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , length ) ;error = NO_ERROR ;enc624j600WriteReg ( interface , ENC624J600_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;}enc624j600WriteReg ( interface , ENC624J600_ERXTAIL , context -> nextPacket - 2 ) ;}enc624j600SetBit ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC ) ;}nicProcessPacket ( interface , context -> rxBuffer , length , & ancillary ) ;}",1407
1991,while ( ibuf [ ind ] == 0x01 ) {if ( ibuf [ ind + 1 ] == 0xFE ) {,while ( ibuf [ ind ] == 0x01 && i < gemsafe_cert_max ) {if ( ibuf [ ind + 1 ] == 0xFE ) {,1408
1992,"if ( vmx_set_msr ( vcpu , & msr ) != 0 ) {trace_kvm_msr_write_ex ( ecx , data ) ;","if ( kvm_set_msr ( vcpu , & msr ) != 0 ) {trace_kvm_msr_write_ex ( ecx , data ) ;",1409
1993,"static VALUE read_memory ( VALUE klass , VALUE content )  {xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt (  ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content )  ) ;VALUE rb_schema ;VALUE errors = rb_ary_new ( ) ;","static VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) {VALUE content ;VALUE parse_options ;int parse_options_int ;xmlSchemaParserCtxtPtr ctx ;VALUE errors ;VALUE rb_schema ;int scanned_args = 0 ;scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ;if ( scanned_args == 1 ) {parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ;}parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) ;ctx = xmlSchemaNewMemParserCtxt ( ( const char * ) StringValuePtr ( content ) ) ;errors = rb_ary_new ( ) ;rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;",1410
1994,return rb_schema ;},return rb_schema ;},1410
1995,"unsigned int len ;unsigned long start = 0 , off ;struct au1200fb_device * fbdev = info -> par ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {",struct au1200fb_device * fbdev = info -> par ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {,1411
1996,"return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;","return vm_iomap_memory ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;",1411
1997,"if ( ! new_service_options . next )  errstr = parse_global_option ( CMD_SET_VALUE , config_opt , config_arg ) ;if ( errstr == option_not_found ) errstr = parse_service_option ( CMD_SET_VALUE , section_ptr , config_opt , config_arg ) ;","if ( ! new_service_options . next ) errstr = parse_global_option ( CMD_SET_VALUE , & new_global_options , config_opt , config_arg ) ;if ( errstr == option_not_found ) errstr = parse_service_option ( CMD_SET_VALUE , section_ptr , config_opt , config_arg ) ;",1412
1998,out += 4 ;},out += 3 ;},1413
1999,out += 4 ;},out += 3 ;},1413
2000,"alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ;data . period = event -> hw . last_period ;if ( alpha_perf_event_set_period ( event , hwc , idx ) ) {if ( perf_event_overflow ( event , 1 , & data , regs ) ) {alpha_pmu_stop ( event , 0 ) ;","alpha_perf_event_update ( event , & data , regs ) ) {alpha_pmu_stop ( event , 0 ) ;",1414
2001,"if ( ! CDROM_CAN ( CDC_MEDIA_CHANGED ) ) return - ENOSYS ;if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ;if ( ( unsigned int ) arg >= cdi -> capacity )  return - EINVAL ;",if ( arg >= cdi -> capacity ) return - EINVAL ;,1415
2002,err = - EINVAL ;if ( ! po -> running ) goto out ;,"
",1416
2003,"goto out ;}if ( ! fanout_find_new_id ( sk , & id ) ) {err = - ENOMEM ;goto out ;}flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ;}match = NULL ;list_for_each_entry ( f , & fanout_list , list ) {if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {match = f ;break ;}}err = - EINVAL ;if ( match && match -> flags != flags ) goto out ;if ( ! match ) {err = - ENOMEM ;match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match ) goto out ;write_pnet ( & match -> net , sock_net ( sk ) ) ;match -> id = id ;match -> type = type ;",spin_lock ( & po -> bind_lock ) ;if ( po -> running && match -> type = type ;,1416
2004,if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {,if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {,1416
2005,out :  if ( err && rollover ) {,spin_unlock ( & po -> bind_lock ) ;if ( err && ! refcount_read ( & match -> sk_ref ) ) {list_del ( & match -> list ) ;kfree ( match ) ;}out : if ( err && rollover ) {,1416
2006,if ( handle -> nmi ) {handle -> event -> pending_wakeup = 1 ;}else  perf_event_wakeup ( handle -> event ) ;,handle -> event -> pending_wakeup = 1 ;,1417
2007,"int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs )  {while ( * s && len > 0 ) {if ( * s & 0x80 ) {if ( u >= PLANE_SIZE ) {u -= PLANE_SIZE ;* op ++ = ( wchar_t ) ( SURROGATE_PAIR |   ( ( u >> 10 ) & SURROGATE_BITS ) ) ;* op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW |  ( u & SURROGATE_BITS ) ) ;}else {* op ++ = ( wchar_t ) u ;}* op ++ = * s ++ ;len -- ;","int utf8s_to_utf16s ( const u8 * s , int len , enum utf16_endian endian , wchar_t * pwcs , int maxlen ) {while ( len > 0 && maxlen > 0 && * s ) {if ( * s & 0x80 ) {if ( u >= PLANE_SIZE ) {if ( maxlen < 2 ) break ;u -= PLANE_SIZE ;put_utf16 ( op ++ , SURROGATE_PAIR | ( ( u >> 10 ) & SURROGATE_BITS ) , endian ) ;put_utf16 ( op ++ , SURROGATE_PAIR | SURROGATE_LOW | ( u & SURROGATE_BITS ) , endian ) ;maxlen -= 2 ;}else {put_utf16 ( op ++ , u , endian ) ;maxlen -- ;}* op ++ = * s ++ ;len -- ;",1418
2008,"int v , i ;if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) {","int v , i ;if ( ! ( s -> state & PNG_IHDR ) ) {av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>before<S2SV_blank>IHDR\\\return AVERROR_INVALIDDATA ;}if ( s -> state & PNG_IDAT ) {av_log ( avctx , AV_LOG_ERROR , ""trns<S2SV_blank>after<S2SV_blank>IDAT\\\return AVERROR_INVALIDDATA ;}if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) {",1419
2009,if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) ||  ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) )  return AVERROR_INVALIDDATA ;,if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) || s -> bit_depth == 1 ) return AVERROR_INVALIDDATA ;,1419
2010,"print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>won\\\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ;if ( as_console ) {","print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>won\\\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ;if ( as_console ) {",1420
2011,dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ;dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ;,dt -> proto = IP_GET_IPPROTO ( p ) ;dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ;dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ;,1421
2012,"status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ;if ( ( status & RXFHSR_RXFV ) != 0 )  {if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 )  {n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ;if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) {ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ;ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ;ksz8851ReadFifo ( interface , context -> rxBuffer , n ) ;ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ;ancillary = NET_DEFAULT_RX_ANCILLARY ;ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ;return ERROR_INVALID_PACKET ;","status = ksz8851ReadReg ( interface , KSZ8851_RXFHSR ) ;if ( ( status & KSZ8851_RXFHSR_RXFV ) != 0 ) {if ( ( status & ( KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE ) ) == 0 ) {n = ksz8851ReadReg ( interface , KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC ;if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) {ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ;ksz8851SetBit ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA ) ;ksz8851ReadFifo ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA ) ;ancillary = NET_DEFAULT_RX_ANCILLARY ;ksz8851SetBit ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF ) ;return ERROR_INVALID_PACKET ;",1422
2013,"static stmt_ty  ast_for_funcdef_impl ( struct compiling * c , const node * n ,   asdl_seq * decorator_seq , int is_async )   {identifier name ;","static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , int is_async ) {const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ;identifier name ;",1423
2014,"if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns ,  type_comment , LINENO ( n ) ,  n -> n_col_offset , c -> c_arena ) ;","if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , c -> c_arena ) ;",1423
2015,"pgd = pgd_offset ( mm , 0xA0000 ) ;if ( pgd_none_or_clear_bad ( pgd ) ) goto out ;","down_write ( & mm -> mmap_sem ) ;pgd = pgd_offset ( mm , 0xA0000 ) ;if ( pgd_none_or_clear_bad ( pgd ) ) goto out ;",1424
2016,out :  flush_tlb ( ) ;},out : up_write ( & mm -> mmap_sem ) ;flush_tlb ( ) ;},1424
2017,"return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL ,  & sa , NULL ) ;","return aa_audit ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL ) ;",1425
2018,"cstate = 0 ;if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {return - 1 ;}if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth ||  ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) {return - 1 ;if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) {jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\return - 1 ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;if ( jas_stream_eof ( in ) ) {jas_free ( siz -> comps ) ;return - 1 ;}return 0 ;}","siz -> comps = 0 ;cstate = 0 ;if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {goto error ;if ( ! siz -> width || ! siz -> height ) {jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\goto error ;}if ( ! siz -> tilewidth || ! siz -> tileheight ) {jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\goto error ;}if ( ! siz -> numcomps || siz -> numcomps > 16384 ) {jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> xoff >= siz -> width ) {jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> yoff >= siz -> height ) {jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) {jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) {jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;goto error ;goto error ;goto error ;goto error ;",1426
2019,"ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ;if ( 0 != ptr_check_result ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ;dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ;if ( dst_coap_msg_ptr -> token_ptr == NULL ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>token!"" ) ;return - 1 ;}message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ;}while ( message_left && ( * * packet_data_pptr != 0xff ) ) {uint16_t option_len = ( * * packet_data_pptr & 0x0F ) ;uint16_t option_number = ( * * packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT ) ;message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ;int8_t option_parse_result ;option_number += previous_option_number ;option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ;case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) {","if ( sn_coap_parser_add_u16_limit ( option_number , previous_option_number , & option_number ) != 0 ) {option_number += previous_option_number ;option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ;case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : if ( dst_coap_msg_ptr -> options_list_ptr -> etag_ptr ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>exists!"" ) ;return - 1 ;}case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : if ( dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>exists!"" ) ;return - 1 ;}case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) {",1427
2020,"case COAP_OPTION_ETAG :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr ,  message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ;","case COAP_OPTION_ETAG : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ;",1427
2021,"case COAP_OPTION_LOCATION_QUERY :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ;case COAP_OPTION_URI_PATH :  ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left ,  & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ;","case COAP_OPTION_LOCATION_QUERY : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ;case COAP_OPTION_URI_PATH : if ( dst_coap_msg_ptr -> uri_path_ptr ) {tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>exists!"" ) ;return - 1 ;}ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ;",1427
2022,"if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) {goto _xmi_end ;","if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , xmi_size , 0 ) ) == 0 ) {goto _xmi_end ;",1428
2023,"total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) )  return 0 ;do_wakeup = 0 ;","struct iov_iter iter ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) ) return 0 ;iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) ;do_wakeup = 0 ;",1429
2024,"void * addr ;size_t chars = buf -> len ;int error , atomic ;if ( chars > total_len ) chars = total_len ;atomic = ! iov_fault_in_pages_write ( iov , chars ) ;redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ;else addr = kmap ( buf -> page ) ;error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ;if ( atomic ) kunmap_atomic ( addr ) ;else kunmap ( buf -> page ) ;if ( unlikely ( error ) ) {if ( atomic ) {atomic = 0 ;goto redo ;}if ( ! ret ) ret = error ;","size_t chars = buf -> len ;size_t written ;int error ;if ( chars > total_len ) chars = total_len ;written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ;if ( unlikely ( written < chars ) ) {if ( ! ret ) ret = - EFAULT ;",1429
2025,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) {,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) # define GIFOutputCode ( code ) \\\\\,1430
2026,}IndexPacket index ;,\\\\\IndexPacket index ;,1430
2027,"
",next_pixel = MagickFalse ;displacement = 1 ;,1430
2028,index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;p ++ ;next_pixel = MagickFalse ;displacement = 1 ;,index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;p ++ ;if ( k < 0 ) continue ;,1430
2029,passert ( GLOBALS_ARE_RESET ( ) ) ;},},1431
2030,p_fm_config_conx_hdlt hdl ;int instance = 0 ;,p_fm_config_conx_hdlt hdl = NULL ;int instance = 0 ;,1432
2031,"goto die_clean ;}goto die_clean ;}return commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;}}die_clean :  if ( hdl ) free ( hdl ) ;return res ;}","goto cleanup ;}goto cleanup ;}res = commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ;goto cleanup ;}}cleanup : if ( hdl ) {if ( hdl -> sm_hdl ) {if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ;}if ( hdl -> pm_hdl ) {if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ;}if ( hdl -> fe_hdl ) {if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ;}free ( hdl ) ;}return res ;}",1432
2032,if ( jas_init ( ) ) {abort ( ) ;infile = 0 ;verbose = 0 ;,"size_t max_samples ;char optstr [ 32 ] ;if ( jas_init ( ) ) {abort ( ) ;max_samples = 64 * JAS_MEBI ;infile = 0 ;verbose = 0 ;case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ;break ;",1433
2033,"case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ;","case OPT_MAXMEM : max_mem = strtoull ( jas_optarg , 0 , 10 ) ;",1433
2034,"
","snprintf ( optstr , sizeof ( optstr ) , ""max_samples=%-zu"" , max_samples ) ;",1433
2035,"if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {jas_stream_close ( instream ) ;if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\\","if ( ! ( image = jas_image_decode ( instream , fmtid , optstr ) ) ) {jas_stream_close ( instream ) ;if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {jas_eprintf ( ""format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\\return EXIT_FAILURE ;}if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\\",1433
2036,"if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {abort ( ) ;}printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\\jas_image_destroy ( image ) ;","printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\\jas_image_destroy ( image ) ;",1433
2037,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;if ( test_suite [ i ] . function ( ) ) {","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;if ( test_suite [ i ] . function ( ) ) {",1434
2038,if ( ( conn -> validator == NULL ) ||  cherokee_buffer_is_empty ( & conn -> validator -> user ) )  return ret_error ;,if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd ) ) return ret_error ;,1435
2039,for ( row = 0 ;row < height ;row ++ )  {,for ( row = 0 ;row < raw_height ;row ++ ) {,1436
2040,"if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width )  derror ( ) ;","if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width && row < height ) derror ( ) ;",1436
2041,if ( len < needed ) {param -> flags |= DM_BUFFER_FULL_FLAG ;,if ( len < needed || len < sizeof ( nl -> dev ) ) {param -> flags |= DM_BUFFER_FULL_FLAG ;,1437
2042,ExitLoop :  if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {,quantum_info = DestroyQuantumInfo ( quantum_info ) ;ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {,1438
2043,"int idx , ret = - EINVAL ;if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ;BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ;hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ;","int idx , ret = 0 ;if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;if ( guest_irq >= irq_rt -> nr_rt_entries ) ;hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] ) ) {pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\\goto out ;}hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ;",1439
2044,if ( bfqq )  bfq_idle_slice_timer_body ( bfqq ) ;return HRTIMER_NORESTART ;,"if ( bfqq ) bfq_idle_slice_timer_body ( bfqd , bfqq ) ;return HRTIMER_NORESTART ;",1440
2045,return rold -> umin_value == 0 &&  rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ;,return false ;,1441
2046,"BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;sa -> rc_family = AF_BLUETOOTH ;","BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;memset ( sa , 0 , sizeof ( * sa ) ) ;sa -> rc_family = AF_BLUETOOTH ;",1442
2047,if ( ! handle )  return NULL ;,if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ;,1443
2048,"length += 1 ;length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ;length += update_prepare_bounds ( context , orderInfo ) ;","length += get_primary_drawing_order_field_bytes ( orderInfo -> orderType ] ;length += update_prepare_bounds ( context , orderInfo ) ;",1444
2049,"olddentry = ovl_dentry_upper ( old ) ;newdentry = ovl_dentry_upper ( new ) ;if ( newdentry ) {newdentry = opaquedir ;opaquedir = NULL ;dget ( newdentry ) ;newdentry = lookup_one_len ( new -> d_name . name , new_upperdir ,  new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) )  goto out_unlock ;}err = - ESTALE ;if ( olddentry -> d_parent != old_upperdir )  goto out_dput ;if ( newdentry -> d_parent != new_upperdir )   goto out_dput ;if ( olddentry == trap ) goto out_dput ;if ( newdentry == trap ) goto out_dput ;","olddentry = lookup_one_len ( old -> d_name . name , new_upperdir , new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) ) goto out_unlock ;}err = - ESTALE ;if ( olddentry -> d_parent != old_upperdir ) goto out_dput ;if ( newdentry -> d_parent != new_upperdir ) goto out_dput ;if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ;newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) ) goto out_dput_old ;err = - ESTALE ;if ( ovl_dentry_upper ( new ) ) {if ( newdentry != opaquedir ) goto out_dput ;if ( newdentry != ovl_dentry_upper ( new ) ) goto out_dput ;if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ;}out_dput_old : dput ( olddentry ) ;",1445
2050,"out_unlock :  unlock_rename ( new_upperdir , old_upperdir ) ;","out_unlock : unlock_rename ( new_upperdir , old_upperdir ) ;",1445
2051,# if 0  DATA_ENSURE ( 1 ) ;p ++ ;s ++ ;# endif if ( * p != * s ++ ) goto fail ;DATA_ENSURE ( 0 ) ;,DATA_ENSURE ( 1 ) ;s ++ ;,1446
2052,"for ( plane = 0 ;plane ++ )  vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ;","for ( plane = 0 ;++ plane ) vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ;",1447
2053,"int copied , error = - EINVAL ;msg -> msg_namelen = 0 ;","int copied , error = - EINVAL ;",1448
2054,"return mount_entry_on_generic ( mntent , path ) ;}","return mount_entry_on_generic ( mntent , path , rootfs ) ;}",1449
2055,return fd ;},sr -> fd_is_fdt = MK_TRUE ;return fd ;},1450
2056,"static void construct_get_dest_keyring ( struct key * * _dest_keyring )  {kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {key_get ( dest_keyring ) ;}else {switch ( cred -> jit_keyring ) {case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) {authkey = cred -> request_key_auth ;down_read ( & authkey -> sem ) ;rka = authkey -> payload . data [ 0 ] ;if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ;up_read ( & authkey -> sem ) ;if ( dest_keyring )  break ;}","static int construct_get_dest_keyring ( struct key * * _dest_keyring ) {int ret ;kenter ( ""%p"" , dest_keyring ) ;if ( dest_keyring ) {do_perm_check = false ;break ;}}",1451
2057,}* _dest_keyring = dest_keyring ;return ;},"if ( dest_keyring && do_perm_check ) {ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ;if ( ret ) {key_put ( dest_keyring ) ;return 0 ret ;}}}* _dest_keyring = dest_keyring ;return ;}",1451
2058,"static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;if ( ! frame_is_intra_only ( cm ) ) {vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col ,  rate , dist , bsize ) ;}else {MB_PREDICTION_MODE intramode = DC_PRED ;set_mode_info ( & xd -> mi [ 0 ] -> mbmi , bsize , intramode ) ;}","static void nonrd_pick_sb_modes ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {TileInfo * const tile_info = & tile_data -> tile_info ;MB_MODE_INFO * mbmi ;set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;if ( ! frame_is_intra_only ( cm ) ) {vp9_pick_inter_mode ( cpi , tile_info , x , tile_data , mi_row , mi_col , rd_cost , bsize , ctx ) ;else vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , rd_cost , bsize , ctx ) ;if ( rd_cost -> rate == INT_MAX ) vp9_rd_cost_reset ( rd_cost ) ;ctx -> rate = rd_cost -> rate ;ctx -> dist = rd_cost -> dist ;",1452
2059,"dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;if ( csum )  dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ;if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) {","dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG ;if ( csum ) dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG ;if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) {",1453
2060,"
",reader . recursive_counter = 0 ;,1454
2061,"* err = superblockRead ( & reader , & reader . superblock ) ;if ( ! * err ) {","* err = superblockRead ( & reader , & reader . superblock ) ;if ( ! * err ) {",1454
2062,if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) )  {,"( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {",1455
2063,"int tmp ;if ( copy_from_user ( buf , buffer , count ) )  return - EFAULT ;","size_t size ;int tmp ;size = min ( count , sizeof ( buf ) ) ;if ( copy_from_user ( buf , buffer , size ) ) return - EFAULT ;",1456
2064,pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ;pMap -> ranges [ 0 ] . addr = memPtr ;,"if ( pMap -> ranges == NULL ) {LOGE ( ""malloc<S2SV_blank>failed:<S2SV_blank>%s\\\munmap ( memPtr , length ) ;return - 1 ;}pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ;pMap -> ranges [ 0 ] . addr = memPtr ;",1457
2065,"case S_IFREG : case S_IFLNK : case S_IFDIR :  switch ( dip -> di_format ) {case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ;if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ;if ( dip -> di_nextents ) return __this_address ;case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ;default : return __this_address ;}switch ( dip -> di_aformat ) {case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ;case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ;default : return __this_address ;}","case S_IFREG : case S_IFLNK : case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ;if ( fa ) return fa ;fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ;if ( fa ) return fa ;",1458
2066,"if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 )  return ret ;","if ( x >= 16 || c >= 256 ) {return AVERROR_INVALIDDATA ;}if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) return ret ;",1459
2067,jas_tvparser_destroy ( tvp ) ;if ( ! cmpt -> sampperx || ! cmpt -> samppery ) {return 0 ;error : if ( cmpt ) {,if ( ! cmpt -> sampperx || ! cmpt -> samppery ) {jas_tvparser_destroy ( tvp ) ;return 0 ;error : if ( cmpt ) {,1460
2068,"if ( ! ctx -> cfg . rc_target_bitrate ) return res ;if ( img ) res = validate_img ( ctx , img ) ;if ( ! res ) res = validate_config ( ctx , & ctx -> cfg , & ctx -> vp8_cfg , 1 ) ;pick_quickcompress_mode ( ctx , duration , deadline ) ;vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ;if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) )  || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) {ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ;return VPX_CODEC_INVALID_PARAM ;}if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) {int ref = 7 ;if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP8_LAST_FRAME ;if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP8_GOLD_FRAME ;if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP8_ALTR_FRAME ;vp8_use_as_reference ( ctx -> cpi , ref ) ;}if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) {int upd = 7 ;if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP8_LAST_FRAME ;if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP8_GOLD_FRAME ;if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP8_ALTR_FRAME ;vp8_update_reference ( ctx -> cpi , upd ) ;}if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) {vp8_update_entropy ( ctx -> cpi , 0 ) ;","if ( ! flags ) {flags = ctx -> control_frame_flags ;ctx -> control_frame_flags = 0 ;res = set_reference_and_update ( ctx , flags ) ;",1461
2069,round = ( vpx_codec_pts_t ) 1000000  * ctx -> cfg . g_timebase . num / 2 - 1 ;,round = ( vpx_codec_pts_t ) 10000000 * ctx -> cfg . g_timebase . num / 2 - 1 ;,1461
2070,"BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ;if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ;if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",1462
2071,"if ( is_sampling_event ( event ) ) {if ( ! head ) {WARN_ON_ONCE ( swhash -> online ) ;return - EINVAL ;}hlist_add_head_rcu ( & event -> hlist_entry , head ) ;","if ( WARN_ON_ONCE ( is_sampling_event ( event ) ) {if ( ! head ) ) return - EINVAL ;}hlist_add_head_rcu ( & event -> hlist_entry , head ) ;",1463
2072,"static int bgp_attr_print ( netdissect_options * ndo ,  u_int atype , const u_char * pptr , u_int len )  {","static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len , const unsigned attr_set_level ) {",1464
2073,if ( ! len ) {,"if ( attr_set_level == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ;else if ( ! len ) {",1464
2074,"if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) )  return 0 ;","if ( ! bgp_attr_print ( ndo , atype , tptr , alen , attr_set_level + 1 ) ) return 0 ;",1464
2075,"StringBuffer_append ( res -> outputbuffer , ""<h2>Monit<S2SV_blank>runtime<S2SV_blank>status</h2>"" ) ;StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\\\'status-table\\\'><tr>"" ""<th<S2SV_blank>width=\\\'40%%\\\'>Parameter</th>"" ""<th<S2SV_blank>width=\\\'60%%\\\'>Value</th></tr>"" ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Monit<S2SV_blank>ID</td><td>%s</td></tr>"" , Run . id ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Host</td><td>%s</td></tr>"" , Run . system -> name ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Process<S2SV_blank>id</td><td>%d</td></tr>"" , pid ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Effective<S2SV_blank>user<S2SV_blank>running<S2SV_blank>Monit</td>"" ""<td>%s</td></tr>"" , Run . Env . user ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Controlfile</td><td>%s</td></tr>"" , Run . files . control ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Debug</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Log</td><td>%s</td></tr>"" , ( Run . flags & Run_Log ) ? ""True"" : ""False"" ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>syslog</td><td>%s</td></tr>"" , ( Run . flags & Run_UseSyslog ) ? ""True"" : ""False"" ) ;if ( Run . eventlist_dir ) {if ( Run . eventlist_slots < 0 ) snprintf ( buf , STRLEN , ""unlimited"" ) ;else snprintf ( buf , STRLEN , ""%d"" , Run . eventlist_slots ) ;StringBuffer_append ( res -> outputbuffer , ""<tr><td>Event<S2SV_blank>queue</td>"" ""<td>base<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>slots</td></tr>"" , Run . eventlist_dir , Run . eventlist_slots ) ;","StringBuffer_append ( res -> outputbuffer , ""<td<S2SV_blank>style=\\\'color:red;\\\'>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_runtime\\\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'action\\\'<S2SV_blank>value=\\\'stop\\\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'>"" ""</form>"" ""</td>"" , res -> token ) ;StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_runtime\\\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'action\\\'<S2SV_blank>value=\\\'validate\\\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'>"" ""</form>"" ""</td>"" , res -> token ) ;StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_viewlog\\\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'>"" ""</form>"" ""</td>"" , res -> token ) ;",1465
2076,"StringBuffer_append ( res -> outputbuffer ,  ""<td<S2SV_blank>style=\\\'color:red;\\\'><form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_runtime\\\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'action\\\'<S2SV_blank>value=\\\'stop\\\'><input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'></form></td>"" ) ;StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\\\'_viewlog\\\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'></form></td>"" ) ;}","StringBuffer_append ( res -> outputbuffer , ""<td<S2SV_blank>style=\\\'color:red;\\\'><form<S2SV_blank>method=POST<S2SV_blank>action=\\\'_runtime\\\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'action\\\'<S2SV_blank>value=\\\'stop\\\'><input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'></form></td>"" ) ;StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\\\'_viewlog\\\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Go\\\'></form></td>"" ) ;}",1465
2077,"vpx_memcpy ( dest , source , dest_width ) ;}","memcpy ( dest , source , dest_width ) ;}",1466
2078,"snprintf ( constr1 , 32 , ""%lld"" , deadline ) ;confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Deadline<S2SV_blank>%s"" , ctime ( ( const time_t * ) & deadline ) ) ;","confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Deadline<S2SV_blank>%s"" , ctime ( ( const time_t * ) & deadline ) ) ;",1467
2079,assert ( n >= 0 && n < 32 ) ;v = 0 ;,if ( n < 0 || n >= 32 ) {return - 1 ;}v = 0 ;,1468
2080,"if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs ,  & len , & iovec , compat ) ;else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs ,  len , iovec ) ;if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ;","if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , & len , & iovec , compat , & iter ) ;else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , len , iovec , & iter ) ;if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ;",1469
2081,"iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ;ret = iter_op ( req , & iter ) ;ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ;","ret = iter_op ( req , & iter ) ;ret = rw_op ( req , iter . iov , iter . nr_segs , req -> ki_pos ) ;",1469
2082,if ( ! el )  return 0 ;,"if ( ! el ) {if ( c -> rbytes > 1024 ) {char * ptr = c -> rcurr ;while ( * ptr == \'<S2SV_blank>\' ) {++ ptr ;}if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) {conn_set_state ( c , conn_closing ) ;return 1 ;}}return 0 ;}",1470
2083,"err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) ,  USB_DT_OTG , ( void * * ) & desc ) ;if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ;","err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , USB_DT_OTG , ( void * * ) & desc , sizeof ( * desc ) ) ;if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ;",1471
2084,"if ( iad_num == USB_MAXIADS ) {dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\\config -> intf_assoc [ iad_num ] =  ( struct usb_interface_assoc_descriptor  * ) header ;","struct usb_interface_assoc_descriptor * d ;d = ( struct usb_interface_assoc_descriptor * ) header ;if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) {dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\\continue ;}if ( iad_num == USB_MAXIADS ) {dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\\config -> intf_assoc [ iad_num ] = d ;",1472
2085,"if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )   return - ENOMEM ;if ( info -> count < 1 ) return - EINVAL ;down_write ( & card -> controls_rwsem ) ;_kctl = snd_ctl_find_id ( card , & info -> id ) ;err = 0 ;if ( _kctl ) {if ( replace ) err = snd_ctl_remove ( card , _kctl ) ;else err = - EBUSY ;}else {if ( replace ) err = - ENOENT ;up_write ( & card -> controls_rwsem ) ;if ( err < 0 ) return err ;","if ( info -> count < 1 ) return - EINVAL ;if ( replace ) {err = snd_ctl_remove_user_ctl ( file , & info -> id ) ;if ( err ) return err ;if ( card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ;",1473
2086,"exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ;return 0 ;","exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ;return 0 ;}if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) {exit_client ( client_p , client_p , client_p , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;return 0 ;",1474
2087,"if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;","if ( ctxt -> rip_relative && likely ( ctxt -> memopp ) ) ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;",1475
2088,"int size = mmap_event -> event_id . header . size ;int ret ;perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ;ret = perf_output_begin ( & handle , event ,  mmap_event -> event_id . header . size , 0 , 0 ) ;if ( ret ) goto out ;","int size = mmap_event -> event_id . header . size , 0 ) ;if ( ret ) goto out ;",1476
2089,dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;random_ether_addr ( dev -> dev_addr ) ;,dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;random_ether_addr ( dev -> dev_addr ) ;,1477
2090,"distortion = vp8_variance16x16  ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ;","distortion = vpx_variance16x16 ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ;",1478
2091,"enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ;if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) {temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ;interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ;temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ;interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ;temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ;interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ;temp = htole16 ( interface -> macAddr . w [ 1 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ;temp = htole16 ( interface -> macAddr . w [ 2 ] ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MAADR3 , temp ) ;}enc624j600WriteReg ( interface , ENC624J600_REG_ERXST , ENC624J600_RX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ERXFCON , ERXFCON_HTEN |  ERXFCON_CRCEN | ERXFCON_RUNTEN | ERXFCON_UCEN | ERXFCON_BCEN ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 ,  MACON2_DEFER | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MAMXFL , ETH_MAX_FRAME_SIZE ) ;enc624j600WritePhyReg ( interface , ENC624J600_PHY_REG_PHANA , PHANA_ADPAUS0 |  PHANA_AD100FD | PHANA_AD100 | PHANA_AD10FD | PHANA_AD10 | PHANA_ADIEEE0 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EIR , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_EIE , EIE_INTIE |  EIE_LINKIE | EIE_PKTIE | EIE_TXIE | EIE_TXABTIE ) ;enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_RXEN ) ;enc624j600DumpReg ( interface ) ;","enc624j600WriteReg ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH ) ;if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) {temp = enc624j600ReadReg ( interface , ENC624J600_MAADR1 ) ;interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ;temp = enc624j600ReadReg ( interface , ENC624J600_MAADR2 ) ;interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ;temp = enc624j600ReadReg ( interface , ENC624J600_MAADR3 ) ;interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ;enc624j600WriteReg ( interface , ENC624J600_MAADR1 , temp ) ;temp = htole16 ( interface -> macAddr . w [ 1 ] ) ;enc624j600WriteReg ( interface , ENC624J600_MAADR2 , temp ) ;temp = htole16 ( interface -> macAddr . w [ 2 ] ) ;enc624j600WriteReg ( interface , ENC624J600_MAADR3 , temp ) ;}enc624j600WriteReg ( interface , ENC624J600_ERXST , ENC624J600_RX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ;enc624j600WriteReg ( interface , ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ;enc624j600WriteReg ( interface , ENC624J600_EHT1 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_EHT2 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_EHT3 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_EHT4 , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ;enc624j600WriteReg ( interface , ENC624J600_MAMXFL , ETH_MAX_FRAME_SIZE ) ;enc624j600WritePhyReg ( interface , ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ;enc624j600WriteReg ( interface , ENC624J600_EIR , 0x0000 ) ;enc624j600WriteReg ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE ) ;enc624j600SetBit ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_RXEN ) ;enc624j600DumpReg ( interface ) ;",1479
2092,"maxlen = strlen ( ( char * ) psf -> header ) ;start = ( ( char * ) psf -> header ) + maxlen ;maxlen = sizeof ( psf -> header ) - maxlen ;va_start ( argptr , format ) ;psf -> headindex = strlen ( ( char * ) psf -> header ) ;return ;","maxlen = psf -> header . ptr ) ;start = ( ( char * ) psf -> header . len - maxlen ;va_start ( argptr , format ) ;psf -> header . indx = strlen ( ( char * ) psf -> header . ptr ) ;return ;",1480
2093,"if ( ( e -> target_offset == sizeof ( struct arpt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> arp ) ) ||  visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",1481
2094,"if ( ! arr || ! json_is_array ( arr ) ) goto out ;merkles = json_array_size ( arr ) ;job_id = json_array_string ( val , 0 ) ;prev_hash = __json_array_string ( val , 1 ) ;coinbase1 = json_array_string ( val , 2 ) ;coinbase2 = json_array_string ( val , 3 ) ;bbversion = __json_array_string ( val , 5 ) ;nbit = __json_array_string ( val , 6 ) ;ntime = __json_array_string ( val , 7 ) ;clean = json_is_true ( json_array_get ( val , 8 ) ) ;if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) {if ( job_id )  free ( job_id ) ;",if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) {free ( job_id ) free ( job_id ) ;,1482
2095,if ( ctx -> priv -> alg_priv )   ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ;ctx -> iface = NULL ;,ctx -> iface -> destroy ( ( vpx_codec_alg_priv_t * ) ctx -> priv -> alg_priv ) ;ctx -> iface = NULL ;,1483
2096,"case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  return 1 ;case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ;","case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : return 1 ;case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ;",1484
2097,"sf -> adaptive_rd_thresh = 1 ;sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ;sf -> allow_skip_recode = 1 ;if ( speed >= 1 ) {sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ;sf -> less_rectangular_check = 1 ;sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD  : USE_LARGESTALL ;if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ;else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ;sf -> adaptive_motion_search = 1 ;sf -> auto_mv_step_size = 1 ;sf -> adaptive_rd_thresh = 2 ;sf -> subpel_iters_per_step = 1 ;sf -> mode_skip_start = 10 ;sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;}sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD  : USE_LARGESTALL ;if ( MIN ( cm -> width , cm -> height ) >= 720 )  sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ;else sf -> disable_split_mask = LAST_AND_INTRA_SPLIT_ONLY ;sf -> adaptive_pred_interp_filter = 2 ;sf -> reference_masking = 1 ;sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ;sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ;sf -> adjust_partitioning_from_last_frame = 1 ;if ( MIN ( cm -> width , cm -> height ) >= 720 )  sf -> disable_split_mask = DISABLE_ALL_SPLIT ;sf -> recode_loop = ALLOW_RECODE_KFMAXBW ;sf -> adaptive_rd_thresh = 3 ;sf -> mode_skip_start = 6 ;sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ;sf -> use_fast_coef_costing = 1 ;sf -> disable_split_mask = DISABLE_ALL_SPLIT ;sf -> adaptive_rd_thresh = 4 ;sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH |  FLAG_EARLY_TERMINATE ;sf -> disable_filter_search_var_thresh = 200 ;sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ;sf -> use_lp32x32fdct = 1 ;}sf -> partition_search_type = FIXED_PARTITION ;sf -> optimize_coefficients = 0 ;sf -> search_method = HEX ;sf -> disable_filter_search_var_thresh = 500 ;sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ;sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ;}cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ;","const int boosted = frame_is_boosted ( cpi ) ;sf -> adaptive_rd_thresh = 1 ;sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ;sf -> mv . adaptive_motion_search = 1 ;sf -> mv . auto_mv_step_size = 1 ;sf -> adaptive_rd_thresh = 2 ;sf -> subpel_iters_per_step = 1 ;sf -> mode_skip_start = 10 ;sf -> tx_size_search_breakout = 1 ;sf -> partition_search_breakout_rate_thr = 80 ;sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;}sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD : USE_LARGESTALL ;sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ;sf -> mode_search_skip_flags = ( cm -> frame_type == KEY_FRAME ) ? 0 : FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ;sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ;sf -> adjust_partitioning_from_last_frame = 1 ;if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = DISABLE_ALL_SPLIT ;sf -> allow_partition_search_skip = 1 ;sf -> disable_split_mask = DISABLE_ALL_SPLIT ;sf -> adaptive_rd_thresh = 4 ;sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ;sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ;sf -> adaptive_interp_filter_search = 1 ;}sf -> mv . search_method = BIGDIA ;sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE ;sf -> optimize_coefficients = 0 ;sf -> mv . search_method = HEX ;sf -> disable_filter_search_var_thresh = 500 ;sf -> intra_y_mode_mask [ i ] = INTRA_DC ;sf -> intra_uv_mode_mask [ i ] = INTRA_DC ;}sf -> partition_search_breakout_rate_thr = 500 ;sf -> mv . reduce_first_step_size = 1 ;sf -> simple_model_rd_from_var = 1 ;",1485
2098,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;BUG_ON ( dh == NULL ) ;","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;BUG_ON ( dh == NULL ) ;",1486
2099,"if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) )  return - EFAULT ;","memset ( txc , 0 , sizeof ( struct timex ) ) ;if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) return - EFAULT ;",1487
2100,"int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ;if ( ret == - 1 ) {","int ret = TEMP_FAILURE_RETRY ( poll ( pfds , ts [ h ] . poll_count , - 1 ) ) ;if ( ret == - 1 ) {",1488
2101,int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ;if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ;,int goodsize = inuse + BASIC_STACK_SIZE ;if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ;,1489
2102,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,1490
2103,"node * ch = CHILD ( n , 0 ) ;switch ( TYPE ( ch ) ) {case NAME : {PyObject * name = NEW_IDENTIFIER ( ch ) ;if ( ! name ) return NULL ;return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ;}case STRING : {PyObject * kind , * str = parsestrplus ( c , n ) ;const char * raw , * s = STR ( CHILD ( n , 0 ) ) ;int quote = Py_CHARMASK ( * s ) ;","node * ch = CHILD ( n , 0 ) ) ;",1491
2104,"char * s = """" ;char buf [ 128 ] ;","const char * s = """" ;char buf [ 128 ] ;",1491
2105,int is_keyframe_qaunt_set = 0 ;vpx_codec_err_t res = VPX_CODEC_OK ;,"SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;vpx_codec_err_t res = VPX_CODEC_OK ;int i , alt_ref_enabled = 0 ;",1492
2106,"if ( strcmp ( ""encoding-mode"" , option_name ) == 0 ) {res = set_option_encoding_mode ( svc_ctx , option_value ) ;}svc_ctx -> spatial_layers = atoi ( option_value ) ;else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) {res = parse_scale_factors ( svc_ctx , option_value ) ;if ( res != VPX_CODEC_OK ) break ;}else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) {res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ;if ( ! is_keyframe_qaunt_set ) {SvcInternal * const si = get_svc_internal ( svc_ctx ) ;memcpy ( get_svc_internal ( svc_ctx ) -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ;else if ( strcmp ( ""quantizers-keyframe"" , option_name ) == 0 ) {res = parse_quantizer_values ( svc_ctx , option_value , 1 ) ;is_keyframe_qaunt_set = 1 ;}","if ( strcmp ( ""spatial-layers"" , option_name ) == 0 ) {svc_ctx -> spatial_layers = atoi ( option_value ) ;}else if ( strcmp ( ""max-quantizers"" , option_name ) == 0 ) {res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL ) ;}svc_ctx -> spatial_layers = atoi ( option_value ) ;else if ( strcmp ( ""min-quantizers"" , option_name ) == 0 ) {res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL ) ;else if ( strcmp ( ""auto-alt-refs"" , option_name ) == 0 ) {res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL ) ;if ( res != VPX_CODEC_OK ) break ;else if ( strcmp ( ""bitrates"" , option_name ) == 0 ) {res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ;}else if ( strcmp ( ""multi-frame-contexts"" , option_name ) == 0 ) {si -> use_multiple_frame_contexts = atoi ( option_value ) ;}",1492
2107,return res ;},"for ( i = 0 ;i < svc_ctx -> spatial_layers ;++ i ) {if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ;}if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ;for ( i = 0 ;i < svc_ctx -> spatial_layers ;++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ;if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) {svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc:<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>ref:<S2SV_blank>Maxinum<S2SV_blank>%d(REF_FRAMES<S2SV_blank>-<S2SV_blank>layers)<S2SV_blank>layers<S2SV_blank>could"" ""enabled<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>reference<S2SV_blank>frame,<S2SV_blank>but<S2SV_blank>%<S2SV_blank>layers<S2SV_blank>are<S2SV_blank>enabled\\\res = VPX_CODEC_INVALID_PARAM ;}return res ;}",1492
2108,"if ( is_sampling_event ( event ) ) {if ( ! head ) {WARN_ON_ONCE ( swhash -> online ) ;return - EINVAL ;}hlist_add_head_rcu ( & event -> hlist_entry , head ) ;","if ( WARN_ON_ONCE ( is_sampling_event ( event ) ) {if ( ! head ) ) return - EINVAL ;}hlist_add_head_rcu ( & event -> hlist_entry , head ) ;",1493
2109,for ( s += 9 ;isspace ( * s ) ;if ( * s == \'/\' ) {while ( * t && ! isspace ( * t ) ) t ++ ;free ( font_name ) ;,for ( s += 9 ;isspace ( ( unsigned char ) * s ) ;if ( * s == \'/\' ) {while ( * t && ! isspace ( ( unsigned char ) * t ) ) t ++ ;free ( font_name ) ;,1494
2110,if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;if ( entry == ( kadm5_principal_ent_t ) NULL )  return EINVAL ;,if ( entry == NULL ) return EINVAL ;if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;,1495
2111,"for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ;","for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] && frame -> linesize [ plane ] ;int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ;",1496
2112,"for ( plane = 1 ;plane ++ )  av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ;","for ( plane = 1 ;plane ++ ) av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ;",1496
2113,"mb_index ++ ;}fprintf ( mvs , ""\\\mb_index = 0 ;","
",1497
2114,mb_index ++ ;},"
",1497
2115,"fprintf ( mvs , ""\\\mb_index = 0 ;","fprintf ( mvs , ""\\\mb_index = 0 ;",1497
2116,"mb_index = 0 ;fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\\","mb_index = 0 ;fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\\",1497
2117,Py_ssize_t i ;PyObject * new_memo = PyDict_New ( ) ;,size_t i ;PyObject * new_memo = PyDict_New ( ) ;,1498
2118,"
",if ( len > 1 ) {,1499
2119,"if ( data [ 1 ] <= 127 )  op -> jump = addr + data [ 1 ] + op -> size ;else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;","if ( data [ 1 ] <= 127 ) {op -> jump = addr + data [ 1 ] + op -> size ;}else {op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ;}}else {op -> jump = addr ;}op -> fail = addr + op -> size ;_6502_anal_esil_ccall ( op , data [ 0 ] ) ;",1499
2120,"do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) ,  mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ;","if ( imp_dbh -> pmysql ) do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ;",1500
2121,"if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) )   pthread_mutex_unlock ( & slot_lock ) ;BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ;}","if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( TEMP_FAILURE_RETRY ( ioctl ( slot -> fd , FIONREAD , & size ) ) {BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ;}}",1501
2122,"if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) {if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size )  cleanup_rfc_slot ( slot ) ;","if ( need_close || TEMP_FAILURE_RETRY ( ( flags & SOCK_THREAD_FD_EXCEPTION ) ) {if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) ) != 0 || ! size ) cleanup_rfc_slot ( slot ) ;",1501
2123,"struct ieee_802_11_phdr phdr ;col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ;","struct ieee_802_11_phdr phdr ;int wtap_encap ;struct eth_phdr eth ;void * phdrp ;col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ;",1502
2124,"next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_gps_handle , next_tvb , pinfo , ppi_tree ) ;}break ;case PPI_VECTOR_INFO : if ( ppi_vector_handle == NULL ) {proto_tree_add_item ( ppi_tree , hf_ppi_vector , tvb , offset , data_len , ENC_NA ) ;}else {next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_vector_handle , next_tvb , pinfo , ppi_tree ) ;}case PPI_SENSOR_INFO : if ( ppi_sensor_handle == NULL ) {proto_tree_add_item ( ppi_tree , hf_ppi_harris , tvb , offset , data_len , ENC_NA ) ;}else {next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_sensor_handle , next_tvb , pinfo , ppi_tree ) ;}case PPI_ANTENNA_INFO : if ( ppi_antenna_handle == NULL ) {proto_tree_add_item ( ppi_tree , hf_ppi_antenna , tvb , offset , data_len , ENC_NA ) ;}else {next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_antenna_handle , next_tvb , pinfo , ppi_tree ) ;}break ;case FNET_PRIVATE : if ( ppi_fnet_handle == NULL ) {proto_tree_add_item ( ppi_tree , hf_ppi_fnet , tvb , offset , data_len , ENC_NA ) ;}else {next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ;call_dissector ( ppi_fnet_handle , next_tvb , pinfo , ppi_tree ) ;}break ;default : proto_tree_add_item ( ppi_tree , hf_ppi_reserved , tvb , offset , data_len , ENC_NA ) ;}offset += data_len ;if ( IS_PPI_FLAG_ALIGN ( flags ) ) {offset += PADDING4 ( offset ) ;}}if ( ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE ( n_ext_flags ) ) {len_remain = tvb_captured_length_remaining ( tvb , offset ) ;# if 0 if ( DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) {pad_len = PADDING4 ( len_remain ) ;# endif pinfo -> fragmented = TRUE ;fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ;while ( fd_head ) {ampdu_len += fd_head -> len + PADDING4 ( fd_head -> len ) + 4 ;fd_head = fd_head -> next ;if ( ampdu_len > AGGREGATE_MAX ) {if ( tree ) {proto_tree_add_expert_format ( ppi_tree , pinfo , & ei_ppi_invalid_length , tvb , offset , - 1 , ""Aggregate<S2SV_blank>length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>(%u)"" , AGGREGATE_MAX ) ;THROW ( ReportedBoundsError ) ;}else {return ;}}fragment_add_seq_next ( & ampdu_reassembly_table , tvb , offset , pinfo , ampdu_id , NULL , len_remain , TRUE ) ;pinfo -> fragmented = TRUE ;fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ;if ( fd_head && tree ) {ft_fdh = fd_head ;seg_tree = proto_tree_add_subtree_format ( ppi_tree , tvb , offset , - 1 , ett_ampdu_segments , & ti , ""A-MPDU<S2SV_blank>(%u<S2SV_blank>bytes<S2SV_blank>w/hdrs):"" , ampdu_len ) ;PROTO_ITEM_SET_GENERATED ( ti ) ;while ( ft_fdh ) {if ( ft_fdh -> tvb_data && ft_fdh -> len ) {last_frame = ft_fdh -> frame ;if ( ! first_mpdu ) proto_item_append_text ( ti , "","" ) ;first_mpdu = FALSE ;proto_item_append_text ( ti , ""<S2SV_blank>#%u(%u)"" , ft_fdh -> frame , ft_fdh -> len ) ;proto_tree_add_uint_format ( seg_tree , hf_ampdu_segment , tvb , 0 , 0 , last_frame , ""Frame:<S2SV_blank>%u<S2SV_blank>(%u<S2SV_blank>byte%s)"" , last_frame , ft_fdh -> len , plurality ( ft_fdh -> len , """" , ""s"" ) ) ;}ft_fdh = ft_fdh -> next ;}if ( last_frame && last_frame != pinfo -> fd -> num ) proto_tree_add_uint ( seg_tree , hf_ampdu_reassembled_in , tvb , 0 , 0 , last_frame ) ;}if ( fd_head && ! DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) {if ( tree ) {ti = proto_tree_add_protocol_format ( tree , proto_get_id_by_filter_name ( ""wlan_aggregate"" ) , tvb , 0 , tot_len , ""IEEE<S2SV_blank>802.11<S2SV_blank>Aggregate<S2SV_blank>MPDU"" ) ;agg_tree = proto_item_add_subtree ( ti , ett_ampdu ) ;}while ( fd_head ) {if ( fd_head -> tvb_data && fd_head -> len ) {mpdu_count ++ ;mpdu_str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""MPDU<S2SV_blank>#%d"" , mpdu_count ) ;next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ;add_new_data_source ( pinfo , next_tvb , mpdu_str ) ;ampdu_tree = proto_tree_add_subtree ( agg_tree , next_tvb , 0 , - 1 , ett_ampdu_segment , NULL , mpdu_str ) ;call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , ampdu_tree , & phdr ) ;}fd_head = fd_head -> next ;}proto_tree_add_uint ( seg_tree , hf_ampdu_count , tvb , 0 , 0 , mpdu_count ) ;pinfo -> fragmented = FALSE ;}else {next_tvb = tvb_new_subset_remaining ( tvb , offset ) ;col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""IEEE<S2SV_blank>802.11n"" ) ;col_set_str ( pinfo -> cinfo , COL_INFO , ""Unreassembled<S2SV_blank>A-MPDU<S2SV_blank>data"" ) ;call_dissector ( data_handle , next_tvb , pinfo , tree ) ;}return ;}next_tvb = tvb_new_subset_remaining ( tvb , offset ) ;if ( dlt == 105 ) {call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ;}else {dissector_try_uint ( wtap_encap_dissector_table ,   wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ;}","wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ;switch ( wtap_encap ) {case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ;phdrp = & eth ;default : phdrp = NULL ;dissector_try_uint_new ( wtap_encap_dissector_table , wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree , TRUE , phdrp ) ;",1502
2125,sh = s_malloc ( hdrlen + initlen + 1 ) ;if ( sh == NULL ) return NULL ;,assert ( initlen + hdrlen + 1 > initlen ) ;sh = s_malloc ( hdrlen + initlen + 1 ) ;if ( sh == NULL ) return NULL ;,1503
2126,"static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) {","static BOOL nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) {",1504
2127,"UINT32 tempWidth ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;for ( y = 0 ;y ++ )  {","UINT32 tempWidth ;if ( ! context || data || ( scanline == 0 ) ) return FALSE ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ;if ( rw < scanline * 2 ) return FALSE ;for ( y = 0 ;y ++ ) {",1504
2128,"
",return TRUE ;,1504
2129,},},1504
2130,"while ( offset < end_offset )  offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;return offset ;}","while ( offset > 0 && offset < end_offset ) {offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;}return offset ;}",1505
2131,case '(' : if ( top - op_stack > nr_parens )  return ERR_PTR ( - EINVAL ) ;* ( ++ top ) = invert ;,case '(' : if ( top - op_stack > nr_parens ) {ret = - EINVAL ;goto out_free ;}* ( ++ top ) = invert ;,1506
2132,"const RATE_CONTROL * rc = & cpi -> rc ;int target ;target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) > INT_MAX )   ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ;}const int initial_boost = 32 ;int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ;if ( rc -> frames_since_key < cpi -> output_framerate / 2 ) {kf_boost = ( int ) ( kf_boost * rc -> frames_since_key /  ( cpi -> output_framerate / 2 ) ) ;}target = ( ( 16 + kf_boost ) * rc -> av_per_frame_bandwidth ) >> 4 ;}","const RATE_CONTROL * rc = & cpi -> rc ;const VP9EncoderConfig * oxcf = & cpi -> oxcf ;const SVC * const svc = & cpi -> svc ;int target ;target = ( ( rc -> starting_buffer_level / 2 ) > INT_MAX ) ? INT_MAX : ( int ) ( rc -> starting_buffer_level / 2 ) ;}int kf_boost = 32 ;double framerate = cpi -> framerate ;if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) {const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ;const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ;framerate = lc -> framerate ;}kf_boost = MAX ( kf_boost , ( int ) ( 2 * framerate - 16 ) ) ;if ( rc -> frames_since_key < framerate / 2 ) {kf_boost = ( int ) ( kf_boost * rc -> frames_since_key / ( framerate / 2 ) ) ;}target = ( ( 16 + kf_boost ) * rc -> avg_frame_bandwidth ) >> 4 ;}",1507
2133,update_db_bp_intercept ( vcpu ) ;},},1508
2134,"static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data )  {int ret ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 ,  indx , data , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}","static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , const void * data ) {u8 * buf ;int ret ;buf = kmemdup ( data , size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , indx , buf , size , 100 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\kfree ( buf ) ;return ret ;}",1509
2135,"static TX_MODE read_tx_mode ( vp9_reader * r ) {TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ;if ( tx_mode == ALLOW_32X32 )  tx_mode += vp9_read_bit ( r ) ;return tx_mode ;","static TX_MODE read_tx_mode ( vpx_reader * r ) {TX_MODE tx_mode = vpx_read_literal ( r , 2 ) ;if ( tx_mode == ALLOW_32X32 ) tx_mode += vpx_read_bit ( r ) ;return tx_mode ;",1510
2136,"register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ;ND_PRINT ( ( ndo , ""\\\","register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ;ND_TCHECK_32BITS ( & hellop -> hello_options ) ;ND_PRINT ( ( ndo , ""\\\",1511
2137,if ( * ( unsigned char * ) data > 1 )  return - ENOTSUPP ;,if ( datalen != 1 ) return - EINVAL ;if ( * ( unsigned char * ) data > 1 ) return - ENOTSUPP ;,1512
2138,"rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ;if ( rc -> uwbd . task == NULL )  printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;else  rc -> uwbd . pid = rc -> uwbd . task -> pid ;}","struct task_struct * task = kthread_run ( uwbd , rc , ""uwbd"" ) ;if ( IS_ERR ( task ) ) {rc -> uwbd . task = NULL ;printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;}else {rc -> uwbd . task = task ;rc -> uwbd . pid = rc -> uwbd . task -> pid ;}}",1513
2139,"case 6 :  # line 96 ""re_grammar.y""  {# line 1045 ""re_grammar.c""  break ;case 26 :  # line 97 ""re_grammar.y""  {# line 1051 ""re_grammar.c"" break ;case 27 :  # line 98 ""re_grammar.y""  {# line 1057 ""re_grammar.c"" break ;case 28 :  # line 99 ""re_grammar.y""  {# line 1063 ""re_grammar.c"" break ;case 29 :  # line 100 ""re_grammar.y""  {# line 1069 ""re_grammar.c"" break ;","case 6 : # line 104 ""re_grammar.y"" {# line 1053 ""re_grammar.c"" break ;case 26 : # line 105 ""re_grammar.y"" {# line 1059 ""re_grammar.c"" break ;case 27 : # line 106 ""re_grammar.y"" {# line 1065 ""re_grammar.c"" break ;case 28 : # line 107 ""re_grammar.y"" {# line 1071 ""re_grammar.c"" break ;case 29 : # line 108 ""re_grammar.y"" {# line 1077 ""re_grammar.c"" break ;",1514
2140,* ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ;if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) {,assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;* ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ;if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) {,1515
2141,"MACROBLOCKD * xd = args -> xd ;TOKENEXTRA * * tp = args -> tp ;struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ;struct macroblockd_plane * pd = & xd -> plane [ plane ] ;const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;const int segment_id = mbmi -> segment_id ;unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ;vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] =  cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ;unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] =  cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ;const uint8_t * const band = get_band_translate ( tx_size ) ;int aoff , loff ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ;","ThreadData * const td = args -> td ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;TOKENEXTRA * * tp = args -> tp ;struct macroblock_plane * p = & x -> plane [ plane ] ;struct macroblockd_plane * pd = & xd -> plane [ plane ] ;const tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;const int segment_id = mbmi -> segment_id ;unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ;vpx_prob ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ;vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = cpi -> common . fc -> coef_probs [ tx_size ] [ type ] [ ref ] ;unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = td -> counts -> eob_branch [ tx_size ] [ type ] [ ref ] ;const uint8_t * const band = get_band_translate ( tx_size ) ;int16_t token ;EXTRABIT extra ;int aoff , loff ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ;",1516
2142,"add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , ZERO_TOKEN , skip_eob , counts [ band [ c ] ] [ pt ] ) ;skip_eob = 1 ;token_cache [ scan [ c ] ] = 0 ;v = qcoeff [ scan [ c ] ] ;}add_token ( & t , coef_probs [ band [ c ] ] [ pt ] ,   vp9_dct_value_tokens_ptr [ v ] . extra ,   ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token ,  ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ;eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ;token_cache [ scan [ c ] ] =  vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ;++ c ;pt = get_coef_context ( nb , token_cache , c ) ;","add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , extra , ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token , ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ;token_cache [ scan [ c ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ;+ c ;",1516
2143,SrcList * pSrc = pSelect -> pSrc ;if ( pSrc == 0 ) {,SrcList * pSrc = pSelect -> pSrc ;if ( pSelect -> selFlags & SF_View ) return WRC_Prune ;if ( pSrc == 0 ) {,1517
2144,if ( addr & ( shmlba - 1 ) ) {if ( shmflg & SHM_RND )  addr &= ~ ( shmlba - 1 ) ;,if ( ( addr & ( shmlba - 1 ) ) {if ( shmflg & SHM_RND ) && addr >= shmlba ) addr &= ~ ( shmlba - 1 ) ;,1518
2145,"serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ;if ( ! serv ) {","serv = svc_create_pooled ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ;if ( ! serv ) {",1519
2146,"void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) {PointZZ_p R0 , R1 , tmp ;","void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) {if ( pointZZ_pIsIdentityElement ( point ) ) {return pointZZ_pSetToIdentityElement ( rop ) ;}PointZZ_p R0 , R1 , tmp ;",1520
2147,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,1521
2148,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",1521
2149,case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool :  case NPNVSupportsWindowless :  type = RPC_TYPE_BOOLEAN ;,case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ;,1522
2150,"ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ;close ( fd ) ;","ssize_t ret = TEMP_FAILURE_RETRY ( sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ) ;close ( fd ) ;",1523
2151,"do ret = send ( sock_fd , buf , s , 0 ) ;while ( ret < 0 && errno == EINTR ) ;","do ret = TEMP_FAILURE_RETRY ( send ( sock_fd , buf , s , 0 ) ) ;while ( ret < 0 && errno == EINTR ) ;",1524
2152,"for ( xIter = crm_first_attr ( xml ) ;const char * prop_name = ( const char * ) xIter -> name ;if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) {continue ;char * path = xml_get_path ( xml ) ;crm_trace ( ""Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s"" , crm_element_name ( xml ) , path ) ;","char * path = xml_get_path ( xml ) ;for ( xIter = crm_first_attr ( xml ) ;const char * prop_name = ( const char * ) xIter -> name ;if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 && strstr ( path , ""/"" XML_CIB_TAG_ACLS ""/"" ) == NULL ) {continue ;crm_trace ( ""Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s"" , crm_element_name ( xml ) , path ) ;",1525
2153,}while ( cIter != NULL ) {,free ( path ) ;}while ( cIter != NULL ) {,1525
2154,"if ( ! dirout ) return ERROR_INT ( ""dirout<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ;if ( ! rootname ) return ERROR_INT ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , 1 ) ;if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ;if ( thumbwidth < MIN_THUMB_WIDTH ) {L_WARNING ( ""thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\\thumbwidth = MIN_THUMB_WIDTH ;}if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ;if ( viewwidth < MIN_VIEW_WIDTH ) {L_WARNING ( ""viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\\viewwidth = MIN_VIEW_WIDTH ;}# ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir<S2SV_blank>-p<S2SV_blank>%s"" , dirout ) ;ret = system ( charbuf ) ;# else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ;# endif if ( ret ) {L_ERROR ( ""output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\\return 1 ;}if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( ""safiles<S2SV_blank>not<S2SV_blank>made"" , procName , 1 ) ;sprintf ( charbuf , ""%s/%s.html"" , dirout , rootname ) ;mainname = stringNew ( charbuf ) ;sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;linkname = stringNew ( charbuf ) ;","snprintf ( charbuf , sizeof ( charbuf ) , ""%s/%s.html"" , dirout , rootname ) ;mainname = stringNew ( charbuf ) ;sprintf ( charbuf , ""%s/%s-links.html"" , dirout , rootname ) ;linkname = stringNew ( charbuf ) ;",1526
2155,"sprintf ( charbuf , ""%s_thumb_%03d"" , rootname , index ) ;sarrayAddString ( sathumbs , charbuf , L_COPY ) ;","snprintf ( charbuf , sizeof ( charbuf ) , ""%s_thumb_%03d"" , rootname , index ) ;sarrayAddString ( sathumbs , charbuf , L_COPY ) ;",1526
2156,static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {if ( svc_ctx == NULL ) return NULL ;return ( const SvcInternal * ) svc_ctx -> internal ;},static const SvcInternal_t * get_const_svc_internal ( const SvcContext * svc_ctx ) {if ( svc_ctx == NULL ) return NULL ;return ( const SvcInternal_t * ) svc_ctx -> internal ;},1527
2157,"spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;flush_rq -> tag = - 1 ;","struct blk_mq_hw_ctx * hctx ;spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ;hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ;blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq ) ;flush_rq -> tag = - 1 ;",1528
2158,"int length ;ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;in_uint8s ( s , length ) ;","uint32 length ;struct stream packet = * s ;ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , length ) ;",1529
2159,"if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) {if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {","if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) {if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {",1530
2160,char buffer [ 80 ] ;int ret ;,char buffer [ 80 ] = {0 };int ret ;,1531
2161,"_y4m -> vpx_bps = 12 ;if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 ||  strcmp ( _y4m -> chroma_type , ""420jpeg"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;}else if ( strcmp ( _y4m -> chroma_type , ""420mpeg2"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;_y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ;else if ( strcmp ( _y4m -> chroma_type , ""420paldv"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;_y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;_y4m -> convert = y4m_convert_42xpaldv_42xjpeg ;}else if ( strcmp ( _y4m -> chroma_type , ""422jpeg"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ;_y4m -> src_c_dec_v = 1 ;_y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;_y4m -> convert = y4m_convert_422jpeg_420jpeg ;else if ( strcmp ( _y4m -> chroma_type , ""422"" ) == 0 ) {_y4m -> dst_c_dec_h = 2 ;_y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;_y4m -> convert = y4m_convert_422_420jpeg ;else {_y4m -> vpx_fmt = VPX_IMG_FMT_I422 ;_y4m -> vpx_bps = 16 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;_y4m -> convert = y4m_convert_null ;}","_y4m -> bps = 12 ;_y4m -> bit_depth = 8 ;if ( strcmp ( _y4m -> chroma_type , ""420p10"" ) == 0 ) {_y4m -> src_c_dec_h = 2 ;_y4m -> bps = 16 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;else if ( strcmp ( _y4m -> chroma_type , ""422p10"" ) == 0 ) {_y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ;_y4m -> bps = 20 ;_y4m -> bit_depth = 10 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;_y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;_y4m -> convert = y4m_convert_null ;fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p10<S2SV_blank>to<S2SV_blank>420jpeg\\\return - 1 ;}else if ( strcmp ( _y4m -> chroma_type , ""422p12"" ) == 0 ) {_y4m -> src_c_dec_h = 2 ;_y4m -> src_c_dec_v = 1 ;_y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ;_y4m -> bps = 24 ;_y4m -> bit_depth = 12 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ;_y4m -> convert = y4m_convert_null ;if ( only_420 ) {fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p12<S2SV_blank>to<S2SV_blank>420jpeg\\\return - 1 ;}",1531
2162,_y4m -> vpx_bps = 24 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;}_y4m -> src_c_dec_h = 1 ;if ( only_420 ) {_y4m -> dst_c_dec_h = 2 ;_y4m -> dst_c_dec_v = 2 ;,_y4m -> vpx_bps = 24 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;}_y4m -> src_c_dec_h = 1 ;if ( only_420 ) {_y4m -> dst_c_dec_h = 2 ;_y4m -> dst_c_dec_v = 2 ;,1531
2163,"fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\\return - 1 ;_y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h  + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;_y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;_y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;return 0 ;","fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p10<S2SV_blank>to<S2SV_blank>420jpeg\\\return - 1 ;}}else if ( strcmp ( _y4m -> chroma_type , ""444p12"" ) == 0 ) {_y4m -> src_c_dec_h = 1 ;_y4m -> src_c_dec_v = 1 ;_y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ;_y4m -> bps = 36 ;_y4m -> bit_depth = 12 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;_y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;_y4m -> convert = y4m_convert_null ;if ( only_420 ) {fprintf ( stderr , ""Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p12<S2SV_blank>to<S2SV_blank>420jpeg\\\return - 1 ;}}else if ( strcmp ( _y4m -> chroma_type , ""444alpha"" ) == 0 ) {_y4m -> src_c_dec_h = 1 ;_y4m -> src_c_dec_v = 1 ;if ( only_420 ) {_y4m -> dst_c_dec_h = 2 ;_y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ;_y4m -> convert = y4m_convert_444_420jpeg ;}else {_y4m -> vpx_fmt = VPX_IMG_FMT_444A ;_y4m -> bps = 32 ;_y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;_y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;_y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;_y4m -> convert = y4m_convert_null ;}}else if ( strcmp ( _y4m -> chroma_type , ""mono"" ) == 0 ) {_y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ;_y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ;_y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;_y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;_y4m -> convert = y4m_convert_mono_420jpeg ;}else {fprintf ( stderr , ""Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\\return - 1 ;_y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;if ( _y4m -> bit_depth == 8 ) _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;else _y4m -> dst_buf = ( unsigned char * ) malloc ( 2 * _y4m -> dst_buf_sz ) ;if ( _y4m -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;return 0 ;",1531
2164,"struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ;if ( otmp ) {","struct obj * otmp ;if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\\\0' ;otmp = readobjnam ( buf , ( struct obj * ) 0 ) ;if ( otmp ) {",1532
2165,"long long directory_table_end , table_start ;if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 )  return FALSE ;if ( read_uids_guids ( & table_start ) == FALSE )  return FALSE ;if ( parse_exports_table ( & table_start ) == FALSE )  return FALSE ;if ( read_fragment_table ( & directory_table_end ) == FALSE )  return FALSE ;if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE )  return FALSE ;if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ;}","long long table_start ;if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) {if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) goto corrupted ;}else table_start = sBlk . s . bytes_used ;if ( sBlk . s . id_table_start >= table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( sBlk . s . no_ids == 0 ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_id_table ( & table_start ) == FALSE ) goto corrupted ;if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) {if ( sBlk . s . lookup_table_start >= table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>lookup<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( parse_exports_table ( & table_start ) == FALSE ) goto corrupted ;}if ( sBlk . s . fragments != 0 ) {if ( sBlk . s . fragment_table_start >= table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( sBlk . s . fragments > sBlk . s . inodes ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_fragment_table ( & table_start ) == FALSE ) goto corrupted ;}else {if ( sBlk . s . fragment_table_start != table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>invalid<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}}if ( sBlk . s . directory_table_start >= table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>directory<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ;if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) {ERROR ( ""read_filesystem_tables:<S2SV_blank>inode<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\goto corrupted ;}if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE ) return FALSE ;if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ;corrupted : ERROR ( ""File<S2SV_blank>system<S2SV_blank>corruption<S2SV_blank>detected\\\return FALSE ;}",1533
2166,static struct env *  createenv ( const struct rule * rule )  {env -> count = 0 ;if ( rule -> options & KEEPENV ) {,"static struct env * createenv ( const struct rule * rule , const struct passwd * mypw , const struct passwd * targpw ) {env -> count = 0 ;addnode ( env , ""DOAS_USER"" , mypw -> pw_name ) ;if ( rule -> options & KEEPENV ) {",1534
2167,}return env ;,"}else {static const char * copyset [ ] = {""DISPLAY"" , ""TERM"" , NULL };addnode ( env , ""HOME"" , targpw -> pw_dir ) ;addnode ( env , ""LOGNAME"" , targpw -> pw_name ) ;addnode ( env , ""PATH"" , getenv ( ""PATH"" ) ) ;addnode ( env , ""SHELL"" , targpw -> pw_shell ) ;addnode ( env , ""USER"" , targpw -> pw_name ) ;fillenv ( env , copyset ) ;}return env ;",1534
2168,"if ( unlikely ( skb -> len <= mss ) ) goto out ;if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) {int type = skb_shinfo ( skb ) -> gso_type ;if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ;skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ;segs = NULL ;goto out ;}if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ;else {offset = skb_checksum_start_offset ( skb ) ;csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ;offset += skb -> csum_offset ;* ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ;skb -> ip_summed = CHECKSUM_NONE ;tnl_hlen = skb_tnl_header_len ( skb ) ;if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;","if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) {if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ;",1535
2169,"vp9_clear_system_state ( ) ;if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) {vpx_memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;vpx_memset ( cpi -> complexity_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;vp9_enable_segmentation ( seg ) ;vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ;for ( segment = 1 ;segment < 2 ;segment ++ ) {const int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex ,  in_frame_q_adj_ratio [ segment ] ) ;vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ;}","vpx_clear_system_state ( ) ;if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) {const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ;memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ;if ( cpi -> rc . sb64_target_rate < 256 ) {vp9_disable_segmentation ( seg ) ;return ;}vp9_enable_segmentation ( seg ) ;vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ;for ( segment = 0 ;segment < AQ_C_SEGMENTS ;++ segment ) {int qindex_delta ;if ( segment == DEFAULT_AQ2_SEG ) continue ;qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ;if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) {qindex_delta = - cm -> base_qindex + 1 ;}if ( ( cm -> base_qindex + qindex_delta ) > 0 ) {vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ;}}",1536
2170,"if ( ! mod_type ) return 0 ;if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ;Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ;if ( ! Module_type ) return 0 ;Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields ,  1 ) ;if ( ! Interactive_type ) return 0 ;Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ;if ( ! Expression_type ) return 0 ;if ( ! Suite_type ) return 0 ;stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ;if ( ! stmt_type ) return 0 ;if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ;FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields ,  5 ) ;if ( ! FunctionDef_type ) return 0 ;AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type ,  AsyncFunctionDef_fields , 5 ) ;if ( ! AsyncFunctionDef_type ) return 0 ;ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ;if ( ! ClassDef_type ) return 0 ;Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ;if ( ! Return_type ) return 0 ;Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields , 1 ) ;if ( ! Delete_type ) return 0 ;Assign_type = make_type ( ""Assign"" , stmt_type , Assign_fields , 2 ) ;if ( ! Assign_type ) return 0 ;AugAssign_type = make_type ( ""AugAssign"" , stmt_type , AugAssign_fields , 3 ) ;if ( ! AugAssign_type ) return 0 ;AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , AnnAssign_fields , 4 ) ;if ( ! AnnAssign_type ) return 0 ;For_type = make_type ( ""For"" , stmt_type , For_fields , 4 ) ;AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , AsyncFor_fields , 4 ) ;While_type = make_type ( ""While"" , stmt_type , While_fields , 3 ) ;If_type = make_type ( ""If"" , stmt_type , If_fields , 3 ) ;","if ( ! Interactive_type ) return 0 ;Expression_type = make_type ( ""Expression"" , mod_type , Module_fields , 2 ) ;if ( ! Module_type ) return 0 ;Interactive_type = make_type ( ""Interactive"" , mod_type , Expression_fields , 1 ) ;if ( ! Expression_type ) return 0 ;FunctionType_type = make_type ( ""FunctionType"" , mod_type , Interactive_fields , 1 ) ;if ( ! Interactive_type ) return 0 ;Expression_type = make_type ( ""Expression"" , mod_type , FunctionType_fields , 2 ) ;if ( ! FunctionType_type ) return 0 ;if ( ! ClassDef_type ) return 0 ;Return_type = make_type ( ""Return"" , stmt_type , FunctionDef_fields , 6 ) ;if ( ! FunctionDef_type ) return 0 ;AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 6 ) ;if ( ! AsyncFunctionDef_type ) return 0 ;ClassDef_type = make_type ( ""ClassDef"" , stmt_type , Return_fields , 1 ) ;AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , Delete_fields , 1 ) ;if ( ! Delete_type ) return 0 ;Assign_type = make_type ( ""Assign"" , stmt_type , AsyncFor_fields , 5 ) ;if ( ! FunctionDef_type ) return 0 ;AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 5 ) ;if ( ! AsyncFunctionDef_type ) return 0 ;ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ;if ( ! ClassDef_type ) return 0 ;Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ;While_type = make_type ( ""While"" , stmt_type , Delete_fields , 1 ) ;if ( ! Delete_type ) return 0 ;Assign_type = make_type ( ""Assign"" , stmt_type , While_fields , 3 ) ;If_type = make_type ( ""If"" , stmt_type , AugAssign_fields , 3 ) ;if ( ! AugAssign_type ) return 0 ;AnnAssign_type = make_type ( ""AnnAssign"" , stmt_type , If_fields , 3 ) ;if ( ! If_type ) return 0 ;With_type = make_type ( ""With"" , stmt_type , For_fields , 4 ) ;if ( ! For_type ) return 0 ;AsyncFor_type = make_type ( ""AsyncFor"" , stmt_type , With_fields , 3 ) ;if ( ! With_type ) return 0 ;AsyncWith_type = make_type ( ""AsyncWith"" , stmt_type , While_fields , 3 ) ;if ( ! While_type ) return 0 ;If_type = make_type ( ""If"" , stmt_type , AsyncWith_fields , 3 ) ;",1537
2171,"arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 2 ) ;if ( ! arg_type ) return 0 ;","arg_type = make_type ( ""arg"" , & AST_type , arg_fields , 3 ) ;if ( ! arg_type ) return 0 ;type_ignore_type = make_type ( ""type_ignore"" , & AST_type , NULL , 0 ) ;if ( ! type_ignore_type ) return 0 ;if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ;TypeIgnore_type = make_type ( ""TypeIgnore"" , type_ignore_type , TypeIgnore_fields , 1 ) ;if ( ! TypeIgnore_type ) return 0 ;",1537
2172,initialized = 1 ;return 1 ;,initialized = 1 ;return 1 ;,1537
2173,"logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ;if ( logfile_fd == INVALID_FD ) {write ( logfile_fd , ""btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea"" , 16 ) ;}","logfile_fd = TEMP_FAILURE_RETRY ( open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ) ;if ( logfile_fd == INVALID_FD ) {TEMP_FAILURE_RETRY ( write ( logfile_fd , ""btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea"" , 16 ) ) ;}",1538
2174,if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 4 ;}if ( context -> curY >= p -> height ) {context -> pass ++ ;if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 1 ;}break ;},if ( context -> curY >= p -> height ) {context -> pass ++ ;break ;}while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) {switch ( ++ context -> pass ) {case 2 : context -> curY = i -> posY + 4 ;break ;case 3 : context -> curY = i -> posY + 2 ;break ;case 4 : context -> curY = i -> posY + 1 ;break ;}},1539
2175,# endif  ++ x -> ymode_count [ m ] ;,# else ( void ) cpi ;# endif ++ x -> ymode_count [ m ] ;,1540
2176,"if ( sr -> smb_fid != 0xffff ) {smbsr_lookup_file ( sr ) ;if ( sr -> fid_ofile == NULL ) {smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ;smb_flush_file ( sr , sr -> fid_ofile ) ;}smb_flush_file ( sr , file ) ;mutex_exit ( & file -> f_mutex ) ;","smb_ofile_flush ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ;smb_flush_file ( sr , sr -> fid_ofile ) ;}smb_ofile_flush ( sr , file ) ;mutex_exit ( & file -> f_mutex ) ;",1541
2177,"int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs )  {while ( * s && len > 0 ) {if ( * s & 0x80 ) {if ( u >= PLANE_SIZE ) {u -= PLANE_SIZE ;* op ++ = ( wchar_t ) ( SURROGATE_PAIR |   ( ( u >> 10 ) & SURROGATE_BITS ) ) ;* op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW |  ( u & SURROGATE_BITS ) ) ;}else {* op ++ = ( wchar_t ) u ;}* op ++ = * s ++ ;len -- ;","int utf8s_to_utf16s ( const u8 * s , int len , enum utf16_endian endian , wchar_t * pwcs , int maxlen ) {while ( len > 0 && maxlen > 0 && * s ) {if ( * s & 0x80 ) {if ( u >= PLANE_SIZE ) {if ( maxlen < 2 ) break ;u -= PLANE_SIZE ;put_utf16 ( op ++ , SURROGATE_PAIR | ( ( u >> 10 ) & SURROGATE_BITS ) , endian ) ;put_utf16 ( op ++ , SURROGATE_PAIR | SURROGATE_LOW | ( u & SURROGATE_BITS ) , endian ) ;maxlen -= 2 ;}else {put_utf16 ( op ++ , u , endian ) ;maxlen -- ;}* op ++ = * s ++ ;len -- ;",1542
2178,"if ( ! pflag ) ( void ) umask ( mask ) ;if ( argc != 1 ) {run_err ( ""ambiguous<S2SV_blank>target"" ) ;exit ( 1 ) ;}targ = * argv ;if ( targetshouldbedirectory ) verifydir ( targ ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ;for ( first = 1 ;;first = 0 ) {cp = buf ;if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ;if ( * cp ++ == \'\\\do {if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ;* cp ++ = ch ;}while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != \'\\\* cp = 0 ;if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ;if ( buf [ 0 ] == \'\\\\01\' || buf [ 0 ] == \'\\\\02\' ) {if ( iamremote == 0 ) {( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ;( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ;}if ( buf [ 0 ] == \'\\\\02\' ) exit ( 1 ) ;++ errs ;continue ;}if ( buf [ 0 ] == \'E\' ) {( void ) atomicio ( vwrite , remout , """" , 1 ) ;return ;}if ( ch == \'\\\cp = buf ;if ( * cp == \'T\' ) {setimes ++ ;cp ++ ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;mtime . tv_sec = ull ;mtime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;atime . tv_sec = ull ;atime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'\\\\0\' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;continue ;}if ( * cp != \'C\' && * cp != \'D\' ) {if ( first ) {run_err ( ""%s"" , cp ) ;exit ( 1 ) ;}SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ;}mode = 0 ;for ( ++ cp ;cp < buf + 5 ;cp ++ ) {if ( * cp < \'0\' || * cp > \'7\' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ;mode = ( mode << 3 ) | ( * cp - \'0\' ) ;}if ( ! pflag ) mode &= ~ mask ;if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ;size = ( off_t ) ull ;if ( ( strchr ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;","+ errs ;if ( * cp == \'\\\\0\' || strchr ( cp , ""."" ) == 0 || strcmp ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;",1543
2179,"int num , i , num1 , num2 ;char * s , * t , * StartClean ;double * argbuf = 0 ;SetDefaults ( ) ;* t ++ = 0 ;while ( * t == \'<S2SV_blank>\' || * t == \'\\\\t\' || * t == \'\\\outpos = outputbuffer ;outpos += sprintf ( outpos , ""\\\\\\\\axo@setObject{if ( * s == \'0\' && s [ 1 ] == \']\' ) {if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) {outpos += sprintf ( outpos , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output.}"" , VERSION , SUBVERSION ) ;fprintf ( outfile , ""%s"" , outputbuffer ) ;return ( 0 ) ;if ( argbuf ) free ( argbuf ) ;return ( - 1 ) ;StartClean = outpos ;nameobject = t ;while ( * t != \'<S2SV_blank>\' && * t != \'\\\\t\' && * t != \'\\\* t ++ = 0 ;while ( * t == \'<S2SV_blank>\' || * t == \'\\\\t\' || * t == \'\\\if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;if ( num2 - 1 != 0 ) {free ( argbuf ) ;return ( - 1 ) ;if ( strcmp ( nameobject , ""Curve"" ) == 0 ) {Curve ( argbuf , num1 ) ;}else if ( strcmp ( nameobject , ""Polygon"" ) == 0 ) {Polygon ( argbuf , num1 , 0 ) ;}else if ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) {Polygon ( argbuf , num1 , 1 ) ;}free ( argbuf ) ;}}else if ( strcmp ( nameobject , ""DashCurve"" ) == 0 ) {if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;if ( num2 != 2 ) {free ( argbuf ) ;return ( - 1 ) ;}}if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ;for ( i = 0 ;","int num , i , num1 , num2 , retcode ;char * s , * t ;double * argbuf = 0 ;retcode = - 1 ;SetDefaults ( ) ;fprintf ( outfile , ""\\\\\\\\axo@setObject{* t ++ = 0 ;while ( * t == \'<S2SV_blank>\' || * t == \'\\\\t\' || * t == \'\\\outpos = outputbuffer ;nameobject = t ;while ( * t != \'<S2SV_blank>\' && * t != \'\\\\t\' && * t != \'\\\* t ++ = 0 ;while ( * t == \'<S2SV_blank>\' || * t == \'\\\\t\' || * t == \'\\\if ( * s == \'0\' && s [ 1 ] == 0 ) {if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) {fprintf ( outfile , ""Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output."" , VERSION , SUBVERSION ) ;fprintf ( outfile , ""%s"" , outputbuffer ) ;return ( 0 ) ;goto EXIT ;if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ;if ( num2 - 1 != 0 ) {free ( argbuf ) ;return ( - 1 ) ;if ( strcmp ( nameobject , ""Curve"" ) == 0 ) goto EXIT ;if ( num2 != 2 ) {free ( argbuf ) ;return ( - 1 ) ;}}if ( ( argbuf = ReadTail ( t , & num ) ) == 0 ) return ( - 1 ) ;for ( i = 0 ;",1544
2180,break ;}free ( argbuf ) ;return ( - 1 ) ;free ( argbuf ) ;return ( - 1 ) ;,"argbuf = 0 ;break ;}goto EXIT ;goto EXIT ;}}SUCCESS : retcode = 0 ;EXIT : if ( argbuf ) {free ( argbuf ) ;}fprintf ( outfile , ""}\\\return ( retcode ) ;",1544
2181,default :  errno = EINVAL ;,case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ;return 0 ;default : errno = EINVAL ;,1545
2182,"static u32 ip_idents_hashrnd __read_mostly ;u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;hash = jhash_3words ( ( __force u32 ) iph -> daddr ,  ( __force u32 ) iph -> saddr ,  iph -> protocol ^ net_hash_mix ( net ) ,  ip_idents_hashrnd ) ;","u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( net -> ipv4 . ip_id_key ) ) ;hash = siphash_3u32 ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol , & net -> ipv4 . ip_id_key ) ;",1546
2183,"if ( obj == Py_None ) {* out = NULL ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ;","if ( lookup_attr_id ( obj , ( PyObject * ) Slice_type ) ;",1547
2184,"if ( exists_not_none ( obj , & PyId_lower ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ;if ( tmp == NULL ) goto failed ;}lower = NULL ;if ( exists_not_none ( obj , & PyId_upper ) ) {","if ( exists_not_none ( obj , & PyId_lower , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;lower = NULL ;}else {int res ;}if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;upper = NULL ;}int res ;res = obj2ast_expr ( tmp , & upper , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;step = NULL ;}else {int res ;res = obj2ast_expr ( tmp , & step , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;* out = Slice ( lower , upper , step , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {asdl_seq * dims ;if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""dims\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ;return 1 ;}else {",1547
2185,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_dims ) ;",Py_ssize_t i ;,1547
2186,"slice_ty value ;res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( dims , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""dims\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice"" ) ;return 1 ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {expr_ty value ;if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index"" ) ;return 1 ;","slice_ty val ;res = obj2ast_slice ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( dims , i , val ) ;}Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;",1547
2187,"static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode ,   const vp9_prob * probs ) {vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ;","static void write_intra_mode ( vpx_writer * w , MB_PREDICTION_MODE mode , const vpx_prob * probs ) {vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ;",1548
2188,"# ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) {if ( setpwnam ( ctl -> pw ) < 0 ) {warn ( ""setpwnam<S2SV_blank>failed"" ) ;","# ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw , "".chfn"" -> pw_uid , LU_GECOS , gecos ) < 0 ) {if ( setpwnam ( ctl -> pw ) < 0 ) {warn ( ""setpwnam<S2SV_blank>failed"" ) ;",1549
2189,if ( radiotap_header -> it_version )  return - EINVAL ;iterator -> _rtheader = radiotap_header ;,if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ;if ( radiotap_header -> it_version ) return - EINVAL ;iterator -> _rtheader + sizeof ( uint32_t ) = radiotap_header ;,1550
2190,if ( ( unsigned long ) iterator -> _arg -  ( unsigned long ) iterator -> _rtheader >  ( unsigned long ) iterator -> _max_length ) return - EINVAL ;,if ( ( unsigned long ) iterator -> _arg - ( unsigned long ) iterator -> _rtheader > ( unsigned long ) iterator -> _max_length ) return - EINVAL ;,1550
2191,"if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) )   goto err_delete ;tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ;","if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) {err = - EOPNOTSUPP ;goto err_delete ;}tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ;",1551
2192,"goto err_delete ;}match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match )  return - ENOMEM ;list_add ( & match -> list , & alink -> dscp_map ) ;}","err = - EOPNOTSUPP ;goto err_delete ;}err = - ENOMEM ;goto err_delete ;}list_add ( & match -> list , & alink -> dscp_map ) ;}",1551
2193,return - EOPNOTSUPP ;},return err ;},1551
2194,}dst_state -> curframe = src -> curframe ;,}dst_state -> speculative = src -> speculative ;dst_state -> curframe = src -> curframe ;,1552
2195,"ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;if ( gdImageTrueColor ( im ) ) {","if ( input <= 0.0 || output <= 0.0 ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ;RETURN_FALSE ;}ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;if ( gdImageTrueColor ( im ) ) {",1553
2196,stream -> config . cfg . g_pass = global -> passes == 2  ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ;if ( pass )  stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ;stream -> cx_time = 0 ;stream -> nbytes = 0 ;,"# if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) {if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ;}if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store"" ) ;}# endif else {stream -> config . cfg . g_pass = global -> passes == 2 ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ;if ( pass ) {stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ;# if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ;# endif }stream -> cx_time = 0 ;stream -> nbytes = 0 ;",1554
2197,if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun )  sas_eh_defer_cmd ( cmd ) ;},if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) sas_eh_finish_cmd ( cmd ) ;},1555
2198,"else  g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;","else if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 ) g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\\else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ;",1556
2199,"VP9_COMMON * const cm = & pbi -> common ;const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ;const uint8_t * end = NULL ;vp9_reader r ;assert ( tile_rows <= 4 ) ;vpx_memset ( cm -> above_context , 0 ,  sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ;vpx_memset ( cm -> above_seg_context , 0 ,   sizeof ( * cm -> above_seg_context ) * aligned_cols ) ;for ( tile_row = 0 ;const int last_tile = tile_row == tile_rows - 1 &&  tile_col == tile_cols - 1 ;const size_t size = get_tile ( data_end , last_tile , & cm -> error , & data ) ;TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ;buf -> data = data ;buf -> size = size ;data += size ;const int col = pbi -> oxcf . inv_tile_order ? tile_cols - tile_col - 1 : tile_col ;const int last_tile = tile_row == tile_rows - 1 && col == tile_cols - 1 ;const TileBuffer * const buf = & tile_buffers [ tile_row ] [ col ] ;TileInfo tile ;vp9_tile_init ( & tile , cm , tile_row , col ) ;setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & r ) ;decode_tile ( pbi , & tile , & r ) ;if ( last_tile ) end = vp9_reader_find_end ( & r ) ;return end ;","VP9_COMMON * const cm = & pbi -> common ;const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ;const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ;int mi_row , mi_col ;TileData * tile_data = NULL ;if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) {CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ;memset ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) {LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ;winterface -> sync ( & pbi -> lf_worker ) ;vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ;}assert ( tile_rows <= 4 ) ;vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ;memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * aligned_cols ) ;get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ;if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) {vpx_free ( pbi -> tile_data ) ;CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ;pbi -> total_tiles = tile_rows * tile_cols ;}for ( tile_row = 0 ;const TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ;tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ;tile_data -> cm = cm ;tile_data -> xd = pbi -> mb ;tile_data -> xd . corrupted = 0 ;tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ;vp9_zero ( tile_data -> dqcoeff ) ;vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ;setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ;vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ;TileInfo tile ;vp9_tile_set_row ( & tile , cm , tile_row ) ;for ( mi_row = tile . mi_row_start ;mi_row < tile . mi_row_end ;mi_row += MI_BLOCK_SIZE ) {const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ;tile_data = pbi -> tile_data + tile_cols * tile_row + col ;vp9_tile_set_col ( & tile , tile_data -> cm , col ) ;vp9_zero ( tile_data -> xd . left_context ) ;vp9_zero ( tile_data -> xd . left_seg_context ) ;for ( mi_col = tile . mi_col_start ;mi_col < tile . mi_col_end ;mi_col += MI_BLOCK_SIZE ) {decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ;}pbi -> mb . corrupted |= tile_data -> xd . corrupted ;if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>tile<S2SV_blank>data"" ) ;}if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) {const int lf_start = mi_row - MI_BLOCK_SIZE ;LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ;if ( lf_start < 0 ) continue ;if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ;winterface -> sync ( & pbi -> lf_worker ) ;lf_data -> start = lf_start ;lf_data -> stop = mi_row ;if ( pbi -> max_threads > 1 ) {winterface -> launch ( & pbi -> lf_worker ) ;}else {winterface -> execute ( & pbi -> lf_worker ) ;}}if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ;}if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) {LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ;winterface -> sync ( & pbi -> lf_worker ) ;lf_data -> start = lf_data -> stop ;lf_data -> stop = cm -> mi_rows ;winterface -> execute ( & pbi -> lf_worker ) ;tile_data = pbi -> tile_data + tile_cols * tile_rows - 1 ;if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ;return vpx_reader_find_end ( & tile_data -> bit_reader ) ;",1557
2200,"VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) {VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ;VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ;if ( ! cm ) return NULL ;","VP9Decoder * vp9_decoder_create ( BufferPool * const pool ) {VP9Decoder * volatile const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ;VP9_COMMON * volatile const cm = pbi ? & pbi -> common : NULL ;if ( ! cm ) return NULL ;",1558
2201,"vp9_initialize_dec ( ) ;vp9_rtcd ( ) ;vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ;cm -> current_video_frame = 0 ;pbi -> oxcf = * oxcf ;pbi -> ready_for_new_data = 1 ;pbi -> decoded_key_frame = 0 ;vp9_init_dequantizer ( cm ) ;vp9_loop_filter_init ( cm ) ;","CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ;memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ;CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ;pbi -> ready_for_new_data = 1 ;pbi -> decoded_key_frame = 0 ;vp9_init_dequantizer ( cm ) ;vp9_loop_filter_init ( cm ) ;",1558
2202,"GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\\( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;}","GF_Box * dref ;GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\\dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) dref ;gf_isom_box_add_for_dump_mode ( s , dref ) ;}",1559
2203,"client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 ,  ( GSourceFunc ) _client_protocol_timeout , client ) ;","
",1560
2204,}return new_fpl ;,new_fpl -> user = get_uid ( fpl -> user ) ;}return new_fpl ;,1561
2205,struct ip_options * opt ;struct inet_request_sock * req_inet ;if ( opt == NULL || opt -> cipso == 0 )  return ;,struct ip_options_rcu * opt ;struct inet_request_sock * req_inet ;if ( opt == NULL || opt -> opt . cipso == 0 ) return ;,1562
2206,"static void tree2tok ( struct vp9_token * tokens , const vp9_tree_index * tree ,  int i , int v , int l ) {const vp9_tree_index j = tree [ i ++ ] ;if ( j <= 0 ) {","static void tree2tok ( struct vp9_token * tokens , const vpx_tree_index * tree , int i , int v , int l ) {const vpx_tree_index j = tree [ i ++ ] ;if ( j <= 0 ) {",1563
2207,"if ( img )   res = validate_img ( ctx , img ) ;pick_quickcompress_mode ( ctx , duration , deadline ) ;if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF |  VP8_EFLAG_NO_REF_ARF ) ) {int ref = 7 ;if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ;if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ;if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ;vp9_use_as_reference ( ctx -> cpi , ref ) ;}if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) {int upd = 7 ;if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ;if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ;if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ;vp9_update_reference ( ctx -> cpi , upd ) ;}if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) {vp9_update_entropy ( ctx -> cpi , 0 ) ;}if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) {unsigned int lib_flags ;YV12_BUFFER_CONFIG sd ;int64_t dst_time_stamp , dst_end_time_stamp ;size_t size , cx_data_sz ;if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR )  ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ;lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ;if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags ,  & sd , dst_time_stamp , dst_end_time_stamp ) ) {VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ;res = update_error_state ( ctx , & cpi -> common . error ) ;}}cx_data = ctx -> cx_data ;cx_data_sz = ctx -> cx_data_sz ;lib_flags = 0 ;","VP9_COMP * const cpi = ctx -> cpi ;const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ;size_t data_sz ;if ( img != NULL ) {res = validate_img ( ctx , img ) ;if ( res == VPX_CODEC_OK && cpi != NULL ) {data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ;if ( data_sz < 4096 ) data_sz = 4096 ;if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) {ctx -> cx_data_sz = data_sz ;free ( ctx -> cx_data ) ;ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ;if ( ctx -> cx_data == NULL ) {return VPX_CODEC_MEM_ERROR ;}}}}pick_quickcompress_mode ( ctx , duration , deadline ) ;vp9_apply_encoding_flags ( cpi , flags ) ;if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) {unsigned int lib_flags = 0 ;YV12_BUFFER_CONFIG sd ;int64_t dst_time_stamp , dst_end_time_stamp ;size_t size , cx_data_sz ;if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ;lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ;if ( vp9_receive_raw_frame ( cpi , flags | ctx -> next_frame_flags , & sd , dst_time_stamp , dst_end_time_stamp ) ) {res = update_error_state ( ctx , & cpi -> common . error ) ;}ctx -> next_frame_flags = 0 ;}cx_data = ctx -> cx_data ;cx_data_sz = ctx -> cx_data_sz ;",1564
2208,"while ( cx_data_sz >= ctx -> cx_data_sz / 2 &&  - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size ,  cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {vpx_codec_pts_t round , delta ;vpx_codec_cx_pkt_t pkt ;VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ;if ( cpi -> common . show_frame == 0 ) {if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ;continue ;}round = ( vpx_codec_pts_t ) 1000000 * ctx -> cfg . g_timebase . num / 2 - 1 ;delta = ( dst_end_time_stamp - dst_time_stamp ) ;pkt . kind = VPX_CODEC_CX_FRAME_PKT ;pkt . data . frame . pts =  ( dst_time_stamp * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ;pkt . data . frame . duration = ( unsigned long )  ( ( delta * ctx -> cfg . g_timebase . den + round )  / ctx -> cfg . g_timebase . num / 10000000 ) ;pkt . data . frame . flags = lib_flags << 16 ;if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ;","while ( cx_data_sz >= ctx -> cx_data_sz / 2 && - 1 != vp9_get_compressed_data ( cpi , & lib_flags , & size , cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {vpx_codec_cx_pkt_t pkt ;VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ;if ( cpi -> common . show_frame || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) ) {if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ;if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) {pkt . kind = VPX_CODEC_CX_FRAME_PKT ;pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ;pkt . data . frame . buf = ctx -> pending_cx_data ;pkt . data . frame . sz = size ;ctx -> pending_cx_data = NULL ;ctx -> pending_cx_data_sz = 0 ;ctx -> pending_frame_count = 0 ;ctx -> pending_frame_magnitude = 0 ;ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ;}continue ;}pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ;pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp ) ;pkt . kind = VPX_CODEC_CX_FRAME_PKT ;pkt . data . frame . pts = ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ;pkt . data . frame . duration = ( unsigned long ) ( ( delta * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) ;pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ;if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ;",1564
2209,size += write_superframe_index ( ctx ) ;pkt . data . frame . buf = ctx -> pending_cx_data ;,if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) size += write_superframe_index ( ctx ) ;pkt . data . frame . buf = ctx -> pending_cx_data ;,1564
2210,"vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;cx_data += size ;}}","if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ;else vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;cx_data += size ;# if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) {vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ;int sl ;vp9_zero ( pkt_sizes ) ;vp9_zero ( pkt_psnr ) ;pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ;pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ;for ( sl = 0 ;sl < cpi -> svc . number_spatial_layers ;++ sl ) {LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ;pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ;pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ;lc -> layer_size = 0 ;}vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ;vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ;}# endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) {break ;}}}",1564
2211,"ctx -> clockid = clockid ;if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ;","spin_lock_init ( & ctx -> cancel_lock ) ;ctx -> clockid = clockid ;if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ;",1565
2212,"struct mount * child , * p ;struct hlist_node * n ;if ( IS_MNT_SHARED ( dest_mnt ) ) {err = invent_group_ids ( source_mnt , true ) ;err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;lock_mount_hash ( ) ;","struct mnt_namespace * ns = dest_mnt -> mnt_ns ;struct mount * child , * p ;struct hlist_node * n ;if ( ! parent_path ) {err = count_mounts ( ns , source_mnt ) ;}if ( IS_MNT_SHARED ( dest_mnt ) ) {err = invent_group_ids ( source_mnt , true ) ;if ( err ) goto out ;err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;lock_mount_hash ( ) ;",1566
2213,"
",child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ;,1566
2214,"umount_tree ( child , UMOUNT_SYNC ) ;}out :  return err ;}","umount_tree ( child , UMOUNT_SYNC ) ;}out : ns -> pending_mounts = 0 ;return err ;}",1566
2215,"ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ;if ( ret ) goto error ;","ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len , 0 ) ;if ( ret ) goto error ;",1567
2216,"void fadst16_8col ( __m128i * in ) {__m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ;","static void fadst16_8col ( __m128i * in ) {__m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ;",1568
2217,"const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( - cospi_16_64 ) ;const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;","const __m128i k__cospi_m16_m16 = _mm_set1_epi16 ( ( int16_t ) - cospi_16_64 ) ;const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;",1568
2218,"static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) {int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth *  ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ;","static int frame_max_bits ( const RATE_CONTROL * rc , const VP9EncoderConfig * oxcf ) {int64_t max_bits = ( ( int64_t ) rc -> avg_frame_bandwidth * ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ;",1569
2219,uchar magicbuf [ MIF_MAGICLEN ] ;char buf [ 4096 ] ;,jas_uchar magicbuf [ MIF_MAGICLEN ] ;char buf [ 4096 ] ;,1570
2220,"void Huff_transmit ( huff_t * huff , int ch , byte * fout ) {int i ;Huff_transmit ( huff , NYT , fout ) ;for ( i = 7 ;send ( huff -> loc [ ch ] , NULL , fout ) ;}","void Huff_transmit ( huff_t * huff , int ch , byte * fout , int maxoffset ) {int i ;Huff_transmit ( huff , NYT , fout , maxoffset ) ;for ( i = 7 ;send ( huff -> loc [ ch ] , NULL , fout , maxoffset ) ;}",1571
2221,"static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled ,   int mi_row , int mi_col , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;unsigned int segment_id = mbmi -> segment_id ;x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 &&  cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ;x -> skip_optimize = ctx -> is_coded ;ctx -> is_coded = 1 ;x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ;x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ;if ( x -> skip_encode ) return ;if ( cm -> frame_type == KEY_FRAME ) {if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) {adjust_act_zbin ( cpi , x ) ;vp9_update_zbin_extra ( cpi , x ) ;}}else {set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) {adjust_act_zbin ( cpi , x ) ;}cpi -> zbin_mode_boost = get_zbin_mode_boost ( mbmi , cpi -> zbin_mode_boost_enabled ) ;vp9_update_zbin_extra ( cpi , x ) ;}if ( output_enabled ) sum_intra_stats ( & cm -> counts , mi ) ;vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;for ( ref = 0 ;ref < 1 + is_compound ;++ ref ) {YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , mbmi -> ref_frame [ ref ] ) ;vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col ,  & xd -> block_refs [ ref ] -> sf ) ;vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ;if ( ! x -> skip ) {mbmi -> skip = 1 ;vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;}mbmi -> skip = 1 ;if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip ||  vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) {++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) ,   & cm -> counts . tx ) [ mbmi -> tx_size ] ;}","static void encode_superblock ( VP9_COMP * cpi , ThreadData * td , TOKENEXTRA * * t , int output_enabled , int mi_row , int mi_col , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ;x -> skip_recode = ! x -> select_tx_size && mbmi -> sb_type >= BLOCK_8X8 && cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ;if ( output_enabled ) sum_intra_stats ( td -> counts , mi ) ;vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;+ ref ) {set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) {adjust_act_zbin ( cpi , x ) ;if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) vp9_build_inter_predictors_sby ( xd , ref , cfg , mi_row , mi_col , & xd -> block_refs [ ref ] -> sf ) ;}vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ;if ( ! x -> skip ) {mbmi -> skip = 1 ;vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ;}mbmi -> skip = 1 ;+ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) ,   & cm -> counts . tx ) [ mbmi -> tx_size ] ;if ( cm -> tx_mode == TX_MODE_SELECT && mbmi -> sb_type >= BLOCK_8X8 && ! ( is_inter_block ( mbmi ) && ( mbmi -> skip || seg_skip ) ) ) ) {++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) , & td -> counts -> tx ) [ mbmi -> tx_size ] ;}assert ( cfg != NULL ) ;",1572
2222,}},"++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ;++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ;}}",1572
2223,"if ( iad_num == USB_MAXIADS ) {dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\\config -> intf_assoc [ iad_num ] =  ( struct usb_interface_assoc_descriptor  * ) header ;","struct usb_interface_assoc_descriptor * d ;d = ( struct usb_interface_assoc_descriptor * ) header ;if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) {dev_warn ( ddev , ""config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\\continue ;}if ( iad_num == USB_MAXIADS ) {dev_warn ( ddev , ""found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>"" ""Association<S2SV_blank>Descriptors<S2SV_blank>"" ""than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>"" ""configuration<S2SV_blank>%d\\\config -> intf_assoc [ iad_num ] = d ;",1573
2224,"int rc ;unsigned char key2 [ 8 ] ;struct crypto_skcipher * tfm_des ;struct scatterlist sgin , sgout ;tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ;if ( IS_ERR ( tfm_des ) ) {rc = PTR_ERR ( tfm_des ) ;cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\\goto smbhash_err ;}","unsigned char key2 [ 8 ] ;struct crypto_skcipher * tfm_des ;struct scatterlist sgin , sgout ;tfm_des = crypto_alloc_cipher ( ""des"" , 0 , CRYPTO_ALG_ASYNC ) ;if ( IS_ERR ( tfm_des ) ) {rc = PTR_ERR ( tfm_des ) ;cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\\goto smbhash_err ;}",1574
2225,"sg_init_one ( & sgin , in , 8 ) ;sg_init_one ( & sgout , out , 8 ) ;skcipher_request_set_callback ( req , 0 , NULL , NULL ) ;skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ;rc = crypto_skcipher_encrypt ( req ) ;smbhash_err :  return rc ;","sg_init_one ( & sgin , in , 8 ) ;sg_init_one ( & sgout , out , 8 ) ;skcipher_request_set_callback ( req , 0 , 0 ) ;return 0 ;",1574
2226,"static inline void header_put_be_int ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ;psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header [ psf -> headindex ++ ] = x ;};}","static inline void header_put_be_int ( SF_PRIVATE * psf , int x ) {psf -> header ) - 4 ) {psf -> header . ptr [ psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header . indx ++ ] = x ;}",1575
2227,"uint32_t value ;int position , zeroes , i , j ;char bits [ 65 ] ;zeroes = i = 0 ;while ( 1 ) {if ( get_bits_left ( gbc ) < zeroes + 1 ) {av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\\if ( get_bits1 ( gbc ) ) {bits [ i ++ ] = \'1\' ;break ;}else {bits [ i ++ ] = \'0\' ;}value = get_bits_long ( gbc , zeroes ) ;j ++ )  bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? \'1\' : \'0\' ;value += ( 1 << zeroes ) - 1 ;}","uint32_t zeroes , bits_value , value ;int position ;zeroes = i = 0 ;while ( 1 ) {if ( get_bits_left ( gbc ) < 1 ) {av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\\if ( get_bits1 ( gbc ) ) break ;if ( get_bits_left ( gbc ) < zeroes ) {av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>"" ""%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\\return AVERROR_INVALIDDATA ;}bits_value = get_bits_long ( gbc , zeroes ) ;value = bits_value + ( UINT32_C ( 1 ) << zeroes ) - 1 ;}if ( ctx -> trace_enable ) {char bits [ 65 ] ;int i , j , k ;if ( zeroes >= 32 ) {while ( zeroes > 32 ) {k = FFMIN ( zeroes - 32 , 32 ) ;for ( i = 0 ;i < k ;i ++ ) bits [ i ] = \'0\' ;bits [ i ] = 0 ;ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , 0 ) ;zeroes -= k ;position += k ;}}for ( i = 0 ;i < zeroes ;i ++ ) bits [ i ] = \'0\' ;bits [ i ++ ] = \'1\' ;if ( zeroes < 32 ) {j ++ ) bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? \'1\' : \'0\' ;value += ( 1 << zeroes ) - 1 ;}",1576
2228,if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ;else if ( i > pos && i + insn -> off + 1 < pos )  insn -> off -= delta ;,if ( i < pos && i + insn -> off + 1 <= pos + delta ) insn -> off += delta ;else if ( i > pos + delta && i + insn -> off + 1 < pos ) insn -> off -= delta ;,1577
2229,case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  case EXIT_REASON_INVEPT :  return 1 ;,case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : return 1 ;,1578
2230,"else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {param -> name = p + i ;}else {error = ERROR_INVALID_SYNTAX ;}}else if ( param -> nameLen == 0 ) {if ( c == \'\\\\0\' || c == \',\' || c == \';\' ) {param -> nameLen = p + i - param -> name ;error = NO_ERROR ;}else if ( c == \'<S2SV_blank>\' || c == \'\\\\t\' ) {param -> nameLen = p + i - param -> name ;}else if ( c == \'=\' ) {separatorFound = TRUE ;param -> nameLen = p + i - param -> name ;}else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {","else if ( isalnum ( c ) || osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 ) {",1579
2231,"else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {","else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 ) {",1579
2232,"else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {param -> value = p + i ;}else {error = ERROR_INVALID_SYNTAX ;}}else {if ( param -> value [ 0 ] == \\\'\\\\""\\\' ) {if ( c == \'\\\\0\' ) {error = ERROR_INVALID_SYNTAX ;}else if ( escapeFlag ) {escapeFlag = FALSE ;}else if ( c == \'\\\\\\\\\' ) {escapeFlag = TRUE ;}else if ( c == \\\'\\\\""\\\' ) {i ++ ;param -> valueLen = p + i - param -> value ;error = NO_ERROR ;}else if ( isprint ( c ) || c == \'\\\\t\' || c >= 128 ) {}else {error = ERROR_INVALID_SYNTAX ;}}else {if ( c == \'\\\\0\' || c == \'<S2SV_blank>\' || c == \'\\\\t\' || c == \',\' || c == \';\' ) {param -> valueLen = p + i - param -> value ;error = NO_ERROR ;}else if ( isalnum ( c ) || strchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 )  {","else if ( isalnum ( c ) || osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || osStrchr ( ""!#$%&\\\'*+-.^_`|~"" , c ) || c >= 128 ) {",1579
2233,"packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 ,  packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL ,  packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ;","packet -> parsed_lines = 0 , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ;",1580
2234,"if ( ! proc_fd_access_allowed ( inode ) ) goto out ;error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ;nd -> last_type = LAST_BIND ;out : return ERR_PTR ( error ) ;",out : return ERR_PTR ( error ) ;,1581
2235,"assert ( pow ( ( float ) r + 1 , dim ) > entries ) ;assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ;return r ;","if ( pow ( ( float ) r + 1 , dim ) <= entries ) return - 1 ;if ( ( int ) floor ( pow ( ( float ) r , dim ) ) > entries ) return - 1 ;return r ;",1582
2236,"q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;","q = QueueAuthenticPixels ( image , x , y , MagickMin ( 4 , dds_info -> width - x ) , MagickMin ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;",1583
2237,"}SkipDXTMipmaps ( image , dds_info , 8 ) ;return MagickTrue ;","return ( }SkipDXTMipmaps ( image , dds_info , 8 , exception ) ) ;",1583
2238,"if ( iph -> ihl == 5 ) {memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ;return 0 ;}opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ;","memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ;if ( iph -> ihl == 5 ) return 0 ;}opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ;",1584
2239,"if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) {if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {","if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , ""value"" , sizeof ( ""value"" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) {if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) {if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) {",1585
2240,"int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ;if ( ret < 0 ) {ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ;if ( ret < 0 ) {","int ret = TEMP_FAILURE_RETRY ( recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ) ;if ( ret < 0 ) {ret = TEMP_FAILURE_RETRY ( recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ) ;if ( ret < 0 ) {",1586
2241,"void BezierOval ( double w , double h , char * action )  {outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\\}","void BezierOval ( double w , double h , char * action ) {char * outpos = outputbuffer ;outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\\sendClean ( outputbuffer ) ;}",1587
2242,"int i ;memset ( cfg , 0 , sizeof ( cfg_t ) ) ;","struct stat st ;FILE * file = NULL ;int fd = - 1 ;int i ;memset ( cfg , 0 , sizeof ( cfg_t ) ) ;",1588
2243,"struct stat st ;FILE * file ;if ( lstat ( filename , & st ) == 0 ) {if ( S_ISREG ( st . st_mode ) ) {file = fopen ( filename , ""a"" ) ;if ( file != NULL ) {}}","fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ;if ( fd >= 0 && ( fstat ( fd , & st ) == 0 ) && S_ISREG ( st . st_mode ) ) {file = fdopen ( fd , ""a"" ) ;if ( file != NULL ) {cfg -> is_custom_debug_file = 1 ;file = NULL ;fd = - 1 ;}}",1588
2244,"
",if ( fd != - 1 ) close ( fd ) ;if ( file != NULL ) fclose ( file ) ;,1588
2245,},},1588
2246,"if ( ! sm_info ) return - ENOMEM ;sbi -> sm_info = sm_info ;sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ;sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ;sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ;sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ;sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ;sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ;sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ;sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ;if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ;if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ;sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ;sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ;sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ;sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ;INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ;if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) {err = create_flush_cmd_control ( sbi ) ;",if ( ! f2fs_readonly ( sbi -> sb ) ) {err = create_flush_cmd_control ( sbi ) ;,1589
2247,"if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ;if ( sun_info . depth < 24 ) {size_t one ;image -> colors = sun_info . maplength ;one = 1 ;if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ;if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}case RMT_RAW : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ;if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ;image -> columns = sun_info . width ;image -> rows = sun_info . height ;if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) &&   ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = sun_info . depth ) > ( 8 * sun_info . length ) * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1590
2248,"length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;","length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;",1590
2249,"outpos +=  sprintf ( outpos , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\\}}","sprintf ( outputbuffer , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\\sendClean ( outputbuffer ) ;}}",1591
2250,"WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ;Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ;","WLog_VRB ( AUTODETECT_TAG , ""received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU"" ) ;if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ;Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ;",1592
2251,_ipmi_destroy_user ( user ) ;cleanup_srcu_struct ( & user -> release_barrier ) ;,_ipmi_destroy_user ( user ) ;,1593
2252,"# endif if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) vp8_activity_masking ( cpi , x ) ;if ( xd -> segmentation_enabled ) {if ( cpi -> segmentation_map [ map_index + mb_col ] <= 3 ) xd -> mode_info_context -> mbmi . segment_id = cpi -> segmentation_map [ map_index + mb_col ] ;else xd -> mode_info_context -> mbmi . segment_id = 0 ;vp8cx_mb_init_quantizer ( cpi , x , 1 ) ;else xd -> mode_info_context -> mbmi . segment_id = 0 ;x -> active_ptr = cpi -> active_map + map_index + mb_col ;if ( cm -> frame_type == KEY_FRAME ) {* totalrate += vp8cx_encode_intra_macroblock ( cpi , x , tp ) ;# ifdef MODE_STATS y_modes [ xd -> mbmi . mode ] ++ ;# endif }* totalrate += vp8cx_encode_inter_macroblock ( cpi , x , tp , recon_yoffset , recon_uvoffset , mb_row , mb_col ) ;# ifdef MODE_STATS inter_y_modes [ xd -> mbmi . mode ] ++ ;if ( xd -> mbmi . mode == SPLITMV ) {int b ;for ( b = 0 ;b < xd -> mbmi . partition_count ;b ++ ) {inter_b_modes [ x -> partition -> bmi [ b ] . mode ] ++ ;# endif  if ( ( cpi -> current_layer == 0 ) &&  ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) {else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) )  {",# endif if ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) {cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ;if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ;else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) {if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ;if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ;cpi -> consec_zero_last [ map_index + mb_col ] = 0 ;cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ;if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ;if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) {else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ) {,1594
2253,"pack_tokens ( w , tp_start , tok_count ) ;}","vp8_pack_tokens ( w , tp_start , tok_count ) ;}",1594
2254,"if ( type == ARPHRD_ETHER )  dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ;else  dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ;","if ( type == ARPHRD_ETHER ) {dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ;dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;}else dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ;",1595
2255,"in_uint16_le ( s , type ) ;in_uint16_le ( s , status ) ;if ( status == CLIPRDR_ERROR )  {","struct stream packet = * s ;in_uint16_le ( s , type ) ;in_uint16_le ( s , status ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}if ( status == CLIPRDR_ERROR ) {",1596
2256,"# if CONFIG_MULTITHREAD  if ( pbi -> b_multithreaded_rd )  vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ;vp8_decoder_remove_threads ( pbi ) ;",# if CONFIG_MULTITHREAD vp8_decoder_remove_threads ( pbi ) ;,1597
2257,"
",if ( l == NULL ) break ;,1598
2258,"if ( rows > 1 ) {pos = columnPos ( l , col ) ;","if ( rows > 1 ) {pos = columnPos ( l , col ) ;",1598
2259,if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) {if ( xWantedSize > 0 )  {xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;}mtCOVERAGE_TEST_MARKER ( ) ;,if ( ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) {if ( xWantedSize > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) {if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) {xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;}xWantedSize = 0 ;}else {xWantedSize = 0 ;},1599
2260,"void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) {","void vp9_iht8x8_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) {",1600
2261,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ;srcreg = ( opcode >> 4 ) & 0x3f ;",1601
2262,"static void  fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( bps * stride ) ) == 0 ) ;if ( ! tmp )  return ;_TIFFmemcpy ( tmp , cp0 , cc ) ;","static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( bps * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))!=0"" ) ;return 0 ;}if ( ! tmp ) return 0 ;_TIFFmemcpy ( tmp , cp0 , cc ) ;",1602
2263,cp -- )  },cp -- ) return 1 ;},1602
2264,"uint16 num_updates ;uint16 left , top , right , bottom , width , height ;uint16 cx , cy , bpp , Bpp , compress , bufsize , size ;uint8 * data , * bmpdata ;logger ( Protocol , Debug , ""%s()"" , __func__ ) ;in_uint16_le ( s , num_updates ) ;in_uint16_le ( s , left ) ;in_uint16_le ( s , top ) ;","logger ( Protocol , Debug , ""%s()"" , __func__ ) ;in_uint16_le ( s , num_updates ) ;in_uint16_le ( s , left ) ;in_uint16_le ( s , top ) ;",1603
2265,"in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ;",process_bitmap_data ( s ) ;,1603
2266,if ( error ) return error ;,if ( error ) {kmem_free ( sbuf ) ;return error ;},1604
2267,if ( error )  return error ;if ( context -> seen_enough )  break ;,if ( error ) return error ;if ( context -> seen_enough ) break ;,1604
2268,"if ( length < sizeof ( struct olsr_common ) ) {goto trunc ;}ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ;ptr . common = ( const struct olsr_common * ) tptr ;length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ;ND_PRINT ( ( ndo , ""OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ;tptr += sizeof ( struct olsr_common ) ;if ( ndo -> ndo_vflag < 1 ) {return ;}while ( tptr < ( pptr + length ) ) {union {const struct olsr_msg4 * v4 ;const struct olsr_msg6 * v6 ;}msgptr ;int msg_len_valid = 0 ;ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;if ( is_ipv6 ) {",if ( length < sizeof ( struct olsr_msg6 ) ) ;,1605
2269,else  {msgptr . v4 = ( const struct olsr_msg4 * ) tptr ;,"else {ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ;msgptr . v4 = ( const struct olsr_msg4 * ) tptr ;",1605
2270,u_int name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;u_int addr_size = 4 ;int name_entries_valid = 0 ;u_int i ;if ( is_ipv6 ) addr_size = 16 ;if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) )  name_entries_valid = 1 ;if ( msg_tlen < 4 ) goto trunc ;,u_int name_entries ;u_int addr_size ;int name_entries_valid ;u_int i ;if ( msg_tlen < 4 ) goto trunc ;name_entries = EXTRACT_16BITS ( msg_data + 2 ) ;addr_size = 4 ;int name_entries_valid = 0 ;if ( is_ipv6 ) addr_size = 16 ;if ( ( name_entries > 0 ) && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) name_entries_valid = 1 ;,1605
2271,"uint16 bitspersample , samplesperpixel ;uint16 input_compression , input_photometric ;copyFunc cf ;","uint16 bitspersample , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;copyFunc cf ;",1606
2272,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",1607
2273,"static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size ,  vp9_coeff_stats * coef_branch_ct ) {vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ;vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ;","static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size , vp9_coeff_stats * coef_branch_ct , vp9_coeff_probs_model * coef_probs ) {vp9_coeff_count * coef_counts = cpi -> td . rd_counts . coef_counts [ tx_size ] ;",1608
2274,"assert ( name ) ;r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ;","assert ( name ) ;r = vt_verify_kbmode ( fd ) ;if ( r == - EBUSY ) {log_warning_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , name ) ;return 0 ;}else if ( r < 0 ) return log_warning_errno ( r , ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m"" , name ) ;r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ;",1609
2275,"static int su3000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ 3 ] = {0xe , 0x80 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x02 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ;","static int su3000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x02 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ;",1610
2276,sock_release ( SOCKET_I ( inode ) ) ;return 0 ;,"__sock_release ( SOCKET_I ( inode ) , inode ) ;return 0 ;",1611
2277,"vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface ,  vpx_codec_enc_cfg_t * cfg ,  vpx_codec_flags_t flags , int ver ) {else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) )  res = VPX_CODEC_INCAPABLE ;","vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , const vpx_codec_enc_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) {",1612
2278,if ( ctx -> priv )  ctx -> priv -> iface = ctx -> iface ;,"
",1612
2279,"static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride ,  int uv_block_size ,  int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) {const InterpKernel * const kernel =  vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ;enum mv_precision mv_precision_uv ;if ( uv_block_size == 8 ) {uv_stride = ( stride + 1 ) >> 1 ;vp9_build_inter_predictor ( y_mb_ptr , stride ,  & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ;vp9_build_inter_predictor ( u_mb_ptr , uv_stride ,  & pred [ 256 ] , uv_block_size ,  & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ;vp9_build_inter_predictor ( v_mb_ptr , uv_stride ,  & pred [ 512 ] , uv_block_size ,  & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ;","static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride , int uv_block_width , int uv_block_height , int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) {const InterpKernel * const kernel = vp9_filter_kernels [ xd -> mi [ 0 ] -> mbmi . interp_filter ] ;enum mv_precision mv_precision_uv ;if ( uv_block_width == 8 ) {uv_stride = ( stride + 1 ) >> 1 ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ;vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ;vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ;return ;}# endif vp9_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ;vp9_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_size , & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ;vp9_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_size , & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ;",1613
2280,"mungspaces ( strcpy ( buf , origbuf ) ) ;bufp = find_optparam ( buf ) ;","while ( * origbuf == \'<S2SV_blank>\' || * origbuf == \'\\\\t\' ) ++ origbuf ;( void ) strncpy ( buf , origbuf , sizeof buf - 1 ) ;buf [ sizeof buf - 1 ] = \'\\\\0\' ;mungspaces ( buf ) ;bufp = find_optparam ( buf ) ;",1614
2281,"cJSON * cJSON_CreateFloatArray ( double * numbers , int count )  {for ( i = 0 ;++ i ) {n = cJSON_CreateFloat ( numbers [ i ] ) ;if ( ! i )  a -> child = n ;","cJSON * cJSON_CreateFloatArray ( const float * numbers , int count ) {for ( i = 0 ;+ i ) {i ++ ) {n = cJSON_CreateFloat ( numbers [ i ] ) ;if ( ! n ) {cJSON_Delete ( a ) ;return 0 ;}if ( ! i ) a -> child = n ;",1615
2282,goto retry_rebind ;},switch ( task -> tk_status ) {case - EACCES : case - EIO : goto die ;default : goto retry_rebind ;}},1616
2283,"struct buffer_head * bh = NULL ;struct fileEntry * fe ;struct extendedFileEntry * efe ;uint16_t ident ;struct udf_inode_info * iinfo = UDF_I ( inode ) ;struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ;unsigned int link_count ;bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ;if ( ! bh ) {udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\\make_bad_inode ( inode ) ;return ;}if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) {udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\\brelse ( bh ) ;make_bad_inode ( inode ) ;return ;}fe = ( struct fileEntry * ) bh -> b_data ;efe = ( struct extendedFileEntry * ) bh -> b_data ;if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) {struct buffer_head * ibh ;ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ;if ( ident == TAG_IDENT_IE && ibh ) {struct buffer_head * nbh = NULL ;struct kernel_lb_addr loc ;if ( ie -> indirectICB . extLength &&   ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 ,  & ident ) ) ) {","struct kernel_lb_addr loc ;if ( ie -> indirectICB . extLength && ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , & ident ) ) ) {",1617
2284,brelse ( nbh ) ;},brelse ( nbh ) ;},1617
2285,"float * w = get_window ( f , n ) ;for ( i = 0 ;","float * w = get_window ( f , n ) ;if ( w == NULL ) return 0 ;for ( i = 0 ;",1618
2286,"uint32 num_properties = GETINT32 ( buf + idx ) ;MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ;","uint32 num_properties = GETINT32 ( buf + idx ) ;assert ( ( num_properties + 1 ) != 0 ) ;MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ;",1619
2287,"
",assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ;,1619
2288,"
",assert ( v -> len + idx <= len ) ;,1619
2289,for ( j = 0 ;j ++ )  a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ;,for ( j = 0 ;j ++ ) a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ;,1619
2290,"if ( a -> type == szMAPI_UNICODE_STRING )  {v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;}","if ( a -> type == szMAPI_UNICODE_STRING ) {assert ( v -> len != 0 ) ;v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ;}",1619
2291,"VP9_COMMON * const cm = & pbi -> common ;const uint8_t * bit_reader_end = NULL ;const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ;TileBuffer tile_buffers [ 1 << 6 ] ;int n ;const int num_threads = pbi -> oxcf . max_threads & ~ 1 ;int i ;CHECK_MEM_ERROR ( cm , pbi -> tile_workers ,  vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ;for ( i = 0 ;VP9Worker * const worker = & pbi -> tile_workers [ i ] ;++ pbi -> num_tile_workers ;vp9_worker_init ( worker ) ;CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ;CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ;if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) {vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ;pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ;}vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ;vpx_memset ( cm -> above_seg_context , 0 ,  sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ;for ( n = 0 ;n < tile_cols ;++ n ) {const size_t size =  get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ;TileBuffer * const buf = & tile_buffers [ n ] ;buf -> data = data ;buf -> size = size ;buf -> col = n ;data += size ;}qsort ( tile_buffers , tile_cols , sizeof ( tile_buffers [ 0 ] ) , compare_tile_buffers ) ;const TileBuffer largest = tile_buffers [ group_start ] ;memmove ( tile_buffers + group_start , tile_buffers + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] ) ) ;tile_buffers [ group_end ] = largest ;VP9Worker * const worker = & pbi -> tile_workers [ i ] ;TileBuffer * const buf = & tile_buffers [ n ] ;tile_data -> cm = cm ;vp9_tile_init ( tile , tile_data -> cm , 0 , buf -> col ) ;setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader ) ;init_macroblockd ( cm , & tile_data -> xd ) ;vp9_zero ( tile_data -> xd . dqcoeff ) ;vp9_worker_execute ( worker ) ;vp9_worker_launch ( worker ) ;}","VP9_COMMON * const cm = & pbi -> common ;const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ;const uint8_t * bit_reader_end = NULL ;const int num_workers = MIN ( pbi -> max_threads & ~ 1 , tile_cols ) ;TileBuffer tile_buffers [ 1 ] [ 1 << 6 ] ;int n ;const int num_threads = pbi -> max_threads & ~ 1 ;int i ;CHECK_MEM_ERROR ( cm , pbi -> tile_workers ) ) ) ;assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ;CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ;CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ;for ( i = 0 ;+ pbi -> num_tile_workers ;VPxWorker * const worker = & pbi -> tile_workers [ i ] ;++ pbi -> num_tile_workers ;winterface -> init ( worker ) ;if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) {vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ;+ n ) {VPxWorker * const worker = & pbi -> tile_workers [ n ] ;winterface -> sync ( worker ) ;worker -> hook = ( VPxWorkerHook ) tile_worker_hook ;}vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ;memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ;get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ;qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ;const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ;memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ;tile_buffers [ 0 ] [ group_end ] = largest ;if ( ! cm -> frame_parallel_decoding_mode ) {int i ;for ( i = 0 ;i < num_workers ;++ i ) {TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ;vp9_zero ( tile_data -> counts ) ;}}VPxWorker * const worker = & pbi -> tile_workers [ i ] ;TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ;tile_data -> pbi = pbi ;tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ;vp9_zero ( tile_data -> dqcoeff ) ;vp9_tile_init ( tile , cm , 0 , buf -> col ) ;vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ;setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ;vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ;winterface -> execute ( worker ) ;vp9_worker_launch ( worker ) ;}",1620
2292,VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ;pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ;}bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ;final_worker = - 1 ;},"VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ;pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ;}bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ;final_worker = - 1 ;}if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) {for ( i = 0 ;i < num_workers ;++ i ) {TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ;vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ;}}",1620
2293,offset = base + get4 ( ) + 8 ;while ( ( save = ftell ( ifp ) ) < offset ) {switch ( tag )  {,offset = base + get4 ( ) + 8 ;# ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ;# endif while ( ( save = ftell ( ifp ) ) < offset ) {if ( len < 0 ) return ;switch ( tag ) {,1621
2294,err = - EINVAL ;if ( ! po -> running ) goto out ;,"
",1622
2295,"goto out ;}if ( ! fanout_find_new_id ( sk , & id ) ) {err = - ENOMEM ;goto out ;}flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ;}match = NULL ;list_for_each_entry ( f , & fanout_list , list ) {if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) {match = f ;break ;}}err = - EINVAL ;if ( match && match -> flags != flags ) goto out ;if ( ! match ) {err = - ENOMEM ;match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ;if ( ! match ) goto out ;write_pnet ( & match -> net , sock_net ( sk ) ) ;match -> id = id ;match -> type = type ;",spin_lock ( & po -> bind_lock ) ;if ( po -> running && match -> type = type ;,1622
2296,if ( match -> type == type &&  match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {,if ( match -> type == type && match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) {,1622
2297,out :  if ( err && rollover ) {,spin_unlock ( & po -> bind_lock ) ;if ( err && ! refcount_read ( & match -> sk_ref ) ) {list_del ( & match -> list ) ;kfree ( match ) ;}out : if ( err && rollover ) {,1622
2298,"struct segmentation * seg = & cm -> seg ;const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ;const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ;vp9_clear_system_state ( ) ;for ( i = ENERGY_MIN ;i <= ENERGY_MAX ;i ++ ) {int qindex_delta , segment_rdmult ;if ( Q_RATIO ( i ) == 1 ) {RDMULT_RATIO ( i ) = 1 ;qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ;vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ;vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ;segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta +  cm -> y_dc_delta_q ) ;RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ;","struct segmentation * seg = & cm -> seg ;vpx_clear_system_state ( ) ;for ( i = 0 ;i < MAX_SEGMENTS ;++ i ) {int qindex_delta , segment_rdmult ;if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) {qindex_delta = - cm -> base_qindex + 1 ;}if ( rate_ratio [ i ] == 1.0 ) {vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ;vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ;",1623
2299,"if ( ! net_eq ( net , & init_net ) )  return - EAFNOSUPPORT ;","if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;",1624
2300,"( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) {","( void ) TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) {",1625
2301,if ( error -> error_code )  ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ;return error -> error_code ;,"if ( error -> error_code ) set_error_detail ( ctx , error -> has_detail ? error -> detail : NULL ) ;return error -> error_code ;",1626
2302,for ( i = j = 0 ;i < sizeof ( buf ) - 1 && str [ i ] ;if ( str [ j ] == '#' ) {,for ( i = j = 0 ;i < sizeof ( buf ) - 1 && str [ j ] ;if ( str [ j ] == '#' ) {,1627
2303,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;",1628
2304,"
","VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corrupt<S2SV_blank>BSON"" ) ;",1629
2305,"b = BCON_NEW ( ""my_dbref"" ,  ""{","b = BCON_NEW ( ""my_dbref"" , ""{",1629
2306,x86_pmu . extra_regs = intel_snb_extra_regs ;x86_pmu . er_flags |= ERF_HAS_RSP_1 ;,if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ;else x86_pmu . extra_regs = intel_snb_extra_regs ;x86_pmu . er_flags |= ERF_HAS_RSP_1 ;,1630
2307,x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;x86_pmu . extra_regs = intel_snb_extra_regs ;,x86_pmu . pebs_aliases = intel_pebs_aliases_snb ;if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ;else x86_pmu . extra_regs = intel_snb_extra_regs ;,1630
2308,"pocstruct_t * ps_prev_poc , * ps_cur_poc ;ih264d_free_dynamic_bufs ( ps_dec ) ;","pocstruct_t * ps_prev_poc , * ps_cur_poc ;WORD32 size ;size = sizeof ( pred_info_t ) * 2 * 32 ;memset ( ps_dec -> ps_pred , 0 , size ) ;size = sizeof ( disp_mgr_t ) ;memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ;size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ;memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ;size = sizeof ( dec_err_status_t ) ;memset ( ps_dec -> ps_dec_err_status , 0 , size ) ;size = sizeof ( sei ) ;memset ( ps_dec -> ps_sei , 0 , size ) ;size = sizeof ( dpb_commands_t ) ;memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ;size = sizeof ( dec_bit_stream_t ) ;memset ( ps_dec -> ps_bitstrm , 0 , size ) ;size = sizeof ( dec_slice_params_t ) ;memset ( ps_dec -> ps_cur_slice , 0 , size ) ;size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ;memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ;size = sizeof ( ctxt_inc_mb_info_t ) ;memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ;size = ( sizeof ( neighbouradd_t ) << 2 ) ;memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ;size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ;memset ( ps_dec -> pv_mv_buf_mgr , 0 , size ) ;ih264d_free_dynamic_bufs ( ps_dec ) ;",1631
2309,"
",ret = - EPERM ;if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ;,1632
2310,if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end &&  end > cur -> vm_start ) {if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ;,if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) {if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) ;WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) goto out_unlock ;,1632
2311,BUG_ON ( vma -> vm_userfaultfd_ctx . ctx &&  vma -> vm_userfaultfd_ctx . ctx != ctx ) ;if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ;,BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ;if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ;,1632
2312,"krb5_key_data * key_data ;if ( n_key_data <= 0 ) return NULL ;if ( key_data_in == NULL )  goto cleanup ;i < n_key_data ;i ++ ) {if ( key_data [ i ] . key_data_ver == 1 ) {key_data [ i ] . key_data_ver = 2 ;key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ;key_data [ i ] . key_data_length [ 1 ] = 0 ;key_data [ i ] . key_data_contents [ 1 ] = NULL ;}}for ( i = 0 ;i < n_key_data - 1 ;i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;if ( ret == NULL ) {err = ENOMEM ;goto cleanup ;}for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ;i < n_key_data ;i ++ ) {krb5_data * code ;if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) {ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ;if ( ret [ j ] == NULL ) goto cleanup ;err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;if ( err ) goto cleanup ;ret [ j ] -> bv_len = code -> length ;ret [ j ] -> bv_val = code -> data ;free ( code ) ;j ++ ;last = i + 1 ;if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ;}}ret [ num_versions ] = NULL ;cleanup : free ( key_data ) ;if ( err != 0 ) {if ( ret != NULL ) {for ( i = 0 ;i <= num_versions ;i ++ )   if ( ret [ i ] != NULL )  free ( ret [ i ] ) ;",krb5_key_data * key_data = NULL ;if ( n_key_data < 0 ) return NULL ;if ( key_data == NULL ) goto cleanup ;ret [ i ] != NULL ;i ++ ) free ( ret [ i ] ) ;,1633
2313,"ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ;switch ( ret ) {","ssize_t ret = TEMP_FAILURE_RETRY ( read ( fd , btpan_cb . congest_packet ) , sizeof ( btpan_cb . congest_packet ) ) ;switch ( ret ) {",1634
2314,if ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) {,if ( TEMP_FAILURE_RETRY ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) {,1634
2315,"if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) )  break ;","if ( poll ( & ufd , 1 , 0 ) ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) break ;",1634
2316,"if ( same_thread_group ( task , current ) ) return 0 ;rcu_read_lock ( ) ;tcred = __task_cred ( task ) ;if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ;if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ;ok : rcu_read_unlock ( ) ;smp_rmb ( ) ;if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ;rcu_read_lock ( ) ;if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {rcu_read_unlock ( ) ;return - EPERM ;","if ( dumpable != SUID_DUMP_USER && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) {",1635
2317,"static int su3000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ 3 ] = {0xe , 0x80 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x02 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ;","static int su3000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x02 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( ds3000_attach , & su3000_ds3000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>DS3000/TS2020!"" ) ;",1636
2318,"static int getnum ( const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;do {a = a * 10 + * ( ( * fmt ) ++ ) - \'0\' ;","static int getnum ( lua_State * L , const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;do {if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - \'0\' ) ) ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ;a = a * 10 + * ( ( * fmt ) ++ ) - \'0\' ;",1637
2319,"markold ( g , g -> survival , g -> reallyold ) ;markold ( g , g -> finobj , g -> finobjrold ) ;","markold ( g , g -> allgc , g -> reallyold ) ;markold ( g , g -> finobj , g -> finobjrold ) ;",1638
2320,"else  return - EIO ;deb_info ( ""Identify<S2SV_blank>state<S2SV_blank>cold<S2SV_blank>=<S2SV_blank>%d\\\","else ret = - EIO ;if ( ! ret ) deb_info ( ""Identify<S2SV_blank>state<S2SV_blank>cold<S2SV_blank>=<S2SV_blank>%d\\\",1639
2321,"( void ) opt ;if ( phase != PROTOCOL_EARLY )  return NULL ;memset ( buffer , 0 , sizeof buffer ) ;s_read ( c , c -> local_rfd . fd , buffer , sizeof buffer ) ;if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) {s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ;throw_exception ( c , 1 ) ;}s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ;return NULL ;","static const uint8_t gss_request [ 8 ] = {0 , 0 , 0 , 8 , 0x04 , 0xd2 , 0x16 , 0x30 };static const uint8_t gss_response [ 62 ] = {\'E\' , 0 , 0 , 0 , 61 , \'S\' , \'E\' , \'R\' , \'R\' , \'O\' , \'R\' , 0 , \'C\' , \'X\' , \'X\' , \'0\' , \'0\' , \'0\' , 0 , \'M\' , \'S\' , \'S\' , \'L\' , \'<S2SV_blank>\' , \'e\' , \'x\' , \'p\' , \'e\' , \'c\' , \'t\' , \'e\' , \'d\' , \'<S2SV_blank>\' , \'b\' , \'u\' , \'t\' , \'<S2SV_blank>\' , \'n\' , \'o\' , \'t\' , \'<S2SV_blank>\' , \'r\' , \'e\' , \'q\' , \'u\' , \'e\' , \'s\' , \'t\' , \'e\' , \'d\' , \'<S2SV_blank>\' , \'b\' , \'y\' , \'<S2SV_blank>\' , \'c\' , \'l\' , \'i\' , \'e\' , \'n\' , \'t\' , 0 , 0 };( void ) opt ;if ( phase != PROTOCOL_EARLY ) return NULL ;s_log ( LOG_DEBUG , ""Started<S2SV_blank>server-side<S2SV_blank>psql<S2SV_blank>protcol<S2SV_blank>negotiation"" ) ;memset ( buffer , gss_request , sizeof gss_request ) ) {s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ;throw_exception ( c , 1 ) ;}s_write ( c , c -> local_wfd . fd , gss_response , sizeof gss_response ) ;throw_exception ( c , 2 ) ;}if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) {s_log ( LOG_ERR , ""PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting"" ) ;throw_exception ( c , 1 ) ;}s_log ( LOG_DEBUG , ""SSLRequest<S2SV_blank>received"" ) ;s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ;return NULL ;",1640
2322,"static int  cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection )  {struct sockaddr_in addr ;int rc = 0 ;char * server = private -> server ;int ret_ga ;static struct mainloop_fd_callbacks cib_fd_callbacks =  {. dispatch = cib_remote_dispatch ,   . destroy = cib_remote_connection_destroy ,  }sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ;if ( sock == - 1 ) {crm_perror ( LOG_ERR , ""Socket<S2SV_blank>creation<S2SV_blank>failed"" ) ;return - 1 ;}bzero ( & hints , sizeof ( struct addrinfo ) ) ;hints . ai_flags = AI_CANONNAME ;hints . ai_family = AF_INET ;hints . ai_socktype = SOCK_RAW ;if ( hints . ai_family == AF_INET6 ) {hints . ai_protocol = IPPROTO_ICMPV6 ;}else {hints . ai_protocol = IPPROTO_ICMP ;}crm_debug ( ""Looking<S2SV_blank>up<S2SV_blank>%s"" , server ) ;ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ;if ( ret_ga ) {crm_err ( ""getaddrinfo:<S2SV_blank>%s"" , gai_strerror ( ret_ga ) ) ;close ( sock ) ;return - 1 ;}if ( res -> ai_canonname ) {server = res -> ai_canonname ;}crm_debug ( ""Got<S2SV_blank>address<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , server , private -> server ) ;if ( ! res -> ai_addr ) {fprintf ( stderr , ""getaddrinfo<S2SV_blank>failed"" ) ;crm_exit ( 1 ) ;}# if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addrlen ) ;# else memset ( & addr , 0 , sizeof ( addr ) ) ;addr . sin_family = AF_INET ;addr . sin_addr . s_addr = inet_addr ( server ) ;# endif addr . sin_port = htons ( private -> port ) ;if ( connect ( sock , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) {crm_perror ( LOG_ERR , ""Connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , server , private -> port ) ;close ( sock ) ;return - 1 ;# ifdef HAVE_GNUTLS_GNUTLS_H  gnutls_global_init ( ) ;gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ;connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ;if ( connection -> session == NULL ) {close ( sock ) ;cib_tls_close ( cib ) ;","static int cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection , gboolean event_channel ) {int rc = 0 ;char * server = private -> server ;int ret_ga ;static struct mainloop_fd_callbacks cib_fd_callbacks = {0 , }cib_fd_callbacks . dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ;cib_fd_callbacks . destroy = cib_remote_connection_destroy ;sock = crm_remote_tcp_connect ( private -> server , private -> port ) ;if ( sock <= 0 ) {crm_perror ( LOG_ERR , ""remote<S2SV_blank>tcp<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed"" , private -> server , private -> port ) ;connection -> socket = sock ;# ifdef HAVE_GNUTLS_GNUTLS_H if ( remote_gnutls_credentials_init == FALSE ) {gnutls_global_init ( ) ;gnutls_anon_allocate_client_credentials ( & anon_cred_c ) ;connection -> session = create_tls_session ( sock , GNUTLS_CLIENT ) ;if ( connection -> session == NULL ) {close ( sock ) ;cib_tls_close ( cib ) ;",1641
2323,"crm_send_remote_msg ( connection -> session , login , connection -> encrypted ) ;answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ;crm_log_xml_trace ( answer , ""Reply"" ) ;","crm_send_remote_msg ( connection -> session , & connection -> recv_buf , login , connection -> encrypted , - 1 , & disconnected ) ;if ( disconnected ) {rc = - ENOTCONN ;}answer = crm_parse_remote_buffer ( & connection -> recv_buf ) ;answer = crm_recv_remote_msg ( connection -> session , connection -> encrypted ) ;crm_log_xml_trace ( answer , ""Reply"" ) ;",1641
2324,if ( rc != 0 ) {cib_tls_close ( cib ) ;}connection -> socket = sock ;,"free_xml ( answer ) ;answer = NULL ;if ( rc != 0 ) {cib_tls_close ( cib ) ;return rc ;}crm_trace ( ""remote<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>established"" ) ;",1641
2325,"vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;if ( setjmp ( cm -> error . jmp ) ) {","memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ;if ( setjmp ( cm -> error . jmp ) ) {",1642
2326,cpi -> kf_overspend_bits = 0 ;cpi -> kf_bitrate_adjustment = 0 ;,cpi -> temporal_layer_id = - 1 ;cpi -> kf_overspend_bits = 0 ;cpi -> kf_bitrate_adjustment = 0 ;,1642
2327,# endif  cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;cpi -> cyclic_refresh_mode_index = 0 ;# ifdef VP8_ENTROPY_STATS  init_context_counters ( ) ;,"# endif cpi -> mse_source_denoised = 0 ;cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ;cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ;if ( cpi -> oxcf . number_of_layers == 1 ) {cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ;}else if ( cpi -> oxcf . number_of_layers == 2 ) {cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ;}cpi -> cyclic_refresh_mode_index = 0 ;CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ;CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ;# ifdef VP8_ENTROPY_STATS init_context_counters ( ) ;cpi -> force_maxqp = 0 ;",1642
2328,cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;# if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ;,cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ;# if CONFIG_INTERNAL_STATS cpi -> b_calculate_ssimg = 0 ;,1642
2329,"# endif  # if 0  framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ;","# endif # ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( ""denoised.yuv"" , ""ab"" ) ;# endif # if 0 framepsnr = fopen ( ""framepsnr.stt"" , ""a"" ) ;",1642
2330,# endif  cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ;# if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ;,# endif cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vpx_sad16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vpx_variance16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vpx_sub_pixel_variance16x16 ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vpx_variance_halfpixvar16x16_h ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vpx_variance_halfpixvar16x16_v ;cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vpx_variance_halfpixvar16x16_hv ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vpx_sad16x16x3 ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vpx_sad16x16x8 ;cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vpx_sad16x16x4d ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vpx_sad16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vpx_variance16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vpx_sub_pixel_variance16x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vpx_sad16x8x3 ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vpx_sad16x8x8 ;cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vpx_sad16x8x4d ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vpx_sad8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vpx_variance8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vpx_sub_pixel_variance8x16 ;cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vpx_sad8x16x3 ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vpx_sad8x16x8 ;cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vpx_sad8x16x4d ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vpx_sad8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vpx_variance8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vpx_sub_pixel_variance8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vpx_sad8x8x3 ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vpx_sad8x8x8 ;cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vpx_sad8x8x4d ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vpx_sad4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vpx_variance4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vpx_sub_pixel_variance4x4 ;cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vpx_sad4x4x3 ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vpx_sad4x4x8 ;cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vpx_sad4x4x4d ;# if ARCH_X86 || ARCH_X86_64 cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ;,1642
2331,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;BUG_ON ( dh == NULL ) ;","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;BUG_ON ( dh == NULL ) ;",1643
2332,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;flags = FAULT_FLAG_ALLOW_RETRY ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;flags = FAULT_FLAG_ALLOW_RETRY ;",1644
2333,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , regs , address ) ;",1644
2334,"ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ;","ND_PRINT ( ( ndo , ""%s"" , mldv2_tstr ) ) ;",1645
2335,"trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;return ;","trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;return ;",1645
2336,"case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ;","case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> unary . child -> ident . ident ) ;",1646
2337,"case EXPR_INVERT : case EXPR_NOT :  ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;if ( ok ) * set_rtrn = ! * set_rtrn ;","case EXPR_INVERT : case EXPR_NOT : ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ;if ( ok ) * set_rtrn = ! * set_rtrn ;",1646
2338,while ( ( c != \'\\\,while ( ( c != \'\\\,1647
2339,"( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" ,  & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] ,  & white_point [ 0 ] , & white_point [ 1 ] ) ;image -> chromaticity . red_primary . x = chromaticity [ 0 ] ;break ;}","if ( sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , & white_point [ 0 ] , & white_point [ 1 ] ) == 8 ) {image -> chromaticity . red_primary . x = chromaticity [ 0 ] ;}break ;}",1647
2340,"( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ;image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;break ;","if ( sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) == 2 ) {image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;}break ;",1647
2341,"static int  mptctl_mpt_command ( unsigned long arg )  {struct mpt_ioctl_command karg ;MPT_ADAPTER * ioc ;int iocnum ;if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_mpt_command()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;}rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ;return rc ;","static int mptctl_mpt_command ( MPT_ADAPTER * ioc , unsigned long arg ) {struct mpt_ioctl_command karg ;rc = mptctl_do_mpt_command ( ioc , karg , & uarg -> MF ) ;return rc ;",1648
2342,Image  * image ;MagickBooleanType status ;,Image * image ;int c ;MagickBooleanType status ;,1649
2343,"unsigned int bit , byte , bytes_per_line , height , length ,  padding ,  value , version , width ;","unsigned int bit , byte , bytes_per_line , height , length , padding , version , width ;",1649
2344,"value = XBMInteger ( image , hex_digits ) ;* p ++ = ( unsigned char ) value ;if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) )  * p ++ = ( unsigned char ) ( value >> 8 ) ;}* p ++ = ( unsigned char ) value ;}","c = XBMInteger ( image , hex_digits ) ;if ( c < 0 ) break ;* p ++ = ( unsigned char ) c ;if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) * p ++ = ( unsigned char ) ( c >> 8 ) ;}if ( c < 0 ) break ;* p ++ = ( unsigned char ) c ;}if ( EOFBlob ( image ) != MagickFalse ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}",1649
2345,"if ( bit == 0 )  byte = ( size_t ) ( * p ++ ) ;SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ;","if ( bit == 0 ) byte = ( unsigned int ) ( * p ++ ) ;SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ;",1649
2346,"com -> len = JAS_CAST ( uint_fast16_t , strlen ( buf ) ) ;com -> regid = JPC_COM_LATIN ;if ( ! ( com -> data = JAS_CAST ( uchar * , jas_strdup ( buf ) ) ) ) {abort ( ) ;","com -> len = JAS_CAST ( jas_uchar * , jas_strdup ( buf ) ) ) ) {abort ( ) ;",1650
2347,chanmode_found = 1 ;if ( set_flag == '+' ) {,if ( ! chanmode_found ) {chanmode_found = 1 ;if ( set_flag == '+' ) {,1651
2348,else  {,}else {,1651
2349,"static int decode_uniform ( vp9_reader * r ) {const int l = 8 ;const int v = vp9_read_literal ( r , l - 1 ) ;return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ;}","static int decode_uniform ( vpx_reader * r ) {const int l = 8 ;const int v = vpx_read_literal ( r , l - 1 ) ;return v < m ? v : ( v << 1 ) - m + vpx_read_bit ( r ) ;}",1652
2350,"int is_valid ;if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;giterr_clear ( ) ;is_valid = error != GIT_ECERTIFICATE ;","int is_valid = ( error == GIT_OK ) ;if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;giterr_clear ( ) ;",1653
2351,"void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) {assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ;","void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vp9_tree tree ) {assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ;",1654
2352,"static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd ,  vp9_reader * r ) {if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {const REFERENCE_MODE mode =  ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . comp_inter [ ctx ] [ mode ] ;","static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_reader * r ) {if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {const REFERENCE_MODE mode = ( REFERENCE_MODE ) vpx_read ( r , cm -> fc -> comp_inter_prob [ ctx ] ) ;FRAME_COUNTS * counts = xd -> counts ;if ( counts ) ++ counts -> comp_inter [ ctx ] [ mode ] ;",1655
2353,},return - 1 ;},1656
2354,"if ( ! stream )   fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ;if ( prev ) {res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) ,  & stream -> config . cfg , global -> usage ) ;stream -> config . cfg . g_timebase . den = 1000 ;stream -> config . cfg . g_w = 0 ;stream -> config . cfg . g_h = 0 ;stream -> config . stereo_fmt = STEREO_FORMAT_MONO ;stream -> config . write_webm = 1 ;# if CONFIG_WEBM_IO  stream -> ebml . last_pts_ms = - 1 ;# endif stream -> ebml . debug = global -> debug ;","if ( stream == NULL ) {fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ;}if ( prev ) {res = vpx_codec_enc_config_default ( global -> codec -> codec_interface ( ) , & stream -> config . write_webm = 1 ;# if CONFIG_WEBM_IO stream -> config . cfg , global -> usage ) ;stream -> ebml . last_pts_ns = - 1 ;stream -> ebml . writer = NULL ;stream -> ebml . segment = NULL ;# endif stream -> ebml . debug = global -> debug ;",1657
2355,"ND_PRINT ( ( ndo , ""\\\","ND_PRINT ( ( ndo , ""%s"" , icmp6_tstr ) ) ;",1658
2356,"trunc :  ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ;return ;","trunc : ND_PRINT ( ( ndo , ""[ndp<S2SV_blank>opt]"" ) ) ;return ;",1658
2357,( * re_ast ) -> root_node = NULL ;return ERROR_SUCCESS ;,( * re_ast ) -> levels = 0 ;( * re_ast ) -> root_node = NULL ;return ERROR_SUCCESS ;,1659
2358,"other = unix_peer_get ( sk ) ;if ( other ) {if ( unix_peer ( other ) != sk ) {sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ;if ( unix_recvq_full ( other ) )  writable = 0 ;}sock_put ( other ) ;","if ( writable ) {unix_state_lock ( sk ) ;other = unix_peer ( sk ) ;if ( other && unix_peer ( other ) != sk && unix_recvq_full ( other ) && unix_dgram_peer_wake_me ( sk , other ) ) writable = 0 ;}sock_put ( other ) ;",1660
2359,"ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ;if ( ret <= 0 ) {auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB ,   ""Failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , key -> key -> key , error ) ;return - 1 ;ret = dict_lookup ( iter -> conn -> dict , iter -> pool ,  str_c ( path ) , & key -> value , & error ) ;","str_append ( path , key -> key -> key ) ;ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value , & error ) ;if ( ret > 0 ) {auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s"" , str_c ( path ) , error ) ;return - 1 ;ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value , & error ) ;",1661
2360,if ( A > skb -> len - sizeof ( struct nlattr ) )  return 0 ;if ( nla -> nla_len > A - skb -> len )  return 0 ;,if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ;if ( nla -> nla_len > skb -> len - A ) return 0 ;,1662
2361,icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ;,"icon_file . directory [ i ] . size ;if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) = ReadBlobLSBLong ( image ) ;",1663
2362,"length = icon_file . directory [ i ] . size ;png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ;","length = icon_file . directory [ i ] . size ;png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ;",1663
2363,"stbbr_send ( ""<presence<S2SV_blank>to=\\\'stabber@localhost\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ;assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\\\""On<S2SV_blank>my<S2SV_blank>mobile\\\\"""" ) ) ;prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ;assert_true ( prof_output_exact ( ""unencrypted"" ) ) ;stbbr_send (  ""<message<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost\\\'>""  ""<received<S2SV_blank>xmlns=\\\'urn:xmpp:carbons:2\\\'>"" ""<forwarded<S2SV_blank>xmlns=\\\'urn:xmpp:forward:0\\\'>"" ""<message<S2SV_blank>id=\\\'prof_msg_7\\\'<S2SV_blank>xmlns=\\\'jabber:client\\\'<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>lang=\\\'en\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ;","stbbr_send ( ""<message<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'stabber@localhost\\\'>"" ""<received<S2SV_blank>xmlns=\\\'urn:xmpp:carbons:2\\\'>"" ""<forwarded<S2SV_blank>xmlns=\\\'urn:xmpp:forward:0\\\'>"" ""<message<S2SV_blank>id=\\\'prof_msg_7\\\'<S2SV_blank>xmlns=\\\'jabber:client\\\'<S2SV_blank>type=\\\'chat\\\'<S2SV_blank>lang=\\\'en\\\'<S2SV_blank>to=\\\'stabber@localhost/profanity\\\'<S2SV_blank>from=\\\'buddy1@localhost/mobile\\\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ;",1664
2364,"memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ;SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ;","memcpy ( serial -> value , priv -> cac_id , serial -> len ) ;SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ;",1665
2365,tok -> level = 0 ;tok -> altwarning = 1 ;,tok -> level = 0 ;tok -> altwarning = 1 ;tok -> async_always = 0 ;,1666
2366,return tok ;},return tok ;},1666
2367,if ( av1 -> av1_config ) {GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ;,if ( av1 -> av1_config && av1 -> av1_config -> config ) {GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ;,1667
2368,"GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\\( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;}","GF_Box * dref ;GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\\dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ;( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) dref ;gf_isom_box_add_for_dump_mode ( s , dref ) ;}",1668
2369,"buff [ r ] = \'\\\\0\' ;set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ;","buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) ] = \'\\\\0\' ;set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ;",1669
2370,ASSERT ( dpbSize ) ;dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ;,"if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) {ALOGE ( ""b/28533562"" ) ;android_errorWriteLog ( 0x534e4554 , ""28533562"" ) ;return ( MEMORY_ALLOCATION_ERROR ) ;}ASSERT ( dpbSize ) ;dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ;",1670
2371,"oe_errno = 0 ;if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen )   addrlen_in = * addrlen ;if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in ,  addrlen ) != OE_OK )  {done :  return ret ;","oe_socklen_t addrlen_out = 0 ;oe_errno = 0 ;if ( ! sock || ! addr || ! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ;addrlen_in = * addrlen ;if ( addrlen_in < 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , & addrlen_out ) != OE_OK ) {if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;* addrlen = addrlen_out ;done : return ret ;",1671
2372,"if ( ! nego_read_request_token_or_cookie ( nego , s ) ) {","if ( ! if ( ! nego_read_request_token_or_cookie ( nego , s ) ) return FALSE ) {",1672
2373,"nego_process_negotiation_request ( nego , s ) ;}","nego_process_negotiation_request ( nego , s ) ;}",1672
2374,struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt = NULL ;,struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt_to_free = NULL ;struct ipv6_txoptions * opt = NULL ;,1673
2375,"if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ;if ( addr_len >= sizeof ( struct sockaddr_in6 ) && lsa -> l2tp_scope_id && ipv6_addr_type ( daddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = lsa -> l2tp_scope_id ;else {if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ;daddr = & sk -> sk_v6_daddr ;fl6 . flowlabel = np -> flow_label ;}if ( fl6 . flowi6_oif == 0 ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ;if ( msg -> msg_controllen ) {opt = & opt_space ;memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ;opt -> tot_len = sizeof ( struct ipv6_txoptions ) ;err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ;if ( err < 0 ) {fl6_sock_release ( flowlabel ) ;return err ;}if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) {flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ;if ( opt == NULL )  opt = np -> opt ;",if ( ! opt ) {opt = txopt_get ( np ) ;opt_to_free = opt ;if ( opt == NULL ) opt = np -> opt ;,1673
2376,out :  fl6_sock_release ( flowlabel ) ;return err < 0 ? err : len ;,out : fl6_sock_release ( flowlabel ) ;txopt_put ( opt_to_free ) ;return err < 0 ? err : len ;,1673
2377,"unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ;unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ;uint32_t valign , falign , hdr_size , j ;struct cli_exe_section * exe_sections ;# endif const char * archtype = NULL , * subsystem = NULL ;","unsigned int i , j , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 , rescan = 1 ;unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ;uint32_t valign , falign , hdr_size ;struct cli_exe_section * exe_sections ;# endif while ( rescan == 1 ) {rescan = 0 ;const char * archtype = NULL , * subsystem = NULL ;",1674
2378,"
","exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ;exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ;exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ;exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ;exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ;exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ;exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ;exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ;exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ;if ( exe_sections [ i ] . rsz ) {if ( ! CLI_ISCONTAINED ( 0 , fsize , exe_sections [ i ] . uraw , exe_sections [ i ] . ursz ) || exe_sections [ i ] . raw >= fsize ) {cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>or<S2SV_blank>exists<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\\if ( nsections == 1 ) {free ( section_hdr ) ;free ( exe_sections ) ;if ( DETECT_BROKEN_PE ) {cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ;return CL_VIRUS ;}return CL_CLEAN ;}for ( j = i ;j < nsections - 1 ;j ++ ) memcpy ( & exe_sections [ j ] , & exe_sections [ j + 1 ] , sizeof ( struct cli_exe_section ) ) ;for ( j = i ;j < nsections - 1 ;j ++ ) memcpy ( & section_hdr [ j ] , & section_hdr [ j + 1 ] , sizeof ( struct pe_image_section_hdr ) ) ;nsections -- ;rescan = 1 ;break ;}}}}for ( i = 0 ;i < nsections ;i ++ ) {",1674
2379,"# endif  for ( i = 0 ;strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ;sname [ 8 ] = 0 ;exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ;exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ;exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ;exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ;exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ;exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ;exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ;exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ;exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ;","# endif for ( i = 0 ;strncpy ( sname , ( char * ) section_hdr [ i ] . Name , 8 ) ;sname [ 8 ] = 0 ;",1674
2380,"cli_dbgmsg ( ""Section<S2SV_blank>contains<S2SV_blank>free<S2SV_blank>space\\\}}if ( exe_sections [ i ] . chr & 0x20000000 ) cli_dbgmsg ( ""Section\\\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>executable\\\if ( exe_sections [ i ] . chr & 0x80000000 ) cli_dbgmsg ( ""Section\\\'s<S2SV_blank>memory<S2SV_blank>is<S2SV_blank>writeable\\\if ( DETECT_BROKEN_PE && ( ! valign || ( exe_sections [ i ] . urva % valign ) ) ) {cli_dbgmsg ( ""VirtualAddress<S2SV_blank>is<S2SV_blank>misaligned\\\cli_dbgmsg ( ""------------------------------------\\\cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ;free ( section_hdr ) ;free ( exe_sections ) ;return CL_VIRUS ;}if ( exe_sections [ i ] . rsz ) {if ( exe_sections [ i ] . raw >= fsize ) {cli_dbgmsg ( ""Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\\cli_dbgmsg ( ""------------------------------------\\\free ( section_hdr ) ;free ( exe_sections ) ;if ( DETECT_BROKEN_PE ) {cli_append_virus ( ctx , ""Heuristics.Broken.Executable"" ) ;return CL_VIRUS ;}return CL_CLEAN ;}","
",1674
2381,"dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ;dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ;while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 )  {dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ;usleep ( 5 ) ;return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ;}","dm9000WriteReg ( DM9000_EPAR , 0x40 | address ) ;dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR ) ;while ( ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE ) != 0 ) {}dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS ) ;usleep ( 5 ) ;return ( dm9000ReadReg ( DM9000_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_EPDRL ) ;",1675
2382,"if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer ,  & bufferoffset ,  i , t2p -> tiff_length ) ) {","if ( ! t2p_process_jpeg_strip ( stripbuffer , & striplength , buffer , t2p -> tiff_datasize , & bufferoffset , i , t2p -> tiff_length ) ) {",1676
2383,"if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) &&  ! inode_capable ( inode , CAP_CHOWN ) )  return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  attr -> ia_mode &= ~ S_ISGID ;","if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ;if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) attr -> ia_mode &= ~ S_ISGID ;",1677
2384,"static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) {","static BOOL nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) {",1678
2385,"UINT32 tempWidth ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;for ( y = 0 ;y ++ )  {","UINT32 tempWidth ;if ( ! context || data || ( scanline == 0 ) ) return FALSE ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ;if ( rw < scanline * 2 ) return FALSE ;for ( y = 0 ;y ++ ) {",1678
2386,"
",return TRUE ;,1678
2387,},},1678
2388,static int isofs_read_inode ( struct inode * inode )  {,"static int isofs_read_inode ( struct inode * inode , int relocated ) {",1679
2389,"parse_rock_ridge_inode ( de , inode ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;","parse_rock_ridge_inode ( de , inode , relocated ) ;if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ;",1679
2390,"rcu_read_lock ( ) ;__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;rcu_read_unlock ( ) ;","__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;rcu_read_unlock ( ) ;",1680
2391,( * re_ast ) -> root_node = NULL ;return ERROR_SUCCESS ;,( * re_ast ) -> levels = 0 ;( * re_ast ) -> root_node = NULL ;return ERROR_SUCCESS ;,1681
2392,"rc = cib_tls_signon ( cib , & ( private -> command ) ) ;}rc = cib_tls_signon ( cib , & ( private -> callback ) ) ;}","rc = cib_tls_signon ( cib , & ( private -> command ) , FALSE ) ;}rc = cib_tls_signon ( cib , & ( private -> callback ) , TRUE ) ;}",1682
2393,msg . msg_name = ( struct sockaddr * ) & address ;msg . msg_namelen = sizeof ( address ) ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;,msg . msg_name = addr ? ( struct sockaddr * ) & address : NULL ;msg . msg_namelen = 0 ;if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ;,1683
2394,"int num00 , tmp_err , n , sr = 0 ;int step_param = 3 ;int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ;int new_mv_mode_penalty = 256 ;const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ;while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ;tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv ,  step_param ,  x -> sadperbit16 , & num00 , & v_fn_ptr ,  x -> nmvjointcost , x -> mvcost , ref_mv ) ;best_mv -> row = tmp_mv . row ;best_mv -> col = tmp_mv . col ;","int num00 , tmp_err , n ;const int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ;int step_param = 3 ;int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ;const int sr = get_search_range ( cpi ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ;}# endif tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;* best_mv = tmp_mv ;",1684
2395,"tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv ,  step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr ,  x -> nmvjointcost ,  x -> mvcost , ref_mv ) ;best_mv -> row = tmp_mv . row ;best_mv -> col = tmp_mv . col ;","tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;* best_mv = tmp_mv ;",1684
2396,"SET_ERRNO ( ENOTSUP ,  ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" ,  filename , page_size , off ) ;","SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ;goto error ;}if ( off + page_size > h -> size ) {SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ;",1685
2397,return merged ;},merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ;return merged ;},1686
2398,"if ( used_address && used_address -> name_len == msg_sys -> msg_namelen &&   ! memcmp ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ) {memcpy ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ;","if ( used_address && msg_sys -> msg_name && used_address -> name_len == msg_sys -> msg_namelen && ! memcmp ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ) {if ( msg_sys -> msg_name ) memcpy ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ;",1687
2399,struct skcipher_ctx * ctx = ask -> private ;unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ;struct skcipher_sg_list * sgl ;struct scatterlist * sg ;unsigned long iovlen ;struct iovec * iov ;int err = - EAGAIN ;int used ;long copied = 0 ;lock_sock ( sk ) ;msg -> msg_namelen = 0 ;,"
",1688
2400,"size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one ,  offset ,  pixel_info_length ;ssize_t count , y ;if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;","size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ;ssize_t count , offset , y ;if ( ( offset < 0 ) || ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ;",1689
2401,if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  {,if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {,1689
2402,p = pixels + offset ;if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length )  {,"if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) {if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;pixel_info = RelinquishVirtualMemory ( pixel_info ) ;ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;}p = pixels + offset ;if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) {",1689
2403,"if ( ( r = cipher_get_keyiv ( cc , enc -> iv , enc -> iv_len ) ) != 0 ) return r ;if ( ( b = sshbuf_new ( ) ) == NULL ) return SSH_ERR_ALLOC_FAIL ;if ( ( r = sshbuf_put_u32 ( b , comp -> type ) ) != 0 ||  ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 ||  ( r = sshbuf_put_cstring ( b , comp -> name ) ) != 0 ) goto out ;","if ( ( r = sshbuf_put_u32 ( b , comp -> type ) ) != 0 || ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 || ( r = sshbuf_put_cstring ( b , comp -> name ) ) != 0 ) goto out ;",1690
2404,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",1691
2405,cib_client_t * client = user_data ;if ( client == NULL ) {,cib_client_t * client = user_data ;int csock = 0 ;if ( client == NULL ) {,1692
2406,"free ( client -> name ) ;free ( client -> callback_id ) ;free ( client ) ;crm_trace ( ""Freed<S2SV_blank>the<S2SV_blank>cib<S2SV_blank>client"" ) ;","if ( client -> remote_auth_timeout ) {g_source_remove ( client -> remote_auth_timeout ) ;}if ( client -> encrypted ) {# ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) {void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ;csock = GPOINTER_TO_INT ( sock_ptr ) ;if ( client -> handshake_complete ) {gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ;}gnutls_deinit ( * client -> session ) ;gnutls_free ( client -> session ) ;}# endif }else {csock = GPOINTER_TO_INT ( client -> session ) ;}client -> session = NULL ;if ( csock > 0 ) {close ( csock ) ;}free ( client -> recv_buf ) ;free ( client -> name ) ;free ( client -> callback_id ) ;free ( client ) ;crm_trace ( ""Freed<S2SV_blank>the<S2SV_blank>cib<S2SV_blank>client"" ) ;",1692
2407,"* p = thread -> twups ;thread -> twups = thread ;work ++ ;if ( ! iswhite ( uv ) ) markvalue ( g , uv -> v ) ;","lua_assert ( ! isold ( thread ) || thread -> openupval == NULL ) ;* p = thread -> twups ;thread -> twups = thread ;lua_assert ( getage ( uv ) <= getage ( thread ) ) ;work ++ ;if ( ! iswhite ( uv ) ) markvalue ( g , uv -> v ) ;",1693
2408,px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;,if ( ! px -> ft ) {return FALSE ;}px -> ft -> data = px ;px -> ft -> accept = prpl_xfer_accept ;,1694
2409,return FALSE ;},transport -> credssp = NULL ;return FALSE ;},1695
2410,"olddentry = ovl_dentry_upper ( old ) ;newdentry = ovl_dentry_upper ( new ) ;if ( newdentry ) {newdentry = opaquedir ;opaquedir = NULL ;dget ( newdentry ) ;newdentry = lookup_one_len ( new -> d_name . name , new_upperdir ,  new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) )  goto out_unlock ;}err = - ESTALE ;if ( olddentry -> d_parent != old_upperdir )  goto out_dput ;if ( newdentry -> d_parent != new_upperdir )   goto out_dput ;if ( olddentry == trap ) goto out_dput ;if ( newdentry == trap ) goto out_dput ;","olddentry = lookup_one_len ( old -> d_name . name , new_upperdir , new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) ) goto out_unlock ;}err = - ESTALE ;if ( olddentry -> d_parent != old_upperdir ) goto out_dput ;if ( newdentry -> d_parent != new_upperdir ) goto out_dput ;if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ;newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ;err = PTR_ERR ( newdentry ) ;if ( IS_ERR ( newdentry ) ) goto out_dput_old ;err = - ESTALE ;if ( ovl_dentry_upper ( new ) ) {if ( newdentry != opaquedir ) goto out_dput ;if ( newdentry != ovl_dentry_upper ( new ) ) goto out_dput ;if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ;}out_dput_old : dput ( olddentry ) ;",1696
2411,"out_unlock :  unlock_rename ( new_upperdir , old_upperdir ) ;","out_unlock : unlock_rename ( new_upperdir , old_upperdir ) ;",1696
