,source,target,group
0,"DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ;if ( cfg -> is_custom_debug_file ) {fclose ( cfg -> debug_file ) ;","DBG ( ""Restored<S2SV_blank>privileges"" ) ;",855
1,"if ( item_num > 65536 ) {av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\","if ( item_num > 65536 || item_num < 0 ) {av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\",856
2,"for ( pad = ( ( 3 * w ) % 4 ) ? ( 4 - ( 3 * w ) % 4 ) : 0 ;else {fdest = fopen ( outfile , ""wb"" ) ;if ( ! fdest ) {fprintf ( stderr , ""ERROR<S2SV_blank>-><S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\\return 1 ;}w = ( int ) image -> comps [ 0 ] . w ;h = ( int ) image -> comps [ 0 ] . h ;fprintf ( fdest , ""BM"" ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + 54 + 1024 + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + 54 + 1024 + w * ( w % 2 ) ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 54 + 1024 ) & 0xff , ( ( 54 + 1024 ) >> 8 ) & 0xff , ( ( 54 + 1024 ) >> 16 ) & 0xff , ( ( 54 + 1024 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 40 ) & 0xff , ( ( 40 ) >> 8 ) & 0xff , ( ( 40 ) >> 16 ) & 0xff , ( ( 40 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( w ) & 0xff ) , ( OPJ_UINT8 ) ( ( w ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( w ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( ( h ) & 0xff ) , ( OPJ_UINT8 ) ( ( h ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c"" , ( 1 ) & 0xff , ( ( 1 ) >> 8 ) & 0xff ) ;fprintf ( fdest , ""%c%c"" , ( 8 ) & 0xff , ( ( 8 ) >> 8 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 0 ) & 0xff , ( ( 0 ) >> 8 ) & 0xff , ( ( 0 ) >> 16 ) & 0xff , ( ( 0 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( OPJ_UINT8 ) ( h * w + h * ( w % 2 ) ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 8 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 16 ) & 0xff , ( OPJ_UINT8 ) ( ( h * w + h * ( w % 2 ) ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 7834 ) & 0xff , ( ( 7834 ) >> 8 ) & 0xff , ( ( 7834 ) >> 16 ) & 0xff , ( ( 7834 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ;fprintf ( fdest , ""%c%c%c%c"" , ( 256 ) & 0xff , ( ( 256 ) >> 8 ) & 0xff , ( ( 256 ) >> 16 ) & 0xff , ( ( 256 ) >> 24 ) & 0xff ) ;if ( image -> comps [ 0 ] . prec > 8 ) {adjustR = ( int ) image -> comps [ 0 ] . prec - 8 ;printf ( ""BMP<S2SV_blank>CONVERSION:<S2SV_blank>Truncating<S2SV_blank>component<S2SV_blank>0<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>bits<S2SV_blank>to<S2SV_blank>8<S2SV_blank>bits\\\}else adjustR = 0 ;for ( i = 0 ;i < 256 ;i ++ ) {fprintf ( fdest , ""%c%c%c%c"" , i , i , i , 0 ) ;}for ( i = 0 ;i < w * h ;i ++ ) {int r ;r = image -> comps [ 0 ] . data [ w * h - ( ( i ) / ( w ) + 1 ) * w + ( i ) % ( w ) ] ;r += ( image -> comps [ 0 ] . sgnd ? 1 << ( image -> comps [ 0 ] . prec - 1 ) : 0 ) ;r = ( ( r >> adjustR ) + ( ( r >> ( adjustR - 1 ) ) % 2 ) ) ;if ( r > 255 ) r = 255 ;else if ( r < 0 ) r = 0 ;fprintf ( fdest , ""%c"" , ( OPJ_UINT8 ) r ) ;if ( ( i + 1 ) % w == 0 ) {for ( ( pad = w % 4 ) ? ( 4 - w % 4 ) : 0 ;pad > 0 ;pad -- )  fprintf ( fdest , ""%c"" , 0 ) ;}}fclose ( fdest ) ;}",for ( pad = ( w % 4 ) ? ( 4 - w % 4 ) : 0 ;,857
3,"OPJ_UINT32 x , y ;OPJ_UINT8 * pix ;x = y = 0U ;while ( y < height ) {","OPJ_UINT32 x , y , written ;OPJ_UINT8 * pix ;x = y = written = 0U ;while ( y < height ) {",858
4,* pix = c1 ;},* pix = c1 ;written ++ ;},858
5,}if ( ( OPJ_UINT32 ) c & 1U ) {return OPJ_TRUE ;},"written ++ ;}if ( ( OPJ_UINT32 ) c & 1U ) {if ( written != width * height ) {fprintf ( stderr , ""warning,<S2SV_blank>image\\\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\\return OPJ_FALSE ;}}return OPJ_TRUE ;",858
6,"id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ;if ( id < 0 ) {ipc_rcu_putref ( msq , msg_rcu_free ) ;return id ;}msq -> q_stime = msq -> q_rtime = 0 ;msq -> q_ctime = get_seconds ( ) ;","msq -> q_stime = msq -> q_rtime = 0 ;msq -> q_ctime = get_seconds ( ) ;id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ;if ( id < 0 ) {ipc_rcu_putref ( msq , msg_rcu_free ) ;return id ;}",859
7,"static void write_interp_filter ( INTERP_FILTER filter ,  struct vp9_write_bit_buffer * wb ) {const int filter_to_literal [ ] = {vp9_wb_write_bit ( wb , filter == SWITCHABLE ) ;if ( filter != SWITCHABLE )  vp9_wb_write_literal ( wb , filter_to_literal [ filter ] , 2 ) ;}","static void write_interp_filter ( INTERP_FILTER filter , struct vpx_write_bit_buffer * wb ) {const int filter_to_literal [ ] = {vpx_wb_write_bit ( wb , filter == SWITCHABLE ) ;if ( filter != SWITCHABLE ) vpx_wb_write_literal ( wb , filter_to_literal [ filter ] , 2 ) ;}",860
8,"static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) {int i , j ;","static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vpx_reader * r ) {int i , j ;",861
9,"JAS_DBGLOG ( 101 , ( ""jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\\result = malloc ( size ) ;","JAS_DBGLOG ( 101 , ( ""jas_malloc(%zu)\\\result = malloc ( size ) ;",862
10,return ret <= 0 ? ret : - EIO ;},return ret < 0 ? ret : - EIO ;},863
11,if ( op -> operands [ 1 ] . immediate == - 1 ) {return - 1 ;}immediate = op -> operands [ 1 ] . immediate * op -> operands [ 1 ] . sign ;if ( op -> operands [ 0 ] . type & OT_GPREG && ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) {if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) ) {if ( ! ( op -> operands [ 1 ] . type & OT_CONSTANT ) && op -> operands [ 1 ] . extended ) {,if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED ) {,864
12,data [ l ++ ] = 0xc7 ;data [ l ++ ] = 0xc0 | op -> operands [ 0 ] . reg ;data [ l ++ ] = 0xb8 | op -> operands [ 0 ] . reg ;,data [ l ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ;return l ;}if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) {mod = 0x2 ;if ( op -> operands [ 1 ] . offset > 127 ) {mod = 0x4 ;}}if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) {if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) {data [ l ++ ] = 0x5 ;if ( op -> operands [ 1 ] . offset > 127 ) {data [ l ++ ] = 0x80 | op -> operands [ 0 ] . reg ;,864
13,data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 4 ;data [ l ++ ] = getsib ( op -> operands [ 0 ] . scale [ 0 ] ) << 6 | op -> operands [ 0 ] . regs [ 0 ] << 3 | 5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;return l ;}if ( ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) {if ( op -> operands [ 0 ] . reg == X86R_UNDEFINED || op -> operands [ 1 ] . reg == X86R_UNDEFINED ) {return - 1 ;}mod = 0x3 ;data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . reg ;,data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ;,864
14,data [ l ++ ] = 0xa1 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;if ( a -> bits == 64 ) {data [ l ++ ] = offset >> 32 ;data [ l ++ ] = offset >> 40 ;data [ l ++ ] = offset >> 48 ;data [ l ++ ] = offset >> 54 ;return l ;if ( op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | ( op -> operands [ 1 ] . regs [ 0 ] - 8 ) ;,data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ;if ( op -> operands [ 1 ] . offset > 127 ) {mod = 0x1 ;}else {if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) {data [ l ++ ] = 0x0d ;}else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) {data [ l ++ ] = 0x05 ;}else {data [ l ++ ] = mod << 5 | op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] - 8 ) ;,864
15,data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ;data [ l ++ ] = 0x8b ;data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {,data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ;data [ l ++ ] = 0x8b ;data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ;}data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;}else {if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {base = 5 ;}if ( base ) {data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ;}else {data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ;}if ( offset || base ) {data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;}return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {,864
16,data [ l ++ ] = 0x25 ;}data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;}if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {,data [ l ++ ] = 0x25 ;}data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) {if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) {data [ l ++ ] = 0x67 ;}data [ l ++ ] = 0x48 ;}}else if ( op -> operands [ 1 ] . type & OT_DWORD ) {data [ l ++ ] = 0x44 ;}else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) {data [ l ++ ] = 0x67 ;}if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) {data [ l ++ ] = 0x48 ;}}if ( op -> operands [ 0 ] . type & OT_WORD ) {data [ l ++ ] = 0x66 ;data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ;}else {data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ;}if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) {if ( a -> bits == 64 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ;data [ l ++ ] = 0x25 ;}else {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;}if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {,864
17,"if ( access ( path , F_OK ) ) {","if ( safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount ) ) {",865
18,"if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) {ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\\\'%s\\\'<S2SV_blank>on<S2SV_blank>\\\'%s\\\'"" , console -> name , path ) ;","if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) {ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\\\'%s\\\'<S2SV_blank>on<S2SV_blank>\\\'%s\\\'"" , console -> name , path ) ;",865
19,"static int fsmVerify ( const char * path , rpmfi fi )  {","static int fsmVerify ( const char * path , rpmfi fi , const struct stat * fsb ) {",866
20,"
",uid_t luid = dsb . st_uid ;,866
21,"if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;rc = fsmStat ( path , 0 , & dsb ) ;if ( rc == RPMERR_ENOENT ) rc = 0 ;if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;}","if ( S_ISDIR ( dsb . st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) return 0 ;rc = fsmStat ( path , 0 , & dsb ) ;if ( rc == RPMERR_ENOENT ) rc = 0 ;if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;}",866
22,"int r = ( int ) recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt ,   p_dcb -> mtu , MSG_DONTWAIT ) ;if ( r > 0 ) {","int r = ( int ) TEMP_FAILURE_RETRY ( recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , p_dcb -> mtu , MSG_DONTWAIT ) ) ;if ( r > 0 ) {",867
23,"dentry -> d_fsdata = ( void * ) ns -> ops ;d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ;","dentry -> d_flags |= DCACHE_RCUACCESS ;dentry -> d_fsdata = ( void * ) ns -> ops ;d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ;",868
24,"uint8_t * buf = mempool_alloc ( buf_pool ) ;struct l2tp_avp_t * avp ;uint8_t * ptr ;int n ;int len = sizeof ( pack -> hdr ) ;ptr = buf + sizeof ( pack -> hdr ) ;list_for_each_entry ( attr , & pack -> attrs , entry ) {avp -> type = htons ( attr -> attr -> id ) ;avp -> M = attr -> M ;avp -> H = attr -> H ;avp -> length = sizeof ( * avp ) + attr -> length ;* ( uint16_t * ) ptr = htons ( * ( uint16_t * ) ptr ) ;if ( attr -> H ) memcpy ( avp -> val , attr -> val . octets , attr -> length ) ;else switch ( attr -> attr -> type ) {case ATTR_TYPE_INT16 : * ( int16_t * ) avp -> val = htons ( attr -> val . int16 ) ;break ;case ATTR_TYPE_INT32 : * ( int32_t * ) avp -> val = htonl ( attr -> val . int32 ) ;break ;case ATTR_TYPE_INT64 : * ( uint64_t * ) avp -> val = htobe64 ( attr -> val . uint64 ) ;break ;case ATTR_TYPE_STRING : case ATTR_TYPE_OCTETS : memcpy ( avp -> val , attr -> val . string , attr -> length ) ;break ;}ptr += sizeof ( * avp ) + attr -> length ;len += sizeof ( * avp ) + attr -> length ;}pack -> hdr . length = htons ( len ) ;memcpy ( buf , & pack -> hdr , sizeof ( pack -> hdr ) ) ;n = sendto ( sock , buf , ntohs ( pack -> hdr . length ) , 0 ,  & pack -> addr , sizeof ( pack -> addr ) ) ;mempool_free ( buf ) ;","struct l2tp_hdr_t * hdr ;struct l2tp_avp_t * avp ;uint8_t * buf , * ptr ;int n , len ;buf = mempool_alloc ( buf_pool ) ;hdr = ( struct l2tp_hdr_t * ) buf ;ptr = ( uint8_t * ) ( hdr + 1 ) ;len = sizeof ( pack -> hdr ) ;list_for_each_entry ( attr , & pack -> attrs , entry ) {avp -> flags = htons ( ( attr -> M ? L2TP_AVP_FLAG_M : 0 ) | ( attr -> H ? L2TP_AVP_FLAG_H : 0 ) | ( ( sizeof ( * avp ) + attr -> length ;* ( uint16_t * ) ptr = htons ( * ( uint16_t * ) ptr ) ;if ( attr -> H ) memcpy ( avp -> val , attr -> val . octets , attr -> length ) & L2TP_AVP_LEN_MASK ) ) ;hdr -> flags = htons ( pack -> hdr . flags ) ;",869
25,"if ( n != ntohs ( pack -> hdr . length ) ) {if ( conf_verbose )  log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>write<S2SV_blank>(%i/%i)\\\}","if ( n != ntohs ( pack -> hdr . length ) ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>write<S2SV_blank>(%i/%i)\\\}",869
26,"if ( strlen ( str ) >= sizeof ( lowstr ) )  {if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 ||  DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {","if ( strlen ( str ) > MAXDATELEN ) {if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {errno = PGTYPES_TS_BAD_TIMESTAMP ;return ( noresult ) ;}switch ( dtype ) {case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) {",870
27,"memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , bs - sizeof ( struct extendedFileEntry ) ) ;","memcpy ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ;if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ;if ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , bs - sizeof ( struct extendedFileEntry ) ) ;",871
28,if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) {if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ;,if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) {if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ;,871
29,"myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = options . compression ?  ""zlib@openssh.com,zlib,none"" : ""none,zlib@openssh.com,zlib"" ;myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ;","myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = options . compression ? ""zlib@openssh.com,none"" : ""none,zlib@openssh.com"" ;myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ;",872
30,"if ( level >= ms -> c . len ) {len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ;ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ;","if ( level >= ms -> c . len = 20 + level ) * sizeof ( * ms -> c . li ) ;ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ;",873
31,"if ( ! sock_flag ( sk , SOCK_ZAPPED ) )  return - EINVAL ;","if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ;",874
32,if ( sk -> sk_state != TCP_CLOSE )  goto out_unlock ;,if ( sk -> sk_state != TCP_CLOSE ) goto out_unlock ;,874
33,}audio_conv_info -> ver_major = ver_major ;,usb_conv_info -> class_data_type = USB_CONV_AUDIO ;}else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) {return 0 ;}audio_conv_info -> ver_major = ver_major ;,875
34,"goto reset ;}SAS_DPRINTK ( ""trying<S2SV_blank>to<S2SV_blank>find<S2SV_blank>task<S2SV_blank>0x%p\\\res = sas_scsi_find_task ( task ) ;switch ( res ) {case TASK_IS_DONE : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\\sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;sas_scsi_clear_queue_lu ( work_q , cmd ) ;tmf_resp = sas_recover_I_T ( task -> dev ) ;if ( tmf_resp == TMF_RESP_FUNC_COMPLETE || tmf_resp == - ENODEV ) {struct domain_device * dev = task -> dev ;SAS_DPRINTK ( ""I_T<S2SV_blank>%016llx<S2SV_blank>recovered\\\","sas_eh_finish_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;continue ;sas_eh_defer_cmd ( cmd ) ;sas_scsi_clear_queue_lu ( work_q , cmd ) ;",876
35,void close_connection ( h2o_http2_conn_t * conn )  {}},int close_connection ( h2o_http2_conn_t * conn ) {return - 1 ;}return 0 ;},877
36,"# if ENABLE_BGP_VNC  bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ;","# if ENABLE_BGP_VNC_ATTR bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ;",878
37,while ( res == 0 && dev ) {struct expander_device * ex = & dev -> ex_dev ;,if ( res == 0 && dev ) {struct expander_device * ex = & dev -> ex_dev ;,879
38,"dev = NULL ;res = sas_find_bcast_dev ( port_dev , & dev ) ;","
",879
39,"return ;}ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>%s,<S2SV_blank>MD<S2SV_blank>Level<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , tok2str ( cfm_opcode_values , ""unknown<S2SV_blank>(%u)"" , cfm_common_header -> opcode ) , CFM_EXTRACT_MD_LEVEL ( cfm_common_header -> mdlevel_version ) , length ) ) ;if ( ndo -> ndo_vflag < 1 ) {return ;}ND_PRINT ( ( ndo , ""\\\tptr += sizeof ( const struct cfm_common_header_t ) ;tlen = length - sizeof ( struct cfm_common_header_t ) ;if ( cfm_common_header -> first_tlv_offset > tlen ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , tlen ) ) ;return ;}switch ( cfm_common_header -> opcode ) {case CFM_OPCODE_CCM : msg_ptr . cfm_ccm = ( const struct cfm_ccm_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ccm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>1,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ccm ) ) ) ;return ;if ( tlen < sizeof ( * msg_ptr . cfm_ccm ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ccm ) ;ccm_interval = CFM_EXTRACT_CCM_INTERVAL ( cfm_common_header -> flags ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[CCM<S2SV_blank>Interval<S2SV_blank>%u%s]"" , ccm_interval , cfm_common_header -> flags & CFM_CCM_RDI_FLAG ? "",<S2SV_blank>RDI"" : """" ) ) ;if ( ccm_interval ) {ND_PRINT ( ( ndo , ""\\\}ND_PRINT ( ( ndo , ""\\\namesp = msg_ptr . cfm_ccm -> names ;names_data_remaining = sizeof ( msg_ptr . cfm_ccm -> names ) ;md_nameformat = * namesp ;namesp ++ ;names_data_remaining -- ;if ( md_nameformat != CFM_CCM_MD_FORMAT_NONE ) {md_namelength = * namesp ;namesp ++ ;names_data_remaining -- ;ND_PRINT ( ( ndo , ""\\\if ( md_namelength > names_data_remaining - 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining - 2 ) ) ;return ;}md_name = namesp ;ND_PRINT ( ( ndo , ""\\\switch ( md_nameformat ) {case CFM_CCM_MD_FORMAT_DNS : case CFM_CCM_MD_FORMAT_CHAR : safeputs ( ndo , md_name , md_namelength ) ;break ;case CFM_CCM_MD_FORMAT_MAC : if ( md_namelength == 6 ) {ND_PRINT ( ( ndo , ""\\\}else {ND_PRINT ( ( ndo , ""\\\}break ;case CFM_CCM_MA_FORMAT_8021 : default : print_unknown_data ( ndo , md_name , ""\\\}namesp += md_namelength ;names_data_remaining -= md_namelength ;}else {ND_PRINT ( ( ndo , ""\\\}ma_nameformat = * namesp ;namesp ++ ;names_data_remaining -- ;ma_namelength = * namesp ;namesp ++ ;names_data_remaining -- ;ND_PRINT ( ( ndo , ""\\\if ( ma_namelength > names_data_remaining ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining ) ) ;return ;}ma_name = namesp ;ND_PRINT ( ( ndo , ""\\\switch ( ma_nameformat ) {case CFM_CCM_MA_FORMAT_CHAR : safeputs ( ndo , ma_name , ma_namelength ) ;break ;case CFM_CCM_MA_FORMAT_8021 : case CFM_CCM_MA_FORMAT_VID : case CFM_CCM_MA_FORMAT_INT : case CFM_CCM_MA_FORMAT_VPN : default : print_unknown_data ( ndo , ma_name , ""\\\}break ;case CFM_OPCODE_LTM : msg_ptr . cfm_ltm = ( const struct cfm_ltm_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>4,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltm ) ) ) ;return ;}if ( tlen < sizeof ( * msg_ptr . cfm_ltm ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ltm ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltm_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case CFM_OPCODE_LTR : msg_ptr . cfm_ltr = ( const struct cfm_ltr_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltr ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>5,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltr ) ) ) ;return ;}if ( tlen < sizeof ( * msg_ptr . cfm_ltr ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ltr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltr_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case CFM_OPCODE_LBR : case CFM_OPCODE_LBM : default : print_unknown_data ( ndo , tptr , ""\\\break ;}tptr += cfm_common_header -> first_tlv_offset ;tlen -= cfm_common_header -> first_tlv_offset ;while ( tlen > 0 ) {cfm_tlv_header = ( const struct cfm_tlv_header_t * ) tptr ;ND_TCHECK2 ( * tptr , 1 ) ;cfm_tlv_type = cfm_tlv_header -> type ;ND_PRINT ( ( ndo , ""\\\if ( cfm_tlv_type == CFM_TLV_END ) {return ;}if ( tlen < sizeof ( struct cfm_tlv_header_t ) ) goto tooshort ;ND_TCHECK2 ( * tptr , sizeof ( struct cfm_tlv_header_t ) ) ;cfm_tlv_len = EXTRACT_16BITS ( & cfm_tlv_header -> length ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , cfm_tlv_len ) ) ;tptr += sizeof ( struct cfm_tlv_header_t ) ;tlen -= sizeof ( struct cfm_tlv_header_t ) ;tlv_ptr = tptr ;if ( tlen < cfm_tlv_len ) goto tooshort ;ND_TCHECK2 ( * tptr , cfm_tlv_len ) ;hexdump = FALSE ;switch ( cfm_tlv_type ) {case CFM_TLV_PORT_STATUS : if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_port_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ;break ;case CFM_TLV_INTERFACE_STATUS : if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_interface_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ;break ;case CFM_TLV_PRIVATE : if ( cfm_tlv_len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Sub-Type<S2SV_blank>%u"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( tptr ) ) , EXTRACT_24BITS ( tptr ) , * ( tptr + 3 ) ) ) ;hexdump = TRUE ;break ;case CFM_TLV_SENDER_ID : {u_int chassis_id_type , chassis_id_length ;u_int mgmt_addr_length ;if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}",goto next_tlv ;,880
40,"return ;}return ;}case CFM_CHASSIS_ID_MAC_ADDRESS :  ND_PRINT ( ( ndo , ""\\\case CFM_CHASSIS_ID_NETWORK_ADDRESS :  hexdump |= cfm_network_addr_print ( ndo , tptr ) ;break ;","return ;}return ;}case CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case CFM_CHASSIS_ID_NETWORK_ADDRESS : hexdump |= cfm_network_addr_print ( ndo , tptr ) ;",880
41,"return ;}if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {return ;}cfm_tlv_len -= mgmt_addr_length ;tptr += mgmt_addr_length ;ND_PRINT ( ( ndo , ""\\\return ;if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {cfm_tlv_len -= mgmt_addr_length ;tptr += mgmt_addr_length ;","return ;}ND_PRINT ( ( ndo , ""\\\if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {return ;}cfm_tlv_len -= mgmt_addr_length ;hex_print ( ndo , ""\\\tptr += mgmt_addr_length ;ND_PRINT ( ( ndo , ""\\\return ;ND_PRINT ( ( ndo , ""\\\if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {cfm_tlv_len -= mgmt_addr_length ;hex_print ( ndo , ""\\\tptr += mgmt_addr_length ;",880
42,tptr += cfm_tlv_len ;tlen -= cfm_tlv_len ;,next_tlv : tptr += cfm_tlv_len ;tlen -= cfm_tlv_len ;,880
43,"jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\\return - 1 ;","jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\\return - 1 ;}if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) {jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\\return - 1 ;}if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) {jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\\return - 1 ;",881
44,"jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data ,  tile -> tcomps [ 2 ] . data ) ;","jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , tile -> tcomps [ 2 ] . data ) ;",881
45,if ( ret )   return - EFAULT ;ptr -> next = NULL ;i < 16 ;i ++ ) ptr -> reply [ i ] = 0 ;ptr -> resultcode = 0 ;ptr -> kernel_data = NULL ;if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) {,ptr -> next = NULL ;ptr -> kernel_data = NULL ;if ( ret ) return - EFAULT ;if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) {,882
46,if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock )  return 0 ;,char * p ;int len ;if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ;,883
47,"if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) {truncate = 1 ;strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ;retnamlen += rr -> len - 5 ;break ;","len = rr -> len - 5 ) >= 254 ) {truncate = 1 ;p = memchr ( rr -> u . NM . name , len ) ;retnamlen += rr -> len - 5 ;break ;",883
48,return - 1 ;},return 1 ;},884
49,"return 0 ;}else if ( ( strcmp ( s , ""-v"" ) == 0 ) || ( strcmp ( s , ""-version"" ) == 0 ) ) {fprintf ( stderr , ""%s<S2SV_blank>%d.%d\\\return 0 ;}else if ( strcmp ( s , ""-V"" ) == 0 ) {VerboseFlag = 1 ;return - 1 ;}return - 1 ;}return - 1 ;}",return 1 ;return - 1 ;}return - 1 ;}return 1 ;},884
50,"if ( ( inbuffer = ReadInput ( inname ) ) == 0 ) return ( - 1 ) ;if ( ( outfile = fopen ( outname , ""w"" ) ) == 0 ) {exit ( - 1 ) ;}","if ( ( inbuffer = ReadInput ( inname ) ) == 0 ) return ( 1 ) ;if ( ( outfile = fopen ( outname , ""w"" ) ) == 0 ) {exit ( 1 ) ;}",884
51,return ( - 1 ) ;},return ( 1 ) ;},884
52,"delim = strchr ( pat -> p . str , \':\' ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , delim ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;mutt_error ( _ ( ""Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s"" ) , pat -> p . str ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;","delim = strchr ( pat -> p . str , false , \':\' ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , delim , false ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str , false ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str , false ) ;mutt_buffer_addstr ( buf , term ) ;mutt_error ( _ ( ""Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s"" ) , pat -> p . str , false ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;",885
53,"static INLINE void right_shift_8x8 ( __m128i * res , int const bit ) {const __m128i kOne = _mm_set1_epi16 ( 1 ) ;const int bit_m02 = bit - 2 ;","static INLINE void right_shift_8x8 ( __m128i * res , const int bit ) {",886
54,"if ( bit_m02 >= 0 ) {__m128i k_const_rounding = _mm_slli_epi16 ( kOne , bit_m02 ) ;res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , k_const_rounding ) ;res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , k_const_rounding ) ;res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , k_const_rounding ) ;res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , k_const_rounding ) ;res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , k_const_rounding ) ;res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , k_const_rounding ) ;res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , k_const_rounding ) ;res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , k_const_rounding ) ;","if ( bit == 2 ) {const __m128i const_rounding = _mm_set1_epi16 ( 1 ) ;res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , const_rounding ) ;res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , const_rounding ) ;res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , const_rounding ) ;res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , const_rounding ) ;res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , const_rounding ) ;res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , const_rounding ) ;res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , const_rounding ) ;res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , const_rounding ) ;",886
55,"res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , bit ) ;res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , bit ) ;res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , bit ) ;res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , bit ) ;res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , bit ) ;res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , bit ) ;res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , bit ) ;res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , bit ) ;","if ( bit == 1 ) {res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 1 ) ;res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 1 ) ;res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 1 ) ;res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 1 ) ;res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 1 ) ;res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 1 ) ;res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 1 ) ;res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 1 ) ;}else {res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 2 ) ;res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 2 ) ;res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 2 ) ;res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 2 ) ;res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 2 ) ;res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 2 ) ;res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 2 ) ;res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 2 ) ;}",886
56,if ( ! ext4_handle_valid ( handle ) )  return 0 ;,if ( ! EXT4_SB ( sb ) -> s_journal ) return 0 ;,887
57,"newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ;atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ;","inet_sk ( newsk ) -> mc_list = NULL ;newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ;atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ;",888
58,"# endif status = nfsd4_encode_bitmap ( xdr , bmval0 , bmval1 , bmval2 ) ;","# endif status = nfsd4_encode_bitmap ( xdr , supp [ 0 ] , supp [ 1 ] , supp [ 2 ] ) ;",889
59,"status = nfsd4_encode_bitmap ( xdr , NFSD_SUPPATTR_EXCLCREAT_WORD0 ,  NFSD_SUPPATTR_EXCLCREAT_WORD1 , NFSD_SUPPATTR_EXCLCREAT_WORD2 ) ;","u32 supp [ 3 ] ;memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ;supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ;supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ;supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ;status = nfsd4_encode_bitmap ( xdr , NFSD_SUPPATTR_EXCLCREAT_WORD0 , NFSD_SUPPATTR_EXCLCREAT_WORD1 , NFSD_SUPPATTR_EXCLCREAT_WORD2 ) ;",889
60,if ( wsctx && wsctx -> readbuflen )  return TRUE ;,if ( wsctx && wsctx -> readlen ) return TRUE ;,890
61,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct inet_sock * newinet ;,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt ;struct inet_sock * newinet ;,891
62,"dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ;return newsk ;}if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ;if ( ! dst ) {struct flowi6 fl6 ;dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ;if ( ! dst ) goto out ;}newsk = dccp_create_openreq_child ( sk , req , skb ) ;if ( newsk == NULL ) goto out_nonewsk ;__ip6_dst_store ( newsk , dst , NULL , NULL ) ;newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ;newdp6 = ( struct dccp6_sock * ) newsk ;newinet = inet_sk ( newsk ) ;newinet -> pinet6 = & newdp6 -> inet6 ;newnp = inet6_sk ( newsk ) ;memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ;newnp -> saddr = ireq -> ir_v6_loc_addr ;newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ;newsk -> sk_bound_dev_if = ireq -> ir_iif ;newinet -> inet_opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;newnp -> pktoptions = NULL ;newnp -> opt = NULL ;newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;if ( np -> opt != NULL )   newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ;inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( newnp -> opt != NULL )   inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen +   newnp -> opt -> opt_flen ) ;dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ;","opt = rcu_dereference ( np -> opt != NULL ) newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ;inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ;dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ;",891
63,prev = NULL ;for ( vma = mm -> mmap ;,if ( ! mmget_still_valid ( mm ) ) goto skip_mm ;prev = NULL ;for ( vma = mm -> mmap ;,892
64,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,skip_mm : up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,892
65,pExpr -> iTable = pX -> iIdxCur ;pExpr -> iColumn = pX -> iIdxCol ;,"assert ( pExpr -> y . pTab != 0 ) ;pExpr -> affExpr = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ;pExpr -> iTable = pX -> iIdxCur ;pExpr -> iColumn = pX -> iIdxCol ;",893
66,"char * path = server . diskstore_path ;if ( ( retval = stat ( path , & sb ) == - 1 ) && errno != ENOENT ) {","char * path = server . ds_path ;if ( ( retval = stat ( path , & sb ) == - 1 ) && errno != ENOENT ) {",894
67,"Stream_Read_UINT32 ( s , scopeCount ) ;scopeList -> count = scopeCount ;","Stream_Read_UINT32 ( s , scopeCount ) ;if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE ;scopeList -> count = scopeCount ;",895
68,"void vp9_idct4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {if ( eob > 1 )  vp9_idct4x4_16_add ( input , dest , stride ) ;else  vp9_idct4x4_1_add ( input , dest , stride ) ;}","void vp9_idct4x4_add ( const tran_low_t * input , uint8_t * dest , int stride , int eob ) {if ( eob > 1 ) vpx_idct4x4_16_add ( input , dest , stride ) ;else vpx_idct4x4_1_add ( input , dest , stride ) ;}",896
69,INST_HANDLER ( sts ) {int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,INST_HANDLER ( sts ) {if ( len < 4 ) {return ;}int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,897
70,"unsigned int maxw , maxh , max ;int offset , upb ;unsigned int i , j ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;for ( i = 0U ;++ i )  {for ( j = 0U ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {","size_t maxw , maxh , max , offx , loopmaxw ;int offset , upb ;size_t i ;upb = ( int ) img -> comps [ 0 ] . prec ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;offx = img -> x0 & 1U ;loopmaxw = maxw - offx ;for ( i = 0U ;+ i )  {++ i ) {size_t j ;if ( offx > 0U ) {sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ;++ y ;++ r ;++ g ;++ b ;}for ( j = 0U ;j < ( loopmaxw & ~ ( unsigned int ) 1U ) ;j += 2U ) {",898
71,"if ( j < maxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;","if ( j < loopmaxw ) {sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ;",898
72,# if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = maxw ;img -> comps [ 2 ] . h = maxh ;# else img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;# endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;},img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;img -> comps [ 2 ] . h = img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ;img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails : free ( r ) ;if ( g ) free ( g ) ;free ( b ) ;},898
73,"int i , j , offset ;uint8_t type ;","int i , offset ;uint8_t type ;",899
74,"u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ;if ( suf < 0x0200 ) {map -> s_partition_type = UDF_VIRTUAL_MAP15 ;map -> s_partition_func = udf_get_pblock_virt15 ;}else {map -> s_partition_type = UDF_VIRTUAL_MAP20 ;map -> s_partition_func = udf_get_pblock_virt20 ;}}else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) {uint32_t loc ;struct sparingTable * st ;struct sparablePartitionMap * spm =  ( struct sparablePartitionMap * ) gpm ;","if ( udf_load_sparable_map ( sb , map , ( struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ;",899
75,ps_dec_op -> u4_output_present = 0 ;ps_dec_op -> u4_frame_decoded_flag = 0 ;ps_dec -> i4_frametype = - 1 ;ps_dec -> i4_content_type = - 1 ;{if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) {ps_dec -> u1_top_bottom_decoded = 0 ;}},"
",900
76,"ps_dec -> u4_prev_nal_skipped = 0 ;ps_dec -> u2_cur_mb_addr = 0 ;ps_dec -> u2_total_mbs_coded = 0 ;ps_dec -> u2_cur_slice_num = 0 ;ps_dec -> cur_dec_mb_num = 0 ;ps_dec -> cur_recon_mb_num = 0 ;ps_dec -> u4_first_slice_in_pic = 2 ;ps_dec -> u1_first_pb_nal_in_pic = 1 ;ps_dec -> u1_slice_header_done = 0 ;ps_dec -> u1_dangling_field = 0 ;ps_dec -> u4_dec_thread_created = 0 ;ps_dec -> u4_bs_deblk_thread_created = 0 ;ps_dec -> u4_cur_bs_mb_num = 0 ;ps_dec -> u4_start_recon_deblk = 0 ;DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\\ps_dec -> u4_pic_buf_got = 0 ;do {pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ;u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ;pu1_bitstrm_buf = ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . pv_base ;u4_next_is_aud = 0 ;buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ;if ( buflen == - 1 ) buflen = 0 ;buflen = MIN ( buflen , ( WORD32 ) ( ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . u4_mem_size - 8 ) ) ;bytes_consumed = buflen + u4_length_of_start_code ;ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ;if ( buflen >= MAX_NAL_UNIT_SIZE ) {ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ;H264_DEC_DEBUG_PRINT ( ""\\\ps_dec -> i4_error_code = 1 << IVD_CORRUPTEDDATA ;ps_dec_op -> e_pic_type = - 1 ;ih264d_signal_decode_thread ( ps_dec ) ;if ( ps_dec -> u4_pic_buf_got == 0 ) {if ( ps_dec -> i4_header_decoded == 3 ) {ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ;}","
",900
77,"
",if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) {ps_dec -> u1_top_bottom_decoded = 0 ;}if ( ps_dec -> u4_pic_buf_got == 1 ) {if ( 1 == ps_dec -> u1_last_pic_not_decoded ) {ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ;if ( ret != OK ) return ret ;ret = ih264d_end_of_pic ( ps_dec ) ;if ( ret != OK ) return ret ;}else {ret = ih264d_end_of_pic ( ps_dec ) ;if ( ret != OK ) return ret ;}},900
78,if ( ret != 0 )  {,if ( ret != 0 ) {,900
79,"DATA_SYNC ( ) ;H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\\","DATA_SYNC ( ) ;H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\\",900
80,"sy = data -> ds . dimension_size [ 1 ] ;sz = data -> ds . dimension_size [ 2 ] ;dzy = dz * dy ;szy = sz * sy ;size = data -> datalayout_chunk [ data -> ds . dimensionality ] ;log ( ""elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\\if ( ! ( output = malloc ( elements * size ) ) ) {return MYSOFA_NO_MEMORY ;}for ( e = 0 ;e < entries_used * 2 ;e ++ ) {if ( node_type == 0 ) {key = readValue ( reader , reader -> superblock . size_of_lengths ) ;}else {size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ;filter_mask = ( uint32_t ) readValue ( reader , 4 ) ;if ( filter_mask ) {log ( ""TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\\free ( output ) ;return MYSOFA_INVALID_FORMAT ;}for ( j = 0 ;j < data -> ds . dimensionality ;j ++ ) {start [ j ] = readValue ( reader , 8 ) ;log ( ""start<S2SV_blank>%d<S2SV_blank>%lu\\\}if ( readValue ( reader , 8 ) ) {break ;}child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ;log ( ""<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\\store = ftell ( reader -> fhd ) ;if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) {free ( output ) ;return errno ;}if ( ! ( input = malloc ( size_of_chunk ) ) ) {free ( output ) ;return MYSOFA_NO_MEMORY ;}if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) {free ( output ) ;free ( input ) ;return MYSOFA_INVALID_FORMAT ;}olen = elements * size ;err = gunzip ( size_of_chunk , input , & olen , output ) ;free ( input ) ;log ( ""<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\\if ( err || olen != elements * size ) {free ( output ) ;return MYSOFA_INVALID_FORMAT ;}switch ( data -> ds . dimensionality ) {case 1 : for ( i = 0 ;i < olen ;i ++ ) {b = i / elements ;x = i % elements + start [ 0 ] ;if ( x < sx ) {j = x * size + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;",j = x * size + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;,901
81,if ( y < sy && x < sx ) {j = ( ( x * sy + y ) * size ) + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;,if ( y < sy && x < sx ) {j = ( ( x * sy + y ) * size ) + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;,901
82,if ( z < sz && y < sy && x < sx ) {j = ( x * szy + y * sz + z ) * size + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;},if ( z < sz && y < sy && x < sx ) {j = ( x * szy + y * sz + z ) * size + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;},901
83,ExprList_Init ( & state -> expr_list ) ;FstringParser_check_invariants ( state ) ;,state -> fmode = 0 ;ExprList_Init ( & state -> expr_list ) ;FstringParser_check_invariants ( state ) ;,902
84,return ret ;},if ( ! ret ) invalidate_lstat_cache ( ) ;return ret ;},903
85,if ( ! awaiting_character ) {recovery_abort ( ) ;,if ( ! awaiting_character || ! recovery_started ) {recovery_abort ( ) ;,904
86,"int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ;if ( sent == ( signed ) len ) osi_free ( buf ) ;","int sent = TEMP_FAILURE_RETRY ( send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ) ;if ( sent == ( signed ) len ) osi_free ( buf ) ;",905
87,return - EINVAL ;},kfree ( a ) ;return - EINVAL ;},906
88,"if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ;if ( tmp == NULL ) goto failed ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""lineno\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_col_offset ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""col_offset\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ;return 1 ;","if ( lookup_attr_id ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""lineno\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ;return 1 ;}else {int res ;}if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""col_offset\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ;else {Py_CLEAR ( tmp ) ;",907
89,"if ( exists_not_none ( obj , & PyId_type ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_type ) ;if ( tmp == NULL ) goto failed ;}else {type = NULL ;if ( exists_not_none ( obj , & PyId_name ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ;if ( tmp == NULL ) goto failed ;}else {name = NULL ;if ( _PyObject_HasAttrId ( obj , & PyId_body ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ;","if ( lookup_attr_id ( obj , & PyId_type ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_type , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type = NULL ;}else {int res ;if ( lookup_attr_id ( obj , & PyId_name , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;name = NULL ;}else {if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler"" ) ;return 1 ;}else {Py_ssize_t i ;",907
90,"stmt_ty value ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler"" ) ;return 1 ;","stmt_ty val ;res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( body , i , val ) ;}",907
91,"u8 reset ;int ret , pos = 0 ;hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! hx ) return - ENOMEM ;reset = 1 ;if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 )  err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;","u8 * buf ;int ret , pos = 0 ;u16 cpu_cs_register = cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) err ( ""could<S2SV_blank>not<S2SV_blank>stop<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;",908
92,"kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( hx ) ;return ret ;","kfree ( hx ) ;return ret ;reset = 0 ;if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register ;buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ;if ( ! buf ) return - ENOMEM ;hx = ( struct hexline * ) buf ;buf [ 0 ] = 1 ;if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 ) != 1 ) {err ( ""could<S2SV_blank>not<S2SV_blank>restart<S2SV_blank>the<S2SV_blank>USB<S2SV_blank>controller<S2SV_blank>CPU."" ) ;kfree ( buf ) ;return ret ;",908
93,"void set_header ( HttpResponse res , const char * name , const char * value ) {HttpHeader h = NULL ;h -> value = Str_dup ( value ) ;if ( res -> headers ) {","void set_header ( HttpResponse res , const char * name , const char * value , ... ) {HttpHeader h = NULL ;va_list ap ;va_start ( ap , value ) ;h -> value = Str_vcat ( value , ap ) ;va_end ( ap ) ;if ( res -> headers ) {",909
94,"char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ;char * mask_decoded5 ;mask_decoded = NULL ;mask_decoded2 = NULL ;mask2 = weechat_string_replace ( mask , dir_separator , ""\\\\01"" ) ;if ( ! mask2 ) goto end ;mask_decoded = weechat_buffer_string_replace_local_var ( buffer , mask2 ) ;if ( ! mask_decoded ) goto end ;mask_decoded2 = weechat_string_replace ( mask_decoded , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ;if ( ! mask_decoded2 ) goto end ;# ifdef __CYGWIN__ mask_decoded3 = weechat_string_replace ( mask_decoded2 , ""\\\\\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ;# else mask_decoded3 = strdup ( mask_decoded2 ) ;# endif if ( ! mask_decoded3 ) goto end ;mask_decoded4 = weechat_string_replace ( mask_decoded3 , ""\\\\01"" , dir_separator ) ;if ( ! mask_decoded4 ) goto end ;length = strlen ( mask_decoded4 ) + 256 + 1 ;mask_decoded5 = malloc ( length ) ;if ( ! mask_decoded5 )  goto end ;mask_decoded5 [ 0 ] = \'\\\\0\' ;strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ;if ( weechat_config_boolean ( logger_config_file_name_lower_case ) )  weechat_string_tolower ( mask_decoded5 ) ;if ( weechat_logger_plugin -> debug ) {weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) ,  mask , mask_decoded5 ) ;}if ( mask_decoded )   free ( mask_decoded ) ;if ( mask_decoded2 )  free ( mask_decoded2 ) ;if ( mask_decoded3 )  free ( mask_decoded3 ) ;if ( mask_decoded4 )  free ( mask_decoded4 ) ;return mask_decoded5 ;}","char * mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 ;mask3 = NULL ;mask4 = NULL ;mask5 = NULL ;mask6 = NULL ;mask7 = NULL ;mask_decoded2 = NULL ;length = strlen ( mask ) + 256 + 1 ;mask_decoded5 = malloc ( length ) ;if ( ! mask_decoded5 ) goto end ;mask_decoded5 [ 0 ] = \'\\\\0\' ;strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) == 0 ) mask2 [ 0 ] = \'\\\\0\' ;mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\\\01"" ) ;if ( ! mask3 ) goto end ;mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ;if ( ! mask4 ) goto end ;mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ;if ( ! mask5 ) goto end ;# ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ;# else mask6 = strdup ( mask5 ) ;# endif if ( ! mask6 ) goto end ;mask7 = weechat_string_replace ( mask6 , ""\\\\01"" , dir_separator ) ;if ( ! mask7 ) goto end ;if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) weechat_string_tolower ( mask7 ) ;if ( weechat_logger_plugin -> debug ) {weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) , mask , mask7 ) ;}if ( mask3 ) free ( mask_decoded ) ;if ( mask_decoded2 ) free ( mask3 ) ;if ( mask4 ) free ( mask_decoded3 ) ;if ( mask_decoded4 ) free ( mask6 ) ;return mask7 ;}",910
95,xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;}if ( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&  ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) {,if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) {xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;}else {xWantedSize = 0 ;}}if ( ( xWantedSize > 0 ) && ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) && ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) {,911
96,"static int em_call ( struct x86_emulate_ctxt * ctxt )  {long rel = ctxt -> src . val ;jmp_rel ( ctxt , rel ) ;return em_push ( ctxt ) ;","static int em_call ( struct x86_emulate_ctxt * ctxt ) {int rc ;long rel = ctxt -> src . val ;rc = jmp_rel ( ctxt , rel ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;return em_push ( ctxt ) ;",912
97,"if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , ""chunked"" ) != NULL ) ) {msr -> reqbody_should_exist = 1 ;","if ( ( transfer_encoding != NULL ) && ( m_strcasestr ( transfer_encoding , ""chunked"" ) != NULL ) ) {msr -> reqbody_should_exist = 1 ;",913
98,"struct desc_struct * desc ;short sel ;if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ;if ( user_64bit_mode ( regs ) ) {unsigned long base ;if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ;else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ;else base = 0 ;return base ;}desc = get_desc ( sel ) ;if ( ! desc )  return - 1L ;return get_desc_base ( desc ) ;}",struct desc_struct desc ;short sel ;desc = get_desc ( sel ) ;if ( ! desc ) return - 1L ;return get_desc_base ( & desc ) ;},914
99,entry . uncompressed_filesize = PHAR_GET_32 ( zipentry . uncompsize ) ;,entry . uncompressed_filesize || read <= 8 = PHAR_GET_32 ( zipentry . uncompsize ) ;,915
100,if ( read != entry . uncompressed_filesize ) {php_stream_close ( sigfile ) ;,if ( read != entry . uncompressed_filesize ) {php_stream_close ( sigfile ) ;,915
101,"
",userfaultfd_ctx_get ( fork_nctx ) ;,916
102,spin_unlock ( & ctx -> event_wqh . lock ) ;ret = 0 ;,spin_unlock ( & ctx -> event_wqh . lock ) ;ret = 0 ;,916
103,"if ( ! ret ) {spin_lock ( & ctx -> event_wqh . lock ) ;uwq = list_first_entry ( & fork_event ,  typeof ( * uwq ) , wq . entry ) ;userfaultfd_event_complete ( ctx , uwq ) ;}spin_unlock ( & ctx -> event_wqh . lock ) ;}","spin_lock ( & ctx -> event_wqh . lock ) ;userfaultfd_ctx_put ( fork_nctx ) ;uwq = list_first_entry ( & fork_event , typeof ( * uwq ) , wq . entry ) ;if ( likely ( ! ret ) ) userfaultfd_event_complete ( ctx , uwq ) ;}else {if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ;}spin_unlock ( & ctx -> event_wqh . lock ) ;",916
104,"const int bh = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ;vp9_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride ,  pd -> dst . buf , pd -> dst . stride ) ;","# if CONFIG_VP9_HIGHBITDEPTH if ( x -> e_mbd . cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vpx_highbd_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride , x -> e_mbd . bd ) ;return ;}# endif vpx_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ;",917
105,"static unsigned short len = 0 ;char buff [ 13 ] , * ret_msg = NULL ;","static size_t len = 0 ;char buff [ 13 ] , * ret_msg = NULL ;",918
106,"# if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject :  return g_NPN_GetValue_real ( instance , variable , value ) ;default : switch ( variable & 0xff ) {","# if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : return g_NPN_GetValue_real ( instance , variable , value ) ;default : switch ( variable & 0xff ) {",919
107,"if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) &&  ( IN_DEV_SHARED_MEDIA ( out_dev ) ||   inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) {flags |= RTCF_DOREDIRECT ;do_cache = false ;}","if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) && skb -> protocol == htons ( ETH_P_IP ) && ( IN_DEV_SHARED_MEDIA ( out_dev ) || inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ;",920
108,"if ( ! x -> e_mbd . left_context ) return ;vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",921
109,"static struct cifsSesInfo *  cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username )  {struct list_head * tmp ;list_for_each ( tmp , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) )   continue ;++ ses -> ses_count ;","static struct cifsSesInfo * cifs_find_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * vol ) {+ ses -> ses_count ;list_for_each_entry ( ses , & server -> smb_ses_list ) {ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ;if ( strncmp ( ses -> userName , vol -> username , MAX_USERNAME_SIZE ) ) continue ;if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ;}++ ses -> ses_count ;",922
110,"case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;break ;","case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;break ;",923
111,"case 0xe9 : case 0xeb :  jmp_rel ( ctxt , ctxt -> src . val ) ;ctxt -> dst . type = OP_NONE ;","case 0xe9 : case 0xeb : rc = jmp_rel ( ctxt , ctxt -> src . val ) ;ctxt -> dst . type = OP_NONE ;",923
112,"case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) ctxt -> dst . val = ctxt -> src . val ;case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;break ;","case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) rc = ctxt -> dst . val = ctxt -> src . val ;case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) jmp_rel ( ctxt , ctxt -> src . val ) ;break ;",923
113,"x < ( ( ssize_t ) image -> columns - 7 ) ;SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ;",x < ( ( ssize_t ) image -> columns - 3 ) ;p ++ ;,924
114,for ( x = 0 ;x += 4 )  {,for ( x = 0 ;x += 4 ) {,924
115,"p ++ ;q ++ ;}if ( ( image -> columns % 4 ) != 0 ) {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ;SetPixelIndex ( indexes + x , index ) ;SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ;if ( ( image -> columns % 4 ) >= 1 )  {if ( ( image -> columns % 4 ) >= 2 )  {",p ++ ;}if ( ( image -> columns % 4 ) > 1 ) {if ( ( image -> columns % 4 ) >= 2 ) {,924
116,"skb = sock_alloc_send_skb ( sk ,  hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;","struct frag_hdr fhdr ;skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;",925
117,"skb -> csum = 0 ;}err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;if ( ! err ) {struct frag_hdr fhdr ;return 0 ;}kfree_skb ( skb ) ;return err ;","skb -> csum = 0 ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",925
118,PIXA * pixa ;L_REGPARAMS * rp ;,"PIXA * pixa , * pixa2 ;L_REGPARAMS * rp ;",926
119,"pixGammaTRCMasked ( pix2 , pix2 , pixim , 1.0 , 60 , 190 ) ;regTestWritePixAndCheck ( rp , pix2 , IFF_JFIF_JPEG ) ;pixaAddPix ( pixa , pix2 , L_INSERT ) ;pixDestroy ( & pixim ) ;startTimer ( ) ;pixim = pixCreate ( w , h , 1 ) ;pixRasterop ( pixim , XS , YS , WS , HS , PIX_SET , NULL , 0 , 0 ) ;pixGetBackgroundRGBMap ( pixs , pixim , NULL , SIZE_X , SIZE_Y , BINTHRESH , MINCOUNT , & pixmr , & pixmg , & pixmb ) ;fprintf ( stderr , ""Time<S2SV_blank>for<S2SV_blank>color<S2SV_blank>adaptmap<S2SV_blank>gen:<S2SV_blank>%7.3f\\\regTestWritePixAndCheck ( rp , pixmr , IFF_PNG ) ;regTestWritePixAndCheck ( rp , pixmg , IFF_PNG ) ;regTestWritePixAndCheck ( rp , pixmb , IFF_PNG ) ;pixaAddPix ( pixa , pixmr , L_INSERT ) ;pixaAddPix ( pixa , pixmg , L_INSERT ) ;pixaAddPix ( pixa , pixmb , L_INSERT ) ;startTimer ( ) ;pixmri = pixGetInvBackgroundMap ( pixmr , BGVAL , SMOOTH_X , SMOOTH_Y ) ;pixmgi = pixGetInvBackgroundMap ( pixmg , BGVAL , SMOOTH_X , SMOOTH_Y ) ;pixmbi = pixGetInvBackgroundMap ( pixmb , BGVAL , SMOOTH_X , SMOOTH_Y ) ;fprintf ( stderr , ""Time<S2SV_blank>for<S2SV_blank>color<S2SV_blank>inv<S2SV_blank>map<S2SV_blank>generation:<S2SV_blank>%7.3f\\\regTestWritePixAndCheck ( rp , pixmri , IFF_PNG ) ;regTestWritePixAndCheck ( rp , pixmgi , IFF_PNG ) ;regTestWritePixAndCheck ( rp , pixmbi , IFF_PNG ) ;pixaAddPix ( pixa , pixmri , L_INSERT ) ;pixaAddPix ( pixa , pixmgi , L_INSERT ) ;pixaAddPix ( pixa , pixmbi , L_INSERT ) ;startTimer ( ) ;pix1 = pixApplyInvBackgroundRGBMap ( pixs , pixmri , pixmgi , pixmbi , SIZE_X , SIZE_Y ) ;fprintf ( stderr , ""Time<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>color<S2SV_blank>inv<S2SV_blank>maps:<S2SV_blank>%7.3f\\\regTestWritePixAndCheck ( rp , pix1 , IFF_JFIF_JPEG ) ;pixaAddPix ( pixa , pix1 , L_INSERT ) ;pix2 = pixGammaTRCMasked ( NULL , pix1 , pixim , 1.0 , 0 , 190 ) ;pixInvert ( pixim , pixim ) ;pixGammaTRCMasked ( pix2 , pix2 , pixim , 1.0 , 60 , 190 ) ;regTestWritePixAndCheck ( rp , pix2 , IFF_JFIF_JPEG ) ;pixaAddPix ( pixa , pix2 , L_INSERT ) ;pixDestroy ( & pixim ) ;startTimer ( ) ;pixim = pixCreate ( w , h , 1 ) ;pixRasterop ( pixim , XS , YS , WS , HS , PIX_SET , NULL , 0 , 0 ) ;pix1 = pixBackgroundNorm ( pixs , pixim , NULL , 5 , 10 , BINTHRESH , 20 , BGVAL , SMOOTH_X , SMOOTH_Y ) ;","pixa2 = pixaCreate ( 3 ) ;pix1 = pixRead ( ""weasel8.png"" ) ;pixGammaTRC ( pix1 , pix1 , 1.0 , 0 , 270 ) ;pixaAddPix ( pixa2 , pix1 , L_COPY ) ;pixGetDimensions ( pix1 , & w , & h , NULL ) ;pixRasterop ( pix1 , 0 , 0 , 5 , h , PIX_SET , NULL , 0 , 0 ) ;pixRasterop ( pix1 , 20 , BGVAL , SMOOTH_X , SMOOTH_Y ) ;",926
120,"pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ;pixWrite ( ""/tmp/lept/adapt/results.jpg"" , pix1 , IFF_JFIF_JPEG ) ;pixDisplayWithTitle ( pix1 , 100 , 0 , NULL , rp -> display ) ;pixDestroy ( & pix1 ) ;pixaDestroy ( & pixa ) ;","pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ;pixWrite ( ""/tmp/lept/adapt/results.jpg"" , pix1 , IFF_JFIF_JPEG ) ;pixDisplayWithTitle ( pix1 , 100 , 0 , NULL , rp -> display ) ;pixaDestroy ( & pixa2 ) ;pixDestroy ( & pix2 ) ;pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ;pixWrite ( ""/tmp/lept/adapt/results.jpg"" , pix1 , IFF_JFIF_JPEG ) ;pixDisplayWithTitle ( pix1 , 50 , 0 , NULL , rp -> display ) ;pixDestroy ( & pix1 ) ;pixaDestroy ( & pixa ) ;",926
121,"strncpy ( str , ""?["" , len ) ;itostr ( token , & str [ 2 ] , 10 ) ;strncat ( str , ""]"" , len ) ;","espruino_snprintf ( str , len , ""?[%d]"" , token ) ;",927
122,"static void count_segs ( VP9_COMP * cpi , const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;xd -> mi = mi_8x8 ;segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ;const BLOCK_SIZE bsize = mi_8x8 [ 0 ] -> mbmi . sb_type ;const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map ,  bsize , mi_row , mi_col ) ;","static void count_segs ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi_8x8 , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) {xd -> mi = mi_8x8 ;segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ;const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;const int pred_segment_id = get_segment_id ( cm , cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;",928
123,if ( dst == NULL || src == NULL ) return ERROR ;if ( dst -> entry_capacity < src -> entry_count + dst -> entry_count ) return ERROR ;,if ( dst == NULL || src == NULL ) return ERROR ;if ( src -> entry_count + dst -> entry_count < src -> entry_count ) return ERROR ;if ( src -> data_count + dst -> data_count < src -> data_count ) return ERROR ;if ( dst -> entry_capacity < src -> entry_count + dst -> entry_count ) return ERROR ;,929
124,"cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) :  jas_stream_tmpfile ( ) ;","cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ;",930
125,return - EINVAL ;},dev_kfree_skb ( skb ) ;return - EINVAL ;},931
126,malloc_called += 1 ;return malloc ( size ) ;,malloc_called = 1 ;return malloc ( size ) ;,932
127,"StringBuffer_append ( res -> outputbuffer , ""%s"" , buf ) ;}","escapeHTML ( res -> outputbuffer , buf ) ;}",933
128,if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 &&  rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,if ( * rsize >= 62 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,934
129,if ( index > MAX_SUPPORTED_TV_TIMING )  return false ;,if ( index >= MAX_SUPPORTED_TV_TIMING ) return false ;,935
130,if ( index == 1 ) {mode -> crtc_htotal -= 1 ;mode -> crtc_vtotal -= 1 ;}break ;case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ;if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 )  return false ;,if ( index >= MAX_SUPPORTED_TV_TIMING_V1_2 ) return false ;,935
131,NEED_IP ( 1 ) ;}copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS )  if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) {const unsigned char * ie = ip + t ;,"NEED_IP ( 1 , 0 ) ;}copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( t , 15 ) && HAVE_OP ( t , 15 ) ) ) {const unsigned char * ie = ip + t ;",936
132,NEED_OP ( t ) ;NEED_IP ( t + 3 ) ;do {,"NEED_OP ( t , 0 ) ;NEED_IP ( t , 3 ) ;do {",936
133,NEED_OP ( 2 ) ;op [ 0 ] = m_pos [ 0 ] ;,"NEED_OP ( 2 , 0 ) ;op [ 0 ] = m_pos [ 0 ] ;",936
134,NEED_IP ( 1 ) ;}NEED_IP ( 2 ) ;},"NEED_IP ( 1 , 0 ) ;}NEED_IP ( 2 , 0 ) ;}",936
135,NEED_IP ( 1 ) ;}NEED_IP ( 2 ) ;},"NEED_IP ( 1 , 0 ) ;}NEED_IP ( 2 , 0 ) ;}",936
136,if ( likely ( HAVE_OP ( t + 15 ) ) ) {do {,"if ( likely ( HAVE_OP ( t , 15 ) ) ) {do {",936
137,if ( HAVE_IP ( 6 ) ) {state = next ;,"if ( HAVE_IP ( 6 , 0 ) ) {state = next ;",936
138,NEED_OP ( t ) ;do {,"NEED_OP ( t , 0 ) ;do {",936
139,NEED_OP ( t ) ;op [ 0 ] = m_pos [ 0 ] ;,"NEED_OP ( t , 0 ) ;op [ 0 ] = m_pos [ 0 ] ;",936
140,"# if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS )  if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) {COPY4 ( op , ip ) ;NEED_IP ( t + 3 ) ;NEED_OP ( t ) ;while ( t > 0 ) {","# if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( 6 , 0 ) && HAVE_OP ( 4 , 0 ) ) ) {COPY4 ( op , ip ) ;NEED_IP ( t , 3 ) ;NEED_OP ( t , 0 ) ;while ( t > 0 ) {",936
141,"boolean_t owner = B_FALSE ;boolean_t groupmbr = B_FALSE ;uid_t uid = crgetuid ( cr ) ;mutex_enter ( & zdp -> z_acl_lock ) ;if ( FUID_INDEX ( zdp -> z_uid ) != 0 || FUID_INDEX ( zdp -> z_gid ) != 0 ) {goto out_slow ;}if ( uid == zdp -> z_uid ) {owner = B_TRUE ;if ( zdp -> z_mode & S_IXUSR ) {goto out ;}else {goto out_slow ;}}if ( groupmember ( zdp -> z_gid , cr ) ) {groupmbr = B_TRUE ;if ( zdp -> z_mode & S_IXGRP ) {goto out ;}else {goto out_slow ;}}if ( ! owner && ! groupmbr ) {if ( zdp -> z_mode & S_IXOTH ) {goto out ;}}out : mutex_exit ( & zdp -> z_acl_lock ) ;return ( 0 ) ;out_slow : mutex_exit ( & zdp -> z_acl_lock ) ;","
",937
142,"if ( ! n || ! buf || ! buf_size ) {o2 = 6 + n -> offset ;if ( ( o2 + 10 < o2 ) || ( o2 + 10 < 10 ) || ( o2 + 10 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;return ;}if ( buf [ o2 + 6 ] == 1 ) n -> order = EXIF_BYTE_ORDER_INTEL ;else if ( buf [ o2 + 6 + 1 ] == 1 ) n -> order = EXIF_BYTE_ORDER_MOTOROLA ;o2 += 8 ;c = exif_get_short ( buf + o2 , n -> order ) ;if ( ( ! ( c & 0xFF ) ) && ( c > 0x500 ) ) {if ( n -> order == EXIF_BYTE_ORDER_INTEL ) {n -> order = EXIF_BYTE_ORDER_MOTOROLA ;}else {n -> order = EXIF_BYTE_ORDER_INTEL ;}}break ;case olympusV2 : datao = o2 ;o2 += 8 ;if ( ( o2 + 4 < o2 ) || ( o2 + 4 < 4 ) || ( o2 + 4 > buf_size ) ) return ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Parsing<S2SV_blank>Olympus<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>v2<S2SV_blank>(0x%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] ) ;","if ( CHECKOVERFLOW ( o2 , buf_size , 10 ) ) {if ( CHECKOVERFLOW ( o2 , buf_size , 4 ) ) return ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Parsing<S2SV_blank>Olympus<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>v2<S2SV_blank>(0x%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] ) ;",938
143,"if ( ( ! ( c & 0xFF ) ) && ( c > 0x500 ) ) {if ( n -> order == EXIF_BYTE_ORDER_INTEL ) {n -> order = EXIF_BYTE_ORDER_MOTOROLA ;}else {n -> order = EXIF_BYTE_ORDER_INTEL ;}}break ;case nikonV2 : o2 += 6 ;if ( ( o2 + 12 < o2 ) || ( o2 + 12 < 12 ) || ( o2 + 12 > buf_size ) ) return ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Parsing<S2SV_blank>Nikon<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>v2<S2SV_blank>(0x%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>"" ""%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] , buf [ o2 + 4 ] , buf [ o2 + 5 ] , buf [ o2 + 6 ] , buf [ o2 + 7 ] ) ;","if ( CHECKOVERFLOW ( o2 , buf_size , 12 ) ) return ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataOlympus"" , ""Parsing<S2SV_blank>Nikon<S2SV_blank>maker<S2SV_blank>note<S2SV_blank>v2<S2SV_blank>(0x%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>"" ""%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x,<S2SV_blank>%02x)..."" , buf [ o2 + 0 ] , buf [ o2 + 1 ] , buf [ o2 + 2 ] , buf [ o2 + 3 ] , buf [ o2 + 4 ] , buf [ o2 + 5 ] , buf [ o2 + 6 ] , buf [ o2 + 7 ] ) ;",938
144,"if ( ( o2 + 2 < o2 ) || ( o2 + 2 < 2 ) || ( o2 + 2 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;if ( ! n -> entries ) {EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteOlympus"" , sizeof ( MnoteOlympusEntry ) * c ) ;return ;}tcount = 0 ;for ( i = c , o = o2 ;i ;-- i , o += 12 ) {size_t s ;if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\\\'%s\\\')..."" , n -> entries [ tcount ] . tag , mnote_olympus_tag_get_name ( n -> entries [ tcount ] . tag ) ) ;# ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG  if ( dataofs + s > buf_size && n -> version == sanyoV1 ) {dataofs -= datao + 6 ;if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s > buf_size ) ) {","if ( CHECKOVERFLOW ( o2 , buf_size , 2 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ;n -> entries [ tcount ] . order = n -> order ;exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . tag , mnote_olympus_tag_get_name ( n -> entries [ tcount ] . tag ) ) ;if ( exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) ;continue ;}# ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG if ( dataofs + s > buf_size && n -> version == sanyoV1 ) {dataofs -= datao + 6 ;if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || ( dataofs + s > buf_size ) ) {",938
145,"static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  {","static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) {",939
146,"if ( perf_event_overflow ( event , nmi , & data , regs ) )  fsl_emb_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) fsl_emb_pmu_stop ( event , 0 ) ;",939
147,if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_xgmac_stats_string ) ;,if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ;,940
148,"
",if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;},941
149,jumpstack [ stackidx ++ ] = e ;},jumpstack [ stackidx ++ ] = e ;},941
150,"}ret = pipe_set_size ( pipe , nr_pages ) ;","}else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) {ret = - EPERM ;goto out ;}ret = pipe_set_size ( pipe , nr_pages ) ;",942
151,"char sbuf [ 128 ] ;void * mbuf = NULL ;void * parg = ( void * ) arg ;long err = - EINVAL ;bool has_array_args ;size_t array_size = 0 ;void __user * user_ptr = NULL ;void * * kernel_ptr = NULL ;if ( _IOC_DIR ( cmd ) != _IOC_NONE ) {if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;}else {mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ;if ( NULL == mbuf ) return - ENOMEM ;parg = mbuf ;}err = - EFAULT ;if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) {unsigned long n = cmd_input_size ( cmd ) ;if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ;if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ;}else {memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ;}}err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ;if ( err < 0 ) goto out ;has_array_args = err ;if ( has_array_args ) {mbuf = kmalloc ( array_size , GFP_KERNEL ) ;err = - ENOMEM ;if ( NULL == mbuf ) goto out_array_args ;err = - EFAULT ;if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ;* kernel_ptr = mbuf ;}err = __video_do_ioctl ( file , cmd , parg ) ;if ( err == - ENOIOCTLCMD ) err = - EINVAL ;if ( has_array_args ) {* kernel_ptr = user_ptr ;if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ;goto out_array_args ;}if ( err < 0 ) goto out ;out_array_args : switch ( _IOC_DIR ( cmd ) ) {case _IOC_READ : case ( _IOC_WRITE | _IOC_READ ) : if ( copy_to_user ( ( void __user * ) arg , parg , _IOC_SIZE ( cmd ) ) ) err = - EFAULT ;break ;}out : kfree ( mbuf ) ;return err ;","return video_usercopy ( file , cmd , arg , __video_do_ioctl ) ;",943
152,"0xD5 , 0x75 , 0xF1 , 0x23 , 0xC1 , 0x81 , 0x4B , 0x44 , 0x23 , 0xBE ,  0x97 , 0x81 , 0x7A , 0xDA , 0x97 , 0x1F , 0x1F , 0x0D , 0xD5 , 0xEC ,  0xC5 , 0x5F , 0x86 , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 ,  0x52 , 0x2C , 0xB7 , 0x20 , 0x29 , 0xC1 , 0xC7 , 0xE6 , 0x8E , 0x6F , 0xE5 , 0xC1 , 0x0D , 0xDD , 0x8A , 0xEF , 0x8D , 0xE7 , 0xA8 , 0x63 , 0xB4 , 0xF7 , 0x58 , 0x32 , 0x0E , 0x24 , 0xAC , 0x30 , 0x94 , 0xF5 , 0xC7 , 0x02 , 0x81 , 0x1B , 0xC7 , 0x68 , 0xE5 , 0x71 , 0xD7 , 0x1E , 0x3D , 0xE4 , 0x2E , 0x2F , 0xC0 , 0x0A , 0xED , 0x34 , 0xAC , 0xC0 , 0x1F , 0x0A , 0x56 , 0xA4 , 0x12 , 0x02 , 0xFD , 0x68 , 0xD2 , 0x4D , 0x5E , 0x0A , 0x5D , 0x78 , 0xE3 , 0xA0 , 0x85 , 0x75 , 0xD2 , 0xA9 , 0xC1 , 0xF2 , 0xAD , 0x65 , 0x11 , 0xDE , 0xE8 , 0x05 , 0x68 , 0x36 , 0x4C , 0x92 , 0x99 , 0x21 , 0xB9 , 0x69 , 0xD0 , 0x6F , 0xD8 , 0xA3 , 0xEA , 0x35 , 0x13 , 0x93 , 0xDC , 0x1B , 0x13 , 0x16 , 0xB2 , 0x15 , 0x8E , 0x10 , 0x22 , 0xCE , 0x01 , 0x1F , 0x1C , 0x09 , 0x86 , 0xD5 , 0xE7 , 0xCB , 0xCF , 0xFA , 0xED , 0x2F , 0xE2 , 0x3A , 0x65 , 0x14 , 0xC9 , 0xFA , 0x70 , 0x99 , 0xF7 , 0xE0 , 0x30 , 0xBF , 0x7F , 0xEA , 0x84 , 0x14 , 0x8A , 0x51 , 0xC9 , 0xE9 , 0x85 , 0x73 , 0x7F , 0xA1 , 0xB0 , 0xC3 , 0x33 , 0x9A , 0xAB , 0x69 , 0x4E , 0x75 , 0xFB , 0x12 , 0xB0 , 0x9E , 0xB1 , 0xD9 , 0xD1 , 0xB9 , 0x32 , 0x1D , 0xC6 , 0xD9 , 0x2C , 0xAA , 0xB0 , 0xC5 , 0x3E , 0x69 , 0x56 , 0xA2 , 0xB3 , 0xA2 , 0x81 , 0xCA , 0x9D , 0x77 , 0xBB , 0x52 , 0x44 , 0xA2 , 0xED , 0xE0 , 0xF0 , 0x2A , 0x81 , 0x85 , 0x90 , 0xB6 , 0x04 , 0x60 , 0xEB , 0x09 , 0x72 , 0x08 , 0x44 , 0xAF , 0x28 , 0xF5 , 0x15 , 0x34 , 0x87 , 0x5C , 0x8A , 0xB4 , 0x5B , 0x15 , 0x6A , 0xAD , 0x27 , 0x4E , 0xA0 , 0xDE , 0x99 , 0x22 , 0xCF , 0xAB , 0x4C , 0xFD , 0x75 , 0x10 , 0x5D , 0xFF , 0xE8 , 0x81 , 0x50 , 0xC4 , 0xC0 , 0x4B }","0xCF , 0x9F , 0x3A , 0x9C , 0xC5 , 0xA5 , 0x89 , 0x27 , 0x6D , 0x2C , 0x2C , 0xF3 , 0xA6 , 0x00 , 0xD2 , 0x7C , 0xEA , 0xFA , 0xF2 , 0x43 , 0x4F , 0x49 , 0x0A , 0xFC , 0xA6 , 0xE7 , 0x75 , 0xCA , 0x07 , 0xDC , 0xA5 , 0xF2 , 0x83 , 0x4E , 0x5A , 0xA0 , 0xA0 , 0xF5 , 0x9C , 0xFD , 0x02 , 0xE6 , 0x9E , 0xFC , 0x01 , 0x59 , 0xD7 , 0xB6 , 0xC1 , 0x4E , 0xC0 , 0xB6 , 0x71 , 0x49 , 0xF0 , 0xC7 , 0xD5 , 0x2F , 0x8D , 0xDF , 0xD3 , 0xF1 , 0x82 , 0x82 , 0x23 , 0x33 , 0x13 , 0x93 , 0xEB , 0x50 , 0x29 , 0xFD , 0x1B , 0x5A , 0x2F , 0xD5 , 0x08 , 0x99 , 0x64 , 0xE9 , 0x7B , 0x1A , 0xDD , 0x68 , 0x16 , 0x08 , 0xD0 , 0x13 , 0x82 , 0xB6 , 0x86 , 0x62 , 0x76 , 0xAA , 0x16 , 0x14 , 0xCC , 0x86 , 0x72 , 0x26 , 0x45 , 0x8E , 0x2A , 0x82 , 0x5B , 0x6F , 0xC1 , 0xDF , 0xAA , 0x18 , 0x43 , 0xB8 , 0xAD , 0x84 , 0x52 , 0xF2 , 0xD9 , 0x9C , 0xC0 , 0x47 , 0x52 , 0x1B , 0x8E , 0x42 , 0xC4 , 0xD3 , 0x61 , 0x7B , 0x65 , 0xA7 , 0x69 , 0x03 , 0xB5 , 0xD4 , 0x6C , 0x83 , 0x6A , 0x46 , 0x73 , 0xAF , 0x76 , 0x77 , 0x70 , 0xC2 , 0xD0 , 0x74 , 0xFE , 0x78 , 0xF5 , 0x75 , 0x3B , 0xCE , 0xE2 , 0xB6 , 0xA0 , 0x25 , 0xE9 , 0xE8 , 0x4B , 0xA2 , 0xF1 , 0x20 , 0x88 , 0x13 , 0x07 , 0xED , 0x66 , 0xBC , 0x46 , 0xA1 , 0xB3 , 0x44 , 0xAF , 0x2C , 0xED , 0x73 , 0x75 , 0x3D , 0x14 , 0x6E , 0x43 , 0x92 , 0x40 , 0x99 , 0xB0 , 0xD1 , 0xBF , 0x2C , 0x4D , 0x0F , 0x2A , 0x63 , 0xF4 , 0x85 , 0x7B , 0x1B , 0x0E , 0x48 , 0x5A , 0x06 , 0x02 , 0xA6 , 0x3D , 0x9E , 0x78 , 0x05 , 0xA8 , 0x7C , 0xAD , 0x54 , 0x49 , 0xDE , 0x7A , 0xE6 , 0x36 , 0x5C , 0x50 , 0xFC , 0x09 , 0x81 , 0x9E , 0x83 , 0x53 , 0x8C , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 , 0x52 , 0x2C , 0xB7 , 0x20 , 0x29 , 0xC1 , 0xC7 , 0xE6 , 0x8E , 0x6F , 0xE5 , 0xC1 , 0x0D , 0xDD , 0x8A , 0xEF , 0x8D , 0xE7 , 0xA8 , 0x63 , 0xB4 , 0xF7 , 0x58 , 0x32 , 0x0E , 0x24 , 0xAC , 0x30 , 0x94 , 0xF5 , 0xC7 , 0x02 , 0x81 , 0x1B , 0xC7 , 0x68 , 0xE5 , 0x71 , 0xD7 , 0x1E , 0x3D , 0xE4 , 0x2E , 0x2F , 0xC0 , 0x0A , 0xED , 0x34 , 0xAC , 0xC0 , 0x1F , 0x0A , 0x56 , 0xA4 , 0x12 , 0x02 , 0xFD , 0x68 , 0xD2 , 0x4D , 0x5E , 0x0A , 0x5D , 0x78 , 0xE3 , 0xA0 , 0x85 , 0x75 , 0xD2 , 0xA9 , 0xC1 , 0xF2 , 0xAD , 0x65 , 0x11 , 0xDE , 0xE8 , 0x05 , 0x68 , 0x36 , 0x4C , 0x92 , 0x99 , 0x21 , 0xB9 , 0x69 , 0xD0 , 0x6F , 0xD8 , 0xA3 , 0xEA , 0x35 , 0x13 , 0x93 , 0xDC , 0x1B , 0x13 , 0x16 , 0xB2 , 0x15 , 0x8E , 0x10 , 0x22 , 0xCE , 0x01 , 0x1F , 0x1C , 0x09 , 0x86 , 0xD5 , 0xE7 , 0xCB , 0xCF , 0xFA , 0xED , 0x2F , 0xE2 , 0x3A , 0x65 , 0x14 , 0xC9 , 0xFA , 0x70 , 0x99 , 0xF7 , 0xE0 , 0x30 , 0xBF , 0x7F , 0xEA , 0x84 , 0x14 , 0x8A , 0x51 , 0xC9 , 0xE9 , 0x85 , 0x73 , 0x7F , 0xA1 , 0xB0 , 0xC3 , 0x33 , 0x9A , 0xAB , 0x69 , 0x4E , 0x75 , 0xFB , 0x12 , 0xB0 , 0x9E , 0xB1 , 0xD9 , 0xD1 , 0xB9 , 0x32 , 0x1D , 0xC6 , 0xD9 , 0x2C , 0xAA , 0xB0 , 0xC5 , 0x3E , 0x69 , 0x56 , 0xA2 , 0xB3 , 0xA2 , 0x81 , 0xCA , 0x9D , 0x77 , 0xBB , 0x52 , 0x44 , 0xA2 , 0xED , 0xE0 , 0xF0 , 0x2A , 0x81 , 0x85 , 0x90 , 0xB6 , 0x04 , 0x60 , 0xEB , 0x09 , 0x72 , 0x08 , 0x44 , 0xAF , 0x28 , 0xF5 , 0x15 , 0x34 , 0x87 , 0x5C , 0x8A , 0xB4 , 0x5B , 0x15 , 0x6A , 0xAD , 0x27 , 0x4E , 0xA0 , 0xDE , 0x99 , 0x22 , 0xCF , 0xAB , 0x4C , 0xFD , 0x75 , 0x10 , 0x5D , 0xFF , 0xE8 , 0x81 , 0x50 , 0xC4 , 0xC0 , 0x4B }",944
153,"static char * print_string_ptr ( const char * str )  {char * ptr2 , * out ;int len = 0 ;unsigned char token ;if ( ! str )  return cJSON_strdup ( """" ) ;ptr = str ;if ( strchr ( ""\\\\""\\\\\\\\\\\\b\\\\f\\\else if ( token < 32 ) len += 5 ;++ ptr ;}if ( ! ( out = ( char * ) cJSON_malloc ( len + 3 ) ) )  return 0 ;","static char * print_string_ptr ( const char * str , printbuffer * p ) {char * ptr2 , * out ;int len = 0 ;unsigned char token ;if ( ! str ) {if ( p ) out = ensure ( p , 3 ) ;else out = ( char * ) cJSON_malloc ( 3 ) ;if ( ! out ) return 0 ;strcpy ( out , ""\\\\""\\\\"""" ) ;return out ;}for ( ptr = str ;* ptr ;ptr ++ ) flag |= ( ( * ptr > 0 && * ptr < 32 ) || ( * ptr == \\\'\\\\""\\\' ) || ( * ptr == \'\\\\\\\\\' ) ) ? 1 : 0 ;if ( ! flag ) {len = ptr - str ;if ( p ) out = ensure ( p , len + 3 ) ;else out = ( char * ) cJSON_malloc ( len + 3 ) ;if ( ! out ) return 0 ;ptr2 = out ;* ptr2 ++ = \\\'\\\\""\\\' ;strcpy ( ptr2 , str ) ;ptr2 [ len ] = \\\'\\\\""\\\' ;ptr2 [ len + 1 ] = 0 ;return out ;}ptr = str ;+ ptr ;if ( strchr ( ""\\\\""\\\\\\\\\\\\b\\\\f\\\else if ( token < 32 ) len += 5 ;ptr ++ ;}if ( p ) out = ensure ( p , len + 3 ) ) ) return 0 ;",945
154,break ;},"break ;}* ptr2 ++ = \\\'\\\\""\\\' ;",945
155,"while ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE )  impeg2d_bit_stream_flush ( ps_stream , MB_STUFFING_CODE_LEN ) ;","while ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) impeg2d_bit_stream_flush ( ps_stream , MB_STUFFING_CODE_LEN ) ;",946
156,"alloc_limit_assert ( ""checked_xcalloc"" , ( num * size ) ) ;return xcalloc ( num , size ) ;","size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;alloc_limit_assert ( ""checked_xcalloc"" , ( res ) ) ;return xcalloc ( num , size ) ;",947
157,"char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ;int dlen = mutt_b64_decode ( out , it ) ;if ( dlen == - 1 ) {","const int olen = 3 * len / 4 + 1 ;char * out = mutt_mem_malloc ( olen ) ;int dlen = mutt_b64_decode ( out , it , olen ) ;if ( dlen == - 1 ) {",948
158,if ( ! sock || ( count && ! buf ) )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! sock || ( count && ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,949
159,"if ( ! list . name || list . noselect ) return ;imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ;url . path = errstr + 1 ;","if ( ! list . name , true || list . noselect ) return ;imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ;url . path = errstr + 1 ;",950
160,mmu_notifier_mm_init ( mm ) ;init_tlb_flush_pending ( mm ) ;,"RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;mmu_notifier_mm_init ( mm ) ;init_tlb_flush_pending ( mm ) ;",951
161,"const int qzbin_factor = q == 0 ? 64 : ( vp9_dc_quant ( q , 0 ) < 148 ? 84 : 80 ) ;const int qrounding_factor = q == 0 ? 64 : 48 ;quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q )   : vp9_ac_quant ( q , 0 ) ;invert_quant ( & quants -> y_quant [ q ] [ i ] , & quants -> y_quant_shift [ q ] [ i ] , quant ) ;quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;cm -> y_dequant [ q ] [ i ] = quant ;quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q )   : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ;invert_quant ( & quants -> uv_quant [ q ] [ i ] , & quants -> uv_quant_shift [ q ] [ i ] , quant ) ;quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> uv_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;cm -> uv_dequant [ q ] [ i ] = quant ;# if CONFIG_ALPHA quant = i == 0 ? vp9_dc_quant ( q , cm -> a_dc_delta_q ) : vp9_ac_quant ( q , cm -> a_ac_delta_q ) ;invert_quant ( & quants -> a_quant [ q ] [ i ] , & quants -> a_quant_shift [ q ] [ i ] , quant ) ;quants -> a_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> a_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;cm -> a_dequant [ q ] [ i ] = quant ;# endif }for ( i = 2 ;i < 8 ;i ++ ) {quants -> y_quant [ q ] [ i ] = quants -> y_quant [ q ] [ 1 ] ;quants -> y_quant_shift [ q ] [ i ] = quants -> y_quant_shift [ q ] [ 1 ] ;quants -> y_zbin [ q ] [ i ] = quants -> y_zbin [ q ] [ 1 ] ;quants -> y_round [ q ] [ i ] = quants -> y_round [ q ] [ 1 ] ;cm -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ;quants -> uv_quant [ q ] [ i ] = quants -> uv_quant [ q ] [ 1 ] ;quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ;quants -> uv_zbin [ q ] [ i ] = quants -> uv_zbin [ q ] [ 1 ] ;cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ;# if CONFIG_ALPHA  quants -> a_quant [ q ] [ i ] = quants -> a_quant [ q ] [ 1 ] ;quants -> a_round [ q ] [ i ] = quants -> a_round [ q ] [ 1 ] ;cm -> a_dequant [ q ] [ i ] = cm -> a_dequant [ q ] [ 1 ] ;# endif }","const int qzbin_factor = get_qzbin_factor ( q , cm -> bit_depth ) ;const int qrounding_factor = q == 0 ? 64 : 48 ;int qrounding_factor_fp = i == 0 ? 48 : 42 ;if ( q == 0 ) qrounding_factor_fp = 64 ;quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q , cm -> bit_depth ) : vp9_ac_quant ( q , 0 , cm -> bit_depth ) ;invert_quant ( & quants -> y_quant [ q ] [ i ] , & quants -> y_quant_shift [ q ] [ i ] , quant ) ;quants -> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ;quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp * quant ) >> 7 ;cm -> y_dequant [ q ] [ i ] = quant ;quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q ) : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ;invert_quant ( & quants -> uv_quant [ q ] [ i ] , & quants -> uv_quant_shift [ q ] [ i ] , quant ) ;quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> uv_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;cpi -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ;quants -> uv_quant [ q ] [ i ] = quants -> uv_quant [ q ] [ 1 ] ;quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ;quants -> uv_zbin [ q ] [ i ] = quants -> uv_zbin [ q ] [ 1 ] ;cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ;# if CONFIG_ALPHA quants -> a_quant [ q ] [ i ] = quants -> a_quant [ q ] [ 1 ] ;quants -> uv_round [ q ] [ i ] = quants -> a_round [ q ] [ 1 ] ;}",952
162,"static inline int  addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) {","int addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) {",953
163,"char buffer [ 4096 ] ;char buffer2 [ 4096 ] ;char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;}else {memcpy ( buf , name , name_len ) ;buf [ name_len ] = 0 ;}encrypt_return_plain :  if ( buf != buffer ) {efree ( buf ) ;}","char * buf , * buf2 , * d , * d_url ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;encrypt_return_plain : efree ( buf ) ;",954
164,"if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {memcpy ( buf2 , value , value_len ) ;buf2 [ value_len ] = 0 ;}else {}if ( buf != buffer ) {efree ( buf ) ;}if ( buf2 != buffer2 ) {}",efree ( buf ) ;,954
165,"msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ;if ( msg -> fp ) return 0 ;","msg -> fp = mutt_bcache_get ( pop_data -> bcache , cache_id ( h -> data ) ) ;if ( msg -> fp ) return 0 ;",955
166,"msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ;if ( ! msg -> fp ) {","msg -> fp = mutt_bcache_put ( pop_data -> bcache , cache_id ( h -> data ) ) ;if ( ! msg -> fp ) {",955
167,"if ( bcache )  mutt_bcache_commit ( pop_data -> bcache , h -> data ) ;else {","if ( bcache ) mutt_bcache_commit ( pop_data -> bcache , cache_id ( h -> data ) ) ;else {",955
168,"ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ;len = ntohs ( a . h . len ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>method=%s"" , len - 4 ,  STR_OR_ID ( a . auth_method , v2_auth ) ) ) ;if ( 1 < ndo -> ndo_vflag && 4 < len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ;ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ;}else if ( ndo -> ndo_vflag && 4 < len ) {if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ;return ( const u_char * ) ext + len ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ;","ikev2_pay_print ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ;if ( 1 < ndo -> ndo_vflag && 4 < len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ;if ( len > 4 ) {if ( ndo -> ndo_vflag && 4 < len ) {if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ;}return ( const u_char * ) ext + len ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ;",956
169,"if ( ( s < entry -> components ) || ( s == 0 ) ) {if ( s > 4 ) doff = exif_get_long ( d + offset + 8 , data -> priv -> order ) ;else doff = offset + 8 ;if ( ( doff + s < doff ) || ( doff + s < s ) || ( doff + s > size ) ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" ,  ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff + s , size ) ;return 0 ;","if ( doff >= size ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Tag<S2SV_blank>starts<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff , size ) ;if ( s > size ) ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff + s , size ) ;return 0 ;",957
170,"p = strchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;p = strchr ( p + 1 , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;","p = osStrchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;p = osStrchr ( p + 1 , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;",958
171,const VP9_CONFIG * const oxcf = & cpi -> oxcf ;LAYER_CONTEXT * const lc = get_layer_context ( svc ) ;RATE_CONTROL * const lrc = & lc -> rc ;const int layer = svc -> temporal_layer_id ;lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ;lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> max_frame_bandwidth = cpi -> rc . max_frame_bandwidth ;if ( layer == 0 ) {lc -> avg_frame_size = lrc -> av_per_frame_bandwidth ;}else {const double prev_layer_framerate =  oxcf -> framerate / oxcf -> ts_rate_decimator [ layer - 1 ] ;const int prev_layer_target_bandwidth =  oxcf -> ts_target_bitrate [ layer - 1 ] * 1000 ;lc -> avg_frame_size = ( int ) ( ( lc -> target_bandwidth - prev_layer_target_bandwidth ) / ( lc -> framerate - prev_layer_framerate ) ) ;,const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;RATE_CONTROL * const lrc = & lc -> rc ;const int st_idx = svc -> spatial_layer_id * svc -> number_temporal_layers + svc -> temporal_layer_id ;const int tl = svc -> temporal_layer_id ;lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ;lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> avg_frame_bandwidth = ( int ) ( ( lc -> target_bandwidth - prev_layer_target_bandwidth ) / ( lc -> framerate - prev_layer_framerate ) ) ;,959
172,mutex_lock ( & ses -> server -> srv_mutex ) ;if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) {rc = ses -> server -> ops -> generate_signingkey ( ses ) ;kfree ( ses -> auth_key . response ) ;goto keygen_exit ;},mutex_lock ( & ses -> server -> ops -> generate_signingkey ) {rc = ses -> server -> ops -> generate_signingkey ( ses ) ;kfree ( ses -> auth_key . response ) ;return rc ;},960
173,ses -> status = CifsGood ;ses -> need_reconnect = false ;spin_unlock ( & GlobalMid_Lock ) ;keygen_exit :  if ( ! ses -> server -> sign ) {kfree ( ses -> auth_key . response ) ;ses -> auth_key . response = NULL ;},"
",960
174,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",961
175,f = po -> fanout ;if ( ! f )  return ;,f = po -> fanout ;if ( f ) {,962
176,"mutex_unlock ( & fanout_mutex ) ;if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ;}","if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ;}mutex_unlock ( & fanout_mutex ) ;}",962
177,"if ( l == 0 )  memcpy ( own_dir , ""."" , 2 ) ;else {","if ( l == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ;# endif # else memcpy ( own_dir , ""."" , 2 ) ;else {",963
178,uint32_t id ;ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ;,"uint32_t id ;if ( size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;size_left = 0 ;continue ;}ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ;",964
179,"
","if ( ! d -> iccprofile_file ) {de_warn ( c , ""Bad<S2SV_blank>ICC<S2SV_blank>profile<S2SV_blank>segment"" ) ;return ;}",965
180,"dbuf_copy ( c -> infile , pos + 4 , data_len , d -> iccprofile_file ) ;}","dbuf_copy ( c -> infile , pos + 4 , data_len , d -> iccprofile_file ) ;}",965
181,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,966
182,"else {ret . code = kadm5_create_policy ( ( void * ) handle , & arg -> rec , arg -> mask ) ;if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ;log_done ( ""kadm5_create_policy"" , ( ( prime_arg == NULL ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ;if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ;}gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",966
183,"int size_chk , err ;if ( chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE ) {if ( mr -> flags & ~ ( XDP_UMEM_UNALIGNED_CHUNK_FLAG | XDP_UMEM_USES_NEED_WAKEUP ) ) return - EINVAL ;",int err ;if ( chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE ) {if ( headroom >= chunk_size - XDP_PACKET_HEADROOM ) return - EINVAL ;,967
184,size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ;if ( size_chk < 0 ) return - EINVAL ;,size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ;if ( size_chk < 0 ) return - EINVAL ;,967
185,"int rec ;int offs = 0 ;int rec_len = file -> record_length ;for ( rec = 1 ;rv = sc_read_record ( card , rec , * out + offs + 2 , rec_len , SC_RECORD_BY_REC_NR ) ;","size_t rec ;size_t offs = 0 ;int rec_len = file -> record_length ;for ( rec = 1 ;rv = sc_read_record ( card , rec , * out + offs + 2 , rec_len , SC_RECORD_BY_REC_NR ) ;",968
186,"
",if ( rec > file -> record_count ) {rv = 0 ;break ;},968
187,"vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;if ( ! x -> mode_info_context -> mbmi . is_4x4 ) {","memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;if ( ! x -> mode_info_context -> mbmi . is_4x4 ) {",969
188,"static const char * parse_value ( cJSON * item , const char * value )  {","static const char * parse_value ( cJSON * item , const char * value , const char * * ep ) {",970
189,"if ( * value == \\\'\\\\""\\\' )  return parse_string ( item , value ) ;if ( * value == \'-\' || ( * value >= \'0\' && * value <= \'9\' ) )  return parse_number ( item , value ) ;if ( * value == \'[\' )  return parse_array ( item , value ) ;if ( * value == \'{\' )  return parse_object ( item , value ) ;ep = value ;","if ( * value == \\\'\\\\""\\\' ) {return parse_string ( item , value , ep ) ;}if ( * value == \'-\' || ( * value >= \'0\' && * value <= \'9\' ) ) {return parse_number ( item , value , ep ) ;}if ( * value == \'[\' ) {return parse_array ( item , value , ep ) ;}* ep = value ;",970
190,"if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) )  return - EFAULT ;","if ( validate_core_offset ( reg ) ) return - EINVAL ;if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) return - EFAULT ;",971
191,get_page ( * page ) ;out : ret = 0 ;,if ( unlikely ( ! try_get_page ( * page ) ) ) {ret = - ENOMEM ;goto unmap ;}out : ret = 0 ;,972
192,"ses = cifs_find_smb_ses ( server , volume_info -> username ) ;if ( ses ) {","ses = cifs_find_smb_ses ( server , volume_info ) ;if ( ses ) {",973
193,"dbg_hid ( ""%s,<S2SV_blank>size:%d\\\spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ;","dbg_hid ( ""%s,<S2SV_blank>size:%d\\\if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) {dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\\return false ;}spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ;",974
194,"fprintf ( stderr , ""usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\\","fprintf ( stderr , ""usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\\",975
195,"int xml_init ( modsec_rec * msr , char * * error_msg ) {if ( error_msg == NULL ) return - 1 ;return 1 ;}","int xml_init ( modsec_rec * msr , char * * error_msg ) {xmlParserInputBufferCreateFilenameFunc entity ;if ( error_msg == NULL ) return - 1 ;if ( msr -> txcfg -> xml_external_entity == 0 ) {entity = xmlParserInputBufferCreateFilenameDefault ( xml_unload_external_entity ) ;}return 1 ;}",976
196,"char buf [ L_BUF_SIZE ] ;char emptystring [ ] = """" ;","char buf [ L_BUFSIZE ] ;char emptystring [ ] = """" ;",977
197,"snprintf ( buf , L_BUF_SIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ;sarrayAddString ( gplot -> datanames , buf , L_COPY ) ;","snprintf ( buf , L_BUFSIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ;sarrayAddString ( gplot -> datanames , buf , L_COPY ) ;",977
198,"snprintf ( buf , L_BUF_SIZE , ""%f<S2SV_blank>%f\\\sarrayAddString ( sa , buf , L_COPY ) ;","snprintf ( buf , L_BUFSIZE , ""%f<S2SV_blank>%f\\\sarrayAddString ( sa , buf , L_COPY ) ;",977
199,"isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return hdrlen ;","isoclns_print ( ndo , p + 1 , length - 1 ) ;return hdrlen ;",978
200,dev_data = pci_get_drvdata ( dev ) ;if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) {,u16 val ;struct pci_cmd_info * cmd = data ;dev_data = pci_get_drvdata ( dev ) ;if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) {,979
201,"return pci_write_config_word ( dev , offset , value ) ;}","cmd -> val = value ;if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ;err = pci_read_config_word ( dev , offset , & val ) ;if ( err || val == value ) return err ;value &= PCI_COMMAND_GUEST ;value |= val & ~ PCI_COMMAND_GUEST ;return pci_write_config_word ( dev , offset , value ) ;}",979
202,if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 &&  rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) {if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 &&  rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) {,if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 91 && rdesc [ 83 ] == 0x26 && rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) {if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 51 && rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) {,980
203,"return ( ! _cups_strcasecmp ( con -> clientname , ""localhost"" ) || ! _cups_strcasecmp ( con -> clientname , ""localhost."" ) ||  # ifdef __linux  ! _cups_strcasecmp ( con -> clientname , ""localhost.localdomain"" ) || # endif ! strcmp ( con -> clientname , ""127.0.0.1"" ) || ! strcmp ( con -> clientname , ""[::1]"" ) ) ;","return ( ! _cups_strcasecmp ( con -> clientname , ""localhost"" ) || ! _cups_strcasecmp ( con -> clientname , ""localhost."" ) || ! strcmp ( con -> clientname , ""127.0.0.1"" ) || ! strcmp ( con -> clientname , ""[::1]"" ) ) ;",981
204,"if ( strcmp ( im -> mode , ""1"" ) == 0 && state -> xsize > state -> bytes * 8 ) {state -> errcode = IMAGING_CODEC_OVERRUN ;}state -> errcode = IMAGING_CODEC_OVERRUN ;ptr = buf ;for ( ;",if ( ( state -> xsize * state -> bits + 7 ) / 8 > state -> bytes * 8 ) {state -> errcode = IMAGING_CODEC_OVERRUN ;}state -> errcode = IMAGING_CODEC_OVERRUN ;ptr = buf ;for ( ;,982
205,"dname = malloc ( strlen ( name ) + 16 ) ;sprintf ( dname , ""%s-versions"" , name ) ;","dname = safe_calloc ( strlen ( name ) + 16 ) ;sprintf ( dname , ""%s-versions"" , name ) ;",983
206,"err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ;if ( err ) return err ;if ( is_pointer_value ( env , insn -> dst_reg ) ) {verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\\return - EACCES ;}err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;}else if ( opcode == BPF_MOV ) {if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( insn -> imm != 0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ;if ( err ) return err ;if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ;regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ;}else {if ( is_pointer_value ( env , insn -> src_reg ) ) {verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\return - EACCES ;}mark_reg_unknown ( env , regs , insn -> dst_reg ) ;regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ;__update_reg_bounds ( & regs [ insn -> dst_reg ] ) ;}__mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ;}","err = check_reg_arg ( env , insn -> dst_reg , insn -> imm ) ;__mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ;if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {__mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ;}",984
207,"strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry1 ) ) , PARAMS_LEN ) ;strncat ( params , ""/"" , PARAMS_LEN ) ;strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry2 ) ) , PARAMS_LEN ) ;gtkui_start_mitm ( ) ;","strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry1 ) ) , ETH_ASCII_ADDR_LEN ) ;strncat ( params , ""/"" , 1 ) ;strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry2 ) ) , IP6_ASCII_ADDR_LEN ) ;gtkui_start_mitm ( ) ;",985
208,"if ( poll ( & pfd , 1 , 500 ) == 0 )  return 0 ;if ( ( sent = send ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 )  {","if ( TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 500 ) ) == 0 ) return 0 ;if ( ( sent = TEMP_FAILURE_RETRY ( send ( fd , p , len , MSG_NOSIGNAL ) ) ) == - 1 ) {",986
209,"bufobj = tok -> decoding_buffer ;Py_INCREF ( bufobj ) ;}else {bufobj = PyObject_CallObject ( tok -> decoding_readline , NULL ) ;if ( bufobj == NULL ) goto error ;","bufobj = _PyObject_CallNoArg ( tok -> decoding_readline , NULL ) ;if ( bufobj == NULL ) goto error ;",987
210,return - ENOMEM ;},q -> fq = NULL ;return - ENOMEM ;},988
211,"gdImagePtr im ;char * buffer ;size_t size ;size = read_test_file ( & buffer , ""heap_overflow.tga"" ) ;im = gdImageCreateFromTgaPtr ( size , ( void * ) buffer ) ;gdTestAssert ( im == NULL ) ;free ( buffer ) ;","check_file ( ""heap_overflow_1.tga"" ) ;check_file ( ""heap_overflow_2.tga"" ) ;",989
212,# ifndef PGEN  # if PY_MINOR_VERSION >= 4  fd = _Py_dup ( fd ) ;# endif  # else fd = dup ( fd ) ;,# ifndef PGEN fd = _Py_dup ( fd ) ;# endif # else fd = dup ( fd ) ;,990
213,"u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ;u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ;struct rd_dev_sg_table * sg_table ;struct page * pg ;struct scatterlist * sg ;","struct rd_dev_sg_table * sg_table ;u32 sg_tables , total_sg_needed ;u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ;int rc ;",991
214,"while ( total_sg_needed ) {sg_per_table = ( total_sg_needed > max_sg_per_table ) ? max_sg_per_table : total_sg_needed ;sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , GFP_KERNEL ) ;if ( ! sg ) {pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist<S2SV_blank>array"" ""<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev\\\return - ENOMEM ;}sg_init_table ( sg , sg_per_table ) ;sg_table [ i ] . sg_table = sg ;sg_table [ i ] . rd_sg_count = sg_per_table ;sg_table [ i ] . page_start_offset = page_offset ;sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) - 1 ;for ( j = 0 ;j < sg_per_table ;j ++ ) {pg = alloc_pages ( GFP_KERNEL , 0 ) ;if ( ! pg ) {pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist"" ""<S2SV_blank>pages<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev_sg_table\\\return - ENOMEM ;}sg_assign_page ( & sg [ j ] , pg ) ;sg [ j ] . length = PAGE_SIZE ;}page_offset += sg_per_table ;total_sg_needed -= sg_per_table ;}","rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ;if ( rc ) return rc ;",991
215,"char buf [ L_BUF_SIZE ] ;char * cmdstr , * plottitle , * dataname ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\\\'%s\\\'"" , gplot -> title ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\\\'%s\\\'"" , gplot -> xlabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\\\'%s\\\'"" , gplot -> ylabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE ,  ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;","char buf [ L_BUFSIZE ] ;char * cmdstr , * plottitle , * dataname ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>title<S2SV_blank>\\\'%s\\\'"" , gplot -> title ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\\\'%s\\\'"" , gplot -> xlabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\\\'%s\\\'"" , gplot -> ylabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;",992
216,"snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;if ( i == 0 )  snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else if ( i < nplots - 1 )  snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else  snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;","snprintf ( buf , L_BUFSIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;if ( i == 0 ) snprintf ( buf , L_BUFSIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else if ( i < nplots - 1 ) snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;",992
217,"outpos +=  sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>w"" , w ) ;}","sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>w"" , w ) ;sendClean ( outputbuffer ) ;}",993
218,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",994
219,"}msg -> msg_namelen = sizeof ( * sax ) ;skb_free_datagram ( sk , skb ) ;release_sock ( sk ) ;","msg -> msg_namelen = sizeof ( * sax ) ;}skb_free_datagram ( sk , skb ) ;release_sock ( sk ) ;",995
220,else  follow_dotdot ( nd ) ;},else return follow_dotdot ( nd ) ;},996
221,list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;,"if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;",997
222,ld -> bytes_left = ld -> buffer_size - words * 4 ;if ( ld -> bytes_left >= 4 ) {,if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ;else ld -> bytes_left = ld -> buffer_size - words * 4 ;if ( ld -> bytes_left >= 4 ) {,998
223,"profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;if ( profile != ( StringInfo * ) NULL ) {","if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;if ( profile != ( StringInfo * ) NULL ) {",999
224,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,1000
225,"sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ;sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ;","memset ( & sync , 0 , sizeof ( sync ) ) ;sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ;sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ;",1001
226,"if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) ||  ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ;set_tls_desc ( target ,  GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ;","int i ;if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ;for ( i = 0 ;i < count / sizeof ( struct user_desc ) ;i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;set_tls_desc ( target , GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ;",1002
227,"char buf [ 32 ] , * e ;sprintf ( buf , fmt , w , n ) ;","char buf [ 50 ] , * e ;sprintf ( buf , fmt , w , n ) ;",1003
228,"# ifndef CONFIG_ZISOFS case SIG ( \'R\' , \'R\' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ;","# ifndef CONFIG_ZISOFS case SIG ( \'R\' , \'R\' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ;",1004
229,"case SIG ( \'E\' , \'R\' ) :  ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ;printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ;","case SIG ( \'E\' , \'R\' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ;printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ;",1004
230,"}skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & error ) ;if ( error < 0 ) goto end ;m -> msg_namelen = 0 ;if ( skb ) {",if ( skb ) {,1005
231,disk -> queue = NULL ;continue ;,put_disk ( disk ) ;disk -> queue = NULL ;continue ;,1006
232,"static int getnum ( lua_State * L , const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - \'0\' ) ) )  luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ;","static int getnum ( const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;",1007
233,void vp9_choose_segmap_coding_method ( VP9_COMP * cpi ) {VP9_COMMON * const cm = & cpi -> common ;,"void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) {",1008
234,"int t_unpred_seg_counts [ MAX_SEGMENTS ] = {0 };vp9_prob no_pred_tree [ SEG_TREE_PROBS ] ;vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ;vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ;const int mis = cm -> mi_stride ;MODE_INFO * * mi_ptr , * * mi ;vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ;vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ;for ( tile_col = 0 ;tile_col < 1 << cm -> log2_tile_cols ;tile_col ++ ) {TileInfo tile ;vp9_tile_init ( & tile , cm , 0 , tile_col ) ;mi_ptr = cm -> mi_grid_visible + tile . mi_col_start ;for ( mi_row = 0 ;mi_row < cm -> mi_rows ;mi_row += 8 , mi_ptr += 8 * mis ) {mi = mi_ptr ;for ( mi_col = tile . mi_col_start ;mi_col < tile . mi_col_end ;mi_col += 8 , mi += 8 )  count_segs_sb ( cpi , & tile , mi , no_pred_segcounts ,  temporal_predictor_count , t_unpred_seg_counts , mi_row , mi_col , BLOCK_64X64 ) ;}calc_segtree_probs ( no_pred_segcounts , no_pred_tree ) ;no_pred_cost = cost_segmap ( no_pred_segcounts , no_pred_tree ) ;if ( ! frame_is_intra_only ( cm ) ) {calc_segtree_probs ( t_unpred_seg_counts , t_pred_tree ) ;t_pred_cost = cost_segmap ( t_unpred_seg_counts , t_pred_tree ) ;for ( i = 0 ;i < PREDICTION_PROBS ;i ++ ) {const int count0 = temporal_predictor_count [ i ] [ 0 ] ;const int count1 = temporal_predictor_count [ i ] [ 1 ] ;t_nopred_prob [ i ] = get_binary_prob ( count0 , count1 ) ;t_pred_cost += count0 * vp9_cost_zero ( t_nopred_prob [ i ] ) + count1 * vp9_cost_one ( t_nopred_prob [ i ] ) ;}}if ( t_pred_cost < no_pred_cost ) {seg -> temporal_update = 1 ;vpx_memcpy ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ;vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ;}vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ;}","vpx_prob no_pred_tree [ SEG_TREE_PROBS ] ;vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ;vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ;memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ;vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ;memset ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ;vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ;vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ;}",1008
235,"g_return_if_fail ( RS_IS_FILTER ( filter ) ) ;GString * str = g_string_new ( ""digraph<S2SV_blank>G<S2SV_blank>{g_file_set_contents ( ""/tmp/rs-filter-graph"" , str -> str , str -> len , NULL ) ;if ( 0 != system ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>/tmp/rs-filter-graph.png<S2SV_blank></tmp/rs-filter-graph"" ) )  g_warning ( ""Calling<S2SV_blank>dot<S2SV_blank>failed"" ) ;if ( 0 != system ( ""gnome-open<S2SV_blank>/tmp/rs-filter-graph.png"" ) )   g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ;g_string_free ( str , TRUE ) ;","g_return_if_fail ( RS_IS_FILTER ( filter ) ) ;gchar * dot_filename ;gchar * png_filename ;gchar * command_line ;GString * str = g_string_new ( ""digraph<S2SV_blank>G<S2SV_blank>{dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ;png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ;g_file_set_contents ( dot_filename , str -> str , str -> len , NULL ) ;command_line = g_strdup_printf ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s"" , png_filename , dot_filename ) ;if ( 0 != system ( command_line ) ) g_warning ( ""Calling<S2SV_blank>dot<S2SV_blank>failed"" ) ;g_free ( command_line ) ;command_line = g_strdup_printf ( ""gnome-open<S2SV_blank>%s"" , png_filename ) ;if ( 0 != system ( command_line ) ) g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ;g_free ( command_line ) ;g_free ( dot_filename ) ;g_free ( png_filename ) ;g_string_free ( str , TRUE ) ;",1009
236,"if ( ( fd = open ( clonedev , O_RDWR ) ) < 0 )  {if ( ( err = ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) < 0 )  {int flags = fcntl ( fd , F_GETFL , 0 ) ;fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ;return fd ;","if ( ( fd = TEMP_FAILURE_RETRY ( open ( clonedev , O_RDWR ) ) ) < 0 ) {if ( ( err = TEMP_FAILURE_RETRY ( ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) ) < 0 ) {int flags = TEMP_FAILURE_RETRY ( fcntl ( fd , F_GETFL , 0 ) ) ;TEMP_FAILURE_RETRY ( fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ) ;return fd ;",1010
237,# if CONFIG_MULTIPLE_ARF  if ( ! cpi -> multi_arf_enabled && cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame ) {# else if ( cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame && ! cpi -> use_svc ) {# endif return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> alt_fb_idx ) ;# if CONFIG_MULTIPLE_ARF   if ( cpi -> multi_arf_enabled ) {int sn = cpi -> sequence_number ;arf_idx = ( cpi -> frame_coding_order [ sn ] < 0 ) ?  cpi -> arf_buffer_idx [ sn + 1 ] : cpi -> arf_buffer_idx [ sn ] ;# endif  return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> gld_fb_idx ) | ( cpi -> refresh_alt_ref_frame << arf_idx ) ;,if ( vp9_preserve_existing_gf ( cpi ) ) {return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> alt_fb_idx ) ;# if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) {int sn = cpi -> sequence_number ;arf_idx = gf_group -> arf_update_idx [ gf_group -> index ] ;# endif return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> gld_fb_idx ) | ( cpi -> refresh_alt_ref_frame << arf_idx ) ;,1011
238,"static void test_show_object ( struct object * object ,  struct strbuf * path ,   const char * last , void * data )  {","static void test_show_object ( struct object * object , const char * last , void * data ) {",1012
239,"if ( copy_from_user ( & info , u_info , sizeof ( info ) ) )  return - EFAULT ;if ( idx == - 1 ) idx = info . entry_number ;","if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) return - EFAULT ;if ( ! tls_desc_okay ( & info ) ) return - EINVAL ;if ( idx == - 1 ) idx = info . entry_number ;",1013
240,"
",shp -> shm_cprid = task_tgid_vnr ( current ) ;shp -> shm_lprid = 0 ;shp -> shm_atim = shp -> shm_dtim = 0 ;shp -> shm_ctim = get_seconds ( ) ;shp -> shm_segsz = size ;shp -> shm_nattch = 0 ;shp -> shm_file = file ;shp -> shm_creator = current ;,1014
241,"id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ;if ( id < 0 ) {shp -> shm_cprid = task_tgid_vnr ( current ) ;shp -> shm_lprid = 0 ;shp -> shm_atim = shp -> shm_dtim = 0 ;shp -> shm_ctim = get_seconds ( ) ;shp -> shm_segsz = size ;shp -> shm_nattch = 0 ;shp -> shm_file = file ;shp -> shm_creator = current ;","id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ;if ( id < 0 ) {",1014
242,". daddr = ( param -> replyopts . srr ?   param -> replyopts . faddr : iph -> saddr ) ,  . saddr = saddr , . flowi4_tos = RT_TOS ( tos ) , . flowi4_proto = IPPROTO_ICMP , . fl4_icmp_type = type , . fl4_icmp_code = code , }",". daddr = ( param -> replyopts . opt . opt . srr ? param -> replyopts . opt . opt . faddr : iph -> saddr ) , . saddr = saddr , . flowi4_tos = RT_TOS ( tos ) , . flowi4_proto = IPPROTO_ICMP , . fl4_icmp_type = type , . fl4_icmp_code = code , }",1015
243,"if ( i_arg ) {retval = copy_strings_kernel ( 1 , & i_arg , bprm ) ;bprm -> interp = interp ;file = open_exec ( interp ) ;return search_binary_handler ( bprm ) ;}","retval = bprm_change_interp ( interp , bprm ) ;if ( retval < 0 ) return retval ;file = open_exec ( interp ) ;if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ;bprm -> file = file ;retval = prepare_binprm ( bprm ) ;bprm -> interp = interp ;file = open_exec ( interp ) ;return search_binary_handler ( bprm ) ;}",1016
244,"sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ;if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) {","snprintf ( addr , sizeof ( addr ) , ""%d.%d.%d.%d"" , a , b , c , d ) ;if ( ! inet_aton ( addr , & ( sin . sin_addr ) ) ) {",1017
245,"int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header )  {","static int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) {",1018
246,"cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ;if ( ! cmd ) return - ENOMEM ;","cmd = kzalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ;if ( ! cmd ) return - ENOMEM ;",1019
247,"hash_param . data = 0 ;hash_param . len = 0 ;hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ;","hash_param . data = instance -> private_key ;hash_param . len = instance -> private_key_len ;hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ;",1020
248,"unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ;out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ;","init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ;out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ;",1021
249,"# ifdef __linux__   sun . sun_path [ 0 ] = '\\\\0' ;memcpy ( sun . sun_path + 1 , address , strlen ( address ) ) ;sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ;# else memcpy ( sun . sun_path , address , strlen ( address ) ) ;# endif client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ;","memcpy ( sun . sun_path [ 0 ] = '\\\\0' ;memcpy ( sun . sun_path , address , strlen ( address ) ) ;sun_len = sizeof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ;# else memcpy ( sun . sun_path , address , strlen ( address ) ) ;client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ;",1022
250,# ifndef NETSNMP_NO_WRITE_SUPPORT  case MODE_SET_RESERVE1 : switch ( table_info -> colnum ) {,# if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS case MODE_SET_RESERVE1 : switch ( table_info -> colnum ) {,1023
251,# ifndef NETSNMP_NO_WRITE_SUPPORT  if ( need_to_validate ) {,# if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS if ( need_to_validate ) {,1023
252,"static struct ip_options * ip_options_get_alloc ( const int optlen )  {return kzalloc ( sizeof ( struct ip_options ) + ( ( optlen + 3 ) & ~ 3 ) ,  GFP_KERNEL ) ;","static struct ip_options_rcu * ip_options_get_alloc ( const int optlen ) {return kzalloc ( sizeof ( struct ip_options_rcu ) + ( ( optlen + 3 ) & ~ 3 ) , GFP_KERNEL ) ;",1024
253,"
",if ( ! cursor ) goto gc_complete ;,1025
254,}slot = node -> parent_slot ;BUG_ON ( ! ptr ) ;node = assoc_array_ptr_to_node ( cursor ) ;,}slot = node -> parent_slot ;BUG_ON ( ! cursor ) ;node = assoc_array_ptr_to_node ( cursor ) ;,1025
255,local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ;for ( i = 0 ;,local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ;if ( args -> nr_local == 0 ) return - EINVAL ;for ( i = 0 ;,1026
256,"if ( ! ( plen <= * len ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;","if ( ! ( plen <= * len && plen > 0 ) ) printf ( ""PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\\assert ( plen <= * len ) ;* len = plen ;",1027
257,"return send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) == size_send ;}","return TEMP_FAILURE_RETRY ( send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) ) == size_send ;}",1028
258,"ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;","ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;",1029
259,"if ( ! capable ( CAP_NET_ADMIN ) )   return - EPERM ;if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) {if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 )  return - EFAULT ;","unsigned int copylen ;if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL ;if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) {copylen = get_arglen [ GET_CMDID ( cmd ) ] ;if ( copylen > 128 ) return - EINVAL ;if ( copy_from_user ( arg , user , copylen ) != 0 ) return - EFAULT ;",1030
260,if ( tgt_clobbers & ~ site_clobbers )  return len ;if ( len < 5 )  return len ;,"if ( len < 5 ) {# ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\\# endif return len ;}",1031
261,if ( o == NULL ) return ;s = o -> ptr ;,"if ( o == NULL || checkType ( c , o , OBJ_STREAM ) ) return ;s = o -> ptr ;",1032
262,"case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 2 , ""Port<S2SV_blank>Id"" ) ;tlv_subtype = PEEK_UINT8 ;if ( ( tlv_subtype == 0 ) || ( tlv_subtype > 7 ) ) {log_warnx ( ""lldp"" , ""unknown<S2SV_blank>subtype<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>id<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size - 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>id<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size - 1 ) ;if ( tlv_type == LLDP_TLV_PORT_ID ) {port -> p_id_subtype = tlv_subtype ;port -> p_id = b ;port -> p_id_len = tlv_size - 1 ;}else {chassis -> c_id_subtype = tlv_subtype ;chassis -> c_id = b ;chassis -> c_id_len = tlv_size - 1 ;}break ;case LLDP_TLV_TTL : CHECK_TLV_SIZE ( 2 , ""TTL"" ) ;chassis -> c_ttl = PEEK_UINT16 ;ttl_received = 1 ;break ;case LLDP_TLV_PORT_DESCR : case LLDP_TLV_SYSTEM_NAME : case LLDP_TLV_SYSTEM_DESCR : if ( tlv_size < 1 ) {log_debug ( ""lldp"" , ""empty<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;break ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size + 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>string<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size ) ;if ( tlv_type == LLDP_TLV_PORT_DESCR ) port -> p_descr = b ;else if ( tlv_type == LLDP_TLV_SYSTEM_NAME ) chassis -> c_name = b ;else chassis -> c_descr = b ;break ;case LLDP_TLV_SYSTEM_CAP : CHECK_TLV_SIZE ( 4 , ""System<S2SV_blank>capabilities"" ) ;chassis -> c_cap_available = PEEK_UINT16 ;chassis -> c_cap_enabled = PEEK_UINT16 ;break ;case LLDP_TLV_MGMT_ADDR : CHECK_TLV_SIZE ( 1 , ""Management<S2SV_blank>address"" ) ;addr_str_length = PEEK_UINT8 ;CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ;PEEK_BYTES ( addr_str_buffer , addr_str_length ) ;addr_length = addr_str_length - 1 ;addr_family = addr_str_buffer [ 0 ] ;addr_ptr = & addr_str_buffer [ 1 ] ;CHECK_TLV_SIZE ( 1 + addr_str_length + 5 , ""Management<S2SV_blank>address"" ) ;iface_subtype = PEEK_UINT8 ;iface_number = PEEK_UINT32 ;af = lldpd_af_from_lldp_proto ( addr_family ) ;if ( af == LLDPD_AF_UNSPEC ) break ;if ( iface_subtype == LLDP_MGMT_IFACE_IFINDEX ) iface = iface_number ;else iface = 0 ;mgmt = lldpd_alloc_mgmt ( af , addr_ptr , addr_length , iface ) ;if ( mgmt == NULL ) {assert ( errno == ENOMEM ) ;log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>management<S2SV_blank>address"" ) ;goto malformed ;}TAILQ_INSERT_TAIL ( & chassis -> c_mgmt , mgmt , m_entries ) ;break ;case LLDP_TLV_ORG :  CHECK_TLV_SIZE ( 4 , ""Organisational"" ) ;PEEK_BYTES ( orgid , sizeof ( orgid ) ) ;","case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 1 + ( int ) sizeof ( orgid ) , ""Organisational"" ) ;PEEK_BYTES ( orgid , sizeof ( orgid ) ) ;",1033
263,int i ;int opts ;,int result ;int i ;int opts ;,1034
264,"if ( ! js_regexec ( re -> prog , text , & m , opts ) ) {js_newarray ( J ) ;","result = js_regexec ( re -> prog , text , & m , opts ) ;if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ;if ( result == 0 ) {js_newarray ( J ) ;",1034
265,if ( m -> msg_flags & MSG_OOB )  goto read_error ;m -> msg_namelen = 0 ;,if ( m -> msg_flags & MSG_OOB ) goto read_error ;,1035
266,"cred = rpc_lookup_cred ( ) ;if ( IS_ERR ( cred ) ) return PTR_ERR ( cred ) ;state = nfs4_do_open ( dir , & path , openflags , NULL , cred ) ;put_rpccred ( cred ) ;","fmode_t fmode = openflags & ( FMODE_READ | FMODE_WRITE ) ;cred = rpc_lookup_cred ( ) ;if ( IS_ERR ( cred ) ) return PTR_ERR ( cred ) ;state = nfs4_do_open ( dir , & path , fmode , openflags , NULL , cred ) ;put_rpccred ( cred ) ;",1036
267,"nfs4_intent_set_file ( nd , & path , state ) ;return 1 ;}nfs4_close_sync ( & path , state , openflags ) ;out_drop : d_drop ( dentry ) ;","nfs4_intent_set_file ( nd , & path , state , fmode ) ;out_drop : d_drop ( dentry ) ;",1036
268,"int target = rc -> av_per_frame_bandwidth * kf_ratio ;return vp9_rc_clamp_iframe_target_size ( cpi , target ) ;","const int target = rc -> avg_frame_bandwidth * kf_ratio ;return vp9_rc_clamp_iframe_target_size ( cpi , target ) ;",1037
269,"if ( test_bit ( DMF_FREEING , & md -> flags ) ||   dm_deleting_md ( md ) )  return NULL ;dm_get ( md ) ;return md ;","spin_lock ( & _minor_lock ) ;if ( test_bit ( DMF_FREEING , & md -> flags ) || dm_deleting_md ( md ) ) {md = NULL ;goto out ;}dm_get ( md ) ;out : spin_unlock ( & _minor_lock ) ;return md ;",1038
270,"if ( nargs == 0 )  return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ;buf = mp_buf_new ( L ) ;","if ( nargs == 0 ) return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ;if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."" ) ;buf = mp_buf_new ( L ) ;",1039
271,if ( group_leader -> ctx -> type != ctx -> type )  goto err_context ;,if ( group_leader -> ctx -> task != ctx -> type ) goto err_context ;,1040
272,down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ;if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ;,"error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ;if ( error ) goto out_dput ;down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ;if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ;",1041
273,"static unsigned int get_sby_perpixel_diff_variance ( VP9_COMP * cpi ,  MACROBLOCK * x ,  int mi_row , int mi_col , BLOCK_SIZE bs ) {const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;int offset = ( mi_row * MI_SIZE ) * yv12 -> y_stride + ( mi_col * MI_SIZE ) ;unsigned int var , sse ;var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf ,  x -> plane [ 0 ] . src . stride , yv12 -> y_buffer + offset , yv12 -> y_stride , & sse ) ;","static unsigned int get_sby_perpixel_diff_variance ( VP9_COMP * cpi , const struct buf_2d * ref , int mi_row , int mi_col , BLOCK_SIZE bs ) {unsigned int sse , var ;uint8_t * last_y ;const YV12_BUFFER_CONFIG * last = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;assert ( last != NULL ) ;last_y = & last -> y_buffer [ mi_row * MI_SIZE * last -> y_stride + ( mi_col * MI_SIZE ] ;var = cpi -> fn_ptr [ bs ] . vf ( ref -> buf , ref -> stride , last_y , last -> y_stride , & sse ) ;",1042
274,"void *  checked_xmalloc ( size_t size )  {alloc_limit_assert ( ""checked_xmalloc"" , size ) ;return xmalloc ( size ) ;}","void * checked_xmalloc ( size_t num , size_t size ) {size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;alloc_limit_assert ( ""checked_xmalloc"" , res ) ;return xmalloc ( num , size ) ;}",1043
275,int m ;m = n ;,"int m ;if ( n < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ;}m = n ;",1044
276,++ j )  if ( p ++ != pages [ i + j ] )  break ;,+ j )  if ( p ++ != pages [ i + j ] )  break ;++ j ) if ( ++ p != pages [ i + j ] ) break ;,1045
277,++ j )  if ( p ++ != pages [ i + j ] )  break ;,+ j )  if ( p ++ != pages [ i + j ] )  break ;++ j ) if ( ++ p != pages [ i + j ] ) break ;,1045
278,hdl -> client_state = HSM_COM_C_STATE_IN ;* p_hdl = hdl ;,if ( mkstemp ( hdl -> c_path ) == - 1 ) {res = HSM_COM_PATH_ERR ;goto cleanup ;}hdl -> client_state = HSM_COM_C_STATE_IN ;* p_hdl = hdl ;,1046
279,"assert ( sp -> encodepfunc != NULL ) ;( * sp -> encodepfunc ) ( tif , bp , cc ) ;return ( * sp -> encoderow ) ( tif , bp , cc , s ) ;","if ( ! assert ( sp -> encodepfunc != NULL ) ;( * sp -> encodepfunc ) ( tif , bp , cc ) ) return 0 ;return ( * sp -> encoderow ) ( tif , bp , cc , s ) ;",1047
280,new -> cid_mask = 0 ;,new -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;0 ;,1048
281,new -> cid_mask = new -> lid_mask = 0xffff ;},new -> cid_mask = new -> lid_mask = 0xffff ;},1048
282,if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) {struct in_ifaddr * * ifap1 = & ifa1 -> ifa_next ;,if ( in_dev -> dead ) goto no_promotions ;if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) {struct in_ifaddr * * ifap1 = & ifa1 -> ifa_next ;,1049
283,else {,no_promotions : else {,1049
284,}* ifap = ifa1 -> ifa_next ;,}* ifap = ifa1 -> ifa_next ;,1049
285,SvcInternal * si ;if ( svc_ctx == NULL ) return ;si = ( SvcInternal * ) svc_ctx -> internal ;if ( si != NULL ) {free ( si -> buffer ) ;if ( si -> rc_stats_buf ) {free ( si -> rc_stats_buf ) ;},SvcInternal_t * si ;if ( svc_ctx == NULL ) return ;si = ( SvcInternal_t * ) svc_ctx -> internal ;if ( si != NULL ) {,1050
286,"strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ;strncpy ( extra_response -> value , NOTUNDERSTOOD ,  strlen ( NOTUNDERSTOOD ) + 1 ) ;list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ;","strlcpy ( extra_response -> key , key , sizeof ( extra_response -> key ) ) ;strlcpy ( extra_response -> value , NOTUNDERSTOOD , sizeof ( extra_response -> value ) ) ;list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ;",1051
287,"u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ;u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ;struct rd_dev_sg_table * sg_table ;struct page * pg ;struct scatterlist * sg ;","struct rd_dev_sg_table * sg_table ;u32 sg_tables , total_sg_needed ;u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ;int rc ;",1052
288,"while ( total_sg_needed ) {sg_per_table = ( total_sg_needed > max_sg_per_table ) ? max_sg_per_table : total_sg_needed ;sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , GFP_KERNEL ) ;if ( ! sg ) {pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist<S2SV_blank>array"" ""<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev\\\return - ENOMEM ;}sg_init_table ( sg , sg_per_table ) ;sg_table [ i ] . sg_table = sg ;sg_table [ i ] . rd_sg_count = sg_per_table ;sg_table [ i ] . page_start_offset = page_offset ;sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) - 1 ;for ( j = 0 ;j < sg_per_table ;j ++ ) {pg = alloc_pages ( GFP_KERNEL , 0 ) ;if ( ! pg ) {pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist"" ""<S2SV_blank>pages<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev_sg_table\\\return - ENOMEM ;}sg_assign_page ( & sg [ j ] , pg ) ;sg [ j ] . length = PAGE_SIZE ;}page_offset += sg_per_table ;total_sg_needed -= sg_per_table ;}","rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ;if ( rc ) return rc ;",1052
289,return ( ( Image * ) NULL ) ;},break ;},1053
290,"}commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ;","}if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ;",1054
291,"buf = malloc ( sz + 1 ) ;SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\\","buf = safe_calloc ( sz + 1 ) ;SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\\",1055
292,"switch ( s -> nal_unit_type ) {case HEVC_NAL_VPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_vps ( gb , s -> avctx , & s -> ps ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_SPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_sps ( gb , s -> avctx , & s -> ps , s -> apply_defdispwin ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_PPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_pps ( gb , s -> avctx , & s -> ps ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_SEI_PREFIX : case HEVC_NAL_SEI_SUFFIX : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_sei ( gb , s -> avctx , & s -> sei , & s -> ps , s -> nal_unit_type ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_TRAIL_R : case HEVC_NAL_TRAIL_N : case HEVC_NAL_TSA_N : case HEVC_NAL_TSA_R : case HEVC_NAL_STSA_N : case HEVC_NAL_STSA_R : case HEVC_NAL_BLA_W_LP : case HEVC_NAL_BLA_W_RADL : case HEVC_NAL_BLA_N_LP : case HEVC_NAL_IDR_W_RADL : case HEVC_NAL_IDR_N_LP : case HEVC_NAL_CRA_NUT : case HEVC_NAL_RADL_N : case HEVC_NAL_RADL_R : case HEVC_NAL_RASL_N : case HEVC_NAL_RASL_R : ret = hls_slice_header ( s ) ;if ( ret < 0 )  return ret ;if ( ( s -> avctx -> skip_frame >= AVDISCARD_BIDIR && s -> sh . slice_type == HEVC_SLICE_B ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONINTRA && s -> sh . slice_type != HEVC_SLICE_I ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONKEY && ! IS_IRAP ( s ) ) ) {break ;}if ( s -> sh . first_slice_in_pic_flag ) {if ( s -> ref ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\\goto fail ;}if ( s -> max_ra == INT_MAX ) {",switch ( s -> max_ra == INT_MAX ) {,1056
293,"pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 )  errExit ( ""chown"" ) ;if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 )  errExit ( ""chmod"" ) ;","copy_file_as_user ( src , dest ) ;if ( rv ) fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\if ( chown ( dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chmod"" ) ;",1057
294,"static inline long decode_twos_comp ( ulong c , int prec )  {","static inline long decode_twos_comp ( jas_ulong c , int prec ) {",1058
295,"x -> skip = 0 ;if ( xd -> segmentation_enabled ) x -> encode_breakout = cpi -> segment_encode_breakout [ xd -> mode_info_context -> mbmi . segment_id ] ;else x -> encode_breakout = cpi -> oxcf . encode_breakout ;# if CONFIG_TEMPORAL_DENOISING x -> best_reference_frame = INTRA_FRAME ;x -> best_zeromv_reference_frame = INTRA_FRAME ;x -> best_sse_inter_mode = 0 ;x -> best_sse_mv . as_int = 0 ;x -> need_to_clamp_best_mvs = 0 ;# endif if ( cpi -> sf . RD ) {int zbin_mode_boost_enabled = x -> zbin_mode_boost_enabled ;if ( cpi -> sf . use_fastquant_for_pick ) {x -> quantize_b = vp8_fast_quantize_b ;x -> quantize_b_pair = vp8_fast_quantize_b_pair ;x -> zbin_mode_boost_enabled = 0 ;}vp8_rd_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate ,  & distortion , & intra_error ) ;if ( cpi -> sf . improved_quant ) {x -> quantize_b = vp8_regular_quantize_b ;x -> quantize_b_pair = vp8_regular_quantize_b_pair ;","x -> zbin_mode_boost_enabled = 0 ;}vp8_rd_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate , & distortion , & intra_error , mb_row , mb_col ) ;if ( cpi -> sf . improved_quant ) {x -> quantize_b = vp8_regular_quantize_b ;x -> quantize_b_pair = vp8_regular_quantize_b_pair ;",1059
296,"ascii = malloc ( strlen ( str ) + 1 ) ;strncpy ( ascii , str , strlen ( str ) + 1 ) ;","ascii = safe_calloc ( strlen ( str ) + 1 ) ;strncpy ( ascii , str , strlen ( str ) + 1 ) ;",1060
297,ascii = malloc ( str_len ) ;for ( ;,ascii = safe_calloc ( str_len ) ;for ( ;,1060
298,char lowstr [ MAXDATELEN + 1 ] ;char * realptr ;if ( strlen ( str ) >= sizeof ( lowstr ) )  {,char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ;char * realptr ;if ( strlen ( str ) > MAXDATELEN ) {,1061
299,free_uid ( group -> inotify_data . user ) ;},atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;free_uid ( group -> inotify_data . user ) ;},1062
300,"int i , j ;p = buff1 ;i = ctm -> length ;str = ( char * ) ctm -> data ;if ( ( i < 11 ) || ( i > 17 ) )  return 0 ;}if ( i < 13 )  return 0 ;}if ( ( * str == \'Z\' ) || ( * str == \'-\' ) || ( * str == \'+\' ) ) {* ( p ++ ) = * ( str ++ ) ;* ( p ++ ) = * ( str ++ ) ;if ( * str == \'.\' ) {while ( ( * str >= \'0\' ) && ( * str <= \'9\' ) )  str ++ ;if ( * str == \'Z\' )  offset = 0 ;else {if ( ( * str != \'+\' ) && ( * str != \'-\' ) )  return 0 ;","int i , j , remaining ;p = buff1 ;remaining = ctm -> length ;str = ( char * ) ctm -> data ;int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ;int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ;if ( remaining < min_length || remaining > max_length ) return 0 ;remaining -= 10 ;}int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ;int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ;if ( remaining < min_length || remaining > max_length ) return 0 ;remaining -= 12 ;}if ( ( * str == \'Z\' ) || ( * str == \'-\' ) || ( * str == \'+\' ) ) {if ( remaining < 2 ) return 0 ;* ( p ++ ) = * ( str ++ ) ;* ( p ++ ) = * ( str ++ ) ;remaining -= 2 ;if ( remaining && * str == \'.\' ) {remaining -- ;for ( i = 0 ;i < 3 && remaining ;i ++ , str ++ , remaining -- ) {if ( * str < \'0\' || * str > \'9\' ) break ;}if ( ! remaining ) return 0 ;if ( * str == \'Z\' ) {if ( remaining != 1 ) return 0 ;offset = 0 ;}else {if ( ( * str != \'+\' ) && ( * str != \'-\' ) ) return 0 ;if ( remaining != 5 ) return 0 ;if ( str [ 1 ] < \'0\' || str [ 1 ] > \'9\' || str [ 2 ] < \'0\' || str [ 2 ] > \'9\' || str [ 3 ] < \'0\' || str [ 3 ] > \'9\' || str [ 4 ] < \'0\' || str [ 4 ] > \'9\' ) return 0 ;",1063
301,void * _TIFFmalloc ( tmsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,void * _TIFFmalloc ( tmsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,1064
302,if ( ! ( flags | RT6_LOOKUP_F_DST_NOREF ) )  dst_hold ( & rt -> dst ) ;,if ( ! ( flags & RT6_LOOKUP_F_DST_NOREF ) ) dst_hold ( & rt -> dst ) ;,1065
303,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,1066
304,"else {log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ;}gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",1066
305,pu1_buf = ( UWORD8 * ) ps_codec -> pv_mv_bank_buf_base ;ps_mv_buf = ( mv_buf_t * ) pu1_buf ;,ps_codec -> i4_max_dpb_size = max_dpb_size ;pu1_buf = ( UWORD8 * ) ps_codec -> pv_mv_bank_buf_base ;ps_mv_buf = ( mv_buf_t * ) pu1_buf ;,1067
306,"ND_PRINT ( ( ndo , "",<S2SV_blank>(SEC)<S2SV_blank>[worktodo]"" ) ) ;","ND_PRINT ( ( ndo , ""%s"" , rpl_tstr ) ) ;",1068
307,"# if 0 trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;","# if 0 trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",1068
308,"static int nfs4_open_recover_helper ( struct nfs4_opendata * opendata , mode_t openflags , struct nfs4_state * * res )  {opendata -> o_arg . open_flags = openflags ;memset ( & opendata -> o_res , 0 , sizeof ( opendata -> o_res ) ) ;nfs4_close_state ( & opendata -> path , newstate , openflags ) ;* res = newstate ;","static int nfs4_open_recover_helper ( struct nfs4_opendata * opendata , fmode_t fmode , struct nfs4_state * * res ) {opendata -> o_arg . open_flags = 0 ;opendata -> o_arg . fmode = fmode ;memset ( & opendata -> o_res , 0 , sizeof ( opendata -> o_res ) ) ;nfs4_close_state ( & opendata -> path , newstate , fmode ) ;* res = newstate ;",1069
309,# if ( ETH_SUPPORT == ENABLED )  message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ;,message -> interface = queueItem -> interface ;# if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ;,1070
310,while ( 1 ) {PyObject * literal = NULL ;,state -> fmode = 1 ;while ( 1 ) {PyObject * literal = NULL ;,1071
311,assert ( ! state -> last_str ||  PyUnicode_GET_LENGTH ( state -> last_str ) != 0 ) ;,"
",1071
312,"if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;","if ( pos + len > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;",1072
313,"verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j )  vstart += verdef -> vd_aux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {","verdef -> vd_version = READ16 ( dfs , j ) int vdaux = verdef -> vd_aux ;if ( vdaux < 1 ) {sdb_free ( sdb_verdef ) ;goto out_error ;}vstart += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {",1073
314,"int sec ;int dsec ;guint pkt_len ;char cap_src [ 13 ] ;guint offset = 0 ;gchar dststr [ 13 ] ;if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" ,  & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) {return - 1 ;}","int pkt_len ;int sec ;int dsec ;char cap_src [ 13 ] ;int offset = 0 ;gchar dststr [ 13 ] ;if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/"" , & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) {return - 1 ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;}",1074
315,"struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;int ret , i ;","struct o2nm_cluster * cluster ;int ret , i ;",1075
316,ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;,o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {o2nm_unlock_subsystem ( ) ;return - EINVAL ;}ret = 0 ;write_lock ( & cluster -> cl_nodes_lock ) ;o2nm_unlock_subsystem ( ) ;,1075
317,if ( ret )  return ret ;,if ( ret ) return ret ;,1075
318,"memcpy ( new , ours , sizeof ( * new ) ) ;len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ;","memcpy ( new , ours , sizeof ( * new ) ) ;memset ( dte , 0 , sizeof ( * dte ) ) ;len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ;",1076
319,if ( ! PPEEK_IS ( ')' ) ) return ONIGERR_INVALID_GROUP_NAME ;PINC ;,"if ( ! PPEEK_IS ( ')' ) ) {r = ONIGERR_INVALID_GROUP_NAME ;onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ;return r ;}PINC ;",1077
320,"FRAME_CONTEXT * fc = & cm -> fc ;const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ;i ++ )  fc -> intra_inter_prob [ i ] = adapt_prob ( pre_fc -> intra_inter_prob [ i ] ,  counts -> intra_inter [ i ] ) ;i ++ )  fc -> comp_inter_prob [ i ] = adapt_prob ( pre_fc -> comp_inter_prob [ i ] ,  counts -> comp_inter [ i ] ) ;i ++ )  fc -> comp_ref_prob [ i ] = adapt_prob ( pre_fc -> comp_ref_prob [ i ] ,  counts -> comp_ref [ i ] ) ;j ++ )  fc -> single_ref_prob [ i ] [ j ] = adapt_prob ( pre_fc -> single_ref_prob [ i ] [ j ] ,  counts -> single_ref [ i ] [ j ] ) ;i ++ )  adapt_probs ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] ,  counts -> inter_mode [ i ] , fc -> inter_mode_probs [ i ] ) ;i ++ )  adapt_probs ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] ,  counts -> y_mode [ i ] , fc -> y_mode_prob [ i ] ) ;++ i )  adapt_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] ,  counts -> uv_mode [ i ] , fc -> uv_mode_prob [ i ] ) ;i ++ )  adapt_probs ( vp9_partition_tree , pre_fc -> partition_prob [ i ] ,  counts -> partition [ i ] , fc -> partition_prob [ i ] ) ;i ++ )  adapt_probs ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] ,  counts -> switchable_interp [ i ] , fc -> switchable_interp_prob [ i ] ) ;","FRAME_CONTEXT * fc = cm -> fc ;const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ;i ++ ) fc -> intra_inter_prob [ i ] = mode_mv_merge_probs ( pre_fc -> intra_inter_prob [ i ] , counts -> intra_inter [ i ] ) ;i ++ ) fc -> comp_inter_prob [ i ] = mode_mv_merge_probs ( pre_fc -> comp_inter_prob [ i ] , counts -> comp_inter [ i ] ) ;i ++ ) fc -> comp_ref_prob [ i ] = mode_mv_merge_probs ( pre_fc -> comp_ref_prob [ i ] , counts -> comp_ref [ i ] ) ;j ++ ) fc -> single_ref_prob [ i ] [ j ] = mode_mv_merge_probs ( pre_fc -> single_ref_prob [ i ] [ j ] , counts -> single_ref [ i ] [ j ] ) ;i ++ ) vpx_tree_merge_probs ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] , counts -> inter_mode [ i ] , fc -> inter_mode_probs [ i ] ) ;i ++ ) vpx_tree_merge_probs ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] , counts -> y_mode [ i ] , fc -> y_mode_prob [ i ] ) ;+ i )  adapt_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] ,  counts -> uv_mode [ i ] , fc -> uv_mode_prob [ i ] ) ;++ i ) vpx_tree_merge_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] , counts -> uv_mode [ i ] , fc -> uv_mode_prob [ i ] ) ;i ++ ) vpx_tree_merge_probs ( vp9_partition_tree , pre_fc -> partition_prob [ i ] , counts -> partition [ i ] , fc -> partition_prob [ i ] ) ;i ++ ) vpx_tree_merge_probs ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] , counts -> switchable_interp [ i ] , fc -> switchable_interp_prob [ i ] ) ;",1078
321,"++ j )  fc -> tx_probs . p8x8 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] ,  branch_ct_8x8p [ j ] ) ;++ j )  fc -> tx_probs . p16x16 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] ,  branch_ct_16x16p [ j ] ) ;++ j )  fc -> tx_probs . p32x32 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] ,  branch_ct_32x32p [ j ] ) ;++ i )  fc -> skip_probs [ i ] = adapt_prob ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ;}","+ j )  fc -> tx_probs . p8x8 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] ,  branch_ct_8x8p [ j ] ) ;++ j ) fc -> tx_probs . p8x8 [ i ] [ j ] = mode_mv_merge_probs ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] , branch_ct_8x8p [ j ] ) ;+ j )  fc -> tx_probs . p16x16 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] ,  branch_ct_16x16p [ j ] ) ;++ j ) fc -> tx_probs . p16x16 [ i ] [ j ] = mode_mv_merge_probs ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] , branch_ct_16x16p [ j ] ) ;+ j )  fc -> tx_probs . p32x32 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] ,  branch_ct_32x32p [ j ] ) ;++ j ) fc -> tx_probs . p32x32 [ i ] [ j ] = mode_mv_merge_probs ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] , branch_ct_32x32p [ j ] ) ;+ i )  fc -> skip_probs [ i ] = adapt_prob ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ;++ i ) fc -> skip_probs [ i ] = mode_mv_merge_probs ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ;}",1078
322,"struct snd_kcontrol * kctl ;list_for_each_entry ( kctl , & card -> controls , list ) {","struct snd_kcontrol * kctl ;if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0 ;list_for_each_entry ( kctl , & card -> controls , list ) {",1079
323,"struct kvm_arch * ka = & v -> kvm -> arch ;void * shared_kaddr ;s64 kernel_ns , max_kernel_ns ;struct pvclock_vcpu_time_info * guest_hv_clock ;u8 pvclock_flags ;","s64 kernel_ns , max_kernel_ns ;struct pvclock_vcpu_time_info * guest_hv_clock ;u8 pvclock_flags ;",1080
324,if ( ! vcpu -> time_page )  return 0 ;,if ( ! vcpu -> pv_time_enabled ) return 0 ;,1080
325,"shared_kaddr = kmap_atomic ( vcpu -> time_page ) ;guest_hv_clock = shared_kaddr + vcpu -> time_offset ;pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ;if ( vcpu -> pvclock_set_guest_stopped_request ) {memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock ,  sizeof ( vcpu -> hv_clock ) ) ;kunmap_atomic ( shared_kaddr ) ;mark_page_dirty ( v -> kvm , vcpu -> time >> PAGE_SHIFT ) ;","if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 ;pvclock_flags = ( guest_hv_clock . flags & PVCLOCK_GUEST_STOPPED ) ;if ( vcpu -> pvclock_set_guest_stopped_request ) {kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , & vcpu -> hv_clock , sizeof ( vcpu -> hv_clock ) ) ;",1080
326,"int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff ,  intptr_t block_size , int64_t * ssz ) {","int64_t vp9_block_error_c ( const tran_low_t * coeff , const int16_t * dqcoeff , intptr_t block_size , int64_t * ssz ) {",1081
327,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  return - ENOKEY ;",if ( key_is_negative ( key ) ) return - ENOKEY ;,1082
328,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ;switch ( dir ) {","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , addr ) ;switch ( dir ) {",1083
329,"void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( get_bit ( fin ) ) {","void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset , int maxoffset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( bloc >= maxoffset ) {* ch = 0 ;* offset = maxoffset + 1 ;return ;}if ( get_bit ( fin ) ) {",1084
330,bufsize = file -> size ;sc_file_free ( file ) ;,"bufsize = MIN ( file -> size , sizeof buf ) ;sc_file_free ( file ) ;",1085
331,"next_byte :  b = cpu_ldub_code ( env , s -> pc ) ;","next_byte : if ( s -> pc - pc_start > 14 ) {goto illegal_op ;}b = cpu_ldub_code ( env , s -> pc ) ;",1086
332,return true ;},if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ;else return true ;},1087
333,"if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) ||  ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) {for ( i = 0 ;segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ;","if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ;if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) {for ( i = 0 ;if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ;",1088
334,const float factor = 0.5 ;const int number_blocks = cm -> mi_rows * cm -> mi_cols ;if ( rc -> av_per_frame_bandwidth < factor * number_blocks ||  number_blocks / 64 < 5 ) return 0 ;,const float factor = 0.25 ;const int number_blocks = cm -> mi_rows * cm -> mi_cols ;if ( rc -> avg_frame_bandwidth < factor * number_blocks || number_blocks / 64 < 5 ) return 0 ;,1089
335,"size_t columns ,  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads ,  sizeof ( * pixels ) ) ;( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ )  {","size_t columns , rows ;rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) ;pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( rows , sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ ) {",1090
336,"char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ;ret = stat ( pathname , & sb ) ;","char * pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"" ;ret = stat ( pathname , & sb ) ;",1091
337,"result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;if ( btif_is_enabled ( ) ) {","result = TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ;if ( btif_is_enabled ( ) ) {",1092
338,"uint32_t off = offset , tmp , finish ;struct ipmi_rs * rsp ;finish = fru -> size ;lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" , offset + length , finish - offset ) ;}memset ( & req , 0 , sizeof ( req ) ) ;","uint32_t off = offset ;uint32_t tmp ;uint32_t finish ;uint32_t size_left_in_buffer ;struct ipmi_rs * rsp ;memset ( frubuf + fru -> size , 0 , length - fru -> size ) ;finish = fru -> size ;lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" , offset + length , finish - offset ) ;length = finish - offset ;}memset ( & req , 0 , sizeof ( req ) ) ;",1093
339,do {tmp = fru -> access ? off >> 1 : off ;,size_left_in_buffer = length ;do {tmp = fru -> access ? off >> 1 : off ;,1093
340,"memcpy ( frubuf , rsp -> data + 1 , tmp ) ;off += tmp ;if ( tmp == 0 && off < finish ) {return 0 ;","if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) {printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ;return - 1 ;}memcpy ( frubuf , rsp -> data + 1 , tmp ) ;off += tmp ;size_left_in_buffer -= tmp ;if ( tmp == 0 && off < finish ) {return 0 ;",1093
341,"if ( buffer )  vterm_allocator_free ( screen -> vt , buffer ) ;","vterm_allocator_free ( screen -> vt , buffer ) ;",1094
342,}conn_without_ssl_ok : ;,peer = NULL ;}conn_without_ssl_ok : ;,1095
343,"static uid_t uid_server = 0 ;static gid_t gid_cluster = 0 ;uid_server = getuid ( ) ;if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & gid_cluster ) < 0 ) {","static gid_t gid_cluster = 0 ;if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & gid_cluster ) < 0 ) {",1096
344,"if ( gid_cluster != 0 && gid_client != 0 ) {uid_t best_uid = - 1 ;if ( uid_client == 0 || uid_server == 0 ) {best_uid = QB_MAX ( uid_client , uid_server ) ;crm_trace ( ""Allowing<S2SV_blank>user<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>clean<S2SV_blank>up<S2SV_blank>after<S2SV_blank>disconnect"" , best_uid ) ;}qb_ipcs_connection_auth_set ( c , best_uid , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) ;","if ( uid_client != 0 ) {qb_ipcs_connection_auth_set ( c , - 1 , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) ;",1096
345,if ( client -> type == USER_CLIENT )  snd_seq_fifo_clear ( client -> data . user . fifo ) ;,if ( client -> type == USER_CLIENT && client -> data . user . fifo ) snd_seq_fifo_clear ( client -> data . user . fifo ) ;,1097
346,stmt_ty s ;node * ch ;mod_ty res = NULL ;c . c_arena = arena ;,"asdl_seq * type_ignores = NULL ;stmt_ty s ;node * ch ;mod_ty res = NULL ;asdl_seq * argtypes = NULL ;expr_ty ret , arg ;c . c_arena = arena ;",1098
347,"res = Module ( stmts , arena ) ;break ;","ch = CHILD ( n , NCH ( n ) - 1 ) ;REQ ( ch , ENDMARKER ) ;num = NCH ( ch ) ;type_ignores = _Py_asdl_seq_new ( num , arena ) ;if ( ! type_ignores ) goto out ;for ( i = 0 ;i < num ;i ++ ) {type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ;if ( ! ti ) goto out ;asdl_seq_SET ( type_ignores , i , ti ) ;}res = Module ( stmts , type_ignores , arena ) ;break ;",1098
348,"default :  PyErr_Format ( PyExc_SystemError , ""invalid<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>PyAST_FromNode"" , TYPE ( n ) ) ;","case func_type_input : n = CHILD ( n , 0 ) ;REQ ( n , func_type ) ;if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) {ch = CHILD ( n , 1 ) ;num = 0 ;for ( i = 0 ;i < NCH ( ch ) ;i ++ ) {if ( TYPE ( CHILD ( ch , i ) ) == test ) {num ++ ;}}argtypes = _Py_asdl_seq_new ( num , arena ) ;if ( ! argtypes ) goto out ;j = 0 ;for ( i = 0 ;i < NCH ( ch ) ;i ++ ) {if ( TYPE ( CHILD ( ch , i ) ) == test ) {arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ;if ( ! arg ) goto out ;asdl_seq_SET ( argtypes , j ++ , arg ) ;}}}else {argtypes = _Py_asdl_seq_new ( 0 , arena ) ;if ( ! argtypes ) goto out ;}ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ;if ( ! ret ) goto out ;res = FunctionType ( argtypes , ret , arena ) ;break ;default : PyErr_Format ( PyExc_SystemError , ""invalid<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>PyAST_FromNode"" , TYPE ( n ) ) ;",1098
349,uint8_t chipRevision ;Dm9000Context * context ;,uint8_t chipRev ;Dm9000Context * context ;,1099
350,"vendorId = ( dm9000ReadReg ( DM9000_REG_VIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_VIDL ) ;productId = ( dm9000ReadReg ( DM9000_REG_PIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_PIDL ) ;chipRevision = dm9000ReadReg ( DM9000_REG_CHIPR ) ;if ( vendorId != DM9000_VID || productId != DM9000_PID ) {if ( chipRevision != DM9000A_CHIP_REV && chipRevision != DM9000B_CHIP_REV )  {dm9000WriteReg ( DM9000_REG_GPR , 0x00 ) ;sleep ( 10 ) ;dm9000WriteReg ( DM9000_REG_NCR , NCR_RST ) ;while ( ( dm9000ReadReg ( DM9000_REG_NCR ) & NCR_RST ) != 0 )  {dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_RST ) ;while ( ( dm9000ReadPhyReg ( DM9000_PHY_REG_BMCR ) & BMCR_RST ) != 0 )  {TRACE_INFO ( ""<S2SV_blank><S2SV_blank>CHIPR<S2SV_blank>=<S2SV_blank>0x%02"" PRIX8 ""\\\\r\\\TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR1<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\\\r\\\TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR2<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\\\r\\\# if ( DM9000_LOOPBACK_MODE == ENABLED )  dm9000WriteReg ( DM9000_REG_NCR , DM9000_LBK_PHY ) ;dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_LOOPBACK | BMCR_SPEED_SEL | BMCR_AN_EN | BMCR_DUPLEX_MODE ) ;# endif for ( i = 0 ;dm9000WriteReg ( DM9000_REG_PAR0 + i , interface -> macAddr . b [ i ] ) ;}dm9000WriteReg ( DM9000_REG_MAR0 + i , 0x00 ) ;}dm9000WriteReg ( DM9000_REG_MAR7 , 0x80 ) ;dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR ) ;dm9000WriteReg ( DM9000_REG_NSR , NSR_WAKEST | NSR_TX2END | NSR_TX1END ) ;dm9000WriteReg ( DM9000_REG_ISR , ISR_LNKCHG | ISR_UDRUN | ISR_ROO | ISR_ROS | ISR_PT | ISR_PR ) ;dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR | IMR_LNKCHGI | IMR_PTI | IMR_PRI ) ;dm9000WriteReg ( DM9000_REG_RCR , RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN ) ;","vendorId = ( dm9000ReadReg ( DM9000_VIDH ) << 8 ) | dm9000ReadReg ( DM9000_VIDL ) ;productId = ( dm9000ReadReg ( DM9000_PIDH ) << 8 ) | dm9000ReadReg ( DM9000_PIDL ) ;chipRev = dm9000ReadReg ( DM9000_REG_CHIPR ) ;if ( vendorId != DM9000_VID || productId != DM9000_PID ) {if ( chipRev != DM9000_CHIPR_REV_A && chipRev != DM9000_CHIPR_REV_B ) {dm9000WriteReg ( DM9000_GPR , 0x00 ) ;sleep ( 10 ) ;dm9000WriteReg ( DM9000_NCR , DM9000_NCR_RST ) ;while ( ( dm9000ReadReg ( DM9000_NCR ) & DM9000_NCR_RST ) != 0 ) {dm9000WritePhyReg ( DM9000_BMCR , DM9000_BMCR_RST ) ;while ( ( dm9000ReadPhyReg ( DM9000_BMCR ) & DM9000_BMCR_RST ) != 0 ) {TRACE_INFO ( ""<S2SV_blank><S2SV_blank>CHIPR<S2SV_blank>=<S2SV_blank>0x%02"" PRIX8 ""\\\\r\\\TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR1<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\\\r\\\TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR2<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\\\r\\\# if ( DM9000_LOOPBACK_MODE == ENABLED ) dm9000WriteReg ( DM9000_NCR , DM9000_NCR_LBK_PHY ) ;dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_LOOPBACK | BMCR_SPEED_SEL | BMCR_AN_EN | BMCR_DUPLEX_MODE ) ;# endif for ( i = 0 ;dm9000WriteReg ( DM9000_PAR0 + i , interface -> macAddr . b [ i ] ) ;}dm9000WriteReg ( DM9000_MAR0 + i , 0x00 ) ;}dm9000WriteReg ( DM9000_MAR7 , 0x80 ) ;dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR ) ;dm9000WriteReg ( DM9000_NSR , DM9000_NSR_WAKEST | DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ;dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG | DM9000_ISR_UDRUN | DM9000_ISR_ROO | DM9000_ISR_ROS | DM9000_ISR_PT | DM9000_ISR_PR ) ;dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI ) ;dm9000WriteReg ( DM9000_RCR , DM9000_RCR_DIS_LONG | DM9000_RCR_DIS_CRC | DM9000_RCR_RXEN ) ;",1099
351,int64_t old_off = s -> off ;uint8_t old_buf [ BUFFER_SIZE ] ;else if ( ( s -> filesize == - 1 && whence == SEEK_END ) )  return AVERROR ( ENOSYS ) ;,uint64_t old_off = s -> off ;uint8_t old_buf [ BUFFER_SIZE ] ;else if ( ( s -> filesize == UINT64_MAX && whence == SEEK_END ) ) return AVERROR ( ENOSYS ) ;,1100
352,vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ;const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ;,vp9_coeff_probs_model * const probs = cm -> fc -> coef_probs [ tx_size ] ;const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ;,1101
353,"static void  swabHorDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horDiff32 ( tif , cp0 , cc ) ;TIFFSwabArrayOfLong ( wp , wc ) ;}","static int swabHorDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ! horDiff32 ( tif , cp0 , cc ) ) return 0 ;TIFFSwabArrayOfLong ( wp , wc ) ;return 1 ;}",1102
354,"static void nfs_set_open_stateid_locked ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags )  {switch ( open_flags ) {case FMODE_READ : set_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ;","static void nfs_set_open_stateid_locked ( struct nfs4_state * state , nfs4_stateid * stateid , fmode_t fmode ) {switch ( fmode ) {case FMODE_READ : set_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ;",1103
355,cf . can_id = 0 ;switch ( * cmd ) {,"memset ( & cf , 0 , sizeof ( cf ) ) ;switch ( * cmd ) {",1104
356,* ( u64 * ) ( & cf . data ) = 0 ;if ( ! ( cf . can_id & CAN_RTR_FLAG ) ) {,if ( ! ( cf . can_id & CAN_RTR_FLAG ) ) {,1104
357,},g_free_not_null ( ircconn -> sasl_username ) ;g_free_not_null ( ircconn -> sasl_password ) ;},1105
358,sock -> sk -> sk_uid = iattr -> ia_uid ;}return err ;,if ( sock -> sk ) sock -> sk -> sk_uid = iattr -> ia_uid ;else err = - ENOENT ;}return err ;,1106
359,char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ;if ( buffer ) {,size_t size = bytes + CHK_OVERHEAD_SIZE ;if ( size < bytes ) {return NULL ;}uint8_t * buffer = ( uint8_t * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ;if ( buffer ) {,1107
360,"
","if ( rar -> dictionary_size == 0 ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size"" ) ;return ( ARCHIVE_FATAL ) ;}",1108
361,"if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context ,  rar -> dictionary_size , & g_szalloc ) ) {","if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , rar -> dictionary_size , & g_szalloc ) ) {",1108
362,"if ( code )  return code ;code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ;","if ( code ) {* status = ""DECODE_PA_FOR_USER"" ;return code ;}code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ;",1109
363,"# line 585 ""ext/standard/var_unserializer.c""  {","# line 576 ""ext/standard/var_unserializer.c"" {",1110
364,"case \'C\' :  case \'O\' : goto yy13 ;case \'N\' : goto yy5 ;case \'R\' : goto yy2 ;case \'S\' : goto yy10 ;case \'a\' : goto yy11 ;case \'b\' : goto yy6 ;case \'d\' : goto yy8 ;case \'i\' : goto yy7 ;case \'o\' : goto yy12 ;case \'r\' : goto yy4 ;case \'s\' : goto yy9 ;case \'}\' : goto yy14 ;default : goto yy16 ;}yy3 :  # line 962 ""ext/standard/var_unserializer.re""  {# line 646 ""ext/standard/var_unserializer.c""  yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy89 ;goto yy3 ;if ( yych == \';\' ) goto yy87 ;goto yy3 ;if ( yych == \':\' ) goto yy83 ;goto yy3 ;if ( yych == \':\' ) goto yy77 ;goto yy3 ;if ( yych == \':\' ) goto yy53 ;goto yy3 ;if ( yych == \':\' ) goto yy46 ;goto yy3 ;if ( yych == \':\' ) goto yy39 ;goto yy3 ;if ( yych == \':\' ) goto yy32 ;goto yy3 ;if ( yych == \':\' ) goto yy25 ;goto yy3 ;if ( yych == \':\' ) goto yy17 ;goto yy3 ;yy14 :  ++ YYCURSOR ;# line 956 ""ext/standard/var_unserializer.re""  {# line 695 ""ext/standard/var_unserializer.c""  yy16 : yych = * ++ YYCURSOR ;goto yy3 ;yy17 : yych = * ++ YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}if ( yych == \'+\' ) goto yy19 ;yy18 : YYCURSOR = YYMARKER ;goto yy3 ;yy19 : yych = * ++ YYCURSOR ;goto yy20 ;}goto yy18 ;yy20 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \';\' ) goto yy18 ;yych = * ++ YYCURSOR ;if ( yych != \\\'""\\\' ) goto yy18 ;++ YYCURSOR ;# line 804 ""ext/standard/var_unserializer.re""  {size_t len , len2 , len3 , maxlen ;zend_long elements ;char * str ;zend_string * class_name ;zend_class_entry * ce ;int incomplete_class = 0 ;int custom_object = 0 ;zval user_func ;zval retval ;zval args [ 1 ] ;if ( ! var_hash ) return 0 ;if ( * start == \'C\' ) {custom_object = 1 ;len2 = len = parse_uiv ( start + 2 ) ;maxlen = max - YYCURSOR ;if ( maxlen < len || len == 0 ) {* p = start + 2 ;return 0 ;}str = ( char * ) YYCURSOR ;YYCURSOR += len ;if ( * ( YYCURSOR ) != \\\'""\\\' ) {return 0 ;if ( * ( YYCURSOR + 1 ) != \':\' ) {* p = YYCURSOR + 1 ;return 0 ;len3 = strspn ( str , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\177\\\\200\\\\201\\\\202\\\\203\\\\204\\\\205\\\\206\\\\207\\\\210\\\\211\\\\212\\\\213\\\\214\\\\215\\\\216\\\\217\\\\220\\\\221\\\\222\\\\223\\\\224\\\\225\\\\226\\\\227\\\\230\\\\231\\\\232\\\\233\\\\234\\\\235\\\\236\\\\237\\\\240\\\\241\\\\242\\\\243\\\\244\\\\245\\\\246\\\\247\\\\250\\\\251\\\\252\\\\253\\\\254\\\\255\\\\256\\\\257\\\\260\\\\261\\\\262\\\\263\\\\264\\\\265\\\\266\\\\267\\\\270\\\\271\\\\272\\\\273\\\\274\\\\275\\\\276\\\\277\\\\300\\\\301\\\\302\\\\303\\\\304\\\\305\\\\306\\\\307\\\\310\\\\311\\\\312\\\\313\\\\314\\\\315\\\\316\\\\317\\\\320\\\\321\\\\322\\\\323\\\\324\\\\325\\\\326\\\\327\\\\330\\\\331\\\\332\\\\333\\\\334\\\\335\\\\336\\\\337\\\\340\\\\341\\\\342\\\\343\\\\344\\\\345\\\\346\\\\347\\\\350\\\\351\\\\352\\\\353\\\\354\\\\355\\\\356\\\\357\\\\360\\\\361\\\\362\\\\363\\\\364\\\\365\\\\366\\\\367\\\\370\\\\371\\\\372\\\\373\\\\374\\\\375\\\\376\\\\377\\\\\\\\"" ) ;if ( len3 != len ) {* p = YYCURSOR + len3 - len ;return 0 ;class_name = zend_string_init ( str , len , 0 ) ;do {if ( ! unserialize_allowed_class ( class_name , classes ) ) {incomplete_class = 1 ;ce = PHP_IC_ENTRY ;break ;}BG ( serialize_lock ) ++ ;ce = zend_lookup_class ( class_name ) ;if ( ce ) {BG ( serialize_lock ) -- ;if ( EG ( exception ) ) {zend_string_release ( class_name ) ;return 0 ;break ;BG ( serialize_lock ) -- ;if ( EG ( exception ) ) {zend_string_release ( class_name ) ;return 0 ;if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == \'\\\\0\' ) ) {incomplete_class = 1 ;ce = PHP_IC_ENTRY ;break ;}ZVAL_STRING ( & user_func , PG ( unserialize_callback_func ) ) ;ZVAL_STR_COPY ( & args [ 0 ] , class_name ) ;BG ( serialize_lock ) ++ ;if ( call_user_function_ex ( CG ( function_table ) , NULL , & user_func , & retval , 1 , args , 0 , NULL ) != SUCCESS ) {BG ( serialize_lock ) -- ;if ( EG ( exception ) ) {zend_string_release ( class_name ) ;zval_ptr_dtor ( & user_func ) ;zval_ptr_dtor ( & args [ 0 ] ) ;return 0 ;php_error_docref ( NULL , E_WARNING , ""defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found"" , Z_STRVAL ( user_func ) ) ;incomplete_class = 1 ;ce = PHP_IC_ENTRY ;zval_ptr_dtor ( & user_func ) ;zval_ptr_dtor ( & args [ 0 ] ) ;break ;}BG ( serialize_lock ) -- ;zval_ptr_dtor ( & retval ) ;if ( EG ( exception ) ) {zend_string_release ( class_name ) ;zval_ptr_dtor ( & user_func ) ;zval_ptr_dtor ( & args [ 0 ] ) ;return 0 ;BG ( serialize_lock ) ++ ;if ( ( ce = zend_lookup_class ( class_name ) ) == NULL ) {php_error_docref ( NULL , E_WARNING , ""Function<S2SV_blank>%s()<S2SV_blank>hasn\\\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for"" , Z_STRVAL ( user_func ) ) ;incomplete_class = 1 ;ce = PHP_IC_ENTRY ;BG ( serialize_lock ) -- ;zval_ptr_dtor ( & user_func ) ;zval_ptr_dtor ( & args [ 0 ] ) ;break ;while ( 1 ) ;* p = YYCURSOR ;if ( custom_object ) {int ret ;ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ;if ( ret && incomplete_class ) {php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ;}zend_string_release ( class_name ) ;return ret ;}elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ;if ( elements < 0 ) {zend_string_release ( class_name ) ;return 0 ;if ( incomplete_class ) {php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ;zend_string_release ( class_name ) ;return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ;# line 878 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;if ( yych != \'+\' ) goto yy18 ;if ( yych <= \'-\' ) goto yy26 ;if ( yych <= \'9\' ) goto yy27 ;yy26 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy27 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'9\' ) goto yy27 ;if ( yych >= \';\' ) goto yy18 ;yych = * ++ YYCURSOR ;if ( yych != \\\'""\\\' ) goto yy18 ;++ YYCURSOR ;# line 793 ""ext/standard/var_unserializer.re""  {zend_long elements ;if ( ! var_hash ) return 0 ;elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ;if ( elements < 0 || elements >= HT_MAX_SIZE ) {return 0 ;return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ;# line 914 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy33 ;if ( yych <= \'9\' ) goto yy34 ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;if ( yych >= \';\' ) goto yy18 ;yych = * ++ YYCURSOR ;if ( yych != \'{\' ) goto yy18 ;++ YYCURSOR ;# line 769 ""ext/standard/var_unserializer.re"" {zend_long elements = parse_iv ( start + 2 ) ;* p = YYCURSOR ;","case \'C\' : case \'O\' : goto yy4 ;case \'N\' : goto yy5 ;case \'R\' : goto yy6 ;case \'S\' : goto yy10 ;case \'a\' : goto yy8 ;case \'b\' : goto yy6 ;case \'d\' : goto yy10 ;case \'i\' : goto yy7 ;case \'o\' : goto yy12 ;case \'r\' : goto yy13 ;case \'s\' : goto yy9 ;case \'}\' : goto yy15 ;default : goto yy16 ;}yy3 : # line 951 ""ext/standard/var_unserializer.re"" {# line 636 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy17 ;goto yy3 ;if ( yych == \';\' ) goto yy19 ;goto yy3 ;if ( yych == \':\' ) goto yy21 ;goto yy3 ;if ( yych == \':\' ) goto yy22 ;goto yy3 ;if ( yych == \':\' ) goto yy23 ;goto yy3 ;if ( yych == \':\' ) goto yy24 ;goto yy3 ;if ( yych == \':\' ) goto yy25 ;goto yy3 ;if ( yych == \':\' ) goto yy26 ;goto yy3 ;if ( yych == \':\' ) goto yy27 ;goto yy3 ;if ( yych == \':\' ) goto yy28 ;goto yy3 ;yy14 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy29 ;goto yy3 ;yy15 : ++ YYCURSOR ;# line 945 ""ext/standard/var_unserializer.re"" {# line 689 ""ext/standard/var_unserializer.c"" yy17 : yych = * ++ YYCURSOR ;+ YYCURSOR ;goto yy31 ;if ( yych == \'+\' ) goto yy30 ;yy18 : YYCURSOR = YYMARKER ;goto yy3 ;yy19 : ++ YYCURSOR ;# line 629 ""ext/standard/var_unserializer.re"" {ZVAL_NULL ( rval ) ;return 1 ;# line 707 ""ext/standard/var_unserializer.c"" yy21 : yych = * ++ YYCURSOR ;if ( yych <= \',\' ) {if ( yych == \'+\' ) goto yy33 ;goto yy18 ;else {if ( yych <= \'-\' ) goto yy33 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy34 ;goto yy18 ;yy22 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy36 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy37 ;goto yy18 ;yy23 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy39 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy40 ;goto yy18 ;yy24 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'1\' ) goto yy42 ;goto yy18 ;yy25 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) {if ( yych <= \',\' ) {if ( yych == \'+\' ) goto yy43 ;goto yy18 ;else {if ( yych <= \'-\' ) goto yy44 ;if ( yych <= \'.\' ) goto yy45 ;goto yy18 ;else {if ( yych <= \'I\' ) {if ( yych <= \'9\' ) goto yy46 ;if ( yych <= \'H\' ) goto yy18 ;goto yy48 ;else {if ( yych == \'N\' ) goto yy49 ;goto yy18 ;yy26 : yych = * ++ YYCURSOR ;if ( yych <= \',\' ) {if ( yych == \'+\' ) goto yy50 ;goto yy18 ;else {if ( yych <= \'-\' ) goto yy50 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy51 ;goto yy18 ;yy27 : yych = * ++ YYCURSOR ;if ( yych <= \',\' ) {if ( yych == \'+\' ) goto yy53 ;goto yy18 ;else {if ( yych <= \'-\' ) goto yy53 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy54 ;goto yy18 ;yy28 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy56 ;goto yy18 ;if ( yych <= \'-\' ) goto yy56 ;if ( yych <= \'9\' ) goto yy57 ;yy29 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy59 ;+ YYCURSOR ;if ( yych <= \'9\' ) goto yy60 ;goto yy18 ;yy30 : yych = * ++ YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy31 ;goto yy18 ;yy31 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy31 ;if ( yych <= \':\' ) goto yy62 ;if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;+ YYCURSOR ;if ( yych == \';\' ) goto yy63 ;goto yy18 ;yy36 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy37 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy37 ;if ( yych <= \':\' ) goto yy65 ;goto yy18 ;yy39 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy40 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy40 ;if ( yych <= \':\' ) goto yy66 ;goto yy18 ;yy42 : yych = * ++ YYCURSOR ;if ( yych == \';\' ) goto yy67 ;goto yy18 ;yy43 : yych = * ++ YYCURSOR ;if ( yych == \'.\' ) goto yy45 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy46 ;goto yy18 ;yy44 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) {if ( yych != \'.\' ) goto yy18 ;}else {if ( yych <= \'9\' ) goto yy46 ;if ( yych == \'I\' ) goto yy48 ;goto yy18 ;}yy45 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy69 ;goto yy18 ;yy46 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ;yych = * YYCURSOR ;if ( yych <= \':\' ) {if ( yych <= \'.\' ) {if ( yych <= \'-\' ) goto yy18 ;goto yy69 ;}else {if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy46 ;goto yy18 ;}}else {if ( yych <= \'E\' ) {if ( yych <= \';\' ) goto yy71 ;if ( yych <= \'D\' ) goto yy18 ;goto yy73 ;}else {if ( yych == \'e\' ) goto yy73 ;goto yy18 ;}}yy48 : yych = * ++ YYCURSOR ;if ( yych == \'N\' ) goto yy74 ;goto yy18 ;yy49 : yych = * ++ YYCURSOR ;if ( yych == \'A\' ) goto yy75 ;goto yy18 ;yy50 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy51 : ++ YYCURSOR ;if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy51 ;if ( yych == \';\' ) goto yy76 ;goto yy18 ;yy53 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy54 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy54 ;if ( yych <= \':\' ) goto yy78 ;goto yy18 ;yy56 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy57 : ++ YYCURSOR ;if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy57 ;if ( yych == \';\' ) goto yy79 ;goto yy18 ;yy59 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy60 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy60 ;if ( yych <= \':\' ) goto yy81 ;goto yy18 ;yy62 : yych = * ++ YYCURSOR ;if ( yych == \\\'""\\\' ) goto yy82 ;goto yy18 ;yy63 : ++ YYCURSOR ;# line 580 ""ext/standard/var_unserializer.re"" {zend_long id ;* p = YYCURSOR ;if ( ! var_hash ) return 0 ;if ( * start == \'C\' ) {custom_object = 1 ;}len2 = len = parse_uiv ( start + 2 ) ;maxlen = max - YYCURSOR ;if ( maxlen < len || len == 0 ) {* p = start + 2 ;return 0 ;id = parse_iv ( start + 2 ) ;* p = YYCURSOR ;",1110
365,"# line 959 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy40 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy41 ;goto yy18 ;","# line 959 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;if ( yych == \'+\' ) goto yy40 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy41 ;goto yy18 ;",1110
366,"# line 735 ""ext/standard/var_unserializer.re""  {","# line 735 ""ext/standard/var_unserializer.re"" {",1110
367,"ZVAL_LONG ( rval , parse_iv ( start + 2 ) ) ;# line 1292 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \'2\' ) goto yy18 ;yych = * ++ YYCURSOR ;if ( yych != \';\' ) goto yy18 ;++ YYCURSOR ;# line 646 ""ext/standard/var_unserializer.re""  {ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ;return 1 ;# line 1306 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 640 ""ext/standard/var_unserializer.re""  {# line 1315 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;if ( yych <= \',\' ) {if ( yych != \'+\' ) goto yy18 ;}else {if ( yych <= \'-\' ) goto yy90 ;if ( yych <= \'/\' ) goto yy18 ;if ( yych <= \'9\' ) goto yy91 ;goto yy18 ;}yy90 : yych = * ++ YYCURSOR ;if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \':\' ) goto yy18 ;yy91 : ++ YYCURSOR ;","ZVAL_LONG ( rval , parse_iv ( start + 2 ) - 1 ;if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) {return 0 ;}if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) {return 0 ;}if ( Z_ISREF_P ( rval_ref ) ) {ZVAL_COPY ( rval , rval_ref ) ;}else {ZVAL_NEW_REF ( rval_ref , rval_ref ) ;ZVAL_COPY ( rval , rval_ref ) ;}+ YYCURSOR ;# line 982 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;if ( yych == \\\'""\\\' ) goto yy84 ;goto yy18 ;yy66 : yych = * ++ YYCURSOR ;if ( yych == \'{\' ) goto yy86 ;goto yy18 ;yy67 : ++ YYCURSOR ;# line 635 ""ext/standard/var_unserializer.re"" {ZVAL_BOOL ( rval , parse_iv ( YYCURSOR ;ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ;return 1 ;# line 1306 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 640 ""ext/standard/var_unserializer.re"" {# line 999 ""ext/standard/var_unserializer.c"" yy69 : ++ YYCURSOR ;",1110
368,"id = parse_iv ( start + 2 ) - 1 ;if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) {","id = parse_iv ( start + 2 ) - 1 ;if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) {",1110
369,"if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ;if ( yych <= \'9\' ) goto yy97 ;if ( yych != \';\' ) goto yy18 ;++ YYCURSOR ;# line 589 ""ext/standard/var_unserializer.re"" {zend_long id ;* p = YYCURSOR ;if ( ! var_hash ) return 0 ;id = parse_iv ( start + 2 ) - 1 ;if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) {return 0 ;zval_ptr_dtor ( rval ) ;if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) {ZVAL_UNDEF ( rval ) ;return 1 ;if ( Z_ISREF_P ( rval_ref ) ) {ZVAL_COPY ( rval , rval_ref ) ;}ZVAL_NEW_REF ( rval_ref , rval_ref ) ;ZVAL_COPY ( rval , rval_ref ) ;}# line 1412 ""ext/standard/var_unserializer.c""  }","if ( YYLIMIT <= YYCURSOR ) YYFILL ( 4 ) ;if ( yych <= \';\' ) {+ YYCURSOR ;if ( yych <= \'9\' ) goto yy69 ;if ( yych <= \':\' ) goto yy18 ;else {if ( yych <= \'E\' ) {if ( yych <= \'D\' ) goto yy18 ;goto yy73 ;if ( yych == \'e\' ) goto yy73 ;goto yy18 ;}}yy71 : ++ YYCURSOR ;# line 683 ""ext/standard/var_unserializer.re"" {# if SIZEOF_ZEND_LONG == 4 use_double : # endif * p = YYCURSOR ;ZVAL_DOUBLE ( rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ;# line 1412 ""ext/standard/var_unserializer.c"" }",1110
370,"}if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) ||  ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) {dev_err ( & djrcv_hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\\return ;","
",1111
371,"umode_t mode = inode -> i_mode ;error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error < 0 ) {gossip_err ( ""%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\\if ( error == 0 )  acl = NULL ;","umode_t mode ;error = posix_acl_update_mode ( inode , & mode ) ;if ( error < 0 ) {gossip_err ( ""%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\\",1112
372,"FILE * file = fopen ( dump_file , ""w"" ) ;if ( ! file ) {","FILE * file = fopen_safe ( dump_file , ""w"" ) ;if ( ! file ) {",1113
373,"if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ||  uid_eq ( root_uid , current_uid ( ) ) ) {int mode = ( table -> mode >> 6 ) & 7 ;if ( gid_eq ( root_gid , current_gid ( ) ) ) {int mode = ( table -> mode >> 3 ) & 7 ;","if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || uid_eq ( root_uid , current_euid ( ) ) ) {int mode = ( table -> mode >> 6 ) & 7 ;if ( in_egroup_p ( root_gid ) ) {int mode = ( table -> mode >> 3 ) & 7 ;",1114
374,# ifdef KEY_DEBUGGING  key -> magic = KEY_DEBUG_MAGIC ;,if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;# ifdef KEY_DEBUGGING key -> magic = KEY_DEBUG_MAGIC ;,1115
375,"int64_t vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , MACROBLOCK * x ,   const TileInfo * const tile ,  int mi_row , int mi_col ,  int * returnrate ,  int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) {VP9_COMMON * cm = & cpi -> common ;MACROBLOCKD * xd = & x -> e_mbd ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;const struct segmentation * seg = & cm -> seg ;MV_REFERENCE_FRAME ref_frame , second_ref_frame ;","void vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * x , int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) {VP9_COMMON * const cm = & cpi -> common ;RD_OPT * const rd_opt = & cpi -> rd ;SPEED_FEATURES * const sf = & cpi -> sf ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;const struct segmentation * const seg = & cm -> seg ;MV_REFERENCE_FRAME ref_frame , second_ref_frame ;",1116
376,"int64_t best_yrd = best_rd_so_far ;int64_t best_tx_rd [ TX_MODES ] ;int64_t best_tx_diff [ TX_MODES ] ;MB_MODE_INFO best_mbmode = {0 };int mode_index , best_mode_index = 0 ;vp9_prob comp_mode_p ;int64_t best_inter_rd = INT64_MAX ;MV_REFERENCE_FRAME best_inter_ref_frame = LAST_FRAME ;int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ;int64_t dist_uv [ TX_SIZES ] ;int skip_uv [ TX_SIZES ] ;MB_PREDICTION_MODE mode_uv [ TX_SIZES ] = {int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ;int_mv seg_mvs [ 4 ] [ MAX_REF_FRAMES ] ;int ref_frame_mask = 0 ;int mode_skip_mask = 0 ;x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;vpx_memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ;for ( i = 0 ;","MB_MODE_INFO best_mbmode ;int ref_index , best_ref_index = 0 ;vpx_prob comp_mode_p ;int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ;int64_t dist_uv ;int skip_uv [ TX_SIZES ] ;MB_PREDICTION_MODE mode_uv [ TX_SIZES ] = {int intra_cost_penalty = vp9_get_intra_cost_penalty ( cm -> base_qindex , cm -> y_dc_delta_q , cm -> bit_depth ) ;int_mv seg_mvs [ 4 ] [ MAX_REF_FRAMES ] ;int ref_frame_skip_mask [ 2 ] = {0 };int64_t mask_filter = 0 ;int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ;int internal_active_edge = vp9_active_edge_sb ( cpi , mi_row , mi_col ) && vp9_internal_image_edge ( cpi ) ;x -> skip_encode = sf -> skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ;vp9_zero ( best_mbmode ) ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;++ i ) filter_cache [ i ] = INT64_MAX ;for ( i = 0 ;",1116
377,"estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp ,  & comp_mode_p ) ;i < REFERENCE_MODES ;++ i ) best_pred_rd [ i ] = INT64_MAX ;for ( i = 0 ;i < TX_MODES ;i ++ )   best_tx_rd [ i ] = INT64_MAX ;for ( i = 0 ;i ++ )  best_filter_rd [ i ] = INT64_MAX ;i ++ ) rate_uv_intra [ i ] = INT_MAX ;* returnrate = INT_MAX ;for ( ref_frame = LAST_FRAME ;vp9_setup_buffer_inter ( cpi , x , tile ,  ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ;frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ;frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ;","estimate_ref_frame_costs ( cm , xd , segment_id , ref_costs_single , ref_costs_comp , & comp_mode_p ) ;+ i ) best_pred_rd [ i ] = INT64_MAX ;i ++ ) best_tx_rd [ i ] = INT64_MAX ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;i ++ ) best_filter_rd [ i ] = INT64_MAX ;i ++ ) best_filter_rd [ i ] = INT_MAX ;* returnrate = INT_MAX ;for ( ref_frame = LAST_FRAME ;vp9_setup_buffer_inter ( cpi , x , tile , ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ;frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ;frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ;",1116
378,"break ;}for ( mode_index = 0 ;int mode_excluded = 0 ;int disable_skip = 0 ;int compmode_cost = 0 ;int rate2 = 0 , rate_y = 0 , rate_uv = 0 ;int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ;int skippable = 0 ;int64_t tx_cache [ TX_MODES ] ;int i ;int this_skip2 = 0 ;int64_t total_sse = INT_MAX ;for ( i = 0 ;++ i )  tx_cache [ i ] = INT64_MAX ;ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 0 ] ;second_ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 1 ] ;if ( mode_index > 2 && cpi -> sf . mode_skip_start < MAX_MODES ) {if ( mode_index == 3 ) {switch ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] ) {case INTRA_FRAME :  mode_skip_mask = 0 ;break ;case LAST_FRAME :  mode_skip_mask = 0x0010 ;break ;case GOLDEN_FRAME :  mode_skip_mask = 0x0008 ;break ;case ALTREF_FRAME :  mode_skip_mask = 0x0000 ;break ;}}if ( mode_skip_mask & ( 1 << mode_index ) )  continue ;}if ( ( best_rd <  ( ( int64_t ) cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] *   cpi -> rd_thresh_freq_sub8x8 [ bsize ] [ mode_index ] >> 5 ) ) ||  cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] == INT_MAX ) continue ;if ( ( second_ref_frame > INTRA_FRAME ) &&  vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ;mbmi -> ref_frame [ 0 ] = ref_frame ;mbmi -> ref_frame [ 1 ] = second_ref_frame ;comp_pred = second_ref_frame > INTRA_FRAME ;if ( comp_pred ) {set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ;mbmi -> uv_mode = DC_PRED ;if ( comp_pred ) {if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ;","break ;}for ( mode_index = 0 ;int mode_excluded = 0 ;rate_uv_intra = INT_MAX ;for ( i = 0 ;+ i )  tx_cache [ i ] = INT64_MAX ;++ i ) tx_cache [ i ] = INT64_MAX ;ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 0 ] ;second_ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 1 ] ;if ( mode_index > 2 && cpi -> sf . mode_skip_start < MAX_MODES ) {if ( mode_index == 3 ) {switch ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] ) {case INTRA_FRAME : mode_skip_mask = 0 ;break ;case LAST_FRAME : mode_skip_mask = 0x0010 ;break ;case GOLDEN_FRAME : mode_skip_mask = 0x0008 ;break ;case ALTREF_FRAME : mode_skip_mask = 0x0000 ;break ;}}if ( mode_skip_mask & ( 1 << mode_index ) ) continue ;}if ( ( best_rd < ( ( int64_t ) cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] * cpi -> rd_thresh_freq_sub8x8 [ bsize ] [ mode_index ] >> 5 ) ) || cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] == INT_MAX ) continue ;if ( ( second_ref_frame > INTRA_FRAME ) && vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ;mbmi -> ref_frame [ 0 ] = ref_frame ;mbmi -> ref_frame [ 1 ] = second_ref_frame ;comp_pred = second_ref_frame > INTRA_FRAME ;if ( comp_pred ) {set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ;mbmi -> uv_mode = DC_PRED ;if ( comp_pred ) {if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ;",1116
379,"if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) &&  vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) {","if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) {",1116
380,"mbmi -> tx_size = TX_4X4 ;if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate , & rate_y , & distortion_y , best_rd ) >= best_rd ) continue ;if ( rate_uv_intra [ TX_4X4 ] == INT_MAX ) {choose_intra_uv_mode ( cpi , ctx , bsize , TX_4X4 ,   & rate_uv_intra [ TX_4X4 ] ,   & rate_uv_tokenonly [ TX_4X4 ] ,   & dist_uv [ TX_4X4 ] , & skip_uv [ TX_4X4 ] ,   & mode_uv [ TX_4X4 ] ) ;}rate2 += rate_uv_intra [ TX_4X4 ] ;rate_uv = rate_uv_tokenonly [ TX_4X4 ] ;distortion2 += dist_uv [ TX_4X4 ] ;distortion_uv = dist_uv [ TX_4X4 ] ;mbmi -> uv_mode = mode_uv [ TX_4X4 ] ;tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;","mbmi -> tx_size = TX_4X4 ;if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate , & rate_y , & distortion_y , best_rd ) >= best_rd ) continue ;if ( rate_uv_intra [ TX_4X4 ] == INT_MAX ) {choose_intra_uv_mode ( cpi , ctx , bsize , TX_4X4 , & rate_uv_intra [ TX_4X4 ] , & rate_uv_tokenonly [ TX_4X4 ] , & dist_uv [ TX_4X4 ] , & skip_uv [ TX_4X4 ] , & mode_uv [ TX_4X4 ] ) ;}rate2 += rate_uv_intra [ TX_4X4 ] ;rate_uv = rate_uv_tokenonly [ TX_4X4 ] ;distortion2 += dist_uv [ TX_4X4 ] ;distortion_uv = dist_uv [ TX_4X4 ] ;mbmi -> uv_mode = mode_uv [ TX_4X4 ] ;tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;",1116
381,"int64_t tmp_best_distortion = INT_MAX , tmp_best_sse , uv_sse ;int tmp_best_skippable = 0 ;int switchable_filter_index ;int_mv * second_ref = comp_pred ?  & mbmi -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ;b_mode_info tmp_best_bmodes [ 16 ] ;MB_MODE_INFO tmp_best_mbmode ;BEST_SEG_INFO bsi [ SWITCHABLE_FILTERS ] ;int pred_exists = 0 ;int uv_skippable ;this_rd_thresh = ( ref_frame == LAST_FRAME ) ?  cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_LAST ] :   cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_ALTR ] ;this_rd_thresh = ( ref_frame == GOLDEN_FRAME ) ?  cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_GOLD ] : this_rd_thresh ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;cpi -> mask_filter_rd = 0 ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;++ i )  cpi -> rd_filter_cache [ i ] = INT64_MAX ;if ( cm -> interp_filter != BILINEAR ) {tmp_best_filter = EIGHTTAP ;if ( x -> source_variance <  cpi -> sf . disable_filter_search_var_thresh ) {tmp_best_filter = EIGHTTAP ;}else if ( cpi -> sf . adaptive_pred_interp_filter == 1 &&  ctx -> pred_interp_filter < SWITCHABLE ) {tmp_best_filter = ctx -> pred_interp_filter ;}else if ( cpi -> sf . adaptive_pred_interp_filter == 2 ) {tmp_best_filter = ctx -> pred_interp_filter < SWITCHABLE ? ctx -> pred_interp_filter : 0 ;}else {for ( switchable_filter_index = 0 ;switchable_filter_index < SWITCHABLE_FILTERS ;++ switchable_filter_index ) {int newbest , rs ;int64_t rs_rd ;mbmi -> interp_filter = switchable_filter_index ;tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile ,  & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , second_ref , best_yrd , & rate , & rate_y , & distortion , & skippable , & total_sse , ( int ) this_rd_thresh , seg_mvs , bsi , switchable_filter_index , mi_row , mi_col ) ;if ( tmp_rd == INT64_MAX ) continue ;rs = vp9_get_switchable_rate ( x ) ;rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ;cpi -> rd_filter_cache [ switchable_filter_index ] = tmp_rd ;cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] =   MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] ,  tmp_rd + rs_rd ) ;if ( cm -> interp_filter == SWITCHABLE ) tmp_rd += rs_rd ;cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , tmp_rd ) ;newbest = ( tmp_rd < tmp_best_rd ) ;if ( newbest ) {tmp_best_filter = mbmi -> interp_filter ;tmp_best_rd = tmp_rd ;}if ( ( newbest && cm -> interp_filter == SWITCHABLE ) || ( mbmi -> interp_filter == cm -> interp_filter && cm -> interp_filter != SWITCHABLE ) ) {tmp_best_rdu = tmp_rd ;tmp_best_rate = rate ;tmp_best_ratey = rate_y ;tmp_best_distortion = distortion ;tmp_best_sse = total_sse ;tmp_best_skippable = skippable ;tmp_best_mbmode = * mbmi ;for ( i = 0 ;i < 4 ;i ++ ) {tmp_best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ;x -> zcoeff_blk [ TX_4X4 ] [ i ] = ! x -> plane [ 0 ] . eobs [ i ] ;}pred_exists = 1 ;if ( switchable_filter_index == 0 &&  cpi -> sf . use_rd_breakout &&  best_rd < INT64_MAX ) {if ( tmp_best_rdu / 2 > best_rd ) {tmp_best_filter = mbmi -> interp_filter ;tmp_best_rdu = INT64_MAX ;break ;}}}}}}if ( tmp_best_rdu == INT64_MAX && pred_exists ) continue ;mbmi -> interp_filter = ( cm -> interp_filter == SWITCHABLE ? tmp_best_filter : cm -> interp_filter ) ;if ( ! pred_exists ) {tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile ,  & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , second_ref , best_yrd , & rate , & rate_y , & distortion , & skippable , & total_sse , ( int ) this_rd_thresh , seg_mvs , bsi , 0 , mi_row , mi_col ) ;if ( tmp_rd == INT64_MAX ) continue ;else {total_sse = tmp_best_sse ;rate = tmp_best_rate ;rate_y = tmp_best_ratey ;distortion = tmp_best_distortion ;skippable = tmp_best_skippable ;* mbmi = tmp_best_mbmode ;for ( i = 0 ;i < 4 ;i ++ ) xd -> mi [ 0 ] -> bmi [ i ] = tmp_best_bmodes [ i ] ;}rate2 += rate ;distortion2 += distortion ;if ( cm -> interp_filter == SWITCHABLE )  rate2 += vp9_get_switchable_rate ( x ) ;if ( ! mode_excluded ) mode_excluded = comp_pred ? cm -> reference_mode == SINGLE_REFERENCE : cm -> reference_mode == COMPOUND_REFERENCE ;compmode_cost = vp9_cost_bit ( comp_mode_p , comp_pred ) ;tmp_best_rdu = best_rd - MIN ( RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) , RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) ;if ( tmp_best_rdu > 0 ) {vp9_build_inter_predictors_sbuv ( & x -> e_mbd , mi_row , mi_col , BLOCK_8X8 ) ;super_block_uvrd ( cpi , x , & rate_uv , & distortion_uv , & uv_skippable ,   & uv_sse , BLOCK_8X8 , tmp_best_rdu ) ;if ( rate_uv == INT_MAX ) continue ;rate2 += rate_uv ;distortion2 += distortion_uv ;skippable = skippable && uv_skippable ;total_sse += uv_sse ;tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;for ( i = 0 ;i < TX_MODES ;++ i ) tx_cache [ i ] = tx_cache [ ONLY_4X4 ] ;}}if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) rate2 += compmode_cost ;if ( second_ref_frame > INTRA_FRAME ) {rate2 += ref_costs_comp [ ref_frame ] ;}else {rate2 += ref_costs_single [ ref_frame ] ;}if ( ! disable_skip ) {const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id ,  SEG_LVL_SKIP ) ;if ( mb_skip_allowed && ref_frame != INTRA_FRAME && ! xd -> lossless ) {if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;}else {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;distortion2 = total_sse ;assert ( total_sse >= 0 ) ;rate2 -= ( rate_y + rate_uv ) ;rate_y = 0 ;rate_uv = 0 ;this_skip2 = 1 ;}}else if ( mb_skip_allowed ) {rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;}this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;}if ( is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) && ! has_second_ref ( & xd -> mi [ 0 ] -> mbmi ) && ! mode_excluded && this_rd < best_inter_rd ) {best_inter_rd = this_rd ;best_inter_ref_frame = ref_frame ;}if ( ! disable_skip && ref_frame == INTRA_FRAME ) {for ( i = 0 ;i < REFERENCE_MODES ;++ i ) best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;i ++ ) best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ;}if ( this_rd < best_rd || x -> skip ) {if ( ! mode_excluded ) {int max_plane = MAX_MB_PLANE ;best_mode_index = mode_index ;if ( ref_frame == INTRA_FRAME ) {mbmi -> mv [ 0 ] . as_int = 0 ;max_plane = 1 ;}* returnrate = rate2 ;* returndistortion = distortion2 ;best_rd = this_rd ;best_yrd = best_rd - RDCOST ( x -> rdmult , x -> rddiv , rate_uv , distortion_uv ) ;best_mbmode = * mbmi ;best_skip2 = this_skip2 ;if ( ! x -> select_txfm_size )   swap_block_ptr ( x , ctx , max_plane ) ;vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] ,   sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ;for ( i = 0 ;i < 4 ;i ++ ) best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ;if ( ( cpi -> sf . mode_search_skip_flags & FLAG_EARLY_TERMINATE ) &&   ( mode_index > MIN_EARLY_TERM_INDEX ) ) {const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ;int scale = 4 ;if ( x -> source_variance < UINT_MAX ) {const int var_adjust = ( x -> source_variance < 16 ) ;scale -= var_adjust ;}if ( ref_frame > INTRA_FRAME && distortion2 * scale < qstep * qstep ) {early_term = 1 ;}}}}if ( ! disable_skip && ref_frame != INTRA_FRAME ) {int64_t single_rd , hybrid_rd , single_rate , hybrid_rate ;if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {single_rate = rate2 - compmode_cost ;hybrid_rate = rate2 ;}else {single_rate = rate2 ;hybrid_rate = rate2 + compmode_cost ;}single_rd = RDCOST ( x -> rdmult , x -> rddiv , single_rate , distortion2 ) ;hybrid_rd = RDCOST ( x -> rdmult , x -> rddiv , hybrid_rate , distortion2 ) ;if ( second_ref_frame <= INTRA_FRAME &&   single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) {best_pred_rd [ SINGLE_REFERENCE ] = single_rd ;}else if ( second_ref_frame > INTRA_FRAME &&   single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) {best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ;}if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] ) best_pred_rd [ REFERENCE_MODE_SELECT ] = hybrid_rd ;}if ( ! mode_excluded && ! disable_skip && ref_frame != INTRA_FRAME && cm -> interp_filter != BILINEAR ) {int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ?  SWITCHABLE_FILTERS : cm -> interp_filter ] ;int64_t adj_rd ;for ( i = 0 ;i < SWITCHABLE_FILTER_CONTEXTS ;i ++ ) {if ( ref == INT64_MAX ) adj_rd = 0 ;else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX )   adj_rd = cpi -> mask_filter_rd - ref + 10 ;else  adj_rd = cpi -> rd_filter_cache [ i ] - ref ;adj_rd += this_rd ;best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ;}}if ( bsize < BLOCK_32X32 ) {if ( bsize < BLOCK_16X16 ) {tx_cache [ ALLOW_8X8 ] = tx_cache [ ONLY_4X4 ] ;tx_cache [ ALLOW_16X16 ] = tx_cache [ ALLOW_8X8 ] ;}tx_cache [ ALLOW_32X32 ] = tx_cache [ ALLOW_16X16 ] ;}if ( ! mode_excluded && this_rd != INT64_MAX ) {for ( i = 0 ;i < TX_MODES && tx_cache [ i ] < INT64_MAX ;i ++ ) {int64_t adj_rd = INT64_MAX ;if ( ref_frame > INTRA_FRAME ) adj_rd = this_rd + tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ;else adj_rd = this_rd ;if ( adj_rd < best_tx_rd [ i ] ) best_tx_rd [ i ] = adj_rd ;}}if ( early_term ) break ;if ( x -> skip && ! comp_pred ) break ;}if ( best_rd >= best_rd_so_far )  return INT64_MAX ;if ( cpi -> sf . use_uv_intra_rd_estimate ) {if ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) {TX_SIZE uv_tx_size ;* mbmi = best_mbmode ;uv_tx_size = get_uv_tx_size ( mbmi ) ;rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] ,   & rate_uv_tokenonly [ uv_tx_size ] ,   & dist_uv [ uv_tx_size ] ,   & skip_uv [ uv_tx_size ] ,   BLOCK_8X8 , uv_tx_size ) ;}}if ( best_rd == INT64_MAX && bsize < BLOCK_8X8 ) {* returnrate = INT_MAX ;* returndistortion = INT64_MAX ;return best_rd ;}if ( cpi -> sf . adaptive_rd_thresh ) {for ( mode_index = 0 ;","+ i )  cpi -> rd_filter_cache [ i ] = INT64_MAX ;+ switchable_filter_index ) {rd_cost -> rate = INT_MAX ;* returndistortion = INT64_MAX ;return best_rd ;+ i ) tx_cache [ i ] = tx_cache [ ONLY_4X4 ] ;+ i ) best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ;if ( cpi -> sf . adaptive_rd_thresh ) {for ( mode_index = 0 ;",1116
382,"++ i )  vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ;mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ;","+ i )  vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ;++ i ) vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ;mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ;",1116
383,if ( ! x -> skip ) {for ( i = 0 ;,if ( ! x -> skip ) {for ( i = 0 ;,1116
384,"store_coding_context ( x , ctx , best_mode_index ,  & mbmi -> ref_mvs [ mbmi -> ref_frame [ 0 ] ] [ 0 ] , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ] [ 0 ] ,  best_pred_diff , best_tx_diff , best_filter_diff ) ;return best_rd ;","store_coding_context ( x , ctx , 1 , 0 , 0 , best_mode_index , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 0 ] ] [ 0 ] , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ] [ 0 ] , best_pred_diff , best_filter_diff , 0 ) ;",1116
385,the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;},the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;},1117
386,else {err = - EINVAL ;goto out ;}}else {* policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ;* policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ;}if ( vma ) {up_read ( & current -> mm -> mmap_sem ) ;vma = NULL ;},"
",1118
387,"return ;}switch ( ( gdAffineStandardMatrix ) type ) {case GD_AFFINE_TRANSLATE : case GD_AFFINE_SCALE : {double x , y ;if ( Z_TYPE_P ( options ) != IS_ARRAY ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Array<S2SV_blank>expected<S2SV_blank>as<S2SV_blank>options"" ) ;}if ( zend_hash_find ( HASH_OF ( options ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) {convert_to_double_ex ( tmp ) ;x = Z_DVAL_PP ( tmp ) ;}convert_to_double_ex ( tmp ) ;y = Z_DVAL_PP ( tmp ) ;}",if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;x = Z_DVAL ( dval ) ;}else {x = Z_DVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;y = Z_DVAL ( dval ) ;}else {y = Z_DVAL_PP ( tmp ) ;}},1119
388,L -> oldpc = pc + 1 ;},L -> oldpc = 1 ;},1120
389,int64_t off = s -> off ;int len = 0 ;,uint64_t off = s -> off ;int len = 0 ;,1121
390,"len += av_strlcatf ( headers + len , sizeof ( headers ) - len ,  ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ;if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ;","len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Range:<S2SV_blank>bytes=%"" PRIu64 ""-"" , s -> off ) ;if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ;",1121
391,s -> filesize = - 1 ;s -> willclose = 0 ;,s -> filesize = UINT64_MAX ;s -> willclose = 0 ;,1121
392,"uint_fast32_t rawsize ;uint_fast32_t inmem ;if ( ! ( image = jas_image_create0 ( ) ) ) {return 0 ;}image -> inmem_ = true ;if ( ! ( image -> cmpts_ = jas_alloc2 ( image -> maxcmpts_ , sizeof ( jas_image_cmpt_t * ) ) ) ) {jas_image_destroy ( image ) ;return 0 ;}rawsize = 0 ;for ( cmptno = 0 , cmptparm = cmptparms ;++ cmptno ,   ++ cmptparm ) {if ( ! ( image -> cmpts_ [ cmptno ] = jas_image_cmpt_create ( cmptparm -> tlx , cmptparm -> tly , cmptparm -> hstep , cmptparm -> vstep , cmptparm -> width , cmptparm -> height , cmptparm -> prec , cmptparm -> sgnd , inmem ) ) ) {jas_image_destroy ( image ) ;return 0 ;}++ image -> numcmpts_ ;}","size_t rawsize ;uint_fast32_t inmem ;image = 0 ;JAS_DBGLOG ( 100 , ( ""jas_image_create(%d,<S2SV_blank>%p,<S2SV_blank>%d)\\\if ( ! ( image = jas_image_create0 ( ) ) ) {goto error ;}if ( ! ( image -> cmpts_ = jas_alloc2 ( image -> maxcmpts_ , sizeof ( jas_image_cmpt_t * ) ) ) ) {goto error ;}# if 0 rawsize = 0 ;# endif for ( cmptno = 0 , cmptparm = cmptparms ;+ cmptno ,   ++ cmptparm ) {+ image -> numcmpts_ ;++ cmptno , ++ cmptparm ) {if ( ! jas_safe_size_mul3 ( cmptparm -> width , cmptparm -> height , ( cmptparm -> prec + 7 ) , & rawsize ) ) {goto error ;}++ image -> numcmpts_ ;}}error : if ( image ) {goto error ;}rawsize /= 8 ;inmem = ( rawsize < JAS_IMAGE_INMEMTHRESH ) ;if ( ! ( image -> cmpts_ [ cmptno ] = jas_image_cmpt_create ( cmptparm -> tlx , cmptparm -> tly , cmptparm -> hstep , cmptparm -> vstep , cmptparm -> width , cmptparm -> height , cmptparm -> prec , cmptparm -> sgnd , inmem ) ) ) {jas_image_destroy ( image ) ;return 0 ;",1122
393,unsigned int i ;cmap -> numchans = ( box -> datalen ) / 4 ;,unsigned int i ;cmap -> ents = 0 ;cmap -> numchans = ( box -> datalen ) / 4 ;,1123
394,"if ( client -> priv -> conn != NULL ) {SmsCleanUp ( client -> priv -> conn ) ;}if ( client -> priv -> ice_connection != NULL ) {IceSetShutdownNegotiation ( client -> priv -> ice_connection , FALSE ) ;IceCloseConnection ( client -> priv -> ice_connection ) ;}if ( client -> priv -> protocol_timeout > 0 ) {g_source_remove ( client -> priv -> protocol_timeout ) ;}","
",1124
395,"VP9_COMMON * const cm = & ctx -> pbi -> common ;cm -> new_fb_idx = - 1 ;if ( ctx -> get_ext_fb_cb != NULL && ctx -> release_ext_fb_cb != NULL ) {cm -> get_fb_cb = ctx -> get_ext_fb_cb ;cm -> release_fb_cb = ctx -> release_ext_fb_cb ;cm -> cb_priv = ctx -> ext_priv ;}cm -> get_fb_cb = vp9_get_frame_buffer ;cm -> release_fb_cb = vp9_release_frame_buffer ;if ( vp9_alloc_internal_frame_buffers ( & cm -> int_frame_buffers ) )  vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>internal<S2SV_blank>frame<S2SV_blank>buffers"" ) ;cm -> cb_priv = & cm -> int_frame_buffers ;}}","int i ;for ( i = 0 ;i < ctx -> num_frame_workers ;++ i ) {VPxWorker * const worker = & ctx -> frame_workers [ i ] ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ;BufferPool * const pool = cm -> buffer_pool ;cm -> new_fb_idx = INVALID_IDX ;cm -> byte_alignment = ctx -> byte_alignment ;cm -> skip_loop_filter = ctx -> skip_loop_filter ;if ( ctx -> get_ext_fb_cb != NULL && ctx -> release_ext_fb_cb != NULL ) {pool -> get_fb_cb = ctx -> get_ext_fb_cb ;pool -> release_fb_cb = ctx -> release_ext_fb_cb ;pool -> cb_priv = ctx -> ext_priv ;}pool -> get_fb_cb = vp9_get_frame_buffer ;cm -> release_fb_cb = vp9_release_frame_buffer ;if ( vp9_alloc_internal_frame_buffers ( & pool -> int_frame_buffers ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>internal<S2SV_blank>frame<S2SV_blank>buffers"" ) ;pool -> cb_priv = & cm -> int_frame_buffers ;}}}",1125
396,"static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName ,   int udfLen , uint8_t * fidName ,  int fidNameLen ) {","static int udf_translate_to_linux ( uint8_t * newName , int newLen , uint8_t * udfName , int udfLen , uint8_t * fidName , int fidNameLen ) {",1126
397,if ( newIndex < 256 )  newName [ newIndex ++ ] = curr ;,if ( newIndex < newLen ) newName [ newIndex ++ ] = curr ;,1126
398,maxFilenameLen = 250 - localExtIndex ;if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ;else newIndex = newExtIndex ;}else if ( newIndex > 250 )  newIndex = 250 ;,maxFilenameLen = newLen - CRC_LEN - localExtIndex ;if ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN ;,1126
399,"hw_init ( LOW_FREQUENCY ) ;if ( ! tsc_sensor_exists ( ) ) {if ( _NFC_status == NFC_IS_ACTIVE ) {printf1 ( TAG_NFC , ""Have<S2SV_blank>NFC\\\\r\\\isLowFreq = 1 ;IS_BUTTON_PRESSED = is_physical_button_pressed ;}else {printf1 ( TAG_NFC , ""Have<S2SV_blank>NO<S2SV_blank>NFC\\\\r\\\hw_init ( HIGH_FREQUENCY ) ;isLowFreq = 0 ;device_init_button ( ) ;}usbhid_init ( ) ;ctaphid_init ( ) ;ctap_init ( ) ;device_migrate ( ) ;# if BOOT_TO_DFU  flash_option_bytes_init ( 1 ) ;# else flash_option_bytes_init ( 0 ) ;# endif }",hw_init ( LOW_FREQUENCY ) ;# if BOOT_TO_DFU flash_option_bytes_init ( 1 ) ;# else flash_option_bytes_init ( 0 ) ;# endif if ( ! tsc_sensor_exists ( ) ) {,1127
400,"status = ocfs2_rw_lock ( inode , 1 ) ;if ( status < 0 ) {","inode_dio_wait ( inode ) ;status = ocfs2_rw_lock ( inode , 1 ) ;if ( status < 0 ) {",1128
401,if ( status )  goto bail_unlock ;inode_dio_wait ( inode ) ;,if ( status ) goto bail_unlock ;,1128
402,"static void sas_destruct_devices ( struct work_struct * work )  {struct domain_device * dev , * n ;struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ;struct asd_sas_port * port = ev -> port ;clear_bit ( DISCE_DESTRUCT , & port -> disc . pending ) ;","void sas_destruct_devices ( struct work_struct * work ) {struct domain_device * dev , * n ;",1129
403,while ( ! EOFBlob ( image ) )  {if ( filepos != ( unsigned int ) filepos )  break ;if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) )  goto MATLAB_KO ;,while ( filepos < GetBlobSize ( image ) && ! EOFBlob ( image ) ) {if ( filepos > GetBlobSize ( image ) || filepos < 0 ) break ;if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) >= GetBlobSize ( image ) ) goto MATLAB_KO ;,1130
404,"if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) ,  ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ;goto ExitLoop ;","ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ;goto ExitLoop ;",1130
405,"char * fmtname ;if ( jas_init ( ) ) {while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_INFILE :  infile = jas_optarg ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {","char * fmtname ;int debug ;if ( jas_init ( ) ) {debug = 0 ;while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) {switch ( id ) {case OPT_DEBUG : debug = atoi ( jas_optarg ) ;break ;case OPT_INFILE : infile = jas_optarg ;jas_setdbglevel ( debug ) ;if ( infile ) {if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) {jas_stream_close ( instream ) ;",1131
406,"if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\","if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {fprintf ( stderr , ""cannot<S2SV_blank>load<S2SV_blank>image\\\",1131
407,"
","ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ;",1132
408,ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ;ps_codec -> i4_bytes_remaining -= ( nal_ofst + nal_len ) ;,ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ;ps_codec -> i4_bytes_remaining -= ( nal_ofst + nal_len ) ;,1132
409,"nfca_poll -> rats_res_len = * data ++ ;pr_debug ( ""rats_res_len<S2SV_blank>%d\\\nfcb_poll -> attrib_res_len = * data ++ ;pr_debug ( ""attrib_res_len<S2SV_blank>%d\\\","nfca_poll -> rats_res_len = min_t ( __u8 , * data ++ , 20 ) ;pr_debug ( ""rats_res_len<S2SV_blank>%d\\\nfcb_poll -> attrib_res_len = min_t ( __u8 , * data ++ , 50 ) ;pr_debug ( ""attrib_res_len<S2SV_blank>%d\\\",1133
410,p = find_eoq ( cmd + 1 ) ;if ( ! p || ! * p ) {,p = cmd [ 0 ] ? find_eoq ( cmd + 1 ) : NULL ;if ( ! p || ! * p ) {,1134
411,struct hns_roce_ib_alloc_ucontext_resp resp ;struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ;,struct hns_roce_ib_alloc_ucontext_resp resp = {};struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ;,1135
412,"int retval = 0 ;int bytes_read = 0 ;retval = - ENODEV ;goto exit ;bytes_read = snprintf ( in_buffer , 20 , ""%lld\\\spin_unlock_irqrestore ( & dev -> lock , flags ) ;if ( * ppos < bytes_read ) {if ( copy_to_user ( buffer , in_buffer + * ppos , bytes_read - * ppos ) ) retval = - EFAULT ;else {retval = bytes_read - * ppos ;* ppos += bytes_read ;}exit : mutex_unlock ( & dev -> io_mutex ) ;return retval ;}","int len = 0 ;int bytes_read = 0 ;mutex_unlock ( & dev -> io_mutex ) ;return - ENODEV ;len = snprintf ( in_buffer , 20 , ""%lld\\\spin_unlock_irqrestore ( & dev -> lock , flags ) ;mutex_unlock ( & dev -> io_mutex ) ;return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) ;",1136
413,"dagid_str = ip6addr_string ( ndo , dao -> rpl_dagid ) ;bp += DAGID_LEN ;length -= DAGID_LEN ;}ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u%s%s,%02x]"" , dagid_str , dao -> rpl_daoseq , dao -> rpl_instanceid , RPL_DAO_K ( dao -> rpl_flags ) ? "",acK"" : """" , RPL_DAO_D ( dao -> rpl_flags ) ? "",Dagid"" : """" , dao -> rpl_flags ) ) ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;","dagid_str = ip6addr_string ( ndo , ""%s"" , rpl_tstr ) ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",1137
414,"int16_t vp9_dc_quant ( int qindex , int delta ) {return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;}","int16_t vp9_dc_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) {# if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) {case VPX_BITS_8 : return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;case VPX_BITS_10 : return dc_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ;case VPX_BITS_12 : return dc_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ;return - 1 ;}# else ( void ) bit_depth ;return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;# endif }",1138
415,"
",else {matvar -> name [ tmp - 1 ] = \'\\\\0\' ;},1139
416,}matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ;,}matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ;,1139
417,"err = aead_register_instance ( tmpl , inst ) ;if ( err ) goto out_drop_aead ;","inst -> free = pcrypt_free ;err = aead_register_instance ( tmpl , inst ) ;if ( err ) goto out_drop_aead ;",1140
418,if ( addr & ( shmlba - 1 ) ) {if ( shmflg & SHM_RND )  addr &= ~ ( shmlba - 1 ) ;,if ( ( addr & ( shmlba - 1 ) ) {if ( shmflg & SHM_RND ) && addr >= shmlba ) addr &= ~ ( shmlba - 1 ) ;,1141
419,"return ( ( Image * ) NULL ) ;}iris_info . magic = ReadBlobMSBShort ( image ) ;do {if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ;switch ( iris_info . storage ) {case 0x00 : image -> compression = NoCompression ;break ;case 0x01 : image -> compression = RLECompression ;break ;default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ;if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;iris_info . rows = ReadBlobMSBShort ( image ) ;iris_info . depth = ReadBlobMSBShort ( image ) ;if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . minimum_value = ReadBlobMSBLong ( image ) ;iris_info . maximum_value = ReadBlobMSBLong ( image ) ;iris_info . sans = ReadBlobMSBLong ( image ) ;( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * )   iris_info . name ) ;iris_info . name [ sizeof ( iris_info . name ) - 1 ] = \'\\\\0\' ;( void ) count ;image -> columns = iris_info . columns ;","count = ReadBlob ( image , sizeof ( iris_info . name ) ;if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) , ( unsigned char * ) iris_info . name ) ;iris_info . name [ sizeof ( iris_info . name ) - 1 ] = \'\\\\0\' ;( void ) count ;image -> columns = iris_info . columns ;",1142
420,"if ( EOFBlob ( image ) != MagickFalse )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1142
421,"if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ;SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ;p += 4 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( bytes_per_pixel == 2 ) {for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {quantum = ( * p << 8 ) ;quantum |= ( * ( p + 1 ) ) ;SetPixelIndex ( image , ( Quantum ) quantum , q ) ;p += 8 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelIndex ( image , * p , q ) ;p += 4 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;}pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",if ( ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;,1142
422,"STREAM out ;in_uint16_le ( in , tick ) ;","STREAM out ;struct stream packet = * in ;if ( ! s_check_rem ( in , 4 ) ) {rdp_protocol_error ( ""rdpsnd_process_training(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>training<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint16_le ( in , tick ) ;",1143
423,"dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\bsg_set_block ( bd , file ) ;","dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;bsg_set_block ( bd , file ) ;",1144
424,"const VP9_CONFIG * oxcf = & cpi -> oxcf ;const RATE_CONTROL * rc = & cpi -> rc ;int64_t critical_level = oxcf -> optimal_buffer_level >> 2 ;int64_t buff_lvl_step = 0 ;int active_worst_quality ;if ( cm -> frame_type == KEY_FRAME ) return rc -> worst_quality ;if ( cm -> current_video_frame > 1 )  active_worst_quality = MIN ( rc -> worst_quality ,  rc -> avg_frame_qindex [ INTER_FRAME ] * 5 / 4 ) ;else active_worst_quality = MIN ( rc -> worst_quality ,  rc -> avg_frame_qindex [ KEY_FRAME ] * 3 / 2 ) ;if ( rc -> buffer_level > oxcf -> optimal_buffer_level ) {","const RATE_CONTROL * rc = & cpi -> oxcf ;const RATE_CONTROL * rc = & cpi -> rc ;int64_t critical_level = oxcf -> optimal_buffer_level >> 3 ;int64_t buff_lvl_step = 0 ;int active_worst_quality ;int ambient_qp ;unsigned int num_frames_weight_key = 5 * cpi -> svc . number_temporal_layers ;if ( cm -> frame_type == KEY_FRAME ) return rc -> worst_quality ;ambient_qp = ( cm -> current_video_frame > 1 ) active_worst_quality = MIN ( rc -> worst_quality , rc -> avg_frame_qindex [ INTER_FRAME ] , rc -> avg_frame_qindex [ KEY_FRAME ] * 3 / 2 ) ;if ( rc -> buffer_level > oxcf -> optimal_buffer_level ) {",1145
425,adjustment =  ( int ) ( ( rc -> worst_quality - rc -> avg_frame_qindex [ INTER_FRAME ] ) *   ( oxcf -> optimal_buffer_level - rc -> buffer_level ) /  buff_lvl_step ) ;active_worst_quality = rc -> avg_frame_qindex [ INTER_FRAME ] + adjustment ;,"adjustment = ( int ) ( ( rc -> worst_quality - rc -> avg_frame_qindex [ INTER_FRAME ] ;active_worst_quality = MIN ( rc -> worst_quality , ambient_qp * 5 / 4 ) ;if ( rc -> buffer_level > rc -> optimal_buffer_level ) {int max_adjustment_down = active_worst_quality / 3 ;if ( max_adjustment_down ) {buff_lvl_step = ( ( rc -> maximum_buffer_size - rc -> optimal_buffer_level ) / max_adjustment_down ) ;if ( buff_lvl_step ) adjustment = ( int ) ( ( rc -> buffer_level - rc -> optimal_buffer_level ) / buff_lvl_step ) ;active_worst_quality -= adjustment ;}}else if ( rc -> buffer_level > critical_level ) {if ( critical_level ) {buff_lvl_step = ( rc -> optimal_buffer_level - critical_level ) ;if ( buff_lvl_step ) {adjustment = ( int ) ( ( rc -> worst_quality - ambient_qp ) * ( rc -> optimal_buffer_level - rc -> buffer_level ) / buff_lvl_step ) ;active_worst_quality = ambient_qp + adjustment ;",1145
426,if ( ! ( buf = g_try_malloc ( size ) ) ) {# ifdef DEBUG g_assert_not_reached ( ) ;,if ( ! ( buf = g_try_malloc0 ( size ) ) ) {# ifdef DEBUG g_assert_not_reached ( ) ;,1146
427,alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,if ( ! pcu -> ctrl_intf ) return - EINVAL ;alt = pcu -> ctrl_intf -> cur_altsetting ;pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ;if ( ! pcu -> data_intf ) return - EINVAL ;alt = pcu -> data_intf -> cur_altsetting ;if ( alt -> desc . bNumEndpoints != 2 ) {,1147
428,"ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;",1148
429,"ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 8 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 1 ) ;if ( bp [ hlen ] & 0xf0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( bp [ hlen ] & 0x10 )  ND_PRINT ( ( ndo , ""K"" ) ) ;hlen += 1 ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;hlen += 2 ;break ;case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK2 ( * mh , hlen + 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( * mh , hlen + 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;","ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x"" , type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;if ( bp [ hlen ] & 0xf0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;}if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , ""K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ;if ( mh -> ip6m_data8 [ 1 ] ) ;if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""<S2SV_blank>K"" ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>seq#=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ;ND_TCHECK_16BITS ( & bp [ hlen ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>lifetime=%u"" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ;ND_TCHECK2 ( bp [ hlen ] , 16 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>homeaddr<S2SV_blank>%s"" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ;",1148
430,"Convert_art ( & dls , & defaultArt , 0 ) ;dls . artCount = 1 ;dls . regionCount = dls . instCount = 0 ;","if ( dls . pDLS ) {Convert_art ( & dls , & defaultArt , 0 ) ;dls . artCount = 1 ;}dls . regionCount = dls . instCount = 0 ;",1149
431,"ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & e , ext , sizeof ( e ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ;if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , ntohs ( e . len ) - 4 ) ) goto trunc ;}else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) )  goto trunc ;return ( const u_char * ) ext + ntohs ( e . len ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;","ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%u"" , ntohs ( e . len ) - 4 ) ) ;if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ntohs ( e . len ) > 4 ) {if ( ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( ext + 1 ) , ep ) ) goto trunc ;}return ( const u_char * ) ext + ntohs ( e . len ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;",1150
432,"strcpy ( plugin_name , argv [ i ] ) ;strcpy ( config_file , argv [ i ] ) ;","if ( strlen ( argv [ i ] ) + 4 + 1 > FN_REFLEN ) {fprintf ( stderr , ""ERROR:<S2SV_blank>argument<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\\return 1 ;}strcpy ( plugin_name , argv [ i ] ) ;strcpy ( config_file , argv [ i ] ) ;",1151
433,"BN_ULONG t1 , t2 ;BN_ULONG c1 , c2 , c3 ;","BN_ULONG c1 , c2 , c3 ;",1152
434,"void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi )  {__issue_discard_cmd ( sbi , false ) ;__drop_discard_cmd ( sbi ) ;__wait_discard_cmd ( sbi , false ) ;}","void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi , bool umount ) {__issue_discard_cmd ( sbi , ! umount ) ;}",1153
435,attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ;if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;attrs = malloc ( alloc_size ) ;if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ;",1154
436,"if ( rdf_parser -> uri_filter )  raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;","raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;if ( rdf_parser -> uri_filter ) raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;",1155
437,if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) ||  ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) )  return KADM5_BAD_MASK ;if ( ( mask & ~ ALL_PRINC_MASK ) )   return KADM5_BAD_MASK ;if ( entry == NULL ) return EINVAL ;,if ( entry == NULL ) return EINVAL ;if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ;if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;,1156
438,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;va_end ( va ) ;",1157
439,"static void read_tx_mode_probs ( struct tx_probs * tx_probs , vp9_reader * r ) {int i , j ;","static void read_tx_mode_probs ( struct tx_probs * tx_probs , vpx_reader * r ) {int i , j ;",1158
440,"static void write_frame_size ( const VP9_COMMON * cm ,  struct vp9_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;write_display_size ( cm , wb ) ;","static void write_frame_size ( const VP9_COMMON * cm , struct vpx_write_bit_buffer * wb ) {vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;vpx_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;write_display_size ( cm , wb ) ;",1159
441,"if ( length == SIZE_MAX ) {rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ;","if ( length == SIZE_MAX || length > INT_MAX ) {rfbErr ( ""rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u"" , ( unsigned int ) length ) ;",1160
442,"# define ThrowCUTReaderException ( severity , tag ) {}Image * image , * palette ;","# define ThrowCUTReaderException ( severity , tag ) \\\\\\\\\\Image * image , * palette ;",1161
443,"
","( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;",1161
444,"offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {","offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {",1161
445,"
",if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;},1162
446,jumpstack [ stackidx ++ ] = e ;},jumpstack [ stackidx ++ ] = e ;},1162
447,if ( ! ( vmx -> exit_reason == EXIT_REASON_MCE_DURING_VMENTRY || vmx -> exit_reason == EXIT_REASON_EXCEPTION_NMI ) ) return ;vmx -> exit_intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ;exit_intr_info = vmx -> exit_intr_info ;if ( is_machine_check ( exit_intr_info ) ) kvm_machine_check ( ) ;if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR &&  ( exit_intr_info & INTR_INFO_VALID_MASK ) ) {,if ( is_nmi ( exit_intr_info ) ) {,1163
448,"tok -> err = json_tokener_success ;while ( PEEK_CHAR ( c , tok ) ) {","tok -> err = json_tokener_success ;if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) {tok -> err = json_tokener_error_size ;return NULL ;}while ( PEEK_CHAR ( c , tok ) ) {",1164
449,if ( c < 0 )  break ;* p ++ = ( unsigned char ) c ;if ( c < 0 )  break ;* p ++ = ( unsigned char ) c ;,"if ( c < 0 ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}* p ++ = ( unsigned char ) c ;if ( c < 0 ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}* p ++ = ( unsigned char ) c ;",1165
450,hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ;},hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED ) ;},1166
451,"static off_t ivf_header_pos = 0 ;switch ( pkt -> kind ) {if ( ! stream -> ebml . debug )  stream -> hash = murmur ( pkt -> data . frame . buf , ( int ) pkt -> data . frame . sz , stream -> hash ) ;",static int64_t ivf_header_pos = 0 ;switch ( pkt -> kind ) {,1167
452,"off_t currpos = ftello ( stream -> file ) ;fseeko ( stream -> file , ivf_header_pos , SEEK_SET ) ;","const int64_t currpos = ftello ( stream -> file ) ;fseeko ( stream -> file , ivf_header_pos , SEEK_SET ) ;",1167
453,case VPX_CODEC_PSNR_PKT :  if ( global -> show_psnr ) {,"# if CONFIG_FP_MB_STATS case VPX_CODEC_FPMB_STATS_PKT : stats_write ( & stream -> fpmb_stats , pkt -> data . firstpass_mb_stats . buf , pkt -> data . firstpass_mb_stats . sz ) ;stream -> nbytes += pkt -> data . raw . sz ;break ;# endif case VPX_CODEC_PSNR_PKT : if ( global -> show_psnr ) {",1167
454,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,1168
455,struct snd_ctl_elem_id id ;unsigned int idx ;,struct snd_ctl_elem_id id ;unsigned int count ;unsigned int idx ;,1169
456,"up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",1169
457,Proto * p = clLvalue ( s2v ( ci -> func ) ) -> p ;if ( p -> is_vararg ) delta = ci -> u . l . nextraargs + p -> numparams + 1 ;,Proto * p = ci_func ( ci ) -> p ;if ( p -> is_vararg ) delta = ci -> u . l . nextraargs + p -> numparams + 1 ;,1170
458,"if ( isLua ( ci -> previous ) )   L -> oldpc = ci -> previous -> u . l . savedpc ;return restorestack ( L , oldtop ) ;","if ( isLua ( ci = ci -> previous ) ) L -> oldpc = pcRel ( ci -> u . l . savedpc , ci_func ( ci ) -> p ) ;return restorestack ( L , oldtop ) ;",1170
459,"pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file"" ) ;* err = 1 ;return ( NULL ) ;}return ( NULL ) ;}amt_read = fread ( & byte_order_magic , 1 , sizeof ( byte_order_magic ) , fp ) ;","pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%"" PRIsize ""<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)"" , sizeof ( byte_order_magic ) , fp ) ;",1171
460,"if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) {pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE ,  ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%"" PRIsize ,  total_length ,  sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) ;* err = 1 ;","if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , total_length , BT_SHB_INSANE_MAX ) ;* err = 1 ;",1171
461,"static int em_jcxz ( struct x86_emulate_ctxt * ctxt )  {if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 )  jmp_rel ( ctxt , ctxt -> src . val ) ;return X86EMUL_CONTINUE ;}","static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) {int rc = X86EMUL_CONTINUE ;if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;return rc ;}",1172
462,"CRM_LOG_ASSERT ( client_obj -> request_id ) ;rid = client_obj -> request_id ;crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" ,  rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}","if ( client_obj -> ipc ) {CRM_LOG_ASSERT ( client_obj -> request_id ) ;rid = client_obj -> request_id ;crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}else {crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}}",1173
463,"void *  checked_xmalloc ( size_t size )  {alloc_limit_assert ( ""checked_xmalloc"" , size ) ;return xmalloc ( size ) ;}","void * checked_xmalloc ( size_t num , size_t size ) {size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;alloc_limit_assert ( ""checked_xmalloc"" , res ) ;return xmalloc ( num , size ) ;}",1174
464,"static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , int ctr_id ,  va_list args ) {if ( data == 1 &&  ( cfg -> rc_end_usage == VPX_CBR ||  cfg -> g_pass == VPX_RC_FIRST_PASS || cfg -> g_pass == VPX_RC_LAST_PASS ) && cfg -> ss_number_layers > 1 && cfg -> ts_number_layers > 1 ) {","static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , va_list args ) {if ( data == 1 && ( cfg -> g_pass == VPX_RC_FIRST_PASS || cfg -> g_pass == VPX_RC_LAST_PASS ) && cfg -> ss_number_layers > 1 && cfg -> ts_number_layers > 1 ) {",1175
465,if ( size_bmp > BMP_HEADER_SIZE ) {int ret ;,if ( size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE ) {int ret ;,1176
466,"dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ;if ( dev ) sctx = dev -> scrub_ctx ;","dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL , true ) ;if ( dev ) sctx = dev -> scrub_ctx ;",1177
467,"if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {goto error ;box -> ops = & jp2_boxinfo_unk . ops ;JAS_DBGLOG ( 10 , (  ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\if ( box -> len == 1 ) {if ( jp2_getuint64 ( in , & extlen ) ) {","if ( ! ( box = jp2_box_create0 ( ) ) ) {goto error ;JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\\if ( box -> len == 1 ) {JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\\if ( jp2_getuint64 ( in , & extlen ) ) {",1178
468,state -> array_nl = NULL ;}}else {if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ;state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ;state -> array_nl_len = len ;,"state -> array_nl = fstrndup ( RSTRING_PTR ( array_nl ) , len ) ;state -> array_nl_len = len ;",1179
469,"if ( ! test_bit ( HCI_UP , & hdev -> flags ) )   return - ENETDOWN ;hci_req_sync_lock ( hdev ) ;ret = __hci_req_sync ( hdev , req , opt , timeout , hci_status ) ;hci_req_sync_unlock ( hdev ) ;return ret ;","hci_req_sync_lock ( hdev ) ;if ( test_bit ( HCI_UP , & hdev -> flags ) ) ret = __hci_req_sync ( hdev , req , opt , timeout , hci_status ) ;else ret = - ENETDOWN ;hci_req_sync_unlock ( hdev ) ;return ret ;",1180
470,vpx_codec_err_t res = VPX_CODEC_OK ;yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ;yv12 -> y_crop_width = img -> d_w ;yv12 -> y_crop_height = img -> d_h ;yv12 -> uv_height = yv12 -> y_height / 2 ;yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ;yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ;yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> d_w ) / 2 ;,const int y_w = img -> d_w ) / 2 ;const int uv_h = ( img -> d_h + 1 ) / 2 ;vpx_codec_err_t res = VPX_CODEC_OK ;yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ;yv12 -> y_crop_width = y_w ;yv12 -> y_crop_height = y_h ;yv12 -> y_width = y_w ;yv12 -> y_height = y_h ;yv12 -> uv_crop_width = uv_w ;yv12 -> uv_crop_height = uv_h ;yv12 -> uv_width = uv_w ;yv12 -> uv_height = uv_h ;yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ;yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ;yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> d_w ;yv12 -> y_crop_height = img -> d_h ;,1181
471,void * buffer ;buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ;,void * buffer ;if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL ;buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ;,1182
472,if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,if ( num < 0 || num >= 256 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,1183
473,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,1183
474,state = vterm_state_new ( vt ) ;vt -> state = state ;,state = vterm_state_new ( vt ) ;if ( state == NULL ) return NULL ;vt -> state = state ;,1184
475,"mpeg4_decode_gop_header ( s , gb ) ;}else if ( startcode == VOS_STARTCODE ) {mpeg4_decode_profile_level ( s , gb ) ;if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&  ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) {s -> studio_profile = 1 ;}}","mpeg4_decode_gop_header ( s , gb , & profile , & level ) ;if ( profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) {s -> studio_profile = 1 ;}else if ( s -> studio_profile ) {av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\\return AVERROR_PATCHWELCOME ;}s -> avctx -> profile = profile ;s -> avctx -> level = level ;}",1185
476,"if ( ! s -> avctx -> bits_per_raw_sample ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>VOL<S2SV_blank>header\\\","if ( ! s -> avctx -> bits_per_raw_sample ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>VOL<S2SV_blank>header\\\",1185
477,"const uint8_t * end , * ptr = avpkt -> data ;int ncolors , cpp , ret , i , j ;end = avpkt -> data + avpkt -> size ;while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 )  ptr ++ ;if ( ptr >= end ) {","const uint8_t * end , * ptr ;int ncolors , cpp , ret , i , j ;av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ;if ( ! x -> buf ) return AVERROR ( ENOMEM ) ;memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ;x -> buf [ avpkt -> size ] = 0 ;ptr = x -> buf ;end = x -> buf + avpkt -> size ;while ( end - ptr > 9 && memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) ) ptr ++ ;if ( end - ptr <= 9 ) {",1186
478,"i ++ )  size *= 94 ;if ( ncolors <= 0 || ncolors > size ) {if ( ! x -> pixels ) return AVERROR ( ENOMEM ) ;ptr += mod_strcspn ( ptr , "","" ) + 1 ;for ( i = 0 ;const uint8_t * index ;if ( ptr + cpp > end )  return AVERROR_INVALIDDATA ;",i ++ ) size *= 95 ;if ( ncolors <= 0 || ncolors > size ) {if ( end - ptr < cpp ) return AVERROR_INVALIDDATA ;for ( i = 0 ;const uint8_t * index ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;if ( ptr + cpp > end ) return AVERROR_INVALIDDATA ;,1186
479,"}for ( i = 0 ;ptr += mod_strcspn ( ptr , ""\\\\"""" ) + 1 ;for ( j = 0 ;if ( ptr + cpp > end )  return AVERROR_INVALIDDATA ;","}for ( i = 0 ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;ptr += mod_strcspn ( ptr , ""\\\\"""" ) + 1 ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;for ( j = 0 ;if ( end - ptr < cpp ) return AVERROR_INVALIDDATA ;",1186
480,"static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred )  {status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ;if ( status == 0 ) break ;","static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , fmode_t fmode , int flags , struct iattr * sattr , struct rpc_cred * cred ) {status = _nfs4_do_open ( dir , path , fmode , flags , sattr , cred , & res ) ;if ( status == 0 ) break ;",1187
481,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
482,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
483,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
484,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
485,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
486,"CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\","CALL_AND_WAIT ( bt_interface -> enable ( false ) , adapter_state_changed ) ;fprintf ( stdout , ""BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\\",1188
487,"
","if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",1189
488,iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;,iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;,1189
489,"if ( i_arg ) {retval = copy_strings_kernel ( 1 , & i_arg , bprm ) ;bprm -> interp = interp ;file = open_exec ( interp ) ;return search_binary_handler ( bprm ) ;}","retval = bprm_change_interp ( interp , bprm ) ;if ( retval < 0 ) return retval ;file = open_exec ( interp ) ;if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ;bprm -> file = file ;retval = prepare_binprm ( bprm ) ;bprm -> interp = interp ;file = open_exec ( interp ) ;return search_binary_handler ( bprm ) ;}",1190
490,"INIT_LIST_HEAD ( & f -> f_u . fu_list ) ;atomic_long_set ( & f -> f_count , 1 ) ;","atomic_long_set ( & f -> f_count , 1 ) ;",1191
491,ps_dec -> u4_first_slice_in_pic = 2 ;ps_dec -> u1_slice_header_done = 0 ;,ps_dec -> u4_first_slice_in_pic = 2 ;ps_dec -> u1_first_pb_nal_in_pic = 1 ;ps_dec -> u1_slice_header_done = 0 ;,1192
492,"( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ;FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ;","( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent - 1 ) ;FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ;",1193
493,if ( pkt == NULL )  continue ;,"
",1194
494,kgctx . have_acceptor_subkey = 1 ;kb1 . contents = k1buf ;,kgctx . established = 1 ;kgctx . have_acceptor_subkey = 1 ;kb1 . contents = k1buf ;,1195
495,msg -> msg_namelen = 0 ;copied = skb -> len ;,copied = skb -> len ;,1196
496,port -> exists = true ;mb ( ) ;return 0 ;,spin_lock_irq ( & i8042_lock ) ;port -> exists = true ;spin_unlock_irq ( & i8042_lock ) ;return 0 ;,1197
497,"skip :  if ( ( new -> euid != old -> uid ||  new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {","skip : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ;if ( ( new -> euid != old -> uid || new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) {",1198
498,if ( ! rc -> source_alt_ref_pending )   rc -> source_alt_ref_active = 0 ;if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ;,if ( ! rc -> source_alt_ref_pending ) {rc -> source_alt_ref_active = 0 ;}if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ;,1199
499,"static void kiocb_batch_free ( struct kiocb_batch * batch )  {struct kiocb * req , * n ;list_for_each_entry_safe ( req , n , & batch -> head , ki_batch ) {kmem_cache_free ( kiocb_cachep , req ) ;}}","static void kiocb_batch_free ( struct kioctx * ctx , struct kiocb_batch * batch ) {struct kiocb * req , * n ;if ( list_empty ( & batch -> head ) ) return ;spin_lock_irq ( & ctx -> ctx_lock ) ;list_for_each_entry_safe ( req , n , & batch -> head , ki_batch ) {list_del ( & req -> ki_list ) ;kmem_cache_free ( kiocb_cachep , req ) ;ctx -> reqs_active -- ;}spin_unlock_irq ( & ctx -> ctx_lock ) ;}",1200
500,"
","memset ( sax , 0 , sizeof ( sax ) ) ;",1201
501,"sax -> sax25_family = AF_NETROM ;skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;","sax -> sax25_family = AF_NETROM ;skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;",1201
502,"if ( cpu_id != RING_BUFFER_ALL_CPUS && ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) return size ;size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ;size *= BUF_PAGE_SIZE ;","nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ;if ( nr_pages < 2 ) nr_pages = 2 ;size = nr_pages * BUF_PAGE_SIZE ;",1202
503,uchar * dp ;dp = data ;,jas_uchar * dp ;dp = data ;,1203
504,dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;dev -> netdev_ops = & macvlan_netdev_ops ;,dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;dev -> netdev_ops = & macvlan_netdev_ops ;,1204
505,int event_id = event -> attr . config ;if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;,u64 event_id = event -> attr . config ;if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;,1205
506,char * buf ;pkglen = s -> end - s -> p ;,"char * buf ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""rdpsnddbg_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , s ) ;}pkglen = s -> end - s -> p ;",1206
507,case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case RAPTOR_OPTION_RELATIVE_URIS : case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,1207
508,"static PixelChannels * * AcquirePixelThreadSet ( const Image * image )  {size_t  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ;for ( i = 0 ;i < ( ssize_t ) number_threads ;i ++ )  {register ssize_t j ;pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns ,  sizeof ( * * pixels ) ) ;if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ;for ( j = 0 ;j < ( ssize_t ) image -> columns ;j ++ )  {","static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) {const Image * next ;size_t columns , number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( columns , sizeof ( * pixels ) ) ;columns = images -> columns ;for ( next = images ;next != ( Image * ) NULL ;next = next -> next ) columns = MagickMax ( next -> columns , columns ) ;for ( i = 0 ;i < ( ssize_t ) columns ;j ++ ) {",1208
509,"int vp9_decode_frame ( VP9Decoder * pbi ,  const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) {struct vp9_read_bit_buffer rb = {data , data_end , 0 , cm , error_handler };const size_t first_partition_size = read_uncompressed_header ( pbi , & rb ) ;const int keyframe = cm -> frame_type == KEY_FRAME ;* p_data_end = data + 1 ;return 0 ;if ( ! pbi -> decoded_key_frame && ! keyframe ) return - 1 ;data += vp9_rb_bytes_read ( & rb ) ;pbi -> do_loopfilter_inline =   ( cm -> log2_tile_rows | cm -> log2_tile_cols ) == 0 && cm -> lf . filter_level ;if ( pbi -> do_loopfilter_inline && pbi -> lf_worker . data1 == NULL ) {CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ;pbi -> lf_worker . hook = ( VP9WorkerHook ) vp9_loop_filter_worker ;if ( pbi -> oxcf . max_threads > 1 && ! vp9_worker_reset ( & pbi -> lf_worker ) ) {vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ;}}init_macroblockd ( cm , & pbi -> mb ) ;cm -> prev_mi = get_prev_mi ( cm ) ;setup_plane_dequants ( cm , xd , cm -> base_qindex ) ;cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ;vp9_zero ( xd -> dqcoeff ) ;if ( pbi -> oxcf . max_threads > 1 && tile_rows == 1 && tile_cols > 1 &&  cm -> frame_parallel_decoding_mode ) {}* p_data_end = decode_tiles ( pbi , data + first_partition_size , data_end ) ;new_fb -> corrupted |= xd -> corrupted ;if ( ! pbi -> decoded_key_frame ) {else vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME ,  ""A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame"" ) ;}","void vp9_decode_frame ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) {struct vpx_read_bit_buffer rb ;int context_updated = 0 ;uint8_t clear_data [ MAX_VP9_HEADER_SIZE ] ;const size_t first_partition_size = read_uncompressed_header ( pbi , init_read_bit_buffer ( pbi , & rb , data , data_end , clear_data ) ) ;const int keyframe = cm -> frame_type == KEY_FRAME ;* p_data_end = data + ( cm -> profile <= PROFILE_2 ? 1 : 2 ) ;return ;data += vpx_rb_bytes_read ( & rb ) ;cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> last_intra_only && cm -> last_show_frame && ( cm -> last_frame_type != KEY_FRAME ) ;* cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ;if ( ! cm -> fc -> initialized ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Uninitialized<S2SV_blank>entropy<S2SV_blank>context."" ) ;if ( new_fb -> corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>header<S2SV_blank>is<S2SV_blank>corrupted."" ) ;if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) {vp9_loop_filter_frame_init ( cm , cm -> lf . filter_level ) ;}if ( pbi -> frame_parallel_decode && cm -> frame_parallel_decoding_mode ) {VPxWorker * const worker = pbi -> frame_worker_owner ;FrameWorkerData * const frame_worker_data = worker -> data1 ;if ( cm -> refresh_frame_context ) {context_updated = 1 ;cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ;}vp9_frameworker_lock_stats ( worker ) ;pbi -> cur_buf -> row = - 1 ;pbi -> cur_buf -> col = - 1 ;frame_worker_data -> frame_context_ready = 1 ;vp9_frameworker_signal_stats ( worker ) ;vp9_frameworker_unlock_stats ( worker ) ;}if ( pbi -> max_threads > 1 && tile_rows == 1 && tile_cols > 1 && cm -> frame_parallel_decoding_mode ) {if ( ! xd -> corrupted ) {if ( ! cm -> skip_loop_filter ) {vp9_loop_filter_frame_mt ( new_fb , cm , pbi -> mb . plane , cm -> lf . filter_level , 0 , 0 , pbi -> tile_workers , pbi -> num_tile_workers , & pbi -> lf_row_sync ) ;}}else {vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted."" ) ;}}* p_data_end = decode_tiles ( pbi , data + first_partition_size , data_end ) ;new_fb -> corrupted |= xd -> corrupted ;if ( ! pbi -> decoded_key_frame ) {else vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted."" ) ;}",1209
510,if ( cm -> refresh_frame_context )   cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ;return 0 ;},if ( cm -> refresh_frame_context && ! context_updated ) cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ;},1209
511,sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;,"unix_dgram_peer_wake_disconnect ( sk , skpair ) ;sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;",1210
512,"ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ;close ( sk ) ;","TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ) ;close ( sk ) ;",1211
513,if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) {if ( new_len > old_len ) goto Efault ;,if ( new_len > old_len ) {unsigned long pgoff ;if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) goto Efault ;pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ;pgoff += vma -> vm_pgoff ;if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval ;,1212
514,"if ( dashsize ) outpos += sprintf ( outpos , ""<S2SV_blank>[%12.3f]<S2SV_blank>%12.3f<S2SV_blank>d"" , dashsize , phase ) ;else outpos += sprintf ( outpos , ""<S2SV_blank>[]<S2SV_blank>0<S2SV_blank>d"" ) ;}","if ( dashsize ) {sprintf ( outputbuffer , ""<S2SV_blank>[%12.3f]<S2SV_blank>%12.3f<S2SV_blank>d"" , dashsize , phase ) ;sendClean ( outputbuffer ) ;}else send ( ""<S2SV_blank>[]<S2SV_blank>0<S2SV_blank>d"" ) ;}",1213
515,"print_octets ( ndo , ( const u_char * ) ptr , len - 6 ) ;","print_octets ( ndo , ( const u_char * ) ptr , len - 6 , len - 6 ) ;",1214
516,"case L2TP_AVP_MSGTYPE :  l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_PROTO_VER :  l2tp_proto_ver_print ( ndo , ptr ) ;break ;case L2TP_AVP_FRAMING_CAP :  l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_BEARER_CAP :  l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_TIE_BREAKER :  print_octets ( ndo , ( const u_char * ) ptr , 8 ) ;break ;case L2TP_AVP_FIRM_VER : case L2TP_AVP_ASSND_TUN_ID : case L2TP_AVP_RECV_WIN_SIZE : case L2TP_AVP_ASSND_SESS_ID :  print_16bits_val ( ndo , ptr ) ;break ;case L2TP_AVP_CHALLENGE_RESP :  print_octets ( ndo , ( const u_char * ) ptr , 16 ) ;break ;case L2TP_AVP_CALL_SER_NUM : case L2TP_AVP_MINIMUM_BPS : case L2TP_AVP_MAXIMUM_BPS : case L2TP_AVP_TX_CONN_SPEED : case L2TP_AVP_PHY_CHANNEL_ID : case L2TP_AVP_RX_CONN_SPEED :  print_32bits_val ( ndo , ( const uint32_t * ) ptr ) ;break ;case L2TP_AVP_BEARER_TYPE :  l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_FRAMING_TYPE :  l2tp_framing_type_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_PROXY_AUTH_TYPE :  l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_PROXY_AUTH_ID :  l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_CALL_ERRORS :  l2tp_call_errors_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_ACCM :  l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ;break ;","case L2TP_AVP_MSGTYPE : l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ;break ;case L2TP_AVP_PROTO_VER : l2tp_proto_ver_print ( ndo , ptr , len - 6 ) ;break ;case L2TP_AVP_FRAMING_CAP : l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_BEARER_CAP : l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_TIE_BREAKER : if ( len - 6 < 8 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;break ;}print_octets ( ndo , ( const u_char * ) ptr , 8 ) ;break ;case L2TP_AVP_FIRM_VER : case L2TP_AVP_ASSND_TUN_ID : case L2TP_AVP_RECV_WIN_SIZE : case L2TP_AVP_ASSND_SESS_ID : if ( len - 6 < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;break ;}print_16bits_val ( ndo , ptr ) ;break ;case L2TP_AVP_CHALLENGE_RESP : if ( len - 6 < 16 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;break ;}print_octets ( ndo , ( const u_char * ) ptr , 16 ) ;break ;case L2TP_AVP_CALL_SER_NUM : case L2TP_AVP_MINIMUM_BPS : case L2TP_AVP_MAXIMUM_BPS : case L2TP_AVP_TX_CONN_SPEED : case L2TP_AVP_PHY_CHANNEL_ID : case L2TP_AVP_RX_CONN_SPEED : if ( len - 6 < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;break ;}print_32bits_val ( ndo , ( const uint32_t * ) ptr , len - 6 ) ;break ;case L2TP_AVP_BEARER_TYPE : l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_FRAMING_TYPE : l2tp_framing_type_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_PROXY_AUTH_TYPE : l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_PROXY_AUTH_ID : l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_CALL_ERRORS : l2tp_call_errors_print ( ndo , ( const u_char * ) ptr , len - 6 ) ;break ;case L2TP_AVP_ACCM : l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ;break ;",1214
517,o4 = o * sizeof ( uint32_t ) ;},if ( q + o >= e ) goto out ;o4 = o * sizeof ( uint32_t ) ;},1215
518,if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) {return NULL ;,if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 1 ) {return NULL ;,1216
519,"case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ;","# if 0 case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ;",1216
520,"case DW_FORM_data2 :  value -> encoding . data = READ ( buf , ut16 ) ;case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ;break ;case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ;for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}","case DW_FORM_data2 : value -> encoding . data = READ ( buf , ut16 ) ;# endif case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ;break ;case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ;if ( value -> encoding . block . data ) {for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}}if ( value -> encoding . block . data ) {for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}}",1216
521,"netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ;return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ;","memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ;return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ;",1217
522,"if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {return 0 ;memset ( box , 0 , sizeof ( jp2_box_t ) ) ;box -> type = type ;",if ( ! ( box = jp2_box_create0 ( ) ) ) ) {return 0 ;box -> type = type ;,1218
523,char * name ;unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = {0 };,char * name ;,1219
524,"if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 )  ossl_raise ( eCipherError , NULL ) ;","if ( EVP_CipherInit_ex ( ctx , cipher , NULL , NULL , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;",1219
525,"av_bprint_init ( bp , 0 , - 1 ) ;while ( zstream . avail_in > 0 ) {av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ;if ( ! buf_size ) {zstream . avail_out = buf_size ;ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ;","av_bprint_init ( bp , 2 , & buf , & buf_size ) ;if ( buf_size < 2 ) {zstream . avail_out = buf_size - 1 ;ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ;",1220
526,"unsigned v = get_symbol ( c , state , 0 ) ;if ( v >= 2 ) {av_log ( f -> avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ver01<S2SV_blank>header\\\return AVERROR_INVALIDDATA ;}f -> version = v ;f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ) ;if ( f -> ac > 1 ) {for ( i = 1 ;i < 256 ;i ++ ) f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ] ;}f -> colorspace = get_symbol ( c , state , 0 ) ;if ( f -> version > 0 ) f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;f -> chroma_planes = get_rac ( c , state ) ;f -> chroma_h_shift = get_symbol ( c , state , 0 ) ;f -> chroma_v_shift = get_symbol ( c , state , 0 ) ;f -> transparency = get_rac ( c , state ) ;f -> plane_count = 2 + f -> transparency ;","int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;unsigned v = get_symbol ( c , state , 0 ) ;chroma_planes = get_rac ( c , state ) ;f -> chroma_h_shift = get_symbol ( c , state , 0 ) ;f -> chroma_v_shift = get_symbol ( c , state , 0 ) ;f -> transparency = get_rac ( c , state ) ;f -> plane_count = 2 + f -> transparency ;",1221
527,r = verify_vc_kbmode ( fd ) ;if ( r < 0 ) {,r = vt_verify_kbmode ( fd ) ;if ( r < 0 ) {,1222
528,"nfcf_poll -> sensf_res_len = * data ++ ;pr_debug ( ""bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\","nfcf_poll -> sensf_res_len = min_t ( __u8 , * data ++ , NFC_SENSF_RES_MAXSIZE ) ;pr_debug ( ""bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\\",1223
529,"
",queueItem -> interface = interface ;,1224
530,queueItem -> srcPort = 0 ;queueItem -> srcIpAddr = IP_ADDR_ANY ;,queueItem -> srcPort = 0 ;queueItem -> srcIpAddr = IP_ADDR_ANY ;,1224
531,NAPI_GRO_CB ( skb ) -> same_flow = 0 ;NAPI_GRO_CB ( skb ) -> udp_mark = 0 ;NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;,NAPI_GRO_CB ( skb ) -> encap_mark = 0 ;NAPI_GRO_CB ( skb ) -> udp_mark = 0 ;NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;,1225
532,"static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps )  {mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ;kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;","static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps ) {int i ;mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , ps -> channels [ 0 ] . count , 0 ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",1226
533,"if ( malloc_called != 20 || free_called != 20 )  fail ( ""Custom<S2SV_blank>allocation<S2SV_blank>failed"" ) ;","if ( malloc_called != 1 || free_called != 20 ) fail ( ""Custom<S2SV_blank>allocation<S2SV_blank>failed"" ) ;",1227
534,"int i ;int j ;int numrows ;int numcols ;if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & xoff , & yoff ) != 2 )   return 0 ;if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 )   return 0 ;if ( ! ( matrix = jas_seq2d_create ( xoff , yoff , xoff + numcols , yoff + numrows ) ) )  return 0 ;if ( jas_matrix_numrows ( matrix ) != numrows || jas_matrix_numcols ( matrix ) != numcols ) {","jas_matind_t i ;jas_matind_t j ;int numrows ;int numcols ;if ( fscanf ( in , ""%ld<S2SV_blank>%ld"" , & tmp_xoff , & tmp_yoff ) != 2 ) return 0 ;if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 ) {return 0 ;}xoff = tmp_xoff ;yoff = tmp_yoff ;if ( ! ( matrix = jas_seq2d_create ( xoff , yoff , xoff + numcols , yoff + numrows ) ) ) {return 0 ;}if ( jas_matrix_numrows ( matrix ) != numrows || jas_matrix_numcols ( matrix ) != numcols ) {",1228
535,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,1229
536,if ( exim_uid == 0 ) {,"if ( exim_uid == 0 ) if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}else {",1230
537,uschar * p = & argrest [ 2 ] ;,"uschar * hn ;if ( received_protocol ) {fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\\exit ( EXIT_FAILURE ) ;}p = & argrest [ 2 ] ;",1230
538,"else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;","else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ;else if ( Ustrcmp ( argrest , ""Ms"" ) == 0 ) sender_host_name = argv [ ++ i ] ;",1230
539,"uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {","uschar * hn = Ustrchr ( argrest , \':\' ) ;if ( hn == NULL ) {",1230
540,"static uint32_t scsi_init_iovec ( SCSIDiskReq * r )  {r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;","static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) {SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;if ( ! r -> iov . iov_base ) {r -> buflen = SCSI_DMA_BUF_SIZE ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}r -> iov . iov_len = MIN ( r -> sector_count * 512 , r -> buflen ) ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;",1231
541,if ( ret != 0 )  return ret ;bo -> dumb = false ;,if ( ret != 0 ) {kfree ( bo ) ;return ret ;}bo -> dumb = false ;,1232
542,"static void encode_sb_rt ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row , int mi_col ,  int output_enabled , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;int ctx ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;const int idx_str = xd -> mi_stride * mi_row + mi_col ;","static void encode_sb_rt ( VP9_COMP * cpi , ThreadData * td , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ;int ctx ;const int idx_str = xd -> mi_stride * mi_row + mi_col ;",1233
543,"switch ( partition ) {case PARTITION_NONE :  if ( output_enabled && bsize >= BLOCK_8X8 )  cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ;encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;break ;case PARTITION_VERT :  if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ;* get_sb_index ( x , subsize ) = 0 ;encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;encode_b_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ;}break ;case PARTITION_HORZ :  if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ;* get_sb_index ( x , subsize ) = 0 ;encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;encode_b_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ;}case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ;encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;* get_sb_index ( x , subsize ) = 1 ;encode_sb_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled ,  subsize ) ;* get_sb_index ( x , subsize ) = 2 ;encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled ,  subsize ) ;* get_sb_index ( x , subsize ) = 3 ;encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ;default :  assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}","if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ;switch ( partition ) {case PARTITION_NONE : encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;case PARTITION_VERT : if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ;encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ;default : assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}",1233
544,void * _TIFFmalloc ( tmsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,void * _TIFFmalloc ( tmsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,1234
545,field [ nf ] = lp ;if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) {,field [ nf ] = lp ;if ( nf >= MAXDATEFIELDS ) return - 1 ;if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) {,1235
546,if ( nf > MAXDATEFIELDS )  return - 1 ;,"
",1235
547,u_int16_t port ;unsigned int ret ;exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ;,struct nf_conn * ct = exp -> master ;union nf_inet_addr newaddr ;u_int16_t port ;unsigned int ret ;newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 ;exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ;,1236
548,"nf_ct_helper_log ( skb , exp -> master , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ;return NF_DROP ;ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo ,  protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ;nf_ct_helper_log ( skb , exp -> master , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ;nf_ct_unexpect_related ( exp ) ;","nf_ct_helper_log ( skb , ct , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ;return NF_DROP ;snprintf ( buffer , sizeof ( buffer ) , ""%u<S2SV_blank>%u"" , ntohl ( newaddr . ip ) , port ) ;pr_debug ( ""nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\\\'%s\\\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\\ret = nf_nat_mangle_tcp_packet ( skb , ct , ctinfo , protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ;nf_ct_helper_log ( skb , ct , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ;nf_ct_unexpect_related ( exp ) ;",1236
549,}return OK ;,"if ( * i == \'\\\\\\\\\' ) {AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ;return HTTP_BAD_REQUEST ;}}return OK ;",1237
550,ipc_lock_object ( & shp -> shm_perm ) ;path = shp -> shm_file -> f_path ;,ipc_lock_object ( & shp -> shm_perm ) ;if ( shp -> shm_file == NULL ) {ipc_unlock_object ( & shp -> shm_perm ) ;err = - EIDRM ;goto out_unlock ;}path = shp -> shm_file -> f_path ;,1238
551,"return ;}switch ( ( gdAffineStandardMatrix ) type ) {case GD_AFFINE_TRANSLATE : case GD_AFFINE_SCALE : {double x , y ;if ( Z_TYPE_P ( options ) != IS_ARRAY ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Array<S2SV_blank>expected<S2SV_blank>as<S2SV_blank>options"" ) ;}if ( zend_hash_find ( HASH_OF ( options ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) {convert_to_double_ex ( tmp ) ;x = Z_DVAL_PP ( tmp ) ;}convert_to_double_ex ( tmp ) ;y = Z_DVAL_PP ( tmp ) ;}",if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;x = Z_DVAL ( dval ) ;}else {x = Z_DVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;y = Z_DVAL ( dval ) ;}else {y = Z_DVAL_PP ( tmp ) ;}},1239
552,if ( test_tsk_need_resched ( rq -> curr ) )  rq -> skip_clock_update = 1 ;,if ( rq -> curr -> se . on_rq && test_tsk_need_resched ( rq -> curr ) ) rq -> skip_clock_update = 1 ;,1240
553,"rc = fsmVerify ( fpath , fi ) ;}","rc = fsmVerify ( fpath , fi , & sb ) ;}",1241
554,if ( ac_size > 0 ) {,{,1242
555,if ( dc_size > 0 ) {unsigned long dest_len = dc_count * 2LL ;if ( dc_count > ( 6LL * td -> xsize * td -> ysize + 63 ) / 64 )  return AVERROR_INVALIDDATA ;,if ( dc_size > 0 ) {unsigned long dest_len = dc_count * 2LL ;if ( dc_count != dc_w * dc_h * 3 ) return AVERROR_INVALIDDATA ;,1242
556,"static void test_show_object ( struct object * object ,  struct strbuf * path ,   const char * last , void * data )  {","static void test_show_object ( struct object * object , const char * last , void * data ) {",1243
557,if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls >  JAS_UINTFAST32_NUMBITS - 2 ||  pirlvl -> prcheightexpn + pi -> picomp -> numrlvls >  JAS_UINTFAST32_NUMBITS - 2 ) {,if ( pirlvl -> prcwidthexpn + picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {,1244
558,if ( name_len == 0 ) goto chunk_end ;name = p ;READ_ENCINT ( length ) ;if ( ( offset == 0 ) && ( length == 0 ) ) {,name = p ;READ_ENCINT ( length ) ;if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ;if ( ( offset == 0 ) && ( length == 0 ) ) {,1245
559,"path -> mnt = mntget ( nd -> path . mnt ) ;if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;follow_mount ( path ) ;error = 0 ;","path -> mnt = nd -> path . mnt ) ;if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ;mntget ( path -> mnt ) ;follow_mount ( path ) ;error = 0 ;",1246
560,"while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val )   && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) )  {","while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val ) && ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) ) {",1247
561,if ( msg -> maxsize - msg -> cursize < 4 ) {msg -> overflowed = qtrue ;,if ( msg -> overflowed ) {,1248
562,if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) {msg -> overflowed = qtrue ;return ;}if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,1248
563,nbits = bits & 7 ;for ( i = 0 ;,"nbits = bits & 7 ;if ( msg -> bit , msg -> maxsize << 3 + nbits > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}for ( i = 0 ;",1248
564,"Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;}}","Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;if ( msg -> bit > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}}}",1248
565,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",1249
566,kgctx . have_acceptor_subkey = 1 ;kb1 . contents = k1buf ;,kgctx . established = 1 ;kgctx . have_acceptor_subkey = 1 ;kb1 . contents = k1buf ;,1250
567,"bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;switch ( rsvp_obj_ctype ) {case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ;ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" ,  ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ;","switch ( rsvp_obj_ctype ) {case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ;bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ;",1251
568,"static vpx_codec_err_t ctrl_use_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {const int reference_flag = va_arg ( args , int ) ;","static vpx_codec_err_t ctrl_use_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {const int reference_flag = va_arg ( args , int ) ;",1252
569,"image -> columns = sun_info . width ;image -> rows = sun_info . height ;image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ;if ( sun_info . depth < 24 ) {size_t one ;image -> storage_class = PseudoClass ;image -> colors = sun_info . maplength ;}switch ( sun_info . maptype ) {case RMT_NONE :  {if ( sun_info . depth < 24 ) {break ;}unsigned char  * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","image -> colors = sun_info . maplength ;switch ( sun_info . maptype ) {unsigned char * sun_colormap ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",1253
570,if ( ! cpi -> refresh_alt_ref_frame && ( cm -> current_video_frame == 0 ||  ( cm -> frame_flags & FRAMEFLAGS_KEY ) ||  rc -> frames_to_key == 0 ||  ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) {cm -> frame_type = KEY_FRAME ;rc -> frames_to_key = cpi -> key_frame_frequency ;rc -> kf_boost = DEFAULT_KF_BOOST ;rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ;rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ;if ( rc -> frames_till_gf_update_due > rc -> frames_to_key )  rc -> frames_till_gf_update_due = rc -> frames_to_key ;cpi -> refresh_golden_frame = 1 ;,if ( ! cpi -> refresh_alt_ref_frame && ( cm -> current_video_frame == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) || rc -> frames_to_key == 0 || ( cpi -> oxcf . auto_key && 0 ) ) ) ) {cm -> frame_type = KEY_FRAME ;rc -> frames_to_key = cpi -> oxcf . key_freq ;rc -> kf_boost = DEFAULT_KF_BOOST ;rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ;rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ;if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) {rc -> frames_till_gf_update_due = rc -> frames_to_key ;rc -> constrained_gf_group = 1 ;}else {rc -> constrained_gf_group = 0 ;}cpi -> refresh_golden_frame = 1 ;,1254
571,"opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , NULL ) ;if ( opendata == NULL ) return ERR_PTR ( - ENOMEM ) ;","opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , 0 , NULL ) ;if ( opendata == NULL ) return ERR_PTR ( - ENOMEM ) ;",1255
572,"ERR ( ""callocing<S2SV_blank>this<S2SV_blank>failed"" ) ;goto error ;this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ;if ( this -> sd < 0 ) {ERR ( ""sockect<S2SV_blank>open<S2SV_blank>failed"" ) ;goto error ;struct sockaddr_in6 addr ;addr . sin6_family = AF_INET6 ;addr . sin6_port = htons ( port ) ;addr . sin6_addr = in6addr_any ;if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) {if ( g_options . only_desired_port == 1 )  ERR ( ""Bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>""  ""Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions."" ) ;ERR ( ""listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ;goto error ;","ERR ( ""IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed"" ) ;goto error ;this -> sd = socket ( AF_INET , SOCK_STREAM , 0 ) ;if ( this -> sd < 0 ) {ERR ( ""IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed"" ) ;goto error ;struct sockaddr_in addr ;addr . sin_family = AF_INET ;addr . sin_port = htons ( port ) ;addr . sin_addr . s_addr = htonl ( 0x7F000001 ) ;if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) {if ( g_options . only_desired_port == 1 ) ERR ( ""IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" ""Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions."" ) ;ERR ( ""IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ;goto error ;",1256
573,"col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PKTAP"" ) ;col_clear ( pinfo -> cinfo , COL_INFO ) ;ti = proto_tree_add_item ( tree , proto_pktap , tvb , offset , pkt_len , ENC_NA ) ;pktap_tree = proto_item_add_subtree ( ti , ett_pktap ) ;proto_tree_add_item ( pktap_tree , hf_pktap_hdrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;if ( pkt_len < MIN_PKTAP_HDR_LEN ) {proto_tree_add_expert ( tree , pinfo , & ei_pktap_hdrlen_too_short , tvb , offset , 4 ) ;return ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_rectype , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;rectype = tvb_get_letohl ( tvb , offset ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_dlt , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;dlt = tvb_get_letohl ( tvb , offset ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_ifname , tvb , offset , 24 , ENC_ASCII | ENC_NA ) ;offset += 24 ;proto_tree_add_item ( pktap_tree , hf_pktap_flags , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_pfamily , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_llhdrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_lltrlrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_pid , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_cmdname , tvb , offset , 20 , ENC_UTF_8 | ENC_NA ) ;offset += 20 ;proto_tree_add_item ( pktap_tree , hf_pktap_svc_class , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_iftype , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;offset += 2 ;proto_tree_add_item ( pktap_tree , hf_pktap_ifunit , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;offset += 2 ;proto_tree_add_item ( pktap_tree , hf_pktap_epid , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;offset += 4 ;proto_tree_add_item ( pktap_tree , hf_pktap_ecmdname , tvb , offset , 20 , ENC_UTF_8 | ENC_NA ) ;if ( rectype == PKT_REC_PACKET ) {next_tvb = tvb_new_subset_remaining ( tvb , pkt_len ) ;dissector_try_uint ( wtap_encap_dissector_table ,   wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ;}","int wtap_encap ;struct eth_phdr eth ;void * phdr ;col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PKTAP"" ) ;col_clear ( pinfo -> cinfo , COL_INFO ) ;wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ;switch ( wtap_encap ) {case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ;phdr = & eth ;break ;default : phdr = NULL ;break ;}dissector_try_uint_new ( wtap_encap_dissector_table , wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree , TRUE , phdr ) ;",1257
574,"VP9_COMMON * const cm = & cpi -> common ;const VP9_CONFIG * const oxcf = & cpi -> oxcf ;RATE_CONTROL * const rc = & cpi -> rc ;cm -> last_frame_type = cm -> frame_type ;rc -> projected_frame_size = ( int ) ( bytes_used << 3 ) ;vp9_rc_update_rate_correction_factors (  cpi , ( cpi -> sf . recode_loop >= ALLOW_RECODE_KFARFGF ||  oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) ? 2 : 0 ) ;rc -> last_q [ KEY_FRAME ] = cm -> base_qindex ;rc -> avg_frame_qindex [ KEY_FRAME ] = ROUND_POWER_OF_TWO (  3 * rc -> avg_frame_qindex [ KEY_FRAME ] + cm -> base_qindex , 2 ) ;}else if ( ! rc -> is_src_frame_alt_ref &&   ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) &&   ! ( cpi -> use_svc && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) ) {rc -> last_q [ 2 ] = cm -> base_qindex ;rc -> avg_frame_qindex [ 2 ] = ROUND_POWER_OF_TWO (   3 * rc -> avg_frame_qindex [ 2 ] + cm -> base_qindex , 2 ) ;}rc -> tot_q += vp9_convert_qindex_to_q ( cm -> base_qindex ) ;rc -> avg_q = rc -> tot_q / ( double ) rc -> ni_frames ;rc -> ni_tot_qi += cm -> base_qindex ;rc -> ni_av_qi = rc -> ni_tot_qi / rc -> ni_frames ;}if ( ( cm -> base_qindex < rc -> last_boosted_qindex ) ||   ( ( cpi -> static_mb_pct < 100 ) &&   ( ( cm -> frame_type == KEY_FRAME ) || cpi -> refresh_alt_ref_frame ||  ( cpi -> refresh_golden_frame && ! rc -> is_src_frame_alt_ref ) ) ) ) {rc -> last_boosted_qindex = cm -> base_qindex ;}","const VP9_COMMON * const cm = & cpi -> common ;const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;RATE_CONTROL * const rc = & cpi -> rc ;const int qindex = cm -> base_qindex ;if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) {vp9_cyclic_refresh_postencode ( cpi ) ;}rc -> projected_frame_size = ( int ) ( bytes_used << 3 ) ;vp9_rc_update_rate_correction_factors ( cpi ) ;rc -> last_q [ KEY_FRAME ] = cm -> base_qindex ;rc -> avg_frame_qindex [ KEY_FRAME ] = qindex ;rc -> avg_frame_qindex [ 2 ] = ROUND_POWER_OF_TWO ( 3 * rc -> avg_frame_qindex [ 2 ] + cm -> base_qindex , 2 ) ;}rc -> tot_q += vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;rc -> avg_q = rc -> tot_q / rc -> ni_frames ;rc -> ni_tot_qi += cm -> base_qindex ;rc -> ni_av_qi = rc -> ni_tot_qi / rc -> ni_frames ;}}if ( ( qindex < rc -> last_boosted_qindex ) || ( ( cpi -> static_mb_pct < 100 ) && ( ( cm -> frame_type == KEY_FRAME ) || ( ! rc -> constrained_gf_group && ( cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! rc -> is_src_frame_alt_ref ) ) ) ) {rc -> last_boosted_qindex = qindex ;}if ( cm -> frame_type == KEY_FRAME ) rc -> last_kf_qindex = qindex ;",1258
575,rc -> total_target_bits += ( cm -> show_frame ? rc -> av_per_frame_bandwidth : 0 ) ;rc -> total_target_vs_actual = rc -> total_actual_bits - rc -> total_target_bits ;if ( oxcf -> play_alternate && cpi -> refresh_alt_ref_frame &&  ( cm -> frame_type != KEY_FRAME ) ) update_alt_ref_frame_stats ( cpi ) ;if ( cm -> frame_type == KEY_FRAME )  rc -> frames_since_key = 0 ;},rc -> total_target_bits += cm -> show_frame ? rc -> av_per_frame_bandwidth : 0 ) ;rc -> total_target_vs_actual = rc -> total_actual_bits - rc -> total_target_bits ;if ( ! cpi -> use_svc ) {if ( is_altref_enabled ( cpi ) && cpi -> refresh_alt_ref_frame && ( cm -> frame_type != KEY_FRAME ) ) update_alt_ref_frame_stats ( cpi ) ;}if ( cm -> frame_type == KEY_FRAME ) rc -> frames_since_key = 0 ;if ( oxcf -> pass != 0 ) {cpi -> resize_pending = rc -> next_frame_size_selector != rc -> frame_size_selector ;rc -> frame_size_selector = rc -> next_frame_size_selector ;}},1258
576,int delegation_type = 0 ;int status ;,fmode_t delegation_type = 0 ;int status ;,1259
577,"old_locale = setlocale ( LC_NUMERIC , ""C"" ) ;rrd_graph_options ( argc , argv , & im ) ;if ( rrd_test_error ( ) ) {rrd_info_free ( im . grinfo ) ;im_free ( & im ) ;","
",1260
578,"rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ;return NULL ;","rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ;return NULL ;",1260
579,"static void findoprnd ( ITEM * ptr , int32 * pos )  {# ifdef BS_DEBUG elog ( DEBUG3 , ( ptr [ * pos ] . type == OPR ) ? ""%d<S2SV_blank><S2SV_blank>%c"" : ""%d<S2SV_blank><S2SV_blank>%d"" , * pos , ptr [ * pos ] . val ) ;","static void findoprnd ( ITEM * ptr , int32 * pos ) {check_stack_depth ( ) ;# ifdef BS_DEBUG elog ( DEBUG3 , ( ptr [ * pos ] . type == OPR ) ? ""%d<S2SV_blank><S2SV_blank>%c"" : ""%d<S2SV_blank><S2SV_blank>%d"" , * pos , ptr [ * pos ] . val ) ;",1261
580,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_ARP_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",1262
581,"static void record_and_restart ( struct perf_event * event , unsigned long val ,  struct pt_regs * regs , int nmi )  {","static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) {",1263
582,"if ( perf_event_overflow ( event , nmi , & data , regs ) )  fsl_emb_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) fsl_emb_pmu_stop ( event , 0 ) ;",1263
583,"ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;","unsigned long eip ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;rc = assign_eip_near ( ctxt , eip ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;",1264
584,"r = parse_gid ( e + 1 , & gid ) ;if ( r < 0 ) goto not_found ;","if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;r = parse_gid ( e + 1 , & gid ) ;if ( r < 0 ) goto not_found ;",1265
585,"static void reconstruct_inter_block ( int plane , int block ,  BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {struct inter_args * args = ( struct inter_args * ) arg ;VP9_COMMON * const cm = args -> cm ;MACROBLOCKD * const xd = args -> xd ;struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;int x , y , eob ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y ,  tx_size , args -> r ) ;inverse_transform_block ( xd , plane , block , tx_size ,   & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ,  pd -> dst . stride , eob ) ;* args -> eobtotal += eob ;}","static int reconstruct_inter_block ( MACROBLOCKD * const xd = args -> xd ;struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;int x , y , eob ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;eob = vp9_decode_block_tokens ( xd , plane , block , tx_size , & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] , pd -> dst . stride , eob ) ;return eob ;}",1266
586,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;if ( dh == NULL ) {","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;if ( dh == NULL ) {",1267
587,"
",if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;,1268
588,length += len ;},length += len ;},1268
589,"
",struct name_snapshot name ;,1269
590,"mask |= FS_EVENT_ON_CHILD ;if ( path )  ret = fsnotify ( p_inode , mask , path , FSNOTIFY_EVENT_PATH ,  dentry -> d_name . name , 0 ) ;else ret = fsnotify ( p_inode , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE ,  dentry -> d_name . name , 0 ) ;}","mask |= FS_EVENT_ON_CHILD ;take_dentry_name_snapshot ( & name , dentry ) ;if ( path ) ret = fsnotify ( p_inode , mask , path , FSNOTIFY_EVENT_PATH , name . name , 0 ) ;else ret = fsnotify ( p_inode , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE , name . name , 0 ) ;release_dentry_name_snapshot ( & name ) ;}",1269
591,"size_t ss = CDF_SEC_SIZE ( h ) , i , j ;scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) , i , j ;scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ;",1270
592,tcon -> bad_network_name = true ;},if ( tcon ) tcon -> bad_network_name = true ;},1271
593,"memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ;rate_len = rate_ie -> len ;if ( rate_ie )   memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ;return ;","if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ;memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ;rate_len = rate_ie -> len ;if ( rate_ie ) {if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ;memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ;}return ;",1272
594,"agoo_log_cat ( & agoo_con_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]"" ,   getpid ( ) , ( unsigned long long ) cnt , b -> id , con -> sock ) ;con_cnt = atomic_fetch_add ( & agoo_server . con_cnt , 1 ) ;","agoo_log_cat ( & agoo_con_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]<S2SV_blank>from<S2SV_blank>%s"" , getpid ( ) , ( unsigned long long ) cnt , b -> id , con -> sock , con -> remote ) ;con_cnt = atomic_fetch_add ( & agoo_server . con_cnt , 1 ) ;",1273
595,"int ret ;ret = strdup_if_nonnull ( & target -> cr_principal , source -> cr_principal ) ;if ( ret )  return ret ;ret = strdup_if_nonnull ( & target -> cr_raw_principal , source -> cr_raw_principal ) ;if ( ret ) return ret ;","target -> cr_principal , source -> cr_principal , GFP_KERNEL ) ;target -> cr_raw_principal = kstrdup ( source -> cr_raw_principal , GFP_KERNEL ) ;if ( ( source -> cr_principal && ! target -> cr_principal ) || ( source -> cr_raw_principal && ! target -> cr_raw_principal ) ) return - ENOMEM ;",1274
596,assert ( offset >= capoff ) ;if ( offset == capoff || offset == capoff + 1 ) {,if ( offset == capoff || offset == capoff + 1 ) {,1275
597,"r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ;if ( r < 0 ) {","r = safe_mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" , root ) ;if ( r < 0 ) {",1276
598,"int err = 0 ;ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\\","int err = 0 ;BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) ;ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\\",1277
599,"err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;","if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) {if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ;else err = ext4_ext_zeroout ( inode , ex ) ;}else err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;",1277
600,"void vp9_temporal_filter_apply_c ( uint8_t * frame1 , unsigned int stride , uint8_t * frame2 ,  unsigned int block_size ,  int strength , int filter_weight , unsigned int * accumulator , uint16_t * count ) {for ( i = 0 , k = 0 ;i < block_size ;for ( j = 0 ;j < block_size ;int src_byte = frame1 [ byte ] ;modifier += 1 << ( strength - 1 ) ;modifier >>= strength ;","void vp9_temporal_filter_apply_c ( uint8_t * frame1 , unsigned int block_width , unsigned int block_height , int strength , int filter_weight , unsigned int * accumulator , uint16_t * count ) {const int rounding = strength > 0 ? 1 << ( strength - 1 ) : 0 ;for ( i = 0 , k = 0 ;i < block_height ;for ( j = 0 ;j < block_width ;int src_byte = frame1 [ byte ] ;modifier += rounding ;modifier >>= strength ;",1278
601,byte += stride - block_size ;},byte += stride - block_width ;},1278
602,case PCIBAR_MEMHI64 :  assert ( idx >= 1 ) ;mask = ~ ( dev -> bar [ idx - 1 ] . size - 1 ) ;default :  assert ( 0 ) ;},"case PCIBAR_MEMHI64 : mask = ~ ( dev -> bar [ idx - 1 ] . size - 1 ) ;default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\return ;}",1279
603,"return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ;}","if ( uid >= AID_APP ) {return 0 ;}return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ;}",1280
604,if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;BeginOfThisString = Offset - SizeOfHeader - 8 ;,if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ;if ( ( Offset + Len ) > SizeOfTag + 8 ) goto Error ;BeginOfThisString = Offset - SizeOfHeader - 8 ;,1281
605,void ext4_xattr_destroy_cache ( struct mb_cache * cache )  {if ( cache )  mb_cache_destroy ( cache ) ;},void ext4_xattr_destroy_cache ( struct mb2_cache * cache ) {if ( cache ) mb2_cache_destroy ( cache ) ;},1282
606,"
",mu_run_test ( test_r_str_escape_sh ) ;,1283
607,mu_run_test ( test_r_str_unescape ) ;mu_run_test ( test_r_str_constpool ) ;,mu_run_test ( test_r_str_unescape ) ;mu_run_test ( test_r_str_constpool ) ;,1283
608,sbinfo -> hstate = config . hstate ;spin_lock_init ( & sbinfo -> stat_lock ) ;sbinfo -> max_blocks = config . nr_blocks ;sbinfo -> free_blocks = config . nr_blocks ;sbinfo -> max_inodes = config . nr_inodes ;,sbinfo -> max_inodes = config . nr_inodes ;sbinfo -> spool = NULL ;if ( config . nr_blocks != - 1 ) {sbinfo -> spool = hugepage_new_subpool ( config . nr_blocks ) ;if ( ! inode ) goto out_free ;},1284
609,if ( ! inode )  goto out_free ;root = d_alloc_root ( inode ) ;if ( ! root ) {out_free :  kfree ( sbinfo ) ;return - ENOMEM ;,if ( ! inode ) goto out_free ;root = d_alloc_root ( inode ) ;if ( ! root ) {out_free : if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ;kfree ( sbinfo ) ;return - ENOMEM ;,1284
610,"U2FHID_INIT_RESP initresp ;if ( resplen > sizeof ( initresp ) )  {return U2FH_MEMORY_ERROR ;memcpy ( & initresp , resp , resplen ) ;dev -> cid = initresp . cid ;dev -> versionInterface = initresp . versionInterface ;dev -> versionMajor = initresp . versionMajor ;dev -> versionMinor = initresp . versionMinor ;dev -> capFlags = initresp . capFlags ;}","int offs = sizeof ( nonce ) ;if ( resplen < 17 ) {return U2FH_SIZE_ERROR ;}if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) {return U2FH_TRANSPORT_ERROR ;}dev -> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ;offs += 4 ;dev -> versionInterface = resp [ offs ++ ] ;dev -> versionMajor = resp [ offs ++ ] ;dev -> versionMinor = resp [ offs ++ ] ;dev -> versionBuild = resp [ offs ++ ] ;dev -> capFlags = resp [ offs ++ ] ;",1285
611,"if ( ! lp || ! timestring || ! timefield )  return MS_FALSE ;if ( strstr ( timestring , "","" ) == NULL && strstr ( timestring , ""/"" ) == NULL ) {","if ( ! lp || ! timestring || ! timefield ) return MS_FALSE ;if ( strchr ( timestring , \'\\\\\'\' ) || strchr ( timestring , \'\\\\\\\\\' ) ) {msSetError ( MS_MISCERR , ""Invalid<S2SV_blank>time<S2SV_blank>filter."" , ""msPostGISLayerSetTimeFilter()"" ) ;return MS_FALSE ;}if ( strstr ( timestring , "","" ) == NULL && strstr ( timestring , ""/"" ) == NULL ) {",1286
612,"return recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ;}","return TEMP_FAILURE_RETRY ( recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ) ;}",1287
613,"if ( ( creds -> pid == task_tgid_vnr ( current ) ||  ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) &&  ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {","if ( ( creds -> pid == task_tgid_vnr ( current ) || ns_capable ( task_active_pid_ns ( current ) -> user_ns , CAP_SYS_ADMIN ) ) && ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {",1288
614,"static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",1289
615,int ret = 0 ;if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ;,"int ret = 0 ;if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ;if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ;",1290
616,"ND_TCHECK ( pptr [ 0 ] ) ;plen = pptr [ 0 ] ;if ( 0 == plen ) {snprintf ( buf , buflen , ""default<S2SV_blank>route<S2SV_blank>target"" ) ;return 1 ;}if ( 32 > plen ) return - 1 ;plen -= 32 ;if ( 64 < plen ) return - 1 ;memset ( & route_target , 0 , sizeof ( route_target ) ) ;ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ;memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ;if ( plen % 8 ) {snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" ,  as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) ,  bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ;","char asbuf [ sizeof ( astostr ) ] ;ND_TCHECK ( pptr [ 5 ] , ( plen + 7 ) / 8 ) ;memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ;if ( plen % 8 ) {snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ;",1291
617,"cork -> length += length ;if ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;if ( proto == IPPROTO_UDP &&  ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {}if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ;","if ( ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;skb = skb_peek_tail ( & sk -> sk_write_queue ) ;cork -> length += length ;if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {if ( ! skb ) goto alloc_new_skb ;",1292
618,"verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j )  vstart += verdef -> vd_aux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {","verdef -> vd_version = READ16 ( dfs , j ) int vdaux = verdef -> vd_aux ;if ( vdaux < 1 ) {sdb_free ( sdb_verdef ) ;goto out_error ;}vstart += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {",1293
619,mapping = ( struct address_space * ) page_private ( page ) ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,1294
620,"zap = key -> payload . data [ 0 ] ;rcu_assign_keypointer ( key , upayload ) ;key -> expiry = 0 ;","if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) zap = key -> payload . data [ 0 ] ;else zap = NULL ;rcu_assign_keypointer ( key , upayload ) ;key -> expiry = 0 ;",1295
621,"void vp9_fht8x8_c ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {vp9_fdct8x8_c ( input , output , stride ) ;}int16_t out [ 64 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;int16_t temp_in [ 8 ] , temp_out [ 8 ] ;const transform_2d ht = FHT_8 [ tx_type ] ;++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j )  outptr [ j * 8 + i ] = temp_out [ j ] ;}","void vp9_fht8x8_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {vpx_fdct8x8_c ( input , output , stride ) ;}tran_low_t out [ 64 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;tran_low_t temp_in [ 8 ] , temp_out [ 8 ] ;const transform_2d ht = FHT_8 [ tx_type ] ;+ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;++ j ) out [ j * stride + i ] * 4 ;+ j )  outptr [ j * 8 + i ] = temp_out [ j ] ;++ j ) outptr [ j * 8 + i ] = temp_out [ j ] ;}",1296
622,"emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , xcp , 0 ) ;MIPS_FPU_EMU_INC_STATS ( emulated ) ;","emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , xcp , 0 ) ;MIPS_FPU_EMU_INC_STATS ( emulated ) ;",1297
623,"if ( s -> chunksize >= 0 ) {if ( ! s -> chunksize ) {s -> chunksize = strtoll ( line , NULL , 16 ) ;av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\\\'\\\if ( ! s -> chunksize )  return 0 ;}int64_t target = h -> is_streamed ? 0 : s -> off ;if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\\av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ;av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\\return read_ret ;","if ( s -> chunksize != UINT64_MAX ) {if ( ! s -> chunksize ) {s -> chunksize = strtoull ( line , NULL , 16 ) ;av_log ( h , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\\\'\\\if ( ! s -> chunksize ) return 0 ;else if ( s -> chunksize == UINT64_MAX ) {av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\\return AVERROR ( EINVAL ) ;}}uint64_t target = h -> is_streamed ? 0 : s -> off ;if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ;av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 ""<S2SV_blank>error=%s.\\\av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ;av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 "".\\\return read_ret ;",1298
624,int iSrc ;res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;,int iSrc ;,1299
625,for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},1299
626,"if ( uref -> field_index >= report -> maxfield ) goto inval ;field = report -> field [ uref -> field_index ] ;if ( uref -> usage_index >= field -> maxusage ) goto inval ;uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ;if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ;goto goodreturn ;default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ;if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) {field = hiddev_lookup_usage ( hid , uref ) ;if ( field == NULL ) goto inval ;else {rinfo . report_type = uref -> report_type ;rinfo . report_id = uref -> report_id ;","
",1300
627,else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) &&  ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ;}switch ( cmd ) {,else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ;}switch ( cmd ) {,1300
628,"ALOGE ( ""b/26366256"" ) ;return ;","ALOGE ( ""b/26366256"" ) ;android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;return ;",1301
629,void unix_inflight ( struct file * fp )  {,"void unix_inflight ( struct user_struct * user , struct file * fp ) {",1302
630,fp -> f_cred -> user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;,user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;,1302
631,"static int pimv2_addr_print ( netdissect_options * ndo ,  const u_char * bp , enum pimv2_addrtype at , int silent )  {int len , hdrlen ;ND_TCHECK ( bp [ 0 ] ) ;if ( pimv2_addr_len == 0 ) {len = sizeof ( struct in_addr ) ;break ;len = sizeof ( struct in6_addr ) ;break ;switch ( pimv2_addr_len ) {case sizeof ( struct in_addr ) : af = AF_INET ;break ;case sizeof ( struct in6_addr ) : af = AF_INET6 ;len = pimv2_addr_len ;hdrlen = 0 ;switch ( at ) {case pimv2_unicast :  ND_TCHECK2 ( bp [ 0 ] , len ) ;if ( af == AF_INET ) {return hdrlen + len ;case pimv2_group : case pimv2_source :  ND_TCHECK2 ( bp [ 0 ] , len + 2 ) ;if ( af == AF_INET ) {","static int pimv2_addr_print ( netdissect_options * ndo , const u_char * bp , u_int len , enum pimv2_addrtype at , u_int addr_len , int silent ) {int hdrlen ;if ( addr_len == 0 ) {if ( len < 2 ) goto trunc ;len = sizeof ( struct in_addr ) ;break ;len = sizeof ( struct in6_addr ) ;break ;switch ( pimv2_addr_len ) {case sizeof ( struct in_addr ) : af = AF_INET ;addr_len = ( u_int ) sizeof ( struct in6_addr ) : af = AF_INET6 ;hdrlen = 0 ;len -= hdrlen ;switch ( at ) {case pimv2_unicast : if ( len < addr_len ) goto trunc ;ND_TCHECK2 ( bp [ 0 ] , addr_len ) ;if ( af == AF_INET ) {return hdrlen + addr_len ;case pimv2_group : case pimv2_source : if ( len < addr_len + 2 ) goto trunc ;ND_TCHECK2 ( bp [ 0 ] , addr_len + 2 ) ;if ( af == AF_INET ) {",1303
632,return hdrlen + 2 + len ;default : return - 1 ;,return hdrlen + 2 + addr_len ;default : return - 1 ;,1303
633,"DPRINTF ( ""Read<S2SV_blank>sector_count=%d\\\if ( r -> sector_count == 0 ) {scsi_req_complete ( & r -> req , GOOD ) ;return ;}assert ( r -> req . aiocb == NULL ) ;if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) {DPRINTF ( ""Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\\scsi_read_complete ( r , - EINVAL ) ;return ;}n = r -> sector_count ;if ( n > SCSI_DMA_BUF_SIZE / 512 ) n = SCSI_DMA_BUF_SIZE / 512 ;r -> iov . iov_len = n * 512 ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ;r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n ,  scsi_read_complete , r ) ;","r -> iov . iov_len = n * 512 ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ;r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , scsi_read_complete , r ) ;",1304
634,match_length += callback_args -> forward_matches ;if ( callback_args -> full_word ) {,match_length += callback_args -> forward_matches ;assert ( match_offset + match_length <= callback_args -> data_size ) ;if ( callback_args -> full_word ) {,1305
635,if ( string -> space == 0 )  string -> space = 1 ;else  string -> space *= 2 ;if ( string -> space < 0 )  {new_len = string -> space = G_MAXINT - 8 ;},"if ( string -> space == 0 ) {string -> space = 4 ;}else {const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ;guint more_space = ( guint ) string -> space * 2 ;if ( string -> space < 0 ) {new_len = string -> space = more_space ;}",1306
636,newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,1307
637,newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,1307
638,"szLineConv [ i ] = 0 ;strcpy ( szLine , szLineConv ) ;","if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;szLineConv [ i ] = 0 ;strcpy ( szLine , szLineConv ) ;",1308
639,"ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc ,  ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ;","ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ;ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ;ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ;ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ;ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ;ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ;",1309
640,if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag )  ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ;,ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ;ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ;if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ;,1309
641,"cmdline_status = options_cmdline ( arg1 , arg2 ) ;if ( cmdline_status )  return cmdline_status ;options_apply ( ) ;if ( bind_ports ( ) )  return 1 ;# ifdef HAVE_CHROOT if ( change_root ( ) )  return 1 ;# endif if ( drop_privileges ( 1 ) )  return 1 ;if ( log_open ( SINK_OUTFILE ) )  return 1 ;# ifndef USE_FORK num_clients = 0 ;","log_flush ( LOG_MODE_BUFFER ) ;cmdline_status = options_cmdline ( arg1 , arg2 ) ;if ( cmdline_status ) {log_flush ( LOG_MODE_ERROR ) ;return cmdline_status ;}options_free ( 1 ) ;options_apply ( ) ;if ( bind_ports ( ) ) {unbind_ports ( ) ;options_free ( 1 ) ;options_defaults ( ) ;options_apply ( ) ;log_flush ( LOG_MODE_ERROR ) ;return 1 ;}# ifdef HAVE_CHROOT if ( change_root ( ) ) {log_flush ( LOG_MODE_ERROR ) ;return 1 ;}# endif if ( drop_privileges ( 1 ) ) {log_flush ( LOG_MODE_ERROR ) ;return 1 ;}if ( log_open ( SINK_OUTFILE ) ) {log_flush ( LOG_MODE_ERROR ) ;return 1 ;}# ifndef USE_FORK num_clients = 0 ;",1310
642,"else len = get_line_size ( * b , * avail , nl ) ;","else len = get_line_size ( * b + len , * avail - len , nl ) ;",1311
643,"len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;","len = get_line_size ( * b , * avail , nl ) ;if ( len >= 0 ) len += tested ;",1311
644,"else {vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",1312
645,"else {vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",1312
646,"static INLINE int cost_coeffs ( MACROBLOCK * x ,  int plane , int block , ENTROPY_CONTEXT * A , ENTROPY_CONTEXT * L , TX_SIZE tx_size , const int16_t * scan , const int16_t * nb , int use_fast_coef_costing ) {const struct macroblockd_plane * pd = & xd -> plane [ plane ] ;const PLANE_TYPE type = pd -> plane_type ;const int16_t * band_count = & band_counts [ tx_size ] [ 1 ] ;const int eob = p -> eobs [ block ] ;const int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;unsigned int ( * token_costs ) [ 2 ] [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = x -> token_costs [ tx_size ] [ type ] [ is_inter_block ( mbmi ) ] ;int c , cost ;assert ( type == PLANE_TYPE_Y ? mbmi -> tx_size == tx_size  : get_uv_tx_size ( mbmi ) == tx_size ) ;if ( eob == 0 ) {int prev_t = vp9_dct_value_tokens_ptr [ v ] . token ;cost = ( * token_costs ) [ 0 ] [ pt ] [ prev_t ] + vp9_dct_value_cost_ptr [ v ] ;token_cache [ 0 ] = vp9_pt_energy_class [ prev_t ] ;int t ;v = qcoeff [ rc ] ;t = vp9_dct_value_tokens_ptr [ v ] . token ;if ( use_fast_coef_costing ) {cost += ( * token_costs ) [ ! prev_t ] [ ! prev_t ] [ t ] + vp9_dct_value_cost_ptr [ v ] ;}cost += ( * token_costs ) [ ! prev_t ] [ pt ] [ t ] + vp9_dct_value_cost_ptr [ v ] ;token_cache [ rc ] = vp9_pt_energy_class [ t ] ;","static int cost_coeffs ( MACROBLOCK * x , int plane , int block , ENTROPY_CONTEXT * A , ENTROPY_CONTEXT * L , TX_SIZE tx_size , const int16_t * scan , const int16_t * nb , int use_fast_coef_costing ) {const tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;unsigned int ( * token_costs ) [ 2 ] [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = x -> token_costs [ tx_size ] [ type ] [ is_inter_block ( mbmi ) ] ;int c , cost ;# if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ;# else const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ;# endif assert ( type == PLANE_TYPE_Y ? mbmi -> tx_size == tx_size : get_uv_tx_size ( mbmi , pd ) == tx_size ) ;if ( eob == 0 ) {int16_t prev_t ;EXTRABIT e ;vp9_get_token_extra ( v , & prev_t , & e ) ;cost = ( * token_costs ) [ 0 ] [ pt ] [ prev_t ] + vp9_get_cost ( prev_t , e , cat6_high_cost ) ;token_cache [ 0 ] = vp9_pt_energy_class [ prev_t ] ;int16_t t ;v = qcoeff [ rc ] ;vp9_get_token_extra ( v , & t , & e ) ;if ( use_fast_coef_costing ) {cost += ( * token_costs ) [ ! prev_t ] [ ! prev_t ] [ t ] + vp9_get_cost ( t , e , cat6_high_cost ) ;}cost += ( * token_costs ) [ ! prev_t ] [ pt ] [ t ] + vp9_get_cost ( t , e , cat6_high_cost ) ;token_cache [ rc ] = vp9_pt_energy_class [ t ] ;",1313
647,if ( net != c_net || ! tc -> t_sock )  continue ;,if ( net != c_net ) continue ;,1314
648,"CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ;CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ;","CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ;CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ;CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ;",1315
649,"}target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;","}m -> msg_namelen = 0 ;target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;",1316
650,return NF_ACCEPT ;},return err == 0 ? NF_ACCEPT : NF_DROP ;},1317
651,"separator = strchr ( line , ':' ) ;if ( separator == NULL ) return ERROR_INVALID_SYNTAX ;","separator = osStrchr ( line , ':' ) ;if ( separator == NULL ) return ERROR_INVALID_SYNTAX ;",1318
652,"
",if ( plenbytes < 0 ) return plenbytes ;,1319
653,"}ND_PRINT ( ( ndo , ""%s"" , buf ) ) ;","}ND_PRINT ( ( ndo , ""%s"" , buf ) ) ;",1319
654,"msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ;if ( msg -> fp ) return 0 ;","msg -> fp = mutt_bcache_get ( pop_data -> bcache , cache_id ( h -> data ) ) ;if ( msg -> fp ) return 0 ;",1320
655,"msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ;if ( ! msg -> fp ) {","msg -> fp = mutt_bcache_put ( pop_data -> bcache , cache_id ( h -> data ) ) ;if ( ! msg -> fp ) {",1320
656,"if ( bcache )  mutt_bcache_commit ( pop_data -> bcache , h -> data ) ;else {","if ( bcache ) mutt_bcache_commit ( pop_data -> bcache , cache_id ( h -> data ) ) ;else {",1320
657,"else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ;}}ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ;if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;","ND_TCHECK ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;",1321
658,"if ( dp -> icmp6_data16 [ 1 ] & 0xc0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x40 )  ND_PRINT ( ( ndo , ""O"" ) ) ;","if ( dp -> icmp6_data16 [ 1 ] ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;",1321
659,struct serial_icounter_struct icount ;struct sb_uart_icount cnow ;,struct serial_icounter_struct icount = {};struct sb_uart_icount cnow ;,1322
660,"r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ;if ( r < 0 ) {","r = safe_mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" , root ) ;if ( r < 0 ) {",1323
661,"Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ;","if ( len > INT_MAX ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ;RETURN_FALSE ;}Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ;",1324
662,"# define ThrowDCMException ( exception , message ) {}char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;","# define ThrowDCMException ( exception , message ) \\\\\\\\\\char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;",1325
663,"if ( length > GetBlobSize ( image ) )  ThrowReaderException ( CorruptImageError ,  ""InsufficientImageDataInFile"" ) ;","if ( length > GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",1325
664,"strlcpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;","strncpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ;",1326
665,lock_sock ( sk ) ;opt -> src_addr = sp -> sa_addr . pptp ;,if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;lock_sock ( sk ) ;opt -> src_addr = sp -> sa_addr . pptp ;,1327
666,int err ;lookup_protocol : err = - ESOCKTNOSUPPORT ;,int err ;if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ;lookup_protocol : err = - ESOCKTNOSUPPORT ;,1328
667,return ( ( f != NULL &&   f -> addressFamily != NULL && f -> addressFamily -> data != NULL )   ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) )  : 0 ) ;,if ( f == NULL || f -> addressFamily != NULL && f -> addressFamily == NULL || f -> addressFamily -> data [ 0 ] << 8 ) | f -> addressFamily -> data [ 1 ] ;,1329
668,assert ( image_info != ( const ImageInfo * ) NULL ) ;,assert ( image_info != ( const ImageInfo * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,1330
669,"if ( chroma_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;","}if ( chroma_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;",1330
670,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,1330
671,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) {scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;;,1330
672,"if ( resize_image == ( Image * ) NULL )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( y = 0 ;","if ( resize_image == ( Image * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}for ( y = 0 ;",1330
673,image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;,1330
674,"if ( arg_zsh ) {if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( fname , & s ) == 0 ) return ;if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) {if ( is_link ( ""/etc/skel/.zshrc"" ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.zshrc<S2SV_blank>file\\\exit ( 1 ) ;}if ( copy_file ( ""/etc/skel/.zshrc"" , fname ) == 0 ) {if ( chown ( fname , u , g ) == - 1 )  errExit ( ""chown"" ) ;fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ;}}else {FILE * fp = fopen ( fname , ""w"" ) ;if ( fp ) {fprintf ( fp , ""\\\fclose ( fp ) ;if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ;if ( chmod ( fname , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chown"" ) ;fs_logger2 ( ""touch"" , fname ) ;}}free ( fname ) ;}else if ( arg_csh ) {if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( fname , & s ) == 0 ) return ;if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {if ( is_link ( ""/etc/skel/.cshrc"" ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.cshrc<S2SV_blank>file\\\if ( copy_file ( ""/etc/skel/.cshrc"" , fname ) == 0 ) {if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ;}FILE * fp = fopen ( fname , ""w"" ) ;if ( fp ) {fprintf ( fp , ""\\\fclose ( fp ) ;if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ;if ( chmod ( fname , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chown"" ) ;}if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {if ( is_link ( ""/etc/skel/.bashrc"" ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.bashrc<S2SV_blank>file\\\if ( copy_file ( ""/etc/skel/.bashrc"" , fname ) == 0 ) {if ( chown ( fname , u , g ) == - 1 ) errExit ( ""chown"" ) ;free ( fname ) ;}}","if ( is_link ( fname ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\\if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) {copy_file_as_user ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ;touch_file_as_user ( fname , u , g , 0644 ) ;if ( is_link ( fname ) ) {fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\\if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) {copy_file_as_user ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) ;",1331
675,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",1332
676,"case SCSI_REQ_STATUS_RETRY_FLUSH :  ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ;if ( ret == 0 ) {",case SCSI_REQ_STATUS_RETRY_FLUSH : ret = scsi_disk_emulate_command ( r ) ;if ( ret == 0 ) {,1333
677,"af = EXTRACT_16BITS ( tptr ) ;safi = tptr [ 2 ] ;ND_PRINT ( ( ndo , ""\\\switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ;default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""\\\if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\goto done ;break ;}tptr += 3 ;ND_TCHECK ( tptr [ 0 ] ) ;nhlen = tptr [ 0 ] ;tlen = nhlen ;tptr ++ ;if ( tlen ) {int nnh = 0 ;ND_PRINT ( ( ndo , ""\\\while ( tlen > 0 ) {if ( nnh ++ > 0 ) {ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ;}switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlen -= sizeof ( struct in_addr ) ;tptr += sizeof ( struct in_addr ) ;}break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ;tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ;}break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ;tlen -= sizeof ( struct in6_addr ) ;tptr += sizeof ( struct in6_addr ) ;}break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ;tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ;}break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlen -= ( sizeof ( struct in_addr ) ) ;tptr += ( sizeof ( struct in_addr ) ) ;}break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ;tptr += tlen ;tlen = 0 ;break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;tlen = 0 ;}else {ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ;if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ;else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ;tptr += tlen ;tlen = 0 ;}break ;default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ;ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ;if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\tptr += tlen ;tlen = 0 ;goto done ;break ;}}}ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ;tptr += tlen ;ND_TCHECK ( tptr [ 0 ] ) ;snpa = tptr [ 0 ] ;tptr ++ ;if ( snpa ) {ND_PRINT ( ( ndo , ""\\\for ( ;snpa > 0 ;snpa -- ) {ND_TCHECK ( tptr [ 0 ] ) ;ND_PRINT ( ( ndo , ""\\\tptr += tptr [ 0 ] + 1 ;}}else {ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ;}while ( len - ( tptr - pptr ) > 0 ) {switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;default : ND_TCHECK2 ( * tptr , tlen ) ;ND_PRINT ( ( ndo , ""\\\if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\\advance = 0 ;tptr = pptr + len ;break ;}if ( advance < 0 ) break ;tptr += advance ;}done : break ;case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ;af = EXTRACT_16BITS ( tptr ) ;safi = tptr [ 2 ] ;ND_PRINT ( ( ndo , ""\\\if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\\while ( len - ( tptr - pptr ) > 0 ) {switch ( af << 8 | safi ) {case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else if ( advance == - 3 ) break ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ;if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\\else if ( advance == - 2 ) goto trunc ;else ND_PRINT ( ( ndo , ""\\\break ;default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ;ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ;if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\\advance = 0 ;tptr = pptr + len ;break ;}if ( advance < 0 ) break ;tptr += advance ;}break ;case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) {ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;break ;}while ( tlen > 0 ) {uint16_t extd_comm ;ND_TCHECK2 ( tptr [ 0 ] , 2 ) ;extd_comm = EXTRACT_16BITS ( tptr ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ;switch ( extd_comm ) {case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ;break ;case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ;break ;case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ;break ;case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ;break ;case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ;break ;case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ;break ;case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ;break ;case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ;break ;default : ND_TCHECK2 ( * tptr , 8 ) ;print_unknown_data ( ndo , tptr , ""\\\break ;}tlen -= 8 ;tptr += 8 ;}break ;case BGPTYPE_PMSI_TUNNEL : {uint8_t tunnel_type , flags ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;ND_PRINT ( ( ndo , ""\\\tptr += 5 ;tlen -= 5 ;switch ( tunnel_type ) {case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ;ND_PRINT ( ( ndo , ""\\\print_unknown_data ( ndo , tptr , ""\\\break ;}case BGPTYPE_AIGP : {uint8_t type ;uint16_t length ;ND_TCHECK2 ( tptr [ 0 ] , 3 ) ;tlen = len ;while ( tlen >= 3 ) {type = * tptr ;length = EXTRACT_16BITS ( tptr + 1 ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;switch ( type ) {case BGP_AIGP_TLV :  ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 ,  EXTRACT_64BITS ( tptr + 3 ) ) ) ;break ;default : if ( ndo -> ndo_vflag <= 1 ) {print_unknown_data ( ndo , tptr + 3 , ""\\\}}","type = * tptr ;length = EXTRACT_16BITS ( tptr + 1 ) ;tlen -= 3 ;ND_PRINT ( ( ndo , ""\\\if ( length < 3 ) goto trunc ;length -= 3 ;ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ;switch ( type ) {case BGP_AIGP_TLV : ND_TCHECK2 ( tptr [ 3 ] , 8 ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr + 3 ) ) ) ;print_unknown_data ( ndo , tptr + 3 , ""\\\",1334
678,state -> object_nl = NULL ;}}else {if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ;state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ;state -> object_nl_len = len ;,"state -> object_nl = fstrndup ( RSTRING_PTR ( object_nl ) , len ) ;state -> object_nl_len = len ;",1335
679,y < nb_blocks ;,y < FFMIN ( nb_blocks ;,1336
680,"for ( y = 0 ;y < s -> ymin ;memset ( ptr , 0 , out_line_size ) ;","for ( y = 0 ;y < s -> ymin , s -> h ) ;memset ( ptr , 0 , out_line_size ) ;",1336
681,"for ( ac = 0 ;int count = skb_queue_len ( & pending ) , tmp ;","spin_lock ( & sta -> ps_lock ) ;for ( ac = 0 ;int count = skb_queue_len ( & pending ) , tmp ;",1337
682,"ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ;if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) {","ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ;spin_unlock ( & sta -> ps_lock ) ;if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) {",1337
683,"prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ;}","enc_tables . counter_head ++ ;enc_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & enc_tables , sizeof ( encT ) ) ;}",1338
684,"struct ssh * ssh = active_state ;struct monitor * mon ;if ( options . compression ) {mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ;mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ;ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ;}",struct monitor * mon ;,1339
685,if ( l >= ( len - o ) ) {iter -> err_off = o ;,if ( l >= ( len - o - 4 ) ) {iter -> err_off = o ;,1340
686,"ap_log_cerror ( APLOG_MARK , APLOG_ERR , 0 , session -> c ,  APLOGNO ( 02920 ) ""h2_session:<S2SV_blank><S2SV_blank>stream(%ld-%d):<S2SV_blank>on_header<S2SV_blank>unknown<S2SV_blank>stream"" , session -> id , ( int ) frame -> hd . stream_id ) ;if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) {return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ;","ap_log_cerror ( APLOG_MARK , APLOG_DEBUG , 0 , session -> c , APLOGNO ( 02920 ) ""h2_session:<S2SV_blank><S2SV_blank>stream(%ld-%d):<S2SV_blank>on_header<S2SV_blank>unknown<S2SV_blank>stream"" , session -> id , ( int ) frame -> hd . stream_id ) ;if ( status == APR_ECONNRESET ) {ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , status , session -> c , ""h2-stream(%ld-%d):<S2SV_blank>on_header,<S2SV_blank>reset<S2SV_blank>stream"" , session -> id , stream -> id ) ;nghttp2_submit_rst_stream ( ngh2 , NGHTTP2_FLAG_NONE , stream -> id , NGHTTP2_INTERNAL_ERROR ) ;}else if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) {return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ;",1341
687,"static void  horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 2 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 2 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%(2*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",1342
688,},return 1 ;},1342
689,"CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ||  ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) ||  bcount != caf_chunk_header . mChunkSize ) {","CAFChannelLayout * caf_channel_layout ;if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) {error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\\\'chan\\\'<S2SV_blank>chunk!"" ) ;return WAVPACK_SOFT_ERROR ;}if ( debug_logging_mode ) error_line ( ""\\\'chan\\\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ;caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {",1343
690,"config -> qmode |= QMODE_REORDERED_CHANS ;channel_layout = num_descriptions ;}if ( ! idents ) {free ( channel_identities ) ;channel_identities = NULL ;}else channel_identities [ idents ] = 0 ;if ( debug_logging_mode ) {error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;if ( channel_reorder && num_descriptions <= 8 ) {char reorder_string [ ] = ""12345678"" ;for ( i = 0 ;i < num_descriptions ;++ i ) reorder_string [ i ] = channel_reorder [ i ] + \'1\' ;reorder_string [ i ] = 0 ;error_line ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\""\\\}}}break ;case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ;if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;break ;default : for ( i = 0 ;i < NUM_LAYOUTS ;++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {config -> channel_mask = layouts [ i ] . mChannelBitmap ;channel_layout = layouts [ i ] . mChannelLayoutTag ;if ( layouts [ i ] . mChannelReorder ) {channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;config -> qmode |= QMODE_REORDERED_CHANS ;}if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ;break ;}if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , caf_channel_layout -> mChannelLayoutTag ) ;break ;}free ( caf_channel_layout ) ;}else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) {uint32_t mEditCount ;if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) {else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) {error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ;return WAVPACK_SOFT_ERROR ;}if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) {config -> qmode |= QMODE_IGNORE_LENGTH ;if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ;else total_samples = - 1 ;}else {if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) {error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) {error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ;if ( ! total_samples ) {error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ;return WAVPACK_SOFT_ERROR ;}if ( total_samples > MAX_WAVPACK_SAMPLES ) {error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}}break ;}else {int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;","+ i ) reorder_string [ i ] = channel_reorder [ i ] + \'1\' ;+ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;char * buff ;if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) {buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;",1343
691,"char linebuf [ L_BUF_SIZE ] ;l_int32 sy , sx , cy , cx , i , j , version , ignore ;if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL )  return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ;sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ;if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\\","char linebuf [ L_BUFSIZE ] ;l_int32 sy , sx , cy , cx , i , j , version , ignore ;if ( fgets ( linebuf , L_BUFSIZE , fp ) == NULL ) return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ;sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" , selname ) ;if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\\",1344
692,"char build [ ATUSB_BUILD_SIZE + 1 ] ;int ret ;ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ;return ret ;}","char * build ;int ret ;build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ;if ( ! build ) return - ENOMEM ;ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ;kfree ( build ) ;return ret ;}",1345
693,if ( isspace ( * s ) )  continue ;,if ( isspace ( ( unsigned char ) * s ) ) continue ;,1346
694,"uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ;parse_cmd_line ( ""js<S2SV_blank>Uzbl.run(\\\'print<S2SV_blank>@useragent\\\').toUpperCase();"" , result ) ;g_assert_cmpstr ( ""TEST<S2SV_blank>USERAGENT"" , == , result -> str ) ;","
",1347
695,"zval * options = NULL , * classes = NULL ;HashTable * class_hash = NULL ;","zval * options = NULL , * classes = NULL ;zval * retval ;HashTable * class_hash = NULL ;",1348
696,"if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;zval_ptr_dtor ( return_value ) ;if ( ! EG ( exception ) ) {var_push_dtor ( & var_hash , return_value ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;","retval = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize_ex ( retval , & p , p + buf_len , & var_hash , class_hash ) ) {PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;if ( ! EG ( exception ) ) {ZVAL_COPY ( return_value , retval ) ;PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ;",1348
697,"int cond_len , then_len , jump_len ;Node * cond = NODE_BAG_BODY ( node ) ;","int cond_len , then_len , else_len , jump_len ;Node * cond = NODE_BAG_BODY ( node ) ;",1349
698,jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ;if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ;,jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP ;,1349
699,"r = compile_tree ( Then , reg , env ) ;if ( r != 0 ) return r ;if ( IS_NOT_NULL ( Else ) ) {int else_len = compile_length_tree ( Else , reg ) ;r = add_op ( reg , OP_JUMP ) ;COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ;r = compile_tree ( Else , reg , env ) ;}","else_len = compile_length_tree ( Else , reg ) ;if ( else_len < 0 ) return else_len ;else else_len = 0 ;r = add_op ( reg , OP_JUMP ) ;COP ( reg ) -> jump . addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP ;r = add_op ( reg , OP_ATOMIC_END ) ;if ( r != 0 ) return r ;if ( IS_NOT_NULL ( Else ) ) {r = compile_tree ( Else , reg , env ) ;}",1349
700,facilities -> source_ndigis = 1 ;}else if ( * p == FAC_NATIONAL_SRC_DIGI ) {if ( ! fac_national_digis_received ) {,else {if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ;},1350
701,"if ( pt [ 6 ] & AX25_HBIT )  memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;else   memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;}","if ( pt [ 6 ] & AX25_HBIT ) {if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ;memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;else memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;}",1350
702,"uint8_t * outbuf ;int rc ;command = buf [ 0 ] ;outbuf = ( uint8_t * ) r -> iov . iov_base ;DPRINTF ( ""Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x"" , req -> lun , req -> tag , buf [ 0 ] ) ;# ifdef DEBUG_SCSI {int i ;for ( i = 1 ;i < r -> req . cmd . len ;i ++ ) {printf ( ""<S2SV_blank>0x%02x"" , buf [ i ] ) ;}printf ( ""\\\}# endif switch ( command ) {case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 :  rc = scsi_disk_emulate_command ( r , outbuf ) ;if ( rc < 0 ) {return 0 ;}r -> iov . iov_len = rc ;break ;case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ;r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ;if ( r -> req . aiocb == NULL ) {scsi_flush_complete ( r , - EIO ) ;}return 0 ;case READ_6 : case READ_10 : case READ_12 : case READ_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ;","int rc ;command = buf [ 0 ] ;outbuf = ( uint8_t * ) r -> iov . iov_base ;DPRINTF ( ""Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x"" , req -> lun , req -> tag , buf [ 0 ] ;",1351
703,"
","assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;assert ( 0 == archive_write_header ( a , ae ) ) ;assert ( 0 == archive_write_finish_entry ( a ) ) ;assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ;assert ( archive_entry_clear ( ae ) != NULL ) ;archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ;failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ;assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ;archive_entry_free ( ae ) ;assert ( 0 == archive_write_finish_entry ( a ) ) ;assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;",1352
704,"assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;assert ( 0 == lstat ( ""dir"" , & st ) ) ;","assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;assert ( 0 == lstat ( ""dir"" , & st ) ) ;",1352
705,"void isoclns_print ( netdissect_options * ndo ,  const uint8_t * p , u_int length , u_int caplen )  {if ( caplen <= 1 ) {ND_PRINT ( ( ndo , ""|OSI"" ) ) ;case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) )  print_unknown_data ( ndo , p , ""\\\break ;case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) )  print_unknown_data ( ndo , p , ""\\\break ;","void isoclns_print ( netdissect_options * ndo , const uint8_t * p , u_int length ) {if ( caplen <= 1 ) {ND_PRINT ( ( ndo , ""|OSI"" ) ) ;case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) ) print_unknown_data ( ndo , p , ""\\\break ;case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) ) print_unknown_data ( ndo , p , ""\\\break ;",1353
706,"if ( caplen > 1 )   print_unknown_data ( ndo , p , ""\\\break ;","if ( length > 1 ) print_unknown_data ( ndo , p , ""\\\break ;",1353
707,register struct enamemem * tp ;char buf [ BUFSIZE ] ;if ( tp -> e_name )   return ( tp -> e_name ) ;cp = buf ;,register struct bsnamemem * tp ;char buf [ BUFSIZE ] ;if ( tp -> bs_name ) return ( tp -> e_name ) ;cp = buf ;,1354
708,"tp -> e_name = strdup ( buf ) ;if ( tp -> e_name == NULL )  ( * ndo -> ndo_error ) ( ndo , ""le64addr_string:<S2SV_blank>strdup(buf)"" ) ;return ( tp -> e_name ) ;}","tp -> bs_name = strdup ( buf ) ;if ( tp -> bs_name == NULL ) ( * ndo -> ndo_error ) ( ndo , ""le64addr_string:<S2SV_blank>strdup(buf)"" ) ;return ( tp -> bs_name ) ;}",1354
709,if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) {ctx -> data_offset = 0x170 + ( ctx -> mb_height << 2 ) ;}else {if ( ctx -> mb_height > 68 ||  ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4 ) {ctx -> data_offset = 0x280 ;},if ( ctx -> mb_height > 68 ) {,1355
710,"static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len )  {struct ipv6_txoptions opt_space ;","static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) {struct ipv6_txoptions * opt_to_free = NULL ;struct ipv6_txoptions opt_space ;",1356
711,"if ( ! opt )  opt = np -> opt ;if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;","if ( ! opt ) {opt = txopt_get ( np ) ;opt_to_free = opt ;}if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;",1356
712,return err < 0 ? err : len ;do_confirm : dst_confirm ( dst ) ;,txopt_put ( opt_to_free ) ;return err < 0 ? err : len ;do_confirm : dst_confirm ( dst ) ;,1356
713,mutex_lock ( & vdev -> vdev_mutex ) ;mutex_lock ( & vi -> vop_mutex ) ;,"if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) {ret = - EINVAL ;goto free_ret ;}mutex_lock ( & vdev -> vdev_mutex ) ;mutex_lock ( & vi -> vop_mutex ) ;",1357
714,if ( count < sizeof ( cmd ) ) {ret = - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ;if ( count < sizeof ( cmd ) ) {ret = - EINVAL ;,1358
715,filename [ filename_size ++ ] = \'\\\\0\' ;if ( rar -> sconv_utf16be == NULL ) {,filename [ filename_size ++ ] = \'\\\\0\' ;if ( rar -> sconv_utf16be == NULL ) {,1359
716,"umode_t mode = inode -> i_mode ;rc = posix_acl_equiv_mode ( acl , & mode ) ;if ( rc < 0 ) return rc ;","umode_t mode ;rc = posix_acl_update_mode ( inode , & mode ) ;if ( rc < 0 ) return rc ;",1360
717,if ( rc == 0 )  acl = NULL ;,"
",1360
718,spin_lock_init ( & port -> phy_list_lock ) ;INIT_LIST_HEAD ( & port -> phy_list ) ;,INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;spin_lock_init ( & port -> phy_list_lock ) ;INIT_LIST_HEAD ( & port -> phy_list ) ;,1361
719,hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ;hmp_chunk [ i ] += chunk_ofs [ i ] ++ ;,hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ;chunk_length [ i ] -= chunk_ofs [ i ] ;hmp_chunk [ i ] += chunk_ofs [ i ] ++ ;,1362
720,"}uint32_t setup_ret = 0 ;if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , 0 ) ) == 0 ) {goto _hmp_end ;chunk_end [ i ] = 1 ;hmp_chunk [ i ] += 3 ;","chunk_length [ i ] -= 3 ;}uint32_t setup_ret = 0 ;if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , chunk_length [ i ] , 0 ) ) == 0 ) {goto _hmp_end ;chunk_end [ i ] = 1 ;chunk_length [ i ] -= 3 ;hmp_chunk [ i ] += 3 ;",1362
721,}var_len_shift = 0 ;if ( * hmp_chunk [ i ] < 0x80 ) {do {chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;var_len_shift += 7 ;}}chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;hmp_chunk [ i ] ++ ;},"chunk_length [ i ] -= setup_ret ;}var_len_shift = 0 ;if ( chunk_length [ i ] && * hmp_chunk [ i ] < 0x80 ) {do {if ( ! chunk_length [ i ] ) break ;chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;var_len_shift += 7 ;chunk_length [ i ] -- ;}}if ( ! chunk_length [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmp_end ;}chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;hmp_chunk [ i ] ++ ;chunk_length [ i ] -- ;}",1362
722,"mem_free ( gr . gr_ctx . value ,  sizeof ( gss_union_ctx_id_desc ) ) ;gss_release_buffer ( & min_stat , & gd -> checksum ) ;mem_free ( gr . gr_ctx . value , sizeof ( gss_union_ctx_id_desc ) ) ;","gss_release_buffer ( & min_stat , & gd -> checksum ) ;",1363
723,"if ( ( creds -> pid == task_tgid_vnr ( current ) ||  ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) &&  ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {","if ( ( creds -> pid == task_tgid_vnr ( current ) || ns_capable ( task_active_pid_ns ( current ) -> user_ns , CAP_SYS_ADMIN ) ) && ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {",1364
724,mntput ( ns -> proc_mnt ) ;},kern_unmount ( ns -> proc_mnt ) ;},1365
725,"if ( ndo -> ndo_vflag )  ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ;p += 8 ;","if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;",1366
726,"return ! inode_capable ( inode , CAP_FOWNER ) ;}","return ! capable_wrt_inode_uidgid ( inode , CAP_FOWNER ) ;}",1367
727,"struct LayerData * cx_layer_list = NULL ;struct LayerData * layer_data ;struct Superframe superframe ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;memset ( & superframe , 0 , sizeof ( superframe ) ) ;svc_log_reset ( svc_ctx ) ;si -> rc_stats_buf_used = 0 ;si -> layers = svc_ctx -> spatial_layers ;if ( si -> frame_within_gop >= si -> kf_dist || si -> encode_frame_count == 0 ) {si -> frame_within_gop = 0 ;}si -> is_keyframe = ( si -> frame_within_gop == 0 ) ;si -> frame_size = 0 ;if ( rawimg != NULL ) {svc_log ( svc_ctx , SVC_LOG_DEBUG , ""vpx_svc_encode<S2SV_blank><S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>frame_count:<S2SV_blank>%d,<S2SV_blank>"" ""frame_within_gop:<S2SV_blank>%d\\\}for ( si -> layer = 0 ;si -> layer < si -> layers ;++ si -> layer ) {if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && si -> is_keyframe && ( si -> layer == 1 || si -> layer == 3 ) ) {svc_log ( svc_ctx , SVC_LOG_DEBUG , ""Skip<S2SV_blank>encoding<S2SV_blank>layer<S2SV_blank>%d\\\continue ;}if ( rawimg != NULL ) {calculate_enc_frame_flags ( svc_ctx ) ;set_svc_parameters ( svc_ctx , codec_ctx ) ;}res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration , si -> enc_frame_flags , deadline ) ;case VPX_CODEC_CX_FRAME_PKT : {const uint32_t frame_pkt_size = ( uint32_t ) ( cx_pkt -> data . frame . sz ) ;si -> bytes_sum [ si -> layer ] += frame_pkt_size ;svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%u\\\ld_list_add ( & cx_layer_list , layer_data ) ;superframe . sizes [ superframe . count ++ ] = frame_pkt_size ;superframe . magnitude |= frame_pkt_size ;break ;}case VPX_CODEC_PSNR_PKT : {int i ;svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\\svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\\for ( i = 0 ;i < COMPONENTS ;i ++ ) {si -> psnr_sum [ si -> layer ] [ i ] += cx_pkt -> data . psnr . psnr [ i ] ;si -> sse_sum [ si -> layer ] [ i ] += cx_pkt -> data . psnr . sse [ i ] ;}break ;}case VPX_CODEC_STATS_PKT : {size_t new_size = si -> rc_stats_buf_used + cx_pkt -> data . twopass_stats . sz ;if ( new_size > si -> rc_stats_buf_size ) {char * p = ( char * ) realloc ( si -> rc_stats_buf , new_size ) ;if ( p == NULL ) {svc_log ( svc_ctx , SVC_LOG_ERROR , ""Error<S2SV_blank>allocating<S2SV_blank>stats<S2SV_blank>buf\\\break ;}si -> rc_stats_buf = p ;si -> rc_stats_buf_size = new_size ;}memcpy ( si -> rc_stats_buf + si -> rc_stats_buf_used , cx_pkt -> data . twopass_stats . buf , cx_pkt -> data . twopass_stats . sz ) ;si -> rc_stats_buf_used += cx_pkt -> data . twopass_stats . sz ;break ;}default : {break ;}}}if ( rawimg == NULL ) {break ;}}if ( codec_ctx -> config . enc -> g_pass != VPX_RC_FIRST_PASS ) {sf_create_index ( & superframe ) ;layer_data = ld_create ( superframe . buffer , superframe . index_size ) ;ld_list_add ( & cx_layer_list , layer_data ) ;si -> frame_size = ld_list_get_buffer_size ( cx_layer_list ) ;if ( si -> frame_size > 0 ) {if ( si -> frame_size > si -> buffer_size ) {free ( si -> buffer ) ;si -> buffer = malloc ( si -> frame_size ) ;if ( si -> buffer == NULL ) {ld_list_free ( cx_layer_list ) ;return VPX_CODEC_MEM_ERROR ;}si -> buffer_size = si -> frame_size ;}ld_list_copy_to_buffer ( cx_layer_list , ( uint8_t * ) si -> buffer ) ;ld_list_free ( cx_layer_list ) ;svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>kf:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>"" ""pts:<S2SV_blank>%d\\\}}++ si -> frame_within_gop ;++ si -> encode_frame_count ;return VPX_CODEC_OK ;}","SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;+ si -> layer ) {svc_log_reset ( svc_ctx ) ;res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration , 0 , deadline ) ;case VPX_CODEC_CX_FRAME_PKT : {const uint32_t frame_pkt_size = ( uint32_t ) ( cx_pkt -> data . frame . sz ) ;si -> bytes_sum [ si -> layer ] += frame_pkt_size ;svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%u\\\+ si -> frame_within_gop ;+ si -> encode_frame_count ;",1368
728,void * parg = NULL ;long err = - EINVAL ;int is_ext_ctrl ;size_t ctrls_size = 0 ;void __user * user_ptr = NULL ;is_ext_ctrl = ( cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS || cmd == VIDIOC_TRY_EXT_CTRLS ) ;switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE :  parg = NULL ;case _IOC_READ :  case _IOC_WRITE :  case ( _IOC_WRITE | _IOC_READ ) :  if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;,"void * parg = ( void * ) arg ;long err = - EINVAL ;if ( has_array_args ) {* kernel_ptr = user_ptr ;if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ;goto out_array_args ;}if ( err < 0 ) goto out ;out_array_args : switch ( _IOC_DIR ( cmd ) ) {case _IOC_NONE : parg = NULL ;case _IOC_READ : case _IOC_WRITE : case ( _IOC_WRITE | _IOC_READ ) : if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;",1369
729,"# ifdef HAVE_INT64_TIMESTAMP  char fstr [ MAXDATELEN + 1 ] ;strcpy ( fstr , ( cp + 1 ) ) ;strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ;* ( fstr + 6 ) = \'\\\\0\' ;",# ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ;int i ;cp ++ ;for ( i = 0 ;i < 6 ;i ++ ) fstr [ i ] = * cp != \'\\\\0\' ? * cp ++ : \'0\' ;fstr [ i ] = \'\\\\0\' ;,1370
730,"pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn +  pi -> picomp -> numrlvls - 1 ) ) ;pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn +  pi -> picomp -> numrlvls - 1 ) ) ;pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;","pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ;pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;",1371
731,"static void  sraSpanInsertAfter ( sraSpan * newspan , sraSpan * after ) {newspan -> _next = after -> _next ;}","static void sraSpanInsertAfter ( sraSpan * newspan , sraSpan * after ) {if ( newspan && after ) {newspan -> _next = after -> _next ;}}",1372
732,while ( c && which > 0 ) {c = c -> next ;-- which ;,while ( c && which > 0 ) c = c -> next ;-- which ;,1373
733,if ( noblock )  return - EAGAIN ;,cond_resched ( ) ;,1374
734,"
","if ( len < j + msg -> len + 1 ) {LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\\return - 1 ;}",1375
735,"memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\\","memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\\",1375
736,"if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ;","if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len ) ) goto trunc ;",1376
737,"case ETHERTYPE_GRE_ISO :  isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ;break ;case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;","case ETHERTYPE_GRE_ISO : isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ;",1376
738,skcipher -> setkey = alg -> setkey ;skcipher -> encrypt = alg -> encrypt ;,skcipher -> setkey = skcipher_setkey ;skcipher -> encrypt = alg -> encrypt ;,1377
739,c . c_arena = arena ;c . c_filename = filename ;c . c_normalize = NULL ;c . c_normalize_args = NULL ;c . c_feature_version = feature_version ;,c . c_feature_version = feature_version ;,1378
740,"PyTuple_SET_ITEM ( c . c_normalize_args , 1 , NULL ) ;Py_DECREF ( c . c_normalize_args ) ;","
",1378
741,"void vp9_encode_block_intra ( MACROBLOCK * x , int plane , int block ,  BLOCK_SIZE plane_bsize , TX_SIZE tx_size ,  unsigned char * skip ) {struct encode_b_args arg = {x , NULL , skip };encode_block_intra ( plane , block , plane_bsize , tx_size , & arg ) ;","void vp9_encode_block_intra ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {struct encode_b_args * const args = arg ;MACROBLOCK * const x = args -> x ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;struct macroblock_plane * const p = & x -> plane [ plane ] ;struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;tran_low_t * coeff = BLOCK_OFFSET ( p -> coeff , block ) ;tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;tran_low_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;const scan_order * scan_order ;TX_TYPE tx_type = DCT_DCT ;PREDICTION_MODE mode ;const int bwl = b_width_log2_lookup [ plane_bsize ] ;const int diff_stride = 4 * ( 1 << bwl ) ;uint8_t * src , * dst ;int16_t * src_diff ;uint16_t * eob = & p -> eobs [ block ] ;const int src_stride = p -> src . stride ;const int dst_stride = pd -> dst . stride ;int i , j ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;dst = & pd -> dst . buf [ 4 * ( j * dst_stride + i ) ] ;src = & p -> src . buf [ 4 * ( j * src_stride + i ) ] ;src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ;if ( tx_size == TX_4X4 ) {tx_type = get_tx_type_4x4 ( pd -> plane_type , xd , block ) ;scan_order = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ;mode = plane == 0 ? get_y_mode ( xd -> mi [ 0 ] , block ) : mbmi -> uv_mode ;}else {mode = plane == 0 ? mbmi -> mode : mbmi -> uv_mode ;if ( tx_size == TX_32X32 ) {scan_order = & vp9_default_scan_orders [ TX_32X32 ] ;}else {tx_type = get_tx_type ( pd -> plane_type , xd ) ;scan_order = & vp9_scan_orders [ tx_size ] [ tx_type ] ;}}vp9_predict_intra_block ( xd , bwl , tx_size , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , i , j , plane ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {switch ( tx_size ) {case TX_32X32 : if ( ! x -> skip_recode ) {vpx_highbd_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ;highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {vp9_highbd_idct32x32_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ;}break ;case TX_16X16 : if ( ! x -> skip_recode ) {vpx_highbd_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ;if ( tx_type == DCT_DCT ) vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ;else vp9_highbd_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ;vpx_highbd_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {vp9_highbd_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ;}break ;case TX_8X8 : if ( ! x -> skip_recode ) {vpx_highbd_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ;if ( tx_type == DCT_DCT ) vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ;else vp9_highbd_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ;vpx_highbd_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {vp9_highbd_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ;}break ;case TX_4X4 : if ( ! x -> skip_recode ) {vpx_highbd_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ;if ( tx_type != DCT_DCT ) vp9_highbd_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ;else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ;vpx_highbd_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {if ( tx_type == DCT_DCT ) {x -> highbd_itxm_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ;}else {vp9_highbd_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type , xd -> bd ) ;}}break ;default : assert ( 0 ) ;return ;}if ( * eob ) * ( args -> skip ) = 0 ;return ;}# endif switch ( tx_size ) {case TX_32X32 : if ( ! x -> skip_recode ) {vpx_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ;fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) vp9_idct32x32_add ( dqcoeff , dst , dst_stride , * eob ) ;break ;case TX_16X16 : if ( ! x -> skip_recode ) {vpx_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ;vp9_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ;vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) vp9_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ;break ;case TX_8X8 : if ( ! x -> skip_recode ) {vpx_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ;vp9_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ;vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) vp9_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ;break ;case TX_4X4 : if ( ! x -> skip_recode ) {vpx_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ;if ( tx_type != DCT_DCT ) vp9_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ;else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ;vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;}if ( ! x -> skip_encode && * eob ) {if ( tx_type == DCT_DCT ) x -> itxm_add ( dqcoeff , dst , dst_stride , * eob ) ;else vp9_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type ) ;}break ;default : assert ( 0 ) ;break ;}if ( * eob ) * ( args -> skip ) = 0 ;",1379
742,UnpackRaster :  if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {,"UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) break ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {",1380
743,"else {if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}if ( bpp == 1 ) {if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) {image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ;}}if ( UnpackWPGRaster ( image , bpp , exception ) < 0 ) {DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ;}if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) {if ( BitmapHeader2 . RotAngle & 0x8000 ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x2000 ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}if ( BitmapHeader2 . RotAngle & 0x0FFF ) {Image * rotate_image ;rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ;if ( rotate_image != ( Image * ) NULL ) {DuplicateBlob ( rotate_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , rotate_image ) ;}}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ;break ;}}break ;case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ;StartWPG . PosSizePrecision = 0 ;while ( ! EOFBlob ( image ) ) {( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ;if ( EOFBlob ( image ) ) break ;Rec2 . Class = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ;if ( i == EOF ) break ;Rd_WP_DWORD ( image , & Rec2 . Extension ) ;Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ;if ( EOFBlob ( image ) ) break ;Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ;switch ( Rec2 . RecType ) {case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ;StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ;StartWPG . PosSizePrecision = ReadBlobByte ( image ) ;break ;case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ;WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ;image -> colors = WPG_Palette . NumOfEntries ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = WPG_Palette . StartIndex ;i < ( int ) WPG_Palette . NumOfEntries ;i ++ ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ;( void ) ReadBlobByte ( image ) ;}break ;case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ;Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ;if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;Bitmap2Header1 . Depth = ReadBlobByte ( image ) ;Bitmap2Header1 . Compression = ReadBlobByte ( image ) ;if ( Bitmap2Header1 . Compression > 1 ) continue ;switch ( Bitmap2Header1 . Depth ) {case 1 : bpp = 1 ;break ;case 2 : bpp = 2 ;break ;case 3 : bpp = 4 ;break ;case 4 : bpp = 8 ;break ;case 8 : bpp = 24 ;break ;default : continue ;}image -> columns = Bitmap2Header1 . Width ;image -> rows = Bitmap2Header1 . Height ;if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) {size_t one ;one = 1 ;image -> colors = one << bpp ;if ( ! AcquireImageColormap ( image , image -> colors , exception ) ) goto NoMemory ;}else {if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelInfo * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ;}switch ( Bitmap2Header1 . Compression ) {case 0 : {ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ;BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;for ( i = 0 ;i < ( ssize_t ) image -> rows ;i ++ ) {( void ) ReadBlob ( image , ldblk , BImgBuff ) ;InsertRow ( image , BImgBuff , i , bpp , exception ) ;}if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;break ;}case 1 : {if ( UnpackWPG2Raster ( image , bpp , exception ) < 0 ) goto DecompressionFailed ;break ;}}if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) {Image * flop_image ;flop_image = FlopImage ( image , exception ) ;if ( flop_image != ( Image * ) NULL ) {DuplicateBlob ( flop_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flop_image ) ;}}if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) {Image * flip_image ;flip_image = FlipImage ( image , exception ) ;if ( flip_image != ( Image * ) NULL ) {DuplicateBlob ( flip_image , image ) ;( void ) RemoveLastImageFromList ( & image ) ;AppendImageToList ( & image , flip_image ) ;}}AcquireNextImage ( image_info , image , exception ) ;image -> depth = 8 ;if ( image -> next == ( Image * ) NULL ) goto Finish ;image = SyncNextImageInList ( image ) ;image -> columns = image -> rows = 1 ;image -> colors = 0 ;break ;case 0x12 : i = ReadBlobLSBShort ( image ) ;if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ;break ;case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ;( void ) WPG2Flags ;break ;}}break ;default : {ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;}}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;","
",1380
744,"
","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;",1381
745,"if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;","if ( * parv [ 1 ] == \':\' || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ;if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_one ( & me , CMD_SASL , acptr , ""%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",1381
746,"if ( ! EmptyString ( cli_sslclifp ( cptr ) ) )  sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;","if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , ""*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s"" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ;",1381
747,"int ret = - 1 ;s = ECDSA_SIG_new ( ) ;if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ;ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;err :  ECDSA_SIG_free ( s ) ;return ( ret ) ;","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = ECDSA_SIG_new ( ) ;if ( d2i_ECDSA_SIG ( & s , & p , sig_len ) == NULL ) goto err ;derlen = i2d_ECDSA_SIG ( s , & der ) ;if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}ECDSA_SIG_free ( s ) ;return ( ret ) ;",1382
748,"switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;","size_t pathlen = 0 ;switch ( af ) {case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ;",1383
749,"case AF_UNIX :  strncpy ( addr_text ,   ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ,  sizeof ( addr_text ) - 1 ) ;addr_text [ sizeof ( addr_text ) - 1 ] = \'\\\\0\' ;","case AF_UNIX : pathlen = sizeof ( ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ) ;if ( MAXPATHLEN <= pathlen ) {pathlen = MAXPATHLEN - 1 ;}strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ;addr_text [ pathlen ] = \'\\\\0\' ;",1383
750,"struct tpacket_req * req = & req_u -> req ;if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) {rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ;rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ;err = - EBUSY ;if ( ! closing ) {if ( atomic_read ( & po -> mapped ) ) goto out ;if ( packet_read_pending ( rb ) ) goto out ;}if ( req -> tp_block_nr ) {err = - EBUSY ;if ( unlikely ( rb -> pg_vec ) ) goto out ;switch ( po -> tp_version ) {case TPACKET_V1 : po -> tp_hdrlen = TPACKET_HDRLEN ;break ;case TPACKET_V2 : po -> tp_hdrlen = TPACKET2_HDRLEN ;break ;case TPACKET_V3 : po -> tp_hdrlen = TPACKET3_HDRLEN ;break ;}err = - EINVAL ;if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) goto out ;if ( unlikely ( ! PAGE_ALIGNED ( req -> tp_block_size ) ) ) goto out ;if ( po -> tp_version >= TPACKET_V3 && ( int ) ( req -> tp_block_size - BLK_PLUS_PRIV ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) goto out ;if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + po -> tp_reserve ) ) goto out ;if ( unlikely ( req -> tp_frame_size & ( TPACKET_ALIGNMENT - 1 ) ) ) goto out ;rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ;if ( unlikely ( rb -> frames_per_block == 0 ) ) goto out ;if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != req -> tp_frame_nr ) ) goto out ;err = - ENOMEM ;order = get_order ( req -> tp_block_size ) ;pg_vec = alloc_pg_vec ( req , order ) ;if ( unlikely ( ! pg_vec ) ) goto out ;switch ( po -> tp_version ) {case TPACKET_V3 : if ( ! tx_ring ) init_prb_bdqc ( po , rb , pg_vec , req_u ) ;break ;default : break ;}}else {err = - EINVAL ;if ( unlikely ( req -> tp_frame_nr ) ) goto out ;}lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;spin_unlock ( & po -> bind_lock ) ;","struct tpacket_req * req = & req_u -> req ;lock_sock ( sk ) ;if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) {spin_lock ( & po -> bind_lock ) ;if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;out : spin_unlock ( & po -> bind_lock ) ;",1384
751,"release_sock ( sk ) ;if ( pg_vec )  free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;","release_sock ( sk ) ;if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;",1384
752,"if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 &&  ! no_port_forwarding_flag && ! options . disable_forwarding ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;","if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 && ! no_port_forwarding_flag && ! options . disable_forwarding && use_privsep ) {c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ;",1385
753,"RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ;RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ;RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ;RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ;RANGE_CHECK ( cfg , ts_number_layers , 1 , VPX_TS_MAX_LAYERS ) ;if ( cfg -> ts_number_layers > 1 ) {unsigned int i ;for ( i = 1 ;++ i )  if ( cfg -> ts_target_bitrate [ i ] < cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ;RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ;for ( i = cfg -> ts_number_layers - 2 ;i > 0 ;-- i )   if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] )   ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ;}if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ;RANGE_CHECK_BOOL ( extra_cfg , enable_auto_alt_ref ) ;RANGE_CHECK ( extra_cfg , cpu_used , - 16 , 16 ) ;RANGE_CHECK_HI ( extra_cfg , noise_sensitivity , 6 ) ;RANGE_CHECK ( extra_cfg , tile_columns , 0 , 6 ) ;RANGE_CHECK ( extra_cfg , tile_rows , 0 , 2 ) ;RANGE_CHECK_HI ( extra_cfg , sharpness , 7 ) ;RANGE_CHECK ( extra_cfg , arnr_max_frames , 0 , 15 ) ;RANGE_CHECK_HI ( extra_cfg , arnr_strength , 6 ) ;RANGE_CHECK ( extra_cfg , arnr_type , 1 , 3 ) ;RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ;if ( extra_cfg -> tuning == VP8_TUNE_SSIM ) ERROR ( ""Option<S2SV_blank>--tune=ssim<S2SV_blank>is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>VP9."" ) ;size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ;int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ;const FIRSTPASS_STATS * stats ;if ( cfg -> ss_number_layers > 1 ) {int i ;","RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 100 ) ;RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 100 ) ;RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ;RANGE_CHECK ( extra_cfg , min_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ;RANGE_CHECK ( extra_cfg , max_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ;if ( extra_cfg -> max_gf_interval > 0 ) {RANGE_CHECK ( extra_cfg , max_gf_interval , 2 , ( MAX_LAG_BUFFERS - 1 ) ) ;}if ( extra_cfg -> min_gf_interval > 0 && extra_cfg -> max_gf_interval > 0 ) {RANGE_CHECK ( extra_cfg , max_gf_interval , extra_cfg -> min_gf_interval , ( MAX_LAG_BUFFERS - 1 ) ) ;}if ( cfg -> ss_number_layers * cfg -> ts_number_layers > VPX_MAX_LAYERS ) ERROR ( ""ss_number_layers<S2SV_blank>*<S2SV_blank>ts_number_layers<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ;if ( cfg -> ts_number_layers > 1 ) {RANGE_CHECK ( cfg , rc_scaled_width , 0 , cfg -> g_w ) ;RANGE_CHECK ( cfg , rc_scaled_height , 0 , cfg -> g_h ) ;}RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ;RANGE_CHECK ( cfg , ts_number_layers , 1 , VPX_TS_MAX_LAYERS ) ;if ( cfg -> ts_number_layers > 1 ) {unsigned int sl , tl ;for ( i = 1 ;+ i )  if ( cfg -> ts_target_bitrate [ i ] < cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ;++ tl ) {const int layer = LAYER_IDS_TO_IDX ( sl , tl , cfg -> ts_number_layers ) ;if ( cfg -> layer_target_bitrate [ layer ] < cfg -> layer_target_bitrate [ layer - 1 ] ) ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ;}}RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ;for ( tl = cfg -> ts_number_layers - 2 ;tl > 0 ;-- i ) if ( cfg -> ts_rate_decimator [ tl - 1 ] != 2 * cfg -> ts_rate_decimator [ tl ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ;}# if CONFIG_SPATIAL_SVC if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && cfg -> g_pass == VPX_RC_LAST_PASS ) {unsigned int i , alt_ref_sum = 0 ;for ( i = 0 ;i < cfg -> ss_number_layers ;++ i ) {if ( cfg -> ss_enable_auto_alt_ref [ i ] ) ++ alt_ref_sum ;}if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers ) ERROR ( ""Not<S2SV_blank>enough<S2SV_blank>ref<S2SV_blank>buffers<S2SV_blank>for<S2SV_blank>svc<S2SV_blank>alt<S2SV_blank>ref<S2SV_blank>frames"" ) ;if ( cfg -> ss_number_layers * cfg -> ts_number_layers > 3 && cfg -> g_error_resilient == 0 ) ERROR ( ""Multiple<S2SV_blank>frame<S2SV_blank>context<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>more<S2SV_blank>than<S2SV_blank>3<S2SV_blank>layers"" ) ;}# endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( ""kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>"" ""or<S2SV_blank>kf_max_dist<S2SV_blank>instead."" ) ;RANGE_CHECK ( extra_cfg , enable_auto_alt_ref , 0 , 2 ) ;RANGE_CHECK ( extra_cfg , cpu_used , - 8 , 8 ) ;RANGE_CHECK_HI ( extra_cfg , cq_level , 0 , 63 ) ;RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ;RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ;RANGE_CHECK ( extra_cfg , content , VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 ) ;if ( extra_cfg -> tuning == VP8_TUNE_SSIM ) ERROR ( ""Option<S2SV_blank>--tune=ssim<S2SV_blank>is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>VP9."" ) ;const size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ;const int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ;const FIRSTPASS_STATS * stats ;if ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) {int i ;",1386
754,"if ( layer_id >= cfg -> ss_number_layers  || ( int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 )  ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ;else {if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 &&   extra_cfg -> bit_depth > BITS_8 )  ERROR ( ""High<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ;if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 &&   extra_cfg -> bit_depth == BITS_8 )  ERROR ( ""Bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1"" ) ;","if ( layer_id >= cfg -> ss_number_layers || ( unsigned int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 ) ERROR ( ""rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet"" ) ;}# if ! CONFIG_VP9_HIGHBITDEPTH if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) {ERROR ( ""Profile<S2SV_blank>><S2SV_blank>1<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build<S2SV_blank>configuration"" ) ;# endif else {if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth > VPX_BITS_8 ) {ERROR ( ""Codec<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ;}if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && cfg -> g_input_bit_depth > 8 ) {ERROR ( ""Source<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ;}if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth == VPX_BITS_8 ) {ERROR ( ""Codec<S2SV_blank>bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1"" ) ;}RANGE_CHECK ( extra_cfg , color_space , VPX_CS_UNKNOWN , VPX_CS_SRGB ) ;",1386
755,"static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {","static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx , va_list args ) {",1387
756,char added ;},},1388
757,"
",if ( ! cd -> disk ) continue ;,1389
758,blk_cleanup_queue ( cd -> disk -> queue ) ;cd -> disk -> queue = NULL ;,blk_cleanup_queue ( cd -> disk -> queue ) ;cd -> disk -> queue = NULL ;,1389
759,"
",if ( lha -> compsize < 0 ) goto invalid ;,1390
760,"if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;","if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;",1390
761,"int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ;APPL_TRACE_DEBUG ( ""accepted<S2SV_blank>fd:%d<S2SV_blank>for<S2SV_blank>server<S2SV_blank>fd:%d"" , fd , s ) ;","int fd = TEMP_FAILURE_RETRY ( accept ( s , ( struct sockaddr * ) & client_address , & clen ) ) ;APPL_TRACE_DEBUG ( ""accepted<S2SV_blank>fd:%d<S2SV_blank>for<S2SV_blank>server<S2SV_blank>fd:%d"" , fd , s ) ;",1391
762,if ( net != & init_net )  return - EAFNOSUPPORT ;,if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( net != & init_net ) return - EAFNOSUPPORT ;,1392
763,"
","rb_define_method ( req_class , ""remote_addr"" , remote_addr , 0 ) ;",1393
764,"rb_define_method ( req_class , ""rack_version"" , rack_version , 0 ) ;rb_define_method ( req_class , ""rack_url_scheme"" , rack_url_scheme , 0 ) ;","rb_define_method ( req_class , ""rack_version"" , rack_version , 0 ) ;rb_define_method ( req_class , ""rack_url_scheme"" , rack_url_scheme , 0 ) ;",1393
765,"rack_version_val = rb_str_new_cstr ( ""rack.version"" ) ;request_method_val = rb_str_new_cstr ( ""REQUEST_METHOD"" ) ;","rack_version_val = rb_str_new_cstr ( ""rack.version"" ) ;remote_addr_val = rb_str_new_cstr ( ""REMOTE_ADDR"" ) ;rb_gc_register_address ( & remote_addr_val ) ;request_method_val = rb_str_new_cstr ( ""REQUEST_METHOD"" ) ;",1393
766,"static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) {const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;","static void calc_segtree_probs ( int * segcounts , vpx_prob * segment_tree_probs ) {const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;",1394
767,"opt = xchg ( & np -> opt , NULL ) ;if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;pktopt = xchg ( & np -> pktoptions , NULL ) ;","opt = xchg ( ( __force struct ipv6_txoptions * * ) & np -> opt , NULL ) ;if ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}pktopt = xchg ( & np -> pktoptions , NULL ) ;",1395
768,"opt = ipv6_renew_options ( sk , np -> opt , optname ,  ( struct ipv6_opt_hdr __user * ) optval , optlen ) ;if ( IS_ERR ( opt ) ) {retv = PTR_ERR ( opt ) ;","opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ;opt = ipv6_renew_options ( sk , opt , optname , ( struct ipv6_opt_hdr __user * ) optval , optlen ) ;if ( IS_ERR ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}",1395
769,"sticky_done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;","sticky_done : if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;",1395
770,"
","atomic_set ( & opt -> refcnt , 1 ) ;",1395
771,opt -> tot_len = sizeof ( * opt ) + optlen ;retv = - EFAULT ;,opt -> tot_len = sizeof ( * opt ) + optlen ;retv = - EFAULT ;,1395
772,"done : if ( opt )  sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;","done : if ( opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ;break ;",1395
773,JSObjectRef globalobject ;JSStringRef var_name ;,JSObjectRef globalobject ;,1396
774,"globalobject = JSContextGetGlobalObject ( context ) ;var_name = JSStringCreateWithUTF8CString ( ""Uzbl"" ) ;JSObjectSetProperty ( context , globalobject , var_name , JSObjectMake ( context , uzbl . js . classref , NULL ) , kJSClassAttributeNone , NULL ) ;",globalobject = JSContextGetGlobalObject ( context ) ;,1396
775,"JSStringRelease ( js_result_string ) ;}JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ;JSStringRelease ( var_name ) ;","
",1396
776,"const int zbin = cpi -> zbin_mode_boost + x -> act_zbin_adj ;int i ;x -> plane [ 0 ] . quant = quants -> y_quant [ qindex ] ;x -> plane [ 0 ] . quant_shift = quants -> y_quant_shift [ qindex ] ;x -> plane [ 0 ] . zbin = quants -> y_zbin [ qindex ] ;x -> plane [ 0 ] . round = quants -> y_round [ qindex ] ;x -> plane [ 0 ] . zbin_extra = ( int16_t ) ( ( cm -> y_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;xd -> plane [ 0 ] . dequant = cm -> y_dequant [ qindex ] ;x -> plane [ i ] . quant_shift = quants -> uv_quant_shift [ qindex ] ;x -> plane [ i ] . zbin = quants -> uv_zbin [ qindex ] ;x -> plane [ i ] . round = quants -> uv_round [ qindex ] ;x -> plane [ i ] . zbin_extra = ( int16_t ) ( ( cm -> uv_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;xd -> plane [ i ] . dequant = cm -> uv_dequant [ qindex ] ;# if CONFIG_ALPHA  x -> plane [ 3 ] . quant = cpi -> a_quant [ qindex ] ;# endif  x -> skip_block = vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ;x -> q_index = qindex ;vp9_initialize_me_consts ( cpi , x -> q_index ) ;}","int i ;x -> plane [ 0 ] . quant_fp = quants -> y_quant_fp [ qindex ] ;xd -> plane [ 0 ] . dequant = cpi -> y_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;xd -> plane [ 0 ] . dequant = cm -> y_dequant [ qindex ] ;x -> plane [ i ] . quant_shift = quants -> uv_quant_shift [ qindex ] ;x -> plane [ i ] . zbin = quants -> uv_zbin [ qindex ] ;xd -> plane [ i ] . dequant = cpi -> uv_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;xd -> plane [ i ] . dequant = cm -> uv_dequant [ qindex ] ;# if CONFIG_ALPHA x -> plane [ 3 ] . quant = cpi -> a_quant [ qindex ] ;# endif x -> skip_block = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ;x -> q_index = qindex ;vp9_initialize_me_consts ( cpi , x , x -> q_index ) ;}",1397
777,"
","if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ;",1398
778,"if ( label_exec ( opt_exec_label ) == - 1 )  die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ;","if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ;",1398
779,"
",if ( unlikely ( page_count ( page ) <= 0 ) ) {if ( pages ) {spin_unlock ( ptl ) ;remainder = 0 ;err = - ENOMEM ;break ;}},1399
780,same_page :  if ( pages ) {,same_page : if ( pages ) {,1399
781,"
",# else ( void ) mr_cfg ;,1400
782,# endif  oxcf -> cpu_used = vp8_cfg . cpu_used ;,# endif oxcf -> cpu_used = vp8_cfg . cpu_used ;,1400
783,oxcf -> tuning = vp8_cfg . tuning ;return VPX_CODEC_OK ;,oxcf -> tuning = vp8_cfg . tuning ;oxcf -> screen_content_mode = vp8_cfg . screen_content_mode ;return VPX_CODEC_OK ;,1400
784,usleep ( us_delay ) ;pthread_mutex_unlock ( & in -> common . lock ) ;,TEMP_FAILURE_RETRY ( usleep ( us_delay ) ) ;pthread_mutex_unlock ( & in -> common . lock ) ;,1401
785,if ( ctx -> pbi ) {vp9_decoder_remove ( ctx -> pbi ) ;ctx -> pbi = NULL ;},if ( ctx -> frame_workers != NULL ) {int i ;for ( i = 0 ;i < ctx -> num_frame_workers ;++ i ) {VPxWorker * const worker = & ctx -> frame_workers [ i ] ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;vpx_get_worker_interface ( ) -> end ( worker ) ;vp9_remove_common ( & frame_worker_data -> pbi -> common ) ;# if CONFIG_VP9_POSTPROC vp9_free_postproc_buffers ( & frame_worker_data -> pbi -> common ) ;# endif vp9_decoder_remove ( frame_worker_data -> pbi ) ;vpx_free ( frame_worker_data -> scratch_buffer ) ;# if CONFIG_MULTITHREAD pthread_mutex_destroy ( & frame_worker_data -> stats_mutex ) ;pthread_cond_destroy ( & frame_worker_data -> stats_cond ) ;# endif vpx_free ( frame_worker_data ) ;}# if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ;# endif }if ( ctx -> buffer_pool ) {vp9_free_ref_frame_buffers ( ctx -> buffer_pool ) ;vp9_free_internal_frame_buffers ( & ctx -> buffer_pool -> int_frame_buffers ) ;}vpx_free ( ctx -> frame_workers ) ;vpx_free ( ctx -> buffer_pool ) ;,1402
786,"c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ;macinf -> lchid [ j + chan ] = c_t + 1 ;macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ;rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ;}","c_t = ( tvb_get_bits8 ( tvb , tb_bit_off , 4 ) + 1 ) % 0xf ;macinf -> lchid [ j + chan ] = c_t ;macinf -> content [ j + chan ] = lchId_type_table [ c_t ] ;rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t ] ;}",1403
787,"if ( setuid ( current_user . uid ) < 0 )  {if ( setgid ( current_user . gid ) < 0 )  sys_error ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>gid<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>effective<S2SV_blank>gid<S2SV_blank>%d"" ) , current_user . gid , current_user . egid ) ;","# if HAVE_DECL_SETRESUID if ( setresuid ( current_user . uid , current_user . uid , current_user . uid ) < 0 ) # endif # else if ( setuid ( current_user . uid ) < 0 ) {# if HAVE_DECL_SETRESGID if ( setresgid ( current_user . gid , current_user . gid , current_user . gid ) < 0 ) # endif # else if ( setgid ( current_user . gid ) < 0 ) sys_error ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>gid<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>effective<S2SV_blank>gid<S2SV_blank>%d"" ) , current_user . gid , current_user . egid ) ;",1404
788,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {ret = - ENOKEY ;goto error2 ;}",ret = key_read_state ( key ) ;if ( ret < 0 ) goto error2 ;,1405
789,"int copy = output_size - count ;if ( avail < copy ) copy = avail ;png_memcpy ( output + count , png_ptr -> zbuf , copy ) ;","png_size_t copy = output_size - count ;if ( ( png_size_t ) avail < copy ) copy = ( png_size_t ) avail ;png_memcpy ( output + count , png_ptr -> zbuf , copy ) ;",1406
790,"pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn +  pi -> picomp -> numrlvls - 1 ) ) ;pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn +  pi -> picomp -> numrlvls - 1 ) ) ;pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;","pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ;pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ;",1407
791,"struct keydata * keyptr ;__u32 * hash = get_cpu_var ( get_random_int_hash ) ;int ret ;keyptr = get_keyptr ( ) ;hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ;ret = half_md4_transform ( hash , keyptr -> secret ) ;put_cpu_var ( get_random_int_hash ) ;","__u32 * hash = get_cpu_var ( get_random_int_hash ) ;int ret ;keyptr = get_keyptr ( ) ;md5_transform ( hash , keyptr -> secret ) ;put_cpu_var ( get_random_int_hash ) ;",1408
792,"struct task_struct * tsk = current ;struct fpu * fpu = & tsk -> thread . fpu ;int state_size = fpu_kernel_xstate_size ;u64 xfeatures = 0 ;int fx_only = 0 ;ia32_fxstate &= ( IS_ENABLED ( CONFIG_X86_32 ) || IS_ENABLED ( CONFIG_IA32_EMULATION ) ) ;if ( ! buf ) {fpu__clear ( fpu ) ;return 0 ;}if ( ! access_ok ( VERIFY_READ , buf , size ) ) return - EACCES ;fpu__activate_curr ( fpu ) ;if ( ! static_cpu_has ( X86_FEATURE_FPU ) ) return fpregs_soft_set ( current , NULL , 0 , sizeof ( struct user_i387_ia32_struct ) , NULL , buf ) != 0 ;if ( use_xsave ( ) ) {struct _fpx_sw_bytes fx_sw_user ;if ( unlikely ( check_for_xstate ( buf_fx , buf_fx , & fx_sw_user ) ) ) {state_size = sizeof ( struct fxregs_state ) ;fx_only = 1 ;trace_x86_fpu_xstate_check_failed ( fpu ) ;state_size = fx_sw_user . xstate_size ;xfeatures = fx_sw_user . xfeatures ;}}if ( ia32_fxstate ) {struct fpu * fpu = & tsk -> thread . fpu ;struct user_i387_ia32_struct env ;int err = 0 ;fpu__drop ( fpu ) ;if ( using_compacted_format ( ) )  err = copy_user_to_xstate ( & fpu -> state . xsave , buf_fx ) ;else   err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ;if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) {","err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ;if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ;}if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) {",1409
793,"static void  swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc32 ( tif , cp0 , cc ) ;}","static int swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc32 ( tif , cp0 , cc ) ;}",1410
794,while ( c -> chunked_encoding && ! c -> chunk_size && c -> buffer_end > c -> buffer_ptr ) {,while ( c -> chunked_encoding && ! c -> chunk_size <= 0 ) {c -> chunk_size = 0 ;goto fail ;}c -> buffer_ptr ) {,1411
795,if ( c -> chunk_size == 0 )  goto fail ;,if ( c -> chunk_size == 0 ) goto fail ;,1411
796,else {c -> chunk_size -= len ;,else {av_assert0 ( len <= c -> chunk_size ) ;c -> chunk_size -= len ;,1411
797,"u16 source_node_id ;u32 specifier_id ;u32 ver ;offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ;buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ;if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) dev -> broadcast_rcv_next_ptr = 0 ;spin_unlock_irqrestore ( & dev -> lock , flags ) ;specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8  | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ;ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ;source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ;if ( specifier_id == IANA_SPECIFIER_ID &&  ( ver == RFC2734_SW_VERSION  # if IS_ENABLED ( CONFIG_IPV6 )  || ver == RFC3146_SW_VERSION  # endif  ) ) {buf_ptr += 2 ;}packet . payload_length = dev -> rcv_buffer_size ;",if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) == IANA_SPECIFIER_ID && ( ver == RFC2734_SW_VERSION # if IS_ENABLED ( CONFIG_IPV6 ) || ver == RFC3146_SW_VERSION # endif ) ) {buf_ptr += 2 ;}packet . payload_length = dev -> rcv_buffer_size ;,1412
798,else  sc = create_spnego_ctx ( ) ;if ( sc == NULL ) {,else sc = create_spnego_ctx ( 0 ) ;if ( sc == NULL ) {,1413
799,len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;if ( ! EVP_CIPHER_CTX_encrypting ( c ) )   len -= EVP_GCM_TLS_TAG_LEN ;EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;,if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ;len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) {if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ;len -= EVP_GCM_TLS_TAG_LEN ;}EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;,1414
800,"int r , len , group = 0 ;Node * qn ;Node * * tp ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term )  goto end_of_token ;switch ( tok -> type ) {","int r , len , group ;Node * qn ;Node * * tp ;unsigned int parse_depth ;group = 0 ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term ) goto end_of_token ;parse_depth = env -> parse_depth ;switch ( tok -> type ) {",1415
801,"qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper ,  r == TK_INTERVAL ) ;","parse_depth ++ ;if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , r == TK_INTERVAL ) ;",1415
802,"static int bson_validate_string ( bson * b , const unsigned char * string ,  const int length , const char check_utf8 , const char check_dot ,  const char check_dollar ) {int position = 0 ;int sequence_length = 1 ;","static int bson_validate_string ( bson * b , const unsigned char * string , const size_t length , const char check_utf8 , const char check_dot , const char check_dollar ) {size_t position = 0 ;int sequence_length = 1 ;",1416
803,"q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) ,   Min ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;","q = QueueAuthenticPixels ( image , x , y , MagickMin ( 4 , dds_info -> width - x ) , MagickMin ( 4 , dds_info -> height - y ) , exception ) ;if ( q == ( PixelPacket * ) NULL ) return MagickFalse ;",1417
804,"}SkipDXTMipmaps ( image , dds_info , 16 ) ;return MagickTrue ;","return ( }SkipDXTMipmaps ( image , dds_info , 16 , exception ) ) ;",1417
805,"if ( getCcalls ( L ) <= CSTACKERR )   luaE_freeCI ( L ) ;luaD_call ( L , func , nResults ) ;","if ( getCcalls ( L ) <= CSTACKERR ) {luaE_exitCcall ( L ) ;luaE_enterCcall ( L ) ;}luaD_call ( L , func , nResults ) ;",1418
806,"sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ;}",},1419
807,"ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , "")"" ) ) ;}ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK :  ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;","ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;atmarp_tpaddr_print ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;break ;case ARPOP_REPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ""at<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""for<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK : ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;",1420
808,"case kEmptyStream :  h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles ,  sizeof ( * h -> emptyStreamBools ) ) ;","case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ;h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , sizeof ( * h -> emptyStreamBools ) ) ;",1421
809,"h -> emptyFileBools = calloc ( empty_streams ,  sizeof ( * h -> emptyFileBools ) ) ;","if ( h -> emptyFileBools != NULL ) return ( - 1 ) ;h -> emptyFileBools = calloc ( empty_streams , sizeof ( * h -> emptyFileBools ) ) ;",1421
810,"h -> antiBools = calloc ( empty_streams ,  sizeof ( * h -> antiBools ) ) ;","if ( h -> antiBools != NULL ) return ( - 1 ) ;h -> antiBools = calloc ( empty_streams , sizeof ( * h -> antiBools ) ) ;",1421
811,if ( ( ll & 1 ) || ll < zip -> numFiles * 4 )  return ( - 1 ) ;,if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) return ( - 1 ) ;if ( zip -> entry_names != NULL ) return ( - 1 ) ;,1421
812,"h -> attrBools = calloc ( ( size_t ) zip -> numFiles ,  sizeof ( * h -> attrBools ) ) ;","if ( h -> attrBools != NULL ) return ( - 1 ) ;h -> attrBools = calloc ( ( size_t ) zip -> numFiles , sizeof ( * h -> attrBools ) ) ;",1421
813,static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx )  {if ( avctx -> bits_per_raw_sample > 8 ) {av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;return avctx -> pix_fmt ;,static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) {MpegEncContext * s = avctx -> priv_data ;if ( avctx -> bits_per_raw_sample > 8 ) {av_assert1 ( s -> studio_profile ) ;return avctx -> pix_fmt ;,1422
814,"len = file ? file -> size : 4096 ;p = realloc ( * data , len ) ;","len = file && file -> size > 0 ? file -> size : 4096 ;p = realloc ( * data , len ) ;",1423
815,"if ( data_sz <= 8 )  return VPX_CODEC_UNSUP_BITSTREAM ;if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ;si -> is_kf = 0 ;si -> w = si -> h = 0 ;{struct vp9_read_bit_buffer rb = {data , data + data_sz , 0 , NULL , NULL };const int frame_marker = vp9_rb_read_literal ( & rb , 2 ) ;const int version = vp9_rb_read_bit ( & rb ) ;( void ) vp9_rb_read_bit ( & rb ) ;if ( frame_marker != VP9_FRAME_MARKER ) return VPX_CODEC_UNSUP_BITSTREAM ;if ( version > 1 ) return VPX_CODEC_UNSUP_BITSTREAM ;if ( vp9_rb_read_bit ( & rb ) ) {return VPX_CODEC_OK ;}si -> is_kf = ! vp9_rb_read_bit ( & rb ) ;if ( si -> is_kf ) {const int sRGB = 7 ;int colorspace ;rb . bit_offset += 1 ;rb . bit_offset += 1 ;if ( vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_0 || vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_1 || vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_2 ) {return VPX_CODEC_UNSUP_BITSTREAM ;}colorspace = vp9_rb_read_literal ( & rb , 3 ) ;if ( colorspace != sRGB ) {rb . bit_offset += 1 ;if ( version == 1 ) {rb . bit_offset += 2 ;rb . bit_offset += 1 ;}}else {if ( version == 1 ) {rb . bit_offset += 1 ;}else {return VPX_CODEC_UNSUP_BITSTREAM ;}}si -> w = vp9_rb_read_literal ( & rb , 16 ) + 1 ;si -> h = vp9_rb_read_literal ( & rb , 16 ) + 1 ;}}return VPX_CODEC_OK ;","return decoder_peek_si_internal ( data , data_sz , si , NULL , NULL , NULL ) ;",1424
816,"sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) {if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) {goto beach ;}i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ;if ( i < 0 ) goto beach ;",st32 vnaux = entry -> vn_aux ;if ( vnaux < 1 ) {vstart += vnaux ;,1425
817,"vstart += entry -> vn_aux ;for ( j = 0 , isum = i + entry -> vn_aux ;","vstart += entry -> vn_aux ;for ( j = 0 , isum = i + entry -> vn_aux ;",1425
818,"if ( code )  return code ;code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ;","if ( code ) {* status = ""DECODE_PA_FOR_USER"" ;return code ;}code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ;",1426
819,"record_and_restart ( event , val , regs , nmi ) ;}","record_and_restart ( event , val , regs ) ;}",1427
820,if ( pSubSrc -> nSrc > 1 || isAgg || IsVirtual ( pSubSrc -> a [ 0 ] . pTab ) ) {return 0 ;,if ( pSubSrc -> nSrc > 1 || isAgg || IsVirtual ( pSubSrc -> a [ 0 ] . pTab ) || ( p -> selFlags & SF_Distinct ) != 0 ) {return 0 ;,1428
821,"DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ;DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ;int dst_stride = x -> e_mbd . dst . y_stride ;","DECLARE_ALIGNED ( 16 , unsigned char , best_predictor [ 16 * 4 ) ;DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff [ 16 ] ) ;int dst_stride = x -> e_mbd . dst . y_stride ;",1429
822,"vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ;}","memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ;}",1429
823,"struct pipe_buffer * buf ;int idx = i -> idx ;size_t off = i -> iov_offset , orig_sz ;orig_sz = size ;if ( size ) {if ( off )   size += off - pipe -> bufs [ idx ] . offset ;while ( 1 ) {if ( size <= buf -> len )  break ;size -= buf -> len ;idx = next_idx ( idx , pipe ) ;}buf -> len = size ;i -> idx = idx ;off = i -> iov_offset = buf -> offset + size ;}if ( off ) idx = next_idx ( idx , pipe ) ;if ( pipe -> nrbufs ) {int unused = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ;while ( idx != unused ) {pipe_buf_release ( pipe , & pipe -> bufs [ idx ] ) ;pipe -> nrbufs -- ;i -> count -= orig_sz ;}","orig_sz = size ;if ( size ) {struct pipe_buffer * buf ;size_t off = i -> iov_offset , left = size ;int idx = i -> idx ;if ( off ) left += off - pipe -> bufs [ idx ] . offset ;while ( 1 ) {if ( left <= buf -> len ) break ;left -= buf -> len ;i -> idx = idx ;off = i -> iov_offset = buf -> offset + left ;}i -> count -= size ;pipe_truncate ( i ) ;",1430
824,"PyObject * logical = NULL ;FriBidiParType base = FRIBIDI_TYPE_RTL ;const char * encoding = ""utf-8"" ;static char * kwargs [ ] =  {""logical"" , ""base_direction"" , ""encoding"" , ""clean"" , ""reordernsm"" , NULL }if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""O|isii"" , kwargs ,   & logical , & base , & encoding , & clean , & reordernsm ) )   return NULL ;if ( ! ( base == FRIBIDI_TYPE_RTL ||  base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) )  return PyErr_Format ( PyExc_ValueError , ""invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON"" , base ) ;if ( PyUnicode_Check ( logical ) )  return log2vis_unicode ( logical , base , clean , reordernsm ) ;else if ( PyString_Check ( logical ) )  return log2vis_encoded_string ( logical , encoding , base , clean , reordernsm ) ;else return PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>unicode<S2SV_blank>or<S2SV_blank>str,<S2SV_blank>not<S2SV_blank>%s"" , logical -> ob_type -> tp_name ) ;","PyUnicodeObject * logical = NULL ;FriBidiParType base = FRIBIDI_TYPE_RTL ;static char * kwargs [ ] = {""logical"" , ""base_direction"" , ""clean"" , ""reordernsm"" , NULL }if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""U|iii"" , kwargs , & logical , & base , & clean , & reordernsm ) ) {return NULL ;}if ( ! ( base == FRIBIDI_TYPE_RTL || base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) {return PyErr_Format ( PyExc_ValueError , ""invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON"" , base ) ;}return unicode_log2vis ( logical , base , clean , reordernsm ) ;",1431
825,wp -> socket_mode = 0666 ;if ( ! c ) {,wp -> socket_mode = 0660 ;if ( ! c ) {,1432
826,"i1_is_end_of_poc = 0 ;if ( ! ps_dec -> u1_first_slice_in_stream ) {i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ;if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) {}}",i1_is_end_of_poc = 1 ;}},1433
827,H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ;return OK ;,ps_dec -> u4_first_slice_in_pic = 0 ;H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ;return OK ;,1434
828,if ( g -> sect <= 0 ||   g -> head <= 0 ||  ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,if ( ( int ) g -> sect <= 0 || ( int ) g -> head <= 0 || ( int ) ( g -> sect * g -> head ) <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,1435
829,"u64 base_addr , size ;if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ;","u64 base_addr , size ;if ( get_securelevel ( ) > 0 ) return - EPERM ;if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ;",1436
830,"if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;out_drop_write :  fh_drop_write ( fh ) ;","error = fh_want_write ( fh ) ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;out_drop_lock : fh_unlock ( fh ) ;fh_drop_write ( fh ) ;",1437
831,dev -> netdev_ops = & bnep_netdev_ops ;dev -> watchdog_timeo = HZ * 2 ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & bnep_netdev_ops ;dev -> watchdog_timeo = HZ * 2 ;,1438
832,"uint32_t authResult = 0 , reasonLen = 0 ;char * reason = NULL ;",uint32_t authResult = 0 ;,1439
833,"if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return FALSE ;reasonLen = rfbClientSwap32IfLE ( reasonLen ) ;reason = malloc ( ( uint64_t ) reasonLen + 1 ) ;if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) {free ( reason ) ;",ReadReason ( client ) ;,1439
834,"}skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & error ) ;if ( error < 0 ) goto end ;m -> msg_namelen = 0 ;if ( skb ) {",if ( skb ) {,1440
835,"cJSON * cJSON_CreateIntArray ( int64_t * numbers , int count )  {for ( i = 0 ;++ i ) {n = cJSON_CreateInt ( numbers [ i ] ) ;if ( ! i )  a -> child = n ;","cJSON * cJSON_CreateIntArray ( const int * numbers , int count ) {for ( i = 0 ;+ i ) {i ++ ) {n = cJSON_CreateInt ( numbers [ i ] ) ;if ( ! n ) {cJSON_Delete ( a ) ;return 0 ;}if ( ! i ) a -> child = n ;",1441
836,f2fs_wait_discard_bios ( sbi ) ;if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) {,"f2fs_wait_discard_bios ( sbi , true ) ;if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) {",1442
837,"bitmap -> compressed = FALSE ;bitmap -> format = gdi -> dstFormat ;bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ;bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ;","UINT32 size = DstWidth * DstHeight ;bitmap -> compressed = FALSE ;bitmap -> format = gdi -> dstFormat ;if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ;size *= GetBytesPerPixel ( bitmap -> format ) ;bitmap -> length = size ;bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ;",1443
838,devc -> voc [ voice ] . panning = value ;},if ( voice < 0 || voice >= devc -> nr_voice ) return ;devc -> voc [ voice ] . panning = value ;},1444
839,"if ( server . vm_enabled && listLength ( server . io_ready_clients ) ) {listIter li ;server . vm_blocked_clients -- ;aeCreateFileEvent ( server . el , c -> fd , AE_READABLE , readQueryFromClient , c ) ;","if ( server . ds_enabled && listLength ( server . io_ready_clients ) ) {listIter li ;server . cache_blocked_clients -- ;aeCreateFileEvent ( server . el , c -> fd , AE_READABLE , readQueryFromClient , c ) ;",1445
840,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ;if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , sfar ) ;if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;",1446
841,while ( entries -- )  {,# ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_PARSEFUJI_PROCESSED ;# endif while ( entries -- ) {,1447
842,int Q = cpi -> active_worst_quality ;cpi -> mb . zbin_over_quant = 0 ;,int Q = cpi -> active_worst_quality ;if ( cpi -> force_maxqp == 1 ) {cpi -> active_worst_quality = cpi -> worst_quality ;return cpi -> worst_quality ;}cpi -> mb . zbin_over_quant = 0 ;,1448
843,f = po -> fanout ;if ( ! f )  return ;,f = po -> fanout ;if ( f ) {,1449
844,"mutex_unlock ( & fanout_mutex ) ;if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ;}","if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ;}mutex_unlock ( & fanout_mutex ) ;}",1449
845,"void vp9_predict_intra_block ( const MACROBLOCKD * xd , int block_idx , int bwl_in ,   TX_SIZE tx_size , MB_PREDICTION_MODE mode ,  const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , int aoff , int loff , int plane ) {const int bwl = bwl_in - tx_size ;const int wmask = ( 1 << bwl ) - 1 ;const int have_top = ( block_idx >> bwl ) || xd -> up_available ;const int have_left = ( block_idx & wmask ) || xd -> left_available ;const int have_right = ( ( block_idx & wmask ) != wmask ) ;assert ( bwl >= 0 ) ;build_intra_predictors ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane ) ;","void vp9_predict_intra_block ( const MACROBLOCKD * xd , int bwl_in , TX_SIZE tx_size , MB_PREDICTION_MODE mode , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , int aoff , int loff , int plane ) {const int bw = ( 1 << bwl ) - 1 ;const int have_top = ( block_idx >> bwl ) || xd -> up_available ;const int have_left = aoff || xd -> left_available ;const int have_right = ( aoff + txw ) < bw ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {build_intra_predictors_high ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane , xd -> bd ) ;return ;}# endif build_intra_predictors ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane ) ;",1450
846,"z . kind = 0 ;z . class = 0 ;# define PARSE_STRING s = parse_field ( ndo , & parse , & parselen ) ;# define PARSE_FIELD_INT ( field ) PARSE_STRING if ( ! lose ) field = strtol ( s , 0 , 16 ) ;if ( lose ) return ;if ( strncmp ( z . version , ""ZEPH"" , 4 ) ) return ;PARSE_FIELD_INT ( z . numfields ) ;PARSE_FIELD_INT ( z . kind ) ;PARSE_FIELD_STR ( z . uid ) ;PARSE_FIELD_INT ( z . port ) ;PARSE_FIELD_INT ( z . auth ) ;PARSE_FIELD_INT ( z . authlen ) ;PARSE_FIELD_STR ( z . authdata ) ;PARSE_FIELD_STR ( z . class ) ;PARSE_FIELD_STR ( z . inst ) ;PARSE_FIELD_STR ( z . opcode ) ;PARSE_FIELD_STR ( z . sender ) ;PARSE_FIELD_STR ( z . recipient ) ;PARSE_FIELD_STR ( z . format ) ;PARSE_FIELD_INT ( z . cksum ) ;PARSE_FIELD_INT ( z . multi ) ;PARSE_FIELD_STR ( z . multi_uid ) ;if ( lose ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;","int truncated = 0 ;z . kind = 0 ;z . class = 0 ;# define PARSE_STRING s = parse_field ( ndo , & parse , & parselen , & truncated ) ;if ( truncated ) goto trunc ;# define PARSE_FIELD_INT ( field ) PARSE_STRING if ( ! lose ) field = strtol ( s , 0 , 16 ) ;if ( lose ) goto trunc ;ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;return ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;return ;",1451
847,},},1451
848,"if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse )  return ( ( void * ) NULL ) ;","if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) return ( ( void * ) NULL ) ;",1452
849,"( void ) AcquireUniqueFilename ( postscript_file ) ;ps_file = fopen_utf8 ( postscript_file , ""wb"" ) ;if ( ps_file == ( FILE * ) NULL ) goto FINISH ;( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ;( void ) ReadBlob ( image , 2 * MagickPathExtent , magick ) ;( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ;while ( PS_Size -- > 0 ) {( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ;}( void ) fclose ( ps_file ) ;magic_info = GetMagicInfo ( magick , 2 * MagickPathExtent , exception ) ;if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ;if ( exception -> severity != UndefinedException ) goto FINISH_UNL ;if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ;( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MagickPathExtent ) ;FormatLocaleString ( clone_info -> filename , MagickPathExtent , ""%s"" , postscript_file ) ;","( void ) strncpy ( clone_info -> magick , magic_info -> name , MagickPathExtent ) ;FormatLocaleString ( clone_info -> filename , MagickPathExtent , ""%s"" , postscript_file ) ;",1453
850,for ( i = 0 ;i < len ;i ++ ) {if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) {szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ;j ++ ;else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;szLineConv [ j ] = szLine [ i ] ;i ++ ;szLineConv [ j ] = szLine [ i ] ;i ++ ;,"for ( i = 0 ;i < len && j < sizeof ( szLineConv ) - 1 ;i ++ , j ++ ) {if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) {if ( j + 1 < sizeof ( szLineConv ) - 1 ) {szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ;j ++ ;else break ;}else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) {if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;else {break ;}}if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;else {break ;}}if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) {szLineConv [ j ] = szLine [ i ] ;i ++ ;",1454
851,i += 1 ;continue ;szLineConv [ j ] = szLine [ i ] ;j ++ ;,break ;if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ;}if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ;else szLineConv [ j ] = szLine [ i ] ;j ++ ;,1454
852,"void rdp_read_flow_control_pdu ( wStream * s , UINT16 * type )  {UINT8 pduType ;Stream_Read_UINT8 ( s , pduType ) ;}","BOOL rdp_read_flow_control_pdu ( wStream * s , UINT16 * type ) {UINT8 pduType ;if ( ! type ) return FALSE ;if ( Stream_GetRemainingLength ( s ) < 6 ) return FALSE ;Stream_Read_UINT8 ( s , pduType ) ;return TRUE ;}",1455
853,"static const u_char *  ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep )  {if ( p [ 0 ] & 0x80 )  totlen = 4 ;else  totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ep < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ;}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ;}return p + totlen ;}","static const u_char * ep2 ) {ND_TCHECK ( p [ 0 ] ) ;if ( p [ 0 ] & 0x80 ) totlen = 4 ;else {ND_TCHECK_16BITS ( & p [ 2 ] ) ;}if ( ep2 < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , totlen - 4 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}return p + totlen ;trunc : return NULL ;}",1456
854,uchar buf [ 2 ] ;assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ;,jas_uchar buf [ 2 ] ;assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ;,1457
855,"
",args -> rmtvaluelen = args -> valuelen ;,1458
856,"}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;","}xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ;",1458
857,reset_globals ( ) ;passert ( GLOBALS_ARE_RESET ( ) ) ;},},1459
858,"while ( bin )  {numones -= 1 ;numones = CLIP3 ( numones , 0 , 16 ) ;",while ( bin && ( numones <= 16 ) ) {numones -= 1 ;,1460
859,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",1461
860,"case PIMV2_HELLO_OPTION_HOLDTIME :  unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;break ;","case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;break ;",1462
861,"case PIMV2_HELLO_OPTION_GENID :  ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ;break ;case PIMV2_HELLO_OPTION_REFRESH_CAP :  ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ;if ( * ( bp + 1 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ;}","case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ;break ;case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ;if ( * ( bp + 1 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ;}",1462
862,return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;},if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;else return NULL ;},1463
863,int64_t cur_offset = avio_tell ( pb ) ;if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ;,"int64_t cur_offset = avio_tell ( pb ) ;if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) {av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\\return AVERROR ( EINVAL ) ;}if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ;",1464
864,if ( count >= 4 ) {int retTIFFReadRawTile ;,if ( count > 4 ) {int retTIFFReadRawTile ;,1465
865,"
","{uint8_t computedHvi [ 32 ] ;uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ;uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ;uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ;memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ;memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ;zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ;free ( DHPartHelloMessageString ) ;if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) {free ( messageData ) ;return BZRTP_PARSER_ERROR_UNMATCHINGHVI ;}}",1466
866,}uint8_t checkH2 [ 32 ] ;,}uint8_t checkH2 [ 32 ] ;,1466
867,"ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;ND_TCHECK ( pim -> pim_rsv ) ;pimv2_addr_len = pim -> pim_rsv ;if ( pimv2_addr_len != 0 )  ND_PRINT ( ( ndo , "",<S2SV_blank>RFC2117-encoding"" ) ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>"" , EXTRACT_16BITS ( & pim -> pim_cksum ) ) ) ;","int pimv2_addr_len ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;if ( len < 2 ) goto trunc ;ND_TCHECK ( pim -> pim_rsv ) ;pimv2_addr_len = pim -> pim_rsv ;if ( pimv2_addr_len != 0 ) ND_PRINT ( ( ndo , "",<S2SV_blank>RFC2117-encoding"" ) ) ;if ( len < 4 ) goto trunc ;ND_TCHECK ( pim -> pim_cksum ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>"" , EXTRACT_16BITS ( & pim -> pim_cksum ) ) ) ;",1467
868,"
",bp += 4 ;len -= 4 ;,1467
869,"switch ( PIM_TYPE ( pim -> pim_typever ) ) {case PIMV2_TYPE_HELLO : {bp += 4 ;while ( bp < ep ) {ND_TCHECK2 ( bp [ 0 ] , 4 ) ;otype = EXTRACT_16BITS ( & bp [ 0 ] ) ;olen = EXTRACT_16BITS ( & bp [ 2 ] ) ;ND_TCHECK2 ( bp [ 0 ] , 4 + olen ) ;ND_PRINT ( ( ndo , ""\\\bp += 4 ;","switch ( PIM_TYPE ( pim -> pim_typever ) ) {case PIMV2_TYPE_HELLO : {while ( len > 0 ) {if ( len < 4 ) goto trunc ;ND_TCHECK2 ( bp [ 0 ] , olen ) ;",1467
870,"while ( ptr < ( bp + olen ) ) {ND_PRINT ( ( ndo , ""\\\advance = pimv2_addr_print ( ndo , ptr , pimv2_unicast , 0 ) ;if ( advance < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}","u_int plen = len ;while ( ptr < ( bp + olen ) ) {ND_PRINT ( ( ndo , ""\\\advance = pimv2_addr_print ( ndo , ptr , plen , pimv2_unicast , pimv2_addr_len , 0 ) ;if ( advance < 0 ) goto trunc ;plen -= advance ;",1467
871,"bp += olen ;}ND_TCHECK2 ( * ( bp + 4 ) , PIMV2_REGISTER_FLAG_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]\\\bp += 8 ;ip = ( const struct ip * ) bp ;switch ( IP_V ( ip ) ) {case 0 :  ND_PRINT ( ( ndo , ""IP-Null-header<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ;","bp += olen ;len -= olen ;}if ( len < 4 ) goto trunc ;ND_TCHECK2 ( * bp , PIMV2_REGISTER_FLAG_LEN ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]\\\bp += 8 ;ip = ( const struct ip * ) bp ;switch ( IP_V ( ip ) ) {case 0 : ND_PRINT ( ( ndo , ""IP-Null-header<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ;",1467
872,"case PIMV2_TYPE_REGISTER_STOP :  bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;","case PIMV2_TYPE_REGISTER_STOP : bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;",1467
873,"int i , j ;bp += 4 ;if ( bp >= ep )  break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;}if ( bp + 4 > ep )  break ;ngroup = bp [ 1 ] ;holdtime = EXTRACT_16BITS ( & bp [ 2 ] ) ;ND_PRINT ( ( ndo , ""\\\","int i , j ;bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>source="" ) ) ;",1467
874,"if ( bp >= ep )  goto jp_done ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;goto jp_done ;}bp += advance ;len -= advance ;if ( bp + 4 > ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;goto jp_done ;}njoin = EXTRACT_16BITS ( & bp [ 0 ] ) ;nprune = EXTRACT_16BITS ( & bp [ 2 ] ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>joined<S2SV_blank>sources:<S2SV_blank>%u,<S2SV_blank>pruned<S2SV_blank>sources:<S2SV_blank>%u"" , njoin , nprune ) ) ;bp += 4 ;len -= 4 ;for ( j = 0 ;j < njoin ;j ++ ) {ND_PRINT ( ( ndo , ""\\\if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;goto jp_done ;}bp += advance ;len -= advance ;}for ( j = 0 ;j < nprune ;j ++ ) {ND_PRINT ( ( ndo , ""\\\if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;goto jp_done ;}bp += advance ;len -= advance ;}}jp_done :  break ;}case PIMV2_TYPE_BOOTSTRAP : {int i , j , frpcnt ;bp += 4 ;if ( bp + sizeof ( uint16_t ) >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>tag=%x"" , EXTRACT_16BITS ( bp ) ) ) ;bp += sizeof ( uint16_t ) ;if ( bp >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>hashmlen=%d"" , bp [ 0 ] ) ) ;if ( bp + 1 >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>BSRprio=%d"" , bp [ 1 ] ) ) ;bp += 2 ;if ( bp >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>BSR="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;","if ( bp >= ep ) goto jp_done ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;",1467
875,"if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) )  < 0 ) {if ( bp >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;if ( bp + 1 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ;bp += 4 ;for ( j = 0 ;if ( ( advance = pimv2_addr_print ( ndo , bp ,  pimv2_unicast , 0 ) ) < 0 ) {if ( bp + 1 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;if ( bp + 2 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ;bp += 4 ;}ND_PRINT ( ( ndo , "")"" ) ) ;bs_done :  break ;case PIMV2_TYPE_ASSERT :  bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;if ( bp >= ep )  break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}","if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {if ( bp >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;if ( bp + 1 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ;bp += 4 ;for ( j = 0 ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {if ( bp + 1 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;if ( bp + 2 >= ep ) {ND_PRINT ( ( ndo , ""...)"" ) ) ;ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ;bp += 4 ;}ND_PRINT ( ( ndo , "")"" ) ) ;bs_done : break ;case PIMV2_TYPE_ASSERT : bp += 4 ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;if ( bp >= ep ) break ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;",1467
876,"bp += 4 ;if ( bp >= ep ) break ;if ( bp + 1 >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ;if ( bp + 3 >= ep ) break ;unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ;bp += 4 ;if ( bp >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>RP="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) )  < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}bp += advance ;ND_PRINT ( ( ndo , ""<S2SV_blank>grp="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}ND_PRINT ( ( ndo , ""<S2SV_blank>forwarder="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) {ND_PRINT ( ( ndo , ""..."" ) ) ;break ;}ND_TCHECK2 ( bp [ 0 ] , 2 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>TUNR<S2SV_blank>"" ) ) ;","bp += 4 ;if ( bp >= ep ) break ;if ( bp + 1 >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ;if ( bp + 3 >= ep ) break ;unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ;bp += 4 ;if ( bp >= ep ) break ;ND_PRINT ( ( ndo , ""<S2SV_blank>RP="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;ND_PRINT ( ( ndo , ""<S2SV_blank>grp="" ) ) ;if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ;ND_PRINT ( ( ndo , ""<S2SV_blank>forwarder="" ) ) ;if ( len < 2 ) goto trunc ;ND_TCHECK ( bp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>TUNR<S2SV_blank>"" ) ) ;",1467
877,"
",if ( pParse -> nErr ) goto multi_select_end ;,1468
878,if ( p -> selFlags & SF_UsesEphemeral ) {int i ;,if ( p -> selFlags & SF_UsesEphemeral ) {int i ;,1468
879,struct fscrypt_info * ci = inode -> i_crypt_info ;if ( ! ci ||  ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ) return fscrypt_get_crypt_info ( inode ) ;return 0 ;,"struct fscrypt_info * crypt_info ;struct fscrypt_context ctx ;struct crypto_skcipher * ctfm ;const char * cipher_str ;int keysize ;u8 * raw_key = NULL ;int res ;if ( inode -> i_crypt_info ) return 0 ;res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ;if ( res ) return res ;if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ;res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ;if ( res < 0 ) {if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ;memset ( & ctx , 0 , sizeof ( ctx ) ) ;ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ;ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ;ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ;memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ;}else if ( res != sizeof ( ctx ) ) {return - EINVAL ;}if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ;if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ;crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ;if ( ! crypt_info ) return - ENOMEM ;crypt_info -> ci_flags = ctx . flags ;crypt_info -> ci_data_mode = ctx . contents_encryption_mode ;crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ;crypt_info -> ci_ctfm = NULL ;memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ;res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ;if ( res ) goto out ;res = - ENOMEM ;raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ;if ( ! raw_key ) goto out ;res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ;if ( res && inode -> i_sb -> s_cop -> key_prefix ) {int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ;if ( res2 ) {if ( res2 == - ENOKEY ) res = - ENOKEY ;goto out ;}}else if ( res ) {goto out ;}ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ;if ( ! ctfm || IS_ERR ( ctfm ) ) {res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ;printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\\goto out ;}crypt_info -> ci_ctfm = ctfm ;crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ;crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ;res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ;if ( res ) goto out ;if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ;out : if ( res == - ENOKEY ) res = 0 ;put_crypt_info ( crypt_info ) ;kzfree ( raw_key ) ;return res ;",1469
880,"struct macroblockd_plane * pd = & xd -> plane [ plane ] ;vp9_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) ,  16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) ,  pd -> dequant , p -> zbin_extra , & p -> eobs [ block ] , scan , iscan ) ;}","# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vpx_highbd_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , & p -> eobs [ block ] , scan , iscan ) ;return ;}# endif vpx_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , & p -> eobs [ block ] , scan , iscan ) ;}",1470
881,"
",if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;},1471
882,jumpstack [ stackidx ++ ] = e ;},jumpstack [ stackidx ++ ] = e ;},1471
883,"CRM_LOG_ASSERT ( client_obj -> request_id ) ;rid = client_obj -> request_id ;crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" ,  rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}","if ( client_obj -> ipc ) {CRM_LOG_ASSERT ( client_obj -> request_id ) ;rid = client_obj -> request_id ;crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}else {crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ;}}",1472
884,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",1473
885,if ( payload_len > IPV6_MAXPLEN ) {,if ( fp && payload_len > IPV6_MAXPLEN ) {,1474
886,if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL )  fp = fp -> next ;,if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) fp = fp -> next ;,1474
887,int i ;for ( i = 0 ;,"int i ;account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ;free_uid ( pipe -> user ) ;for ( i = 0 ;",1475
888,"info = sdscatprintf ( sdsempty ( ) , ""redis_version:%s\\\\r\\\if ( server . vm_enabled ) {lockThreadedIO ( ) ;info = sdscatprintf ( info ,  ""vm_conf_max_memory:%llu\\\\r\\\","info = sdscatprintf ( sdsempty ( ) , ""redis_version:%s\\\\r\\\if ( server . ds_enabled ) {lockThreadedIO ( ) ;info = sdscatprintf ( info , ""cache_max_memory:%llu\\\\r\\\",1476
889,"p = strrchr ( context -> buffer , \\\'\\\\""\\\' ) ;p = strchr ( context -> buffer , \\\'\\\\""\\\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;","p = osStrchr ( context -> buffer , \\\'\\\\""\\\' ) ;p = strchr ( context -> buffer , \\\'\\\\""\\\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;",1477
890,"void imap_quote_string ( char * dest , size_t dlen , const char * src )  {static const char quote [ ] = ""\\\\""\\\\\\\\"" ;","void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) {const char * quote = ""`\\\\""\\\\\\\\"" ;if ( ! quote_backtick ) quote ++ ;",1478
891,"static inline void header_put_le_short ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;};}","static inline void header_put_le_short ( SF_PRIVATE * psf , int x ) {psf -> header ) - 2 ) {psf -> header . indx ++ ] = ( x >> 8 ) ;}",1479
892,"
",img -> bit_depth = 8 ;,1480
893,img -> bps = 12 ;img -> user_priv = user_priv ;,img -> bps = 12 ;img -> user_priv = user_priv ;,1480
894,s = & pit_state -> channels [ addr ] ;mutex_lock ( & pit_state -> lock ) ;,if ( addr == 3 ) return 0 ;s = & pit_state -> channels [ addr ] ;mutex_lock ( & pit_state -> lock ) ;,1481
895,"if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;","if ( ! dev_name || kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) {error = - ENOENT ;",1482
896,"int i , n_items , end_lineno , end_col_offset ;asdl_seq * items , * body ;REQ ( n , with_stmt ) ;n_items = ( NCH ( n ) - 2 ) / 2 ;items = _Py_asdl_seq_new ( n_items , c -> c_arena ) ;for ( i = 1 ;i < NCH ( n ) - 2 ;withitem_ty item = ast_for_with_item ( c , CHILD ( n , i ) ) ;if ( is_async )   return AsyncWith ( items , body , LINENO ( n0 ) , n0 -> n_col_offset ,  end_lineno , end_col_offset , c -> c_arena ) ;else  return With ( items , body , LINENO ( n ) , n -> n_col_offset ,  end_lineno , end_col_offset , c -> c_arena ) ;","int i , n_items , nch_minus_type , has_type_comment , end_lineno , end_col_offset ;asdl_seq * items , * body ;string type_comment ;REQ ( n , with_stmt ) ;has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ;nch_minus_type = NCH ( n ) - has_type_comment ;n_items = ( nch_minus_type - 2 ) / 2 ;items = _Py_asdl_seq_new ( n_items , c -> c_arena ) ;for ( i = 1 ;i < nch_minus_type - 2 ;withitem_ty item = ast_for_with_item ( c , CHILD ( n , i ) ) ;if ( has_type_comment ) {type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ;if ( ! type_comment ) return NULL ;}else type_comment = NULL ;if ( is_async ) return AsyncWith ( items , body , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else return With ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;",1483
897,"while ( * s && * s != \\\'\\\\""\\\' )  * ptmp ++ = * s ++ ;","while ( * s && ( * s != \\\'\\\\""\\\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) * ptmp ++ = * s ++ ;",1484
898,while ( isdigit ( ( unsigned char ) * s ) )  * ptmp ++ = * s ++ ;,while ( isdigit ( ( unsigned char ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) * ptmp ++ = * s ++ ;,1484
899,tlv = cp + i ;type = EXTRACT_16BITS ( tlv ) ;,if ( i + 4 > length ) return - 1 ;tlv = cp + i ;type = EXTRACT_16BITS ( tlv ) ;,1485
900,"ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ;switch ( type ) {","ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ;if ( i + 4 + optlen > length ) return - 1 ;switch ( type ) {",1485
901,"if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;","gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) {fprintf ( stderr , ""svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\\memcpy ( gr -> gr_ctx . length = 4 ;gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ;",1486
902,"s -> off = strtoll ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 )  s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ;}","s -> off = strtoull ( p , NULL , 10 ) ;if ( ( slash = strchr ( p , \'/\' ) ) && strlen ( slash ) > 0 ) s -> filesize = strtoull ( slash + 1 , NULL , 10 ) ;}",1487
903,"if ( count != ( ssize_t ) length )  ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ;","if ( count != ( ssize_t ) length ) {quantum_info = DestroyQuantumInfo ( quantum_info ) ;ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;}( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ;",1488
904,const VP9_CONFIG * oxcf = & cpi -> oxcf ;RATE_CONTROL * const rc = & cpi -> rc ;,const VP9EncoderConfig * oxcf = & cpi -> oxcf ;RATE_CONTROL * const rc = & cpi -> rc ;,1489
905,int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark *  oxcf -> optimal_buffer_level / 100 ) ;if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) {,int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark * rc -> optimal_buffer_level / 100 ) ;if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) {,1489
906,register struct enamemem * tp ;char buf [ BUFSIZE ] ;if ( tp -> e_name )   return ( tp -> e_name ) ;cp = buf ;,register struct bsnamemem * tp ;char buf [ BUFSIZE ] ;if ( tp -> bs_name ) return ( tp -> e_name ) ;cp = buf ;,1490
907,"tp -> e_name = strdup ( buf ) ;if ( tp -> e_name == NULL )  ( * ndo -> ndo_error ) ( ndo , ""le64addr_string:<S2SV_blank>strdup(buf)"" ) ;return ( tp -> e_name ) ;}","tp -> bs_name = strdup ( buf ) ;if ( tp -> bs_name == NULL ) ( * ndo -> ndo_error ) ( ndo , ""le64addr_string:<S2SV_blank>strdup(buf)"" ) ;return ( tp -> bs_name ) ;}",1490
908,"static int can_open_cached ( struct nfs4_state * state , int mode )  {switch ( mode & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) {case FMODE_READ : ret |= test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ;return ret ;}","static int can_open_cached ( struct nfs4_state * state , fmode_t mode , int open_mode ) {if ( open_mode & O_EXCL ) goto out ;switch ( mode & ( FMODE_READ | FMODE_WRITE ) ) {case FMODE_READ : ret |= test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ;out : return ret ;}",1491
909,if ( src < ( uint8_t * ) buf || src > ( uint8_t * ) buf + buf_size )  goto done ;,if ( src < ( uint8_t * ) buf || src + src_size < src || src + src_size > ( uint8_t * ) buf + buf_size ) goto done ;,1492
910,"if ( * p == FAC_CCITT_DEST_NSAP ) {memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ;","if ( l < 10 || l > 20 ) return - 1 ;if ( * p == FAC_CCITT_DEST_NSAP ) {memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ;",1493
911,"int i ;for ( i = 0 ;i < pWith -> nCte ;i ++ ) {if ( sqlite3StrICmp ( zName , pWith -> a [ i ] . zName ) == 0 ) {sqlite3ErrorMsg ( pParse , ""duplicate<S2SV_blank>WITH<S2SV_blank>table<S2SV_blank>name:<S2SV_blank>%s"" , zName ) ;}}}if ( pWith ) {int nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ;pNew = sqlite3DbRealloc ( db , pWith , nByte ) ;","sqlite3_int64 nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ;pNew = sqlite3DbRealloc ( db , pWith , nByte ) ;",1494
912,"if ( offset >= ARRAY_SIZE ( sysinfo_table ) ) {printk ( ""sysinfo(%d)"" , command ) ;goto out ;}down_read ( & uts_sem ) ;res = sysinfo_table [ offset ] ;len = strlen ( res ) + 1 ;if ( len > count )  len = count ;",if ( ( unsigned long ) len > ( unsigned long ) count ) len = count ;,1495
913,"ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ;","ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;",1496
914,"trunc :  ND_PRINT ( ( ndo , ""\\\}","trunc : ND_PRINT ( ( ndo , ""\\\}",1496
915,"cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;","nd -> last_type = LAST_BIND ;cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ;error = PTR_ERR ( cookie ) ;",1497
916,return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;},goto bail ;}goto bail ;}goto bail ;}goto bail ;}goto bail ;}goto bail ;},1498
917,},bail : free ( tmpbuf ) ;tmpbuf = NULL ;return - 1 ;},1498
918,"static void  ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ;}ptr = cp [ 2 ] - 1 ;len = 0 ;switch ( cp [ 3 ] & 0xF ) {case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ;","static int ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ( 0 ) ;}ND_TCHECK ( cp [ 2 ] ) ;ND_TCHECK ( cp [ 3 ] ) ;ptr = cp [ 2 ] - 1 ;len = 0 ;switch ( cp [ 3 ] & 0xF ) {case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ;",1499
919,"if ( ptr == len )  type = ""<S2SV_blank>^<S2SV_blank>"" ;ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ;","if ( ptr == len ) type = ""<S2SV_blank>^<S2SV_blank>"" ;ND_TCHECK2 ( cp [ len ] , hoplen ) ;ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ;return ( 0 ) ;trunc : return ( - 1 ) ;",1499
920,},},1499
921,void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec )  {,WORD32 impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) {,1500
922,ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ;ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},1500
923,ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ;ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},1500
924,},return 0 ;},1500
925,"comics_document -> selected_command = g_find_program_in_path ( ""unrar-free"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = GNAUNRAR ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}}","
",1501
926,"comics_document -> selected_command = g_find_program_in_path ( ""7z"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = P7ZIP ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}","
",1501
927,"comics_document -> selected_command = g_find_program_in_path ( ""7z"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = P7ZIP ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}}else if ( g_content_type_is_a ( mime_type , ""application/x-cbt"" ) || g_content_type_is_a ( mime_type , ""application/x-tar"" ) ) {comics_document -> selected_command = g_find_program_in_path ( ""tar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}comics_document -> selected_command = g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}","
",1501
928,"static u32 ip6_idents_hashrnd __read_mostly ;u32 id ;net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ;id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ;return htonl ( id ) ;","u32 id ;id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ;return htonl ( id ) ;",1502
929,"int mi_index = 0 ;FILE * mvs = fopen ( file , ""a"" ) ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ;int rows = cm -> mi_rows ;print_mi_data ( cm , mvs , ""Partitions:"" , offsetof ( MB_MODE_INFO , sb_type ) ) ;print_mi_data ( cm , mvs , ""Modes:"" , offsetof ( MB_MODE_INFO , mode ) ) ;print_mi_data ( cm , mvs , ""Skips:"" , offsetof ( MB_MODE_INFO , skip ) ) ;print_mi_data ( cm , mvs , ""Ref<S2SV_blank>frame:"" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ;log_frame_info ( cm , ""Vectors<S2SV_blank>"" , mvs ) ;fprintf ( mvs , ""V<S2SV_blank>"" ) ;for ( mi_col = 0 ;fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row ,  mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . col ) ;mi_index ++ ;mi_index += 8 ;}fclose ( mvs ) ;}","FILE * mvs = fopen ( file , ""a"" ) ;MODE_INFO * * mi = cm -> mi_grid_visible ;int rows = cm -> mi_rows ;print_mi_data ( cm , mvs , ""Ref<S2SV_blank>frame:"" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ;log_frame_info ( cm , ""Skips:"" , mvs ) ;fprintf ( mvs , ""V<S2SV_blank>"" ) ;for ( mi_col = 0 ;fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , mi_8x8 [ mi_index ] -> mbmi . skip ) ;mi ++ ;mi_index += 8 ;}fclose ( mvs ) ;}",1503
930,"}else if ( caught_signal ) status = caught_signal + 128 ;if ( caught_signal )  {sleep ( 2 ) ;kill ( child , SIGKILL ) ;fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\\switch ( caught_signal ) {","child = ( pid_t ) - 1 ;}else if ( caught_signal && child != ( pid_t ) - 1 ) status = caught_signal + 128 ;if ( caught_signal ) {if ( child != ( pid_t ) - 1 ) {}sleep ( 2 ) ;kill ( child , SIGKILL ) ;fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\\switch ( caught_signal ) {",1504
931,}if ( ret ) fpstate_init ( & fpu -> state ) ;,if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;}if ( ret ) fpstate_init ( & fpu -> state ) ;,1505
932,return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ;},if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ;},1506
933,"if ( level != SOL_PPPOL2TP )  return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ;if ( optlen < sizeof ( int ) ) return - EINVAL ;",if ( level != SOL_PPPOL2TP ) return - EINVAL ;if ( optlen < sizeof ( int ) ) return - EINVAL ;,1507
934,"static void write_frame_size_with_refs ( VP9_COMP * cpi ,  struct vp9_write_bit_buffer * wb ) {VP9_COMMON * const cm = & cpi -> common ;found = cm -> width == cfg -> y_crop_width &&  cm -> height == cfg -> y_crop_height ;if ( cpi -> use_svc ) {found = 0 ;vp9_wb_write_bit ( wb , found ) ;vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;}","static void write_frame_size_with_refs ( VP9_COMP * cpi , struct vpx_write_bit_buffer * wb ) {VP9_COMMON * const cm = & cpi -> common ;if ( cpi -> use_svc && ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( cpi -> svc . number_spatial_layers > 1 && cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . is_key_frame ) || ( is_two_pass_svc ( cpi ) && cpi -> svc . encode_empty_frame_state == ENCODING && cpi -> svc . layer_context [ 0 ] . frames_from_key_frame < cpi -> svc . number_temporal_layers + 1 ) ) ) {found = 0 ;else if ( cfg != NULL ) {found = cm -> width == cfg -> y_crop_width && cm -> height == cfg -> y_crop_height ;}vpx_wb_write_bit ( wb , found ) ;vpx_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;vpx_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;}",1508
935,"BUG_IF ( tree_root == NULL ) ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;","if ( tree_root == NULL ) return 0 ;fprintf ( stdout , ""<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>"" ) ;",1509
936,int err ;sock -> state = SS_UNCONNECTED ;,int err ;if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ;sock -> state = SS_UNCONNECTED ;,1510
937,"VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ;state -> vt = vt ;","VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ;if ( state == NULL ) return NULL ;state -> vt = vt ;",1511
938,"static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res )  {","static int _nfs4_do_open ( struct inode * dir , struct path * path , fmode_t fmode , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) {",1512
939,"if ( path -> dentry -> d_inode != NULL )  nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( FMODE_READ | FMODE_WRITE ) ) ;status = - ENOMEM ;opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ;if ( opendata == NULL ) goto err_put_state_owner ;","if ( path -> dentry -> d_inode != NULL ) nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , fmode ) ;status = - ENOMEM ;opendata = nfs4_opendata_alloc ( path , sp , fmode , flags , sattr ) ;if ( opendata == NULL ) goto err_put_state_owner ;",1512
940,commonlen = COMPUTESIZE ( state . num ) ;query = ( QUERYTYPE * ) palloc ( commonlen ) ;,"if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;commonlen = COMPUTESIZE ( state . num ) ;query = ( QUERYTYPE * ) palloc ( commonlen ) ;",1513
941,"while ( tmp && alen < tmp ) {ND_PRINT ( ( ndo , ""\\\","while ( tmp && alen < tmp ) {ND_TCHECK2 ( * tptr , alen ) ;ND_PRINT ( ( ndo , ""\\\",1514
942,libettercap_init ( ) ;ef_globals_alloc ( ) ;,int ret_value = 0 ;libettercap_init ( ) ;ef_globals_alloc ( ) ;,1515
943,"if ( write_output ( ) != E_SUCCESS )  FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ;","ret_value = write_output ( ) != E_SUCCESS ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ;",1515
944,"printf ( ""Boot<S2SV_blank>sector<S2SV_blank>contents:\\\if ( ! atari_format ) {char id [ 9 ] ;strncpy ( id , ( const char * ) b -> system_id , 8 ) ;id [ 8 ] = 0 ;printf ( ""System<S2SV_blank>ID<S2SV_blank>\\\\""%s\\\\""\\\}else {printf ( ""Serial<S2SV_blank>number<S2SV_blank>0x%x\\\}printf ( ""Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\\printf ( ""%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\\printf ( ""First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\printf ( ""%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\\if ( ! fs -> root_cluster ) {","printf ( ""%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\\if ( ! fs -> root_cluster ) {",1516
945,"static void update_stats ( VP9_COMP * cpi ) {VP9_COMMON * const cm = & cpi -> common ;const MACROBLOCK * const x = & cpi -> mb ;if ( ! frame_is_intra_only ( cm ) ) {const int seg_ref_active = vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id ,  SEG_LVL_REF_FRAME ) ;FRAME_COUNTS * const counts = & cm -> counts ;const int inter_block = is_inter_block ( mbmi ) ;","static void update_stats ( VP9_COMMON * cm , ThreadData * td ) {const MACROBLOCK * x = & td -> mb ;const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ;const BLOCK_SIZE bsize = mbmi -> sb_type ;if ( ! frame_is_intra_only ( cm ) ) {FRAME_COUNTS * const counts = td -> counts ;const int inter_block = is_inter_block ( mbmi ) ;const int seg_ref_active = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_REF_FRAME ) ;",1517
946,}},"if ( inter_block && ! segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) {const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ;if ( bsize >= BLOCK_8X8 ) {const PREDICTION_MODE mode = mbmi -> mode ;++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ;}else {const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ;const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ;int idx , idy ;for ( idy = 0 ;idy < 2 ;idy += num_4x4_h ) {for ( idx = 0 ;idx < 2 ;idx += num_4x4_w ) {const int j = idy * 2 + idx ;const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ;++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ;}}}}}}",1517
947,"attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;","n -> mounts += n -> pending_mounts ;n -> pending_mounts = 0 ;attach_shadowed ( mnt , parent , shadows ) ;touch_mnt_namespace ( n ) ;",1518
948,"const char * errstr ;if ( ( pw = getpwnam ( s ) ) != NULL ) {# else  sscanf ( s , ""%d"" , uid ) ;# endif  if ( errstr ) return - 1 ;return 0 ;}","# if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) const char * errstr = NULL ;# else int status ;# endif if ( ( pw = getpwnam ( s ) ) != NULL ) {if ( errstr ) return - 1 ;# else status = sscanf ( s , ""%d"" , uid ) ;if ( status != 1 ) return - 1 ;# endif return 0 ;}",1519
949,"SkipRGBMipmaps ( image , dds_info , 3 ) ;return MagickTrue ;","return ( SkipRGBMipmaps ( image , dds_info , 3 , exception ) ) ;",1520
950,"void vp9_fht8x8_sse2 ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {case DCT_DCT :  vp9_fdct8x8_sse2 ( input , output , stride ) ;break ;","void vp9_fht8x8_sse2 ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {case DCT_DCT : vpx_fdct8x8_sse2 ( input , output , stride ) ;break ;",1521
951,"
","if ( c16 -> Curves [ i ] == NULL ) {for ( j = 0 ;j < i ;j ++ ) {_cmsFree ( ContextID , c16 -> Curves [ j ] ) ;}_cmsFree ( ContextID , c16 -> Curves ) ;_cmsFree ( ContextID , c16 ) ;return NULL ;}",1522
952,"c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {","c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ;if ( nElements == 256 ) {",1522
953,"if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL &&   strchr ( topicName , '+' ) == NULL )  {","if ( osStrlen ( topicName ) == 2 && osStrchr ( topicName , '#' ) == NULL && osStrchr ( topicName , '+' ) == NULL ) {",1523
954,"len = min_t ( unsigned int , len , sizeof ( sec ) ) ;if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ;","sec . key_size = 0 ;len = min_t ( unsigned int , len , sizeof ( sec ) ) ;if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ;",1524
955,"if ( ! data )   return 0 ;memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ;","if ( ! data || len < 2 ) {return 0 ;}memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ;",1525
956,"void show_object_with_name ( FILE * out , struct object * obj ,  struct strbuf * path , const char * component )  {fputc ( \'\\\free ( name ) ;}","void show_object_with_name ( FILE * out , struct object * obj , const char * component ) {}",1526
957,"int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {","int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",1527
958,int max_bytes_matched = input_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,int max_bytes_matched ;max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,1527
959,"void vp9_rc_init ( const VP9_CONFIG * oxcf , int pass , RATE_CONTROL * rc ) {if ( pass == 0 && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) {rc -> avg_frame_qindex [ 0 ] = oxcf -> worst_allowed_q ;rc -> avg_frame_qindex [ 1 ] = oxcf -> worst_allowed_q ;rc -> avg_frame_qindex [ 2 ] = oxcf -> worst_allowed_q ;else {rc -> avg_frame_qindex [ 0 ] = ( oxcf -> worst_allowed_q +  oxcf -> best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ 1 ] = ( oxcf -> worst_allowed_q +  oxcf -> best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ 2 ] = ( oxcf -> worst_allowed_q +  oxcf -> best_allowed_q ) / 2 ;}rc -> last_q [ 0 ] = oxcf -> best_allowed_q ;rc -> last_q [ 1 ] = oxcf -> best_allowed_q ;","void vp9_rc_init ( const VP9EncoderConfig * oxcf , int pass , RATE_CONTROL * rc ) {int i ;if ( pass == 0 && oxcf -> rc_mode == VPX_CBR ) {rc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ;rc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ;rc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ 1 ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;rc -> last_q [ 0 ] = oxcf -> best_allowed_q ;rc -> last_q [ 1 ] = oxcf -> best_allowed_q ;",1528
960,char * typespec = 0 ;unsigned char doc_stack [ DOC_STACK_SIZE ] ;size_t doc_stack_pointer = 0 ;size_t array_index = 0 ;unsigned int array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ;size_t array_index_stack_pointer = 0 ;,size_t array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ;size_t array_index_stack_pointer = 0 ;,1529
961,"index_session_authenticated = SSL_SESSION_get_ex_new_index ( 0 ,  ""session<S2SV_blank>authenticated"" , NULL , NULL , NULL ) ;index_session_connect_address = SSL_SESSION_get_ex_new_index ( 0 , ""session<S2SV_blank>connect<S2SV_blank>address"" , NULL , cb_dup_addr , cb_free_addr ) ;","index_session_authenticated = SSL_SESSION_get_ex_new_index ( 0 , ""session<S2SV_blank>authenticated"" , cb_new_auth , NULL , NULL ) ;index_session_connect_address = SSL_SESSION_get_ex_new_index ( 0 , ""session<S2SV_blank>connect<S2SV_blank>address"" , NULL , cb_dup_addr , cb_free_addr ) ;",1530
962,"LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ;for ( ++ x ;","LINE_OP ( output [ x ] , inverse_db_table [ y & 255 ] ) ;for ( ++ x ;",1531
963,"LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ;}","LINE_OP ( output [ x ] , inverse_db_table [ y & 255 ] ) ;}",1531
964,"static MB_PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , vp9_reader * r ,  int ctx ) {const int mode = vp9_read_tree ( r , vp9_inter_mode_tree ,   cm -> fc . inter_mode_probs [ ctx ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . inter_mode [ ctx ] [ mode ] ;","static PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , MACROBLOCKD * xd , vpx_reader * r , int ctx ) {const int mode = vpx_read_tree ( r , vp9_inter_mode_tree , cm -> fc -> inter_mode_probs [ ctx ] ) ;FRAME_COUNTS * counts = xd -> counts ;if ( counts ) ++ counts -> inter_mode [ ctx ] [ mode ] ;",1532
965,"if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )   return - ENOMEM ;if ( info -> count < 1 ) return - EINVAL ;down_write ( & card -> controls_rwsem ) ;_kctl = snd_ctl_find_id ( card , & info -> id ) ;err = 0 ;if ( _kctl ) {if ( replace ) err = snd_ctl_remove ( card , _kctl ) ;else err = - EBUSY ;}else {if ( replace ) err = - ENOENT ;up_write ( & card -> controls_rwsem ) ;if ( err < 0 ) return err ;","if ( info -> count < 1 ) return - EINVAL ;if ( replace ) {err = snd_ctl_remove_user_ctl ( file , & info -> id ) ;if ( err ) return err ;if ( card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ;",1533
966,"static void optimize_b ( int plane , int block , BLOCK_SIZE plane_bsize ,   TX_SIZE tx_size , MACROBLOCK * mb ,  ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) {struct macroblock_plane * p = & mb -> plane [ plane ] ;struct macroblockd_plane * pd = & xd -> plane [ plane ] ;const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ;unsigned best_index [ 1025 ] [ 2 ] ;const int16_t * coeff = BLOCK_OFFSET ( mb -> plane [ plane ] . coeff , block ) ;int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;int16_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;int eob = p -> eobs [ block ] , final_eob , sz = 0 ;const int i0 = 0 ;int rc , x , next , i ;int64_t rdmult , rddiv , rd_cost0 , rd_cost1 ;int rate0 , rate1 , error0 , error1 , t0 , t1 ;int best , band , pt ;PLANE_TYPE type = pd -> plane_type ;int err_mult = plane_rd_mult [ type ] ;uint8_t token_cache [ 1024 ] ;const int16_t * dequant_ptr = pd -> dequant ;const uint8_t * const band_translate = get_band_translate ( tx_size ) ;const int16_t * scan = so -> scan ;const int16_t * nb = so -> neighbors ;assert ( ( ! type && ! plane ) || ( type && plane ) ) ;rdmult = mb -> rdmult * err_mult ;if ( ! is_inter_block ( & mb -> e_mbd . mi [ 0 ] -> mbmi ) )  rdmult = ( rdmult * 9 ) >> 4 ;rddiv = mb -> rddiv ;tokens [ eob ] [ 0 ] . rate = 0 ;tokens [ eob ] [ 0 ] . next = default_eob ;tokens [ eob ] [ 0 ] . token = EOB_TOKEN ;tokens [ eob ] [ 0 ] . qc = 0 ;* ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ;next = eob ;i ++ )  token_cache [ scan [ i ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [   qcoeff [ scan [ i ] ] ] . token ] ;for ( i = eob ;i -- > i0 ;int base_bits , d2 , dx ;rc = scan [ i ] ;x = qcoeff [ rc ] ;if ( x ) {rate1 = tokens [ next ] [ 1 ] . rate ;t0 = ( vp9_dct_value_tokens_ptr + x ) -> token ;if ( next < default_eob ) {","static int optimize_b ( MACROBLOCK * mb , int plane , int block , TX_SIZE tx_size , MACROBLOCK * mb , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) {struct macroblock_plane * const p = & mb -> plane [ plane ] ;struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ;uint8_t token_cache [ 1024 ] ;const tran_low_t * const coeff = BLOCK_OFFSET ( mb -> plane [ plane ] . coeff , block ) ;tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;const int eob = p -> eobs [ block ] ;const PLANE_TYPE type = pd -> plane_type ;int err_mult = plane_rd_mult [ type ] ;uint8_t token_cache [ 1024 ] ;const int16_t * dequant_ptr = pd -> dequant ;const uint8_t * const band_translate = get_band_translate ( tx_size ) ;const int16_t * const scan = so -> scan ;const int16_t * const nb = so -> neighbors ;int next = eob , sz = 0 ;int64_t rdmult = mb -> rdmult * plane_rd_mult [ type ] , rddiv = mb -> rddiv ;int64_t rd_cost0 , rd_cost1 ;int rate0 , rate1 , error0 , error1 ;int16_t t0 , t1 ;EXTRABIT e0 ;int best , band , pt , i , final_eob ;# if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ;# endif assert ( ( ! type && ! plane ) || ( type && plane ) ) ;if ( ! is_inter_block ( & mb -> e_mbd . mi [ 0 ] -> mbmi ) ) rdmult = ( rdmult * 9 ) >> 4 ;tokens [ eob ] [ 0 ] . rate = 0 ;tokens [ eob ] [ 1 ] = tokens [ eob ] [ 0 ] . token = EOB_TOKEN ;tokens [ eob ] [ 0 ] ;i ++ ) token_cache [ scan [ i ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ qcoeff [ scan [ i ] ] ] . token ] ;for ( i = eob ;i -- > 0 ;int base_bits , d2 , dx ;const int rc = scan [ i ] ;int x = qcoeff [ rc ] ;if ( x ) {vp9_get_token_extra ( x , & t0 , & e0 ) ;if ( next < default_eob ) {",1534
967,base_bits = * ( vp9_dct_value_cost_ptr + x ) ;dx = mul * ( dqcoeff [ rc ] - coeff [ rc ] ) ;d2 = dx * dx ;,"base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost ) ;dx = mul * ( dqcoeff [ rc ] - coeff [ rc ] ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {dx >>= xd -> bd - 8 ;}# endif d2 = dx * dx ;",1534
968,}t0 = t1 = ( vp9_dct_value_tokens_ptr + x ) -> token ;},"e0 = 0 ;}vp9_get_token_extra ( x , & t0 , & e0 ) ;t1 = t0 ;}",1534
969,base_bits = * ( vp9_dct_value_cost_ptr + x ) ;if ( shortcut ) {dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ;d2 = dx * dx ;,"base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost ) ;if ( shortcut ) {# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {dx -= ( ( dequant_ptr [ rc != 0 ] >> ( xd -> bd - 8 ) ) + sz ) ^ sz ;}else {dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ;}# else dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ;# endif d2 = dx * dx ;",1534
970,"t0 = tokens [ next ] [ 0 ] . token ;t1 = tokens [ next ] [ 1 ] . token ;if ( t0 != EOB_TOKEN ) {tokens [ next ] [ 0 ] . rate += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 1 ] [ 0 ] [ t0 ] ;tokens [ next ] [ 0 ] . token = ZERO_TOKEN ;}if ( t1 != EOB_TOKEN ) {tokens [ next ] [ 1 ] . rate += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 1 ] [ 0 ] [ t1 ] ;tokens [ next ] [ 1 ] . token = ZERO_TOKEN ;}best_index [ i ] [ 0 ] = best_index [ i ] [ 1 ] = 0 ;}}band = band_translate [ i + 1 ] ;pt = combine_entropy_contexts ( * a , * l ) ;rate0 = tokens [ next ] [ 0 ] . rate ;rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t0 ] ;rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t1 ] ;UPDATE_RD_COST ( ) ;final_eob = i0 - 1 ;vpx_memset ( qcoeff , 0 , sizeof ( * qcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ;vpx_memset ( dqcoeff , 0 , sizeof ( * dqcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ;for ( i = next ;x = tokens [ i ] [ best ] . qc ;if ( x ) {final_eob = i ;rc = scan [ i ] ;qcoeff [ rc ] = x ;* a = * l = ( final_eob > 0 ) ;}","rate0 = tokens [ next ] [ 0 ] . rate ;rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t0 ] ;rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t1 ] ;UPDATE_RD_COST ( ) ;final_eob = i0 - 1 ;vpx_memset ( qcoeff , 0 , sizeof ( * qcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ;vpx_memset ( dqcoeff , 0 , sizeof ( * dqcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ;for ( i = next ;const int x = tokens [ i ] [ best ] . qc ;const int rc = scan [ i ] ;if ( x ) {final_eob = i ;qcoeff [ rc ] = x ;return final_eob ;}",1534
971,"int vp9_decode_block_tokens ( VP9_COMMON * cm , MACROBLOCKD * xd ,   int plane , int block , BLOCK_SIZE plane_bsize ,   int x , int y , TX_SIZE tx_size , vp9_reader * r ) {struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;const int ctx = get_entropy_context ( tx_size , pd -> above_context + x , pd -> left_context + y ) ;const scan_order * so = get_scan ( xd , tx_size , pd -> plane_type , block ) ;const int eob = decode_coefs ( cm , xd , pd -> plane_type ,   BLOCK_OFFSET ( pd -> dqcoeff , block ) , tx_size ,   pd -> dequant , ctx , so -> scan , so -> neighbors , r ) ;vp9_set_contexts ( xd , pd , plane_bsize , tx_size , eob > 0 , x , y ) ;return eob ;","int vp9_decode_block_tokens ( MACROBLOCKD * xd , int plane , int block , BLOCK_SIZE plane_bsize , int x , int y , TX_SIZE tx_size , vpx_reader * r , int seg_id ) {struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;const int16_t * const dequant = pd -> seg_dequant [ seg_id ] ;const int ctx = get_entropy_context ( tx_size , pd -> above_context + x , pd -> left_context + y ) ;const int eob = decode_coefs ( cm , xd , pd -> plane_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , tx_size , pd -> dequant , ctx , sc -> scan , so -> neighbors , r ) ;dec_set_contexts ( xd , pd , plane_bsize , tx_size , eob > 0 , x , y ) ;return eob ;",1535
972,free_called += 1 ;free ( ptr ) ;,free_called = 1 ;free ( ptr ) ;,1536
973,goto chpwfail ;},goto bailout ;},1537
974,goto chpwfail ;}goto chpwfail ;}goto chpwfail ;},goto bailout ;}goto bailout ;}goto bailout ;},1537
975,"goto err_free_mem ;}buf [ BUF_SIZE - 1 ] = \'\\\\0\' ;dev_info ( s -> dev , ""Board<S2SV_blank>ID:<S2SV_blank>%02x\\\dev_info ( s -> dev , ""Firmware<S2SV_blank>version:<S2SV_blank>%s\\\s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ;s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ;s -> vb_queue . drv_priv = s ;s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ;s -> vb_queue . ops = & airspy_vb2_ops ;s -> vb_queue . mem_ops = & vb2_vmalloc_memops ;s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ;ret = vb2_queue_init ( & s -> vb_queue ) ;if ( ret ) {dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\\goto err_free_mem ;}s -> vdev = airspy_template ;s -> vdev . queue = & s -> vb_queue ;s -> vdev . queue -> lock = & s -> vb_queue_lock ;video_set_drvdata ( & s -> vdev , s ) ;s -> v4l2_dev . release = airspy_video_release ;ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ;if ( ret ) {dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\\goto err_free_mem ;}v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ;s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ;s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ;v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ;s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ;s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ;v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ;s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ;if ( s -> hdl . error ) {ret = s -> hdl . error ;dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\\v4l2_ctrl_handler_setup ( & s -> hdl ) ;s -> v4l2_dev . ctrl_handler = & s -> hdl ;s -> vdev . v4l2_dev = & s -> v4l2_dev ;s -> vdev . lock = & s -> v4l2_lock ;ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ;if ( ret ) {dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\\goto err_unregister_v4l2_dev ;}err_unregister_v4l2_dev :  v4l2_device_unregister ( & s -> v4l2_dev ) ;",err_unregister_v4l2_dev : v4l2_device_unregister ( & s -> v4l2_dev ) ;,1538
976,"if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;status = AcquireImageColormap ( image , image -> colors , exception ) ;if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT )  max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;else  max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ;","if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ;",1539
977,# endif  # if HAVA_LZMA_H && HAVE_LIBLZMA  if ( zip -> zipx_lzma_valid ) {,# endif # if HAVE_LZMA_H && HAVE_LIBLZMA if ( zip -> zipx_lzma_valid ) {,1540
978,"mcryptd_check_internal ( tb , & type , & mask ) ;halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ;","if ( ! mcryptd_check_internal ( tb , & type , & mask ) ) return - EINVAL ;halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ;",1541
979,"static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up )  {","static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , struct tee_ta_param * p , struct utee_params * up ) {",1542
980,"switch ( TEE_PARAM_TYPE_GET ( types , n ) ) {case TEE_PARAM_TYPE_MEMREF_INPUT :  case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : p -> u [ n ] . mem . mobj = & mobj_virt ;break ;case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ;}}","uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ;switch ( TEE_PARAM_TYPE_GET ( types , n ) ) {case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ;case TEE_PARAM_TYPE_MEMREF_INPUT : p -> u [ n ] . mem . mobj = & mobj_virt ;if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ;break ;case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ;}return TEE_SUCCESS ;}",1542
981,"mcryptd_check_internal ( tb , & type , & mask ) ;halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ;","if ( ! mcryptd_check_internal ( tb , & type , & mask ) ) return - EINVAL ;halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ;",1543
982,"void fdct8_sse2 ( __m128i * in ) {const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;","static void fdct8_sse2 ( __m128i * in ) {const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;",1544
983,"if ( output )   strcpy ( output , ( const char * ) output_u8 ) ;free ( output_u8 ) ;","size_t len = strlen ( ( char * ) output_u8 ) ;if ( len > 63 ) {free ( output_u8 ) ;return IDN2_TOO_BIG_DOMAIN ;}if ( output ) strcpy ( output , ( char * ) output_u8 ) ;free ( output_u8 ) ;",1545
984,if ( ! unconditional ( & e -> ip ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,1546
985,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;if ( error == 0 )  acl = NULL ;}","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",1547
986,"if ( key_is_instantiated ( keyring ) ) {if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , "":<S2SV_blank>%lu"" , keyring -> keys . nr_leaves_on_tree ) ;","if ( key_is_positive ( keyring ) ) {if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , "":<S2SV_blank>%lu"" , keyring -> keys . nr_leaves_on_tree ) ;",1548
987,"int isopen ;char * s ;size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ;poly = ( POLYGON * ) palloc0 ( size ) ;","int base_size ;int isopen ;char * s ;base_size = sizeof ( poly -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) ;poly = ( POLYGON * ) palloc0 ( size ) ;",1549
988,"void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride )  {nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ;if ( context -> ChromaSubsamplingLevel ) {nsc_encode_subsampling ( context ) ;}","BOOL nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) {if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ;if ( ! nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ) return FALSE ;if ( context -> ChromaSubsamplingLevel ) {if ( ! nsc_encode_subsampling ( context ) ) return FALSE ;}return TRUE ;",1550
989,* ( * fill ) ++ = suffix [ code ] ;firstchar = oldcode = code ;,"if ( code >= clear ) {fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\\return 0 ;}* ( * fill ) ++ = suffix [ code ] ;firstchar = oldcode = code ;",1551
990,"zip_error_set ( error , ZIP_ER_INTERNAL , 0 ) ;if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;}","
",1552
991,if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;,if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;,1552
992,char added ;},},1553
993,"separator = strchr ( context -> buffer , \':\' ) ;if ( separator ) {","separator = osStrchr ( context -> buffer , \':\' ) ;if ( separator ) {",1554
994,"if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) {return MSPACK_ERR_SEEK ;}}num_chunks = chm -> last_pmgl - x + 1 ;if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) {return MSPACK_ERR_NOMEMORY ;errors = 0 ;while ( num_chunks -- ) {if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) {sys -> free ( chunk ) ;return MSPACK_ERR_READ ;if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ;if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) {sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small"" ) ;if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) {sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ;}p = & chunk [ pmgl_Entries ] ;end = & chunk [ chm -> chunk_size - 2 ] ;num_entries = EndGetI16 ( end ) ;while ( num_entries -- ) {READ_ENCINT ( name_len ) ;if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ;name = p ;p += name_len ;READ_ENCINT ( section ) ;READ_ENCINT ( offset ) ;READ_ENCINT ( length ) ;if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ;if ( ( offset == 0 ) && ( length == 0 ) ) {if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == \'/\' ) ) continue ;}if ( section > 1 ) {sys -> message ( fh , ""invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\\\'%u\\\'."" , section ) ;continue ;}if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) {sys -> free ( chunk ) ;return MSPACK_ERR_NOMEMORY ;}fi -> next = NULL ;fi -> filename = ( char * ) & fi [ 1 ] ;fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ;fi -> offset = offset ;fi -> length = length ;sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ;fi -> filename [ name_len ] = \'\\\\0\' ;if ( name [ 0 ] == \':\' && name [ 1 ] == \':\' ) {if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) {if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . content = fi ;}else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {chm -> sec1 . control = fi ;}else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . spaninfo = fi ;}}}","if ( name_len == 40 && memcmp ( name , content_name , 40 ) == 0 ) {if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . content = fi ;else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) {chm -> sec1 . control = fi ;else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) {chm -> sec1 . spaninfo = fi ;}}",1555
995,"void generate_filename ( const char * pattern , char * out , size_t q_len ,  unsigned int d_w , unsigned int d_h , unsigned int frame_in ) {","static void generate_filename ( const char * pattern , char * out , size_t q_len , unsigned int d_w , unsigned int d_h , unsigned int frame_in ) {",1556
996,}pat_len = strlen ( q ) ;,break ;}pat_len = strlen ( q ) ;,1556
997,"if ( args -> skip )  return ;if ( ! is_inter_block ( mbmi ) )   vp9_encode_block_intra ( x , plane , block , plane_bsize , tx_size , & mbmi -> skip ) ;else vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;dist_block ( plane , block , tx_size , args ) ;rate_block ( plane , block , plane_bsize , tx_size , args ) ;rd1 = RDCOST ( x -> rdmult , x -> rddiv , args -> rate , args -> dist ) ;rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , args -> sse ) ;rd = MIN ( rd1 , rd2 ) ;args -> this_rate += args -> rate ;args -> this_dist += args -> dist ;args -> this_sse += args -> sse ;args -> this_rd += rd ;args -> skip = 1 ;return ;}","int rate ;int64_t dist ;int64_t sse ;if ( args -> exit_early ) return ;if ( ! is_inter_block ( mbmi ) ) {struct encode_b_args arg = {x , NULL , & mbmi -> skip };vp9_encode_block_intra ( plane , block , plane_bsize , tx_size , & arg ) ;dist_block ( x , plane , block , tx_size , & dist , & sse ) ;}else if ( max_txsize_lookup [ plane_bsize ] == tx_size ) {if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_NONE ) {vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;dist_block ( x , plane , block , tx_size , & dist , & sse ) ;}else if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_AC_ONLY ) {tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ plane ] . coeff , block ) ;tran_low_t * const dqcoeff = BLOCK_OFFSET ( xd -> plane [ plane ] . dqcoeff , block ) ;vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ;sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ;dist = sse ;if ( x -> plane [ plane ] . eobs [ block ] ) {const int64_t orig_sse = ( int64_t ) coeff [ 0 ] * coeff [ 0 ] ;const int64_t resd_sse = coeff [ 0 ] - dqcoeff [ 0 ] ;int64_t dc_correct = orig_sse - resd_sse * resd_sse ;# if CONFIG_VP9_HIGHBITDEPTH dc_correct >>= ( ( xd -> bd - 8 ) * 2 ) ;# endif if ( tx_size != TX_32X32 ) dc_correct >>= 2 ;dist = MAX ( 0 , sse - dc_correct ) ;}}else {x -> plane [ plane ] . eobs [ block ] = 0 ;sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ;dist = sse ;}}else {vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;dist_block ( x , plane , block , tx_size , & dist , & sse ) ;}rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ;if ( args -> this_rd + rd > args -> best_rd ) {args -> exit_early = 1 ;return ;}rate = rate_block ( plane , block , plane_bsize , tx_size , args ) ;rd1 = RDCOST ( x -> rdmult , x -> rddiv , args -> rate , args -> dist ) ;rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , sse ) ;rd = MIN ( rd1 , rd2 ) ;args -> this_rate += rate ;args -> this_dist += args -> dist ;args -> this_sse += sse ;args -> this_rd += rd ;args -> exit_early = 1 ;return ;}args -> skippable &= ! x -> plane [ plane ] . eobs [ block ] ;",1557
998,"if ( layer_info == ( LayerInfo * ) NULL ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed"" ) ;ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;}( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ;for ( i = 0 ;i < number_layers ;i ++ ) {ssize_t x , y ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g"" , ( double ) i + 1 ) ;layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ;layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ;y = ReadBlobSignedLong ( image ) ;x = ReadBlobSignedLong ( image ) ;layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ;layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ;layer_info [ i ] . channels = ReadBlobShort ( image ) ;if ( layer_info [ i ] . channels > MaxPSDChannels ) {layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""MaximumChannelsExceeded"" , image -> filename ) ;}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g"" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ;for ( j = 0 ;j < ( ssize_t ) layer_info [ i ] . channels ;j ++ ) {layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ;layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g"" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ;}count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ;ReversePSDString ( image , type , 4 ) ;if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM"" , type ) ;layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""ImproperImageHeader"" , image -> filename ) ;}count = ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ;ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ;layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s"" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? ""true"" : ""false"" , layer_info [ i ] . flags , layer_info [ i ] . visible ? ""true"" : ""false"" ) ;( void ) ReadBlobByte ( image ) ;size = ReadBlobLong ( image ) ;if ( size != 0 ) {MagickSizeType combined_length , length ;if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info"" ) ;length = ReadBlobLong ( image ) ;combined_length = length + 4 ;if ( length != 0 ) {layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ;layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ;layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ;layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ;layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ;layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ;if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) {layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ;layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ;}if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g"" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ;if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) {","if ( DiscardBlobBytes ( image , length ) == MagickFalse ) {",1558
999,"for ( j = 0 ;j += 8 )  {ThrowBinaryException ( CorruptImageError ,  ""InsufficientImageDataInFile"" , image -> filename ) ;}","for ( j = 0 ;j += 8 ) {ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ;}",1558
1000,"u8 * gb_cur , * version_tlv , version , version_length ;u8 * lto_tlv , lto_length ;u8 * wks_tlv , wks_length ;u8 * miux_tlv , miux_length ;gb_len += version_length ;lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ;gb_len += lto_length ;pr_debug ( ""Local<S2SV_blank>wks<S2SV_blank>0x%lx\\\gb_len += wks_length ;miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 ,  & miux_length ) ;gb_len += miux_length ;","u8 * gb_cur , version , version_length ;u8 lto_length , wks_length , miux_length ;u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL ;if ( ! version_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += version_length ;lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ;if ( ! lto_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += lto_length ;pr_debug ( ""Local<S2SV_blank>wks<S2SV_blank>0x%lx\\\if ( ! wks_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += wks_length ;miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 , & miux_length ) ;if ( ! miux_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += miux_length ;",1559
1001,return 0 ;},if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;return 0 ;},1560
1002,"mrb_value value ;fiber_check_cfunc ( mrb , c ) ;if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>transferred<S2SV_blank>fiber"" ) ;}if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""double<S2SV_blank>resume<S2SV_blank>(fib)"" ) ;}if ( c -> status == MRB_FIBER_TERMINATED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>dead<S2SV_blank>fiber"" ) ;}mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ;c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ;if ( c -> status == MRB_FIBER_CREATED ) {mrb_value * b , * e ;if ( len >= c -> stend - c -> stack ) {mrb_raise ( mrb , E_FIBER_ERROR , ""too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>to<S2SV_blank>fiber"" ) ;}","enum mrb_fiber_state status ;mrb_value value ;fiber_check_cfunc ( mrb , c ) ;status = c -> status ;if ( resume && status == MRB_FIBER_TRANSFERRED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>transferred<S2SV_blank>fiber"" ) ;}if ( status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""double<S2SV_blank>resume<S2SV_blank>(fib)"" ) ;}if ( status == MRB_FIBER_TERMINATED ) {mrb_raise ( mrb , E_FIBER_ERROR , ""resuming<S2SV_blank>dead<S2SV_blank>fiber"" ) ;}old_c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ;c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ;fiber_switch_context ( mrb , c ) ;if ( status == MRB_FIBER_CREATED ) {mrb_value * b , * e ;mrb_stack_extend ( mrb , len + 2 ) ;",1561
1003,"fiber_switch_context ( mrb , c ) ;if ( vmexec ) {",if ( vmexec ) {,1561
1004,uint_t i ;DhcpOption * option ;if ( length < sizeof ( DhcpMessage ) )   return NULL ;length -= sizeof ( DhcpMessage ) ;if ( option -> code == DHCP_OPT_PAD )  continue ;if ( option -> code == DHCP_OPT_END )  break ;if ( ( i + 1 ) >= length || ( i + 1 + option -> length ) >= length )  break ;return NULL ;},size_t i ;DhcpOption * option ;if ( length >= sizeof ( DhcpMessage ) ) return NULL ;length -= sizeof ( DhcpMessage ) ;if ( option -> code == DHCP_OPT_PAD ) {}else if ( option -> code == DHCP_OPT_END ) {break ;}else {if ( ( i + sizeof ( DhcpOption ) + option -> length ) >= length ) break ;}}return NULL ;},1562
1005,"ipv6_select_ident ( fptr ) ;segs = skb_segment ( skb , features ) ;","ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ;segs = skb_segment ( skb , features ) ;",1563
1006,"rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ;rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ;rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ;","rb_define_singleton_method ( klass , ""read_memory"" , read_memory , - 1 ) ;rb_define_singleton_method ( klass , ""from_document"" , from_document , - 1 ) ;rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ;",1564
1007,"status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else if ( image -> storage_class == PseudoClass ) for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}else {number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ;SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ;if ( image -> colors != 0 ) {ssize_t index ;index = ( ssize_t ) GetPixelRed ( image , q ) ;SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red ) , q ) ;index = ( ssize_t ) GetPixelGreen ( image , q ) ;SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green ) , q ) ;index = ( ssize_t ) GetPixelBlue ( image , q ) ;SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue ) , q ) ;}SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ;p ++ ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;count = ReadBlob ( image , 1 , & viff_info . identifier ) ;if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) {AcquireNextImage ( image_info , image , exception ) ;if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;}",status = MagickFalse ;,1565
1008,# define MAXLINELEN 80  int i ;int j ;,# define MAXLINELEN 80 jas_matind_t i ;jas_matind_t j ;,1566
1009,"static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len ,  struct iovec * iovec )  {return 0 ;}","static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , struct iovec * iovec , struct iov_iter * iter ) {if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ;iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;return 0 ;}",1567
1010,if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) )  return ERR_PTR ( - EINVAL ) ;,if ( ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ;if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ;,1568
1011,void ntlm_print_negotiate_flags ( UINT32 flags )  {,static void ntlm_print_negotiate_flags ( UINT32 flags ) {,1569
1012,"new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;","new_fname = safe_calloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;",1570
1013,"# line 496 ""ext/standard/var_unserializer.c""  {","# line 501 ""ext/standard/var_unserializer.c"" {",1571
1014,"yy3 :  # line 861 ""ext/standard/var_unserializer.re""  {# line 558 ""ext/standard/var_unserializer.c""  yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;","yy3 : # line 875 ""ext/standard/var_unserializer.re"" {# line 563 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;",1571
1015,"# line 855 ""ext/standard/var_unserializer.re""  {# line 607 ""ext/standard/var_unserializer.c""  yy16 : yych = * ++ YYCURSOR ;","# line 869 ""ext/standard/var_unserializer.re"" {# line 612 ""ext/standard/var_unserializer.c"" yy16 : yych = * ++ YYCURSOR ;",1571
1016,"# line 708 ""ext/standard/var_unserializer.re""  {","# line 717 ""ext/standard/var_unserializer.re"" {",1571
1017,"
",if ( elements < 0 ) {efree ( class_name ) ;return 0 ;},1571
1018,"if ( incomplete_class ) {php_store_class_name ( * rval , class_name , len2 ) ;# line 785 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;","if ( incomplete_class ) {php_store_class_name ( * rval , class_name , len2 ) ;# line 795 ""ext/standard/var_unserializer.c"" yy25 : yych = * ++ YYCURSOR ;",1571
1019,"# line 699 ""ext/standard/var_unserializer.re""  {return object_common2 ( UNSERIALIZE_PASSTHRU ,   object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ;}# line 819 ""ext/standard/var_unserializer.c""  yy32 : yych = * ++ YYCURSOR ;","# line 704 ""ext/standard/var_unserializer.re"" {long elements ;elements = object_common1 ( UNSERIALIZE_PASSTHRU , elements ) ;}# line 819 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;",1571
1020,"# line 678 ""ext/standard/var_unserializer.re""  {","# line 683 ""ext/standard/var_unserializer.re"" {",1571
1021,"# line 861 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;","# line 875 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;",1571
1022,"# line 643 ""ext/standard/var_unserializer.re""  {","# line 648 ""ext/standard/var_unserializer.re"" {",1571
1023,"# line 917 ""ext/standard/var_unserializer.c""  yy46 : yych = * ++ YYCURSOR ;","# line 931 ""ext/standard/var_unserializer.c"" yy46 : yych = * ++ YYCURSOR ;",1571
1024,"# line 610 ""ext/standard/var_unserializer.re""  {","# line 615 ""ext/standard/var_unserializer.re"" {",1571
1025,"# line 971 ""ext/standard/var_unserializer.c""  yy53 : yych = * ++ YYCURSOR ;","# line 985 ""ext/standard/var_unserializer.c"" yy53 : yych = * ++ YYCURSOR ;",1571
1026,"# line 600 ""ext/standard/var_unserializer.re""  {# line 1069 ""ext/standard/var_unserializer.c""  yy65 : yych = * ++ YYCURSOR ;","# line 605 ""ext/standard/var_unserializer.re"" {# line 1083 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;",1571
1027,"# line 585 ""ext/standard/var_unserializer.re""  {","# line 590 ""ext/standard/var_unserializer.re"" {",1571
1028,"# line 1143 ""ext/standard/var_unserializer.c""  yy76 : yych = * ++ YYCURSOR ;","# line 1157 ""ext/standard/var_unserializer.c"" yy76 : yych = * ++ YYCURSOR ;",1571
1029,"# line 558 ""ext/standard/var_unserializer.re""  {","# line 563 ""ext/standard/var_unserializer.re"" {",1571
1030,"# line 1197 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;# line 551 ""ext/standard/var_unserializer.re""  {# line 1212 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 544 ""ext/standard/var_unserializer.re""  {# line 1222 ""ext/standard/var_unserializer.c""  yy89 : yych = * ++ YYCURSOR ;","# line 1211 ""ext/standard/var_unserializer.c"" yy83 : yych = * ++ YYCURSOR ;# line 556 ""ext/standard/var_unserializer.re"" {# line 1226 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 549 ""ext/standard/var_unserializer.re"" {# line 1236 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;",1571
1031,"# line 521 ""ext/standard/var_unserializer.re""  {","# line 526 ""ext/standard/var_unserializer.re"" {",1571
1032,"# line 1268 ""ext/standard/var_unserializer.c""  yy95 : yych = * ++ YYCURSOR ;","# line 1282 ""ext/standard/var_unserializer.c"" yy95 : yych = * ++ YYCURSOR ;",1571
1033,"# line 500 ""ext/standard/var_unserializer.re""  {","# line 505 ""ext/standard/var_unserializer.re"" {",1571
1034,"# line 1312 ""ext/standard/var_unserializer.c""  }# line 863 ""ext/standard/var_unserializer.re""  return 0 ;","# line 1326 ""ext/standard/var_unserializer.c"" }# line 863 ""ext/standard/var_unserializer.re"" return 0 ;",1571
1035,"if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) )  {","if ( TEMP_FAILURE_RETRY ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) ) == sizeof ( cmd ) ) {",1572
1036,* ( * fill ) ++ = suffix [ code ] ;firstchar = oldcode = code ;,"if ( code >= clear ) {fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\\return 0 ;}* ( * fill ) ++ = suffix [ code ] ;firstchar = oldcode = code ;",1573
1037,"msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ;","skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ;",1574
1038,p -> exit_signal = - 1 ;p -> group_leader = current -> group_leader ;if ( clone_flags & CLONE_PARENT )  p -> exit_signal = current -> group_leader -> exit_signal ;else p -> exit_signal = args -> exit_signal ;,p -> group_leader = current -> group_leader ;,1575
1039,}p -> real_parent = current ;}klp_copy_process ( p ) ;,if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ;else p -> exit_signal = current -> group_leader -> exit_signal ;}p -> real_parent = current ;p -> exit_signal = args -> exit_signal ;}klp_copy_process ( p ) ;,1575
1040,"static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len ,  const u_char * ep , uint32_t phase , uint32_t doi0 _U_ ,   uint32_t proto0 _U_ , int depth )  {","static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) {",1576
1041,"ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ;switch ( ntohs ( n . type ) ) {size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ;while ( cp < ep && cp < ep2 ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;break ;}case IPSECDOI_NTYPE_REPLAY_STATUS :  ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;break ;case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ;default :  isakmp_print ( ndo , cp ,  item_len - sizeof ( * p ) - n . spi_size , NULL ) ;ND_PRINT ( ( ndo , "")"" ) ) ;}","switch ( ntohs ( n . type ) ) {size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) ) ;ND_PRINT ( ( ndo , "")"" ) ) ;break ;}case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ;ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;break ;case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ;break ;default : if ( ndo -> ndo_vflag > 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ;}else {if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ;ND_PRINT ( ( ndo , "")"" ) ) ;}",1576
1042,"iframe -> iv = nghttp2_mem_malloc ( mem , sizeof ( nghttp2_settings_entry ) *  iframe -> max_niv ) ;","if ( iframe -> max_niv - 1 > session -> max_settings ) {rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_ENHANCE_YOUR_CALM , ""SETTINGS:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>setting<S2SV_blank>entries"" ) ;if ( nghttp2_is_fatal ( rv ) ) {return rv ;}return ( ssize_t ) inlen ;}iframe -> iv = nghttp2_mem_malloc ( mem , sizeof ( nghttp2_settings_entry ) * iframe -> max_niv ) ;",1577
1043,"if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ;if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) {code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ;if ( code ) return code ;}tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ;code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ;if ( code ) goto error_return ;lock_flags = XFS_ILOCK_EXCL ;xfs_ilock ( ip , lock_flags ) ;if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) {",if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! capable_wrt_inode_uidgid ( VFS_I ( ip ) ) ) {,1578
1044,"if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) &&  ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) )  ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;","if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;",1578
1045,"update_open_stateid ( state , & data -> o_res . stateid , NULL ,  data -> o_arg . open_flags ) ;iput ( inode ) ;","update_open_stateid ( state , & data -> o_res . stateid , NULL , data -> o_arg . fmode ) ;iput ( inode ) ;",1579
1046,"# define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\\","# define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\\",1580
1047,"}# define EXIFMultipleFractions ( size , format , arg1 , arg2 ) {","\\\\\# define EXIFMultipleFractions ( size , format , arg1 , arg2 ) \\\\\",1580
1048,}typedef struct _DirectoryInfo {,\\\\\typedef struct _DirectoryInfo {,1580
1049,"
",if ( q > ( exif + length - 12 ) ) break ;,1580
1050,"
",if ( components < 0 ) break ;,1580
1051,"if ( GetValueFromSplayTree ( exif_resources , q ) == q )  break ;components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;number_bytes = ( size_t ) components * tag_bytes [ format ] ;","if ( GetValueFromSplayTree ( exif_resources , q ) == q ) break ;components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ;number_bytes = ( size_t ) components * tag_bytes [ format ] ;",1580
1052,if ( ! static_key_enabled ( work -> key ) )  static_key_slow_inc ( work -> key ) ;,BUG_ON ( ! static_key_enabled ( work -> key ) ) ;static_key_slow_dec ( work -> key ) ;,1581
1053,goto errout_locked ;},goto errout_free ;},1582
1054,kfree ( family -> attrbuf ) ;errout_locked : genl_unlock_all ( ) ;,errout_free : kfree ( family -> attrbuf ) ;errout_locked : genl_unlock_all ( ) ;,1582
1055,"memcpy ( & bss_cfg -> wmm_info , wmm_ie +   sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;","if ( * ( wmm_ie + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ;memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;",1583
1056,"separator = strchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;","separator = osStrchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;",1584
1057,* ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,* ( buf + insertpos ) = _x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,1585
1058,"if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else  ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;goto out ;if ( flags == EXT4_GET_BLOCKS_CONVERT ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;","if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) {ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ;else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ;if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;goto out ;if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) {ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ;",1586
1059,"size = urb -> transfer_buffer_length ;if ( usb_pipeout ( urb -> pipe ) ) return 0 ;size = urb -> actual_length ;if ( ! ( size > 0 ) ) return 0 ;ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ;if ( ret != size ) {}usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return ret ;}","if ( size > urb -> transfer_buffer_length ) {if ( ud -> side == USBIP_STUB ) {usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ;return 0 ;usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return - EPIPE ;}ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ;if ( ret != size ) {}usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ;return ret ;}",1587
1060,net -> dev_base_seq = 1 ;net -> user_ns = user_ns ;,"get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;net -> dev_base_seq = 1 ;net -> user_ns = user_ns ;",1588
1061,"strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ;strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name ,  sizeof ( ualg -> cru_driver_name ) ) ;strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) ,  sizeof ( ualg -> cru_module_name ) ) ;","strncpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ;strncpy ( ualg -> cru_driver_name , alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ) ;strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ;",1589
1062,"strlcpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;","strncpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;",1589
1063,"cJSON * c ;ep = 0 ;if ( ! ( c = cJSON_New_Item ( ) ) ) return 0 ;if ( ! parse_value ( c , skip ( value ) ) ) {cJSON_Delete ( c ) ;return 0 ;}return c ;","return cJSON_ParseWithOpts ( value , 0 , 0 ) ;",1590
1064,"
",if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) {return ( - 1 ) ;},1591
1065,unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ;},unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ;},1591
1066,BUG_ON ( direction != ITER_PIPE ) ;i -> type = direction ;,BUG_ON ( direction != ITER_PIPE ) ;WARN_ON ( pipe -> nrbufs == pipe -> buffers ) ;i -> type = direction ;,1592
1067,mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ;mnt -> mnt . mnt_flags = mnt_flags ;,mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ;mnt -> mnt . mnt_flags = mnt_flags ;,1593
1068,"static int fsmVerify ( const char * path , rpmfi fi )  {","static int fsmVerify ( const char * path , rpmfi fi , const struct stat * fsb ) {",1594
1069,"
",uid_t luid = dsb . st_uid ;,1594
1070,"if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;rc = fsmStat ( path , 0 , & dsb ) ;if ( rc == RPMERR_ENOENT ) rc = 0 ;if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;}","if ( S_ISDIR ( dsb . st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) return 0 ;rc = fsmStat ( path , 0 , & dsb ) ;if ( rc == RPMERR_ENOENT ) rc = 0 ;if ( S_ISDIR ( dsb . st_mode ) ) return 0 ;}",1594
1071,"# endif _end :  snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ;}","# endif _end : kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ;snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;}",1595
1072,"for ( plane = 0 ;in -> data [ plane ] && plane < 4 ;plane ++ )  hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;for ( plane = 0 ;in -> data [ plane ] && plane < 4 ;plane ++ )  vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;","for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;plane ++ ) hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;plane ++ ) vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;",1596
1073,"bool valid_handle ;BUG_ON ( client != handle -> client ) ;valid_handle = ion_handle_validate ( client , handle ) ;if ( ! valid_handle ) {return ;}mutex_unlock ( & client -> lock ) ;ion_handle_put ( handle ) ;","BUG_ON ( client != handle -> client ) ;ion_free_nolock ( client , handle ) ;if ( ! valid_handle ) {",1597
1074,WORD16 i2_level_arr [ 16 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,WORD16 ai2_level_arr [ 19 ] ;WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,1598
1075,"print_int ( ""coded_picture_number"" , frame -> coded_picture_number ) ;print_int ( ""display_picture_number"" , frame -> display_picture_number ) ;print_int ( ""interlaced_frame"" , frame -> interlaced_frame ) ;print_int ( ""top_field_first"" , frame -> top_field_first ) ;print_int ( ""repeat_pict"" , frame -> repeat_pict ) ;if ( frame -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ;else print_str_opt ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ;if ( frame -> colorspace != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ;else print_str_opt ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ;if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED )  print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ;","print_primaries ( w , frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ;",1599
1076,"if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\\","if ( ! s -> cdx [ i ] || s -> cdx [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\\",1600
1077,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;",1601
1078,else  follow_dotdot ( nd ) ;},else return follow_dotdot ( nd ) ;},1602
1079,"dname = malloc ( strlen ( name ) + 16 ) ;sprintf ( dname , ""%s-versions"" , name ) ;","dname = safe_calloc ( strlen ( name ) + 16 ) ;sprintf ( dname , ""%s-versions"" , name ) ;",1603
1080,"while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END )  {","check_stack_depth ( ) ;while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) {",1604
1081,"struct sock * sk ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;","struct sock * sk ;if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;",1605
1082,"static void usage ( char * progname ) {printf ( ""Usage:\\\printf ( ""%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>"" ,  progname ) ;printf ( ""<output_yuv><S2SV_blank>[<frames>]\\\","static void usage ( ) {printf ( ""Usage:\\\printf ( ""%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>"" , exec_name ) ;printf ( ""<output_yuv><S2SV_blank>[<frames>]\\\",1606
1083,# endif  int watchdog = 0 ;ssize_t num ;,# endif int watchdog = 0 ;,1607
1084,"SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;}}if ( c -> reneg_state == RENEG_DETECTED && ! c -> opt -> option . renegotiation ) {s_log ( LOG_ERR , ""Aborting<S2SV_blank>due<S2SV_blank>to<S2SV_blank>renegotiation<S2SV_blank>request"" ) ;throw_exception ( c , 1 ) ;}if ( shutdown_wants_read || shutdown_wants_write ) {num = SSL_shutdown ( c -> ssl ) ;if ( num < 0 )  err = SSL_get_error ( c -> ssl , ( int ) num ) ;else err = SSL_ERROR_NONE ;case SSL_ERROR_SYSCALL :  if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ;case SSL_ERROR_ZERO_RETURN :  SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_WANT_WRITE :  s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ;","SSL_set_shutdown ( c -> ssl , num ) ;else err = SSL_ERROR_NONE ;case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ;case SSL_ERROR_ZERO_RETURN : SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ;",1607
1085,"default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ;throw_exception ( c , 1 ) ;}}if ( sock_open_wr && sock_can_wr ) {num = writesocket ( c -> sock_wfd -> fd , c -> ssl_buff , c -> ssl_ptr ) ;switch ( num ) {case - 1 : if ( parse_socket_error ( c , ""writesocket"" ) ) break ;sock_open_rd = sock_open_wr = 0 ;break ;case 0 : s_log ( LOG_DEBUG , ""writesocket<S2SV_blank>returned<S2SV_blank>0"" ) ;break ;default : memmove ( c -> ssl_buff , c -> ssl_buff + num , c -> ssl_ptr - ( size_t ) num ) ;c -> ssl_ptr -= ( size_t ) num ;memset ( c -> ssl_buff + c -> ssl_ptr , 0 , ( size_t ) num ) ;c -> sock_bytes += ( size_t ) num ;watchdog = 0 ;}}if ( sock_open_rd && sock_can_rd ) {num = readsocket ( c -> sock_rfd -> fd ,  c -> sock_buff + c -> sock_ptr , BUFFSIZE - c -> sock_ptr ) ;switch ( num ) {case - 1 : if ( parse_socket_error ( c , ""readsocket"" ) ) break ;sock_open_rd = sock_open_wr = 0 ;break ;case 0 : s_log ( LOG_INFO , ""Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(readsocket)"" ) ;sock_open_rd = 0 ;break ;default : c -> sock_ptr += ( size_t ) num ;watchdog = 0 ;}}read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ;write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ;if ( ( write_wants_read && ssl_can_rd ) || ( write_wants_write && ssl_can_wr ) ) {write_wants_read = 0 ;write_wants_write = 0 ;num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ;switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) {case SSL_ERROR_NONE : if ( num == 0 ) {s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>0"" ) ;break ;}memmove ( c -> sock_buff , c -> sock_buff + num , c -> sock_ptr - ( size_t ) num ) ;c -> sock_ptr -= ( size_t ) num ;memset ( c -> sock_buff + c -> sock_ptr , 0 , ( size_t ) num ) ;c -> ssl_bytes += ( size_t ) num ;watchdog = 0 ;break ;case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ;write_wants_write = 1 ;break ;case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ;write_wants_read = 1 ;break ;case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ;break ;case SSL_ERROR_SYSCALL :   if ( num && parse_socket_error ( c , ""SSL_write"" ) )  break ;if ( c -> sock_ptr ) {s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ;throw_exception ( c , 1 ) ;}s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ;SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_ZERO_RETURN :   s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ;if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_SSL :  sslerror ( ""SSL_write"" ) ;","case SSL_ERROR_ZERO_RETURN : SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ;if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;case SSL_ERROR_SSL : sslerror ( ""SSL_write"" ) ;int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ;",1607
1086,"break ;case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ;","break ;case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ;",1607
1087,"s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)"" ) ;SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_RECEIVED_SHUTDOWN ) ;}if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) {if ( c -> sock_ptr || write_wants_write ) {s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ;throw_exception ( c , 1 ) ;}s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)"" ) ;SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_SENT_SHUTDOWN ) ;}if ( sock_open_wr && SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN && ! c -> ssl_ptr ) {sock_open_wr = 0 ;if ( ! c -> sock_wfd -> is_socket ) {s_log ( LOG_DEBUG , ""Closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>descriptor"" ) ;sock_open_rd = 0 ;}else if ( ! shutdown ( c -> sock_wfd -> fd , SHUT_WR ) ) {s_log ( LOG_DEBUG , ""Sent<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ;}else {s_log ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ;sock_open_rd = 0 ;}}if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && ! sock_open_rd && ! c -> sock_ptr && ! write_wants_write ) {if ( SSL_version ( c -> ssl ) != SSL2_VERSION ) {s_log ( LOG_DEBUG , ""Sending<S2SV_blank>close_notify<S2SV_blank>alert"" ) ;shutdown_wants_write = 1 ;}else {s_log ( LOG_DEBUG , ""Closing<S2SV_blank>SSLv2<S2SV_blank>socket"" ) ;","s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ;",1607
1088,if ( err )  return err ;if ( priv_ctx ) {,if ( err ) goto free_data ;if ( priv_ctx ) {,1608
1089,"elm_win_title_set ( app_data -> window , APP_NAME ) ;evas_object_smart_callback_add ( app_data -> window , ""delete,request"" , on_window_deletion , & app_data ) ;Evas_Object * bg = elm_bg_add ( app_data -> window ) ;elm_bg_color_set ( bg , 193 , 192 , 191 ) ;evas_object_size_hint_weight_set ( bg , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ;elm_win_resize_object_add ( app_data -> window , bg ) ;","elm_win_title_set ( app_data -> window , window_width , window_height ) ;",1609
1090,"evas_object_resize ( app_data -> window , DEFAULT_WIDTH , DEFAULT_HEIGHT ) ;evas_object_show ( app_data -> window ) ;","evas_object_resize ( app_data -> window , DEFAULT_WIDTH , DEFAULT_HEIGHT ) ;evas_object_show ( app_data -> window ) ;",1609
1091,if ( refill_pi_state_cache ( ) )  return - ENOMEM ;,if ( uaddr1 == uaddr2 ) return - EINVAL ;if ( refill_pi_state_cache ( ) ) return - ENOMEM ;,1610
1092,if ( unlikely ( ret != 0 ) )  goto out_put_key1 ;hb1 = hash_futex ( & key1 ) ;,"if ( unlikely ( ret != 0 ) ) goto out_put_key1 ;if ( requeue_pi && match_futex ( & key1 , & key2 ) ) {ret = - EINVAL ;goto out_put_keys ;}hb1 = hash_futex ( & key1 ) ;",1610
1093,sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;int all_param_pass = 1 ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ;bool all_param_pass = true ;union sctp_params param ;sctp_addiphdr_t * hdr ;union sctp_addr_param * addr_param ;chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ;,1611
1094,"while ( chunk_len > 0 ) {err_code = sctp_process_asconf_param ( asoc , asconf ,  asconf_param ) ;if ( SCTP_ERROR_NO_ERROR != err_code )  all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack ,  asconf_param -> crr_id , err_code ,  asconf_param ) ;length = ntohs ( asconf_param -> param_hdr . length ) ;asconf_param = ( void * ) asconf_param + length ;chunk_len -= length ;","sctp_walk_params ( param , addip , addip_hdr . params ) {if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ;err_code = sctp_process_asconf_param ( asoc , asconf , param . addip ) ;if ( err_code != SCTP_ERROR_NO_ERROR ) all_param_pass = 0 ;if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , param . addip -> crr_id , err_code , asconf_param ) ;",1611
1095,cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;,cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;,1612
1096,cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;break ;,cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;break ;,1612
1097,while ( c != EOF && c != \'\\\c = tok_nextc ( tok ) ;},"const char * prefix , * p , * type_start ;while ( c != EOF && c != \'\\\c = tok_nextc ( tok ) ;}if ( tok -> type_comments ) {p = tok -> start ;prefix = type_comment_prefix ;while ( * prefix && p < tok -> cur ) {if ( * prefix == \'<S2SV_blank>\' ) {while ( * p == \'<S2SV_blank>\' || * p == \'\\\\t\' ) {p ++ ;}}else if ( * prefix == * p ) {p ++ ;}else {break ;}prefix ++ ;}if ( ! * prefix ) {int is_type_ignore = 1 ;tok_backup ( tok , c ) ;type_start = p ;is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ;p += 6 ;while ( is_type_ignore && p < tok -> cur ) {if ( * p == \'#\' ) break ;is_type_ignore = is_type_ignore && ( * p == \'<S2SV_blank>\' || * p == \'\\\\t\' ) ;p ++ ;}if ( is_type_ignore ) {if ( blankline ) {tok_nextc ( tok ) ;tok -> atbol = 1 ;}return TYPE_IGNORE ;}else {* p_start = ( char * ) type_start ;* p_end = tok -> cur ;return TYPE_COMMENT ;}}}",1613
1098,LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ;const int old_frame_since_key = cpi -> rc . frames_since_key ;cpi -> rc = lc -> rc ;cpi -> twopass = lc -> twopass ;cpi -> oxcf . target_bandwidth = lc -> target_bandwidth ;cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ;cpi -> oxcf . optimal_buffer_level = lc -> optimal_buffer_level ;cpi -> oxcf . maximum_buffer_size = lc -> maximum_buffer_size ;cpi -> output_framerate = lc -> framerate ;,LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;const int old_frame_since_key = cpi -> rc . frames_since_key ;cpi -> alt_ref_source = lc -> rc ;cpi -> twopass = lc -> alt_ref_source ;,1614
1099,"status = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ;if ( ( status & ISR_LCIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_LCIS ) ;status = ksz8851ReadReg ( interface , KSZ8851_REG_P1SR ) ;if ( ( status & P1SR_LINK_GOOD ) != 0 ) {if ( ( status & P1SR_OPERATION_SPEED ) != 0 ) {if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 )  {","status = ksz8851ReadReg ( interface , KSZ8851_ISR ) ;if ( ( status & KSZ8851_ISR_LCIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS ) ;status = ksz8851ReadReg ( interface , KSZ8851_P1SR ) ;if ( ( status & KSZ8851_P1SR_LINK_GOOD ) != 0 ) {if ( ( status & KSZ8851_P1SR_OPERATION_DUPLEX ) != 0 ) {if ( ( status & KSZ8851_ISR_RXIS ) != 0 ) {if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 ) {",1615
1100,"if ( ( status & ISR_RXIS ) != 0 )  {ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_RXIS ) ;frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_REG_RXFCTR ) ) ;while ( frameCount > 0 ) {ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_RXIE ) ;}","if ( ( status & ISR_RXIS ) != 0 ) {ksz8851WriteReg ( interface , KSZ8851_ISR , KSZ8851_ISR_RXIS ) ;frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_RXFCTR ) ) ;while ( frameCount > 0 ) {ksz8851SetBit ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_RXIE ) ;}",1615
1101,case IS_STRING :  convert_to_double_ex ( zval_affine_elem ) ;affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ;break ;,case IS_STRING : {zval dval ;dval = * * zval_affine_elem ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;affine [ i ] = Z_DVAL ( dval ) ;}break ;,1616
1102,"convert_to_long_ex ( tmp ) ;rect . x = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;convert_to_long_ex ( tmp ) ;rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;convert_to_long_ex ( tmp ) ;rect . height = Z_LVAL_PP ( tmp ) ;}","if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . x = Z_LVAL ( lval ) ;}}rect . x = Z_LVAL_PP ( tmp ) ;}else {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . y = Z_LVAL ( lval ) ;}}else {rect . y = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . width = Z_LVAL ( lval ) ;}}else {rect . width = Z_LVAL_PP ( tmp ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ;if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . height = Z_LVAL ( lval ) ;}else {rect . height = Z_LVAL_PP ( tmp ) ;}}",1616
1103,fail :  vp9_free_context_buffers ( cm ) ;return 1 ;,"fail : vp9_set_mb_mi ( cm , 0 , 0 ) ;vp9_free_context_buffers ( cm ) ;return 1 ;",1617
1104,"__mincore_unmapped_range ( addr , end , vma , vec ) ;goto out ;if ( pte_none ( pte ) )  __mincore_unmapped_range ( addr , addr + PAGE_SIZE ,  vma , vec ) ;if ( non_swap_entry ( entry ) ) {* vec = 1 ;}else {# ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ;# else WARN_ON ( 1 ) ;* vec = 1 ;# endif }","memset ( vec , 1 , nr ) ;goto out ;if ( pte_none ( pte ) ) * vec = 0 ;* vec = ! ! non_swap_entry ( entry ) ;",1618
1105,"buffer = zend_string_alloc ( len , 0 ) ;n = zip_fread ( zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ;","buffer = zend_string_safe_alloc ( 1 , len , 0 , 0 ) ;n = zip_fread ( zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ;",1619
1106,if ( addr > ( vdev -> config_len - sizeof ( val ) ) )  return ;,if ( addr + sizeof ( val ) ) ) return ;,1620
1107,"u64 nsec = ( u64 ) jiffies * TICK_NSEC ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ;}","u32 rem ;value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) ;value -> tv_nsec = rem ;}",1621
1108,if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ;,if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) sanitize_dead_code ( env ) ;if ( ret == 0 ) return - EINVAL ;,1622
1109,if ( ret == 0 )  ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,if ( ret == 0 ) ret = convert_ctx_accesses ( env ) ;if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ;,1622
1110,"int align = DEFAULT_ALIGNMENT ;if ( ! memblk ) new_addr = vpx_malloc ( size ) ;else if ( ! size ) vpx_free ( memblk ) ;else {addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ;memblk = NULL ;# if CONFIG_MEM_MANAGER  new_addr = vpx_mm_realloc ( addr , size + align + ADDRESS_STORAGE_SIZE ) ;# else  new_addr = VPX_REALLOC_L ( addr , size + align + ADDRESS_STORAGE_SIZE ) ;","new_addr = realloc ( addr , size + align + ADDRESS_STORAGE_SIZE ) ;# else new_addr = VPX_REALLOC_L ( addr , size + align + ADDRESS_STORAGE_SIZE ) ;",1623
1111,egress :  if ( errcode != 0 )  assert ( state -> status != 0 ) ;,"egress : if ( errcode != 0 && state -> status == NULL ) state -> status = ""UNKNOWN_REASON"" ;",1624
1112,"if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ;( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ;( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ;( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ;( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ;( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ;( void ) ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ;viff_info . comment [ 511 ] = \'\\\\0\' ;if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment ) ;if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ;else image -> endian = MSBEndian ;viff_info . rows = ReadBlobLong ( image ) ;viff_info . columns = ReadBlobLong ( image ) ;viff_info . subrows = ReadBlobLong ( image ) ;viff_info . x_offset = ReadBlobSignedLong ( image ) ;viff_info . y_offset = ReadBlobSignedLong ( image ) ;viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;viff_info . location_type = ReadBlobLong ( image ) ;viff_info . location_dimension = ReadBlobLong ( image ) ;viff_info . number_of_images = ReadBlobLong ( image ) ;viff_info . number_data_bands = ReadBlobLong ( image ) ;viff_info . data_storage_type = ReadBlobLong ( image ) ;viff_info . data_encode_scheme = ReadBlobLong ( image ) ;viff_info . map_scheme = ReadBlobLong ( image ) ;viff_info . map_storage_type = ReadBlobLong ( image ) ;viff_info . map_rows = ReadBlobLong ( image ) ;viff_info . map_columns = ReadBlobLong ( image ) ;viff_info . map_subrows = ReadBlobLong ( image ) ;viff_info . map_enable = ReadBlobLong ( image ) ;viff_info . maps_per_cycle = ReadBlobLong ( image ) ;viff_info . color_space_model = ReadBlobLong ( image ) ;for ( i = 0 ;i < 420 ;i ++ ) ( void ) ReadBlobByte ( image ) ;if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ;number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ;if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ;if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ;if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ;if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ;if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ;if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ;if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ;if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ;switch ( ( int ) viff_info . map_scheme ) {case VFF_MS_NONE : {if ( viff_info . number_data_bands < 3 ) {if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> matte = viff_info . number_data_bands == 4 ? MagickTrue : MagickFalse ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",1625
1113,"if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 ||  ( r = sshbuf_get_u32 ( b , ( u_int * ) & comp -> enabled ) ) != 0 || ( r = sshbuf_get_cstring ( b , & comp -> name , NULL ) ) != 0 ) goto out ;","if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 || ( r = sshbuf_get_u32 ( b , ( u_int * ) & comp -> enabled ) ) != 0 || ( r = sshbuf_get_cstring ( b , & comp -> name , NULL ) ) != 0 ) goto out ;",1626
1114,END_OF_READING :  if ( clone_info )  clone_info = DestroyImageInfo ( clone_info ) ;CloseBlob ( image ) ;,END_OF_READING : CloseBlob ( image ) ;,1627
1115,DeleteImageFromList ( & tmp ) ;},if ( tmp == image2 ) image2 = ( Image * ) NULL ;DeleteImageFromList ( & tmp ) ;},1627
1116,"int open_mode = opendata -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ;nfs4_stateid stateid ;if ( can_open_cached ( state , open_mode ) ) {spin_lock ( & state -> owner -> so_lock ) ;if ( can_open_cached ( state , open_mode ) ) {update_open_stateflags ( state , open_mode ) ;spin_unlock ( & state -> owner -> so_lock ) ;if ( delegation == NULL ||  ! can_open_delegated ( delegation , open_mode ) ) {rcu_read_unlock ( ) ;","int open_mode = opendata -> o_arg . open_flags & O_EXCL ;fmode_t fmode = opendata -> o_arg . fmode ;nfs4_stateid stateid ;if ( can_open_cached ( state , fmode ) ;spin_unlock ( & state -> owner -> so_lock ) ;if ( delegation == NULL || ! can_open_delegated ( delegation , fmode ) ) {rcu_read_unlock ( ) ;",1628
1117,"if ( update_open_stateid ( state , NULL , & stateid , open_mode ) )  goto out_return_state ;","if ( update_open_stateid ( state , NULL , & stateid , fmode ) ) goto out_return_state ;",1628
1118,else {err = - EINVAL ;goto out ;}}else {* policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ;* policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ;}if ( vma ) {up_read ( & current -> mm -> mmap_sem ) ;vma = NULL ;},"
",1629
1119,"bitmap -> compressed = FALSE ;bitmap -> format = gdi -> dstFormat ;bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ;bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ;","UINT32 size = DstWidth * DstHeight ;bitmap -> compressed = FALSE ;bitmap -> format = gdi -> dstFormat ;if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ;size *= GetBytesPerPixel ( bitmap -> format ) ;bitmap -> length = size ;bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ;",1630
1120,"const VP9_CONFIG * const oxcf = & cpi -> oxcf ;int active_best_quality ;int active_worst_quality = calc_active_worst_quality_one_pass_vbr ( cpi ) ;if ( frame_is_intra_only ( cm ) ) {active_best_quality = rc -> best_quality ;# if ! CONFIG_MULTIPLE_ARF if ( rc -> this_key_frame_forced ) {double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q ,  last_boosted_q * 0.75 ) ;active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;}else if ( cm -> current_video_frame > 0 ) {double q_adj_factor = 1.0 ;active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] ,   rc -> kf_boost ,  kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val ,  q_val * q_adj_factor ) ;}active_best_quality = active_worst_quality + vp9_compute_qdelta ( rc , current_q , current_q * 0.3 ) ;# endif }else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) {if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) {if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) {if ( q < cpi -> cq_target_quality )  q = cpi -> cq_target_quality ;","const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;const int cq_level = get_active_cq_level ( rc , oxcf ) ;int active_best_quality ;int active_worst_quality = calc_active_worst_quality_one_pass_vbr ( cpi ) ;int * inter_minq ;ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ;if ( frame_is_intra_only ( cm ) ) {if ( rc -> this_key_frame_forced ) {double last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ;active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;}else {double q_adj_factor = 1.0 ;active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor ) ;}active_best_quality = get_kf_active_quality ( rc , rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) {if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) {if ( q < cpi -> cq_target_quality ) q = cpi -> cq_target_quality ;",1631
1121,}else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) {if ( ! cpi -> refresh_alt_ref_frame ) {active_best_quality = cpi -> cq_target_quality ;},}else if ( oxcf -> rc_mode == VPX_CQ ) {if ( ! cpi -> refresh_alt_ref_frame ) {active_best_quality = cpi -> cq_target_quality ;},1631
1122,if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) {active_best_quality = cpi -> cq_target_quality ;}else {if ( cm -> current_video_frame > 1 ) active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ;else active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ;if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) &&   ( active_best_quality < cpi -> cq_target_quality ) ) {if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ;,if ( oxcf -> rc_mode == VPX_Q ) {if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ;,1631
1123,# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY   if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) {if ( ! ( cm -> current_video_frame == 0 ) )  * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ;}# endif  if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) {q = active_best_quality ;,# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) {if ( ! ( cm -> current_video_frame == 0 ) ) * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ;}# endif if ( oxcf -> rc_mode == VPX_Q ) {active_best_quality = cq_level ;,1631
1124,"# if CONFIG_MULTIPLE_ARF  if ( cpi -> multi_arf_enabled && ( cm -> frame_type != KEY_FRAME ) && cpi -> oxcf . end_usage != USAGE_CONSTANT_QUALITY ) {double new_q ;double current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ;int level = cpi -> this_frame_weight ;assert ( level >= 0 ) ;new_q = current_q * ( 1.0 - ( 0.2 * ( cpi -> max_arf_level - level ) ) ) ;q = active_worst_quality + vp9_compute_qdelta ( rc , current_q , new_q ) ;* bottom_index = q ;* top_index = q ;printf ( ""frame:%d<S2SV_blank>q:%d\\\}# endif assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ;",assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ;,1631
1125,"for ( j = 1 ;lua_pushnumber ( L , j ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array"" ) ;for ( j = 1 ;lua_pushnumber ( L , j ) ;",1632
1126,guint32 off = offset ;guint32 len ;,"guint32 off = offset , last_off ;guint32 len ;",1633
1127,"DebugLog ( ( ""parse_wbxml_tag<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\while ( off < tvb_len ) {","DebugLog ( ( ""parse_wbxml_tag<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\last_off = off ;while ( off < tvb_len ) {",1633
1128,"
",if ( off < last_off ) {THROW ( ReportedBoundsError ) ;}last_off = off ;,1633
1129,"}DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\","}DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\",1633
1130,"Py_INCREF ( id ) ;PyDict_DelItemString ( value , ""$id"" ) ;if ( database == NULL ) {","if ( id == NULL ) {id = Py_None ;Py_INCREF ( id ) ;}else {Py_INCREF ( id ) ;PyDict_DelItemString ( value , ""$id"" ) ;}if ( database == NULL ) {",1634
1131,"case BGP_CAPCODE_RESTART :  ND_PRINT ( ( ndo , ""\\\","case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ;ND_PRINT ( ( ndo , ""\\\",1635
1132,"
",if ( idx > 63 ) return AVERROR_INVALIDDATA ;,1636
1133,"j = scantable [ idx ++ ] ;block [ j ] = sign ? 1 : - 1 ;j = scantable [ idx ++ ] ;block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ;}j = scantable [ idx ++ ] ;","j = scantable [ idx ++ ] ;block [ j ] = sign ? 1 : - 1 ;if ( idx > 63 ) return AVERROR_INVALIDDATA ;j = scantable [ idx ++ ] ;block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ;}if ( idx > 63 ) return AVERROR_INVALIDDATA ;j = scantable [ idx ++ ] ;",1636
1134,"static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) {vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] ,   MODEL_NODES * sizeof ( vp9_prob ) ) ;}","static void extend_to_full_distribution ( vpx_prob * probs , vp9_prob p ) {memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , MODEL_NODES * sizeof ( vpx_prob ) ) ;}",1637
1135,"PNG_UNUSED ( png_ptr ) # ifdef PNG_STRING_COPYRIGHT return PNG_STRING_COPYRIGHT # else # ifdef __STDC__  return ( ( png_charp ) PNG_STRING_NEWLINE ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2014<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" PNG_STRING_NEWLINE ) ;# else  return ( ( png_charp ) ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014\\\\\# endif # endif }","PNG_UNUSED ( png_ptr ) # ifdef PNG_STRING_COPYRIGHT return PNG_STRING_COPYRIGHT # else # ifdef __STDC__ return ( ( png_charp ) PNG_STRING_NEWLINE ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" PNG_STRING_NEWLINE ) ;# else return ( ( png_charp ) ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015\\\\\# endif # endif }",1638
1136,case PKT_STARTUP : if ( client -> pool ) {,"case PKT_STARTUP : if ( ! client -> auth_user ) {disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ;return false ;}if ( client -> pool ) {",1639
1137,"case \'p\' :  if ( cf_auth_type <= AUTH_TRUST ) {disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ;","case \'p\' : if ( cf_auth_type <= AUTH_TRUST ) {disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ;",1639
1138,"rc = cmd_start ( adata , cmdstr , flags ) ;if ( rc < 0 ) {","if ( flags & IMAP_CMD_SINGLE ) {if ( adata -> nextcmd != adata -> lastcmd ) imap_exec ( adata , NULL , IMAP_CMD_POLL ) ;}rc = cmd_start ( adata , cmdstr , flags ) ;if ( rc < 0 ) {if ( ( flags & IMAP_CMD_SINGLE ) && ( adata -> nextcmd == adata -> lastcmd ) ) break ;",1640
1139,}mutt_sig_allow_interrupt ( false ) ;,}mutt_sig_allow_interrupt ( false ) ;,1640
1140,"return PNG_OUT_OF_MEMORY_ERROR ;}if ( setjmp ( mainprog_ptr -> jmpbuf ) ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return LIBPNG_FATAL_ERROR ;}# if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ;# endif # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) ""pHYs\\\\0iTXt\\\\0tEXt\\\\0zTXt"" , 4 ) ;# endif png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ;struct rwpng_read_data read_data = {infile , 0 };png_set_read_fn ( png_ptr , & read_data , user_read_data ) ;png_read_info ( png_ptr , info_ptr ) ;png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , & bit_depth , & color_type , NULL , NULL , NULL ) ;if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return PNG_OUT_OF_MEMORY_ERROR ;}","
",1641
1141,"
","if ( rowbytes > INT_MAX / mainprog_ptr -> height ) {png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ;return PNG_OUT_OF_MEMORY_ERROR ;}",1641
1142,"if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) {fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\","if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) {fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\\",1641
1143,"ar2 -> intf [ 0 ] = interface ;ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ;r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ;if ( r ) goto fail1 ;alt = ar2 -> intf [ 1 ] -> cur_altsetting ;ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ;r = ati_remote2_urb_init ( ar2 ) ;if ( r )  goto fail2 ;ar2 -> channel_mask = channel_mask ;if ( r )  goto fail2 ;usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ;if ( r )  goto fail2 ;r = ati_remote2_input_init ( ar2 ) ;if ( r )  goto fail3 ;usb_set_intfdata ( interface , ar2 ) ;fail3 :  sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ;fail2 :  ati_remote2_urb_cleanup ( ar2 ) ;usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ;","if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) {dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\\r = - ENODEV ;goto fail1 ;}ar2 -> intf [ 0 ] = interface ;ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ;if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) {dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\\r = - ENODEV ;goto fail1 ;}r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ;if ( r ) goto fail3 ;ar2 -> channel_mask = channel_mask ;if ( r ) goto fail2 ;usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ;if ( r ) goto fail3 ;r = ati_remote2_input_init ( ar2 ) ;if ( r ) goto fail4 ;usb_set_intfdata ( interface , ar2 ) ;fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ;fail3 : ati_remote2_urb_cleanup ( ar2 ) ;fail2 : usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ;",1642
1144,"pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ;RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ;","pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size + EXTRA_BS_OFFSET ) ;RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ;",1643
1145,"
",if ( unlikely ( page_count ( page ) <= 0 ) ) {if ( pages ) {spin_unlock ( ptl ) ;remainder = 0 ;err = - ENOMEM ;break ;}},1644
1146,same_page :  if ( pages ) {,same_page : if ( pages ) {,1644
1147,u8 odata [ 16 ] ;u8 idata [ 16 ] ;,u8 * odata = pctx -> odata ;u8 * idata = pctx -> idata ;,1645
1148,"if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\","if ( ! urb -> actual_length ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\\return ;}if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\",1646
1149,"else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) {memcpy ( command_info -> result_buffer , & data [ 1 ] ,  urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;","else if ( ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) {memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;",1646
1150,"static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header ,  struct mb_cache_entry * * pce )  {struct mb_cache_entry * ce ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;again :   ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev ,  hash ) ;if ( IS_ERR ( ce ) ) {if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ;break ;}","static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , struct mb2_cache_entry * * pce ) {struct mb2_cache_entry * ce ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ce = mb2_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , hash ) ;",1647
1151,"ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;}","ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce ) ;}",1647
1152,"if ( vm_flags & VM_NORESERVE )  return 0 ;if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ;else {struct resv_map * resv_map = resv_map_alloc ( ) ;if ( ! resv_map ) return - ENOMEM ;chg = to - from ;set_vma_resv_map ( vma , resv_map ) ;set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ;}if ( chg < 0 ) return chg ;if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;","struct hugepage_subpool * spool = subpool_inode ( inode ) ;if ( hugepage_subpool_get_pages ( spool , chg ) ) return - ENOSPC ;hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ret ;",1648
1153,"lua_pushvalue ( L , i ) ;mp_encode_lua_type ( L , buf , 0 ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ;lua_pushvalue ( L , i ) ;mp_encode_lua_type ( L , buf , 0 ) ;",1649
1154,drop_futex_key_refs ( & q -> key ) ;},},1650
1155,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",1651
1156,if ( sk_hashed ( sk ) ) {write_lock_bh ( & ping_table . lock ) ;hlist_nulls_del ( & sk -> sk_nulls_node ) ;write_unlock_bh ( & ping_table . lock ) ;}},write_lock_bh ( & ping_table . lock ) ;if ( sk_hashed ( sk ) ) {hlist_nulls_del ( & sk -> sk_nulls_node ) ;}write_unlock_bh ( & ping_table . lock ) ;},1652
1157,msc -> ntouches = 0 ;for ( ii = 0 ;npoints = ( size - 6 ) / 8 ;msc -> ntouches = 0 ;,"if ( npoints > 15 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\\return 0 ;}msc -> ntouches = 0 ;for ( ii = 0 ;npoints = ( size - 6 ) / 8 ;if ( npoints > 15 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\\return 0 ;}msc -> ntouches = 0 ;",1653
1158,"int hdrlen ;uint16_t fc ;if ( caplen < 3 ) {ND_PRINT ( ( ndo , ""[|802.15.4]<S2SV_blank>%x"" , caplen ) ) ;return caplen ;}fc = EXTRACT_LE_16BITS ( p ) ;hdrlen = extract_header_length ( fc ) ;seq = EXTRACT_LE_8BITS ( p + 2 ) ;p += 3 ;caplen -= 3 ;ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ fc & 0x7 ] ) ) ;if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ;if ( hdrlen == - 1 ) {ND_PRINT ( ( ndo , ""invalid!<S2SV_blank>"" ) ) ;return caplen ;}if ( ! ndo -> ndo_vflag ) {p += hdrlen ;caplen -= hdrlen ;}else {switch ( ( fc >> 10 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;p += 2 ;case 0x03 :  panid = EXTRACT_LE_16BITS ( p ) ;ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;break ;}ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ;switch ( ( fc >> 14 ) & 0x3 ) {case 0x00 :  ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;case 0x01 :  ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;case 0x02 :   if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p ) ;}ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;break ;case 0x03 :   if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p ) ;}ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;break ;}caplen -= hdrlen ;}return 0 ;}","u_int hdrlen ;uint16_t fc ;switch ( ( fc >> 10 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;caplen -= 2 ;hdrlen += 2 ;if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;p += 2 ;case 0x03 : panid = EXTRACT_LE_16BITS ( p ) ;ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;break ;}ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ;switch ( ( fc >> 14 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;case 0x01 : ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;case 0x02 : if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p + 2 ) ) ) ;caplen -= 2 ;hdrlen += 2 ;}ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;break ;case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}panid = EXTRACT_LE_16BITS ( p ) ;caplen -= 2 ;hdrlen += 2 ;caplen -= 2 ;hdrlen += 2 ;}if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) }ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ;caplen -= 8 ;hdrlen += 8 ;caplen -= 8 ;hdrlen += 8 ;break ;}return hdrlen ;}",1654
1159,struct pmu * leader_pmu = event -> group_leader -> pmu ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;,struct pmu * leader_pmu = event -> group_leader -> pmu ;if ( is_software_event ( event ) ) return 1 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;,1655
1160,"id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ;if ( id < 0 ) {ipc_rcu_putref ( msq , msg_rcu_free ) ;return id ;}msq -> q_stime = msq -> q_rtime = 0 ;msq -> q_ctime = get_seconds ( ) ;","msq -> q_stime = msq -> q_rtime = 0 ;msq -> q_ctime = get_seconds ( ) ;id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ;if ( id < 0 ) {ipc_rcu_putref ( msq , msg_rcu_free ) ;return id ;}",1656
1161,"VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( ! load -> real ) {if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ;# ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\\# endif load -> real -> progress_signal = load -> out ;g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ;if ( class -> load ( load ) ||  vips_image_pio_input ( load -> real ) )  return ( NULL ) ;if ( ! vips_foreign_load_iscompat ( load -> real , out ) )  return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;","VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ;if ( load -> error ) return ( NULL ) ;if ( ! load -> real ) || vips_foreign_load_iscompat ( load -> real , out ) ) return ( NULL ) ;vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ;",1657
1162,"vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;}vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;}","memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;}memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ;}",1658
1163,"if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {dptr = & xargs -> tktpolicydn ;","arg = ( arg != NULL ) ? arg : """" ;if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {dptr = & xargs -> tktpolicydn ;",1659
1164,"
",if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;,1660
1165,line += PKT_LEN_SIZE ;if ( len == PKT_LEN_SIZE ) {,line += PKT_LEN_SIZE ;if ( len == PKT_LEN_SIZE ) {,1660
1166,"flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;","flen = udf_get_filename ( dir -> i_sb , nameptr , lfi , fname , UDF_NAME_LEN ) ;if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ;",1661
1167,"outpos +=  sprintf ( outpos , ""\\\}","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",1662
1168,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",1663
1169,"pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 *  sizeof ( * pixels ) ) ;","pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ;",1663
1170,"if ( copy_from_user ( & sas , optval , len ) )  return - EFAULT ;","len = min_t ( size_t , len , sizeof ( sas ) ) ;if ( copy_from_user ( & sas , optval , len ) ) return - EFAULT ;",1664
1171,"len = min_t ( size_t , len , sizeof ( sas ) ) ;if ( put_user ( len , optlen ) ) return - EFAULT ;","if ( put_user ( len , optlen ) ) return - EFAULT ;",1664
1172,for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src + i ) ;,for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src + i ) ;,1665
1173,"char buffer [ 4096 ] ;char buffer2 [ 4096 ] ;char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;}else {memcpy ( buf , name , name_len ) ;buf [ name_len ] = 0 ;}encrypt_return_plain :  if ( buf != buffer ) {efree ( buf ) ;}","char * buf , * buf2 , * d , * d_url ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;encrypt_return_plain : efree ( buf ) ;",1666
1174,"if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {memcpy ( buf2 , value , value_len ) ;buf2 [ value_len ] = 0 ;}else {}if ( buf != buffer ) {efree ( buf ) ;}if ( buf2 != buffer2 ) {}",efree ( buf ) ;,1666
1175,if ( ! ( vmx -> exit_reason == EXIT_REASON_MCE_DURING_VMENTRY || vmx -> exit_reason == EXIT_REASON_EXCEPTION_NMI ) ) return ;vmx -> exit_intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ;exit_intr_info = vmx -> exit_intr_info ;if ( is_machine_check ( exit_intr_info ) ) kvm_machine_check ( ) ;if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR &&  ( exit_intr_info & INTR_INFO_VALID_MASK ) ) {,if ( is_nmi ( exit_intr_info ) ) {,1667
1176,"static REFERENCE_MODE read_frame_reference_mode ( const VP9_COMMON * cm ,  vp9_reader * r ) {if ( is_compound_reference_allowed ( cm ) ) {return vp9_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT  : COMPOUND_REFERENCE ) : SINGLE_REFERENCE ;","static REFERENCE_MODE read_frame_reference_mode ( const VP9_COMMON * cm , vpx_reader * r ) {if ( is_compound_reference_allowed ( cm ) ) {return vpx_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT : COMPOUND_REFERENCE ) : SINGLE_REFERENCE ;",1668
1177,if ( outlength16 >= inlength * 16 )  return vp9_filteredinterp_filters1000 ;else if ( outlength16 >= inlength * 13 )  return vp9_filteredinterp_filters875 ;else if ( outlength16 >= inlength * 11 )  return vp9_filteredinterp_filters750 ;else if ( outlength16 >= inlength * 9 )  return vp9_filteredinterp_filters625 ;else  return vp9_filteredinterp_filters500 ;},if ( outlength16 >= inlength * 16 ) return filteredinterp_filters1000 ;else if ( outlength16 >= inlength * 13 ) return filteredinterp_filters875 ;else if ( outlength16 >= inlength * 11 ) return filteredinterp_filters750 ;else if ( outlength16 >= inlength * 9 ) return filteredinterp_filters625 ;else return filteredinterp_filters500 ;},1669
1178,"case 0x00 :  p += 2 ;n += 2 ;case 0x40 :  if ( * p == FAC_NATIONAL_RAND )  facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ;case 0x80 :  p += 4 ;n += 4 ;case 0xC0 :  l = p [ 1 ] ;if ( * p == FAC_NATIONAL_DEST_DIGI ) {memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> source_ndigis = 1 ;memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> dest_ndigis = 1 ;memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ;}memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ;}else if ( * p == FAC_NATIONAL_DIGIS ) {fac_national_digis_received = 1 ;","case 0x00 : if ( len < 2 ) return - 1 ;p += 2 ;n += 2 ;case 0x40 : if ( len < 3 ) return - 1 ;if ( * p == FAC_NATIONAL_RAND ) facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ;case 0x80 : if ( len < 4 ) return - 1 ;p += 4 ;n += 4 ;case 0xC0 : if ( len < 2 ) return - 1 ;l = p [ 1 ] ;if ( len < 2 + l ) return - 1 ;if ( * p == FAC_NATIONAL_DEST_DIGI ) {if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> source_ndigis = 1 ;if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ;facilities -> dest_ndigis = 1 ;if ( l < AX25_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ;}if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ;memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ;}else if ( * p == FAC_NATIONAL_DIGIS ) {if ( l % AX25_ADDR_LEN ) return - 1 ;fac_national_digis_received = 1 ;",1670
1179,"static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi ,  TX_SIZE tx_size ,  vp9_coeff_stats * frame_branch_ct ) {vp9_coeff_probs_model * new_frame_coef_probs = cpi -> frame_coef_probs [ tx_size ] ;vp9_coeff_probs_model * old_frame_coef_probs =  cpi -> common . fc . coef_probs [ tx_size ] ;const vp9_prob upd = DIFF_UPDATE_PROB ;","static void update_coef_probs_common ( vpx_writer * const bc , VP9_COMP * cpi , TX_SIZE tx_size , vp9_coeff_stats * frame_branch_ct , vp9_coeff_probs_model * new_coef_probs ) {vp9_coeff_probs_model * old_coef_probs = cpi -> common . fc . coef_probs [ tx_size ] ;const vp9_prob upd = DIFF_UPDATE_PROB ;",1671
1180,"vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;int s ;if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] ,  old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ;","vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;const vpx_prob oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;int s ;if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd , stepsize ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ;",1671
1181,"vp9_write_bit ( bc , 0 ) ;return ;vp9_write_bit ( bc , 1 ) ;for ( i = 0 ;","vpx_write_bit ( bc , 0 ) ;return ;vpx_write_bit ( bc , 1 ) ;for ( i = 0 ;",1671
1182,"vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;const vp9_prob upd = DIFF_UPDATE_PROB ;int s ;if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] ,  old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;vp9_write ( bc , u , upd ) ;if ( u ) {","vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vpx_prob * oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;const vpx_prob upd = DIFF_UPDATE_PROB ;int s ;if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd , stepsize ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;vpx_write ( bc , u , upd ) ;if ( u ) {",1671
1183,case ONE_LOOP :  case ONE_LOOP_REDUCED : {const int prev_coef_contexts_to_update =  cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEFF_CONTEXTS >> 1 : COEFF_CONTEXTS ;,case ONE_LOOP_REDUCED : {const int prev_coef_contexts_to_update = cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEFF_CONTEXTS >> 1 : COEFF_CONTEXTS ;,1671
1184,"vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;if ( l >= prev_coef_contexts_to_update ||  k >= coef_band_to_update ) {u = 0 ;if ( t == PIVOT_NODE )  s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] ,  old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ;else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;if ( s > 0 && newp != * oldp )  u = 1 ;}updates += u ;vp9_write_bit ( bc , 1 ) ;for ( v = 0 ;++ v )  vp9_write ( bc , 0 , upd ) ;}vp9_write ( bc , u , upd ) ;if ( u ) {","vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vpx_prob * oldp = old_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ;vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ;if ( t == PIVOT_NODE ) {s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , old_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd , stepsize ) ;s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ;}if ( s > 0 && newp != * oldp ) u = 1 ;updates += u ;vpx_write_bit ( bc , 1 ) ;for ( v = 0 ;+ v )  vp9_write ( bc , 0 , upd ) ;++ v ) vpx_write ( bc , 0 , upd ) ;}vpx_write ( bc , u , upd ) ;if ( u ) {",1671
1185,"vp9_write_bit ( bc , 0 ) ;}","vpx_write_bit ( bc , 0 ) ;}",1671
1186,if ( ! retval ) {r = strdup ( realm ) ;if ( ! r ) {retval = ENOMEM ;}},"if ( ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ;",1672
1187,"void vp9_fht16x16_sse2 ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {case DCT_DCT :  vp9_fdct16x16_sse2 ( input , output , stride ) ;break ;","void vp9_fht16x16_sse2 ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {case DCT_DCT : vpx_fdct16x16_sse2 ( input , output , stride ) ;break ;",1673
1188,if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) {if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO )  c -> idct_put = ff_simple_idct_put_int32_10bit ;,if ( c -> mpeg4_studio_profile ) c -> idct_put = ff_simple_idct_put_int32_10bit ;,1674
1189,int c_sz ;_dst += _y4m -> pic_w * _y4m -> pic_h ;,int c_sz ;( void ) _aux ;_dst += _y4m -> pic_w * _y4m -> pic_h ;,1675
1190,"rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ;","rc = fsmMkfile ( fi , fpath , files , psm , 0 , nodigest , & setmeta , & firsthardlink ) ;",1676
1191,"rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ;firsthardlink = - 1 ;","rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ;firsthardlink = - 1 ;",1676
1192,"size_t ss = CDF_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;if ( pos > ss * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;",1677
1193,struct fb_vblank vblank ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;,"struct fb_vblank vblank ;memset ( & vblank , 0 , sizeof ( vblank ) ) ;vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ;",1678
1194,int ret = 0 ;mutex_lock ( & inode -> i_mutex ) ;if ( ret >= 0 ) {if ( ! list_empty ( & io -> list ) ) list_del_init ( & io -> list ) ;ext4_free_io_end ( io ) ;}},"struct ext4_inode_info * ei = EXT4_I ( inode ) ;unsigned long flags ;int ret ;mutex_lock ( & inode -> i_mutex ) ;if ( ret < 0 ) {return ;}spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ;if ( ! list_empty ( & io -> list ) ) list_del_init ( & io -> list ) ;spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;mutex_unlock ( & inode -> i_mutex ) ;ext4_free_io_end ( io ) ;}",1679
1195,"if ( recvd ) {clear_sock ( pool ) ;sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;}else {if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\"",<S2SV_blank>\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\""]}"" , swork_id ++ ) ;}if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) {",if ( n2size < 1 ) {,1680
1196,"if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;","if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;",1680
1197,if ( s ) {struct unix_sock * u = unix_sk ( s ) ;spin_lock ( & unix_gc_lock ) ;,spin_lock ( & unix_gc_lock ) ;if ( s ) {struct unix_sock * u = unix_sk ( s ) ;,1681
1198,spin_unlock ( & unix_gc_lock ) ;}},}fp -> f_cred -> user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;},1681
1199,BOOL ret = FALSE ;WCHAR * data = NULL ;goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}goto out ;}data = NULL ;ret = TRUE ;out : free ( data ) ;return ret ;},WCHAR * data = NULL ;goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}return TRUE ;err : sud -> directory = NULL ;free ( data ) ;return FALSE ;},1682
1200,"in_uint16_le ( s , length ) ;in_uint16_le ( s , flags ) ;in_uint8 ( s , type ) ;next_order = s -> p + ( sint16 ) length + 7 ;","struct stream packet = * s ;in_uint16_le ( s , length ) ;in_uint16_le ( s , flags ) ;in_uint8 ( s , type ) ;if ( ! s_check_rem ( s , length + 7 ) ) {rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ;}next_order = s -> p + ( sint16 ) length + 7 ;",1683
1201,if ( cpi -> common . frame_type == KEY_FRAME ) {cpi -> rc . key_frame_rate_correction_factor = factor ;}if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) &&  ! cpi -> rc . is_src_frame_alt_ref &&   ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) )  cpi -> rc . gf_rate_correction_factor = factor ;else  cpi -> rc . rate_correction_factor = factor ;},"RATE_CONTROL * const rc = & cpi -> rc ;factor /= rcf_mult [ cpi -> rc . frame_size_selector ] ;factor = fclamp ( factor , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ;if ( cpi -> common . frame_type == KEY_FRAME ) {rc -> rate_correction_factors [ KF_STD ] = factor ;}else if ( cpi -> oxcf . pass == 2 ) {RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ;rc -> rate_correction_factors [ rf_lvl ] = factor ;}if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && ! rc -> is_src_frame_alt_ref && ! ( cpi -> use_svc && ( cpi -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rc -> rate_correction_factors [ GF_ARF_STD ] = factor ;else rc -> rate_correction_factors [ INTER_NORMAL ] = factor ;}",1684
1202,spin_lock_init ( & tu -> qlock ) ;init_waitqueue_head ( & tu -> qchange_sleep ) ;mutex_init ( & tu -> tread_sem ) ;tu -> ticks = 1 ;,spin_lock_init ( & tu -> ioctl_lock ) ;tu -> ticks = 1 ;,1685
1203,"
","if ( u1_nal_ref_idc != 0 ) {if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) {memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ;}}",1686
1204,ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ;ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ;,ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ;ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ;,1686
1205,"char buf [ 32 ] ;js_Object * self = js_toobject ( J , 0 ) ;","char buf [ 100 ] ;js_Object * self = js_toobject ( J , 0 ) ;",1687
