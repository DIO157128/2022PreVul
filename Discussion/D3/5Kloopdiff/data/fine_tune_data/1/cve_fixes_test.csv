,source,target,group
0,sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;,"unix_dgram_peer_wake_disconnect ( sk , skpair ) ;sock_put ( skpair ) ;unix_peer ( sk ) = NULL ;",0
1,"static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index ,  int_mv * ref_mv ,  int_mv * second_ref_mv , int64_t comp_pred_diff [ REFERENCE_MODES ] ,  int64_t tx_size_diff [ TX_MODES ] ,   int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) {MACROBLOCKD * const xd = & x -> e_mbd ;ctx -> best_mode_index = mode_index ;ctx -> mic = * xd -> mi [ 0 ] ;ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ;ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ;vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;","static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , int64_t comp_pred_diff [ REFERENCE_MODES ] , int64_t tx_size_diff [ TX_MODES ] , int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable ) {MACROBLOCKD * const xd = & x -> e_mbd ;ctx -> mbmi_ext = * x -> mbmi_ext ;ctx -> best_mode_index = mode_index ;ctx -> mic = * xd -> mi [ 0 ] ;ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ;ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ;memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;",1
2,"ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;","ND_TCHECK2 ( * ext , sizeof ( a ) ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;",2
3,if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) {cm -> allow_comp_inter_inter = 0 ;}cm -> allow_comp_inter_inter = 1 ;cm -> comp_fixed_ref = ALTREF_FRAME ;int i ;const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ;const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter )  cm -> reference_mode = SINGLE_REFERENCE ;else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] &&   mode_thresh [ COMPOUND_REFERENCE ] >   mode_thresh [ REFERENCE_MODE_SELECT ] &&  check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ;else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] )  cm -> reference_mode = SINGLE_REFERENCE ;else cm -> reference_mode = REFERENCE_MODE_SELECT ;if ( cm -> interp_filter == SWITCHABLE ) {if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP_SMOOTH ;}else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP_SHARP ;}else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) {cm -> interp_filter = EIGHTTAP ;}}encode_frame_internal ( cpi ) ;for ( i = 0 ;i < REFERENCE_MODES ;++ i ) {const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ;cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ;for ( i = 0 ;const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;}for ( i = 0 ;,cpi -> allow_comp_inter_inter = 0 ;}cm -> allow_comp_inter_inter = 1 ;cm -> comp_fixed_ref = ALTREF_FRAME ;+ i ) {int i ;const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ;int64_t * const mode_thrs = rd_opt -> prediction_type_threshes [ frame_type ] ;const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ;int64_t * const filter_thrs = rd_opt -> filter_threshes [ frame_type ] [ i ] += diff ;for ( i = 0 ;const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ;cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ;}for ( i = 0 ;,3
4,single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;}vp9_zero ( cm -> counts . comp_inter ) ;}vp9_zero ( cm -> counts . comp_inter ) ;},single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ;comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ;}vp9_zero ( cm -> counts . comp_inter ) ;}vp9_zero ( cm -> counts . comp_inter ) ;},3
5,"count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;}reset_skip_txfm_size ( cm , TX_8X8 ) ;}reset_skip_txfm_size ( cm , TX_4X4 ) ;}reset_skip_txfm_size ( cm , TX_16X16 ) ;}cm -> interp_filter = SWITCHABLE ;encode_frame_internal ( cpi ) ;","count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ;count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ;count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ;count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ;count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ;count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ;count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ;count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ;}reset_skip_txfm_size ( cm , TX_8X8 ) ;}reset_skip_txfm_size ( cm , TX_4X4 ) ;}reset_skip_txfm_size ( cm , TX_16X16 ) ;}cm -> interp_filter = get_interp_filter ( filter_thrs , is_alt_ref ) ;encode_frame_internal ( cpi ) ;",3
6,"if ( test_bit ( EV_KEY , dev -> evbit ) &&  ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) {","if ( old_keycode > KEY_MAX ) {dev_warn ( dev -> dev . parent ? : & dev -> dev , ""%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\\}else if ( test_bit ( EV_KEY , dev -> evbit ) && ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) {",4
7,if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  goto out_nofree ;if ( addr_len ) * addr_len = sizeof ( sa ) ;,if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) goto out_nofree ;,5
8,"if ( msg -> msg_name != NULL )   memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ;out : skb_free_datagram ( sk , skb ) ;","if ( msg -> msg_name != NULL ) {memcpy ( msg -> msg_name , & sa , sizeof ( sa ) ) ;* addr_len = sizeof ( sa ) ;}out : skb_free_datagram ( sk , skb ) ;",5
9,if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) )  return CURLE_OUT_OF_MEMORY ;,if ( ( ulen > SIZE_T_MAX / 4 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;,6
10,"if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;","if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;",7
11,saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;,saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,8
12,"FILE * fp = fopen ( dest_filename , ""w"" ) ;if ( ! fp ) return false ;","FILE * fp = fopen ( dest_filename , ""wx"" ) ;if ( ! fp ) return false ;",9
13,"* low = p - reg -> dmax ;if ( * low > s ) {if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc ,  ( pprev ? pprev : str ) , * low ) ;}","if ( p - str < reg -> dmax ) {* low = ( UChar * ) str ;if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ;}}else {* low = p - reg -> dmax ;if ( * low > s ) {if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ;}",10
14,"if ( hrtimer_cancel ( timer ) )  hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;}","mutex_lock ( & pit -> pit_state . lock ) ;if ( hrtimer_cancel ( timer ) ) hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;mutex_unlock ( & pit -> pit_state . lock ) ;}",11
15,vpx_roi_map_t roi = {0 };roi . rows = ( cfg -> g_h + 15 ) / 16 ;,"vpx_roi_map_t roi ;memset ( & roi , 0 , sizeof ( roi ) ) ;roi . rows = ( cfg -> g_h + 15 ) / 16 ;",12
16,"static const char * parse_object ( cJSON * item , const char * value )  {ep = value ;return 0 ;' )  return value + 1 ;if ( ! ( item -> child = child = cJSON_New_Item ( ) ) )  return 0 ;if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) )  return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ;child -> next = new_item ;new_item -> prev = child ;child = new_item ;if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) )  return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ;' )  return value + 1 ;ep = value ;","static const char * parse_object ( cJSON * item , const char * value , const char * * ep ) {* ep = value ;return 0 ;' ) return value + 1 ;item -> child = child = cJSON_New_Item ( ) ) ) return 0 ;if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) ) return 0 ;ep = value ;return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ;if ( ! item -> child ) return 0 ;value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) ) return 0 ;* ep = value ;return 0 ;value = skip ( parse_value ( child , skip ( value + 1 ) , ep ) ) ;if ( ! value ) return 0 ;' ) return value + 1 ;* ep = value ;",13
17,"
","if ( s -> image_offset_x || s -> image_offset_y ) {avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ;return AVERROR_PATCHWELCOME ;}",14
18,ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,14
19,"addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ;}","addModuleArgument ( pParse , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ;}",15
20,return 0 ;},av_freep ( & x -> buf ) ;x -> buf_size = 0 ;return 0 ;},16
21,"new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;","new_fname = safe_calloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ;snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ;",17
22,break ;},if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;break ;},18
23,"strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ;","strncpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ;",19
24,"void imap_quote_string ( char * dest , size_t dlen , const char * src )  {static const char quote [ ] = ""\\\\""\\\\\\\\"" ;","void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) {const char * quote = ""`\\\\""\\\\\\\\"" ;if ( ! quote_backtick ) quote ++ ;",20
25,"int r ;if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ;for ( ;if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) {","int r , dontmax = 0 ;if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ;if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) {st . st_size = 64 * 1024 ;dontmax = 1 ;}if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;for ( ;if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) {",21
26,if ( params -> buffer . fragment_size == 0 ||  params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size )  return - EINVAL ;,if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > INT_MAX / params -> buffer . fragment_size ) return - EINVAL ;,22
27,"memcpy ( output , input , sizeof ( uint8_t ) * length ) ;return ;","memcpy ( output , input , sizeof ( output [ 0 ] ) * length ) ;return ;",23
28,if ( vcpu -> arch . time_page ) {kvm_release_page_dirty ( vcpu -> arch . time_page ) ;vcpu -> arch . time_page = NULL ;},vcpu -> arch . pv_time_enabled = false ;,24
29,"handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ;if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ;data . allocation . handle = handle -> id ;cleanup_handle = handle ;break ;case ION_IOC_FREE : {struct ion_handle * handle ;handle = ion_handle_get_by_id ( client , data . handle . handle ) ;if ( IS_ERR ( handle ) )  return PTR_ERR ( handle ) ;ion_free ( client , handle ) ;ion_handle_put ( handle ) ;","mutex_lock ( & client -> lock ) ;handle = ion_handle_get_by_id_nolock ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ;if ( IS_ERR ( handle ) ) {mutex_unlock ( & client -> lock ) ;return PTR_ERR ( handle ) ;ion_free_nolock ( client , handle ) ;ion_handle_put_nolock ( handle ) ;mutex_unlock ( & client -> lock ) ;",25
30,int data_len = elt -> length -   sizeof ( struct oz_get_desc_rsp ) + 1 ;u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;,"u16 offs , total_size ;u8 data_len ;if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ;data_len = elt -> length - ( sizeof ( struct oz_get_desc_rsp ) - 1 ) ;offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;",26
31,"
","case OZ_SET_CONFIG_RSP : {struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_SET_INTERFACE_RSP : {struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_VENDOR_CLASS_RSP : {struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ;}break ;",26
32,"growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;","growBuffer ( buffer , i + XML_PARSER_BUFFER_SIZE ) ;",27
33,"growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;}","growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ;}",27
34,if ( len < 5 )   return len ;b -> opcode = 0xe9 ;,"if ( len < 5 ) {# ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\\# endif return len ;}b -> opcode = 0xe9 ;",28
35,continue ;},buffer_size -= ( size_t ) pkg_length ;continue ;},29
36,continue ;},buffer_size -= ( size_t ) pkg_length ;continue ;},29
37,}},buffer_size -= ( size_t ) pkg_length ;}},29
38,mapping = ( struct address_space * ) page_private ( page ) ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping ;mutex_lock ( & mapping -> i_mmap_mutex ) ;,30
39,"void fdct16_8col ( __m128i * in ) {__m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ;const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ;","static void fdct16_8col ( __m128i * in ) {__m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ;const __m128i k__cospi_p08_m24 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_8_64 , - cospi_24_64 ) ;const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ;",31
40,"i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ;i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ;i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ;i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ;i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ;i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ;s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ;s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ;s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ;s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ;s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ;s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ;s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ;s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ;p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ;p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ;p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ;p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ;p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ;p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ;p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ;p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ;u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ;u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ;u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ;u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ;v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ;v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ;v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ;v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ;u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ;u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ;u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ;u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ;u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ;","i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , k__cospi_p24_p08 ) ;",31
41,"v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ;u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ;u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ;u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ;u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ;u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ;v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ;v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ;v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ;v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ;in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ;in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ;in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ;u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ;u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ;u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ;u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ;v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ;u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ;u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ;u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ;u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ;v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ;v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ;v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ;v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ;v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ;v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ;v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ;v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ;t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ;t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ;t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ;t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ;p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ;p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ;p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ;p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ;p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ;p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ;p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ;p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ;u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ;u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ;u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ;u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ;v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ;v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ;v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ;v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ;u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ;u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;","v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p24_p08 ) ;v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ;v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ;v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ;u [ 2 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ;",31
42,"s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ;","s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ;s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ;",31
43,"
",if ( avio_feof ( pb ) ) {return AVERROR_EOF ;},32
44,"if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\","if ( pes_signal != 1 || pes_header_data_length == 0 ) {pva_log ( s , AV_LOG_WARNING , ""expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>"" ""trying<S2SV_blank>to<S2SV_blank>recover\\\",32
45,newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;,33
46,newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,newnp -> pktoptions = NULL ;newnp -> opt = NULL ;,33
47,"long elements ;elements = parse_iv2 ( ( * p ) + 2 , p ) ;( * p ) += 2 ;if ( ce -> serialize == NULL ) {object_init_ex ( * rval , ce ) ;else {zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\\\'%s\\\'"" , ce -> name ) ;return 0 ;}","long elements ;if ( * p >= max - 2 ) {zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ;return - 1 ;",34
48,trace_kvm_emulate_insn_failed ( vcpu ) ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;,trace_kvm_emulate_insn_failed ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0 ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;,35
49,auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;,"if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) {kfree_skb ( chunk -> auth_chunk ) ;sctp_association_free ( new_asoc ) ;return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ;}auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;",36
50,params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;",37
51,"declen = mutt_b64_decode ( out2 , out1 ) ;if ( ! TEST_CHECK ( declen == - 1 ) ) {","declen = mutt_b64_decode ( out2 , out1 , sizeof ( out2 ) ) ;if ( ! TEST_CHECK ( declen == - 1 ) ) {",38
52,"declen = mutt_b64_decode ( out2 , out1 ) ;if ( ! TEST_CHECK ( declen == i ) ) {","declen = mutt_b64_decode ( out2 , out1 , sizeof ( out2 ) ) ;if ( ! TEST_CHECK ( declen == i ) ) {",38
53,"RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ;RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ;RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ;RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ;RANGE_CHECK_HI ( cfg , g_profile , 3 ) ;","RANGE_CHECK ( cfg , g_w , 1 , 1000000000 ) ;RANGE_CHECK_HI ( cfg , g_profile , 3 ) ;",39
54,"RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ;","RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ;RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 ) ;if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ;",39
55,"i ++ )  if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] )  ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ;","i ++ ) if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] && cfg -> rc_target_bitrate > 0 ) ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing"" ) ;",39
56,"if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ;if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ;ret = 0 ;if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ;key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ;if ( IS_ERR ( key_ref ) ) {ret = PTR_ERR ( key_ref ) ;goto error ;}key = key_ref_to_ptr ( key_ref ) ;ret = - EACCES ;down_write ( & key -> sem ) ;if ( ! capable ( CAP_SYS_ADMIN ) ) {if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ;if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ;}if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) {ret = - ENOMEM ;newowner = key_user_lookup ( uid ) ;if ( ! newowner ) goto error_put ;if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) {unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ;unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ;spin_lock ( & newowner -> lock ) ;if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ;newowner -> qnkeys ++ ;newowner -> qnbytes += key -> quotalen ;spin_unlock ( & newowner -> lock ) ;spin_lock ( & key -> user -> lock ) ;key -> user -> qnkeys -- ;key -> user -> qnbytes -= key -> quotalen ;spin_unlock ( & key -> user -> lock ) ;}atomic_dec ( & key -> user -> nkeys ) ;atomic_inc ( & newowner -> nkeys ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {atomic_dec ( & key -> user -> nikeys ) ;",if ( key -> state != KEY_IS_UNINSTANTIATED ) {atomic_dec ( & key -> user -> nikeys ) ;,40
57,"long mtemp , save_adjust , rem ;s64 freq_adj ;","long mtemp , save_adjust ;s64 freq_adj ;",41
58,"time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ;","time_offset = div_s64 ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ;",41
59,"time_offset = div_long_long_rem_signed ( time_offset ,   NTP_INTERVAL_FREQ ,  & rem ) ;","time_offset = div_long_long_rem_signed ( time_offset , NTP_INTERVAL_FREQ ) ;",41
60,"
",ND_TCHECK_32BITS ( bp ) ;,42
61,temp = EXTRACT_32BITS ( bp ) ;bp += sizeof ( int32_t ) ;,temp = EXTRACT_32BITS ( bp ) ;bp += sizeof ( int32_t ) ;,42
62,if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;,if ( ( '%' == in ) && ( alloc > 2 ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {char hexstr [ 3 ] ;,43
63,size_t length ;uint_t i ;if ( segment -> dataOffset < 5 )  return NULL ;length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ;i = 0 ;if ( option -> kind == TCP_OPTION_NOP )  {continue ;}if ( option -> kind == TCP_OPTION_END ) break ;if ( ( i + 1 ) >= length || ( i + option -> length ) > length )  break ;return NULL ;},size_t i ;size_t length ;if ( segment -> dataOffset >= ( sizeof ( TcpHeader ) / 4 ) ) {length = ( segment -> dataOffset * 4 ) - sizeof ( TcpHeader ) ;i = 0 ;if ( option -> kind == TCP_OPTION_END ) {break ;}else if ( option -> kind == TCP_OPTION_NOP ) {}else {if ( ( i + 1 ) >= length ) break ;if ( option -> length < sizeof ( TcpOption ) || ( i + option -> length ) > length ) break ;}}return NULL ;},44
64,"double vp9_convert_qindex_to_q ( int qindex ) {return vp9_ac_quant ( qindex , 0 ) / 4.0 ;}","double vp9_convert_qindex_to_q ( int qindex , vpx_bit_depth_t bit_depth ) {# if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) {case VPX_BITS_8 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ;case VPX_BITS_10 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 16.0 ;case VPX_BITS_12 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 64.0 ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ;return - 1.0 ;}# else return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ;# endif }",45
65,if ( byte [ i ] & 0x40 )  i -- ;,if ( byte [ i ] & 0x40 && i > 0 ) i -- ;,46
66,if ( s -> pts == AV_NOPTS_VALUE ) {,if ( s -> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0 ) {,47
67,"if ( buf -> pts == AV_NOPTS_VALUE ) {return write_to_fifo ( s -> fifo , buf ) ;","if ( buf -> pts == AV_NOPTS_VALUE ) {return write_to_fifo ( s -> fifo , buf ) ;",47
68,parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;parameters -> prch_init [ i ] = 256 ;},if ( parameters -> numresolution == 1 ) {parameters -> res_spec = 1 ;parameters -> prcw_init [ 0 ] = 128 ;parameters -> prch_init [ 0 ] = 128 ;}else {parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;}parameters -> prch_init [ i ] = 256 ;},48
69,return ERROR_INV_SPS_PPS_T ;},return ERROR_INV_SLICE_HDR_T ;},49
70,"if ( ! setup_stratum_curl ( pool ) ) goto out ;resend : if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) {",if ( n2size < 1 ) {,50
71,"if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;","if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;",50
72,"for ( i = 0 ;i ++ )   nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;}if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {",51
73,# undef _  default : switch ( variable & 0xff ) {,_ ( NPPVpluginUrlRequestsDisplayedBool ) ;_ ( NPPVpluginWantsAllNetworkStreams ) ;_ ( NPPVpluginNativeAccessibleAtkPlugId ) ;_ ( NPPVpluginCancelSrcStream ) ;_ ( NPPVSupportsAdvancedKeyHandling ) ;# undef _ default : switch ( variable & 0xff ) {,52
74,"if ( level != SOL_PPPOL2TP )  return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ;if ( get_user ( len , optlen ) ) return - EFAULT ;","if ( level != SOL_PPPOL2TP ) return - EINVAL ;if ( get_user ( len , optlen ) ) return - EFAULT ;",53
75,"# ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}mysql_options ( & mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;# endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;","SSL_SET_OPTIONS ( & mysql ) ;if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",54
76,"if ( ipv6_hdr ( skb ) -> payload_len == 0 ) {pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\\return skb ;}if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ;clone = skb_clone ( skb , GFP_ATOMIC ) ;if ( clone == NULL ) {pr_debug ( ""Can\\\'t<S2SV_blank>clone<S2SV_blank>skb\\\return skb ;}NFCT_FRAG6_CB ( clone ) -> orig = skb ;if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) {pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\\goto ret_orig ;}skb_set_transport_header ( clone , fhoff ) ;hdr = ipv6_hdr ( clone ) ;fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ;if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) {pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\\goto ret_orig ;}","
",55
77,"if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS )  {enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ;enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ;enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ;return NO_ERROR ;","if ( enc624j600ReadReg ( interface , ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS ) {enc624j600WriteReg ( interface , ENC624J600_EGPWRPT , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteBuffer ( interface , ENC624J600_ETXST , ENC624J600_TX_BUFFER_START ) ;enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ;enc624j600ClearBit ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF ) ;enc624j600SetBit ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS ) ;return NO_ERROR ;",56
78,native_handle_t * h = malloc (   sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ;if ( h ) {,if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) {return NULL ;}size_t mallocSize = sizeof ( native_handle_t ) + ( sizeof ( int ) * ( numFds + numInts ) ) ;native_handle_t * h = malloc ( mallocSize ) ;if ( h ) {,57
79,"static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 )   {psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ;psf -> header [ psf -> headindex ++ ] = x ;};}","static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x ) {psf -> header ) - 3 ) {psf -> header . ptr [ psf -> header . ptr [ psf -> headindex ++ ] = x ;}",58
80,ptr = p + 2 ;},ptr = p + 3 ;},59
81,"if ( pmd_none ( * pmd ) ) {if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ;if ( err ) break ;continue ;}if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ;if ( err ) break ;if ( ! walk -> pte_entry ) continue ;split_huge_page_pmd ( walk -> mm , pmd ) ;if ( pmd_none_or_clear_bad ( pmd ) )  goto again ;",if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) goto again ;,60
82,"while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 )  {","while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) {",61
83,"else if ( ! ctx -> iface || ! ctx -> priv || ! ctx -> iface -> ctrl_maps ) res = VPX_CODEC_ERROR ;else {vpx_codec_ctrl_fn_map_t * entry ;res = VPX_CODEC_ERROR ;for ( entry = ctx -> iface -> ctrl_maps ;entry && entry -> fn ;entry ++ ) {if ( ! entry -> ctrl_id || entry -> ctrl_id == ctrl_id ) {va_list ap ;va_start ( ap , ctrl_id ) ;res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ;va_end ( ap ) ;","else if ( ! ctx -> iface || ! ctx -> priv , ap ) ;va_end ( ap ) ;",62
84,"isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;","isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;",63
85,"# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE &&  * p == SSL3_MT_CLIENT_HELLO ) &&  ! dtls1_record_replay_check ( s , bitmap ) ) {","# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) {",64
86,"d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ;if ( ! d ) return NULL ;","d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr , true ) ;if ( ! d ) return NULL ;",65
87,ue -> info = * info ;ue -> info . access = 0 ;,ue -> card = card ;ue -> info = * info ;ue -> info . access = 0 ;,66
88,}fpp = & fpl -> fp [ fpl -> count ] ;,fpl -> user = NULL ;}fpp = & fpl -> fp [ fpl -> count ] ;,67
89,return num ;},if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;return num ;},67
90,"u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;smin_val = src_reg . smin_value ;smax_val = src_reg . smax_value ;umin_val = src_reg . umin_value ;umax_val = src_reg . umax_value ;src_known = tnum_is_const ( src_reg . var_off ) ;dst_known = tnum_is_const ( dst_reg -> var_off ) ;if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}switch ( opcode ) {case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value += smin_val ;dst_reg -> smax_value += smax_val ;}if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value += umin_val ;dst_reg -> umax_value += umax_val ;}dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ;break ;case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value -= smax_val ;dst_reg -> smax_value -= smin_val ;}if ( dst_reg -> umin_value < umax_val ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value -= umax_val ;dst_reg -> umax_value -= umin_val ;}dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ;break ;case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ;if ( smin_val < 0 || dst_reg -> smin_value < 0 ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}break ;case BPF_AND : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = dst_reg -> var_off . value ;dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ;dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_LSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value <<= umin_val ;dst_reg -> umax_value <<= umax_val ;}dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ;__update_reg_bounds ( dst_reg ) ;break ;case BPF_RSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ;dst_reg -> umin_value >>= umax_val ;dst_reg -> umax_value >>= umin_val ;__update_reg_bounds ( dst_reg ) ;break ;case BPF_ARSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value >>= umin_val ;dst_reg -> smax_value >>= umin_val ;dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ;dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;__update_reg_bounds ( dst_reg ) ;break ;default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( & src_reg , 4 ) ;}",u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;if ( insn_bitness == 32 ) {},68
91,"error = copy_to_user ( buf , & socket_packet -> icmp_packet ,   socket_packet -> icmp_len ) ;packet_len = socket_packet -> icmp_len ;","packet_len = min ( count , socket_packet -> icmp_len ) ;error = copy_to_user ( buf , & socket_packet -> icmp_packet , packet_len ) ;",69
92,"READ ( data , msg . f . length )   if ( msg . f . length > sizeof ( data ) )  rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\\else   HandleFence ( cl , flags , msg . f . length , data ) ;return ;","if ( msg . f . length > sizeof ( data ) ) {rfbLog ( ""Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\\SKIP ( msg . f . length ) }else {READ ( data , msg . f . length ) HandleFence ( cl , flags , msg . f . length , data ) ;}return ;",70
93,uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ( cc % ( bps * stride ) ) != 0 ) {if ( ! tmp )  return 0 ;,uint8 * tmp ;if ( ( cc % ( bps * stride ) ) != 0 ) {tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ! tmp ) return 0 ;,71
94,"spin_lock_irq ( & tu -> qlock ) ;while ( ( long ) count - result >= unit ) {while ( ! tu -> qused ) {wait_queue_t wait ;if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) {err = - EAGAIN ;goto _error ;}set_current_state ( TASK_INTERRUPTIBLE ) ;init_waitqueue_entry ( & wait , current ) ;add_wait_queue ( & tu -> qchange_sleep , & wait ) ;spin_unlock_irq ( & tu -> qlock ) ;schedule ( ) ;spin_lock_irq ( & tu -> qlock ) ;",mutex_lock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;mutex_unlock ( & tu -> ioctl_lock ) ;schedule ( ) ;mutex_lock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;,72
95,"mutex_lock ( & tu -> ioctl_lock ) ;if ( tu -> tread ) {else {if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ;}mutex_unlock ( & tu -> ioctl_lock ) ;spin_lock_irq ( & tu -> qlock ) ;return result > 0 ? result : err ;}",if ( tu -> tread ) {spin_lock_irq ( & tu -> qlock ) ;mutex_unlock ( & tu -> ioctl_lock ) ;return result > 0 ? result : err ;},72
96,avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;while ( len && avail && * old ) {,if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;while ( len && avail && * old ) {,73
97,"int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) {const char * cbuf = buf ;int sent = send ( conn -> sock , cbuf , len , flags ) ;if ( sent == - 1 ) {","int mongo_env_write_socket ( mongo * conn , const void * buf , size_t len ) {const char * cbuf = buf ;size_t sent = send ( conn -> sock , cbuf , len , flags ) ;if ( sent == - 1 ) {",74
98,"uint32_t qttag , qtsize32 , len ;int32_t nest = 0 ;","uint32_t qttag , qtsize32 ;size_t len ;int32_t nest = 0 ;",75
99,"LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ;NESTSIZE ( lastsize - 8 ) ;","LongSeek ( mp4 , lastsize - 8 - 8 , SEEK_CUR ) ;NESTSIZE ( lastsize - 8 ) ;",75
100,"LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;","LongSeek ( mp4 , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;",75
101,"mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ;mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ;mp4 -> metasize_count = 1 ;return ( size_t ) mp4 ;}if ( qttag != MAKEID ( \'m\' , \'o\' , \'o\' , \'v\' ) && qttag != MAKEID ( \'u\' , \'d\' , \'t\' , \'a\' ) ) {LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;",mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ) ;NESTSIZE ( qtsize ) ;,75
102,"struct sk_buff * skb ;skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ;if ( dump_one_state ( x , 0 , & info ) ) {kfree_skb ( skb ) ;return NULL ;}","struct sk_buff * skb ;int err ;skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ;err = dump_one_state ( x , 0 , & info ) ;if ( err ) {kfree_skb ( skb ) ;return ERR_PTR ( err ) ;}",76
103,"len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ;if ( len == - 1 ) {","len = mutt_b64_decode ( obuf , idata -> buf + 2 , sizeof ( obuf ) ) ;if ( len == - 1 ) {",77
104,"UWORD16 u2_first_mb_in_slice , u2_frame_num ;UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ;UWORD32 u4_idr_pic_id = 0 ;UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ;UWORD8 u1_nal_unit_type ;UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ;UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ;WORD8 i1_is_end_of_poc ;WORD32 ret , end_of_frame ;WORD32 prev_slice_err , num_mb_skipped ;UWORD8 u1_mbaff ;pocstruct_t * ps_cur_poc ;UWORD32 u4_temp ;WORD32 i_temp ;UWORD32 u4_call_end_of_pic = 0 ;ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ;u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) {return ERROR_CORRUPTED_SLICE ;}if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) {return ERROR_CORRUPTED_SLICE ;}COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ;u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ;u1_slice_type = u4_temp ;COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ;ps_dec -> u1_sl_typ_5_9 = 0 ;if ( u1_slice_type > 4 ) {u1_slice_type -= 5 ;ps_dec -> u1_sl_typ_5_9 = 1 ;}{UWORD32 skip ;if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) {UWORD32 u4_bit_stream_offset = 0 ;if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) {skip = 0 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ;}else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) {skip = 0 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ;}else {skip = 1 ;}if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) {skip = 0 ;}if ( skip ) {ps_dec -> u4_prev_nal_skipped = 1 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ;return 0 ;}else {if ( 1 == ps_dec -> u4_prev_nal_skipped ) {ps_dec -> u4_return_to_app = 1 ;return 0 ;}}}}u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ;ps_pps = & ps_dec -> ps_pps [ u4_temp ] ;if ( FALSE == ps_pps -> u1_is_valid ) {return ERROR_INV_SLICE_HDR_T ;}ps_seq = ps_pps -> ps_sps ;if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ;if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ;u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ;if ( ! ps_seq -> u1_frame_mbs_only_flag )  {u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ;u1_bottom_field_flag = 0 ;",if ( i1_is_end_of_poc ) {ps_dec -> u1_first_slice_in_stream = 0 ;return ERROR_INCOMPLETE_FRAME ;},78
105,}u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;,}u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;,78
106,if ( ! ps_dec -> u1_first_slice_in_stream )  {,if ( ! ps_dec -> u1_first_slice_in_stream ) {,78
107,int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,struct address_space * mapping ;pgoff_t idx ;unsigned long size ;int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,79
108,"if ( vm_shared ) {struct address_space * mapping = dst_vma -> vm_file -> f_mapping ;pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;spin_lock ( ptl ) ;ret = - EEXIST ;","mapping = dst_vma -> vm_file -> f_mapping ;idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;if ( vm_shared ) {size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_nounlock ;spin_lock ( ptl ) ;size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_unlock ;ret = - EEXIST ;",79
109,"char query [ 1024 ] , * end ;MYSQL_RES * result ;end = strxmov ( query , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , db , ""`"" , NullS ) ;if ( wild && wild [ 0 ] )  strxmov ( end , ""<S2SV_blank>like<S2SV_blank>\\\'"" , wild , ""\\\'"" , NullS ) ;","char query [ NAME_LEN + 100 ] ;int len ;MYSQL_RES * result ;len = sizeof ( query ) ;len -= my_snprintf ( query , len , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`"" , db ) ;if ( wild && wild [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len , ""<S2SV_blank>like<S2SV_blank>\\\'"" , wild , ""\\\'"" , NullS ) ;",80
110,"unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ;unsigned char * y ;y_stride = 32 ;vfp -> copymem ( y_0 - 1 - pre_stride , pre_stride , xd -> y_buf , y_stride , 18 ) ;y = xd -> y_buf + y_stride + 1 ;# else unsigned char * y = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ;y_stride = pre_stride ;# endif  bestmv -> as_mv . row <<= 3 ;bestmv -> as_mv . col <<= 3 ;startmv = * bestmv ;",unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row *= 8 ;bestmv -> as_mv . col <<= 3 ;startmv = * bestmv ;,81
111,"this_mv . as_mv . col += 8 ;thismse = vfp -> svf_halfpix_h ( y , y_stride , z , b -> src_stride , & sse ) ;right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( right < bestmse ) {* bestmv = this_mv ;bestmse = right ;* distortion = thismse ;* sse1 = sse ;}this_mv . as_mv . col = startmv . as_mv . col ;this_mv . as_mv . row = ( ( startmv . as_mv . row - 8 ) | 4 ) ;thismse = vfp -> svf_halfpix_v ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ;up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( up < bestmse ) {* bestmv = this_mv ;bestmse = up ;* distortion = thismse ;* sse1 = sse ;}this_mv . as_mv . row += 8 ;thismse = vfp -> svf_halfpix_v ( y , y_stride , z , b -> src_stride , & sse ) ;down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( down < bestmse ) {* bestmv = this_mv ;bestmse = down ;* distortion = thismse ;* sse1 = sse ;}whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ;this_mv = startmv ;switch ( whichdir ) {case 0 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ;this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ;thismse = vfp -> svf_halfpix_hv ( y - 1 - y_stride , y_stride , z , b -> src_stride , & sse ) ;break ;case 1 : this_mv . as_mv . col += 4 ;this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ;thismse = vfp -> svf_halfpix_hv ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ;break ;case 2 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ;this_mv . as_mv . row += 4 ;thismse = vfp -> svf_halfpix_hv ( y - 1 , y_stride , z , b -> src_stride , & sse ) ;break ;case 3 : default : this_mv . as_mv . col += 4 ;this_mv . as_mv . row += 4 ;thismse = vfp -> svf_halfpix_hv ( y , y_stride , z , b -> src_stride , & sse ) ;break ;}diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ;if ( diag < bestmse ) {* bestmv = this_mv ;bestmse = diag ;* distortion = thismse ;* sse1 = sse ;}if ( bestmv -> as_mv . row < startmv . as_mv . row ) y -= y_stride ;if ( bestmv -> as_mv . col < startmv . as_mv . col ) y -- ;",this_mv . as_mv . col *= 8 ;,81
112,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,82
113,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",82
114,"error = scsi_nonblockable_ioctl ( sdp , cmd , p ,  ( mode & FMODE_NDELAY ) != 0 ) ;","error = scsi_verify_blk_ioctl ( bdev , cmd ) ;if ( error < 0 ) return error ;error = scsi_nonblockable_ioctl ( sdp , cmd , p , ( mode & FMODE_NDELAY ) != 0 ) ;",83
115,if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock )  return 0 ;,char * p ;int len ;if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ;,84
116,"if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) {truncate = 1 ;strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ;retnamlen += rr -> len - 5 ;break ;","len = rr -> len - 5 ) >= 254 ) {truncate = 1 ;p = memchr ( rr -> u . NM . name , len ) ;retnamlen += rr -> len - 5 ;break ;",84
117,VpxVideoWriter * writer = NULL ;vpx_codec_ctx_t codec ;vpx_fixed_buf_t stats = {0 };VpxVideoInfo info = {0 };const VpxInterface * encoder = NULL ;int pass ;,"int w , h ;vpx_codec_ctx_t codec ;vpx_fixed_buf_t stats ;const VpxInterface * encoder = NULL ;int pass ;",85
118,"info . codec_fourcc = encoder -> fourcc ;info . time_base . numerator = 1 ;info . time_base . denominator = fps ;info . frame_width = strtol ( width_arg , NULL , 0 ) ;info . frame_height = strtol ( height_arg , NULL , 0 ) ;if ( info . frame_width <= 0 ||   info . frame_height <= 0 ||   ( info . frame_width % 2 ) != 0 ||   ( info . frame_height % 2 ) != 0 ) {die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;}if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width ,   info . frame_height , 1 ) ) {die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;}","w = strtol ( width_arg , NULL , 0 ) ;info . frame_height = strtol ( height_arg , NULL , 0 ) ;if ( info . frame_width <= 0 || info . frame_height <= 0 || ( w % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ;}if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , w , h , 1 ) ) {die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ;}",85
119,"while ( vpx_img_read ( & raw , infile ) ) {++ frame_count ;if ( pass == 0 ) {get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;}else {encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;}}if ( pass == 0 ) {get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;}else {printf ( ""\\\}fclose ( infile ) ;printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\\","+ frame_count ;while ( vpx_img_read ( & raw ) ;fclose ( infile ) ;printf ( ""Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\\",85
120,if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ;if ( c -> string )  cJSON_free ( c -> string ) ;,if ( ! ( c -> type & cJSON_StringIsConst ) && ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ;if ( c -> string ) cJSON_free ( c -> string ) ;,86
121,void vp9_inc_frame_in_layer ( SVC * svc ) {LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 )  ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ;},void vp9_inc_frame_in_layer ( VP9_COMP * const cpi ) {LAYER_CONTEXT * const lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] ;++ lc -> frames_from_key_frame ;},87
122,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",88
123,"long rem ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;","u32 rem ;value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;value -> tv_usec = rem / NSEC_PER_USEC ;",89
124,"switch ( atype ) {case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;else {ND_TCHECK ( * tptr ) ;","
",90
125,"tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;","ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;",90
126,ExitLoop :  if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {,quantum_info = DestroyQuantumInfo ( quantum_info ) ;ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) {,91
127,skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == \'\\\,skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) && ! eof ( s ) ) ) if ( next ( s ) == \'\\\,92
128,"while ( peek ( s ) != \'>\' && ! eol ( s ) )  buf_append ( s , next ( s ) ) ;","while ( peek ( s ) != \'>\' && ! eol ( s ) ) buf_append ( s , next ( s ) ) ;",92
129,"enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ;}while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 )  {}enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ;sleep ( 1 ) ;if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 )  {","enc624j600WriteReg ( interface , ENC624J600_EUDAST , 0x1234 ) ;}while ( enc624j600ReadReg ( interface , ENC624J600_EUDAST ) != 0x1234 ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY ) == 0 ) {}enc624j600SetBit ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST ) ;sleep ( 1 ) ;if ( enc624j600ReadReg ( interface , ENC624J600_EUDAST ) != 0x0000 ) {",93
130,"if ( length < 2 ) return 0 ;elementlen = * ( p + offset + 1 ) ;if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ;if ( length < elementlen + 2 ) return 0 ;switch ( * ( p + offset ) ) {case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) )  return 0 ;","memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;",94
131,"if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) )  return 0 ;if ( length < challenge . length ) return 0 ;","
",94
132,"case E_RATES : memcpy ( & rates , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( rates . length != 0 ) {if ( rates . length > sizeof rates . rate ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) )  return 0 ;if ( length < rates . length ) return 0 ;memcpy ( & rates . rate , p + offset , rates . length ) ;offset += rates . length ;length -= rates . length ;}if ( ! pbody -> rates_present && rates . length != 0 ) {pbody -> rates = rates ;pbody -> rates_present = 1 ;}break ;case E_DS : memcpy ( & ds , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ds . length != 1 ) {offset += ds . length ;length -= ds . length ;break ;}ds . channel = * ( p + offset ) ;offset += 1 ;length -= 1 ;if ( ! pbody -> ds_present ) {pbody -> ds = ds ;pbody -> ds_present = 1 ;}break ;case E_CF : memcpy ( & cf , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( cf . length != 6 ) {offset += cf . length ;length -= cf . length ;break ;}memcpy ( & cf . count , p + offset , 6 ) ;offset += 6 ;length -= 6 ;if ( ! pbody -> cf_present ) {pbody -> cf = cf ;pbody -> cf_present = 1 ;}break ;case E_TIM : memcpy ( & tim , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( tim . length <= 3 ) {offset += tim . length ;length -= tim . length ;break ;}if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ;memcpy ( & tim . count , p + offset , 3 ) ;offset += 3 ;length -= 3 ;memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ;offset += tim . length - 3 ;","case E_RATES : memcpy ( & rates , p + offset , tim . length - 3 ) ;offset += tim . length - 3 ;",94
133,size_t e ;if ( c -> stack == NULL ) return ;,size_t e ;mrb_value nil ;if ( c -> stack == NULL ) return ;,95
134,if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) {c -> stbase [ i ] = mrb_nil_value ( ) ;}else {}},e = c -> stend - c -> stbase ;nil = mrb_nil_value ( ) ;for ( ;i < e ;i ++ ) {c -> stbase [ i ] = nil ;}},95
135,"if ( client -> ipc == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;","if ( client -> ipc == NULL && client -> session == NULL ) {crm_warn ( ""Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel"" ) ;",96
136,"
",if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;,97
137,"sk_wait_data ( sk , & timeo , NULL ) ;if ( signal_pending ( current ) ) {","sk_wait_data ( sk , & timeo , NULL ) ;if ( signal_pending ( current ) ) {",97
138,"ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 )  ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;""  ""<S2SV_blank>using<S2SV_blank>read-until-close"" , tenc ) ;return APR_EGENERAL ;}lenp = NULL ;","ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" , tenc ) ;return APR_EINVAL ;",98
139,return APR_ENOSPC ;},return APR_ENOSPC ;},98
140,if ( rv != APR_SUCCESS ) {return AP_FILTER_ERROR ;,apr_brigade_cleanup ( bb ) ;if ( rv != APR_SUCCESS ) {return AP_FILTER_ERROR ;,98
141,"case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT :  case BODY_CHUNK_END : {rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ;","case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF : {rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ;",98
142,"int merge_trailers =  conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ;return read_chunked_trailers ( ctx , f , b , merge_trailers ) ;","return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ) ;",98
143,break ;},"ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( int ) ctx -> state ) ;return APR_EGENERAL ;}",98
144,"if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ;len -= sizeof ( * id ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ;nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ;len -= sizeof ( * io ) * nid ;io = ( struct id_off * ) ( id + 1 ) ;cp = ( char * ) ( io + nid ) ;if ( ! ND_TTEST2 ( cp , len ) ) {ND_PRINT ( ( ndo , ""\\\\"""" ) ) ;","if ( ND_TTEST2 ( cp , len ) ) {ND_PRINT ( ( ndo , ""\\\\"""" ) ) ;",99
145,struct ipv6_txoptions * opt = NULL ;struct ip6_flowlabel * flowlabel = NULL ;,struct ipv6_txoptions * opt = NULL ;struct ipv6_txoptions * opt_to_free = NULL ;struct ip6_flowlabel * flowlabel = NULL ;,100
146,if ( ! opt )  opt = np -> opt ;,if ( ! opt ) {opt = txopt_get ( np ) ;opt_to_free = opt ;},100
147,fl6_sock_release ( flowlabel ) ;if ( ! err ) return len ;,fl6_sock_release ( flowlabel ) ;txopt_put ( opt_to_free ) ;if ( ! err ) return len ;,100
148,"umode_t mode = inode -> i_mode ;ret = posix_acl_equiv_mode ( acl , & mode ) ;if ( ret < 0 ) return ret ;","umode_t mode ;ret = posix_acl_update_mode ( inode , & mode ) ;if ( ret < 0 ) return ret ;",101
149,NUMA * na ;PIX * pixt ;,NUMA * na ;,102
150,"pixt = pixCopy ( NULL , pix ) ;goodcol = 0 ;",goodcol = 0 ;,102
151,"for ( j = goodcol - 1 ;j -- ) {pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j + 1 , 0 ) ;pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ;}pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j - 1 , 0 ) ;pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ;}pixDestroy ( & pixt ) ;","for ( j = goodcol - 1 ;j -- ) pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pix , j + 1 , 0 ) ;pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pix , j - 1 , 0 ) ;}",102
152,"u16 source_node_id ;u32 specifier_id ;u32 ver ;offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ;buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ;if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) dev -> broadcast_rcv_next_ptr = 0 ;spin_unlock_irqrestore ( & dev -> lock , flags ) ;specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8  | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ;ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ;source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ;if ( specifier_id == IANA_SPECIFIER_ID &&  ( ver == RFC2734_SW_VERSION  # if IS_ENABLED ( CONFIG_IPV6 )  || ver == RFC3146_SW_VERSION  # endif  ) ) {buf_ptr += 2 ;}packet . payload_length = dev -> rcv_buffer_size ;",if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) == IANA_SPECIFIER_ID && ( ver == RFC2734_SW_VERSION # if IS_ENABLED ( CONFIG_IPV6 ) || ver == RFC3146_SW_VERSION # endif ) ) {buf_ptr += 2 ;}packet . payload_length = dev -> rcv_buffer_size ;,103
153,"sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;if ( isk -> cmsg_flags )  ip_cmsg_recv ( msg , skb ) ;sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_port = 0 ;* addr_len = sizeof ( * sin6 ) ;if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;","if ( sin ) {sin -> sin_family = AF_INET ;sin -> sin_port = 0 ;}if ( isk -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;if ( sin6 ) {sin6 -> sin6_family = AF_INET6 ;sin6 -> sin6_port = 0 ;* addr_len = sizeof ( * sin6 ) ;}if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ;",104
154,"down_write ( & mm -> mmap_sem ) ;mutex_lock ( & ufile -> umap_lock ) ;list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) {","down_write ( & mm -> mmap_sem ) ;if ( ! mmget_still_valid ( mm ) ) goto skip_mm ;mutex_lock ( & ufile -> umap_lock ) ;skip_mm : list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) {",105
155,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,105
156,"guint uint_val = GST_READ_UINT32_LE ( value ) ;g_value_init ( & tag_value , G_TYPE_UINT ) ;gboolean bool_val = GST_READ_UINT32_LE ( value ) ;if ( strncmp ( ""Stereoscopic"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {","guint uint_val ;if ( value_len < 4 ) break ;uint_val = GST_READ_UINT32_LE ( value ) ;g_value_init ( & tag_value , G_TYPE_UINT ) ;gboolean bool_val ;if ( value_len < 4 ) break ;bool_val = GST_READ_UINT32_LE ( value ) ;if ( strncmp ( ""Stereoscopic"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {",106
157,kk = malloc ( xsize * kmax * sizeof ( float ) ) ;if ( ! kk )  return ( Imaging ) ImagingError_MemoryError ( ) ;,if ( kmax > 0 && xsize > SIZE_MAX / kmax ) return ( Imaging ) ImagingError_MemoryError ( ) ;if ( xsize * kmax > SIZE_MAX / sizeof ( float ) ) return ( Imaging ) ImagingError_MemoryError ( ) ;kk = malloc ( xsize * kmax * sizeof ( float ) ) ;if ( ! kk ) return ( Imaging ) ImagingError_MemoryError ( ) ;if ( xsize > SIZE_MAX / ( 2 * sizeof ( int ) ) ) return ( Imaging ) ImagingError_MemoryError ( ) ;,107
158,countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ;newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ;,tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ;newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ;,108
159,"struct timespec ts ;if ( ! nsec ) return ( struct timespec ) {ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ;if ( unlikely ( nsec < 0 ) )   set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ;return ts ;","struct timespec ts ;s32 rem ;if ( ! nsec ) return ( struct timespec ) {ts . tv_sec = div_s64_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( unlikely ( nsec < 0 ) ) {ts . tv_sec , ts . tv_nsec ) ;return ts ;",109
160,"default :  buffer = malloc ( msg . tc . length + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) {","default : if ( msg . tc . length > MAX_TEXTCHAT_SIZE ) return FALSE ;buffer = malloc ( msg . tc . length + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) {",110
161,"rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ;rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ;rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ;","rb_define_singleton_method ( klass , ""read_memory"" , read_memory , - 1 ) ;rb_define_singleton_method ( klass , ""from_document"" , from_document , - 1 ) ;rb_define_private_method ( klass , ""validate_document"" , validate_document , 1 ) ;",111
162,"static void nsc_encode_subsampling ( NSC_CONTEXT * context )  {BYTE * co_dst ;BYTE * cg_dst ;INT8 * co_src0 ;INT8 * co_src1 ;INT8 * cg_src0 ;INT8 * cg_src1 ;UINT32 tempHeight ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;for ( y = 0 ;y ++ )  {co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;co_src1 = co_src0 + tempWidth ;cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;cg_src1 = cg_src0 + tempWidth ;for ( x = 0 ;","static BOOL nsc_encode_subsampling ( NSC_CONTEXT * context ) {UINT32 tempHeight ;if ( ! context ) return FALSE ;tempWidth = ROUND_UP_TO ( context -> width , 8 ) ;if ( tempHeight == 0 ) return FALSE ;if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ;for ( y = 0 ;y ++ ) {BYTE * co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ;BYTE * cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ;const INT8 * co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ;const INT8 * co_src1 = co_src0 + tempWidth ;const INT8 * cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ;const INT8 * cg_src1 = cg_src0 + tempWidth ;for ( x = 0 ;",112
163,},return TRUE ;},112
164,int iSrc ;res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;,int iSrc ;,113
165,for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},113
166,"if ( hrtimer_cancel ( timer ) )  hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;}","mutex_lock ( & pit -> pit_state . lock ) ;if ( hrtimer_cancel ( timer ) ) hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ;mutex_unlock ( & pit -> pit_state . lock ) ;}",114
167,"FILE * file = NULL ;ASSERT ( idfile ) ;md5_context_t ctx ;char buf [ STRLEN ] ;snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ;md5_init ( & ctx ) ;fprintf ( file , ""%s"" , Run . id ) ;LogInfo ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\\LogError ( ""idfile<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\\\return NULL ;}if ( ( file = fopen ( idfile , ""r"" ) ) == ( FILE * ) NULL ) {","ASSERT ( idfile ) ;FILE * file = NULL ;md5_context_t ctx ;char buf [ STRLEN ] ;snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ;md5_init ( & ctx ) ;fprintf ( file , ""%s"" , Run . id ) ;LogInfo ( ""<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\\file = fopen ( idfile , ""r"" ) ) == ( FILE * ) NULL ) {",115
168,"aptr += RRFIXEDSZ ;if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) {","aptr += RRFIXEDSZ ;if ( aptr + rr_len > abuf + alen ) {free ( rr_name ) ;status = ARES_EBADRESP ;break ;}if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) {",116
169,hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ;lf = fwnet_get_hdr_lf ( & hdr ) ;,if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ;hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ;lf = fwnet_get_hdr_lf ( & hdr ) ;,117
170,hdr . w1 = ntohl ( buf [ 1 ] ) ;buf += 2 ;,if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ;hdr . w1 = ntohl ( buf [ 1 ] ) ;buf += 2 ;if ( fg_off + len > dg_size ) return 0 ;,117
171,"spin_lock_irqsave ( & dev -> lock , flags ) ;peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ;","spin_lock_irqsave ( & dev -> lock , flags ) ;peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ;",117
172,"if ( ( mask & ~ ALL_PRINC_MASK ) )  return KADM5_BAD_MASK ;ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;","if ( mask & KADM5_TL_DATA ) {for ( tl_data_tail = entry -> tl_data ;tl_data_tail != NULL ;tl_data_tail = tl_data_tail -> tl_data_next ) {if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ;}}if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;",118
173,"static int em_jcxz ( struct x86_emulate_ctxt * ctxt )  {if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 )  jmp_rel ( ctxt , ctxt -> src . val ) ;return X86EMUL_CONTINUE ;}","static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) {int rc = X86EMUL_CONTINUE ;if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;return rc ;}",119
174,if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ;if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ;else mnt -> mnt_group_id = old -> mnt_group_id ;if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) {err = mnt_alloc_group_id ( mnt ) ;if ( err ) goto out_free ;mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ;if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) )  mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) )  mnt -> mnt . mnt_flags |= MNT_LOCKED ;,if ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ;if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ;if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ;if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) mnt -> mnt . mnt_flags |= MNT_LOCKED ;,120
175,"if ( ! f ) {if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) {warn ( ""write<S2SV_blank>%s:"" , name ) ;","if ( s && ( ! f ) {if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) ) {warn ( ""write<S2SV_blank>%s:"" , name ) ;",121
176,"if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL )  {",if ( ( psf = psf_allocate ( ) ) == NULL ) {,122
177,box -> len = len ;if ( box -> len == 1 ) {,"box -> len = len ;JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\if ( box -> len == 1 ) {box -> ops = & jp2_boxinfo_unk . ops ;",123
178,"jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;","jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;",123
179,"count = yr_max ( 64 , ( index + 1 ) * 2 ) ;array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc (  array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;","count = 64 ;while ( count <= index ) count *= 2 ;array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;while ( count <= index ) count *= 2 ;array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;",124
180,if ( len == 6 ) {,if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && len == 6 ) {,125
181,"if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 )  ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ;else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 )  ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ;","if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ;else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ;",125
182,"ND_TCHECK2 ( dp [ 0 ] , 0 ) ;astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ;","ND_TCHECK ( dp [ 0 ] , 0 ) ;astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ;",126
183,"if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ;if ( copy > size ) {++ from ;-- count ;offset = 0 ;}else offset += size ;copy -= size ;offset1 += size ;}if ( len == offset1 ) return 0 ;while ( count -- ) {struct page * page [ MAX_SKB_FRAGS ] ;int num_pages ;unsigned long base ;unsigned long truesize ;len = from -> iov_len - offset ;if ( ! len ) {offset = 0 ;++ from ;continue ;}base = ( unsigned long ) from -> iov_base + offset ;size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ;num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ;if ( ( num_pages != size ) ||  ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) {",+ from ;+ from ;if ( num_pages != size ) || ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) {,127
184,"buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ;buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ;","if ( uri_ptr [ alias_len ] == '.' ) {char * s = uri_ptr + alias_len + 1 ;if ( * s == '.' ) ++ s ;if ( * s == '/' || * s == '\\\\0' ) {size_t vlen = buffer_string_length ( ds -> value ) ;if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) {con -> http_status = 403 ;return HANDLER_FINISHED ;}}}buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ;buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ;",128
185,"size_t buf_size = 0 ;if ( ! sock || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_sendv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {done :  if ( buf ) oe_free ( buf ) ;","size_t buf_size = 0 ;size_t data_size = 0 ;if ( ! sock || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_sendv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : if ( buf ) oe_free ( buf ) ;",129
186,out_err :  kfree ( init_name ) ;return rv ;,out_err : if ( rv && new_smi -> io . io_cleanup ) {new_smi -> io . io_cleanup ( & new_smi -> io ) ;new_smi -> io . io_cleanup = NULL ;}kfree ( init_name ) ;return rv ;,130
187,# endif  # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ;,# endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;# ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ;,131
188,len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 ;len = args -> len = ntohl ( * p ++ ) ;if ( args -> count != args -> len ) return 0 ;,132
189,"if ( ! ( info = bmp_getinfo ( in ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\\}if ( ! bmp_issupported ( & hdr , info ) ) {","JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\\if ( ! ( info = bmp_getinfo ( in ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\\}JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\\if ( ! bmp_issupported ( & hdr , info ) ) {",133
190,"case IPOPT_TS :  ip_printts ( ndo , cp , option_len ) ;break ;case IPOPT_RA :  if ( option_len < 4 ) {","case IPOPT_TS : if ( ip_printts ( ndo , cp , option_len ) ;break ;case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ;break ;case IPOPT_RA : if ( option_len < 4 ) {",134
191,numSamples = pWTIntFrame -> numSamples ;pOutputBuffer = pWTIntFrame -> pAudioBuffer ;,"numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pOutputBuffer = pWTIntFrame -> pAudioBuffer ;",135
192,"u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr ,  iph -> protocol ,  ip_idents_hashrnd ) ;","static u32 ip_idents_hashrnd_extra __read_mostly ;u32 hash , id ;net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ;net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra ) ) ;hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol ^ ip_idents_hashrnd_extra , ip_idents_hashrnd ) ;",136
193,"strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ;strncpy ( extra_response -> value , NOTUNDERSTOOD ,  strlen ( NOTUNDERSTOOD ) + 1 ) ;list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ;","strlcpy ( extra_response -> key , key , sizeof ( extra_response -> key ) ) ;strlcpy ( extra_response -> value , NOTUNDERSTOOD , sizeof ( extra_response -> value ) ) ;list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ;",137
194,"static int override_release ( char __user * release , int len )  {int ret = 0 ;char buf [ 65 ] ;char * rest = UTS_RELEASE ;int ndots = 0 ;unsigned v ;while ( * rest ) {snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ;ret = copy_to_user ( release , buf , len ) ;}","static int override_release ( char __user * release , size_t len ) {int ret = 0 ;const char * rest = UTS_RELEASE ;char buf [ 65 ] = {0 };int ndots = 0 ;unsigned v ;size_t copy ;while ( * rest ) {copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ;copy = scnprintf ( buf , copy , ""2.6.%u%s"" , v , rest ) ;ret = copy_to_user ( release , buf , copy + 1 ) ;}",138
195,if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_gmac_stats_string ) ;,if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_gmac_stats_string ) ;,139
196,"struct rdcost_block_args args = {0 };args . x = x ;args . use_fast_coef_costing = use_fast_coef_casting ;if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ;if ( args . skip ) {* rate = INT_MAX ;* skippable = 0 ;else {* distortion = args . this_dist ;* rate = args . this_rate ;* sse = args . this_sse ;* skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ;}",struct rdcost_block_args args ;vp9_zero ( args ) ;args . x = x ;args . use_fast_coef_costing = use_fast_coef_casting ;args . skippable = 1 ;if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ;if ( args . exit_early ) {* rate = INT_MAX ;* skippable = args . skippable ;,140
197,"len = strlen ( ""/lock/lxc/"" ) + strlen ( n ) + strlen ( p ) + 3 ;rundir = get_rundir ( ) ;ret = snprintf ( dest , len , ""%s/lock/lxc/%s"" , rundir , p ) ;if ( ret < 0 || ret >= len ) {int l2 = 22 + strlen ( n ) + strlen ( p ) ;if ( l2 > len ) {free ( rundir ) ;","len = strlen ( ""/lxc/lock/"" ) + strlen ( n ) + strlen ( p ) + 3 ;rundir = get_rundir ( ) ;ret = snprintf ( dest , len , ""%s/lxc/lock/%s"" , rundir , p ) ;if ( ret < 0 || ret >= len ) {free ( dest ) ;free ( rundir ) ;return NULL ;}ret = snprintf ( dest , len , ""%s/lxc/lock/%s/.%s"" , rundir , p , n ) ;free ( rundir ) ;if ( l2 > len ) {",141
198,free ( rundir ) ;return NULL ;,free ( rundir ) ;return NULL ;,141
199,struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;,struct flowi6 * fl6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ;fl6 = & inet -> cork . fl . u . ip6 ;,142
200,"endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ;","if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\\err = - EINVAL ;goto fail3 ;}endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ;",143
201,goto fail3 ;},err = - EINVAL ;goto fail3 ;},143
202,"GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ;if ( ptr -> esd ) {gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ;ptr -> esd = NULL ;","extern Bool use_dump_mode ;GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ;if ( ptr -> esd ) {if ( ! use_dump_mode ) gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ;ptr -> esd = NULL ;",144
203,if ( * pStackPtr >= CDL_STACK_SIZE )   return EAS_ERROR_FILE_FORMAT ;* pStackPtr = * pStackPtr + 1 ;,"if ( * pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) {ALOGE ( ""b/34031018,<S2SV_blank>stackPtr(%d)"" , * pStackPtr ) ;android_errorWriteLog ( 0x534e4554 , ""34031018"" ) ;return EAS_ERROR_FILE_FORMAT ;}* pStackPtr = * pStackPtr + 1 ;",145
204,"memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}","memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) | txp -> offset ) , data_len ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",146
205,"}else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) {s -> filesize = strtoll ( p , NULL , 10 ) ;}","}else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == UINT64_MAX ) {s -> filesize = strtoll ( p , NULL , 10 ) ;}",147
206,"s -> filesize = - 1 ;s -> chunksize = 0 ;}else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) {ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) {ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) {ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) {if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ;","s -> filesize = strtoull ( p , ""close"" ) ) s -> willclose = 1 ;",147
207,"s -> icy_metaint = strtoll ( p , NULL , 10 ) ;}","s -> icy_metaint = strtoull ( p , NULL , 10 ) ;}",147
208,"
",mutt_socket_empty ( conn ) ;,148
209,"}if ( ! mutt_str_startswith ( buf , ""382"" , CASE_MATCH ) ) {","}if ( ! mutt_str_startswith ( buf , ""382"" , CASE_MATCH ) ) {",148
210,"outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ;}LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ;LineTo ( - length * 0.5 , - arrow . width ) ;outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ;}","send ( ""<S2SV_blank>h<S2SV_blank>f"" ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ;}send ( ""<S2SV_blank>h<S2SV_blank>f"" ) ;}",149
211,# endif  numSamples = pWTIntFrame -> numSamples ;pMixBuffer = pWTIntFrame -> pMixBuffer ;,"# endif numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pMixBuffer = pWTIntFrame -> pMixBuffer ;",150
212,char added ;},},151
213,"const char * name = d -> name ;struct device dev = d -> udev -> dev ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\dvb_usbv2_exit ( d ) ;dev_info ( & dev , ""%s:<S2SV_blank>\\\'%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}","const char * devname = kstrdup ( dev_name ( & d -> udev -> dev ) , GFP_KERNEL ) ;const char * drvname = d -> name ;dev_dbg ( & d -> udev -> dev , ""%s:<S2SV_blank>bInterfaceNumber=%d\\\pr_info ( ""%s:<S2SV_blank>\\\'%s:%s\\\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\\}",152
214,"list_del ( & key -> graveyard_link ) ;kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) &&  ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ;","short state = key -> state ;list_del ( & key -> graveyard_link ) ;kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ;if ( state == KEY_IS_POSITIVE && key -> type -> destroy ) key -> type -> destroy ( key ) ;",153
215,"if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) )  atomic_dec ( & key -> user -> nikeys ) ;",if ( state != KEY_IS_UNINSTANTIATED ) atomic_dec ( & key -> user -> nikeys ) ;,153
216,"REQ ( n , for_stmt ) ;if ( NCH ( n ) == 9 ) {seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ;if ( ! seq ) return NULL ;","int has_type_comment ;string type_comment ;REQ ( n , for_stmt ) ;has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT ;if ( NCH ( n ) == 9 + has_type_comment ) {seq = ast_for_suite ( c , CHILD ( n , 8 + has_type_comment ) ) ;if ( ! seq ) return NULL ;",154
217,"suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ;if ( ! suite_seq ) return NULL ;if ( is_async )   return AsyncFor ( target , expression , suite_seq , seq ,  LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else  return For ( target , expression , suite_seq , seq ,  LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;","suite_seq = ast_for_suite ( c , CHILD ( n , 5 + has_type_comment ) ) ;if ( ! suite_seq ) return NULL ;if ( has_type_comment ) {type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ;if ( ! type_comment ) return NULL ;}else type_comment = NULL ;if ( is_async ) return AsyncFor ( target , expression , suite_seq , seq , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;else return For ( target , expression , suite_seq , seq , type_comment , LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ;",154
218,"if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ||  uid_eq ( root_uid , current_uid ( ) ) ) {int mode = ( table -> mode >> 6 ) & 7 ;if ( gid_eq ( root_gid , current_gid ( ) ) ) {int mode = ( table -> mode >> 3 ) & 7 ;","if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || uid_eq ( root_uid , current_euid ( ) ) ) {int mode = ( table -> mode >> 6 ) & 7 ;if ( in_egroup_p ( root_gid ) ) {int mode = ( table -> mode >> 3 ) & 7 ;",155
219,"
","( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;",156
220,MinVal = 0 ;MaxVal = 0 ;,MinVal = 0 ;MaxVal = 0 ;,156
221,mutex_lock ( & vdev -> vdev_mutex ) ;mutex_lock ( & vi -> vop_mutex ) ;,"if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) {ret = - EINVAL ;goto free_ret ;}mutex_lock ( & vdev -> vdev_mutex ) ;mutex_lock ( & vi -> vop_mutex ) ;",157
222,if ( bytecnt ) {wpc -> file_format = * byteptr ++ ;,if ( bytecnt >= 2 ) {wpc -> file_format = * byteptr ++ ;if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;,158
223,bytecnt -- ;},bytecnt -- ;},158
224,"if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ;cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ;if ( cur_node == 0 ) {if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>"" ""empty<S2SV_blank>extents<S2SV_blank>btree\\\free ( node ) ;return 1 ;}if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" ""root<S2SV_blank>node<S2SV_blank>%"" PRIu32 "";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%"" PRIu16 ""\\\is_done = 0 ;while ( is_done == 0 ) {TSK_OFF_T cur_off ;uint16_t num_rec ;ssize_t cnt ;hfs_btree_node * node_desc ;if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) {",if ( keylen >= nodesize - rec_off ) {,159
225,"if ( ( keylen ) > nodesize ) {tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ;tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%""  PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ;free ( node ) ;","if ( ( keylen ) > nodesize ) {tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ;tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , ( nodesize - rec_off ) ) ;free ( node ) ;",159
226,"if ( sock -> ops ) {struct module * owner = sock -> ops -> owner ;sock -> ops -> release ( sock ) ;sock -> ops = NULL ;module_put ( owner ) ;}if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list )  pr_err ( ""%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\\if ( ! sock -> file ) {iput ( SOCK_INODE ( sock ) ) ;return ;}sock -> file = NULL ;","__sock_release ( sock , NULL ) ;",160
227,lock_sock ( sk ) ;if ( ctx -> more ) {,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;if ( ctx -> more ) {,161
228,"ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ;ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ;return ;}","cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ;cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ;}",162
229,"# else fprintf ( stderr , ""WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\\\""%s\\\\""\\\# endif break ;}else if ( ! strcmp ( argv [ i ] , ""-p"" ) ) {if ( i + 1 < ( u32 ) argc ) gpac_profile = argv [ i + 1 ] ;else {fprintf ( stderr , ""Bad<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>-p,<S2SV_blank>expecting<S2SV_blank>profile<S2SV_blank>name<S2SV_blank>but<S2SV_blank>no<S2SV_blank>more<S2SV_blank>args\\\return 1 ;}}else if ( ! strncmp ( argv [ i ] , ""-p="" , 3 ) ) gpac_profile = argv [ i ] + 3 ;}# ifdef _TWO_DIGIT_EXPONENT _set_output_format ( _TWO_DIGIT_EXPONENT ) ;# endif gf_sys_init ( mem_track , gpac_profile ) ;if ( argc < 2 ) {fprintf ( stderr , ""Not<S2SV_blank>enough<S2SV_blank>arguments<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\\gf_sys_close ( ) ;return 0 ;}helpout = stdout ;i = mp4box_parse_args ( argc , argv ) ;if ( i ) {return mp4box_cleanup ( i - 1 ) ;}if ( ! inName && dump_std ) inName = ""std"" ;if ( ! inName ) {if ( has_next_arg ) {fprintf ( stderr , ""Broken<S2SV_blank>argument<S2SV_blank>specifier<S2SV_blank>or<S2SV_blank>file<S2SV_blank>name<S2SV_blank>missing<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\\}else {PrintUsage ( ) ;}return mp4box_cleanup ( 1 ) ;}if ( ! strcmp ( inName , ""std"" ) ) dump_std = 2 ;if ( ! strcmp ( inName , ""stdb"" ) ) {inName = ""std"" ;dump_std = 1 ;}if ( ! interleaving_time ) {if ( dash_duration ) interleaving_time = dash_duration ;else if ( ! do_flat ) {interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ;}}if ( dump_std ) outName = ""std"" ;if ( dump_std == 2 ) {# ifdef WIN32 if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == - 1 ) # else if ( freopen ( NULL , ""wb"" , stdout ) == NULL ) # endif {fprintf ( stderr , ""Fatal<S2SV_blank>error:<S2SV_blank>cannot<S2SV_blank>reopen<S2SV_blank>stdout<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>mode.\\\return mp4box_cleanup ( 1 ) ;}}# if ! defined ( GPAC_DISABLE_STREAMING ) && ! defined ( GPAC_DISABLE_SENG ) if ( live_scene ) {int ret = live_session ( argc , argv ) ;return mp4box_cleanup ( ret ) ;}# endif GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO ;gf_log_set_tool_level ( GF_LOG_CONTAINER , level ) ;gf_log_set_tool_level ( GF_LOG_SCENE , level ) ;gf_log_set_tool_level ( GF_LOG_PARSER , level ) ;gf_log_set_tool_level ( GF_LOG_AUTHOR , level ) ;gf_log_set_tool_level ( GF_LOG_CODING , level ) ;gf_log_set_tool_level ( GF_LOG_DASH , level ) ;# ifdef GPAC_MEMORY_TRACKING if ( mem_track ) gf_log_set_tool_level ( GF_LOG_MEMORY , level ) ;# endif e = gf_sys_set_args ( argc , ( const char * * ) argv ) ;if ( e ) {fprintf ( stderr , ""Error<S2SV_blank>assigning<S2SV_blank>libgpac<S2SV_blank>arguments:<S2SV_blank>%s\\\return mp4box_cleanup ( 1 ) ;}if ( raw_cat ) {char chunk [ 4096 ] ;FILE * fin , * fout ;s64 to_copy , done ;fin = gf_fopen ( raw_cat , ""rb"" ) ;if ( ! fin ) return mp4box_cleanup ( 1 ) ;fout = gf_fopen ( inName , ""a+b"" ) ;if ( ! fout ) {gf_fclose ( fin ) ;return mp4box_cleanup ( 1 ) ;}gf_fseek ( fin , 0 , SEEK_END ) ;to_copy = gf_ftell ( fin ) ;gf_fseek ( fin , 0 , SEEK_SET ) ;done = 0 ;while ( 1 ) {u32 nb_bytes = ( u32 ) gf_fread ( chunk , 4096 , fin ) ;gf_fwrite ( chunk , nb_bytes , fout ) ;done += nb_bytes ;fprintf ( stderr , ""Appending<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%02.2f<S2SV_blank>done\\\\r"" , raw_cat , 100.0 * done / to_copy ) ;if ( done >= to_copy ) break ;}gf_fclose ( fin ) ;gf_fclose ( fout ) ;return mp4box_cleanup ( 0 ) ;}if ( compress_top_boxes ) {if ( size_top_box ) {u64 top_size = do_size_top_boxes ( inName , compress_top_boxes , size_top_box ) ;fprintf ( stdout , LLU ""\\\return mp4box_cleanup ( e ? 1 : 0 ) ;}else {e = do_compress_top_boxes ( inName , outName , compress_top_boxes , comp_top_box_version , comp_lzma ) ;return mp4box_cleanup ( e ? 1 : 0 ) ;}}if ( do_mpd_rip ) {e = rip_mpd ( inName , outName ) ;return mp4box_cleanup ( e ? 1 : 0 ) ;}# ifndef GPAC_DISABLE_CORE_TOOLS if ( do_wget != NULL ) {e = gf_dm_wget ( do_wget , inName , 0 , 0 , NULL ) ;if ( e != GF_OK ) {fprintf ( stderr , ""Cannot<S2SV_blank>retrieve<S2SV_blank>%s:<S2SV_blank>%s\\\return mp4box_cleanup ( 1 ) ;}return mp4box_cleanup ( 0 ) ;}# endif if ( udp_dest ) {GF_Socket * sock = gf_sk_new ( GF_SOCK_TYPE_UDP ) ;u16 port = 2345 ;char * sep = strrchr ( udp_dest , \':\' ) ;if ( sep ) {sep [ 0 ] = 0 ;port = atoi ( sep + 1 ) ;}e = gf_sk_bind ( sock , ""127.0.0.1"" , 0 , udp_dest , port , 0 ) ;if ( sep ) sep [ 0 ] = \':\' ;if ( e ) fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>%s\\\else {e = gf_sk_send ( sock , ( u8 * ) inName , ( u32 ) strlen ( inName ) ) ;if ( e ) fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>datagram:<S2SV_blank>%s\\\}gf_sk_del ( sock ) ;return 0 ;}# ifndef GPAC_DISABLE_MPD if ( do_mpd ) {Bool remote = GF_FALSE ;GF_MPD * mpd ;char * mpd_base_url = NULL ;if ( ! strnicmp ( inName , ""http://"" , 7 ) || ! strnicmp ( inName , ""https://"" , 8 ) ) {# if ! defined ( GPAC_DISABLE_CORE_TOOLS ) e = gf_dm_wget ( inName , ""tmp_main.m3u8"" , 0 , 0 , & mpd_base_url ) ;if ( e != GF_OK ) {fprintf ( stderr , ""Cannot<S2SV_blank>retrieve<S2SV_blank>M3U8<S2SV_blank>(%s):<S2SV_blank>%s\\\if ( mpd_base_url ) gf_free ( mpd_base_url ) ;return mp4box_cleanup ( 1 ) ;}remote = GF_TRUE ;# else gf_free ( mpd_base_url ) ;fprintf ( stderr , ""HTTP<S2SV_blank>Downloader<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build\\\return mp4box_cleanup ( 1 ) ;# endif if ( outName ) strcpy ( outfile , outName ) ;else {const char * sep = gf_file_basename ( inName ) ;char * ext = gf_file_ext_start ( sep ) ;if ( ext ) ext [ 0 ] = 0 ;sprintf ( outfile , ""%s.mpd"" , sep ) ;if ( ext ) ext [ 0 ] = \'.\' ;}}else {if ( outName ) strcpy ( outfile , outName ) ;else {char * dst = strdup ( inName ) ;char * ext = strstr ( dst , "".m3u8"" ) ;if ( ext ) ext [ 0 ] = 0 ;sprintf ( outfile , ""%s.mpd"" , dst ) ;gf_free ( dst ) ;}}mpd = gf_mpd_new ( ) ;if ( ! mpd ) {e = GF_OUT_OF_MEM ;fprintf ( stderr , ""[DASH]<S2SV_blank>Error:<S2SV_blank>MPD<S2SV_blank>creation<S2SV_blank>problem<S2SV_blank>%s\\\mp4box_cleanup ( 1 ) ;}FILE * f = gf_fopen ( remote ? ""tmp_main.m3u8"" : inName , ""r"" ) ;u32 manif_type = 0 ;if ( f ) {char szDATA [ 1000 ] ;s32 read ;szDATA [ 999 ] = 0 ;read = ( s32 ) gf_fread ( szDATA , 999 , f ) ;if ( read < 0 ) read = 0 ;szDATA [ read ] = 0 ;gf_fclose ( f ) ;if ( strstr ( szDATA , ""SmoothStreamingMedia"" ) ) manif_type = 2 ;else if ( strstr ( szDATA , ""#EXTM3U"" ) ) manif_type = 1 ;}if ( manif_type == 1 ) {e = gf_m3u8_to_mpd ( remote ? ""tmp_main.m3u8"" : inName , mpd_base_url ? mpd_base_url : inName , outfile , 0 , ""video/mp2t"" , GF_TRUE , use_url_template , segment_timeline , NULL , mpd , GF_TRUE , GF_TRUE ) ;}else if ( manif_type == 2 ) {e = gf_mpd_smooth_to_mpd ( remote ? ""tmp_main.m3u8"" : inName , mpd , mpd_base_url ? mpd_base_url : inName ) ;}else {e = GF_NOT_SUPPORTED ;}if ( ! e ) gf_mpd_write_file ( mpd , outfile ) ;if ( mpd ) gf_mpd_del ( mpd ) ;if ( mpd_base_url ) gf_free ( mpd_base_url ) ;if ( remote ) {gf_file_delete ( ""tmp_main.m3u8"" ) ;}if ( e != GF_OK ) {fprintf ( stderr , ""Error<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s):<S2SV_blank>%s\\\return mp4box_cleanup ( 1 ) ;}else {fprintf ( stderr , ""Done<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s)\\\return mp4box_cleanup ( 0 ) ;}}# endif if ( dash_duration && ! nb_dash_inputs ) {dash_inputs = set_dash_input ( dash_inputs , inName , & nb_dash_inputs ) ;}if ( do_saf && ! encode ) {switch ( get_file_type_by_ext ( inName ) ) {case GF_FILE_TYPE_BT_WRL_X3DV : case GF_FILE_TYPE_XMT_X3D : case GF_FILE_TYPE_SVG : encode = GF_TRUE ;break ;case GF_FILE_TYPE_NOT_SUPPORTED : case GF_FILE_TYPE_ISO_MEDIA : case GF_FILE_TYPE_SWF : case GF_FILE_TYPE_LSR_SAF : break ;}}# ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode == GF_SM_DUMP_SVG ) {if ( strstr ( inName , "".srt"" ) || strstr ( inName , "".ttxt"" ) ) import_subtitle = 2 ;}# endif if ( import_subtitle && ! trackID ) {# ifndef GPAC_DISABLE_MEDIA_IMPORT GF_MediaImporter import ;file = gf_isom_open ( ""ttxt_convert"" , GF_ISOM_OPEN_WRITE , NULL ) ;if ( timescale && file ) gf_isom_set_timescale ( file , timescale ) ;memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ;import . dest = file ;import . in_name = inName ;e = gf_media_import ( & import ) ;if ( e ) {fprintf ( stderr , ""Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\\gf_isom_delete ( file ) ;gf_file_delete ( ""ttxt_convert"" ) ;return mp4box_cleanup ( 1 ) ;}strcpy ( outfile , inName ) ;","# else fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\\\",163
230,"fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD"" , inName ) ;}","fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD"" , inName ) ;}",163
231,test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ;test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ;test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ;result_has_retransmits = j_sender_has_retransmits -> valueint ;,test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuedouble ;test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuedouble ;test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuedouble ;result_has_retransmits = j_sender_has_retransmits -> valueint ;,164
232,jitter = j_jitter -> valuefloat ;cerror = j_errors -> valueint ;,jitter = j_jitter -> valuedouble ;cerror = j_errors -> valueint ;,164
233,"skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ;if ( ! skb ) goto read_error ;","m -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ;if ( ! skb ) goto read_error ;",165
234,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",166
235,"uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ;parse_cmd_line ( ""js<S2SV_blank>Uzbl.run(\\\'print<S2SV_blank>@useragent\\\').toUpperCase();"" , result ) ;g_assert_cmpstr ( ""TEST<S2SV_blank>USERAGENT"" , == , result -> str ) ;","
",167
236,"if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ;if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ;map -> m_flags &= ~ EXT4_MAP_FLAGS ;down_write ( & EXT4_I ( inode ) -> i_data_sem ) ;if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) {retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ;}else {retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ;if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) {ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ;}if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ;}if ( retval > 0 ) {unsigned int status ;if ( unlikely ( retval != map -> m_len ) ) {ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ;WARN_ON ( 1 ) ;if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) {ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ;if ( ret ) {retval = ret ;goto out_sem ;}}if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) {if ( ext4_es_is_written ( & es ) ) goto out_sem ;}status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ;if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ;ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ;if ( ret < 0 ) {retval = ret ;goto out_sem ;}}out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ;if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) {ret = check_block_validity ( inode , map ) ;if ( ret != 0 ) return ret ;}return retval ;","if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) {ret = ext4_jbd2_file_inode ( handle , inode ) ;if ( ret ) return ret ;return retval ;",168
237,head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ;track_shift = 2 * head_shift + 3 ;,if ( ! F_SECT_PER_TRACK ) return ;head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ;track_shift = 2 * head_shift + 3 ;,169
238,if ( roishift == 0 && bgshift == 0 ) {return ;,"if ( roishift < 0 ) {jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\\roishift = 0 ;}if ( roishift == 0 && bgshift == 0 ) {return ;",170
239,mask = ( 1 << numbps ) - 1 ;if ( mag & ( ~ mask ) ) {,"mask = ( JAS_CAST ( uint_fast32_t , 1 ) << numbps ) - 1 ;if ( mag & ( ~ mask ) ) {",170
240,case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON :  case EXIT_REASON_INVEPT :  return 1 ;,case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : return 1 ;,171
241,struct pmu * leader_pmu = event -> group_leader -> pmu ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;,struct pmu * leader_pmu = event -> group_leader -> pmu ;if ( is_software_event ( event ) ) return 1 ;if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ;,172
242,int n = 0 ;apr_size_t len = 1 ;,int do_read = 1 ;int n = 0 ;apr_size_t len = 1 ;,173
243,plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1 ;sock = ap_get_conn_socket ( r -> connection ) ;if ( plaintext ) {,plaintext = ap_lua_ssl_is_https ( r -> connection ) ;while ( do_read ) {do_read = 0 ? 0 : 1 ;sock = ap_get_conn_socket ( r -> connection ) ;if ( plaintext ) {,173
244,"lua_pushboolean ( L , fin ) ;return 2 ;}if ( opcode == 0x09 ) {char frame [ 2 ] ;plen = 2 ;frame [ 0 ] = 0x8A ;frame [ 1 ] = 0 ;apr_socket_send ( sock , frame , & plen ) ;lua_websocket_read ( L ) ;}",do_read = 1 ;}},173
245,"if ( user_ns != mnt_ns -> user_ns )  copy_flags |= CL_SHARED_TO_SLAVE ;new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ;","if ( user_ns != mnt_ns -> user_ns ) copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED ;new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ;",174
246,void uwbd_stop ( struct uwb_rc * rc )  {kthread_stop ( rc -> uwbd . task ) ;,void uwbd_stop ( struct uwb_rc * rc ) {if ( rc -> uwbd . task ) kthread_stop ( rc -> uwbd . task ) ;,175
247,"record_and_restart ( event , val , regs , nmi ) ;}","record_and_restart ( event , val , regs ) ;}",176
248,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",177
249,"SetImageColorspace ( image , GRAYColorspace ) ;if ( scene == 0 ) {","SetImageColorspace ( image , GRAYColorspace ) ;if ( scene == 0 ) {",177
250,"const void * data ;size_t size ;int noffset = 0 ;char * err_msg = """" ;if ( fit_image_get_data_and_size ( fit , image_noffset , & data , & size ) ) {printf ( ""error!\\\return fit_image_verify_with_data ( fit , image_noffset , data , size ) ;}","const char * name = fit_get_name ( fit , image_noffset , NULL ) ;const void * data ;size_t size ;char * err_msg = """" ;if ( strchr ( name , \'@\' ) ) {err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ;goto err ;}if ( fit_image_get_data_and_size ( fit , image_noffset , & data , & size ) ) {goto err ;}return fit_image_verify_with_data ( fit , noffset , NULL ) , fit_get_name ( fit , image_noffset , NULL ) ) ;",178
251,if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) )  return FALSE ;if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) )  return FALSE ;,if ( * dp != ( csum & 0xff ) || dp [ 1 ] != ( ( csum >> 8 ) & 0xff ) || dp [ 2 ] != ( ( csum >> 16 ) & 0xff ) || dp [ 3 ] != ( ( csum >> 24 ) & 0xff ) ) return FALSE ;if ( * dp != ( csum & 0xff ) || dp [ 1 ] != ( ( csum >> 8 ) & 0xff ) ) return FALSE ;,179
252,"int ret ;word32 hash_len , hash_enc_len ;# ifdef WOLFSSL_SMALL_STACK byte * hash_data ;# else byte hash_data [ MAX_DER_DIGEST_SZ ] ;# endif if ( data == NULL || data_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) {return BAD_FUNC_ARG ;}if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) {WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len"" ) ;return BAD_FUNC_ARG ;}ret = wc_HashGetDigestSize ( hash_type ) ;if ( ret < 0 ) {WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>hash<S2SV_blank>type/len"" ) ;return ret ;}hash_enc_len = hash_len = ret ;# if ! defined ( NO_RSA ) && ! defined ( WOLFSSL_RSA_PUBLIC_ONLY ) if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) {hash_enc_len += MAX_DER_DIGEST_ASN_SZ ;}# endif # ifdef WOLFSSL_SMALL_STACK hash_data = ( byte * ) XMALLOC ( hash_enc_len , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ;if ( hash_data == NULL ) {return MEMORY_E ;}# endif  ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ;if ( ret == 0 ) {ret = wc_SignatureGenerateHash ( hash_type , sig_type ,  hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ;}}# ifdef WOLFSSL_SMALL_STACK XFREE ( hash_data , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ;# endif return ret ;","return wc_SignatureGenerate_ex ( hash_type , sig_type , data , data_len , hash_data , hash_len ) ;if ( ret == 0 ) {ret = wc_SignatureGenerateHash ( hash_type , sig_type , hash_data , hash_enc_len , sig , sig_len , key , key_len , rng , 1 ) ;",180
253,"if ( copy_in ) {ret = copy_from_user ( bounce_buf , ( void __user * ) buf , len ) ;* bounce_buf_ret = bounce_buf ;hgcm_call_add_pagelist_size ( bounce_buf , len , extra ) ;","* bounce_buf_ret = bounce_buf ;if ( copy_in ) {ret = copy_from_user ( bounce_buf , ( void __user * ) buf , len ) ;hgcm_call_add_pagelist_size ( bounce_buf , len , extra ) ;",181
254,"static double calculate_modified_err ( const VP9_COMP * cpi ,  const FIRSTPASS_STATS * this_frame ) {const struct twopass_rc * twopass = & cpi -> twopass ;const SVC * const svc = & cpi -> svc ;const FIRSTPASS_STATS * stats ;double av_err ;double modified_error ;if ( svc -> number_spatial_layers > 1 && svc -> number_temporal_layers == 1 ) {twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ;}stats = & twopass -> total_stats ;av_err = stats -> ssim_weighted_pred_err / stats -> count ;modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err /  DOUBLE_DIVIDE_CHECK ( av_err ) ,  cpi -> oxcf . two_pass_vbrbias / 100.0 ) ;return fclamp ( modified_error , twopass -> modified_error_min , twopass -> modified_error_max ) ;","static double calculate_modified_err ( const VP9_COMP * cpi , const TWO_PASS * twopass , const VP9EncoderConfig * oxcf , const FIRSTPASS_STATS * this_frame ) {const FIRSTPASS_STATS * const stats = & twopass -> total_stats ;av_err = stats -> ssim_weighted_pred_err / stats -> count ;const double av_err = ( stats -> coded_error * av_weight ) / stats -> count ;double modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err / DOUBLE_DIVIDE_CHECK ( av_err ) , cpi -> oxcf . two_pass_vbrbias / 100.0 ) ;modified_error *= pow ( calculate_active_area ( cpi , this_frame ) , ACT_AREA_CORRECTION ) ;return fclamp ( modified_error , twopass -> modified_error_min , twopass -> modified_error_max ) ;",182
255,"while ( bytes ) {int copy = min ( bytes , iov -> iov_len - base ) ;","while ( bytes || ! iov -> iov_len ) {int copy = min ( bytes , iov -> iov_len - base ) ;",183
256,return FALSE ;},transport -> credssp = NULL ;return FALSE ;},184
257,"return true ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;","return ( * field_rtrn != NULL ) ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;",185
258,int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ;int nStr = ( int ) strlen ( zMatchinfo ) ;pRet = sqlite3_malloc ( nByte + nStr + 1 ) ;if ( pRet ) {,sqlite3_int64 nByte = sizeof ( u32 ) * ( 2 * ( sqlite3_int64 ) nElem + 1 ) + sizeof ( MatchinfoBuffer ) ;sqlite3_int64 nStr = strlen ( zMatchinfo ) ;pRet = sqlite3_malloc ( nByte + nStr + 1 ) ;if ( pRet ) {,186
259,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;save_and_clear_fpu ( ) ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;save_and_clear_fpu ( ) ;",187
260,"# ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}mysql_options ( & mysql_connection , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;# endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;","SSL_SET_OPTIONS ( & mysql_connection ) ;if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",188
261,"memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ;memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ;if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ;","strlcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ;strlcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ;if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ;",189
262,"void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 ,  int c0 , int r1 , int c1 ) {int i ;if ( mat0 -> data_ ) {","void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t c1 ) {int i ;if ( mat0 -> data_ ) {",190
263,if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) {return NULL ;,if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 1 ) {return NULL ;,191
264,"case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ;","# if 0 case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ;",191
265,"case DW_FORM_data2 :  value -> encoding . data = READ ( buf , ut16 ) ;case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ;break ;case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ;for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}","case DW_FORM_data2 : value -> encoding . data = READ ( buf , ut16 ) ;# endif case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ;break ;case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ;if ( value -> encoding . block . data ) {for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}}if ( value -> encoding . block . data ) {for ( j = 0 ;value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ;}}",191
266,"struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;","struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ;",192
267,"void HTML_put_string ( HTStructured * me , const char * s )  {# ifdef USE_PRETTYSRC char * translated_string = NULL ;","void HTML_put_string ( HTStructured * me , const char * s ) {HTChunk * target = NULL ;# ifdef USE_PRETTYSRC char * translated_string = NULL ;",193
268,"case HTML_TITLE :  HTChunkPuts ( & me -> title , s ) ;break ;case HTML_STYLE :  HTChunkPuts ( & me -> style_block , s ) ;break ;case HTML_SCRIPT :  HTChunkPuts ( & me -> script , s ) ;break ;case HTML_OBJECT :  HTChunkPuts ( & me -> object , s ) ;break ;case HTML_TEXTAREA :  HTChunkPuts ( & me -> textarea , s ) ;break ;case HTML_SELECT : case HTML_OPTION :  HTChunkPuts ( & me -> option , s ) ;break ;case HTML_MATH :  HTChunkPuts ( & me -> math , s ) ;break ;","case HTML_TITLE : target = & me -> title , s ) ;break ;case HTML_STYLE : target = & me -> style_block , s ) ;break ;case HTML_SCRIPT : target = & me -> script , s ) ;break ;case HTML_OBJECT : target = & me -> object , s ) ;break ;case HTML_TEXTAREA : target = & me -> textarea , s ) ;break ;case HTML_SELECT : case HTML_OPTION : target = & me -> option , s ) ;break ;case HTML_MATH : target = & me -> math , s ) ;break ;",193
269,"
","if ( target != NULL ) {if ( target -> data == s ) {CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\\\'\\\}else {HTChunkPuts ( target , s ) ;}}",193
270,# ifdef USE_PRETTYSRC  if ( psrc_convert_string ) {,# ifdef USE_PRETTYSRC if ( psrc_convert_string ) {,193
271,"static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , va_list args ) {",194
272,when = timespec_to_ns ( new_setting -> it_value ) ;period = timespec_to_ns ( new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( n ) ;if ( when > now ) when -= now ;,when = timespec_to_ns ( & new_setting -> it_value ) ;period = timespec_to_ns ( & new_setting -> it_interval ) ;if ( when == 0 ) return 0 ;now = timespec_to_ns ( & n ) ;if ( when > now ) when -= now ;,195
273,break ;},if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;break ;},196
274,"sprintf ( descriptor -> msg , ""\\\","sprintf ( descriptor -> msg , ""\\\",197
275,if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  {,if ( field_identifier == SQL_DESC_COUNT && ( intptr_t ) value < 0 ) {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) value != SQL_PARAM_OUTPUT_STREAM ) {,197
276,"if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO )  && ext4_can_extents_be_merged ( inode , ex , newext ) ) {","if ( ex && ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) && ext4_can_extents_be_merged ( inode , ex , newext ) ) {",198
277,"merge :  if ( flag != EXT4_GET_BLOCKS_PRE_IO )  ext4_ext_try_to_merge ( inode , path , nearex ) ;","merge : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( inode , path , nearex ) ;",198
278,"static int  mptctl_replace_fw ( unsigned long arg )  {MPT_ADAPTER * ioc ;int iocnum ;return - EFAULT ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_replace_fw()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;","static int mptctl_replace_fw ( MPT_ADAPTER * ioc , unsigned long arg ) {return - EFAULT ;",199
279,"if ( ( addr_fd = open ( val , O_RDONLY ) ) != - 1 )  {read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ;if ( ( string_to_bdaddr ( val , local_addr ) ) && ( memcmp ( local_addr -> address , null_bdaddr , BD_ADDR_LEN ) != 0 ) ) {","if ( ( addr_fd = TEMP_FAILURE_RETRY ( open ( val , O_RDONLY ) ) ) != - 1 ) {TEMP_FAILURE_RETRY ( read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ) ;if ( ( string_to_bdaddr ( val , local_addr ) ) && ( memcmp ( local_addr -> address , null_bdaddr , BD_ADDR_LEN ) != 0 ) ) {",200
280,op -> regs [ reg_index ] = reg ;op -> scale [ reg_index ] = temp ;++ reg_index ;}op -> offset += temp ;op -> regs [ reg_index ] = X86R_UNDEFINED ;},+ reg_index ;if ( reg_index < 2 ) {op -> regs [ reg_index ] = reg ;op -> scale [ reg_index ] = temp ;}++ reg_index ;}op -> offset += temp ;if ( reg_index < 2 ) {op -> regs [ reg_index ] = X86R_UNDEFINED ;}},201
281,"
","value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . Assign . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . For . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . With . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ;if ( ! value ) goto failed ;if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ;Py_DECREF ( value ) ;",202
282,"break ;case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ;","break ;case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ;",202
283,"break ;case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ;","break ;case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ;",202
284,"break ;case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ;","break ;case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ;",202
285,"break ;case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ;","break ;case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ;",202
286,"break ;case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ;","break ;case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ;",202
287,"break ;case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ;","break ;case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ;",202
288,"break ;case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ;","break ;case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ;",202
289,if ( qop_req != 0 ) {if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,if ( ctx -> terminated || qop_req != 0 ) {if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,203
290,"if ( _PyObject_HasAttrId ( obj , & PyId_context_expr ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & context_expr , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""context_expr\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ;if ( exists_not_none ( obj , & PyId_optional_vars ) ) {res = obj2ast_expr ( tmp , & optional_vars , arena ) ;if ( res != 0 ) goto failed ;else {","if ( lookup_attr_id ( obj , & PyId_context_expr ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""context_expr\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ;else {if ( lookup_attr_id ( obj , & PyId_optional_vars , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;else {int res ;res = obj2ast_expr ( tmp , & optional_vars , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",204
291,"# define ThrowPICTException ( exception , message ) {}char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;","# define ThrowPICTException ( exception , message ) \\\\\\\\\\char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;",205
292,"( void ) ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;while ( ( c = ReadBlobByte ( image ) ) == 0 ) ;if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;version = ( ssize_t ) ReadBlobByte ( image ) ;if ( version == 2 ) {c = ReadBlobByte ( image ) ;if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;}else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;flags = 0 ;image -> depth = 8 ;image -> columns = ( size_t ) ( frame . right - frame . left ) ;image -> rows = ( size_t ) ( frame . bottom - frame . top ) ;image -> resolution . x = DefaultResolution ;image -> resolution . y = DefaultResolution ;image -> units = UndefinedResolution ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;jpeg = MagickFalse ;for ( code = 0 ;EOFBlob ( image ) == MagickFalse ;) {if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ;if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ;if ( code < 0 ) break ;if ( code == 0 ) continue ;if ( code > 0xa1 ) {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ;}else {if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ;switch ( code ) {case 0x01 : {length = ReadBlobMSBShort ( image ) ;if ( length != 0x000a ) {for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ;image -> columns = ( size_t ) ( frame . right - frame . left ) ;image -> rows = ( size_t ) ( frame . bottom - frame . top ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;break ;}case 0x12 : case 0x13 : case 0x14 : {ssize_t pattern ;size_t height , width ;pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < 8 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;if ( pattern == 2 ) {for ( i = 0 ;i < 5 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ;length = ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> depth = ( size_t ) pixmap . component_size ;image -> resolution . x = 1.0 * pixmap . horizontal_resolution ;image -> resolution . y = 1.0 * pixmap . vertical_resolution ;image -> units = PixelsPerInchResolution ;( void ) ReadBlobMSBLong ( image ) ;flags = ( ssize_t ) ReadBlobMSBShort ( image ) ;length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i <= ( ssize_t ) length ;i ++ ) ( void ) ReadBlobMSBLong ( image ) ;width = ( size_t ) ( frame . bottom - frame . top ) ;height = ( size_t ) ( frame . right - frame . left ) ;if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ;if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ;if ( length == 0 ) length = width ;if ( length < 8 ) {for ( i = 0 ;i < ( ssize_t ) ( length * height ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}else for ( i = 0 ;i < ( ssize_t ) height ;i ++ ) {if ( EOFBlob ( image ) != MagickFalse ) break ;if ( length > 200 ) {for ( j = 0 ;j < ( ssize_t ) ReadBlobMSBShort ( image ) ;j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}else for ( j = 0 ;j < ( ssize_t ) ReadBlobByte ( image ) ;j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}break ;}case 0x1b : {image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;break ;}case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : {length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;break ;}case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : {PICTRectangle source , destination ;register unsigned char * p ;size_t j ;ssize_t bytes_per_line ;unsigned char * pixels ;bytes_per_line = 0 ;if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ;else {( void ) ReadBlobMSBShort ( image ) ;( void ) ReadBlobMSBShort ( image ) ;( void ) ReadBlobMSBShort ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ;if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) {if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;tile_image -> depth = ( size_t ) pixmap . component_size ;tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ;tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ;tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ;tile_image -> units = PixelsPerInchResolution ;if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ;}if ( ( code != 0x9a ) && ( code != 0x9b ) ) {tile_image -> colors = 2 ;if ( ( bytes_per_line & 0x8000 ) != 0 ) {( void ) ReadBlobMSBLong ( image ) ;flags = ( ssize_t ) ReadBlobMSBShort ( image ) ;tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ;}status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ;if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( ( bytes_per_line & 0x8000 ) != 0 ) {for ( i = 0 ;i < ( ssize_t ) tile_image -> colors ;i ++ ) {j = ReadBlobMSBShort ( image ) % tile_image -> colors ;if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ;tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ;}}else {for ( i = 0 ;i < ( ssize_t ) tile_image -> colors ;i ++ ) {tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ;tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ;tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ;}}}if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;( void ) ReadBlobMSBShort ( image ) ;if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) {length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) ( length - 2 ) ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ;else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ;if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ;p = pixels ;for ( y = 0 ;y < ( ssize_t ) tile_image -> rows ;y ++ ) {if ( p > ( pixels + extent + image -> columns ) ) {pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;}q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) tile_image -> columns ;x ++ ) {if ( tile_image -> storage_class == PseudoClass ) {index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ;SetPixelIndex ( tile_image , index , q ) ;SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ;SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ;SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ;}else {if ( pixmap . bits_per_pixel == 16 ) {i = ( ssize_t ) ( * p ++ ) ;j = ( size_t ) ( * p ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ;}else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) {if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ;}else {if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ;SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ;SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ;SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ;}}p ++ ;q += GetPixelChannels ( tile_image ) ;}if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ;if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) {p += ( pixmap . component_count - 1 ) * tile_image -> columns ;if ( p < pixels ) break ;}status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ;if ( status == MagickFalse ) break ;}pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ;tile_image = DestroyImage ( tile_image ) ;break ;}case 0xa1 : {unsigned char * info ;size_t type ;type = ReadBlobMSBShort ( image ) ;length = ReadBlobMSBShort ( image ) ;if ( length == 0 ) break ;( void ) ReadBlobMSBLong ( image ) ;length -= MagickMin ( length , 4 ) ;if ( length == 0 ) break ;info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ;if ( info == ( unsigned char * ) NULL ) break ;count = ReadBlob ( image , length , info ) ;if ( count != ( ssize_t ) length ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ;}switch ( type ) {case 0xe0 : {profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;SetStringInfoDatum ( profile , info ) ;status = SetImageProfile ( image , ""icc"" , profile , exception ) ;profile = DestroyStringInfo ( profile ) ;if ( status == MagickFalse ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case 0x1f2 : {profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;SetStringInfoDatum ( profile , info ) ;status = SetImageProfile ( image , ""iptc"" , profile , exception ) ;if ( status == MagickFalse ) {info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}profile = DestroyStringInfo ( profile ) ;break ;}default : break ;}info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;break ;}default : {if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ;else for ( i = 0 ;i < ( ssize_t ) codes [ code ] . length ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;}}}if ( code == 0xc00 ) {for ( i = 0 ;i < 24 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;continue ;}if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ;if ( code == 0x8200 ) {char filename [ MaxTextExtent ] ;FILE * file ;int unique_file ;jpeg = MagickTrue ;read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) {( void ) RelinquishUniqueFileResource ( read_info -> filename ) ;( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ;ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ;}length = ReadBlobMSBLong ( image ) ;if ( length > 154 ) {for ( i = 0 ;i < 6 ;i ++ ) ( void ) ReadBlobMSBLong ( image ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) {( void ) fclose ( file ) ;( void ) RelinquishUniqueFileResource ( read_info -> filename ) ;ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;}for ( i = 0 ;i < 122 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;for ( i = 0 ;i < ( ssize_t ) ( length - 154 ) ;i ++ ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",205
293,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,206
294,"static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , va_list args ) {",207
295,"enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_NO_FLAGS ) ;if ( rc == IMAP_EXEC_FATAL ) goto bail ;","enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ;mutt_socket_empty ( adata -> conn ) ;if ( rc == IMAP_EXEC_FATAL ) goto bail ;",208
296,"log_file = NULL ;}if ( ! name ) return ;file_name = make_file_name ( name , prog , namespace , instance ) ;log_file = fopen ( file_name , ""a"" ) ;if ( log_file ) {","log_file = fopen_safe ( file_name , ""a"" ) ;if ( log_file ) {",209
297,f2fs_wait_discard_bios ( sbi ) ;out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ;,"f2fs_wait_discard_bios ( sbi , false ) ;out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ;",210
298,"int frame_avail , got_data ;struct VpxInputContext input = {0 };struct VpxEncoderConfig global ;exec_name = argv_ [ 0 ] ;if ( argc < 3 ) usage_exit ( ) ;input . framerate . numerator = 30 ;input . framerate . denominator = 1 ;input . use_i420 = 1 ;input . only_i420 = 1 ;argv = argv_dup ( argc - 1 , argv_ + 1 ) ;parse_global_config ( & global , argv ) ;{","# if CONFIG_VP9_HIGHBITDEPTH vpx_image_t raw_shift ;int allocated_raw_shift = 0 ;int use_16bit_internal = 0 ;int input_shift = 0 ;# endif int frame_avail , got_data ;struct VpxInputContext input ;struct VpxEncoderConfig global ;memset ( & input , 0 , sizeof ( input ) ) ;exec_name = argv_ [ 0 ] ;if ( argc < 3 ) usage_exit ( ) ;input . only_i420 = 1 ;input . use_i420 = 1 ;input . only_i420 = 1 ;argv = argv_dup ( argc - 1 , argv_ + 1 ) ;parse_global_config ( & global , argv ) ;{",211
299,"int64_t average_rate = - 1 ;off_t lagged_count = 0 ;open_input_file ( & input ) ;if ( ! input . width || ! input . height )  FOREACH_STREAM ( {}if ( ! input . width || ! input . height ) fatal ( ""Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>""  ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ;FOREACH_STREAM ( set_stream_dimensions ( stream , input . width , input . height ) ) ;","int64_t lagged_count = 0 ;open_input_file ( & input ) ;if ( ! input . width || ! input . height ) {FOREACH_STREAM ( {}) ;}if ( ! input . width || ! input . height ) fatal ( ""Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>"" ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ;if ( ! input . bit_depth ) {FOREACH_STREAM ( {if ( stream -> config . cfg . g_input_bit_depth ) input . bit_depth = stream -> config . cfg . g_input_bit_depth ;else input . bit_depth = stream -> config . cfg . g_input_bit_depth = ( int ) stream -> config . cfg . g_bit_depth ;}) ;if ( input . bit_depth > 8 ) input . fmt |= VPX_IMG_FMT_HIGHBITDEPTH ;}else {FOREACH_STREAM ( {stream -> config . cfg . g_input_bit_depth = input . bit_depth ;}}FOREACH_STREAM ( set_stream_dimensions ( stream , input . width , input . height ) ) ;",211
300,"if ( input . file_type == FILE_TYPE_Y4M ) memset ( & raw , 0 , sizeof ( raw ) ) ;else vpx_img_alloc ( & raw ,  input . use_i420 ? VPX_IMG_FMT_I420  : VPX_IMG_FMT_YV12 , input . width , input . height , 32 ) ;FOREACH_STREAM ( stream -> rate_hist = init_rate_histogram ( & stream -> config . cfg , & global . framerate ) ) ;FOREACH_STREAM ( open_output_file ( stream , & global ) ) ;FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ;frame_avail = 1 ;","if ( input . file_type == FILE_TYPE_Y4M ) memset ( & raw , input . fmt , input . width , input . height , 32 ) ;FOREACH_STREAM ( stream -> rate_hist = init_rate_histogram ( & stream -> config . cfg , & global , & input . pixel_aspect_ratio . framerate ) ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global . codec -> name , ""vp9"" ) == 0 || strcmp ( global . codec -> name , ""vp10"" ) == 0 ) {FOREACH_STREAM ( {if ( stream -> config . use_16bit_internal ) {use_16bit_internal = 1 ;}if ( stream -> config . cfg . g_profile == 0 ) {input_shift = 0 ;else {input_shift = ( int ) stream -> config . cfg . g_bit_depth - stream -> config . cfg . g_input_bit_depth ;}}) ;}# endif }FOREACH_STREAM ( open_output_file ( stream , & global ) ) ;FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ;frame_avail = 1 ;",211
301,"fprintf ( stderr , ""\\\\033[K"" ) ;}if ( frames_in > global . skip_frames ) {vpx_usec_timer_start ( & timer ) ;vpx_usec_timer_mark ( & timer ) ;cx_time += vpx_usec_timer_elapsed ( & timer ) ;if ( ! got_data && input . length && ! streams -> frames_out ) {lagged_count = global . limit ? seen_frames : ftello ( input . file ) ;off_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ;rate = cx_time ? frame_in_lagged * ( int64_t ) 1000000 / cx_time : 0 ;off_t input_pos = ftello ( input . file ) ;off_t input_pos_lagged = input_pos - lagged_count ;int64_t limit = input . length ;rate = cx_time ? input_pos_lagged * ( int64_t ) 1000000 / cx_time : 0 ;","}if ( frames_in > global . skip_frames ) {# if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * frame_to_encode ;if ( input_shift || ( use_16bit_internal && input . bit_depth == 8 ) ) {assert ( use_16bit_internal ) ;if ( ! allocated_raw_shift ) {vpx_img_alloc ( & raw_shift , raw . fmt | VPX_IMG_FMT_HIGHBITDEPTH , input . width , input . height , 32 ) ;allocated_raw_shift = 1 ;}vpx_img_upshift ( & raw_shift , & raw , input_shift ) ;frame_to_encode = & raw_shift ;}else {frame_to_encode = & raw ;}vpx_usec_timer_start ( & timer ) ;if ( use_16bit_internal ) {assert ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ;FOREACH_STREAM ( {if ( stream -> config . use_16bit_internal ) encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ;else assert ( 0 ) ;}) ;}else {assert ( ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) == 0 ) ;FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ) ;# endif }# else vpx_usec_timer_start ( & timer ) ;vpx_usec_timer_mark ( & timer ) ;cx_time += vpx_usec_timer_elapsed ( & timer ) ;if ( ! got_data && input . length && streams != NULL && ! streams -> frames_out ) {lagged_count = global . limit ? seen_frames : ftello ( input . file ) ;const int64_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ;rate = cx_time ? frame_in_lagged * ( int64_t ) 1000000 / cx_time : 0 ;const int64_t input_pos = ftello ( input . file ) ;const int64_t input_pos_lagged = input_pos - lagged_count ;const int64_t limit = input . length ;rate = cx_time ? input_pos_lagged * ( int64_t ) 1000000 / cx_time : 0 ;",211
302,"}if ( stream_cnt > 1 ) fprintf ( stderr , ""\\\if ( ! global . quiet )  FOREACH_STREAM ( fprintf ( stderr ,  ""\\\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7lub/f<S2SV_blank>%7"" PRId64 ""b/s""  ""<S2SV_blank>%7"" PRId64 ""<S2SV_blank>%s<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\033[K\\\) ;if ( global . show_psnr )  FOREACH_STREAM ( show_psnr ( stream ) ) ;FOREACH_STREAM ( vpx_codec_destroy ( & stream -> encoder ) ) ;","if ( ! global . quiet ) {fprintf ( stderr , ""\\\\033[K"" ) ;}if ( stream_cnt > 1 ) fprintf ( stderr , ""\\\if ( ! global . quiet ) FOREACH_STREAM ( fprintf ( stderr , ""\\\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7"" PRId64 ""b/f<S2SV_blank>%7"" PRId64 ""b/s"" ""<S2SV_blank>%7"" PRId64 ""<S2SV_blank>%s<S2SV_blank>(%.2f<S2SV_blank>fps)\\\\033[K\\\}if ( global . show_psnr ) {if ( global . codec -> fourcc == VP9_FOURCC ) {FOREACH_STREAM ( show_psnr ( stream , ( 1 << stream -> config . cfg . g_input_bit_depth ) - 1 ) ) ;# if CONFIG_FP_MB_STATS FOREACH_STREAM ( stats_close ( & stream -> fpmb_stats , global . passes - 1 ) ) ;# endif }else {FOREACH_STREAM ( show_psnr ( stream , 255.0 ) ) ;}) ;# endif # if CONFIG_VP9_HIGHBITDEPTH if ( allocated_raw_shift ) vpx_img_free ( & raw_shift }FOREACH_STREAM ( vpx_codec_destroy ( & stream -> encoder ) ) ;",211
303,"FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ;if ( global . pass ) break ;","FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ;if ( global . pass ) break ;",211
304,}# endif vpx_img_free ( & raw ) ;,}# endif vpx_img_free ( & raw ) ;switch ( global . color_type ) {case I420 : input . fmt = VPX_IMG_FMT_I420 ;break ;case I422 : input . fmt = VPX_IMG_FMT_I422 ;break ;case I444 : input . fmt = VPX_IMG_FMT_I444 ;break ;case I440 : input . fmt = VPX_IMG_FMT_I440 ;break ;case YV12 : input . fmt = VPX_IMG_FMT_YV12 ;break ;},211
305,int opts ;Resub m ;,int result ;int opts ;Resub m ;,212
306,"if ( ! js_regexec ( re -> prog , text , & m , opts ) ) {if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ;","result = js_regexec ( re -> prog , text , & m , opts ) ;if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ;if ( result == 0 ) {if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ;",212
307,"uint32_t GetPayloadTime ( size_t handle , uint32_t index , float * in , float * out )  {if ( mp4 == NULL ) return 0 ;if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return 1 ;* in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ;* out = ( float ) ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ;return 0 ;}","uint32_t GetPayloadTime ( size_t handle , uint32_t index , double * in , float * out ) {if ( mp4 == NULL ) return GPMF_ERROR_MEMORY ;if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return GPMF_ERROR_MEMORY ;* in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ;* out = ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ;return GPMF_OK ;}",213
308,uint32_t id ;ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ;,"uint32_t id ;if ( size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;size_left = 0 ;continue ;}ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ;",214
309,"separator = strchr ( connection -> buffer , \':\' ) ;if ( separator != NULL ) {","separator = osStrchr ( connection -> buffer , \':\' ) ;if ( separator != NULL ) {",215
310,if ( option ) {if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE ) && option -> no_auto_window_update ) {,( * session_ptr ) -> max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS ;if ( option ) {if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE ) && option -> no_auto_window_update ) {,216
311,"}rv = nghttp2_hd_deflate_init2 ( & ( * session_ptr ) -> hd_deflater , max_deflate_dynamic_table_size , mem ) ;","if ( ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS ) && option -> max_settings ) {( * session_ptr ) -> max_settings = option -> max_settings ;}}rv = nghttp2_hd_deflate_init2 ( & ( * session_ptr ) -> hd_deflater , max_deflate_dynamic_table_size , mem ) ;",216
312,"if ( rc < 0 )   dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\\","if ( rc != KLSI_STATUSBUF_LEN ) {dev_err ( & port -> dev , ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\\if ( rc >= 0 ) rc = - EIO ;}",217
313,"case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ;w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ;if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ;return 1 ;case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ;cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ;w = cpu -> type ;if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ;return 1 ;case GSI_GET_HWRPB :  if ( nbytes < sizeof ( * hwrpb ) )  return - EINVAL ;",case GSI_UACPROC : if ( nbytes > sizeof ( * hwrpb ) ) return - EINVAL ;,218
314,"else  jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\\}","else {jsExceptionHere ( JSET_ERROR , ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\\return 0 ;}if ( gfx . data . height & 7 ) {jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\\return 0 ;}}",219
315,"if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) )  return 1 ;if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL ||  ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX &&  inode -> i_flock -> fl_type != F_RDLCK ) ) )  return 1 ;",if ( inode -> i_flock == NULL || ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && inode -> i_flock -> fl_type != F_RDLCK ) ) ) return 1 ;,220
316,"static ssize_t _hostsock_recvfrom ( oe_fd_t * sock_ , void * buf , size_t count , int flags ,  const struct oe_sockaddr * src_addr ,  oe_socklen_t * addrlen ) {oe_socklen_t addrlen_in = 0 ;oe_errno = 0 ;if ( ! sock || ( count && ! buf ) )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen ) addrlen_in = * addrlen ;if ( oe_syscall_recvfrom_ocall ( & ret , sock -> host_fd , buf , count , flags ,  ( struct oe_sockaddr * ) src_addr ,  addrlen_in ,  addrlen ) != OE_OK )  {done :  return ret ;","static ssize_t _hostsock_recvfrom ( oe_fd_t * sock_ , void * buf , size_t count , int flags , struct oe_sockaddr * src_addr , oe_socklen_t * addrlen ) {oe_socklen_t addrlen_in = 0 ;oe_socklen_t addrlen_out = 0 ;oe_errno = 0 ;if ( ! sock || ( count && ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( src_addr && addrlen ) addrlen_in = * addrlen ;if ( oe_syscall_recvfrom_ocall ( & ret , sock -> host_fd , buf , count , flags , src_addr , addrlen_in , addrlen ) != OE_OK ) {if ( src_addr && addrlen ) {if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;* addrlen = addrlen_out ;}if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;",221
317,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read )  ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ;else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) {i_temp = ih264d_read_mmco_commands ( ps_dec ) ;if ( i_temp < 0 ) {return ERROR_DBP_MANAGER_T ;}ps_dec -> u4_bitoffset = i_temp ;}else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;,222
318,"static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r ,  int size_group ) {const MB_PREDICTION_MODE y_mode = read_intra_mode ( r ,   cm -> fc . y_mode_prob [ size_group ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ;","static PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , MACROBLOCKD * xd , vpx_reader * r , int size_group ) {const PREDICTION_MODE y_mode = read_intra_mode ( r , cm -> fc -> y_mode_prob [ size_group ] ) ;FRAME_COUNTS * counts = xd -> counts ;if ( counts ) ++ counts -> y_mode [ size_group ] [ y_mode ] ;",223
319,"case MAPI_ATTACH_LONG_FILENAME :  if ( file -> name ) XFREE ( file -> name ) ;file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ;case MAPI_ATTACH_DATA_OBJ :  file -> len = a -> values [ 0 ] . len ;if ( file -> data ) XFREE ( file -> data ) ;case MAPI_ATTACH_MIME_TAG :  if ( file -> mime_type ) XFREE ( file -> mime_type ) ;file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;case MAPI_ATTACH_CONTENT_ID :  if ( file -> content_id ) XFREE ( file -> content_id ) ;file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;","case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ;if ( file -> name ) XFREE ( file -> name ) ;file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ;case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ;file -> len = a -> values [ 0 ] . len ;if ( file -> data ) XFREE ( file -> data ) ;case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ;if ( file -> mime_type ) XFREE ( file -> mime_type ) ;file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;if ( file -> content_id ) XFREE ( file -> content_id ) ;file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ;",224
320,"final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;fl6 -> saddr = ireq -> ir_v6_loc_addr ;fl6 -> flowi6_oif = ireq -> ir_iif ;","rcu_read_lock ( ) ;final_p = fl6_update_dst ( fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;fl6 -> saddr = ireq -> ir_v6_loc_addr ;fl6 -> flowi6_oif = ireq -> ir_iif ;",225
321,new -> cid_mask = 0 ;,new -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;0 ;,226
322,new -> cid_mask = new -> lid_mask = 0xffff ;},new -> cid_mask = new -> lid_mask = 0xffff ;},226
323,"# ifndef CONFIG_ZISOFS case SIG ( \'R\' , \'R\' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ;","# ifndef CONFIG_ZISOFS case SIG ( \'R\' , \'R\' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ;",227
324,"case SIG ( \'E\' , \'R\' ) :  ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ;printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ;","case SIG ( \'E\' , \'R\' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ;printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ;",227
325,"return ( mhlen ) ;break ;if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ;return ( mhlen ) ;trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ( mhlen ) ;}",return ( - 1 ) ;,228
326,int rc = 0 ;if ( ! ss_initialized ) {,int rc = 0 ;if ( ! scontext_len ) return - EINVAL ;if ( ! ss_initialized ) {,229
327,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,230
328,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",230
329,"
",LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;,230
330,l_row -- ;l_column -- ;,l_row -- ;l_column -- ;,230
331,"float * w = get_window ( f , n ) ;for ( i = 0 ;","float * w = get_window ( f , n ) ;if ( w == NULL ) return 0 ;for ( i = 0 ;",231
332,"if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) {ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ;","if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ;",232
333,for ( n = 0 ;n ++ )  {,"if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;for ( n = 0 ;n ++ ) {",232
334,"struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;int i , j ;","tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;int i , j ;",233
335,"if ( ! x -> skip_recode )   vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) {optimize_b ( plane , block , plane_bsize , tx_size , x , a , l ) ;}switch ( tx_size ) {case TX_32X32 :  vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_16X16 :  vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_8X8 :  vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_4X4 :  xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;}","if ( ! x -> skip_recode ) {if ( x -> quant_fp ) {if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC && plane == 0 ) {p -> eobs [ block ] = 0 ;* a = * l = 0 ;return ;}else {vp9_xform_quant_fp ( x , plane , block , plane_bsize , tx_size ) ;}else if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_AC_ONLY ) {vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ;}else {p -> eobs [ block ] = 0 ;* a = * l = 0 ;return ;}}else {vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;}}}}}else {if ( max_txsize_lookup [ plane_bsize ] == tx_size ) {int txfm_blk_index = ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ;if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_NONE ) {vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) {const int ctx = combine_entropy_contexts ( * a , * l ) ;* a = * l = optimize_b ( x , plane , block , tx_size , ctx ) > 0 ;}# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {switch ( tx_size ) {case TX_32X32 : vp9_highbd_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;break ;case TX_16X16 : vp9_highbd_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;break ;case TX_8X8 : vp9_highbd_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;break ;case TX_4X4 : x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;break ;default : assert ( 0 && ""Invalid<S2SV_blank>transform<S2SV_blank>size"" ) ;}return ;}# endif switch ( tx_size ) {case TX_32X32 : vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_16X16 : vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_8X8 : vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;case TX_4X4 : x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;break ;break ;}",233
336,"
","if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",234
337,iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;,iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;,234
338,int i ;int j ;int rowstep ;jas_seqent_t * data ;,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;jas_seqent_t * data ;,235
339,for ( ifa1 = in_dev -> ifa_list ;if ( ifa1 == ifa ) {,if ( in_dev -> dead ) goto no_promotions ;for ( ifa1 = in_dev -> ifa_list ;if ( ifa1 == ifa ) {,236
340,"}if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ;","}no_promotions : if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ;",236
341,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,237
342,BUG ( ) ;}BUG ( ) ;},return false ;}}else if ( r -> CRn == 0 && r -> CRm == 9 ) {if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ;idx = ARMV8_PMU_CYCLE_IDX ;return false ;},238
343,"static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx )  {make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ;index = pending_index ( netbk -> pending_prod ++ ) ;","static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx , u8 status ) {make_tx_response ( vif , & pending_tx_info -> req , status ) ;index = pending_index ( netbk -> pending_prod ++ ) ;",239
344,"goto try_again ;req -> status = 0 ;req -> zero = 0 ;req -> length = count ;req -> complete = f_hidg_req_complete ;req -> context = hidg ;status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ;if ( status < 0 ) {ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\\goto release_write_pending_unlocked ;}spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked :  hidg -> write_pending = 0 ;","goto release_write_pending ;spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked : hidg -> write_pending = 0 ;",240
345,"ret = snprintf ( path , PATH_MAX , SBINDIR ""/init.lxc.static"" ) ;","ret = safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount ) ;",241
346,"ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ;if ( ret < 0 ) SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container"" ) ;","ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ;if ( ret < 0 ) SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container"" ) ;",241
347,"status = ocfs2_rw_lock ( inode , 1 ) ;if ( status < 0 ) {","inode_dio_wait ( inode ) ;status = ocfs2_rw_lock ( inode , 1 ) ;if ( status < 0 ) {",242
348,if ( status )  goto bail_unlock ;inode_dio_wait ( inode ) ;,if ( status ) goto bail_unlock ;,242
349,"count = yr_max ( 64 , ( index + 1 ) * 2 ) ;array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc (  array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;","count = 64 ;while ( count <= index ) count *= 2 ;array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;while ( count <= index ) count *= 2 ;array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ;",243
350,"if ( offset >= ARRAY_SIZE ( sysinfo_table ) ) {printk ( ""sysinfo(%d)"" , command ) ;goto out ;}down_read ( & uts_sem ) ;res = sysinfo_table [ offset ] ;len = strlen ( res ) + 1 ;if ( len > count )  len = count ;",if ( ( unsigned long ) len > ( unsigned long ) count ) len = count ;,244
351,"if ( ( mask & ~ ALL_PRINC_MASK ) )  return KADM5_BAD_MASK ;ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;","if ( mask & KADM5_TL_DATA ) {for ( tl_data_tail = entry -> tl_data ;tl_data_tail != NULL ;tl_data_tail = tl_data_tail -> tl_data_next ) {if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ;}}if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;",245
352,"int rose_parse_facilities ( unsigned char * p ,  struct rose_facilities_struct * facilities ) {if ( facilities_len == 0 )  return 0 ;while ( facilities_len > 0 ) {if ( * p == 0x00 ) {if ( len < 0 )  return 0 ;facilities_len -= len + 1 ;p += len + 1 ;if ( len < 0 )  return 0 ;facilities_len -= len + 1 ;p += len + 1 ;break ;default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\\facilities_len -- ;p ++ ;else break ;}return 1 ;","int rose_parse_facilities ( unsigned char * p , unsigned packet_len , struct rose_facilities_struct * facilities ) {if ( facilities_len == 0 || ( unsigned ) facilities_len > packet_len ) return 0 ;while ( facilities_len >= 3 && * p == 0x00 ) {break ;default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\\len = 1 ;if ( len < 0 ) return 0 ;if ( WARN_ON ( len >= facilities_len ) ) return 0 ;facilities_len -= len + 1 ;return facilities_len == 0 ;",246
353,"if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) &&  ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {","if ( ( creds -> pid == task_tgid_vnr ( current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) {",247
354,"outpos +=  sprintf ( outpos , ""\\\}","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",248
355,"media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ;if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ;","memset ( & pad , 0 , sizeof ( pad ) ) ;media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ;if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ;",249
356,"media_device_kpad_to_upad ( entity -> links [ l ] . source ,  & link . source ) ;","memset ( & link , 0 , sizeof ( link ) ) ;media_device_kpad_to_upad ( entity -> links [ l ] . source , & link . source ) ;",249
357,efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ;rc = efx_probe_channels ( efx ) ;,BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ;if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) {rc = - EINVAL ;goto fail3 ;}efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ;rc = efx_probe_channels ( efx ) ;,250
358,struct sock * sk = sock -> sk ;struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ;,struct sock * sk = sock -> sk ;,251
359,if ( ! err ) {if ( sat ) {}msg -> msg_namelen = sizeof ( * sat ) ;,if ( ! err && msg -> msg_name ) {struct sockaddr_at * sat = msg -> msg_name ;msg -> msg_namelen = sizeof ( * sat ) ;,251
360,"if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ;GET_HANDLE ( ) ;if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) {st = EINVAL ;k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ;goto cleanup ;}if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ;filtuser = ldap_filter_correct ( user ) ;if ( filtuser == NULL ) {st = ENOMEM ;goto cleanup ;}if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ;else optype = MODIFY_PRINCIPAL ;if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ;if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ;if ( entry -> mask & KADM5_LOAD ) {unsigned int tree = 0 ;int numlentries = 0 ;char * filter = NULL ;if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) {filter = NULL ;if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ;found_entry = FALSE ;for ( tree = 0 ;found_entry == FALSE && tree < ntrees ;++ tree ) {if ( principal_dn == NULL ) {LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ;}else {LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ;}if ( st == LDAP_SUCCESS ) {numlentries = ldap_count_entries ( ld , result ) ;if ( numlentries > 1 ) {free ( filter ) ;st = EINVAL ;k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>found"" ) , user ) ;goto cleanup ;}else if ( numlentries == 1 ) {found_entry = TRUE ;if ( principal_dn == NULL ) {ent = ldap_first_entry ( ld , result ) ;if ( ent != NULL ) {if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) {ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ;st = set_ldap_error ( context , st , 0 ) ;free ( filter ) ;goto cleanup ;}}}}}else if ( st != LDAP_NO_SUCH_OBJECT ) {st = set_ldap_error ( context , st , 0 ) ;free ( filter ) ;goto cleanup ;}ldap_msgfree ( result ) ;result = NULL ;}free ( filter ) ;if ( found_entry == FALSE && principal_dn != NULL ) {create_standalone_prinicipal = TRUE ;standalone_principal_dn = strdup ( principal_dn ) ;CHECK_NULL ( standalone_principal_dn ) ;}}if ( principal_dn == NULL && xargs . dn == NULL ) {if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) {subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;}else if ( xargs . containerdn ) {if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) {if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) {int ost = st ;st = EINVAL ;k5_prependmsg ( context , ost , st , _ ( ""\\\'%s\\\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ;}goto cleanup ;}subtree = strdup ( xargs . containerdn ) ;}else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) {subtree = strdup ( ldap_context -> lrparams -> containerref ) ;}else {subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;}CHECK_NULL ( subtree ) ;if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ;CHECK_NULL ( standalone_principal_dn ) ;create_standalone_prinicipal = TRUE ;free ( subtree ) ;subtree = NULL ;}if ( xargs . dn_from_kbd == TRUE ) {int dnlen = 0 , subtreelen = 0 ;char * dn = NULL ;krb5_boolean outofsubtree = TRUE ;if ( xargs . dn != NULL ) {dn = xargs . dn ;}else if ( xargs . linkdn != NULL ) {dn = xargs . linkdn ;}else if ( standalone_principal_dn != NULL ) {dn = standalone_principal_dn ;}if ( subtreelist == NULL ) {st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ;if ( st ) goto cleanup ;}for ( tre = 0 ;tre < ntrees ;++ tre ) {if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) {outofsubtree = FALSE ;break ;}else {dnlen = strlen ( dn ) ;subtreelen = strlen ( subtreelist [ tre ] ) ;if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) {outofsubtree = FALSE ;break ;}}}if ( outofsubtree == TRUE ) {st = EINVAL ;k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ;goto cleanup ;}if ( standalone_principal_dn == NULL ) {char * attributes [ ] = {""krbticketpolicyreference"" , ""krbprincipalname"" , NULL };ldap_msgfree ( result ) ;result = NULL ;LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ;if ( st == LDAP_SUCCESS ) {ent = ldap_first_entry ( ld , result ) ;if ( ent != NULL ) {if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) {ldap_value_free ( values ) ;}if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) {krb_identity_exists = TRUE ;ldap_value_free ( values ) ;}}}else {st = set_ldap_error ( context , st , OP_SEARCH ) ;goto cleanup ;}}}if ( xargs . dn != NULL && krb_identity_exists == TRUE ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}if ( xargs . linkdn != NULL ) {if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}{char * * linkdns = NULL ;int j = 0 ;if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) {snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}if ( linkdns != NULL ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;for ( j = 0 ;linkdns [ j ] != NULL ;++ j ) free ( linkdns [ j ] ) ;free ( linkdns ) ;goto cleanup ;}}establish_links = TRUE ;}if ( entry -> mask & KADM5_LAST_SUCCESS ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_LAST_FAILED ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) {krb5_kvno fail_auth_count ;fail_auth_count = entry -> fail_auth_count ;if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ;st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ;if ( st != 0 ) goto cleanup ;}else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) {int attr_mask = 0 ;krb5_boolean has_fail_count ;st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ;if ( st != 0 ) goto cleanup ;has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ;# ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ;if ( st != 0 ) goto cleanup ;}else {# endif if ( has_fail_count ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ;if ( st != 0 ) goto cleanup ;}st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ;if ( st != 0 ) goto cleanup ;# ifdef LDAP_MOD_INCREMENT }# endif }else if ( optype == ADD_PRINCIPAL ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ;}if ( entry -> mask & KADM5_MAX_LIFE ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_MAX_RLIFE ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_ATTRIBUTES ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_PRINCIPAL ) {memset ( strval , 0 , sizeof ( strval ) ) ;strval [ 0 ] = user ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_PW_EXPIRATION ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_POLICY ) {memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ;for ( tl_data = entry -> tl_data ;tl_data ;tl_data = tl_data -> tl_data_next ) {if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) {if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) {goto cleanup ;}break ;}}if ( princ_ent . aux_attributes & KADM5_POLICY ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ;strval [ 0 ] = polname ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;}else {st = EINVAL ;k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ;goto cleanup ;}}else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) {if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_POLICY_CLR ) {if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) {krb5_kvno mkvno ;if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ;bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ;if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" ,   LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 )  goto cleanup ;","if ( bersecretkey == NULL ) {+ tree ) {+ tre ) {+ j ) free ( linkdns [ j ] ) ;if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) {st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) goto cleanup ;",252
361,"pirlvl = pi -> picomp -> pirlvls ;pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;","pirlvl = pi -> picomp -> pirlvls ;if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;",253
362,if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",253
363,bh -> b_size = map . m_len << inode -> i_blkbits ;},bh -> b_size = ( u64 ) map . m_len << inode -> i_blkbits ;},254
364,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;int hsub = s -> draw . hsub [ plane ] ;,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ;int hsub = s -> draw . hsub [ plane ] ;,255
365,"memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;","if ( l > ll ) l = ll ;memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;VFP_Extend ( bo -> vfc , l ) ;",256
366,addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;,"memset ( addr , 0 , sizeof ( * addr ) ) ;addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;",257
367,file_sb_list_del ( file ) ;BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ;,BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ;,258
368,for ( i = 0 ;i < 4 && out -> data [ i ] ;int hsub = s -> draw . hsub [ i ] ;,for ( i = 0 ;i < 4 && out -> data [ i ] && out -> linesize [ i ] ;int hsub = s -> draw . hsub [ i ] ;,259
369,WORD16 i2_level_arr [ 16 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,WORD16 ai2_level_arr [ 19 ] ;WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,260
370,"image = 0 ;info = 0 ;if ( optstr ) {jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\\","bmp_dec_importopts_t opts ;size_t num_samples ;image = 0 ;info = 0 ;if ( bmp_dec_parseopts ( optstr , & opts ) ) {goto error ;",261
371,"jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\\goto error ;","jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\\goto error ;}if ( ! jas_safe_size_mul3 ( info -> width , info -> height , info -> numplanes , & num_samples ) ) {jas_eprintf ( ""image<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\\goto error ;}if ( opts . max_samples > 0 && num_samples > opts . max_samples ) {jas_eprintf ( ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>pixels<S2SV_blank>exceeded<S2SV_blank>(%zu)\\\goto error ;",261
372,"q = strchr ( context -> buffer , '<S2SV_blank>' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;q = strchr ( uri , '<S2SV_blank>' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;","q = osStrchr ( context -> buffer , '<S2SV_blank>' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;q = osStrchr ( uri , '<S2SV_blank>' ) ;if ( q == NULL ) return ERROR_INVALID_SYNTAX ;",262
373,"BUG_ON ( ! thresholds ) ;usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ;","BUG_ON ( ! thresholds ) ;if ( ! thresholds -> primary ) goto unlock ;usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ;",263
374,mutex_unlock ( & memcg -> thresholds_lock ) ;},unlock : mutex_unlock ( & memcg -> thresholds_lock ) ;},263
375,"char query [ 255 ] ;MYSQL_FIELD * field ;fprintf ( stderr , ""%s:<S2SV_blank>Cannot<S2SV_blank>list<S2SV_blank>databases:<S2SV_blank>%s\\\return 1 ;}if ( wild && mysql_num_rows ( result ) == 1 ) {row = mysql_fetch_row ( result ) ;if ( ! my_strcasecmp ( & my_charset_latin1 , row [ 0 ] , wild ) ) {mysql_free_result ( result ) ;if ( opt_status ) return list_table_status ( mysql , wild , NULL ) ;else return list_tables ( mysql , wild , NULL ) ;}}if ( wild ) printf ( ""Wildcard:<S2SV_blank>%s\\\header = ""Databases"" ;length = ( uint ) strlen ( header ) ;field = mysql_fetch_field ( result ) ;if ( length < field -> max_length ) length = field -> max_length ;if ( ! opt_verbose ) print_header ( header , length , NullS ) ;else if ( opt_verbose == 1 ) print_header ( header , length , ""Tables"" , 6 , NullS ) ;else print_header ( header , length , ""Tables"" , 6 , ""Total<S2SV_blank>Rows"" , 12 , NullS ) ;while ( row || ( row = mysql_fetch_row ( result ) ) ) {counter ++ ;if ( opt_verbose ) {if ( ! ( mysql_select_db ( mysql , row [ 0 ] ) ) ) {MYSQL_RES * tresult = mysql_list_tables ( mysql , ( char * ) NULL ) ;if ( mysql_affected_rows ( mysql ) > 0 ) {sprintf ( tables , ""%6lu"" , ( ulong ) mysql_affected_rows ( mysql ) ) ;rowcount = 0 ;if ( opt_verbose > 1 ) {MYSQL_ROW trow ;while ( ( trow = mysql_fetch_row ( tresult ) ) ) {sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , trow [ 0 ] ) ;if ( ! ( mysql_query ( mysql , query ) ) ) {","char query [ NAME_LEN + 100 ] ;MYSQL_FIELD * field ;my_snprintf ( query , sizeof ( query ) , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , trow [ 0 ] ) ;if ( ! ( mysql_query ( mysql , query ) ) ) {",264
376,}return 0 ;,return - ENOMEM ;}return 0 ;,265
377,"skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ;if ( ! skb ) goto read_error ;","m -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ;if ( ! skb ) goto read_error ;",266
378,"tok -> err = json_tokener_success ;while ( PEEK_CHAR ( c , tok ) ) {","tok -> err = json_tokener_success ;if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) {tok -> err = json_tokener_error_size ;return NULL ;}while ( PEEK_CHAR ( c , tok ) ) {",267
379,"ascii = malloc ( strlen ( str ) + 1 ) ;strncpy ( ascii , str , strlen ( str ) + 1 ) ;","ascii = safe_calloc ( strlen ( str ) + 1 ) ;strncpy ( ascii , str , strlen ( str ) + 1 ) ;",268
380,ascii = malloc ( str_len ) ;for ( ;,ascii = safe_calloc ( str_len ) ;for ( ;,268
381,"char * *  prepenv ( const struct rule * rule )  {static const char * safeset [ ] = {""DISPLAY"" , ""HOME"" , ""LOGNAME"" , ""MAIL"" , ""PATH"" , ""TERM"" , ""USER"" , ""USERNAME"" , NULL };env = createenv ( rule ) ;if ( ! ( rule -> options & KEEPENV ) ) fillenv ( env , safeset ) ;","char * * prepenv ( const struct rule * rule , const struct passwd * mypw , const struct passwd * targpw ) {env = createenv ( rule ) ;if ( ! ( rule -> options & KEEPENV ) ) fillenv ( env , safeset ) ;",269
382,"if ( hashbin -> hb_type & HB_LOCK ) {spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ;}queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;while ( queue ) {if ( free_func )  ( * free_func ) ( queue ) ;queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;}}hashbin -> hb_current = NULL ;hashbin -> magic = ~ HB_MAGIC ;if ( hashbin -> hb_type & HB_LOCK ) {spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP  hashbin_lock_depth -- ;","if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ;while ( 1 ) {queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ;if ( ! queue ) break ;if ( free_func ) {if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;free_func ( queue ) ;if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ;# ifdef CONFIG_LOCKDEP hashbin_lock_depth -- ;",270
383,section -> spatial_layer_id = frame -> spatial_layer_id ;section -> intra_error += frame -> intra_error ;section -> coded_error += frame -> coded_error ;section -> sr_coded_error += frame -> sr_coded_error ;section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ;section -> pcnt_inter += frame -> pcnt_inter ;section -> pcnt_neutral += frame -> pcnt_neutral ;section -> MVr += frame -> MVr ;,section -> pcnt_inter += frame -> pcnt_inter ;section -> pcnt_neutral += frame -> pcnt_neutral ;section -> intra_skip_pct += frame -> intra_skip_pct ;section -> inactive_zone_rows += frame -> inactive_zone_rows ;section -> inactive_zone_cols += frame -> inactive_zone_cols ;section -> MVr += frame -> MVr ;,271
384,struct loop_device * lo = disk -> private_data ;int err ;if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ;mutex_lock ( & lo -> lo_ctl_mutex ) ;if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) {err = loop_clr_fd ( lo ) ;if ( ! err ) return ;else if ( lo -> lo_state == Lo_bound ) {blk_mq_freeze_queue ( lo -> lo_queue ) ;blk_mq_unfreeze_queue ( lo -> lo_queue ) ;}mutex_unlock ( & lo -> lo_ctl_mutex ) ;},mutex_lock ( & loop_index_mutex ) ;__lo_release ( disk -> private_data ) ;mutex_unlock ( & lo -> lo_ctl_mutex ) ;,272
385,"
","if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) {ret = - ENOENT ;goto out ;}",273
386,"if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {sb -> st_mode = S_IFDIR | 00555 ;",273
387,error = 0 ;if ( pkt == NULL ) continue ;,error = 0 ;,274
388,countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ;newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ;,tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ;newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ;,275
389,"unsigned char * buf ;assert ( m -> buf_ ) ;if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) {return - 1 ;","unsigned char * buf ;assert ( m -> buf_ ) ;if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {return - 1 ;",276
390,case SO_SNDBUF :  if ( val > sysctl_wmem_max )  val = sysctl_wmem_max ;if ( ( val * 2 ) < SOCK_MIN_SNDBUF )  sk -> sk_sndbuf = SOCK_MIN_SNDBUF ;else sk -> sk_sndbuf = val * 2 ;,"case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ;sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ;",277
391,case SO_RCVBUF :  if ( val > sysctl_rmem_max )  val = sysctl_rmem_max ;if ( ( val * 2 ) < SOCK_MIN_RCVBUF )  sk -> sk_rcvbuf = SOCK_MIN_RCVBUF ;else sk -> sk_rcvbuf = val * 2 ;,"case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ;sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ;",277
392,x < ( ssize_t ) image -> columns ;,"x < ( ssize_t ) ConstrainColormapIndex ( image , image -> columns ;",278
393,"SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;","SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , exception ) , q ) ;",278
394,"SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t )  GetPixelIndex ( image , q ) , q ) ;q += GetPixelChannels ( image ) ;","SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) GetPixelIndex ( image , q ) , q ) ;q += GetPixelChannels ( image ) ;",278
395,"# endif  while ( ( ch = getopt ( ac , av , ""cDdksE:a:t:"" ) ) != - 1 ) {switch ( ch ) {case \'k\' :  k_flag ++ ;break ;","# endif while ( ( ch = getopt ( ac , av , ""cDdksE:a:P:t:"" ) ) != - 1 ) {switch ( ch ) {case \'k\' : k_flag ++ ;break ;case \'P\' : if ( pkcs11_whitelist != NULL ) fatal ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ;pkcs11_whitelist = xstrdup ( optarg ) ;break ;",279
396,"if ( ac == 0 && ! c_flag && ! s_flag ) {shell = getenv ( ""SHELL"" ) ;","if ( pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ;if ( ac == 0 && ! c_flag && ! s_flag ) {shell = getenv ( ""SHELL"" ) ;",279
397,"if ( pledge ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 )  fatal ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , __progname , strerror ( errno ) ) ;","if ( pledge ( ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 ) fatal ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , __progname , strerror ( errno ) ) ;",279
398,int i ;int j ;,jas_matind_t i ;jas_matind_t j ;,280
399,"if ( sport == 1719 || dport == 1719 )  {if ( packet -> payload [ 0 ] == 0x16 && packet -> payload [ 1 ] == 0x80 && packet -> payload [ 4 ] == 0x06 && packet -> payload [ 5 ] == 0x00 )   {NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\\","if ( sport == 1719 || dport == 1719 ) {if ( ( packet -> payload_packet_len >= 5 ) && ( packet -> payload [ 0 ] == 0x16 ) && ( packet -> payload [ 1 ] == 0x80 ) && ( packet -> payload [ 4 ] == 0x06 ) && ( packet -> payload [ 5 ] == 0x00 ) ) {NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>H323<S2SV_blank>broadcast\\\",281
400,mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ;mnt -> mnt . mnt_flags = mnt_flags ;,mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ;mnt -> mnt . mnt_flags = mnt_flags ;,282
401,"# else  path = g_get_tmp_dir ( ) ;# endif filename = g_build_filename ( path , "".ettercap_gtk"" , NULL ) ;","# else path = g_get_home_dir ( ) ;# endif filename = g_build_filename ( path , "".ettercap_gtk"" , NULL ) ;",283
402,"switch ( fmt ) {case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : xcs = 1 ;break ;default : xcs = 0 ;break ;}switch ( fmt ) {case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I440 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 : ycs = 1 ;break ;default : ycs = 0 ;break ;}align = ( 1 << xcs ) - 1 ;w = ( d_w + align ) & ~ align ;align = ( 1 << ycs ) - 1 ;h = ( d_h + align ) & ~ align ;if ( ! img ) {img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;if ( ! img ) goto fail ;img -> self_allocd = 1 ;}else {memset ( img , 0 , sizeof ( vpx_image_t ) ) ;}img -> img_data = img_data ;if ( ! img_data ) {const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ;",w = d_w ;h = d_h ;alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ;,284
403,"INIT_LIST_HEAD ( & f -> f_u . fu_list ) ;atomic_long_set ( & f -> f_count , 1 ) ;","atomic_long_set ( & f -> f_count , 1 ) ;",285
404,saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;saddr . sin_port = htons ( port ) ;,saddr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;saddr . sin_port = htons ( port ) ;,286
405,if ( count < sizeof hdr )  return - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( count < sizeof hdr ) return - EINVAL ;,287
406,len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;offset += 4 + len ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;,if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;offset += 4 + len ;if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;,288
407,len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( ! client_hash ) {,if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( ! client_hash ) {,288
408,len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( client_hash ) {,if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( client_hash ) {,288
409,len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( ! client_hash ) {,if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;if ( ! client_hash ) {,288
410,"
",if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ;,288
411,else  offset += 4 + len ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;,else offset += 4 + len ;len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ;,288
412,"
",if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;},289
413,jumpstack [ stackidx ++ ] = e ;},jumpstack [ stackidx ++ ] = e ;},289
414,for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,290
415,"list_add_tail ( & info -> list , & xen_irq_list_head ) ;}","INIT_LIST_HEAD ( & info -> eoi_list ) ;list_add_tail ( & info -> list , & xen_irq_list_head ) ;}",291
416,"const VP9_COMMON * const cm = & cpi -> common ;const VP9_CONFIG * oxcf = & cpi -> oxcf ;rc -> bits_off_target += rc -> av_per_frame_bandwidth - encoded_frame_size ;}rc -> bits_off_target = MIN ( rc -> bits_off_target , oxcf -> maximum_buffer_size ) ;rc -> buffer_level = rc -> bits_off_target ;if ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {update_layer_buffer_level ( & cpi -> svc , encoded_frame_size ) ;","const VP9_COMMON * const cm = & cpi -> common ;rc -> bits_off_target += rc -> avg_frame_bandwidth - encoded_frame_size ;}rc -> bits_off_target = MIN ( rc -> bits_off_target , rc -> maximum_buffer_size ) ;rc -> buffer_level = rc -> bits_off_target ;if ( is_one_pass_cbr_svc ( cpi ) ) {update_layer_buffer_level ( & cpi -> svc , encoded_frame_size ) ;",292
417,sun_info . height = ReadBlobMSBLong ( image ) ;sun_info . depth = ReadBlobMSBLong ( image ) ;sun_info . length = ReadBlobMSBLong ( image ) ;sun_info . type = ReadBlobMSBLong ( image ) ;sun_info . maptype = ReadBlobMSBLong ( image ) ;sun_info . maplength = ReadBlobMSBLong ( image ) ;extent = sun_info . height * sun_info . width ;,bytes_per_line = sun_info . width * sun_info . depth ;sun_info . height ;,293
418,"sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length ,   sizeof ( * sun_data ) ) ;if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;height = sun_info . height ;bytes_per_line = sun_info . width * sun_info . depth ;","sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ;if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;height = sun_info . height ;bytes_per_line = sun_info . width * sun_info . depth ;",293
419,return 0 ;},skip_metadata ( ps ) ;return 0 ;},294
420,"if ( strchr ( argv [ 1 ] , \'<S2SV_blank>\' ) ) {","# if 0 if ( strchr ( argv [ 1 ] , \'<S2SV_blank>\' ) ) {",295
421,logmode = LOGMODE_JOURNAL ;,# endif logmode = LOGMODE_JOURNAL ;,295
422,"{char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ;","{char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ;",295
423,}dd_close ( dd ) ;,}dd_close ( dd ) ;,295
424,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,296
425,"error = copy_to_user ( buf , & socket_packet -> icmp_packet ,   socket_packet -> icmp_len ) ;packet_len = socket_packet -> icmp_len ;","packet_len = min ( count , socket_packet -> icmp_len ) ;error = copy_to_user ( buf , & socket_packet -> icmp_packet , packet_len ) ;",297
426,return 0 ;},if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;return 0 ;},298
427,"uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ;unsigned char * channel_identities = NULL ;","uint32_t chan_chunk = 0 , desc_chunk = 0 , channel_layout = 0 , bcount ;unsigned char * channel_identities = NULL ;",299
428,"WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;if ( debug_logging_mode ) {","WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;desc_chunk = 1 ;if ( debug_logging_mode ) {",299
429,else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ;,else if ( ! desc_chunk || ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ;,299
430,"if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) ||  bcount != sizeof ( mEditCount ) ) {","if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) {",299
431,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;set_acl_inode ( inode , inode -> i_mode ) ;if ( error == 0 ) acl = NULL ;","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;",300
432,"
","{uint8_t computedHvi [ 32 ] ;uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ;uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ;uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ;memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ;memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ;zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ;free ( DHPartHelloMessageString ) ;if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) {free ( messageData ) ;return BZRTP_PARSER_ERROR_UNMATCHINGHVI ;}}",301
433,}uint8_t checkH2 [ 32 ] ;,}uint8_t checkH2 [ 32 ] ;,301
434,"}err = hidp_connection_add ( & ca , csock , isock ) ;","}ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;err = hidp_connection_add ( & ca , csock , isock ) ;",302
435,if ( keyring ) {,if ( keyring && link_ret == 0 ) {,303
436,"if ( keyring )  __key_link_end ( keyring , & key -> index_key , edit ) ;","if ( keyring ) __key_link_end ( keyring , & key -> index_key , edit ) ;",303
437,"size_t ld ;const char * data = luaL_checklstring ( L , 2 , & ld ) ;size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ;int n = 0 ;size_t size = optsize ( L , opt , & fmt ) ;pos += gettoalign ( pos , & h , opt , size ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;","luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ;pos -- ;int n = 0 ;size_t size = optsize ( L , size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;",304
438,"up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE ,  & control -> id ) ;return 0 ;","struct snd_ctl_elem_id id = control -> id ;up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , & id ) ;return 0 ;",305
439,evtchn = info -> evtchn ;if ( ! VALID_EVTCHN ( evtchn ) )  return ;,"unsigned int cpu ;evtchn = info -> evtchn ;if ( ! VALID_EVTCHN ( evtchn ) || ! list_empty ( & info -> eoi_list ) ) return ;cpu = info -> eoi_cpu ;if ( info -> eoi_time && info -> irq_epoch == per_cpu ( irq_epoch , cpu ) ) {lateeoi_list_add ( info ) ;return ;}info -> eoi_time = 0 ;",306
440,"static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , va_list args ) {",307
441,# else  return VPX_CODEC_INCAPABLE ;# endif },# else ( void ) ctx ;( void ) args ;return VPX_CODEC_INCAPABLE ;# endif },307
442,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ;if ( current -> pid != previous_pid ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , regs -> ARM_pc ) ;if ( current -> pid != previous_pid ) {",308
443,"struct file * file = vma -> vm_file ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {","struct file * file = vma -> vm_file ) ;down_read ( & EXT4_I ( inode ) -> i_mmap_sem ;file_update_time ( vma -> vm_file ) ;if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) {",309
444,out :  sb_end_pagefault ( inode -> i_sb ) ;return ret ;,out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;sb_end_pagefault ( inode -> i_sb ) ;return ret ;,309
445,"uint8_t * const buffers [ 4 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer ,  src -> alpha_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride , src -> uv_stride ,  src -> alpha_stride }","uint8_t * const buffers [ 3 ] = {src -> y_buffer , src -> u_buffer , src -> v_buffer }const int strides [ 4 ] = {src -> y_stride , src -> uv_stride }",310
446,"char * buf , * payload ;uint32_t * payload32 ;int ret = - 1 , result = - 1 ;int total = 0 ;ws_mask_t mask ;","int result = - 1 , result = - 1 ;int total = 0 ;ws_mask_t mask ;",311
447,"}else if ( 0 == ret ) {result = 0 ;else {errno = EAGAIN ;}goto spor ;}opcode = header -> b0 & 0x0f ;flength = header -> b1 & 0x7f ;if ( ! ( header -> b1 & 0x80 ) ) {rfbErr ( ""%s:<S2SV_blank>got<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>mask\\\errno = EIO ;goto spor ;}if ( flength < 126 ) {fhlen = 2 ;mask = header -> u . m ;}else if ( flength == 126 && 4 <= ret ) {flength = WS_NTOH16 ( header -> u . s16 . l16 ) ;fhlen = 4 ;mask = header -> u . s16 . m16 ;}else if ( flength == 127 && 10 <= ret ) {flength = WS_NTOH64 ( header -> u . s64 . l64 ) ;fhlen = 10 ;mask = header -> u . s64 . m64 ;}else {rfbErr ( ""%s:<S2SV_blank>incomplete<S2SV_blank>frame<S2SV_blank>header\\\errno = EIO ;goto spor ;}total = fhlen + flength + 4 ;payload = buf + fhlen + 4 ;if ( - 1 == ( ret = ws_read ( cl , buf , total ) ) ) {int olderrno = errno ;rfbErr ( ""%s:<S2SV_blank>read;<S2SV_blank>%m"" , __func__ ) ;errno = olderrno ;return ret ;}else if ( ret < total ) {rfbLog ( ""%s:<S2SV_blank>read;<S2SV_blank>got<S2SV_blank>partial<S2SV_blank>data\\\}else {buf [ ret ] = \'\\\\0\' ;}payload32 = ( uint32_t * ) payload ;for ( i = 0 ;i < flength / 4 ;i ++ ) {payload32 [ i ] ^= mask . u ;}for ( i *= 4 ;i < flength ;i ++ ) {payload [ i ] ^= mask . c [ i % 4 ] ;}switch ( opcode ) {case WS_OPCODE_CLOSE : rfbLog ( ""got<S2SV_blank>closure,<S2SV_blank>reason<S2SV_blank>%d\\\errno = ECONNRESET ;break ;case WS_OPCODE_TEXT_FRAME : if ( - 1 == ( flength = b64_pton ( payload , ( unsigned char * ) wsctx -> codeBufDecode , sizeof ( wsctx -> codeBufDecode ) ) ) ) {rfbErr ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%m\\\break ;}payload = wsctx -> codeBufDecode ;case WS_OPCODE_BINARY_FRAME : if ( flength > len ) {memcpy ( wsctx -> readbuf , payload + len , flength - len ) ;wsctx -> readbufstart = 0 ;wsctx -> readbuflen = flength - len ;flength = len ;}memcpy ( dst , payload , flength ) ;result = flength ;break ;default : rfbErr ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\\spor : return result ;","else if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) {hybiDecodeCleanup ( wsctx ) ;rfbLog ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\\return result ;",311
448,double motion_pct = next_frame -> pcnt_motion ;prediction_decay_rate = next_frame -> pcnt_inter ;,double motion_pct = next_frame -> pcnt_motion ;( void ) cpi ;prediction_decay_rate = next_frame -> pcnt_inter ;,312
449,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;ext4_mark_inode_dirty ( handle , inode ) ;if ( error == 0 )  acl = NULL ;}","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",313
450,"if ( level != SOL_IP ) return - EOPNOTSUPP ;if ( ip_mroute_opt ( optname ) ) return ip_mroute_getsockopt ( sk , optname , optval , optlen ) ;","if ( inet_opt ) memcpy ( optbuf , & inet_opt -> opt , sizeof ( struct ip_options ) + inet_opt -> opt . optlen ) ;",314
451,"opt -> optlen = 0 ;if ( inet -> opt )  memcpy ( optbuf , inet -> opt , sizeof ( struct ip_options ) + inet -> opt -> optlen ) ;","struct ip_options_rcu * inet_opt ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;opt -> optlen = 0 ;if ( inet -> opt ) memcpy ( optbuf , inet -> opt , sizeof ( struct ip_options ) + inet -> opt -> optlen ) ;",314
452,"UINT32 PathLength ;Stream_Seek ( irp -> input , 28 ) ;Stream_Read_UINT32 ( irp -> input , PathLength ) ;status = ConvertFromUnicode ( CP_UTF8 , 0 , ( WCHAR * ) Stream_Pointer ( irp -> input ) , PathLength / 2 ,  & path , 0 , NULL , NULL ) ;","WCHAR * ptr ;UINT32 PathLength ;if ( ! Stream_SafeSeek ( irp -> input , 28 ) ) return ERROR_INVALID_DATA ;if ( Stream_GetRemainingLength ( irp -> input ) < 4 ) return ERROR_INVALID_DATA ;Stream_Read_UINT32 ( irp -> input , PathLength ) ;ptr = ( WCHAR * ) Stream_Pointer ( irp -> input ) ;if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ;status = ConvertFromUnicode ( CP_UTF8 , 0 , ptr , PathLength / 2 , & path , 0 , NULL , NULL ) ;",315
453,"ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;",316
454,void * buffer ;buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ;,void * buffer ;if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL ;buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ;,317
455,"if ( p7 -> d . ptr == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ;return NULL ;}i = OBJ_obj2nid ( p7 -> type ) ;p7 -> state = PKCS7_S_HEADER ;switch ( i ) {case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ;if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ;goto err ;}md_sk = p7 -> d . sign -> md_algs ;break ;case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ;md_sk = p7 -> d . signed_and_enveloped -> md_algs ;data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ;enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ;evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ;if ( evp_cipher == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ;goto err ;}break ;case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ;enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ;data_body = p7 -> d . enveloped -> enc_data -> enc_data ;evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ;if ( evp_cipher == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ;goto err ;}break ;default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ;goto err ;}if ( md_sk != NULL ) {for ( i = 0 ;i < sk_X509_ALGOR_num ( md_sk ) ;i ++ ) {xa = sk_X509_ALGOR_value ( md_sk , i ) ;if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ;goto err ;}j = OBJ_obj2nid ( xa -> algorithm ) ;evp_md = EVP_get_digestbynid ( j ) ;if ( evp_md == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ;goto err ;}BIO_set_md ( btmp , evp_md ) ;if ( out == NULL ) out = btmp ;else BIO_push ( out , btmp ) ;btmp = NULL ;}}if ( evp_cipher != NULL ) {if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ;goto err ;}if ( pcert ) {for ( i = 0 ;i < sk_PKCS7_RECIP_INFO_num ( rsk ) ;i ++ ) {ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ;if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ;ri = NULL ;}if ( ri == NULL ) {PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ;goto err ;}}if ( pcert == NULL ) {for ( i = 0 ;i < sk_PKCS7_RECIP_INFO_num ( rsk ) ;i ++ ) {ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ;if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ;ERR_clear_error ( ) ;}}else {if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ;ERR_clear_error ( ) ;}evp_ctx = NULL ;BIO_get_cipher_ctx ( etmp , & evp_ctx ) ;if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ;if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ;tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ;tkey = OPENSSL_malloc ( tkeylen ) ;if ( ! tkey ) goto err ;if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ;if ( ek == NULL ) {ek = tkey ;eklen = tkeylen ;tkey = NULL ;}if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) {if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) {OPENSSL_clear_free ( ek , eklen ) ;ek = tkey ;eklen = tkeylen ;tkey = NULL ;}}ERR_clear_error ( ) ;if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ;OPENSSL_clear_free ( ek , eklen ) ;ek = NULL ;OPENSSL_clear_free ( tkey , tkeylen ) ;tkey = NULL ;if ( out == NULL ) out = etmp ;else BIO_push ( out , etmp ) ;etmp = NULL ;}if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) {bio = in_bio ;",if ( in_bio != NULL ) ) {bio = in_bio ;,318
456,if ( ret ) goto out ;touch_atime ( & path ) ;path_put ( & path ) ;,if ( ! IS_ERR ( raw ) ) if ( ret ) goto out ;touch_atime ( & path ) ;path_put ( & path ) ;,319
457,proc = rqstp -> rq_procinfo ;rqstp -> rq_cachetype = proc -> pc_cachetype ;,"proc = rqstp -> rq_procinfo ;if ( nfs_request_too_big ( rqstp , proc ) ) {dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\\* statp = rpc_garbage_args ;return 1 ;}rqstp -> rq_cachetype = proc -> pc_cachetype ;",320
458,"if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 )   goto end ;if ( MyFlags & MY_REDEL_MAKE_BACKUP ) {","if ( ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) {if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) goto end ;}if ( MyFlags & MY_REDEL_MAKE_BACKUP ) {",321
459,e . ifindex = port -> dev -> ifindex ;e . state = p -> state ;,"memset ( & e , 0 , sizeof ( e ) ) ;e . ifindex = port -> dev -> ifindex ;e . state = p -> state ;",322
460,"u_int len , j ;if ( ( offset + 4 + str_len ) >= packet -> payload_packet_len ) return ( - 1 ) ;","u_int len , j ;if ( * rdnSeqBuf_offset >= rdnSeqBuf_len ) {# ifdef DEBUG_TLS printf ( ""[TLS]<S2SV_blank>%s()<S2SV_blank>[buffer<S2SV_blank>capacity<S2SV_blank>reached][%u]\\\# endif return - 1 ;}if ( ( offset + 4 + str_len ) >= packet -> payload_packet_len ) return ( - 1 ) ;",323
461,sec = t % 86400 ;wday = ( 4 + days ) % 7 ;,sec = t % 86400 ;if ( days > 2932896 ) {days = 2932896 ;sec = 86399 ;}wday = ( 4 + days ) % 7 ;,324
462,"struct rose_sock * rose = rose_sk ( sk ) ;struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ;if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ;if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ;qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ;skb_pull ( skb , ROSE_MIN_LEN ) ;if ( rose -> qbitincl ) {asmptr = skb_push ( skb , 1 ) ;* asmptr = qbit ;}skb_reset_transport_header ( skb ) ;copied = skb -> len ;if ( copied > size ) {copied = size ;msg -> msg_flags |= MSG_TRUNC ;}skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ;if ( srose != NULL ) {memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;","struct rose_sock * rose = rose_sk ( sk ) ;if ( msg -> msg_name ) {struct sockaddr_rose * srose ;memset ( msg -> msg_name , 0 , msg -> msg_iov , copied ) ;if ( srose != NULL ) {memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;",325
463,"if ( ( o + s < o ) || ( o + s < s ) || ( o + s > ds ) || ( o > ds ) ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" ,  ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)<S2SV_blank>or<S2SV_blank>size<S2SV_blank>(%u)."" , o , s ) ;","if ( o >= ds ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)<S2SV_blank>or<S2SV_blank>size<S2SV_blank>(%u)."" , o , s ) ;",326
464,if ( ! handle )  return NULL ;,if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ;,327
465,"map = __bpf_map_get ( f ) ;if ( IS_ERR ( map ) ) {verbose ( ""fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\\fdput ( f ) ;return PTR_ERR ( map ) ;",return PTR_ERR ( map ) ;,328
466,"case IPSECDOI_ID_IPV4_ADDR : if ( len < 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]"" , len ) ) ;","case IPSECDOI_ID_IPV4_ADDR : if ( len < 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" , len ) ) ;",329
467,"if ( len < 20 )  ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ;","if ( len < 20 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ;",329
468,case OBJECT_TYPE_INTEGER :  ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ;break ;case OBJECT_TYPE_STRING :  ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;break ;,case OBJECT_TYPE_INTEGER : ( ( YR_OBJECT_INTEGER * ) copy ) -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value ;break ;case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) object ) -> value != NULL ) {( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ;}else {( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;}break ;case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value ;break ;,330
469,"if ( ( e -> target_offset == sizeof ( struct ipt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> ip ) ) ||  visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",331
470,if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt )   return - EINVAL ;if ( ! rt ) return 0 ;,struct xfrm_replay_state_esn * rs ;if ( p -> flags & XFRM_STATE_ESN ) {if ( ! rt ) return - EINVAL ;rs = nla_data ( rt ) ;if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ;if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ;}if ( ! rt ) return 0 ;,332
471,"int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;","unlink ( path ) ;int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_EXCL , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;",333
472,"static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client ,  krb5_principal client_principal ,  hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) {","static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , krb5_principal client_principal , const char * tgt_realm , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) {",334
473,"# define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) ,  krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ;if ( ret ) goto out ;","# define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , tgt_realm ) ;if ( ret ) goto out ;",334
474,"static void evtchn_fifo_handle_events ( unsigned cpu )  {__evtchn_fifo_handle_events ( cpu , false ) ;}","static void evtchn_fifo_handle_events ( unsigned cpu , struct evtchn_loop_ctrl * ctrl ) {__evtchn_fifo_handle_events ( cpu , ctrl ) ;}",335
475,"map = __bpf_map_get ( f ) ;if ( IS_ERR ( map ) ) {verbose ( ""fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\\fdput ( f ) ;return PTR_ERR ( map ) ;",return PTR_ERR ( map ) ;,336
476,"
",queueItem -> interface = interface ;,337
477,queueItem -> srcPort = 0 ;# if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) {,queueItem -> srcPort = 0 ;# if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) {,337
478,"static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row , int mi_col ,  int output_enabled , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;int ctx ;BLOCK_SIZE subsize ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;subsize = * get_sb_partitioning ( x , bsize ) ;}partition = partition_lookup [ bsl ] [ subsize ] ;switch ( partition ) {case PARTITION_NONE :  if ( output_enabled && bsize >= BLOCK_8X8 )  cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ;encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;break ;case PARTITION_VERT :  if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ;* get_sb_index ( x , subsize ) = 0 ;encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;if ( mi_col + hbs < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;encode_b ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ;}case PARTITION_HORZ :  if ( output_enabled )  cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ;encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;if ( mi_row + hbs < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;encode_b ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ;}case PARTITION_SPLIT :  subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ;* get_sb_index ( x , subsize ) = 0 ;encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;* get_sb_index ( x , subsize ) = 1 ;encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ;* get_sb_index ( x , subsize ) = 2 ;encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ;* get_sb_index ( x , subsize ) = 3 ;encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ;break ;default :  assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}","static void encode_sb ( VP9_COMP * cpi , ThreadData * td , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ;int ctx ;BLOCK_SIZE subsize = bsize ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;subsize = get_subsize ( bsize , pc_tree -> partitioning ) ;}partition = partition_lookup [ bsl ] [ subsize ] ;if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ;switch ( partition ) {case PARTITION_NONE : encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ;case PARTITION_VERT : if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ;encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ;default : assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}",338
479,spin_lock_bh ( & g_cdev . lock ) ;pd = g_cdev . active_pd ;,if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;spin_lock_bh ( & g_cdev . lock ) ;pd = g_cdev . active_pd ;,339
480,"list_add_tail ( & sp -> auto_asconf_list ,  & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;}else   sp -> do_auto_asconf = 0 ;local_bh_enable ( ) ;","spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;list_add_tail ( & sp -> auto_asconf_list , & net -> sctp . auto_asconf_splist ) ;sp -> do_auto_asconf = 1 ;spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;}else {sp -> do_auto_asconf = 0 ;}local_bh_enable ( ) ;",340
481,file_sb_list_del ( file ) ;file_free ( file ) ;,file_free ( file ) ;,341
482,}return item ;,if ( ! item -> valuestring ) {cJSON_Delete ( item ) ;return 0 ;}}return item ;,342
483,if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || pReplyData == NULL || * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) +  sizeof ( uint16_t ) ) ) {status = - EINVAL ;,if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || pReplyData == NULL || * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + sizeof ( uint16_t ) ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t ) ) {status = - EINVAL ;,343
484,"if ( new -> process_keyring )  return - EEXIST ;keyring = keyring_alloc ( ""_pid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;","if ( new -> process_keyring ) return 0 ;keyring = keyring_alloc ( ""_pid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;",344
485,"strncpy ( result , ""undefined"" , 10 ) ;}","strcpy ( result , ""undefined"" , 10 ) ;}",345
486,FreeStmt ( ( ParseCommon * ) & append ) ;return expr ;,FreeStmt ( ( ParseCommon * ) append ) ;return expr ;,346
487,"ret = - EEXIST ;if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ;if ( vm_shared ) {page_dup_rmap ( page , true ) ;}else {ClearPagePrivate ( page ) ;hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ;}_dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ;if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ;_dst_pte = pte_mkyoung ( _dst_pte ) ;set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ;( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ;hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ;update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ;spin_unlock ( ptl ) ;ret = 0 ;out : return ret ;out_release_unlock : spin_unlock ( ptl ) ;out_release_nounlock :  if ( vm_shared ) unlock_page ( page ) ;put_page ( page ) ;",out_release_nounlock : put_page ( page ) ;,347
488,frag = ( hm_fragment * ) item -> data ;OPENSSL_free ( frag -> fragment ) ;,frag = ( hm_fragment * ) item -> data ;OPENSSL_free ( frag -> fragment ) ;,348
489,"struct range * range ;struct evbuffer * evb = NULL ;size_t content_length ;int code = 500 , fd = - 1 , i , nranges , ret ;uint32_t boundary ;if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) {code = 416 ;if ( ( evb = evbuffer_new ( ) ) == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer"" ;goto abort ;}( void ) snprintf ( content_range , sizeof ( content_range ) ,  ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;content_length = range -> end - range -> start + 1 ;if ( buffer_add_range ( fd , evb , range ) == 0 )  goto abort ;content_length = 0 ;boundary = arc4random ( ) ;-%ud\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Type:<S2SV_blank>%s/%s\\\\r\\\content_length += i ;if ( ( i = evbuffer_add_printf ( evb , ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\\\r\\\range ++ ;}if ( ( i = evbuffer_add_printf ( evb , ""\\\\r\\\-%ud--\\\\r\\\content_length += i ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) ,  ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ;media = & multipart_media ;-%llu--\\\\r\\\close ( fd ) ;fd = - 1 ;case 0 :  goto done ;default : break ;if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 )  goto fail ;bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ;if ( clt -> clt_persist )  clt -> clt_toread = TOREAD_HTTP_HEADER ;else clt -> clt_toread = TOREAD_HTTP_NONE ;clt -> clt_done = 0 ;done : evbuffer_free ( evb ) ;server_reset_http ( clt ) ;abort :  if ( evb != NULL )  evbuffer_free ( evb ) ;","struct range_data * r = & clt -> clt_ranges ;struct range * range ;size_t content_length = 0 ;int code = 500 , fd = - 1 , i , nranges , ret ;if ( ( nranges = parse_ranges ( clt , range_str , st -> st_size ) ) < 1 ) {code = 416 ;r -> range_media = media ;range = & r -> range [ 0 ] ;( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes<S2SV_blank>%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ;range = & r -> range [ 0 ] ;content_length += range -> end - range -> start + 1 ;content_length = 0 ;boundary = arc4random ( ) ;content_length += ret + range -> end , st -> st_size ) ) == - 1 ) goto abort ;range ++ ;}if ( ( ret = snprintf ( NULL , 0 , ""\\\\r\\\content_length += ret ;( void ) strlcpy ( multipart_media . media_type , ""multipart"" , sizeof ( multipart_media . media_type ) ) ;( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary ) ;media = & multipart_media ;r -> range_toread = TOREAD_HTTP_RANGE ;case 0 : close ( fd ) ;goto done ;default : break ;}clt -> clt_fd = fd ;if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ;clt -> clt_srvbev_throttled = 0 ;clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ;if ( clt -> clt_srvbev == NULL ) {errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ;goto fail ;bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ;bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ;bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ;bufferevent_disable ( clt -> clt_bev , EV_READ ) ;done : server_reset_http ( clt ) ;abort : if ( evb != NULL ) evbuffer_free ( evb ) ;",349
490,io -> io_cleanup = port_cleanup ;switch ( io -> regsize ) {,switch ( io -> regsize ) {,350
491,return 0 ;},io -> io_cleanup = port_cleanup ;return 0 ;},350
492,\\\\\\,\\\\\\,351
493,"if ( s_poll_interval == NULL )  s_poll_interval = ""3000"" ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id ,  session_state , op_iframe_id , s_poll_interval , redirect_uri ,  redirect_uri ) ;","int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ;if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 ;java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , session_state , op_iframe_id , poll_interval , redirect_uri , redirect_uri ) ;",351
494,# endif  exit ( i ) ;},"# endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) {fprintf ( stderr , ""Can\\\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\\exit ( 1 ) ;}# endif exit ( i ) ;}",352
495,"remaining = tvb_captured_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {","remaining = tvb_reported_length_remaining ( tvb , offset ) ;if ( remaining <= 0 ) {",353
496,new_timer -> it_overrun = - 1 ;if ( event ) {,new_timer -> it_overrun = - 1LL ;if ( event ) {,354
497,for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ;,for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ;,355
498,struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ;unsigned long tmp ;if ( tmp && tmp == cluster -> cl_has_local &&  cluster -> cl_local_node != node -> nd_num )  return - EBUSY ;if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret )  return ret ;},struct o2nm_cluster * cluster ;unsigned long tmp ;o2nm_lock_subsystem ( ) ;cluster = to_o2nm_cluster_from_node ( node ) ;if ( ! cluster ) {ret = - EINVAL ;goto out ;}if ( tmp && tmp == cluster -> cl_has_local && cluster -> cl_local_node != node -> nd_num ) {ret = - EBUSY ;goto out ;}if ( tmp && ! cluster -> cl_has_local ) {ret = o2net_start_listening ( node ) ;if ( ret ) goto out ;},356
499,return count ;},ret = count ;out : o2nm_unlock_subsystem ( ) ;return ret ;},356
500,if ( ! vcpu -> arch . time_page )  return - EINVAL ;,if ( ! vcpu -> arch . pv_time_enabled ) return - EINVAL ;,357
501,"while ( nr > 0 ) {c = tty -> ops -> write ( tty , b , nr ) ;if ( c < 0 ) {","struct n_tty_data * ldata = tty -> disc_data ;while ( nr > 0 ) {mutex_lock ( & ldata -> output_lock ) ;c = tty -> ops -> write ( tty , b , nr ) ;mutex_unlock ( & ldata -> output_lock ) ;if ( c < 0 ) {",358
502,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",359
503,if ( ! new )  return - ENOMEM ;BUG_ON ( new -> thread_keyring ) ;,if ( ! new ) return - ENOMEM ;,360
504,subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ;subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ;,ND_TCHECK_16BITS ( obj_tptr + offset ) ;subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ;subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ;,361
505,"case INT_SWITCHING_TYPE_SUBOBJ :  ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ;ND_PRINT ( ( ndo , ""\\\case WAVELENGTH_SUBOBJ :  ND_PRINT ( ( ndo , ""\\\","case INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK_8BITS ( obj_tptr + offset + 3 , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ;ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ;ND_PRINT ( ( ndo , ""\\\bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ;ND_PRINT ( ( ndo , ""\\\case WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;ND_PRINT ( ( ndo , ""\\\",361
506,"static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi ,  int mi_row , int mi_col ) {unsigned int var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb ,  mi_row , mi_col , BLOCK_64X64 ) ;","static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , MACROBLOCK * x , int mi_row , int mi_col ) {unsigned int var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , BLOCK_64X64 ) ;",362
507,"nfca_poll -> nfcid1_len = * data ++ ;pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\\","nfca_poll -> nfcid1_len = min_t ( __u8 , * data ++ , NFC_NFCID1_MAXSIZE ) ;pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\\",363
508,"static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , int mi_col , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;VP9_COMMON * const cm = & cpi -> common ;const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ;const int mb_row = mi_row >> 1 ;const int mb_col = mi_col >> 1 ;const int idx_map = mb_row * cm -> mb_cols + mb_col ;x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ;x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ;x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ;x -> rddiv = cpi -> RDDIV ;x -> rdmult = cpi -> RDMULT ;if ( seg -> enabled ) {mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}","static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , MACROBLOCK * const x , int mi_row , int mi_col , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ;x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;vp9_setup_dst_planes ( xd -> plane , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ;x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ;x -> rddiv = cpi -> rd . RDDIV ;x -> rdmult = cpi -> rd . RDMULT ;if ( seg -> enabled ) {mbmi -> segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}",364
509,},xd -> tile = * tile ;},364
510,"
","if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) {SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ;}",365
511,"if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) {uv__write_int ( error_fd , - errno ) ;","if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) {uv__write_int ( error_fd , - errno ) ;",365
512,ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ;},if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) {return IHEVCD_INVALID_PARAMETER ;}ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ;},366
513,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) {smp_rmb ( ) ;return key -> reject_error ;}",ret = key_read_state ( key ) ;if ( ret < 0 ) return ret ;,367
514,"u64 t = ca -> sum_rtt ;do_div ( t , ca -> cnt_rtt ) ;info . tcpv_rtt = t ;nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ;","if ( info . tcpv_rttcnt > 0 ) {u64 t = ca -> sum_rtt ;do_div ( t , info . tcpv_rttcnt ) ;info . tcpv_rtt = t ;}nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ;",368
515,"for ( i = 0 ;i <= SERDES_MAX ;ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ;","for ( i = 0 ;i < SERDES_MAX ;ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ;",369
516,if ( err > 0 ) {signo = SIGCHLD ;err = 0 ;}if ( ! err ) {,"
",370
517,"static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) {const VP9_COMMON * const cm = & cpi -> common ;const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) {assert ( ! is_compound ) ;assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ;if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ;vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME ,  vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ;vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ;if ( bit0 ) {vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ;}","static void write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) {if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ;if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ;}else {assert ( ! is_compound == ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ;vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ;vpx_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ;if ( bit0 ) {vpx_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ;}",371
518,"strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ;","strncpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ;",372
519,void * H264SwDecMalloc ( u32 size ) {return malloc ( size ) ;},"void * H264SwDecMalloc ( u32 size , u32 num ) {if ( size > UINT32_MAX / num ) {ALOGE ( ""can\\\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes"" , size , num ) ;android_errorWriteLog ( 0x534e4554 , ""27855419"" ) ;return NULL ;}return malloc ( size * num ) ;}",373
520,"
",h . h2 -> tp_padding = 0 ;,374
521,hdrlen = sizeof ( * h . h2 ) ;break ;,hdrlen = sizeof ( * h . h2 ) ;break ;,374
522,pinctrl_unregister ( gpio_dev -> pctrl ) ;return 0 ;,return 0 ;,375
523,"strcpy ( m , name ) ;for ( p = path ;","memcpy ( m , name , nlen + 1 ) ;for ( p = path ;",376
524,"nmv_context * fc = & cm -> fc . nmvc ;const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ;adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ;for ( i = 0 ;comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ;adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes ,  comp -> classes ) ;adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ;for ( j = 0 ;++ j )  comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ;for ( j = 0 ;++ j )  adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] ,  comp -> class0_fp [ j ] ) ;adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ;if ( allow_hp ) {comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ;comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ;}","nmv_context * fc = & cm -> fc -> nmvc ;const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ;vpx_tree_merge_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ;for ( i = 0 ;comp -> sign = mode_mv_merge_probs ( pre_comp -> sign , c -> sign ) ;vpx_tree_merge_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , comp -> classes ) ;vpx_tree_merge_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ;for ( j = 0 ;+ j )  comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ;++ j ) comp -> bits [ j ] = mode_mv_merge_probs ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ;for ( j = 0 ;+ j )  adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] ,  comp -> class0_fp [ j ] ) ;++ j ) vpx_tree_merge_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , comp -> class0_fp [ j ] ) ;vpx_tree_merge_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ;if ( allow_hp ) {comp -> class0_hp = mode_mv_merge_probs ( pre_comp -> class0_hp , c -> class0_hp ) ;comp -> hp = mode_mv_merge_probs ( pre_comp -> hp , c -> hp ) ;}",377
525,"if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) {pr_err ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\\","if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ;if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ;if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) {pr_err ( ""set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\\",378
526,"}if ( lastPart ) {warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\\\""boundary\\\\""<S2SV_blank>for<S2SV_blank>\\\\""multipart/form-data\\\\""!"" ) ;}","else {warn ( ""[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data"" ) ;break ;}}if ( lastPart ) {warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\\\""boundary\\\\""<S2SV_blank>for<S2SV_blank>\\\\""multipart/form-data\\\\""!"" ) ;",379
527,"interface = socket -> interface ;buffer = ipAllocBuffer ( 0 , & offset ) ;","if ( message -> interface != NULL ) {interface = message -> interface ;}else {interface = socket -> interface ;}buffer = ipAllocBuffer ( 0 , & offset ) ;",380
528,"variance_node node ;tree_to_node ( data , bsize , & node ) ;","variance_node node ;memset ( & node , 0 , sizeof ( node ) ) ;tree_to_node ( data , bsize , & node ) ;",381
529,"int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct ,  const vp9_prob * oldp ,  vp9_prob * bestp ,  vp9_prob upd ) {int i , old_b , new_b , update_b , savings , bestsavings , step ;vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ;vp9_model_to_full_probs ( oldp , oldplist ) ;vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ;for ( i = UNCONSTRAINED_NODES , old_b = 0 ;step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ;for ( newp = * bestp ;","int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , const vpx_prob * oldp , vpx_prob * bestp , vp9_prob upd ) {int i , old_b , new_b , update_b , savings , bestsavings , step ;vpx_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ;vp9_model_to_full_probs ( oldp , oldplist ) ;memcpy ( newplist , oldp , sizeof ( vpx_prob ) * UNCONSTRAINED_NODES ) ;for ( i = UNCONSTRAINED_NODES , old_b = 0 ;if ( * bestp > oldp [ PIVOT_NODE ] ) {step = - stepsize ;for ( newp = * bestp ;newp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ;for ( newp = * bestp ;",382
530,* bestp = bestnewp ;return bestsavings ;,"}else {step = stepsize ;for ( newp = * bestp ;newp < oldp [ PIVOT_NODE ] ;newp += step ) {if ( newp < 1 || newp > 255 ) continue ;newplist [ PIVOT_NODE ] = newp ;vp9_model_to_full_probs ( newplist , newplist ) ;for ( i = UNCONSTRAINED_NODES , new_b = 0 ;i < ENTROPY_NODES ;++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ;new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ;update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ;savings = old_b - new_b - update_b ;if ( savings > bestsavings ) {bestsavings = savings ;bestnewp = newp ;}}}* bestp = bestnewp ;return bestsavings ;",382
531,"static int target_xcopy_locate_se_dev_e4 ( const unsigned char * dev_wwn ,   struct se_device * * found_dev )  {struct xcopy_dev_search_info info ;int ret ;memset ( & info , 0 , sizeof ( info ) ) ;info . dev_wwn = dev_wwn ;ret = target_for_each_device ( target_xcopy_locate_se_dev_e4_iter , & info ) ;if ( ret == 1 ) {* found_dev = info . found_dev ;}else {pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\\}","static int target_xcopy_locate_se_dev_e4 ( struct se_session * sess , const unsigned char * dev_wwn , struct se_device * * _found_dev , struct percpu_ref * * _found_lun_ref ) {struct se_dev_entry * deve ;struct se_node_acl * nacl ;struct se_lun * this_lun = NULL ;struct se_device * found_dev = NULL ;if ( ! sess ) goto err_out ;pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\\nacl = sess -> se_node_acl ;rcu_read_lock ( ) ;hlist_for_each_entry_rcu ( deve , & nacl -> lun_entry_hlist , link ) {struct se_device * this_dev ;int rc ;this_lun = rcu_dereference ( deve -> se_lun ) ;this_dev = rcu_dereference_raw ( this_lun -> lun_se_dev ) ;rc = target_xcopy_locate_se_dev_e4_iter ( this_dev , dev_wwn ) ;if ( rc ) {if ( percpu_ref_tryget_live ( & this_lun -> lun_ref ) ) found_dev = this_dev ;break ;}}rcu_read_unlock ( ) ;if ( found_dev == NULL ) goto err_out ;pr_debug ( ""lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\\* _found_dev = found_dev ;* _found_lun_ref = & this_lun -> lun_ref ;err_out : pr_debug_ratelimited ( ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\\",383
532,if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) )  return - EINVAL ;param . regd = hwsim_world_regdom_custom [ idx ] ;},if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) {kfree ( hwname ) ;return - EINVAL ;}param . regd = hwsim_world_regdom_custom [ idx ] ;},384
533,"reason = malloc ( ( uint64_t ) reasonLen + 1 ) ;if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) {","if ( reasonLen > 1 << 20 ) {rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned int ) reasonLen ) ;return ;}reason = malloc ( reasonLen + 1 ) ;if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) {",385
534,},"if ( cpu_has_secondary_exec_ctrls ( ) ) {if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ;else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ;}if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;}",386
535,"switch ( opt ) {case LCPOPT_VEXT : if ( len < 6 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>6)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 2 ) , 3 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;","ND_TCHECK_24BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;",387
536,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK_32BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ;",387
537,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ;ND_TCHECK_32BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",387
538,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ;ND_TCHECK ( p [ 2 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Callback<S2SV_blank>Operation<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( ppp_callback_values , ""Unknown"" , p [ 2 ] ) , p [ 2 ] ) ) ;break ;case LCPOPT_MLMRRU : if ( len != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;",387
539,"char * dbuf ;char * ticket_buf ;int ret ;dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ;ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ;ret = process_one_ticket ( ac , secret , & p , end ,  dbuf , ticket_buf ) ;if ( ret )  goto out ;}ret = 0 ;out : kfree ( ticket_buf ) ;out_dbuf : kfree ( dbuf ) ;return ret ;bad :  ret = - EINVAL ;goto out ;}","int ret ;dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ;ceph_decode_8_safe ( & p , end ) ;ret = process_one_ticket ( ac , secret , & p , end , dbuf , ticket_buf ) ;if ( ret ) return ret ;}return 0 ;bad : ret = - EINVAL ;}",388
540,for ( arc = 0 ;short a_label = dfa_state -> s_arc [ arc ] . a_lbl ;,if ( ch_type == suite && TYPE ( tree ) == funcdef ) {ch_type = func_body_suite ;}for ( arc = 0 ;short a_label = dfa_state -> s_arc [ arc ] . a_lbl ;,389
541,bitlen2 = VARBITLEN ( arg2 ) ;bytelen = VARBITTOTALLEN ( bitlen1 + bitlen2 ) ;,"bitlen2 = VARBITLEN ( arg2 ) ;if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ;bytelen = VARBITTOTALLEN ( bitlen1 + bitlen2 ) ;",390
542,return alg -> cra_rng . rng_make_random ?  alg -> cra_rng . seedsize : ralg -> seedsize ;,return ralg -> seedsize ;,391
543,"static void  horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 4 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 4 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",392
544,},return 1 ;},392
545,"if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) {* pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ;if ( * pgmap ) page = pte_page ( pte ) ;else goto no_page ;else if ( unlikely ( ! page ) ) {",if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) {if ( unlikely ( ! try_get_page ( page ) ) ) {page = ERR_PTR ( - ENOMEM ) ;goto out ;},393
546,if ( flags & FOLL_GET )  get_page ( page ) ;if ( flags & FOLL_TOUCH ) {,if ( flags & FOLL_GET ) get_page ( page ) ;if ( flags & FOLL_TOUCH ) {,393
547,"if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;","if ( NULL == siocb -> scm , false ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;",394
548,"if ( credit < 0 )   state = decrease_reservation ( - credit , GFP_BALLOON ) ;state = update_schedule ( state ) ;","if ( credit < 0 ) {long n_pages ;n_pages = min ( - credit , si_mem_available ( ) ) ;state = decrease_reservation ( n_pages , GFP_BALLOON ) ;if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ;}state = update_schedule ( state ) ;",395
549,ps_dec -> u2_disp_height = i4_cropped_ht ;ps_dec -> u2_disp_width = i4_cropped_wd ;,if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) {return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ;}ps_dec -> u2_disp_height = i4_cropped_ht ;ps_dec -> u2_disp_width = i4_cropped_wd ;,396
550,"void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf )  {get_page ( buf -> page ) ;}","bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {return try_get_page ( buf -> page ) ;}",397
551,byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ;if ( byteStrm == NULL ) {,"byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) , strmLen ) ;if ( byteStrm == NULL ) {",398
552,"static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree ,   int16_t extra , uint8_t token ,  uint8_t skip_eob_node , unsigned int * counts ) {","static INLINE void add_token ( TOKENEXTRA * * t , const vpx_prob * context_tree , int16_t extra , uint8_t token , uint8_t skip_eob_node , unsigned int * counts ) {",399
553,int i ;int j ;int rowstep ;jas_seqent_t * data ;,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;jas_seqent_t * data ;,400
554,struct siginfo info ;info . si_signo = sig ;,struct siginfo info = {};info . si_signo = sig ;,401
555,# ifdef CONFIG_SMP  free_percpu ( s -> s_files ) ;# endif for ( i = 0 ;,for ( i = 0 ;,402
556,"rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ;}","rc = expandRegular ( fi , dest , psm , 1 , nodigest , 1 ) ;}",403
557,"if ( ! rc )  rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ;}if ( ! rc )  rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ;* firsthardlink = - 1 ;","if ( ! rc ) rc = expandRegular ( fi , dest , psm , 1 , nodigest , 0 ) ;}if ( ! rc ) rc = expandRegular ( fi , dest , psm , 0 , nodigest , 0 ) ;* firsthardlink = - 1 ;",403
558,"const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i ,  p -> src . stride ) ] ;uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i ,  pd -> dst . stride ) ] ;const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ;for ( ref = 0 ;const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i ,  pd -> pre [ ref ] . stride ) ] ;vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride ,  dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv ,  & xd -> block_refs [ ref ] -> sf , width , height , ref ,  kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) ,  mi_row * MI_SIZE + 4 * ( i / 2 ) ) ;}vp9_subtract_block ( height , width ,  raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride ,  dst , pd -> dst . stride ) ;k = i ;","const uint8_t * const src = & p -> src . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ;uint8_t * const dst = & pd -> dst . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , pd -> dst . stride ) ] ;const InterpKernel * kernel = vp9_filter_kernels [ mi -> mbmi . interp_filter ) ;for ( ref = 0 ;const uint8_t * pre = & pd -> pre [ ref ] . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , pd -> pre [ ref ] . stride ) ] ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {vp9_highbd_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) , xd -> bd ) ;}else {vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , xd -> bd ) ;}else {vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ;}# else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ;# endif k = i ;",404
559,"int16_t * coeff ;k += ( idy * 2 + idx ) ;x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) ,  coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ;thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ;thissse += ssz ;thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;","int16_t * coeff ;k += ( idy * 2 + idx ) ;x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ;}else {thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ;}# else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ;# endif thissse += ssz ;thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;",404
560,"sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;","sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ;sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;",405
561,"const char * old_name ;trap = lock_rename ( new_dir , old_dir ) ;if ( d_really_is_negative ( old_dentry ) || old_dentry == trap || d_mountpoint ( old_dentry ) ) goto exit ;dentry = lookup_one_len ( new_name , new_dir , strlen ( new_name ) ) ;if ( IS_ERR ( dentry ) || dentry == trap || d_really_is_positive ( dentry ) ) goto exit ;old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ;error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ;fsnotify_oldname_free ( old_name ) ;fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ;fsnotify_oldname_free ( old_name ) ;unlock_rename ( new_dir , old_dir ) ;","struct name_snapshot old_name ;trap = lock_rename ( new_dir , old_dir ) ;take_dentry_name_snapshot ( & old_name , old_dentry ) ;error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ;release_dentry_name_snapshot ( & old_name ) ;fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ;fsnotify_oldname_free ( old_name ) ;unlock_rename ( new_dir , old_dir ) ;",406
562,if ( ! offset ) {return & EG ( uninitialized_zval_ptr ) ;,if ( ! offset || ! ht ) {return & EG ( uninitialized_zval_ptr ) ;,407
563,if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) )  * flags &= ~ FOLL_WRITE ;return 0 ;,if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) * flags |= FOLL_COW ;return 0 ;,408
564,"sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ;size = 8 ;sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ;size = 4 ;","snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ;size = 8 ;snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ;size = 4 ;",409
565,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ;strasm = r_str_concat ( strasm , str ) ;","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i"" , vA ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ;strasm = r_str_concat ( strasm , str ) ;",409
566,"# undef llint  sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;","# undef llint snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;",409
567,"case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{break ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default :  sprintf ( str , ""<S2SV_blank>{}sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>{strasm = r_str_concat ( strasm , str ) ;case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default :  sprintf ( str , ""<S2SV_blank>{break ;sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}","case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , "",<S2SV_blank>[%04x]"" , vB ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{strasm = r_str_concat ( strasm , str ) ;case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;snprintf ( str , sizeof ( str ) , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}",409
568,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}",409
569,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ;}",409
570,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}",409
571,"sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;case 5 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ;default :  sprintf ( str , ""<S2SV_blank>{}sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;}sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ;}sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;}sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;case 5 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>%s<S2SV_blank>;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>class+%i"" , vB ) ;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>%s<S2SV_blank>;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>method+%i"" , vB ) ;}",409
572,"gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ;}return GF_OK ;}","if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\\ptr -> key_info [ 20 ] = 16 ;return GF_NON_COMPLIANT_BITSTREAM ;}gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ;}else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\\return GF_NON_COMPLIANT_BITSTREAM ;}return GF_OK ;}",410
573,if ( ret == - EEXIST )  goto fail_dir_item ;,if ( ret == - EEXIST || ret == - EOVERFLOW ) goto fail_dir_item ;,411
574,if ( i4_prev_row != i4_row )  {,if ( i4_prev_row < i4_row ) {,412
575,"}impeg2d_bit_stream_flush ( & s_bitstrm , START_CODE_LEN ) ;","}else if ( i4_prev_row > i4_row ) {android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ;}impeg2d_bit_stream_flush ( & s_bitstrm , START_CODE_LEN ) ;",412
576,"struct hstate * h = hstate_vma ( vma ) ;struct page * page ;struct address_space * mapping = vma -> vm_file -> f_mapping ;struct inode * inode = mapping -> host ;if ( chg )  if ( hugetlb_get_quota ( inode -> i_mapping , chg ) )  return ERR_PTR ( - VM_FAULT_SIGBUS ) ;page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ;if ( ! page ) {hugetlb_put_quota ( inode -> i_mapping , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;","struct hugepage_subpool * spool = subpool_vma ( vma ) ;struct hstate * h = hstate_vma ( vma ) ;struct page * page ;if ( chg ) if ( hugepage_subpool_get_pages ( spool , chg ) ) return ERR_PTR ( - VM_FAULT_SIGBUS ) ;hugepage_subpool_put_pages ( spool , chg ) ;return ERR_PTR ( - VM_FAULT_SIGBUS ) ;set_page_private ( page , ( unsigned long ) mapping ) ;vma_commit_reservation ( h , vma , addr ) ;",413
577,"if ( svm_set_msr ( & svm -> vcpu , & msr ) ) {trace_kvm_msr_write_ex ( ecx , data ) ;","if ( kvm_set_msr ( & svm -> vcpu , & msr ) ) {trace_kvm_msr_write_ex ( ecx , data ) ;",414
578,uchar * dp ;dp = data ;,jas_uchar * dp ;dp = data ;,415
579,len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ;if ( ! EVP_CIPHER_CTX_encrypting ( c ) )   len -= cctx -> M ;EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;,if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ;len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ;if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) {if ( len < cctx -> M ) return 0 ;len -= cctx -> M ;}EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;,416
580,"if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) )  MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;filepos = TellBlob ( image ) ;","if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) {MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}filepos = TellBlob ( image ) ;",417
581,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ;destreg = ( opcode >> 4 ) & 0x3f ;",418
582,char * ptr ;int n = 0 ;ptr = fmt ;while ( * ptr != \'\\\\0\' ) if ( * ptr ++ == \'%\' ) {if ( * ptr == \'\\\\0\' ) return 1 ;if ( * ptr == \'%\' ) ptr ++ ;else if ( * ptr == \'s\' || * ptr == \'S\' ) {n = 1 ;ptr ++ ;}else {if ( * ptr == \'<S2SV_blank>\' ) ptr ++ ;while ( * ptr >= \'0\' && * ptr <= \'9\' ) ptr ++ ;if ( * ptr ++ != \'l\' ) return 1 ;if ( * ptr == \'u\' ) ptr ++ ;else return 1 ;n ++ ;}}return ( n != 3 ) ;,"return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt ) ;",419
583,"buf = PyObject_CallObject ( tok -> decoding_readline , NULL ) ;if ( buf == NULL ) {","buf = _PyObject_CallNoArg ( tok -> decoding_readline , NULL ) ;if ( buf == NULL ) {",420
584,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;switch ( rd ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;switch ( rd ) {",421
585,struct ip_options * opt = NULL ;struct inet_request_sock * req_inet ;,struct ip_options_rcu * opt = NULL ;struct inet_request_sock * req_inet ;,422
586,"memcpy ( opt -> __data , buf , buf_len ) ;opt -> optlen = opt_len ;opt -> cipso = sizeof ( struct iphdr ) ;kfree ( buf ) ;kfree ( opt ) ;return 0 ;","memcpy ( opt -> opt . __data , buf , buf_len ) ;opt -> opt . optlen = opt_len ;opt -> opt . cipso = sizeof ( struct iphdr ) ;kfree ( buf ) ;if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu ) ;return 0 ;",422
587,"char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ;if ( curl_env && * curl_env ) {char * encoded_url = r_str_escape ( url ) ;char * res = r_sys_cmd_strf ( ""curl<S2SV_blank>\\\'%s\\\'"" , encoded_url ) ;free ( encoded_url ) ;if ( res ) {if ( code ) {* code = 200 ;}if ( rlen ) {* rlen = strlen ( res ) ;}}free ( curl_env ) ;return res ;}free ( curl_env ) ;RSocket * s ;int ssl = r_str_startswith ( url , ""https://"" ) ;char * response , * host , * path , * port = ""80"" ;char * uri = strdup ( url ) ;if ( ! uri ) {return NULL ;}if ( code ) {* code = 0 ;}if ( rlen ) {* rlen = 0 ;}host = strstr ( uri , ""://"" ) ;if ( ! host ) {free ( uri ) ;eprintf ( ""r_socket_http_get:<S2SV_blank>Invalid<S2SV_blank>URI"" ) ;return NULL ;}host += 3 ;port = strchr ( host , \':\' ) ;if ( ! port ) {port = ssl ? ""443"" : ""80"" ;path = host ;}else {* port ++ = 0 ;path = port ;}path = strchr ( path , \'/\' ) ;if ( ! path ) {path = """" ;}else {* path ++ = 0 ;}s = r_socket_new ( ssl ) ;if ( ! s ) {eprintf ( ""r_socket_http_get:<S2SV_blank>Cannot<S2SV_blank>create<S2SV_blank>socket\\\free ( uri ) ;return NULL ;}if ( r_socket_connect_tcp ( s , host , port , 0 ) ) {r_socket_printf ( s , ""GET<S2SV_blank>/%s<S2SV_blank>HTTP/1.1\\\\r\\\response = r_socket_http_answer ( s , code , rlen ) ;}else {eprintf ( ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\\response = NULL ;}free ( uri ) ;r_socket_free ( s ) ;return response ;","return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS ) ;",423
588,"
",if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) {,424
589,flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ;stream_id = flags & 0x7F ;,}flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ;stream_id = flags & 0x7F ;,424
590,}if ( end - p >= 88 ) {,}if ( end - p >= 88 ) {,424
591,}p += chunksize ;,"if ( chunksize > end - p ) {av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\\return AVERROR_INVALIDDATA ;}}p += chunksize ;",424
592,"kref_put ( & reservations -> refs , resv_map_release ) ;if ( reserve ) {",resv_map_put ( vma ) ;if ( reserve ) {,425
593,int file_is_raw ( struct VpxInputContext * input ) {uint8_t buf [ 32 ] ;,static int file_is_raw ( struct VpxInputContext * input ) {uint8_t buf [ 32 ] ;,426
594,"if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) ,  buf + 4 , 32 - 4 , & si ) ) {","if ( ! vpx_codec_peek_stream_info ( decoder -> codec_interface ( ) , buf + 4 , 32 - 4 , & si ) ) {",426
595,"vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ;}","memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ;}",427
596,"deconstruct_array ( key_array , TEXTOID , - 1 , false , \'i\' ,  & key_datums , & key_nulls , & key_count ) ;if ( PG_ARGISNULL ( 1 ) ) {","deconstruct_array ( key_array , TEXTOID , - 1 , false , \'i\' , & key_datums , & key_nulls , & key_count ) ;if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;if ( PG_ARGISNULL ( 1 ) ) {",428
597,case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR :  return ( ( iova < mem -> iova ) ||   ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ?  - EFAULT : 0 ;,case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : if ( iova < mem -> iova ) || ( ( iova + length ) > ( mem -> iova + mem -> length - length ) return - EFAULT ;return 0 ;,429
598,s -> filesize = - 1 ;s -> location = av_strdup ( uri ) ;,s -> filesize = UINT64_MAX ;s -> location = av_strdup ( uri ) ;,430
599,"static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) {int min_log2_tile_cols , max_log2_tile_cols , ones ;while ( ones -- )  vp9_wb_write_bit ( wb , 1 ) ;if ( cm -> log2_tile_cols < max_log2_tile_cols )  vp9_wb_write_bit ( wb , 0 ) ;vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ;if ( cm -> log2_tile_rows != 0 )  vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ;}","static void write_tile_info ( const VP9_COMMON * const cm , struct vp9_write_bit_buffer * wb ) {int min_log2_tile_cols , max_log2_tile_cols , ones ;while ( ones -- ) vpx_wb_write_bit ( wb , 1 ) ;if ( cm -> log2_tile_cols < max_log2_tile_cols ) vpx_wb_write_bit ( wb , 0 ) ;vpx_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) vpx_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ;}",431
600,"memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ;for ( section = new_service_options . next ;number_of_sections = num ;CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;","memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ;memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ;memset ( & new_global_options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ;for ( section = new_service_options . next ;number_of_sections = num ;CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;",432
601,"int j , len = apdu . resp [ i + 1 ] ;unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ;","size_t j , len = apdu . resp [ i + 1 ] ;unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ;",433
602,"case 0x84 :  memcpy ( file -> name , d , len ) ;file -> namelen = len ;break ;","case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ;memcpy ( file -> name , d , file -> namelen = len ;break ;",433
603,"dentry -> d_fsdata = ( void * ) ns -> ops ;d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ;","dentry -> d_flags |= DCACHE_RCUACCESS ;dentry -> d_fsdata = ( void * ) ns -> ops ;d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ;",434
604,"LPSTR tmp = NULL ;size_t cs = 0 , x , ds , len ;if ( s )  tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","LPSTR tmp = NULL ;LPSTR tmp2 = NULL ;size_t cs = 0 , x , ds , len ;if ( s ) {tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;}if ( NULL == tmp ) {",435
605,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
606,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
607,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
608,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp ) {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
609,"tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( NULL == tmp )  {","tmp2 = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ;if ( ! tmp2 ) free ( tmp ) ;tmp = tmp2 ;if ( NULL == tmp ) {",435
610,uint8_t verify_crls = cred -> x509Credential . x509CrlVerifyMode ;if ( ! ( ssl_ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ) ) {if ( ! anonTLS )  {if ( cred -> x509Credential . x509CACertFile ) {,uint8_t verify_crls ;if ( ! ( ssl_ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ) ) {if ( ! anonTLS ) {verify_crls = cred -> x509Credential . x509CrlVerifyMode ;if ( cred -> x509Credential . x509CACertFile ) {,436
611,"char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ;ret = stat ( pathname , & sb ) ;","char * pathname = RUNTIME_PATH ""/lxc/lock/var/lib/lxc/"" ;ret = stat ( pathname , & sb ) ;",437
612,while ( ( u64 ) len > s ) {,while ( ( u64 ) len - s > s ) {,438
613,"_iov -> iov_len = min ( ( u64 ) len , size ) ;_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ;","_iov -> iov_len = min ( ( u64 ) len , size ) ;_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ;",438
614,if ( err < 0 )   return err ;msg_bytes = sparams -> msg_bytes ;,if ( err < 0 ) {kfree ( partdata ) ;return err ;}msg_bytes = sparams -> msg_bytes ;,439
615,if ( unlikely ( chunk_length < required_length ) )  return 0 ;,if ( unlikely ( chunk -> pdiscard ) ) return 0 ;if ( unlikely ( chunk_length < required_length ) ) return 0 ;,440
616,"show ( obj , base , name , cb_data ) ;strbuf_addstr ( base , name ) ;","strbuf_addstr ( base , name ) ;show ( obj , base -> buf , cb_data ) ;",441
617,"if ( uref -> field_index >= report -> maxfield ) goto inval ;field = report -> field [ uref -> field_index ] ;if ( uref -> usage_index >= field -> maxusage ) goto inval ;uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ;if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ;goto goodreturn ;default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ;if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) {field = hiddev_lookup_usage ( hid , uref ) ;if ( field == NULL ) goto inval ;else {rinfo . report_type = uref -> report_type ;rinfo . report_id = uref -> report_id ;","
",442
618,else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) &&  ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ;}switch ( cmd ) {,else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ;}switch ( cmd ) {,442
619,switch ( bps / 8 )  {,"if ( bytes_per_pixel > sizeof ( swapbuff ) ) {TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ;return ( 1 ) ;}switch ( bps / 8 ) {",443
620,"ND_PRINT ( ( ndo , ""<S2SV_blank>opt:pad0"" ) ) ;","ND_PRINT ( ( ndo , ""%s"" , rpl_tstr ) ) ;",444
621,"}return ;trunc :  ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;","ND_TCHECK ( opt -> rpl_dio_len ) ;}return ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ;return ;",444
622,"if ( rc != X86EMUL_CONTINUE ) goto done ;rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ;if ( rc != X86EMUL_CONTINUE ) goto done ;rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ;done :  if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ;",if ( ctxt -> rip_relative ) ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ;done : return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ;,445
623,# endif  # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ;,# endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;# ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ;,446
624,value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |   ( ( unsigned char * ) buffer ) [ 1 ] ) ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,value = ( unsigned short ) buffer [ 1 ] << 8 ) | buffer [ 0 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | ( ( unsigned char * ) buffer ) [ 1 ] ) ;quantum . unsigned_value = value & 0xffff ) ;return ( quantum . signed_value ) ;,447
625,"extent_type = btrfs_file_extent_type ( leaf , fi ) ;if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) {item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ;else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) {item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ;item_end -- ;if ( found_type > min_type ) {del_item = 1 ;else {if ( item_end < new_size ) break ;if ( found_key . offset >= new_size ) del_item = 1 ;else del_item = 0 ;}found_extent = 0 ;if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ;if ( del_item ) last_size = found_key . offset ;else last_size = new_size ;if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) {u64 num_dec ;extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ;if ( ! del_item ) {u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ;extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ;btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ;num_dec = ( orig_num_bytes - extent_num_bytes ) ;if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ;","extent_type = btrfs_file_extent_type ( leaf , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) {err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ;if ( err ) {btrfs_abort_transaction ( trans , root , err ) ;goto error ;pending_del_nr = 0 ;err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ;if ( err ) {btrfs_abort_transaction ( trans , root , err ) ;goto error ;else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ;",448
626,"if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ;if ( ! del_item &&  btrfs_file_extent_compression ( leaf , fi ) == 0 &&  btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) )  inode_sub_bytes ( inode , item_end + 1 -  new_size ) ;btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ;size = btrfs_file_extent_calc_inline_size ( size ) ;btrfs_truncate_item ( root , path , size , 1 ) ;","if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) {inode_sub_bytes ( inode , num_dec ) ;if ( ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( btrfs_file_extent_compression ( leaf , fi ) == 0 && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , item_end + 1 - new_size ) ;",448
627,"int err ;unsigned int hash ;struct sk_buff * skb ;long timeo ;struct scm_cookie scm ;int max_level ;int data_len = 0 ;wait_for_unix_gc ( ) ;err = scm_send ( sock , msg , & scm , false ) ;if ( err < 0 ) return err ;err = - EOPNOTSUPP ;if ( msg -> msg_flags & MSG_OOB ) goto out ;if ( msg -> msg_namelen ) {err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ;if ( err < 0 ) goto out ;namelen = err ;}else {sunaddr = NULL ;err = - ENOTCONN ;other = unix_peer_get ( sk ) ;if ( ! other ) goto out ;}if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ;err = - EMSGSIZE ;if ( len > sk -> sk_sndbuf - 32 ) goto out ;if ( len > SKB_MAX_ALLOC ) {data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ;data_len = PAGE_ALIGN ( data_len ) ;BUILD_BUG_ON ( SKB_MAX_ALLOC < PAGE_SIZE ) ;}skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err , PAGE_ALLOC_COSTLY_ORDER ) ;if ( skb == NULL ) goto out ;err = unix_scm_to_skb ( & scm , skb , true ) ;if ( err < 0 ) goto out_free ;max_level = err + 1 ;skb_put ( skb , len - data_len ) ;skb -> data_len = data_len ;skb -> len = len ;err = skb_copy_datagram_from_iter ( skb , 0 , & msg -> msg_iter , len ) ;if ( err ) goto out_free ;timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ;restart : if ( ! other ) {err = - ECONNRESET ;if ( sunaddr == NULL ) goto out_free ;other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ;if ( other == NULL ) goto out_free ;}if ( sk_filter ( other , skb ) < 0 ) {err = len ;goto out_free ;}unix_state_lock ( other ) ;err = - EPERM ;if ( ! unix_may_send ( sk , other ) ) goto out_unlock ;if ( sock_flag ( other , SOCK_DEAD ) ) {unix_state_unlock ( other ) ;sock_put ( other ) ;err = 0 ;unix_state_lock ( sk ) ;if ( unix_peer ( sk ) == other ) {unix_peer ( sk ) = NULL ;unix_state_unlock ( sk ) ;","if ( unix_peer ( sk ) == other ) {unix_peer ( sk ) = NULL ;unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) ;unix_state_unlock ( sk ) ;",449
628,"if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) {if ( ! timeo ) {err = - EAGAIN ;goto out_unlock ;}timeo = unix_wait_for_peer ( other , timeo ) ;err = sock_intr_errno ( timeo ) ;","if ( unlikely ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) {if ( ! timeo ) {err = - EAGAIN ;sk_locked = 1 ;goto out_unlock ;}timeo = unix_wait_for_peer ( other , timeo ) ;err = sock_intr_errno ( timeo ) ;",449
629,out_unlock :  unix_state_unlock ( other ) ;out_free : kfree_skb ( skb ) ;,out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;unix_state_unlock ( other ) ;out_free : kfree_skb ( skb ) ;,449
630,pinctrl_unregister ( gpio_dev -> pctrl ) ;return 0 ;,return 0 ;,450
631,load_xid_epoch ( & state ) ;nxip = cur -> xcnt ;,"load_xid_epoch ( & state ) ;StaticAssertStmt ( MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP , ""possible<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>txid_current_snapshot()"" ) ;nxip = cur -> xcnt ;",451
632,"err = - EMSGSIZE ;if ( len > 0xFFFF )  goto out ;err = - EOPNOTSUPP ;if ( msg -> msg_flags & MSG_OOB ) goto out ;if ( msg -> msg_namelen ) {DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ;err = - EINVAL ;if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ;if ( usin -> sin_family != AF_INET ) {pr_info_once ( ""%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\\err = - EAFNOSUPPORT ;if ( usin -> sin_family ) goto out ;}daddr = usin -> sin_addr . s_addr ;}else {err = - EDESTADDRREQ ;if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ;daddr = inet -> inet_daddr ;}ipc . sockc . tsflags = sk -> sk_tsflags ;ipc . addr = inet -> inet_saddr ;ipc . opt = NULL ;ipc . tx_flags = 0 ;ipc . ttl = 0 ;ipc . tos = - 1 ;ipc . oif = sk -> sk_bound_dev_if ;if ( msg -> msg_controllen ) {err = ip_cmsg_send ( sk , msg , & ipc , false ) ;if ( unlikely ( err ) ) {kfree ( ipc . opt ) ;goto out ;}if ( ipc . opt ) free = 1 ;}saddr = ipc . addr ;ipc . addr = daddr ;if ( ! ipc . opt ) {struct ip_options_rcu * inet_opt ;rcu_read_lock ( ) ;inet_opt = rcu_dereference ( inet -> inet_opt ) ;if ( inet_opt ) {memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ;ipc . opt = & opt_copy . opt ;}rcu_read_unlock ( ) ;}if ( ipc . opt ) {err = - EINVAL ;if ( inet -> hdrincl )  goto done ;",int hdrincl ;err = - EMSGSIZE ;if ( hdrincl ) goto done ;,452
633,"flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE ,  inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol ,  inet_sk_flowi_flags ( sk ) |  ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) ,  daddr , saddr , 0 , 0 , sk -> sk_uid ) ;if ( ! inet -> hdrincl ) {rfv . msg = msg ;","flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , daddr , saddr , 0 , 0 , sk -> sk_uid ) ;if ( ! inet -> hdrincl ) {rfv . msg = msg ;",452
634,"back_from_confirm :  if ( inet -> hdrincl )  err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ;","back_from_confirm : if ( inet -> hdrincl ) err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ;",452
635,case IO_DISCONNECTED :  io_free ( fs -> io ) ;fs -> io = NULL ;break ;,"
",453
636,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},454
637,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,454
638,"if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;","fix_google_param ( google_out ) ;fix_google_param ( google_sig ) ;fix_google_param ( google_reqId ) ;fix_google_param ( google_version ) ;fix_google_param ( responseHandler ) ;fix_google_param ( outFileName ) ;if ( ! chart || ! * chart ) {buffer_sprintf ( w -> response . data , ""No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request."" ) ;",455
639,"while ( i < npages ) {# ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ;# endif unsigned order = 0 , j ;if ( ! pages [ i ] ) {++ i ;continue ;}# ifdef CONFIG_TRANSPARENT_HUGEPAGE  if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) {for ( j = 0 ;j < HPAGE_PMD_NR ;++ j ) if ( p ++ != pages [ i + j ] ) break ;if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ;}# endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\\__free_pages ( pages [ i ] , order ) ;j = 1 << order ;while ( j ) {pages [ i ++ ] = NULL ;-- j ;}}return ;}i = 0 ;# ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) {unsigned max_size , n2free ;spin_lock_irqsave ( & huge -> lock , irq_flags ) ;while ( i < npages ) {struct page * p = pages [ i ] ;",+ i ;+ j ) if ( p ++ != pages [ i + j ] ) break ;while ( ( npages - i ) >= HPAGE_PMD_NR ) {struct page * p = pages [ i ] ;,456
640,"asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr )  {console_verbose ( ) ;die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ;local_irq_disable ( ) ;panic ( ""bad<S2SV_blank>mode"" ) ;","asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) {siginfo_t info ;void __user * pc = ( void __user * ) instruction_pointer ( regs ) ;console_verbose ( ) ;__show_regs ( regs ) ;info . si_signo = SIGILL ;info . si_errno = 0 ;info . si_code = ILL_ILLOPC ;info . si_addr = pc ;arm64_notify_die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , & info , 0 ) ;",457
641,status = sBtInterface -> enable ( ) ;check_return_status ( status ) ;,status = sBtInterface -> enable ( false ) ;check_return_status ( status ) ;,458
642,"static int  l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 )   {if ( tl1 > l2 ) return 0 ;","static int l_strnstart ( netdissect_options * ndo , const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) {if ( ! ND_TTEST2 ( * str2 , tl1 ) ) {return 0 ;}if ( tl1 > l2 ) return 0 ;",459
643,else   iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ;if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) {,else {dst = skb_dst ( skb ) ;iif = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ;}if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) {,460
644,"int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) )  return - 1 ;","static int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {const UINT64 offset = ( UINT64 ) fields -> BufferOffset + ( UINT64 ) fields -> Len ;if ( offset > Stream_Length ( s ) ) return - 1 ;",461
645,"if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) {fprintf ( tf , ""%d\\\","if ( ( tf = fopen_safe ( tfile -> file_path , ""w"" ) ) ) {fprintf ( tf , ""%d\\\",462
646,"int  rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len )  {attr = ( struct vendor_attribute * ) * data ;* vendor = ntohl ( attr -> vendor_value ) ;* data = attr -> attrib_data ;return ( attr -> attrib_type ) ;}","int rad_get_vendor_attr ( u_int32_t * vendor , unsigned char * type , const void * * data , size_t * len , const void * raw , size_t raw_len ) {if ( raw_len < sizeof ( struct vendor_attribute ) ) {return - 1 ;}attr = ( struct vendor_attribute * ) raw ;* vendor = ntohl ( attr -> vendor_value ) ;* type = attr -> attrib_type ;* data = attr -> attrib_data ;if ( ( attr -> attrib_len + 4 ) > raw_len ) {return - 1 ;}return ( attr -> attrib_type ) ;}",463
647,mutex_lock ( & tu -> tread_sem ) ;if ( tu -> timeri ) {,if ( tu -> timeri ) {,464
648,__err :  mutex_unlock ( & tu -> tread_sem ) ;return err ;,__err : return err ;,464
649,"strlcpy ( comp1_str , comp1 -> data , comp1 -> length + 1 ) ;if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST ||  krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_INST || ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_UNKNOWN && kdc_active_realm -> realm_host_based_services != NULL && ( krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , comp1_str ) == TRUE || krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , KRB5_CONF_ASTERISK ) == TRUE ) ) ) && ( kdc_active_realm -> realm_no_host_referral == NULL || ( krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , KRB5_CONF_ASTERISK ) == FALSE && krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , comp1_str ) == FALSE ) ) ) {if ( memchr ( comp2 -> data , \'.\' , comp2 -> length ) == NULL ) goto cleanup ;temp_buf = calloc ( 1 , comp2 -> length + 1 ) ;strlcpy ( temp_buf , comp2 -> data , comp2 -> length + 1 ) ;retval = krb5int_get_domain_realm_mapping ( kdc_context , temp_buf , & realms ) ;","if ( comp1 -> data , comp1 -> length + 1 ) ;strlcpy ( temp_buf , comp2 -> data , comp2 -> length + 1 ) ;retval = krb5int_get_domain_realm_mapping ( kdc_context , temp_buf , & realms ) ;",465
650,"for ( i = 0 ;i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ;i ++ )  photometric [ i ] = ( char ) data [ i ] ;","if ( data == ( unsigned char * ) NULL ) break ;for ( i = 0 ;i <= ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ;i ++ ) photometric [ i ] = ( char ) data [ i ] ;",466
651,case 0x0008 :  {number_scenes = StringToUnsignedLong ( ( char * ) data ) ;,case 0x0008 : {if ( data == ( unsigned char * ) NULL ) break ;number_scenes = StringToUnsignedLong ( ( char * ) data ) ;,466
652,"if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1051 : {if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ;break ;}case 0x1052 : {if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1053 : {if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1200 : case 0x3006 : {if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / bytes_per_pixel ) ;datum = ( int ) colors ;graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ;if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ;else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ;break ;}case 0x1201 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ;if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;redmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1202 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ;if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;greenmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1203 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ;if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;bluemap [ i ] = ( int ) index ;p += 2 ;}break ;}default : break ;}break ;}case 0x2050 : {switch ( element ) {case 0x0020 : {if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) polarity = MagickTrue ;break ;}default : break ;}break ;}default : break ;}if ( data != ( unsigned char * ) NULL ) {char * attribute ;for ( i = 0 ;dicom_info [ i ] . description != ( char * ) NULL ;i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ;if ( dicom_info [ i ] . description != ( char * ) NULL ) {attribute = AcquireString ( ""dcm:"" ) ;( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ;for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) {( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ;( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ;}attribute = DestroyString ( attribute ) ;}}if ( image_info -> verbose != MagickFalse ) {if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\\else {for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) {ssize_t j ;datum = 0 ;for ( j = ( ssize_t ) length - 1 ;j >= 0 ;j -- ) datum = ( 256 * datum + data [ j ] ) ;( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ;}else for ( i = 0 ;i < ( ssize_t ) length ;i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ;else ( void ) FormatLocaleFile ( stdout , ""%c"" , \'.\' ) ;( void ) FormatLocaleFile ( stdout , ""\\\}}if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}}if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ;if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) {Image * images ;ImageInfo * read_info ;int c ;size_t length ;unsigned int tag ;for ( i = 0 ;i < ( ssize_t ) stream_info -> remaining ;i ++ ) ( void ) ReadBlobByte ( image ) ;tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ;( void ) tag ;length = ( size_t ) ReadBlobLSBLong ( image ) ;stream_info -> offset_count = length >> 2 ;if ( stream_info -> offset_count != 0 ) {MagickOffsetType offset ;stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ;if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;offset = TellBlob ( image ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] += offset ;}read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;images = NewImageList ( ) ;for ( scene = 0 ;scene < ( ssize_t ) number_scenes ;scene ++ ) {char filename [ MagickPathExtent ] ;const char * property ;FILE * file ;Image * jpeg_image ;int unique_file ;unsigned int tag ;tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ;length = ( size_t ) ReadBlobLSBLong ( image ) ;if ( tag == 0xFFFEE0DD ) break ;if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( file == ( FILE * ) NULL ) {( void ) RelinquishUniqueFileResource ( filename ) ;ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ;break ;}for ( ;length != 0 ;length -- ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}( void ) fputc ( c , file ) ;}( void ) fclose ( file ) ;( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ;if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ;jpeg_image = ReadImage ( read_info , exception ) ;if ( jpeg_image != ( Image * ) NULL ) {ResetImagePropertyIterator ( image ) ;property = GetNextImageProperty ( image ) ;while ( property != ( const char * ) NULL ) {( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ;property = GetNextImageProperty ( image ) ;}AppendImageToList ( & images , jpeg_image ) ;}( void ) RelinquishUniqueFileResource ( filename ) ;}read_info = DestroyImageInfo ( read_info ) ;image = DestroyImage ( image ) ;return ( GetFirstImageInList ( images ) ) ;}if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) {QuantumAny range ;size_t length ;length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ;for ( i = 0 ;i ++ )  scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ;","if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) GetQuantumRange ( depth ) + 1 ) ;for ( i = 0 ;i ++ ) scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ;",466
653,"status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;","if ( pixel . red <= GetQuantumRange ( depth ) ) status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;",466
654,pixel . red = scale [ pixel . red ] ;pixel . green = scale [ pixel . green ] ;pixel . blue = scale [ pixel . blue ] ;},pixel . red = scale [ pixel . red ] ;if ( pixel . green <= GetQuantumRange ( depth ) ) pixel . green = scale [ pixel . green ] ;if ( pixel . blue <= GetQuantumRange ( depth ) ) pixel . blue = scale [ pixel . blue ] ;},466
655,"size_t ss = CDF_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;if ( pos > ss * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;",467
656,"
",if ( stco -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ;,468
657,( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ;}if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ;( * offset ) = co64 -> offsets [ sampleNumber - 1 ] ;,( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ;}if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ;if ( co64 -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ;( * offset ) = co64 -> offsets [ sampleNumber - 1 ] ;,468
658,"memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;rcu_read_lock ( ) ;","memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;rcu_read_lock ( ) ;",469
659,"vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;{vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ;","memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ;{memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ;",470
660,"rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ;if ( rsrc . type_count < 1 ) {","if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) {psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\\goto parse_rsrc_fork_cleanup ;};rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ;if ( rsrc . type_count < 1 ) {",471
661,k ++ )  {if ( marker == STR_MARKER ) {,"k ++ ) {if ( rsrc . type_offset + k * 8 > rsrc . rsrc_len ) {psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\\goto parse_rsrc_fork_cleanup ;};if ( marker == STR_MARKER ) {",471
662,"int start = 0 ;u32 prev_legacy , cur_legacy ;kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;","int start = 0 ;int i ;u32 prev_legacy , cur_legacy ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , kvm -> arch . vpit -> pit_state . channels [ i ] . count , start ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",472
663,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",473
664,if ( ( s -> options & SSL_OP_EPHEMERAL_RSA )  # ifndef OPENSSL_NO_KRB5 && ! ( alg_k & SSL_kKRB5 ) # endif )  s -> s3 -> tmp . use_rsa_tmp = 1 ;else s -> s3 -> tmp . use_rsa_tmp = 0 ;,s -> s3 -> tmp . use_rsa_tmp = 1 ;else s -> s3 -> tmp . use_rsa_tmp = 0 ;,474
665,"if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ;if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) {code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ;if ( code ) return code ;}tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ;code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ;if ( code ) goto error_return ;lock_flags = XFS_ILOCK_EXCL ;xfs_ilock ( ip , lock_flags ) ;if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) {",if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! capable_wrt_inode_uidgid ( VFS_I ( ip ) ) ) {,475
666,"if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) &&  ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) )  ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;","if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ;",475
667,release_sock ( sk ) ;return 0 ;,msg -> msg_namelen = 0 ;release_sock ( sk ) ;return 0 ;,476
668,"}ret = pipe_set_size ( pipe , nr_pages ) ;","}else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) {ret = - EPERM ;goto out ;}ret = pipe_set_size ( pipe , nr_pages ) ;",477
669,"# ifdef CONFIG_SWAP  if ( ! file ) {* prev = vma ;force_swapin_readahead ( vma , start , end ) ;* prev = vma ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;# else if ( ! file ) return - EBADF ;# endif if ( IS_DAX ( file_inode ( file ) ) ) {return 0 ;}* prev = vma ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;","* prev = vma ;# ifdef CONFIG_SWAP if ( ! file ) {force_swapin_readahead ( vma , start , end ) ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;",478
670,sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;iv = timr -> it_interval ;,sig_none = timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;iv = timr -> it_interval ;,479
671,"uint8_t i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\switch ( subtype ) {case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_len < 7 ) {return hexdump ;}sublen = * ( tptr + 6 ) ;if ( tlv_len < 7 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 7 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) {return hexdump ;}sublen = * ( tptr + 4 ) ;if ( tlv_len < 5 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 5 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;tval = * ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\","u_int i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\",480
672,"ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;","ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;",480
673,if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,if ( numrows < 0 || numcols < 0 ) {return 0 ;}if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) {return 0 ;,481
674,"int len = mutt_b64_decode ( buffer , encoded ) ;if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) {","int len = mutt_b64_decode ( buffer , encoded , sizeof ( buffer ) ) ;if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) {",482
675,case L2CAP_MODE_ERTM :  if ( enable_ertm )  break ;,case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING : if ( enable_ertm ) break ;,483
676,if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) {pDup -> op = TK_NULL ;pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ;},"assert ( pDup == 0 || ! ExprHasProperty ( pDup , EP_MemToken ) ) ;if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) {pDup -> op = TK_NULL ;pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ;pDup -> u . zToken = 0 ;}",484
677,"
","if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;",485
678,return self ;},return self ;},485
679,"rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;","if ( desc == NULL ) desc = """" ;rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;",486
680,"ND_PRINT ( ( ndo , ""%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , ( ndo -> ndo_vflag < 1 ) ? """" : ""\\\","ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;",487
681,"trunc :  ND_PRINT ( ( ndo , ""\\\return 0 ;","trunc : ND_PRINT ( ( ndo , ""\\\return 0 ;",487
682,uint64 nstrips64 ;uint32 nstrips32 ;,uint32 nstrips ;,488
683,"nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ;if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) )  return ;newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripByteCounts\\\\""<S2SV_blank>array"" ) ;newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) ,  ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripOffsets\\\\""<S2SV_blank>array"" ) ;for ( strip = 0 ;strip < nstrips32 ;if ( stripbytes > bytecount ) stripbytes = bytecount ;newcounts [ strip ] = stripbytes ;newoffsets [ strip ] = offset ;offset += stripbytes ;td -> td_stripsperimage = td -> td_nstrips = nstrips32 ;TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ;","nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ;if ( nstrips == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) return ;newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips , sizeof ( uint64 ) , ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripByteCounts\\\\""<S2SV_blank>array"" ) ;newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips , sizeof ( uint64 ) , ""for<S2SV_blank>chopped<S2SV_blank>\\\\""StripOffsets\\\\""<S2SV_blank>array"" ) ;for ( strip = 0 ;strip < nstrips ;if ( stripbytes > bytecount ) stripbytes = bytecount ;newcounts [ strip ] = stripbytes ? offset : 0 ;offset += stripbytes ;td -> td_stripsperimage = td -> td_nstrips = nstrips ;TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ;",488
684,static ssize_t aio_setup_single_vector ( struct kiocb * kiocb )   {kiocb -> ki_iovec = & kiocb -> ki_inline_vec ;kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ;kiocb -> ki_nr_segs = 1 ;,"static ssize_t aio_setup_single_vector ( int type , struct file * file , struct kiocb * kiocb ) {int bytes ;bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ;if ( bytes < 0 ) return bytes ;kiocb -> ki_iovec = & kiocb -> ki_inline_vec ;kiocb -> ki_iovec -> iov_len = bytes ;kiocb -> ki_nr_segs = 1 ;",489
685,switch ( c = ( * dis_getc ) ( stream ) )  {,"if ( count >= dis_umaxd ) {if ( count > dis_umaxd ) goto overflow ;if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ;}switch ( c = ( * dis_getc ) ( stream ) ) {",490
686,"if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 )  return - 1 ;","if ( TEMP_FAILURE_RETRY ( ioctl ( socket -> fd , FIONREAD , & size ) ) == - 1 ) return - 1 ;",491
687,"static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd ,  int hbs , int mi_row , int mi_col ,  PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) {const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ;const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ;vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ;}vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ;}","static void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const xd , int hbs , int mi_row , int mi_col , PARTITION_TYPE p , BLOCK_SIZE bsize , vpx_writer * w ) {const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;const vpx_prob * const probs = xd -> partition_probs [ ctx ] ;const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ;vpx_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ;}vpx_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ;}",492
688,int i ;vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ;for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ;i -- )  {,vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ;for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ;i -- ) {,493
689,void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields )  {,static void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {,494
690,"result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ,  USB_DT_SECURITY , ( void * * ) & secd ) ;if ( result == - 1 ) {","result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , USB_DT_SECURITY , ( void * * ) & secd , sizeof ( * secd ) ) ;if ( result == - 1 ) {",495
691,"vpx_memcpy ( udp , up , 4 ) ;vpx_memcpy ( vdp , vp , 4 ) ;}","memcpy ( udp , up , 4 ) ;memcpy ( vdp , vp , 4 ) ;}",496
692,"regs [ value_regno ] . id = 0 ;regs [ value_regno ] . off = 0 ;regs [ value_regno ] . range = 0 ;regs [ value_regno ] . type = reg_type ;}}else if ( reg -> type == PTR_TO_STACK ) {if ( ! tnum_is_const ( reg -> var_off ) ) {char tn_buf [ 48 ] ;tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ;verbose ( env , ""variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d"" , tn_buf , off , size ) ;return - EACCES ;}off += reg -> var_off . value ;if ( off >= 0 || off < - MAX_BPF_STACK ) {verbose ( env , ""invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\\return - EACCES ;}if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ;if ( t == BPF_WRITE ) err = check_stack_write ( env , state , off , size , value_regno ) ;else err = check_stack_read ( env , state , off , size , value_regno ) ;","regs [ value_regno ] , size ) ;",497
693,"regs [ value_regno ] . var_off =  tnum_cast ( regs [ value_regno ] . var_off , size ) ;","coerce_reg_to_size ( & regs [ value_regno ] . var_off = tnum_cast ( regs [ value_regno ] . var_off , size ) ;",497
694,"int pkt_len ;char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir ,  cap_dst , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int ,   cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) )  return FALSE ;","char line [ NETSCREEN_LINE_LENGTH ] ;char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ;if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , cap_dst , & wth -> phdr , wth -> frame_buffer , line , err , err_info ) ) return FALSE ;",498
695,"return MSPACK_ERR_SIGNATURE ;}hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ;hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ;hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ;hdr -> length = 0 ;hdr -> filename = NULL ;hdr -> extra = NULL ;hdr -> extra_length = 0 ;if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) {if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;hdr -> length = EndGetI32 ( & buf [ 0 ] ) ;}if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) {if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ;}if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) {if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ;i = EndGetI16 ( & buf [ 0 ] ) ;if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ;}if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) {off_t pos = sys -> tell ( fh ) ;char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ;if ( ! fn ) return MSPACK_ERR_NOMEMORY ;hdr -> filename = fn ;if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) {if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 9 ) ? i + 1 : 9 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) )  return MSPACK_ERR_SEEK ;}if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 4 ) ? i + 1 : 4 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) )  return MSPACK_ERR_SEEK ;}if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ;","int len ;char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ;if ( ! fn ) return MSPACK_ERR_NOMEMORY ;hdr -> filename = fn ;if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) {if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 9 ) ? i + 1 : 9 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) return MSPACK_ERR_SEEK ;}if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 4 ) ? i + 1 : 4 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) return MSPACK_ERR_SEEK ;}if ( ! ( hdr -> filename = fn ) ) return MSPACK_ERR_NOMEMORY ;",499
696,"int oe_iov_pack ( const struct oe_iovec * iov , int iovcnt , void * * buf_out ,  size_t * buf_size_out )  {if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out )  goto done ;* buf_size_out = buf_size ;buf = NULL ;","int oe_iov_pack ( const struct oe_iovec * iov , int iovcnt , void * * buf_out , size_t * buf_size_out , size_t * data_size_out ) {if ( data_size_out ) * data_size_out = 0 ;if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out || ! data_size_out ) goto done ;* buf_size_out = buf_size ;* data_size_out = data_size ;buf = NULL ;",500
697,buf = NULL ;ret = 0 ;,* data_size_out = data_size ;buf = NULL ;ret = 0 ;,500
698,"if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) {return - 1 ;","if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) {jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\return - 1 ;}if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) {return - 1 ;",501
699,"if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;out_drop_write :  fh_drop_write ( fh ) ;","error = fh_want_write ( fh ) ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;out_drop_lock : fh_unlock ( fh ) ;fh_drop_write ( fh ) ;",502
700,"forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  NULL , NULL ) ;forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  NULL , NULL ) ;","forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , offset , flags , NULL , NULL ) ;forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , offset , flags , NULL , NULL ) ;",503
701,"backward_matches = exec ( ac_match -> backward_code ,  data + offset ,  offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ;","backward_matches = exec ( ac_match -> backward_code , data + offset , data_size - offset , offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ;",503
702,"
",if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;,504
703,"bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ;if ( bh ) {","bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ;if ( bh ) {",504
704,"SEPARATE_ZVAL ( var2 ) ;convert_to_double ( * var2 ) ;matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ;RETURN_FALSE ;}}","if ( Z_TYPE_PP ( var2 ) != IS_DOUBLE ) {zval dval ;dval = * * var ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ;}else {matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ;}}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ;RETURN_FALSE ;}}",505
705,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;set_acl_inode ( inode , inode -> i_mode ) ;if ( error == 0 ) acl = NULL ;","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;",506
706,"vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ;if ( cpi -> common . frame_type != KEY_FRAME )  {","if ( cpi -> oxcf . screen_content_mode ) {int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ;if ( Q >= qp_thresh ) {cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ;}else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) {cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ;}else {cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ;}block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ;}memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ;if ( cpi -> common . frame_type != KEY_FRAME && block_count > 0 ) {",507
707,cpi -> cyclic_refresh_mode_index = i ;},cpi -> cyclic_refresh_mode_index = i ;# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) {cpi -> cyclic_refresh_q = Q ;lf_adjustment = - 40 ;for ( i = 0 ;i < mbs_in_frame ;++ i ) {seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ;}}}# endif },507
708,struct serial_icounter_struct icount ;struct sb_uart_icount cnow ;,struct serial_icounter_struct icount = {};struct sb_uart_icount cnow ;,508
709,"other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ;if ( ! other_branch ) return - EFAULT ;","other_branch = push_stack ( env , * insn_idx , false + insn -> off + 1 , * insn_idx ) ;if ( ! other_branch ) return - EFAULT ;",509
710,}# ifdef FEAT_EVAL if ( ignore_script ) return ;,}if ( check_secure ( ) ) return ;# ifdef FEAT_EVAL if ( ignore_script ) return ;,510
711,msc -> ntouches = 0 ;for ( ii = 0 ;npoints = ( size - 6 ) / 8 ;msc -> ntouches = 0 ;,"if ( npoints > 15 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\\return 0 ;}msc -> ntouches = 0 ;for ( ii = 0 ;npoints = ( size - 6 ) / 8 ;if ( npoints > 15 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\\return 0 ;}msc -> ntouches = 0 ;",511
712,"bool inode_owner_or_capable ( const struct inode * inode )  {if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ;if ( inode_capable ( inode , CAP_FOWNER ) )  return true ;","bool inode_owner_or_capable ( const struct inode * inode ) {struct user_namespace * ns ;if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ;ns = current_user_ns ( ) ;if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid ) ) return true ;",512
713,filename [ filename_size ++ ] = \'\\\\0\' ;if ( rar -> sconv_utf16be == NULL ) {,filename [ filename_size ++ ] = \'\\\\0\' ;if ( rar -> sconv_utf16be == NULL ) {,513
714,goto error ;},usb_free_urb ( urb ) ;goto error ;},514
715,"msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ;","skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ;",515
716,"static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data ,  OPJ_UINT32 * p_data_written ,  const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) {opj_write_bytes ( p_data , J2K_MS_SOT ,  2 ) ;","static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) {if ( p_total_data_size < 12 ) {opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\\return OPJ_FALSE ;}opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ;",516
717,"void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) {fadst16_8col ( in0 ) ;","static void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) {fadst16_8col ( in0 ) ;",517
718,# if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL &&  ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) &&  EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) {,# if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL && ! SSL_WRITE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) {,518
719,"static const u_char * ikev1_attrmap_print ( netdissect_options * ndo ,  const u_char * p , const u_char * ep ,  const struct attrmap * map , size_t nmap ) {if ( p [ 0 ] & 0x80 )  totlen = 4 ;else  totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ep < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;ND_PRINT ( ( ndo , ""value="" ) ) ;v = EXTRACT_16BITS ( & p [ 2 ] ) ;else  rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ;}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ;}return p + totlen ;}","static const u_char * ep2 , const struct attrmap * map , size_t nmap ) {ND_TCHECK ( p [ 0 ] ) ;}if ( ep2 < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;ND_PRINT ( ( ndo , ""value="" ) ) ;v = EXTRACT_16BITS ( & p [ 2 ] ) ;else rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , totlen - 4 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}return p + totlen ;trunc : return NULL ;}",519
720,u32 offset ;msg -> msg_namelen = 0 ;,u32 offset ;,520
721,rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i )  {if ( i -> next == 0 ) {,rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i ) {if ( ! i ) return NULL ;if ( i -> next == 0 ) {,521
722,if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,if ( bpp == 1 && buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ;,522
723,if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,if ( pixdepth == 1 ) {avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;}else if ( bpp == 8 && pixdepth == 8 ) {avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;,522
724,"void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd ,  int frame_filter_level , int y_only , int partial_frame ) {","void vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , VP9_COMMON * cm , MACROBLOCKD * xd , int frame_filter_level , int y_only , int partial_frame ) {",523
725,"vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd ,  start_mi_row , end_mi_row , y_only ) ;","vp9_loop_filter_rows ( frame , cm , xd -> plane , start_mi_row , end_mi_row , y_only ) ;",523
726,"
",queueItem -> interface = interface ;,524
727,queueItem -> srcPort = ntohs ( header -> srcPort ) ;# if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) {,queueItem -> srcPort = ntohs ( header -> srcPort ) ;# if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) {,524
728,"server . bindaddr = NULL ;server . unixsocket = NULL ;server . ipfd = - 1 ;server . sofd = - 1 ;server . dbnum = REDIS_DEFAULT_DBNUM ;server . verbosity = REDIS_VERBOSE ;server . maxidletime = REDIS_MAXIDLETIME ;server . saveparams = NULL ;server . loading = 0 ;server . logfile = NULL ;server . syslog_enabled = 0 ;server . syslog_ident = zstrdup ( ""redis"" ) ;","server . ds_enabled = 0 ;server . ds_path = zstrdup ( ""redis"" ) ;",525
729,"server . pidfile = zstrdup ( ""/var/run/redis.pid"" ) ;server . dbfilename = zstrdup ( ""dump.rdb"" ) ;server . appendfilename = zstrdup ( ""appendonly.aof"" ) ;server . requirepass = NULL ;server . rdbcompression = 1 ;server . activerehashing = 1 ;server . maxclients = 0 ;server . bpop_blocked_clients = 0 ;server . maxmemory = 0 ;server . maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU ;server . maxmemory_samples = 3 ;server . vm_enabled = 0 ;server . vm_swap_file = zstrdup ( ""/tmp/redis-%p.vm"" ) ;server . vm_page_size = 256 ;server . vm_pages = 1024 * 1024 * 100 ;server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ;server . vm_max_threads = 4 ;","server . pidfile = zstrdup ( ""/tmp/redis.ds"" ) ;server . cache_max_memory = 64LL * 1024 * 100 ;server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ;server . vm_max_threads = 4 ;",525
730,int this_rd ;if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) {,int this_rd ;int denoise_aggressive = 0 ;if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) {,526
731,if ( this_mode == ZEROMV )  {if ( ( cpi -> ref_frame_flags & VP8_LAST_FRAME &  cpi -> common . refresh_last_frame ) && x -> e_mbd . mode_info_context -> mbmi . ref_frame != LAST_FRAME ) rd_adj = 100 ;,# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {denoise_aggressive = ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive ) ? 1 : 0 ;}# endif if ( ! cpi -> oxcf . screen_content_mode && this_mode == ZEROMV && x -> e_mbd . mode_info_context -> mbmi . ref_frame == LAST_FRAME && ( denoise_aggressive || ( cpi -> closest_reference_frame == LAST_FRAME ) ) ) {if ( x -> is_skin ) rd_adj = 100 ;,526
732,kfree ( adis -> buffer ) ;if ( ! adis -> buffer )  return - ENOMEM ;rx = adis -> buffer ;tx = rx + scan_count ;,kfree ( adis -> buffer ) {kfree ( adis -> xfer ) ;adis -> xfer = NULL ;;}if ( ! adis -> buffer ) return - ENOMEM ;rx = adis -> buffer ;tx = rx + scan_count ;,527
733,"static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel )  {assign_eip_near ( ctxt , ctxt -> _eip + rel ) ;}","static inline int jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) {return assign_eip_near ( ctxt , ctxt -> _eip + rel ) ;}",528
734,"option_number += option_ext ;* message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ;","if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) {return - 1 ;}* message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ;",529
735,"option_number += 269 ;* message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ;","if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) {return - 1 ;}* message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ;",529
736,"if ( io -> status ) {spin_unlock_irqrestore ( & io -> lock , flags ) ;spin_unlock_irqrestore ( & io -> lock , flags ) ;for ( i = io -> entries - 1 ;}","if ( io -> status || io -> count == 0 ) {spin_unlock_irqrestore ( & io -> lock , flags ) ;io -> count ++ ;spin_unlock_irqrestore ( & io -> lock , flags ) ;for ( i = io -> entries - 1 ;spin_lock_irqsave ( & io -> lock , flags ) ;io -> count -- ;if ( ! io -> count ) complete ( & io -> complete ) ;spin_unlock_irqrestore ( & io -> lock , flags ) ;}",530
737,"else if ( n <= 15 && ! strchr ( name , \'.\' ) && type == HOST_TYPE_IPV4 )  {else if ( ! strchr ( name , \'.\' ) )  {","else if ( n <= 15 && ! osStrchr ( name , \'.\' ) && type == HOST_TYPE_IPV4 ) {else if ( ! osStrchr ( name , \'.\' ) ) {",531
738,"hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;nexthdr = * prevhdr ;","hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;if ( hlen < 0 ) {err = hlen ;goto fail ;}nexthdr = * prevhdr ;",532
739,"rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\if ( msg_flags & MSG_OOB ) goto out ;","rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\msg -> msg_namelen = 0 ;if ( msg_flags & MSG_OOB ) goto out ;",533
740,"
",msg -> msg_namelen = sizeof ( * sin ) ;,533
741,}break ;,}break ;,533
742,}if ( addr_len ) * addr_len = sizeof ( * saddr ) ;,* addr_len = sizeof ( * saddr ) ;},534
743,"void fadst8_sse2 ( __m128i * in ) {const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ;","static void fadst8_sse2 ( __m128i * in ) {const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ;",535
744,const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ;,const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ;const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ;,535
745,"int rc ;sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ;rc = ecryptfs_parse_options ( sbi , raw_data ) ;if ( rc ) {","uid_t check_ruid ;int rc ;sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ;rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ;if ( rc ) {",536
746,"ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ;s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ;","if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) {rc = - EPERM ;printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\\goto out_free ;}ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ;s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ;",536
747,"list_add ( & dev -> vm_node , & kvm -> devices ) ;mutex_unlock ( & kvm -> lock ) ;if ( ops -> init ) ops -> init ( dev ) ;ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ;if ( ret < 0 ) {mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;ops -> destroy ( dev ) ;return ret ;}kvm_get_kvm ( kvm ) ;cd -> fd = ret ;",kvm_get_kvm ( kvm ) ;cd -> fd = ret ;,537
748,int is_entity ;int i ;Dwg_Class * klass ;unhandled : is_entity = 0 ;i = obj -> type - 500 ;klass = NULL ;dwg = obj -> parent ;if ( dwg -> dwg_class && i >= 0 && i < ( int ) dwg -> num_classes ) {klass = & dwg -> dwg_class [ i ] ;is_entity = klass ? dwg_class_is_entity ( klass ) : 0 ;}if ( obj -> fixedtype == DWG_TYPE_TABLE )  {}else if ( obj -> fixedtype == DWG_TYPE_DATATABLE )  {}else if ( klass && ! is_entity ) {,unhandled : if ( obj -> fixedtype == DWG_TYPE_TABLE ) {}else if ( obj -> fixedtype == DWG_TYPE_DATATABLE ) {}else if ( klass && ! is_entity ) {,538
749,evtchn_to_irq [ row ] [ col ] = irq ;return 0 ;,"WRITE_ONCE ( evtchn_to_irq [ row ] [ col ] , irq ) ;return 0 ;",539
750,"inl = i2d ( data , NULL ) ;buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ;","if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;goto err ;}inl = i2d ( data , NULL ) ;buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ;",540
751,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return 0 ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return 0 ;",541
752,"
",if ( ! cursor ) goto gc_complete ;,542
753,}slot = node -> parent_slot ;BUG_ON ( ! ptr ) ;node = assoc_array_ptr_to_node ( cursor ) ;,}slot = node -> parent_slot ;BUG_ON ( ! cursor ) ;node = assoc_array_ptr_to_node ( cursor ) ;,542
754,"down_write ( & mm -> mmap_sem ) ;vma = find_vma_prev ( mm , start , & prev ) ;","down_write ( & mm -> mmap_sem ) ;if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;vma = find_vma_prev ( mm , start , & prev ) ;",543
755,goto present_leaves_cluster_but_not_new_leaf ;},"pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\\}",544
756,"return true ;present_leaves_cluster_but_not_new_leaf :  pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\\new_n0 -> back_pointer = node -> back_pointer ;new_n0 -> parent_slot = node -> parent_slot ;new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ;new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ;new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ;new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ;edit -> adjust_count_on = new_n0 ;for ( i = 0 ;i < ASSOC_ARRAY_FAN_OUT ;i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ;new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ;edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ;edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ;edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ;edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ;pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\\","
",544
757,"
",msg -> msg_namelen = 0 ;,545
758,"lock_sock ( sk ) ;for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ;","lock_sock ( sk ) ;for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ;",545
759,"struct mount * m , * child ;int ret = 0 ;","struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ;struct mount * m , * child ;int ret = 0 ;",546
760,"source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ;child = copy_tree ( source , source -> mnt . mnt_root , type ) ;","source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ;if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ;child = copy_tree ( source , source -> mnt . mnt_root , type ) ;",546
761,}msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ;,}INTL_CHECK_LOCALE_LEN ( slocale_len ) ;msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ;,547
762,if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 4 ;}if ( context -> curY >= p -> height ) {context -> pass ++ ;if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 1 ;}break ;},if ( context -> curY >= p -> height ) {context -> pass ++ ;break ;}while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) {switch ( ++ context -> pass ) {case 2 : context -> curY = i -> posY + 4 ;break ;case 3 : context -> curY = i -> posY + 2 ;break ;case 4 : context -> curY = i -> posY + 1 ;break ;}},548
763,"if ( client -> priv -> conn != NULL ) {SmsCleanUp ( client -> priv -> conn ) ;}if ( client -> priv -> ice_connection != NULL ) {IceSetShutdownNegotiation ( client -> priv -> ice_connection , FALSE ) ;IceCloseConnection ( client -> priv -> ice_connection ) ;}if ( client -> priv -> protocol_timeout > 0 ) {g_source_remove ( client -> priv -> protocol_timeout ) ;}","
",549
764,"args -> index = probe ;else {name_rmt = xfs_attr3_leaf_name_remote ( leaf , probe ) ;if ( name_rmt -> namelen != args -> namelen ) continue ;if ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) != 0 ) continue ;if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ;args -> index = probe ;args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount ,  args -> valuelen ) ;return XFS_ERROR ( EEXIST ) ;}","args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , args -> valuelen ) ;",550
765,"void sum_2_variances ( const var * a , const var * b , var * r ) {fill_variance ( a -> sum_square_error + b -> sum_square_error ,  a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ;}","static void sum_2_variances ( const var * a , const var * b , var * r ) {assert ( a -> log2_count == b -> log2_count ) ;fill_variance ( a -> sum_square_error + b -> sum_square_error , a -> log2_count + 1 , r ) ;}",551
766,goto next_desc ;},"goto next_desc ;}if ( ( buflen < elength ) || ( elength < 3 ) ) {dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\\break ;}",552
767,DevInfo . MaxRDMBufferSize = BUFFER_4K ;DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ;,"memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;DevInfo . MaxRDMBufferSize = BUFFER_4K ;DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ;",553
768,"for ( i = 0 ;data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ;assert ( data [ i ] ) ;","assert ( jas_image_numcmpts ( image ) ;++ i ) {data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) <= 3 ) ;for ( i = 0 ;i < 3 ;++ i ) {data [ i ] = 0 ;}for ( i = 0 ;if ( ! ( data [ i ] ) ;",554
769,return - 1 ;}z = ( z << 8 ) | c ;nz += 8 ;,goto error ;}z = ( z << 8 ) | c ;nz += 8 ;,554
770,return - 1 ;return - 1 ;,goto error ;goto error ;,554
771,"
",data [ i ] = 0 ;error : for ( i = 0 ;i < 3 ;++ i ) {if ( data [ i ] ) {jas_matrix_destroy ( data [ i ] ) ;}}return - 1 ;,554
772,# ifndef _MSC_VER   char fpath [ grub_strlen ( currpath ) + 1 ] ;# else char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ;# endif  char * name = fpath ;,char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ;char * name = fpath ;,555
773,* currfound = currnode ;return 0 ;,* currfound = currnode ;free ( fpath ) ;return 0 ;,555
774,"return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ;}if ( grub_errno )   return grub_errno ;break ;return grub_error ( GRUB_ERR_SYMLINK_LOOP ,  ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ;free_node ( oldnode , c ) ;return grub_errno ;","free ( fpath ) ;return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ;}if ( grub_errno ) {free ( fpath ) ;return grub_errno ;}break ;free ( fpath ) ;free ( fpath ) ;return grub_error ( GRUB_ERR_SYMLINK_LOOP , ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ;free ( fpath ) ;free_node ( oldnode , c ) ;return grub_errno ;",555
775,"return grub_errno ;}return 0 ;}return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ;}","return grub_errno ;}free ( fpath ) ;return 0 ;}free ( fpath ) ;return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ;}",555
776,"
",if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) {ret = - EINVAL ;goto out_err1 ;},556
777,"clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ;if ( ! clips ) {","clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ;if ( ! clips ) {",556
778,return 0 ;},match_data -> cmp = asymmetric_key_cmp ;return 0 ;},557
779,"ret = - EFAULT ;if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ;ret = security_file_permission ( file , MAY_READ ) ;if ( unlikely ( ret ) ) break ;ret = aio_setup_single_vector ( kiocb ) ;ret = - EFAULT ;if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ;ret = security_file_permission ( file , MAY_WRITE ) ;if ( unlikely ( ret ) ) break ;ret = aio_setup_single_vector ( kiocb ) ;ret = security_file_permission ( file , MAY_READ ) ;if ( unlikely ( ret ) ) break ;","ret = aio_setup_single_vector ( READ , file , kiocb ) ;ret = aio_setup_single_vector ( WRITE , file , kiocb ) ;",558
780,"ret = security_file_permission ( file , MAY_WRITE ) ;if ( unlikely ( ret ) ) break ;","
",558
781,"long start ;char * header ;header = calloc ( 1 , 1024 ) ;start = ftell ( fp ) ;fseek ( fp , 0 , SEEK_SET ) ;","char * header ;header = calloc ( 1 , 1024 ) ;long start = ftell ( fp ) ;fseek ( fp , 0 , SEEK_SET ) ;",559
782,dev -> netdev_ops = & bnep_netdev_ops ;dev -> watchdog_timeo = HZ * 2 ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & bnep_netdev_ops ;dev -> watchdog_timeo = HZ * 2 ;,560
783,return ret != - EEXIST ? ret : 0 ;},return ret ;},561
784,"for ( pass = 0 ;pass < 10 ;proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ;","for ( pass = 0 ;pass < 10 || image ;proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ;",562
785,int64_t old_off = s -> off ;uint8_t old_buf [ BUFFER_SIZE ] ;else if ( ( s -> filesize == - 1 && whence == SEEK_END ) )  return AVERROR ( ENOSYS ) ;,uint64_t old_off = s -> off ;uint8_t old_buf [ BUFFER_SIZE ] ;else if ( ( s -> filesize == UINT64_MAX && whence == SEEK_END ) ) return AVERROR ( ENOSYS ) ;,563
786,vpx_scale_rtcd ( ) ;once ( setup_rtcd_internal ) ;,once ( setup_rtcd_internal ) ;,564
787,"int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;BIO_write ( bio , obj_txt , len ) ;BIO_write ( bio , ""\\\","OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;BIO_printf ( bio , obj_txt , len ) ;BIO_write ( bio , ""%s\\\",565
788,return in ;},return NULL ;},566
789,"int perf_event_task_disable ( void )  {struct perf_event * event ;list_for_each_entry ( event , & current -> perf_event_list , owner_entry )   perf_event_for_each_child ( event , perf_event_disable ) ;mutex_unlock ( & current -> perf_event_mutex ) ;","int perf_event_task_disable ( void ) {struct perf_event_context * ctx ;struct perf_event * event ;list_for_each_entry ( event , _perf_event_disable ) ;perf_event_ctx_unlock ( event , ctx ) ;}mutex_unlock ( & current -> perf_event_mutex ) ;",567
790,if ( ! unconditional ( & e -> ipv6 ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,568
791,"if ( code )  return code ;code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;","if ( code ) {* status = ""DECODE_PA_S4U_X509_USER"" ;return code ;}code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ;",569
792,"arg_ty  arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int  end_lineno , int end_col_offset , PyArena * arena ) {","arg_ty arg ( identifier arg , expr_ty annotation , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",570
793,p -> lineno = lineno ;p -> col_offset = col_offset ;,p -> type_comment = type_comment ;p -> lineno = lineno ;p -> col_offset = col_offset ;,570
794,"int hdrlen ;uint16_t fc ;if ( caplen < 3 ) {ND_PRINT ( ( ndo , ""[|802.15.4]<S2SV_blank>%x"" , caplen ) ) ;return caplen ;}fc = EXTRACT_LE_16BITS ( p ) ;hdrlen = extract_header_length ( fc ) ;seq = EXTRACT_LE_8BITS ( p + 2 ) ;p += 3 ;caplen -= 3 ;ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ fc & 0x7 ] ) ) ;if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ;if ( hdrlen == - 1 ) {ND_PRINT ( ( ndo , ""invalid!<S2SV_blank>"" ) ) ;return caplen ;}if ( ! ndo -> ndo_vflag ) {p += hdrlen ;caplen -= hdrlen ;}else {switch ( ( fc >> 10 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;p += 2 ;case 0x03 :  panid = EXTRACT_LE_16BITS ( p ) ;ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;break ;}ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ;switch ( ( fc >> 14 ) & 0x3 ) {case 0x00 :  ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;case 0x01 :  ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;case 0x02 :   if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p ) ;}ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;break ;case 0x03 :   if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p ) ;}ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;break ;}caplen -= hdrlen ;}return 0 ;}","u_int hdrlen ;uint16_t fc ;switch ( ( fc >> 10 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;caplen -= 2 ;hdrlen += 2 ;if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;p += 2 ;case 0x03 : panid = EXTRACT_LE_16BITS ( p ) ;ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;break ;}ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ;switch ( ( fc >> 14 ) & 0x3 ) {case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ;case 0x01 : ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ;case 0x02 : if ( ! ( fc & ( 1 << 6 ) ) ) {panid = EXTRACT_LE_16BITS ( p + 2 ) ) ) ;caplen -= 2 ;hdrlen += 2 ;}ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ;break ;case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}panid = EXTRACT_LE_16BITS ( p ) ;caplen -= 2 ;hdrlen += 2 ;caplen -= 2 ;hdrlen += 2 ;}if ( caplen < 2 ) {ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ;return hdrlen ;}if ( ndo -> ndo_vflag ) }ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ;caplen -= 8 ;hdrlen += 8 ;caplen -= 8 ;hdrlen += 8 ;break ;}return hdrlen ;}",571
795,"static void  l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat )  {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_ASYNC_MASK ) {","static void l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_ASYNC_MASK ) {",572
796,"int filt_mid = cm -> filter_level ;int filt_low = 0 ;vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ;cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ;","int filt_mid ;int filt_low = 0 ;memset ( ss_err , 0 , sizeof ( ss_err ) ) ;cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ;",573
797,"strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;rcipher . blocksize = alg -> cra_blocksize ;","strncpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ;rcipher . blocksize = alg -> cra_blocksize ;",574
798,vpx_active_map_t map = {0 }map . rows = ( cfg -> g_h + 15 ) / 16 ;,"vpx_active_map_t map = {0 , 0 , 0 }map . rows = ( cfg -> g_h + 15 ) / 16 ;",575
799,return NGHTTP2_ERR_INVALID_ARGUMENT ;},return NGHTTP2_ERR_INVALID_ARGUMENT ;}if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) {return NGHTTP2_ERR_TOO_MANY_SETTINGS ;},576
800,then = now ;for ( i = hist -> frames ;,if ( ! cfg -> rc_target_bitrate ) return ;then = now ;for ( i = hist -> frames ;,577
801,}},}}if ( free < 0 ) {err = - ENOMEM ;goto out ;},578
802,"if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",579
803,wp -> socket_mode = 0666 ;if ( ! c ) {,wp -> socket_mode = 0660 ;if ( ! c ) {,580
804,"strncpy ( str , ""?["" , len ) ;itostr ( token , & str [ 2 ] , 10 ) ;strncat ( str , ""]"" , len ) ;","espruino_snprintf ( str , len , ""?[%d]"" , token ) ;",581
805,"rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ;}","minfo . flags = 0 ;rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ;}",582
806,srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;,"memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;",583
807,"if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ;len -= sizeof ( * id ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ;nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ;len -= sizeof ( * io ) * nid ;io = ( struct id_off * ) ( id + 1 ) ;cp = ( char * ) ( io + nid ) ;if ( ! ND_TTEST2 ( cp , len ) ) {ND_PRINT ( ( ndo , ""\\\\"""" ) ) ;","if ( ND_TTEST2 ( cp , len ) ) {ND_PRINT ( ( ndo , ""\\\\"""" ) ) ;",584
808,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,585
809,"newinet -> pinet6 = & newdp6 -> inet6 ;newnp = inet6_sk ( newsk ) ;memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ;ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ;ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ;inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ;newsk -> sk_backlog_rcv = dccp_v4_do_rcv ;newnp -> pktoptions = NULL ;",newinet -> inet_opt = NULL ;,586
810,newinet -> opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;,newinet -> opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;,586
811,"static double get_prediction_decay_rate ( const VP9_COMMON * cm ,  const FIRSTPASS_STATS * next_frame ) {const double mb_sr_err_diff = ( next_frame -> sr_coded_error -  next_frame -> coded_error ) / cm -> MBs ;const double second_ref_decay = mb_sr_err_diff <= 512.0   ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 )  : 0.85 ;return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ;","static double get_prediction_decay_rate ( const VP9_COMP * cpi , const FIRSTPASS_STATS * next_frame ) {const double sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) ;const double second_ref_decay = mb_sr_err_diff <= 512.0 ? fclamp ( pow ( 1.0 - sr_decay_rate ) * zero_motion_factor ) ) ) ;",587
812,"# endif case PTRACE_GET_THREAD_AREA :  ret = put_user ( task_thread_info ( child ) -> tp_value ,  datap ) ;","# endif case PTRACE_GET_THREAD_AREA : ret = put_user ( task_thread_info ( child ) -> tp_value [ 0 ] , datap ) ;",588
813,"flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ;vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) ,  & stream -> config . cfg , flags ) ;","# if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ;# endif flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ;vpx_codec_enc_init ( & stream -> encoder , global -> codec -> codec_interface ( ) , & stream -> config . cfg , flags ) ;",589
814,"vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ;}","vpx_codec_dec_init ( & stream -> decoder , decoder -> codec_interface ( ) , NULL , 0 ) ;}",589
815,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" ,  dev_name ( & qedi -> pdev -> dev ) , nfunc , line ,  qedi -> host_no , & vaf ) ;else  pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",590
816,* head = NULL ;* out = line ;return 0 ;,"giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ;return GIT_ERROR ;",591
817,"static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client ,  int id ) {handle = idr_find ( & client -> idr , id ) ;if ( handle ) ion_handle_get ( handle ) ;return handle ? handle : ERR_PTR ( - EINVAL ) ;}","struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , int id ) {handle = ion_handle_get_by_id_nolock ( client , id ) ;return handle ;}",592
818,"void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) {bloc = * offset ;send ( huff -> loc [ ch ] , NULL , fout ) ;* offset = bloc ;","void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset , int maxoffset ) {bloc = * offset ;send ( huff -> loc [ ch ] , NULL , fout , maxoffset ) ;* offset = bloc ;",593
819,"int i , j , offset ;uint8_t type ;","int i , offset ;uint8_t type ;",594
820,"u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ;if ( suf < 0x0200 ) {map -> s_partition_type = UDF_VIRTUAL_MAP15 ;map -> s_partition_func = udf_get_pblock_virt15 ;}else {map -> s_partition_type = UDF_VIRTUAL_MAP20 ;map -> s_partition_func = udf_get_pblock_virt20 ;}}else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) {uint32_t loc ;struct sparingTable * st ;struct sparablePartitionMap * spm =  ( struct sparablePartitionMap * ) gpm ;","if ( udf_load_sparable_map ( sb , map , ( struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ;",594
821,},( void ) _y4m ;( void ) _dst ;( void ) _aux ;},595
822,"struct mb_cache_entry * ce ;down_write ( & EXT2_I ( inode ) -> xattr_sem ) ;ea_bdebug ( bh , ""b_count=%d"" , atomic_read ( & ( bh -> b_count ) ) ) ;if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) {ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ;goto cleanup ;}ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ;lock_buffer ( bh ) ;if ( ce )  mb_cache_entry_free ( ce ) ;le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ;if ( ce ) mb_cache_entry_release ( ce ) ;","down_write ( & EXT2_I ( inode ) -> xattr_sem ) ;lock_buffer ( bh ) ;if ( ce ) mb_cache_entry_free ( ce ) ;le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ;if ( ce ) mb_cache_entry_release ( ce ) ;",596
823,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},597
824,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,597
825,int m ;m = n ;,"int m ;if ( n < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ;}m = n ;",598
826,out :  kfree ( resp ) ;return res ;,out : kfree ( req ) ;kfree ( resp ) ;return res ;,599
827,"char buf [ MAX_PKT_SIZE ] ;memset ( buf , 0 , sizeof ( buf ) ) ;len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ;if ( len > 0 ) {buf [ len ] = 0 ;if ( sa . sa_family != AF_INET ) return ;","char buf [ MAX_PKT_SIZE + 1 ] ;memset ( buf , 0 , sizeof ( buf ) - 1 ) ;len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ;if ( len > 0 ) {if ( sa . sa_family != AF_INET ) return ;",600
828,"unsigned int maxw , maxh , max ;int offset , upb ;unsigned int i , j ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;for ( i = 0U ;i < ( maxh & ~ ( unsigned int ) 1U ) ;i += 2U )  {ny = y + maxw ;nr = r + maxw ;for ( j = 0 ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {","size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ;int offset , upb ;size_t i ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;offx = img -> x0 & 1U ;loopmaxw = maxw - offx ;offy = img -> y0 & 1U ;loopmaxh = maxh - offy ;if ( offy > 0U ) {size_t j ;for ( j = 0 ;j < maxw ;++ j ) {sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ;++ y ;++ r ;++ g ;++ b ;}}for ( i = 0U ;i < ( loopmaxh & ~ ( unsigned int ) 1U ) ;i += 2U ) {ny = y + maxw ;nr = r + maxw ;for ( j = 0 ;j < ( maxw & ~ ( size_t ) 1U ) ;j += 2U ) {size_t j ;",601
829,if ( j < maxw )  {,if ( j < maxw ) {,601
830,if ( i < maxh )  {for ( j = 0U ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {,if ( i < maxh ) {for ( j = 0U ;j < ( loopmaxw & ~ ( unsigned int ) 1U ) ;j += 2U ) {,601
831,if ( j < maxw ) {,if ( j < loopmaxw ) {,601
832,# if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = maxw ;img -> comps [ 2 ] . h = maxh ;# else  img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;# endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;},img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;img -> comps [ 2 ] . h = img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ;img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails : free ( r ) ;if ( g ) free ( g ) ;free ( b ) ;},601
833,if ( * p == '#' ) {p ++ ;,"len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;if ( * p == '#' ) {p ++ ;",602
834,print_bpf_insn ( insn ) ;},"print_bpf_insn ( env , insn ) ;}",603
835,"if ( uid_eq ( uid , current_fsuid ( ) ) )  return true ;if ( gid_eq ( gid , current_fsgid ( ) ) )  return true ;","if ( uid_eq ( uid , file -> f_cred -> fsuid ) ) return true ;if ( gid_eq ( gid , file -> f_cred -> fsgid ) ) return true ;",604
836,return true ;},return nf_generic_should_process ( nf_ct_protonum ( ct ) ) ;},605
837,"im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ;im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ;","if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) {return NULL ;}im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ;im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ;",606
838,"if ( cpi -> pass == 0 ) {if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER )  q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ;if ( q == 0 )  q ++ ;","if ( cpi -> oxcf . rc_mode == VPX_CBR ) q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ;",607
839,"if ( packet -> size + act_size > MT_PACKET_LEN ) {fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\","if ( act_size > MT_PACKET_LEN - packet -> size ) {fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\",608
840,"while ( * s && * s != \\\'\\\\""\\\' )  * ptmp ++ = * s ++ ;","while ( * s && ( * s != \\\'\\\\""\\\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) * ptmp ++ = * s ++ ;",609
841,while ( isdigit ( ( unsigned char ) * s ) )  * ptmp ++ = * s ++ ;,while ( isdigit ( ( unsigned char ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) ) * ptmp ++ = * s ++ ;,609
842,"ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ;",610
843,s -> servername_done = 0 ;s -> tlsext_status_type = - 1 ;,s -> tlsext_use_etm = 0 ;,611
844,s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ;# ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ;,s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ;# ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ;,611
845,"if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 0 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tlsext_debug_arg ) ;if ( type == TLSEXT_TYPE_renegotiate ) {if ( ! ssl_parse_clienthello_renegotiate_ext ( s , & extension , al ) ) return 0 ;renegotiate_seen = 1 ;}else if ( s -> version == SSL3_VERSION ) {}else if ( type == TLSEXT_TYPE_server_name ) {unsigned int servname_type ;PACKET sni , hostname ;if ( ! PACKET_as_length_prefixed_2 ( & extension , & sni ) || PACKET_remaining ( & sni ) == 0 ) {return 0 ;}if ( ! PACKET_get_1 ( & sni , & servname_type ) || servname_type != TLSEXT_NAMETYPE_host_name || ! PACKET_as_length_prefixed_2 ( & sni , & hostname ) ) {return 0 ;}if ( ! s -> hit ) {if ( PACKET_remaining ( & hostname ) > TLSEXT_MAXLEN_host_name ) {* al = TLS1_AD_UNRECOGNIZED_NAME ;return 0 ;}if ( PACKET_contains_zero_byte ( & hostname ) ) {* al = TLS1_AD_UNRECOGNIZED_NAME ;return 0 ;}if ( ! PACKET_strndup ( & hostname , & s -> session -> tlsext_hostname ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}s -> servername_done = 1 ;}else {s -> servername_done = s -> session -> tlsext_hostname && PACKET_equal ( & hostname , s -> session -> tlsext_hostname , strlen ( s -> session -> tlsext_hostname ) ) ;}}# ifndef OPENSSL_NO_SRP else if ( type == TLSEXT_TYPE_srp ) {PACKET srp_I ;if ( ! PACKET_as_length_prefixed_1 ( & extension , & srp_I ) ) return 0 ;if ( PACKET_contains_zero_byte ( & srp_I ) ) return 0 ;if ( ! PACKET_strndup ( & srp_I , & s -> srp_ctx . login ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}}# endif # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) {PACKET ec_point_format_list ;if ( ! PACKET_as_length_prefixed_1 ( & extension , & ec_point_format_list ) || PACKET_remaining ( & ec_point_format_list ) == 0 ) {return 0 ;}if ( ! s -> hit ) {if ( ! PACKET_memdup ( & ec_point_format_list , & s -> session -> tlsext_ecpointformatlist , & s -> session -> tlsext_ecpointformatlist_length ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}}}else if ( type == TLSEXT_TYPE_elliptic_curves ) {PACKET elliptic_curve_list ;if ( ! PACKET_as_length_prefixed_2 ( & extension , & elliptic_curve_list ) || PACKET_remaining ( & elliptic_curve_list ) == 0 || ( PACKET_remaining ( & elliptic_curve_list ) % 2 ) != 0 ) {return 0 ;}if ( ! s -> hit ) {if ( ! PACKET_memdup ( & elliptic_curve_list , & s -> session -> tlsext_ellipticcurvelist , & s -> session -> tlsext_ellipticcurvelist_length ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}}}# endif else if ( type == TLSEXT_TYPE_session_ticket ) {if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tls_session_ticket_ext_cb_arg ) ) {* al = TLS1_AD_INTERNAL_ERROR ;return 0 ;}}else if ( type == TLSEXT_TYPE_signature_algorithms ) {PACKET supported_sig_algs ;if ( ! PACKET_as_length_prefixed_2 ( & extension , & supported_sig_algs ) || ( PACKET_remaining ( & supported_sig_algs ) % 2 ) != 0 || PACKET_remaining ( & supported_sig_algs ) == 0 ) {return 0 ;}if ( ! s -> hit ) {if ( ! tls1_save_sigalgs ( s , PACKET_data ( & supported_sig_algs ) , PACKET_remaining ( & supported_sig_algs ) ) ) {return 0 ;}}}else if ( type == TLSEXT_TYPE_status_request ) {if ( ! PACKET_get_1 ( & extension , ( unsigned int * ) & s -> tlsext_status_type ) ) {return 0 ;}# ifndef OPENSSL_NO_OCSP if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp ) {const unsigned char * ext_data ;PACKET responder_id_list , exts ;if ( ! PACKET_get_length_prefixed_2 ( & extension , & responder_id_list ) ) return 0 ;sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ;if ( PACKET_remaining ( & responder_id_list ) > 0 ) {s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ;if ( s -> tlsext_ocsp_ids == NULL ) {* al = SSL_AD_INTERNAL_ERROR ;return 0 ;}}else {s -> tlsext_ocsp_ids = NULL ;}while ( PACKET_remaining ( & responder_id_list ) > 0 ) {OCSP_RESPID * id ;PACKET responder_id ;const unsigned char * id_data ;if ( ! PACKET_get_length_prefixed_2 ( & responder_id_list , & responder_id ) || PACKET_remaining ( & responder_id ) == 0 ) {return 0 ;}id_data = PACKET_data ( & responder_id ) ;id = d2i_OCSP_RESPID ( NULL , & id_data , PACKET_remaining ( & responder_id ) ) ;if ( id == NULL ) return 0 ;if ( id_data != PACKET_end ( & responder_id ) ) {OCSP_RESPID_free ( id ) ;return 0 ;}if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) ) {OCSP_RESPID_free ( id ) ;* al = SSL_AD_INTERNAL_ERROR ;return 0 ;}}if ( ! PACKET_as_length_prefixed_2 ( & extension , & exts ) ) return 0 ;if ( PACKET_remaining ( & exts ) > 0 ) {ext_data = PACKET_data ( & exts ) ;sk_X509_EXTENSION_pop_free ( s -> tlsext_ocsp_exts , X509_EXTENSION_free ) ;s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & ext_data , PACKET_remaining ( & exts ) ) ;if ( s -> tlsext_ocsp_exts == NULL || ext_data != PACKET_end ( & exts ) ) {return 0 ;}}}else # endif {s -> tlsext_status_type = - 1 ;}}# ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) {unsigned int hbtype ;if ( ! PACKET_get_1 ( & extension , & hbtype ) || PACKET_remaining ( & extension ) ) {* al = SSL_AD_DECODE_ERROR ;return 0 ;}switch ( hbtype ) {case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ;break ;case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ;s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ;break ;default : * al = SSL_AD_ILLEGAL_PARAMETER ;return 0 ;}}# endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) {s -> s3 -> next_proto_neg_seen = 1 ;}# endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation && s -> s3 -> tmp . finish_md_len == 0 ) {if ( ! tls1_alpn_handle_client_hello ( s , & extension , al ) ) return 0 ;}# ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) && type == TLSEXT_TYPE_use_srtp ) {if ( ssl_parse_clienthello_use_srtp_ext ( s , & extension , al ) ) return 0 ;}# endif else if ( type == TLSEXT_TYPE_encrypt_then_mac )  s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ;else if ( ! s -> hit ) {",if ( s -> tlsext_debug_cb ) s -> tlsext_use_etm = 1 ;else if ( ! s -> hit ) {,611
846,int cpu = smp_processor_id ( ) ;do {},int cpu = smp_processor_id ( ) ;read_lock ( & evtchn_rwlock ) ;do {read_unlock ( & evtchn_rwlock ) ;},612
847,const char * path = conn -> data -> state . path ;int len ;,const char * path = conn -> data -> state . path ;,613
848,"smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ;if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ;","result = Curl_urldecode ( conn -> data , path , 0 , & smtpc -> domain , NULL , TRUE ) ;if ( result ) return result ;",613
849,while ( ! * ( iter -> substr_cur ) )  iter -> substr_cur ++ ;else * ( iter -> substr_end ) = '\\\\0' ;,else * ( iter -> substr_end ++ ) = '\\\\0' ;,614
850,"const struct aodv_hello * ah ;switch ( ep -> type ) {if ( length < sizeof ( struct aodv_hello ) )  goto trunc ;ND_PRINT ( ( ndo , ""\\\","const struct aodv_hello * ah ;ND_TCHECK ( * ep ) ;switch ( ep -> type ) {if ( length < sizeof ( struct aodv_hello ) ) goto trunc ;if ( ep -> length < 4 ) {ND_PRINT ( ( ndo , ""\\\break ;}ND_PRINT ( ( ndo , ""\\\",615
851,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;line_step = frame -> linesize [ plane ] ;,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ;line_step = frame -> linesize [ plane ] ;,616
852,"
","if ( daemon_mode == TRUE && sigrestart == FALSE ) {result = daemon_init ( ) ;if ( result == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ;cleanup ( ) ;exit ( EXIT_FAILURE ) ;}nagios_pid = ( int ) getpid ( ) ;}",617
853,"if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ;","if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ;",617
854,exit ( EXIT_FAILURE ) ;},exit ( EXIT_FAILURE ) ;},617
855,"if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ;if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ;if ( ( ( int ) arg >= cdi -> capacity ) )  return - EINVAL ;",if ( arg >= cdi -> capacity ) ) return - EINVAL ;,618
856,rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) /  ( cm -> width * cm -> height ) ;,if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / ( cm -> width * cm -> height ) ;,619
857,else # endif  for ( i = 0 ;i <= w - sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,else # endif for ( i = 0 ;i <= w - ( int ) sizeof ( long ) ;long a = * ( long * ) ( src1 + i ) ;,620
858,"if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) {log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\\","if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) {if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ;ret = fdt_check_full ( fit , size ) ;if ( ret ) {log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\\return - EINVAL ;}}if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) {log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\\",621
859,"dwc3_gadget_giveback ( dep , req , ret ) ;return ret ;","dwc3_gadget_del_and_unmap_request ( dep , req , ret ) ;return ret ;",622
860,"
","if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;",623
861,"return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ;}","return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ;}",623
862,if ( flags & MSG_OOB )  return - EOPNOTSUPP ;msg -> msg_namelen = 0 ;,if ( flags & MSG_OOB ) return - EOPNOTSUPP ;,624
863,if ( rs -> rs_bound_addr == 0 ) {ret = - ENOTCONN ;,if ( rs -> rs_bound_addr == 0 || ! rs -> rs_transport ) {ret = - ENOTCONN ;,625
864,"iwl_sta_ucode_activate ( priv , sta_id ) ;ret = 0 ;","ret = iwl_sta_ucode_activate ( priv , sta_id ) ;",626
865,"if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 &&  unconditional ( & e -> ipv6 ) ) || visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",627
866,if ( ! chan ) {err = - EINVAL ;goto out_free ;}if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ;request -> channels [ i ] = chan ;,request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;,628
867,"nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) {if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;","nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) {if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;",628
868,"static void  sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) {newspan -> _next = before ;}","static void sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) {if ( newspan && before ) {newspan -> _next = before ;}}",629
869,int just_opened = 0 ;restart : if ( ! v -> needed ) return AVERROR_EOF ;,int just_opened = 0 ;int reload_count = 0 ;restart : if ( ! v -> needed ) return AVERROR_EOF ;,630
870,reload :  if ( ! v -> finished &&  av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) {,reload : reload_count ++ ;if ( reload_count > c -> max_reload ) return AVERROR_EOF ;if ( ! v -> finished && av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) {,630
871,"spin_lock_init ( & sta -> lock ) ;INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ;","spin_lock_init ( & sta -> lock ) ;spin_lock_init ( & sta -> ps_lock ) ;INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ;",631
872,out_size = in_len + 32 ;out_buf = flb_malloc ( out_size ) ;,int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ;out_size = 10 + 8 + max_input_expansion + in_len ;out_buf = flb_malloc ( out_size ) ;,632
873,cmap_len = get_ushort ( & tga [ 5 ] ) ;cmap_entry_size = tga [ 7 ] ;# if 0  x_origin = get_ushort ( & tga [ 8 ] ) ;y_origin = get_ushort ( & tga [ 10 ] ) ;# endif  image_w = get_ushort ( & tga [ 12 ] ) ;image_h = get_ushort ( & tga [ 14 ] ) ;pixel_depth = tga [ 16 ] ;,cmap_len = get_tga_ushort ( & tga [ 5 ] ) ;cmap_entry_size = tga [ 7 ] ;# if 0 x_origin = get_tga_ushort ( & tga [ 8 ] ) ;y_origin = get_tga_ushort ( & tga [ 10 ] ) ;# endif image_w = get_tga_ushort ( & tga [ 12 ] ) ;image_h = get_tga_ushort ( & tga [ 14 ] ) ;pixel_depth = tga [ 16 ] ;,633
874,"return ( ( Image * ) NULL ) ;}iris_info . magic = ReadBlobMSBShort ( image ) ;do {if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ;switch ( iris_info . storage ) {case 0x00 : image -> compression = NoCompression ;break ;case 0x01 : image -> compression = RLECompression ;break ;default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ;if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . dimension = ReadBlobMSBShort ( image ) ;iris_info . columns = ReadBlobMSBShort ( image ) ;iris_info . rows = ReadBlobMSBShort ( image ) ;iris_info . depth = ReadBlobMSBShort ( image ) ;if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;iris_info . minimum_value = ReadBlobMSBLong ( image ) ;iris_info . maximum_value = ReadBlobMSBLong ( image ) ;iris_info . sans = ReadBlobMSBLong ( image ) ;( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * )   iris_info . name ) ;iris_info . name [ sizeof ( iris_info . name ) - 1 ] = \'\\\\0\' ;( void ) count ;image -> columns = iris_info . columns ;","count = ReadBlob ( image , sizeof ( iris_info . name ) ;if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) , ( unsigned char * ) iris_info . name ) ;iris_info . name [ sizeof ( iris_info . name ) - 1 ] = \'\\\\0\' ;( void ) count ;image -> columns = iris_info . columns ;",634
875,"if ( EOFBlob ( image ) != MagickFalse )  ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",634
876,"if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ;SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ;SetPixelAlpha ( image , OpaqueAlpha , q ) ;if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ;p += 4 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( bytes_per_pixel == 2 ) {for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {quantum = ( * p << 8 ) ;quantum |= ( * ( p + 1 ) ) ;SetPixelIndex ( image , ( Quantum ) quantum , q ) ;p += 8 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelIndex ( image , * p , q ) ;p += 4 ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}( void ) SyncImage ( image , exception ) ;}pixel_info = RelinquishVirtualMemory ( pixel_info ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",if ( ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;,634
877,"if ( key_is_instantiated ( key ) )  seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ;","if ( key_is_positive ( key ) ) seq_printf ( m , "":<S2SV_blank>%zu<S2SV_blank>[%s]"" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff"" ) ;",635
878,"if ( context -> resynch ) {entry = & entries [ 0 ] ;for ( i = 0 ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) {if ( cursor -> offset == context -> dupcnt ) {context -> dupcnt = 0 ;break ;}context -> dupcnt ++ ;}else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) {context -> dupcnt = 0 ;break ;}}if ( i == ichdr . count ) {trace_xfs_attr_list_notfound ( context ) ;return 0 ;}}else {entry = & entries [ 0 ] ;i = 0 ;}context -> resynch = 0 ;retval = 0 ;for ( ;i < ichdr . count ;entry ++ , i ++ ) {if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) {cursor -> hashval = be32_to_cpu ( entry -> hashval ) ;cursor -> offset = 0 ;}if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ;if ( entry -> flags & XFS_ATTR_LOCAL ) {xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ;retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;","if ( ! retval ) retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ;",636
879,if ( retval )  return retval ;,if ( retval ) return retval ;,636
880,"cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ;vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ;","memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ;",637
881,"if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 )  return 1 ;","if ( th -> fin ) goto discard ;if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) return 1 ;",638
882,u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;if ( insn_bitness == 32 ) {,u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;u32 dst = insn -> dst_reg ;int ret ;if ( insn_bitness == 32 ) {,639
883,"case BPF_ADD :  if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) ||  signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {","case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\return ret ;}if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {",639
884,"case BPF_SUB :  if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) ||  signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {","case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\return ret ;}if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {",639
885,"static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ ] = {0x51 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config ,   & d -> dev -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL )  return - EIO ;if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe ,  & dw2104_ts2020_config ,  & d -> dev -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;","static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;mutex_unlock ( & d -> data_mutex ) ;adap -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , & d -> i2c_adap ) ;if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ;if ( adap -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> i2c_adap ) ) {info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ;",640
886,if ( ! vcpu -> arch . time_page )  return - EINVAL ;,if ( ! vcpu -> arch . pv_time_enabled ) return - EINVAL ;,641
887,default :  errno = EINVAL ;,case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ;return 0 ;default : errno = EINVAL ;,642
888,"ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;","ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;",643
889,"case BPF_TYPE_PROG :  atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ;break ;case BPF_TYPE_MAP :  bpf_map_inc ( raw , true ) ;break ;","case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw ) ;break ;case BPF_TYPE_MAP : raw = bpf_map_inc ( raw , true ) ;break ;",644
890,signed long personality ;if ( ! options ) options = & attach_static_default_options ;,int procfd ;signed long personality ;if ( ! options ) options = & attach_static_default_options ;,645
891,"
","procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ;shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ;rexit ( - 1 ) ;}",645
892,"ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ;if ( ret < 0 ) {","ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ;if ( ret < 0 ) {",645
893,". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function ,  . exec_payload = exec_payload  }",". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload , . procfd = procfd }",645
894,"timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) {","m -> msg_namelen = 0 ;timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) {",646
895,"if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\\","if ( * rsize >= 31 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\\",647
896,"pfn = kvm_pin_pages ( slot , gfn , page_size ) ;if ( is_error_noslot_pfn ( pfn ) ) {kvm_unpin_pages ( kvm , pfn , page_size ) ;goto unmap_pages ;","pfn = kvm_pin_pages ( slot , gfn , page_size >> PAGE_SHIFT ) ;if ( is_error_noslot_pfn ( pfn ) ) {kvm_unpin_pages ( kvm , pfn , page_size >> PAGE_SHIFT ) ;goto unmap_pages ;",648
897,if ( skb_is_nonlinear ( skb ) )  return 0 ;,if ( skb_is_nonlinear ( skb ) ) return 0 ;if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ;,649
898,int is_udplite = IS_UDPLITE ( sk ) ;int is_udp4 ;,bool checksum_valid = false ;int is_udplite = IS_UDPLITE ( sk ) ;int is_udp4 ;,650
899,"if ( udp_lib_checksum_complete ( skb ) )  goto csum_copy_err ;if ( skb_csum_unnecessary ( skb ) )  err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;","checksum_valid = ! udp_lib_checksum_complete ( skb ) ;if ( ! checksum_valid ) goto csum_copy_err ;if ( checksum_valid || skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;",650
900,"Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ;","if ( length > INT_MAX ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ;RETURN_FALSE ;}Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ;",651
901,"jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len )  {","jas_iccprof_t * jas_iccprof_createfrombuf ( jas_uchar * buf , int len ) {",652
902,return ret != - EEXIST ? ret : 0 ;},return ret ;},653
903,TfLiteIntArray * ret =   ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ;ret -> size = size ;,int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ;if ( alloc_size <= 0 ) return NULL ;TfLiteIntArray * ret = ( TfLiteIntArray * ) malloc ( alloc_size ) ;if ( ! ret ) return ret ;ret -> size = size ;,654
904,"struct gs_host_config hconf = {. byte_order = 0x0000beef , };struct gs_device_config dconf ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber ,  & hconf ,   sizeof ( hconf ) ,  1000 ) ;if ( rc < 0 ) {dev_err ( & intf -> dev , ""Couldn\\\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\\}rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber ,  & dconf ,   sizeof ( dconf ) ,  1000 ) ;return rc ;}icount = dconf . icount + 1 ;return - EINVAL ;}if ( ! dev )  return - ENOMEM ;init_usb_anchor ( & dev -> rx_submitted ) ;atomic_set ( & dev -> active_channels , 0 ) ;dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ;if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) {kfree ( dev ) ;return rc ;return 0 ;}","struct gs_host_config * hconf ;struct gs_device_config dconf ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , hconf , sizeof ( * hconf ) , 1000 ) ;kfree ( hconf ) ;if ( rc < 0 ) {dev_err ( & intf -> dev , ""Couldn\\\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\\}dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ;if ( ! dconf ) return - ENOMEM ;rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , dconf , sizeof ( * dconf ) , 1000 ) ;kfree ( dconf ) ;return rc ;}icount = dconf -> icount + 1 ;kfree ( dconf ) ;return - EINVAL ;}if ( ! dev ) {kfree ( dconf ) ;return - ENOMEM ;}init_usb_anchor ( & dev -> rx_submitted ) ;atomic_set ( & dev -> active_channels , 0 ) ;dev -> canch [ i ] = gs_make_candev ( i , intf , dconf ) ;if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) {kfree ( dconf ) ;kfree ( dev ) ;return rc ;kfree ( dconf ) ;return 0 ;}",655
905,case 0x00 :  p += 2 ;n += 2 ;case 0x40 :  p += 3 ;n += 3 ;case 0x80 :  p += 4 ;n += 4 ;case 0xC0 :  l = p [ 1 ] ;if ( l < 10 || l > 20 ) return - 1 ;,case 0x00 : if ( len < 2 ) return - 1 ;p += 2 ;n += 2 ;case 0x40 : if ( len < 3 ) return - 1 ;p += 3 ;n += 3 ;case 0x80 : if ( len < 4 ) return - 1 ;p += 4 ;n += 4 ;case 0xC0 : if ( len < 2 ) return - 1 ;l = p [ 1 ] ;if ( l < 10 || l > 20 ) return - 1 ;,656
906,"utee_param_to_param ( param , callee_params ) ;}","res = utee_param_to_param ( utc , param , callee_params ) ;if ( res != TEE_SUCCESS ) return res ;}",657
907,if ( image -> storage_class == PseudoClass )  {,"status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( image -> storage_class == PseudoClass ) {",658
908,"vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;","vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ;vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;",659
909,"for ( i = 0 ;i <= SERDES_MAX ;ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ;","for ( i = 0 ;i < SERDES_MAX ;ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ;",660
910,break ;},* objp = NULL ;break ;},661
911,else   iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ;if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) {,else {dst = skb_dst ( skb ) ;iif = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ;}if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) {,662
912,"static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags ,  const char * data , int optional )  {# endif  if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) {if ( optional ) {","static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , const char * data , int optional , const char * rootfs ) {# endif if ( safe_mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data , rootfs ) ) {if ( optional ) {",663
913,"# endif if ( mount ( fsname , target , fstype ,  mountflags | MS_REMOUNT , data ) ) {if ( optional ) {","# endif if ( mount ( fsname , target , fstype , mountflags | MS_REMOUNT , data ) < 0 ) {if ( optional ) {",663
914,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return simulate_ll ( regs , opcode ) ;perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;return simulate_sc ( regs , opcode ) ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return simulate_ll ( regs , opcode ) ;perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;return simulate_sc ( regs , opcode ) ;",664
915,cleanup_free char * base_path = NULL ;int clone_flags ;,const char * base_path = NULL ;int clone_flags ;,665
916,"base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ;if ( ensure_dir ( base_path , 0755 ) ) {free ( base_path ) ;base_path = xasprintf ( ""/tmp/.bubblewrap-%d"" , real_uid ) ;if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( ""Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed"" ) ;}","base_path = ""/tmp"" ;",665
917,"void vp9_fht4x4_c ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {vp9_fdct4x4_c ( input , output , stride ) ;}int16_t out [ 4 * 4 ] ;int16_t * outptr = & out [ 0 ] ;int i , j ;int16_t temp_in [ 4 ] , temp_out [ 4 ] ;const transform_2d ht = FHT_4 [ tx_type ] ;++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ;++ j )  outptr [ j * 4 + i ] = temp_out [ j ] ;}","void vp9_fht4x4_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {vpx_fdct4x4_c ( input , output , stride ) ;}tran_low_t out [ 4 * 4 ] ;int i , j ;int16_t temp_in [ 4 ] , temp_out [ 4 ] ;const transform_2d ht = FHT_4 [ tx_type ] ;+ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ;++ j ) out [ j * stride + i ] * 16 ;+ j )  outptr [ j * 4 + i ] = temp_out [ j ] ;++ j ) outptr [ j * 4 + i ] = temp_out [ j ] ;}",666
918,"static const char * parse_array ( cJSON * item , const char * value )  {ep = value ;return 0 ;if ( * value == ']' )  return value + 1 ;if ( ! ( item -> child = child = cJSON_New_Item ( ) ) )  return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) )  return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ;child -> next = new_item ;new_item -> prev = child ;child = new_item ;if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) )  return 0 ;if ( * value == ']' )  return value + 1 ;ep = value ;","static const char * parse_array ( cJSON * item , const char * value , const char * * ep ) {* ep = value ;return 0 ;if ( * value == ']' ) return value + 1 ;item -> child = child = cJSON_New_Item ( ) ) ) return 0 ;if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) return 0 ;if ( ! ( new_item = cJSON_New_Item ( ) ;if ( ! item -> child ) return 0 ;value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) return 0 ;if ( * value == ']' ) return value + 1 ;* ep = value ;",667
919,"int yy , mm , dd , hr , min , sec , csec ;guint pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line ,  ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;","int yy , mm , dd , hr , min , sec , csec , pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;",668
920,"num_items_scanned = sscanf ( line ,  ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}","num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;}",668
921,const char * args [ 11 ] ;{,"char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ;if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ;log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ;const char * args [ 13 ] ;{args [ i ++ ] = ""--tmpdir"" ;args [ i ++ ] = tmp_directory ;",669
922,"args [ i ++ ] = ""--"" ;args [ i ] = NULL ;","args [ i ++ ] = ""--"" ;args [ i ] = NULL ;",669
923,"
","pid_t pid = fork ( ) ;if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ;if ( pid == 0 ) {",669
924,"execvp ( EXECUTABLE , ( char * * ) args ) ;error_msg_and_die ( ""Can\\\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;}","int status ;if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ;if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ;else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ;if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ;if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ;error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ;}execvp ( EXECUTABLE , ( char * * ) args ) ;error_msg_and_die ( ""Can\\\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ;}",669
925,kern_msg -> msg_name = kern_address ;},if ( kern_msg -> msg_name ) kern_msg -> msg_name = kern_address ;},670
926,},"id_key_set = rb_intern_const ( ""key_set"" ) ;}",671
927,"if ( ! strcmp ( page , ""/styles.css"" ) ) {",if ( ! page_name_is_good ( page ) ) {,672
928,"if ( strchr ( page , \'/\' ) )  {","if ( strchr ( page , \'/\' ) ) {",672
929,"int do_rf64 = 0 , write_junk = 1 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;JunkChunk junkchunk ;","int do_rf64 = 0 , write_junk = 1 , table_length = 0 ;ChunkHeader ds64hdr , datahdr , fmthdr ;DS64Chunk ds64_chunk ;CS64Chunk cs64_chunk ;JunkChunk junkchunk ;",673
930,"if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;","total_riff_bytes += table_length * sizeof ( CS64Chunk ) ;if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ;strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ;",673
931,ds64hdr . ckSize = sizeof ( ds64_chunk ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;riffhdr . ckSize = ( uint32_t ) - 1 ;,ds64hdr . ckSize = sizeof ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) ;CLEAR ( ds64_chunk ) ;ds64_chunk . sampleCount64 = total_samples ;ds64_chunk . tableLength = table_length ;riffhdr . ckSize = ( uint32_t ) - 1 ;,673
932,"WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ||  ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) ||  ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {","if ( table_length ) {strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ;cs64_chunk . chunkSize64 = 12345678 ;WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ;}WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ;WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ;if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) {error_line ( ""can\\\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ;return FALSE ;}if ( ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) {",673
933,pipe -> curbuf = 0 ;kfree ( pipe -> bufs ) ;,"account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;pipe -> curbuf = 0 ;kfree ( pipe -> bufs ) ;",674
934,"cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ;cli_writeint32 ( & exe [ pe + 0x50 ] , cli_readint32 ( & exe [ pe + 0x50 ] ) - sects [ scount ] . vsz ) ;","if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) {cli_dbgmsg ( ""WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\\return CL_EFORMAT ;}cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ;cli_writeint32 ( & exe [ pe + 0x50 ] , cli_readint32 ( & exe [ pe + 0x50 ] ) - sects [ scount ] . vsz ) ;",675
935,if ( shdr -> sh_size < 1 ) {return false ;,if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return false ;,676
936,"int ret = - 1 ;s = ECDSA_SIG_new ( ) ;if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ;ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;err :  ECDSA_SIG_free ( s ) ;return ( ret ) ;","const unsigned char * p = sigbuf ;unsigned char * der = NULL ;int derlen = - 1 ;int ret = - 1 ;s = ECDSA_SIG_new ( ) ;if ( d2i_ECDSA_SIG ( & s , & p , sig_len ) == NULL ) goto err ;derlen = i2d_ECDSA_SIG ( s , & der ) ;if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) goto err ;ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;err : if ( derlen > 0 ) {OPENSSL_cleanse ( der , derlen ) ;OPENSSL_free ( der ) ;}ECDSA_SIG_free ( s ) ;return ( ret ) ;",677
937,NAPI_GRO_CB ( skb ) -> same_flow = 0 ;NAPI_GRO_CB ( skb ) -> udp_mark = 0 ;NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;,NAPI_GRO_CB ( skb ) -> encap_mark = 0 ;NAPI_GRO_CB ( skb ) -> udp_mark = 0 ;NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ;,678
938,"struct mb_cache_entry * ce = NULL ;int error = 0 ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;# define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ;ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev ,  bs -> bh -> b_blocknr ) ;if ( ce ) {mb_cache_entry_free ( ce ) ;ce = NULL ;}}unlock_buffer ( bs -> bh ) ;if ( error == - EFSCORRUPTED ) goto bad_block ;if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ;if ( error ) goto cleanup ;goto inserted ;}else {int offset = ( char * ) s -> here - bs -> bh -> b_data ;unlock_buffer ( bs -> bh ) ;if ( ce ) {mb_cache_entry_release ( ce ) ;ce = NULL ;}","struct mb2_cache_entry * ce = NULL ;int error = 0 ;struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;# define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ;__u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ;mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ;",679
939,"le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""reusing;mb_cache_entry_release ( ce ) ;ce = NULL ;","if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) {unlock_buffer ( new_bh ) ;dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ;brelse ( new_bh ) ;mb2_cache_entry_put ( ext4_mb_cache , ce ) ;ce = NULL ;new_bh = NULL ;goto inserted ;}le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ;ea_bdebug ( new_bh , ""reusing;mb2_cache_entry_touch ( ext4_mb_cache , ce ) ;mb2_cache_entry_put ( ext4_mb_cache , ce ) ;ce = NULL ;",679
940,cleanup : if ( ce )  mb_cache_entry_release ( ce ) ;brelse ( new_bh ) ;,"cleanup : if ( ce ) mb2_cache_entry_put ( ext4_mb_cache , ce ) ;brelse ( new_bh ) ;",679
941,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\",680
942,"static void oidc_scrub_headers ( request_rec * r ) {oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ;","void oidc_scrub_headers ( request_rec * r ) {oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ;",681
943,"readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ;if ( readBytes < 0 ) goto exit_closed ;","if ( self -> packetSize <= bufPos ) goto exit_error ;readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ;if ( readBytes < 0 ) goto exit_closed ;",682
944,size_t e ;if ( c -> stack == NULL ) return ;,size_t e ;mrb_value nil ;if ( c -> stack == NULL ) return ;,683
945,if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) {c -> stbase [ i ] = mrb_nil_value ( ) ;}else {}},e = c -> stend - c -> stbase ;nil = mrb_nil_value ( ) ;for ( ;i < e ;i ++ ) {c -> stbase [ i ] = nil ;}},683
946,"if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  return - ENOKEY ;",if ( key_is_negative ( key ) ) return - ENOKEY ;,684
947,if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;,if ( ! new_buffer ) {pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,685
948,if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;,if ( ! new_buffer ) {pc -> overread_index = pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,685
949,"private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h ,  const cdf_stream_t * sst , const uint64_t clsid [ 2 ] )  {","private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , const cdf_stream_t * sst , const cdf_directory_t * root_storage ) {",686
950,"str = cdf_clsid_to_mime ( clsid , clsid2desc ) ;if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 )  return - 2 ;}m = cdf_file_property_info ( ms , info , count , clsid ) ;free ( info ) ;","if ( root_storage ) {str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid , clsid2desc ) ;if ( str ) if ( file_printf ( ms , "",<S2SV_blank>%s"" , str ) == - 1 ) return - 2 ;}}m = cdf_file_property_info ( ms , info , count , root_storage ) ;free ( info ) ;",686
951,op -> regs [ reg_index ] = reg ;op -> scale [ reg_index ] = temp ;++ reg_index ;}op -> offset += temp ;op -> regs [ reg_index ] = X86R_UNDEFINED ;},+ reg_index ;if ( reg_index < 2 ) {op -> regs [ reg_index ] = reg ;op -> scale [ reg_index ] = temp ;}++ reg_index ;}op -> offset += temp ;if ( reg_index < 2 ) {op -> regs [ reg_index ] = X86R_UNDEFINED ;}},687
952,"gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc ,   & pdev -> dev , gpio_dev ) ;if ( IS_ERR ( gpio_dev -> pctrl ) ) {if ( ret )  goto out1 ;ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;","gpio_dev -> pctrl = devm_pinctrl_register ( & pdev -> dev , & amd_pinctrl_desc , gpio_dev ) ;if ( IS_ERR ( gpio_dev -> pctrl ) ) {if ( ret ) return ret ;ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ;",688
953,out1 :  pinctrl_unregister ( gpio_dev -> pctrl ) ;,"
",688
954,"decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ;decoder_info -> pb_split = get_flc ( 1 , stream ) ;","decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ;decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE ) ) ;decoder_info -> pb_split = get_flc ( 1 , stream ) ;",689
955,int is_udplite = IS_UDPLITE ( sk ) ;bool slow ;,bool checksum_valid = false ;int is_udplite = IS_UDPLITE ( sk ) ;bool slow ;,690
956,"if ( udp_lib_checksum_complete ( skb ) )  goto csum_copy_err ;if ( skb_csum_unnecessary ( skb ) )  err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;","checksum_valid = ! udp_lib_checksum_complete ( skb ) ;if ( ! checksum_valid ) goto csum_copy_err ;if ( checksum_valid || skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;",690
957,"int ret , last_pwd ;krb5_boolean have_pol = FALSE ;","int ret , last_pwd , n_new_keys ;krb5_boolean have_pol = FALSE ;",691
958,"if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) {if ( keepold ) return KADM5_PROTECT_PRINCIPAL ;new_n_ks_tuple = 1 ;}ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ;if ( ret ) goto done ;ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ;if ( ret ) goto done ;ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;if ( ret ) goto done ;kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ;ret = krb5_timeofday ( handle -> context , & now ) ;if ( ret ) goto done ;if ( ( adb . aux_attributes & KADM5_POLICY ) ) {ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ;if ( ret ) goto done ;}if ( have_pol ) {ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ;if ( ret ) goto done ;# if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) {ret = KADM5_PASS_TOOSOON ;goto done ;}# endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ;else kdb -> pw_expiration = 0 ;}else {kdb -> pw_expiration = 0 ;}ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ;if ( ret ) goto done ;kdb -> fail_auth_count = 0 ;if ( keyblocks ) {ret = decrypt_key_data ( handle -> context ,   kdb -> n_key_data , kdb -> key_data ,  keyblocks , n_keys ) ;","if ( krb5_principal_compare ( handle -> context , n_new_keys , kdb -> key_data ) ;ret = decrypt_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data , keyblocks , n_keys ) ;",691
959,"int isopen ;char * s ;size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ;poly = ( POLYGON * ) palloc0 ( size ) ;","int base_size ;int isopen ;char * s ;base_size = sizeof ( poly -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) ;poly = ( POLYGON * ) palloc0 ( size ) ;",692
960,"ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;","ND_TCHECK_32BITS ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",693
961,# if CONFIG_MULTIPLE_ARF  if ( ! cpi -> multi_arf_enabled ) # endif rc -> source_alt_ref_pending = 0 ;,rc -> source_alt_ref_pending = 0 ;,694
962,while ( ( u64 ) len > s ) {,while ( ( u64 ) len - s > s ) {,695
963,"_iov -> iov_len = min ( ( u64 ) len , size ) ;_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ;","_iov -> iov_len = min ( ( u64 ) len , size ) ;_iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ;",695
964,struct desc_struct * desc ;unsigned long limit ;if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ;desc = get_desc ( sel ) ;if ( ! desc )  return 0 ;limit = get_desc_limit ( desc ) ;if ( desc -> g )  limit = ( limit << 12 ) + 0xfff ;,struct desc_struct desc ;unsigned long limit ;desc = get_desc ( sel ) ;if ( ! desc ) return 0 ;limit = get_desc_limit ( & desc ) ;if ( desc . g ) limit = ( limit << 12 ) + 0xfff ;,696
965,( void ) CloseBlob ( pwp_image ) ;pwp_image = DestroyImage ( pwp_image ) ;,"
",697
966,"if ( buf_len == 0 ) {return ;}s = p = ( const unsigned char * ) buf ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;if ( * p != \'x\' || * ++ p != \':\' ) {goto outexcept ;}++ p ;pcount = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) {goto outexcept ;}-- p ;count = Z_LVAL_P ( pcount ) ;while ( count -- > 0 ) {spl_SplObjectStorageElement * pelement ;zend_string * hash ;if ( * p != \';\' ) {goto outexcept ;}++ p ;if ( * p != \'O\' && * p != \'C\' && * p != \'r\' ) {goto outexcept ;}if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) {goto outexcept ;}if ( Z_TYPE ( entry ) != IS_OBJECT ) {zval_ptr_dtor ( & entry ) ;goto outexcept ;}}ZVAL_UNDEF ( & inf ) ;",+ p ;+ p ;}ZVAL_UNDEF ( & inf ) ;,698
967,"unsigned long tpgt ;int ret ;if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ;if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX )  return ERR_PTR ( - EINVAL ) ;","u16 tpgt ;int ret ;if ( kstrtou16 ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) return ERR_PTR ( - EINVAL ) ;",699
968,"static  void headerMergeLegacySigs ( Header h , Header sigh )  {HeaderIterator hi ;hi = headerInitIterator ( sigh ) ;for ( ;headerNext ( hi , & td ) ;rpmtdFreeData ( & td ) ) {switch ( td . tag ) {case RPMSIGTAG_SIZE :  td . tag = RPMTAG_SIGSIZE ;break ;case RPMSIGTAG_PGP :  td . tag = RPMTAG_SIGPGP ;break ;case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ;break ;case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ;break ;case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ;break ;case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ;break ;case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ;break ;case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ;break ;case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default :  if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) )  continue ;if ( ! headerIsEntry ( h , td . tag ) ) {switch ( td . type ) {","static rpmTagVal headerMergeLegacySigs ( Header h , Header sigh , char * * msg ) {const struct taglate_s * xl ;rpmtdReset ( & td ) ;for ( xl = xlateTags ;xl -> stag ;xl ++ ) {if ( headerIsEntry ( h , xl -> xtag ) ) break ;if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) {if ( xl -> stag != xl -> xtag ) td . tag ) {case RPMSIGTAG_SIZE : td . tag = xl -> xtag ;if ( td . type != rpmTagGetTagType ( td . tag ) ) break ;if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ;if ( xl -> count && td . count != xl -> count ) break ;if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) continue ;if ( ! headerIsEntry ( h , td . tag ) ) {switch ( td . type ) {",700
969,"( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ;}headerFreeIterator ( hi ) ;","( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ) break ;rpmtdFreeData ( & td ) ;}}rpmtdFreeData ( & td ) ;if ( xl -> stag ) {rasprintf ( msg , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ;return xl -> stag ;",700
970,"xmlGenericError ( xmlGenericErrorContext ,  ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\\}","xmlGenericError ( xmlGenericErrorContext , ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\\}if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) {xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ;while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ;return ( - 1 ) ;}",701
971,if ( ! ext4_handle_valid ( handle ) )  return 0 ;,if ( ! EXT4_SB ( sb ) -> s_journal ) return 0 ;,702
972,"ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;","ND_TCHECK2 ( * ext , sizeof ( a ) ) ;UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ;",703
973,"netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ;return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ;","memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ;return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ;",704
974,"if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) )  return 1 ;if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL ||  ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX &&  inode -> i_flock -> fl_type != F_RDLCK ) ) )  return 1 ;",if ( inode -> i_flock == NULL || ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && inode -> i_flock -> fl_type != F_RDLCK ) ) ) return 1 ;,705
975,"static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode ,  struct ext4_ext_path * path )  {struct ext4_extent * ex ;int depth ;ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical""  ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\\","static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path ) {struct ext4_extent * ex ;ext4_lblk_t ee_block ;unsigned int ee_len ;int depth ;ee_block = le32_to_cpu ( ex -> ee_block ) ;ee_len = ext4_ext_get_actual_len ( ex ) ;ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\\if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) {err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ;if ( err < 0 ) goto out ;ext4_ext_drop_refs ( path ) ;path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ;if ( IS_ERR ( path ) ) {err = PTR_ERR ( path ) ;goto out ;}depth = ext_depth ( inode ) ;ex = path [ depth ] . p_ext ;}",706
976,return ret ;},"if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;return ret ;}",707
977,if ( noblock )  return - EAGAIN ;,cond_resched ( ) ;,708
978,"if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;","if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW ) ) == - 1 ) {log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d"" , type , fifo -> name , errno ) ;",709
979,"init_thread :  fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ;","if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;init_thread : fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ;",710
980,"bool valid_handle ;BUG_ON ( client != handle -> client ) ;valid_handle = ion_handle_validate ( client , handle ) ;if ( ! valid_handle ) {return ;}mutex_unlock ( & client -> lock ) ;ion_handle_put ( handle ) ;","BUG_ON ( client != handle -> client ) ;ion_free_nolock ( client , handle ) ;if ( ! valid_handle ) {",711
981,"else umount_tree ( mnt , 0 ) ;}","else umount_tree ( mnt , UMOUNT_CONNECTED ) ;}",712
982,"s -> decode_mb = mpeg4_decode_studio_mb ;decode_smpte_tc ( ctx , gb ) ;","s -> interlaced_dct = 0 ;s -> decode_mb = mpeg4_decode_studio_mb ;decode_smpte_tc ( ctx , gb ) ;",713
983,"k -> get_config ( vdev , vdev -> config ) ;if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ;","if ( addr + sizeof ( val ) > vdev -> config_len ) {return ( uint32_t ) - 1 ;}k -> get_config ( vdev , vdev -> config ) ;",714
984,"static void encode_frame ( vpx_codec_ctx_t * ctx ,  const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline ,  VpxVideoWriter * writer ) {vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) {if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {}","static int encode_frame ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , VpxVideoWriter * writer ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) {got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {return got_pkts ;}",715
985,"static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ,   double this_frame_mv_in_out ) {double frame_boost ;if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min )   frame_boost = ( IIFACTOR * this_frame -> intra_error /   DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;else frame_boost = ( IIFACTOR * cpi -> twopass . gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;return MIN ( frame_boost , GF_RMAX ) ;}","static double calc_frame_boost ( VP9_COMP * cpi , const FIRSTPASS_STATS * this_frame , double this_frame_mv_in_out , double max_boost ) {double frame_boost ;const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ;const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ;int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ;num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ;frame_boost = ( BASELINE_ERR_PER_MB * num_mbs ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ;frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction ;return MIN ( frame_boost , max_boost * boost_q_correction ) ;}",716
986,"static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags )  {if ( open_stateid != NULL )  nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ;write_sequnlock ( & state -> seqlock ) ;update_open_stateflags ( state , open_flags ) ;spin_unlock ( & state -> owner -> so_lock ) ;","static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , fmode_t fmode ) {if ( open_stateid != NULL ) nfs_set_open_stateid_locked ( state , open_stateid , fmode ) ;write_sequnlock ( & state -> seqlock ) ;update_open_stateflags ( state , fmode ) ;spin_unlock ( & state -> owner -> so_lock ) ;",717
987,"ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;if ( gdImageTrueColor ( im ) ) {","if ( input <= 0.0 || output <= 0.0 ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ;RETURN_FALSE ;}ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ;if ( gdImageTrueColor ( im ) ) {",718
988,"q = ( const uint8_t * ) ( const void * )  ( ( const char * ) ( const void * ) p +  CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {","size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;if ( q > e ) {DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\\if ( inp [ i ] . pi_type & CDF_VECTOR ) {",719
989,"char linebuf [ L_BUF_SIZE ] ;l_int32 sy , sx , cy , cx , i , j , version , ignore ;if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL )  return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ;sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ;if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\\","char linebuf [ L_BUFSIZE ] ;l_int32 sy , sx , cy , cx , i , j , version , ignore ;if ( fgets ( linebuf , L_BUFSIZE , fp ) == NULL ) return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ;sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" , selname ) ;if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\\",720
990,struct net_device * dev = vif -> dev ;if ( netif_carrier_ok ( dev ) ) {rtnl_lock ( ) ;if ( netif_running ( dev ) )  xenvif_down ( vif ) ;rtnl_unlock ( ) ;xenvif_put ( vif ) ;},if ( netif_carrier_ok ( dev ) ) {rtnl_lock ( ) ;if ( netif_running ( dev ) ) xenvif_carrier_off ( vif ) ;rtnl_unlock ( ) ;xenvif_put ( vif ) ;,721
991,"static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd ,  const struct in6_addr * dst , const struct in6_addr * src ) {u32 hash , id ;hash = __ipv6_addr_jhash ( dst , hashrnd ) ;hash = __ipv6_addr_jhash ( src , hash ) ;hash ^= net_hash_mix ( net ) ;","static u32 __ipv6_select_ident ( struct net * net , const struct in6_addr * dst , const struct in6_addr * src ) {const struct {struct in6_addr dst ;struct in6_addr src ;}__aligned ( SIPHASH_ALIGNMENT ) combined = {. dst = * dst , . src = * src , };u32 hash , id ;if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) ) ;hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key ) ;",722
992,"err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ;err = - errno ;","err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ;err = - errno ;goto close_sock ;}val = 1 ;ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ;if ( ret == - 1 ) {err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."" ) ;err = - errno ;",723
993,hlist_del ( & pin -> m_list ) ;hlist_del ( & pin -> s_list ) ;spin_unlock ( & pin_lock ) ;,hlist_del_init ( & pin -> m_list ) ;hlist_del_init ( & pin -> s_list ) ;spin_unlock ( & pin_lock ) ;,724
994,MACROBLOCK * x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;int step_param ;int sadpb = x -> sadperbit16 ;int bestsme = INT_MAX ;MV best_ref_mv1 = {,MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ;int step_param ;int sadpb = x -> sadperbit16 ;int bestsme = INT_MAX ;int distortion ;unsigned int sse ;int cost_list [ 5 ] ;MV best_ref_mv1 = {,725
995,"xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ;xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ;if ( cpi -> speed < 8 )  step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ;else step_param = cpi -> sf . reduce_first_step_size + 2 ;step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ;vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 ,  & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ;{int distortion ;","step_param = mv_sf -> reduce_first_step_size ;step_param = MIN ( step_param , MAX_MVSEARCH_STEPS - 2 ) ) ;vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 , cond_cost_list ( cpi , cost_list ) , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ;{int distortion ;",725
996,"packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ;err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ;","if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ;err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ;",726
997,"ses = cifs_find_smb_ses ( server , volume_info -> username ) ;if ( ses ) {","ses = cifs_find_smb_ses ( server , volume_info ) ;if ( ses ) {",727
998,"
",ybf -> uv_crop_width = ( width + 1 ) / 2 ;ybf -> uv_crop_height = ( height + 1 ) / 2 ;,728
999,ybf -> uv_width = uv_width ;ybf -> uv_height = uv_height ;,ybf -> uv_width = uv_width ;ybf -> uv_height = uv_height ;,728
1000,f2fs_wait_discard_bios ( sbi ) ;if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) {,"f2fs_wait_discard_bios ( sbi , true ) ;if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) {",729
1001,s += padlen + 3 ;( * psig ) = s ;return NULL ;,"( * psig ) = s + padlen + 3 ;{const u_char * p ;size_t cnt_ffs = 0 ;for ( p = s + 2 ;p < s + padlen + 2 ;p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ;if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ;}return NULL ;",730
1002,if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) {ctx -> data_offset = 0x170 + ( ctx -> mb_height << 2 ) ;}else {if ( ctx -> mb_height > 68 ||  ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4 ) {ctx -> data_offset = 0x280 ;},if ( ctx -> mb_height > 68 ) {,731
1003,"if ( likely ( port -> exists && ! filtered ) )  serio_interrupt ( serio , data , dfl ) ;","if ( likely ( serio && ! filtered ) ) serio_interrupt ( serio , data , dfl ) ;",732
1004,"reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;","reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ;if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ;",733
1005,"band -> prec = av_malloc_array ( reslevel -> num_precincts_x *  ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;","band -> prec = av_calloc ( reslevel -> num_precincts_x * ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ;",733
1006,out1 :  free_netdev ( net ) ;out : return status ;,out1 : cancel_work_sync ( & dev -> kevent ) ;del_timer_sync ( & dev -> delay ) ;free_netdev ( net ) ;out : return status ;,734
1007,"# ifdef HAVE_INT64_TIMESTAMP  char fstr [ MAXDATELEN + 1 ] ;strncpy ( fstr , ( cp + 1 ) , 7 ) ;strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ;* ( fstr + 6 ) = \'\\\\0\' ;",# ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ;int i ;cp ++ ;for ( i = 0 ;i < 6 ;i ++ ) fstr [ i ] = * cp != \'\\\\0\' ? * cp ++ : \'0\' ;fstr [ i ] = \'\\\\0\' ;,735
1008,ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;return em_pop ( ctxt ) ;,"int rc ;unsigned long eip ;rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ;return em_pop ( ctxt ) ;",736
1009,case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED :  if ( calldata -> arg . open_flags == 0 )  break ;,case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED : if ( calldata -> arg . fmode == 0 ) break ;,737
1010,"found :  if ( prev ) {int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ;if ( i > 0 ) {offset += i ;while ( next && FRAG6_CB ( next ) -> offset < end ) {int i = end - FRAG6_CB ( next ) -> offset ;if ( i < next -> len ) {if ( ! pskb_pull ( next , i ) ) goto err ;FRAG6_CB ( next ) -> offset += i ;fq -> q . meat -= i ;if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ;break ;}else {struct sk_buff * free_it = next ;next = next -> next ;if ( prev ) prev -> next = next ;else fq -> q . fragments = next ;fq -> q . meat -= free_it -> len ;frag_kfree_skb ( fq -> q . net , free_it ) ;}}",found : if ( prev && ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset > 0 ) {offset += i ;while ( next && FRAG6_CB ( next ) -> offset < end ) goto discard_fq ;,738
1011,"err :  IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ;","discard_fq : fq_kill ( fq ) ;err : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ;",738
1012,if ( sbinfo -> max_blocks >= 0 ) {buf -> f_blocks = sbinfo -> max_blocks ;buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ;buf -> f_files = sbinfo -> max_inodes ;,if ( sbinfo -> spool ) {long free_pages ;spin_lock ( & sbinfo -> spool -> lock ) ;buf -> f_blocks = sbinfo -> spool -> max_hpages ;free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages ;buf -> f_bavail = buf -> f_bfree = free_pages ;spin_unlock ( & sbinfo -> spool -> lock ) ;buf -> f_files = sbinfo -> max_inodes ;,739
1013,if ( operand >= MAX_OPERANDS ) {,if ( strlen ( token ) > 4 && operand >= MAX_OPERANDS ) {,740
1014,if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) {op -> operands_count ++ ;,if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) {op -> operands_count ++ ;,740
1015,else {ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ;}ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;if ( u1_slice_type == I_SLICE ) {,if ( u1_slice_type == I_SLICE ) {,741
1016,"vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ;vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ;vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ;for ( j = 1 ;vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ;vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ;vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ;}vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ;vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ;vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ;}","memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ;memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ;memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ;for ( j = 1 ;memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ;memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ;memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ;}memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ;memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ;memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ;}",742
1017,"# line 1661 ""grammar.c"" break ;case 9 : # line 242 ""grammar.y"" {YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( rule == NULL ) ;( yyval . rule ) = rule ;}# line 1674 ""grammar.c"" break ;case 10 : # line 251 ""grammar.y"" {YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ;rule -> tags = ( yyvsp [ - 3 ] . c_string ) ;rule -> metas = ( yyvsp [ - 1 ] . meta ) ;rule -> strings = ( yyvsp [ 0 ] . string ) ;}# line 1686 ""grammar.c"" break ;case 11 : # line 259 ""grammar.y"" {YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ;compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ;yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 1701 ""grammar.c"" break ;case 12 : # line 274 ""grammar.y"" {( yyval . meta ) = NULL ;}# line 1709 ""grammar.c"" break ;case 13 : # line 278 ""grammar.y"" {YR_META null_meta ;memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ;null_meta . type = META_TYPE_NULL ;compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ;( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 1736 ""grammar.c"" break ;case 14 : # line 305 ""grammar.y"" {( yyval . string ) = NULL ;}# line 1744 ""grammar.c"" break ;case 15 : # line 309 ""grammar.y"" {YR_STRING null_string ;memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ;null_string . g_flags = STRING_GFLAGS_NULL ;compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . string ) = ( yyvsp [ 0 ] . string ) ;}# line 1771 ""grammar.c"" break ;case 17 : # line 340 ""grammar.y"" {( yyval . integer ) = 0 ;}# line 1777 ""grammar.c"" break ;case 18 : # line 341 ""grammar.y"" {( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ;}# line 1783 ""grammar.c"" break ;case 19 : # line 346 ""grammar.y"" {( yyval . integer ) = RULE_GFLAGS_PRIVATE ;}# line 1789 ""grammar.c"" break ;case 20 : # line 347 ""grammar.y"" {( yyval . integer ) = RULE_GFLAGS_GLOBAL ;}# line 1795 ""grammar.c"" break ;case 21 : # line 353 ""grammar.y"" {( yyval . c_string ) = NULL ;}# line 1803 ""grammar.c"" break ;case 22 : # line 357 ""grammar.y"" {compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , """" , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ;}# line 1821 ""grammar.c"" break ;case 23 : # line 375 ""grammar.y"" {char * identifier ;compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = identifier ;}# line 1838 ""grammar.c"" break ;case 24 : # line 388 ""grammar.y"" {char * tag_name = ( yyvsp [ - 1 ] . c_string ) ;size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ;while ( tag_length > 0 ) {if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) {yr_compiler_set_error_extra_info ( compiler , tag_name ) ;compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ;break ;}tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ;tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ;}if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ;}# line 1874 ""grammar.c"" break ;case 25 : # line 424 ""grammar.y"" {( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ;}# line 1880 ""grammar.c"" break ;case 26 : # line 425 ""grammar.y"" {( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ;}# line 1886 ""grammar.c"" break ;case 27 : # line 431 ""grammar.y"" {SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ;( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1906 ""grammar.c"" break ;case 28 : # line 447 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1923 ""grammar.c"" break ;case 29 : # line 460 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ;yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1940 ""grammar.c"" break ;case 30 : # line 473 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1957 ""grammar.c"" break ;case 31 : # line 486 ""grammar.y"" {( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;ERROR_IF ( ( yyval . meta ) == NULL ) ;}# line 1974 ""grammar.c"" break ;case 32 : # line 502 ""grammar.y"" {( yyval . string ) = ( yyvsp [ 0 ] . string ) ;}# line 1980 ""grammar.c"" break ;case 33 : # line 503 ""grammar.y"" {( yyval . string ) = ( yyvsp [ - 1 ] . string ) ;}# line 1986 ""grammar.c"" break ;case 34 : # line 509 ""grammar.y"" {compiler -> error_line = yyget_lineno ( yyscanner ) ;}# line 1994 ""grammar.c"" break ;case 35 : # line 513 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ;yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;compiler -> error_line = 0 ;}# line 2009 ""grammar.c"" break ;case 36 : # line 524 ""grammar.y"" {compiler -> error_line = yyget_lineno ( yyscanner ) ;}# line 2017 ""grammar.c"" break ;case 37 : # line 528 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ;yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;compiler -> error_line = 0 ;}# line 2033 ""grammar.c"" break ;case 38 : # line 540 ""grammar.y"" {( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ;yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ;yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ;ERROR_IF ( ( yyval . string ) == NULL ) ;}# line 2047 ""grammar.c"" break ;case 39 : # line 553 ""grammar.y"" {( yyval . integer ) = 0 ;}# line 2053 ""grammar.c"" break ;case 40 : # line 554 ""grammar.y"" {( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ;}# line 2059 ""grammar.c"" break ;case 41 : # line 559 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_WIDE ;}# line 2065 ""grammar.c"" break ;case 42 : # line 560 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_ASCII ;}# line 2071 ""grammar.c"" break ;case 43 : # line 561 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_NO_CASE ;}# line 2077 ""grammar.c"" break ;case 44 : # line 562 ""grammar.y"" {( yyval . integer ) = STRING_GFLAGS_FULL_WORD ;}# line 2083 ""grammar.c"" break ;case 45 : # line 568 ""grammar.y"" {int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ;if ( var_index >= 0 ) {compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ;}else {YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ;if ( object == NULL ) {char * ns = compiler -> current_namespace -> name ;object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ;}if ( object != NULL ) {char * id ;compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = object ;( yyval . expression ) . identifier = object -> identifier ;}else {YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ;if ( rule != NULL ) {compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ;( yyval . expression ) . value . integer = UNDEFINED ;( yyval . expression ) . identifier = rule -> identifier ;}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ;compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ;}}}yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 2172 ""grammar.c"" break ;case 46 : # line 653 ""grammar.y"" {YR_OBJECT * field = NULL ;if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) {field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ;if ( field != NULL ) {char * ident ;compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = field ;( yyval . expression ) . identifier = field -> identifier ;}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ;compiler -> last_result = ERROR_INVALID_FIELD_NAME ;}}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ;compiler -> last_result = ERROR_NOT_A_STRUCTURE ;}yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 2222 ""grammar.c"" break ;case 47 : # line 699 ""grammar.y"" {YR_OBJECT_ARRAY * array ;YR_OBJECT_DICTIONARY * dict ;if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) {if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) {yr_compiler_set_error_extra_info ( compiler , ""array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type"" ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ;array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = array -> prototype_item ;( yyval . expression ) . identifier = array -> identifier ;}else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) {if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) {yr_compiler_set_error_extra_info ( compiler , ""dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type"" ) ;compiler -> last_result = ERROR_WRONG_TYPE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ;dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = dict -> prototype_item ;( yyval . expression ) . identifier = dict -> identifier ;}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ;compiler -> last_result = ERROR_NOT_INDEXABLE ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 2283 ""grammar.c"" break ;case 48 : # line 757 ""grammar.y"" {YR_OBJECT_FUNCTION * function ;char * args_fmt ;if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) {compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ;function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ;( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ;( yyval . expression ) . value . object = function -> return_obj ;( yyval . expression ) . identifier = function -> identifier ;}else {yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ;compiler -> last_result = ERROR_NOT_A_FUNCTION ;}yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 2328 ""grammar.c"" break ;case 49 : # line 801 ""grammar.y"" {( yyval . c_string ) = yr_strdup ( """" ) ;}# line 2334 ""grammar.c"" break ;case 50 : # line 802 ""grammar.y"" {( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ;}# line 2340 ""grammar.c"" break ;case 51 : # line 807 ""grammar.y"" {( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ;switch ( ( yyvsp [ 0 ] . expression ) . type ) {case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ;break ;case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ;break ;case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ;break ;case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ;break ;case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ;break ;}ERROR_IF ( ( yyval . c_string ) == NULL ) ;}# line 2369 ""grammar.c""  break ;case 52 :  # line 832 ""grammar.y""  {","# line 2371 ""grammar.c"" break ;case 9 : # line 834 ""grammar.y"" {",743
1018,"
",default : assert ( FALSE ) ;,743
1019,"}}# line 2405 ""grammar.c""  break ;case 53 :  # line 868 ""grammar.y""  {","}}# line 2405 ""grammar.c"" break ;case 53 : # line 868 ""grammar.y"" {",743
1020,"# line 2451 ""grammar.c""  break ;case 54 :  # line 914 ""grammar.y""  {","# line 2451 ""grammar.c"" break ;case 54 : # line 914 ""grammar.y"" {",743
1021,"# line 2474 ""grammar.c""  break ;case 55 :  # line 936 ""grammar.y""  {# line 2487 ""grammar.c""  break ;case 56 :  # line 945 ""grammar.y""  {# line 2500 ""grammar.c""  break ;case 57 :  # line 954 ""grammar.y""  {# line 2519 ""grammar.c""  break ;case 58 :  # line 969 ""grammar.y""  {# line 2535 ""grammar.c""  break ;case 59 :  # line 981 ""grammar.y""  {# line 2553 ""grammar.c""  break ;case 60 :  # line 995 ""grammar.y""  {# line 2570 ""grammar.c""  break ;case 61 :  # line 1008 ""grammar.y""  {# line 2585 ""grammar.c""  break ;case 62 :  # line 1019 ""grammar.y""  {}# line 2597 ""grammar.c"" break ;case 63 :  # line 1027 ""grammar.y""  {","# line 2474 ""grammar.c"" break ;case 55 : # line 936 ""grammar.y"" {# line 2487 ""grammar.c"" break ;case 56 : # line 945 ""grammar.y"" {# line 2500 ""grammar.c"" break ;case 57 : # line 954 ""grammar.y"" {# line 2519 ""grammar.c"" break ;case 58 : # line 969 ""grammar.y"" {# line 2535 ""grammar.c"" break ;case 59 : # line 981 ""grammar.y"" {# line 2553 ""grammar.c"" break ;case 60 : # line 995 ""grammar.y"" {# line 2570 ""grammar.c"" break ;case 61 : # line 1008 ""grammar.y"" {# line 2585 ""grammar.c"" break ;case 62 : # line 1019 ""grammar.y"" {}# line 2597 ""grammar.c"" break ;case 63 : # line 1027 ""grammar.y"" {",743
1022,"# line 2631 ""grammar.c""  break ;case 64 :  # line 1057 ""grammar.y""  {","# line 2631 ""grammar.c"" break ;case 64 : # line 1057 ""grammar.y"" {",743
1023,"# line 2670 ""grammar.c""  break ;case 65 :  # line 1092 ""grammar.y""  {","# line 2670 ""grammar.c"" break ;case 65 : # line 1092 ""grammar.y"" {",743
1024,"# line 2753 ""grammar.c""  break ;case 66 :  # line 1171 ""grammar.y""  {","# line 2753 ""grammar.c"" break ;case 66 : # line 1171 ""grammar.y"" {",743
1025,"# line 2787 ""grammar.c""  break ;case 67 :  # line 1201 ""grammar.y""  {","# line 2787 ""grammar.c"" break ;case 67 : # line 1201 ""grammar.y"" {",743
1026,"# line 2840 ""grammar.c""  break ;case 68 :  # line 1250 ""grammar.y""  {# line 2850 ""grammar.c""  break ;case 69 :  # line 1256 ""grammar.y""  {# line 2860 ""grammar.c""  break ;case 70 :  # line 1262 ""grammar.y""  {","# line 2840 ""grammar.c"" break ;case 68 : # line 1250 ""grammar.y"" {# line 2850 ""grammar.c"" break ;case 69 : # line 1256 ""grammar.y"" {# line 2860 ""grammar.c"" break ;case 70 : # line 1262 ""grammar.y"" {",743
1027,"# line 2890 ""grammar.c""  break ;case 71 :  # line 1288 ""grammar.y""  {","# line 2890 ""grammar.c"" break ;case 71 : # line 1288 ""grammar.y"" {",743
1028,"# line 2930 ""grammar.c""  break ;case 72 :  # line 1324 ""grammar.y""  {","# line 2930 ""grammar.c"" break ;case 72 : # line 1324 ""grammar.y"" {",743
1029,"# line 2959 ""grammar.c""  break ;case 73 :  # line 1349 ""grammar.y""  {","# line 2959 ""grammar.c"" break ;case 73 : # line 1349 ""grammar.y"" {",743
1030,"# line 2999 ""grammar.c""  break ;case 74 :  # line 1385 ""grammar.y""  {# line 3012 ""grammar.c""  break ;case 75 :  # line 1394 ""grammar.y""  {# line 3025 ""grammar.c""  break ;case 76 :  # line 1403 ""grammar.y""  {# line 3038 ""grammar.c""  break ;case 77 :  # line 1412 ""grammar.y""  {# line 3051 ""grammar.c""  break ;case 78 :  # line 1421 ""grammar.y""  {# line 3064 ""grammar.c""  break ;case 79 :  # line 1430 ""grammar.y""  {# line 3077 ""grammar.c""  break ;case 80 :  # line 1439 ""grammar.y""  {# line 3085 ""grammar.c""  break ;case 81 :  # line 1443 ""grammar.y""  {# line 3093 ""grammar.c""  break ;case 82 :  # line 1450 ""grammar.y""  {# line 3099 ""grammar.c""  break ;case 83 :  # line 1451 ""grammar.y""  {# line 3105 ""grammar.c""  break ;case 84 :  # line 1457 ""grammar.y""  {","# line 2999 ""grammar.c"" break ;case 74 : # line 1385 ""grammar.y"" {# line 3012 ""grammar.c"" break ;case 75 : # line 1394 ""grammar.y"" {# line 3025 ""grammar.c"" break ;case 76 : # line 1403 ""grammar.y"" {# line 3038 ""grammar.c"" break ;case 77 : # line 1412 ""grammar.y"" {# line 3051 ""grammar.c"" break ;case 78 : # line 1421 ""grammar.y"" {# line 3064 ""grammar.c"" break ;case 79 : # line 1430 ""grammar.y"" {# line 3077 ""grammar.c"" break ;case 80 : # line 1439 ""grammar.y"" {# line 3085 ""grammar.c"" break ;case 81 : # line 1443 ""grammar.y"" {# line 3093 ""grammar.c"" break ;case 82 : # line 1450 ""grammar.y"" {# line 3099 ""grammar.c"" break ;case 83 : # line 1451 ""grammar.y"" {# line 3105 ""grammar.c"" break ;case 84 : # line 1457 ""grammar.y"" {",743
1031,"# line 3127 ""grammar.c""  break ;case 85 :  # line 1479 ""grammar.y""  {# line 3143 ""grammar.c""  break ;case 86 :  # line 1491 ""grammar.y""  {# line 3158 ""grammar.c""  break ;case 87 :  # line 1506 ""grammar.y""  {# line 3167 ""grammar.c""  break ;case 89 :  # line 1512 ""grammar.y""  {# line 3178 ""grammar.c""  break ;case 92 :  # line 1529 ""grammar.y""  {# line 3189 ""grammar.c""  break ;case 93 :  # line 1536 ""grammar.y""  {# line 3200 ""grammar.c""  break ;case 95 :  # line 1548 ""grammar.y""  {# line 3208 ""grammar.c""  break ;case 96 :  # line 1552 ""grammar.y""  {# line 3216 ""grammar.c""  break ;case 97 :  # line 1560 ""grammar.y""  {# line 3224 ""grammar.c""  break ;case 98 :  # line 1564 ""grammar.y""  {# line 3238 ""grammar.c""  break ;case 99 :  # line 1574 ""grammar.y""  {yywarning ( yyscanner , ""Using<S2SV_blank>deprecated<S2SV_blank>\\\\""entrypoint\\\\""<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\\\""entry_point\\\\""<S2SV_blank>"" ""function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead."" ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}# line 3256 ""grammar.c""  break ;case 100 :  # line 1588 ""grammar.y""  {CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX"" ) ;compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}# line 3276 ""grammar.c""  break ;case 101 :  # line 1604 ""grammar.y""  {compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ;}# line 3290 ""grammar.c""  break ;case 102 :  # line 1614 ""grammar.y""  {compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ;}# line 3303 ""grammar.c""  break ;case 103 :  # line 1623 ""grammar.y""  {","# line 3127 ""grammar.c"" break ;case 85 : # line 1479 ""grammar.y"" {# line 3143 ""grammar.c"" break ;case 86 : # line 1491 ""grammar.y"" {# line 3158 ""grammar.c"" break ;case 87 : # line 1506 ""grammar.y"" {# line 3167 ""grammar.c"" break ;case 89 : # line 1512 ""grammar.y"" {# line 3178 ""grammar.c"" break ;case 92 : # line 1529 ""grammar.y"" {# line 3189 ""grammar.c"" break ;case 93 : # line 1536 ""grammar.y"" {# line 3200 ""grammar.c"" break ;case 95 : # line 1548 ""grammar.y"" {# line 3208 ""grammar.c"" break ;case 96 : # line 1552 ""grammar.y"" {# line 3216 ""grammar.c"" break ;case 97 : # line 1560 ""grammar.y"" {# line 3224 ""grammar.c"" break ;case 98 : # line 1564 ""grammar.y"" {# line 2409 ""grammar.c"" break ;case 99 : # line 872 ""grammar.y"" {",743
1032,"# line 3332 ""grammar.c""  break ;case 104 :  # line 1648 ""grammar.y""  {# line 3348 ""grammar.c""  break ;case 105 :  # line 1660 ""grammar.y""  {# line 3364 ""grammar.c""  break ;case 106 :  # line 1672 ""grammar.y""  {","# line 3332 ""grammar.c"" break ;case 104 : # line 1648 ""grammar.y"" {# line 3348 ""grammar.c"" break ;case 105 : # line 1660 ""grammar.y"" {# line 3364 ""grammar.c"" break ;case 106 : # line 1672 ""grammar.y"" {",743
1033,"# line 3384 ""grammar.c""  break ;case 107 :  # line 1688 ""grammar.y""  {compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ;yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}# line 3400 ""grammar.c""  break ;case 108 :  # line 1700 ""grammar.y""  {compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ;if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ;yr_free ( ( yyvsp [ 0 ] . c_string ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = UNDEFINED ;}# line 3420 ""grammar.c""  break ;case 109 :  # line 1716 ""grammar.y""  {","# line 2455 ""grammar.c"" break ;case 107 : # line 918 ""grammar.y"" {",743
1034,"# line 3469 ""grammar.c""  break ;case 110 :  # line 1761 ""grammar.y""  {CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , ""-"" ) ;if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) {( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ;}else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) {( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ;compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ;}ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}# line 3492 ""grammar.c""  break ;case 111 :  # line 1780 ""grammar.y""  {","# line 2478 ""grammar.c"" break ;case 110 : # line 940 ""grammar.y"" {",743
1035,"# line 3514 ""grammar.c""  break ;case 112 :  # line 1798 ""grammar.y""  {","# line 3514 ""grammar.c"" break ;case 112 : # line 1798 ""grammar.y"" {",743
1036,"# line 3536 ""grammar.c""  break ;case 113 :  # line 1816 ""grammar.y""  {","# line 2491 ""grammar.c"" break ;case 113 : # line 949 ""grammar.y"" {",743
1037,"# line 3558 ""grammar.c""  break ;case 114 :  # line 1834 ""grammar.y""  {compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""\\\\\\\\"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) {if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) {( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ;( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ;}else {compiler -> last_result = ERROR_DIVISION_BY_ZERO ;ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ;}}else {( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ;}}# line 3588 ""grammar.c""  break ;case 115 :  # line 1860 ""grammar.y""  {","# line 2504 ""grammar.c"" break ;case 114 : # line 958 ""grammar.y"" {",743
1038,"# line 3610 ""grammar.c""  break ;case 116 :  # line 1878 ""grammar.y""  {# line 3624 ""grammar.c""  break ;case 117 :  # line 1888 ""grammar.y""  {# line 3638 ""grammar.c""  break ;case 118 :  # line 1898 ""grammar.y""  {# line 3652 ""grammar.c""  break ;case 119 :  # line 1908 ""grammar.y""  {# line 3666 ""grammar.c""  break ;case 120 :  # line 1918 ""grammar.y""  {# line 3680 ""grammar.c""  break ;case 121 :  # line 1928 ""grammar.y""  {# line 3694 ""grammar.c""  break ;case 122 :  # line 1938 ""grammar.y""  {# line 3702 ""grammar.c""  break ;# line 3706 ""grammar.c""  default : break ;","# line 3610 ""grammar.c"" break ;case 116 : # line 1878 ""grammar.y"" {# line 2523 ""grammar.c"" break ;case 117 : # line 973 ""grammar.y"" {# line 2539 ""grammar.c"" break ;case 118 : # line 1898 ""grammar.y"" {# line 2557 ""grammar.c"" break ;case 119 : # line 999 ""grammar.y"" {# line 2574 ""grammar.c"" break ;case 120 : # line 1918 ""grammar.y"" {# line 2589 ""grammar.c"" break ;case 121 : # line 1928 ""grammar.y"" {# line 2637 ""grammar.c"" break ;case 122 : # line 1938 ""grammar.y"" {# line 2676 ""grammar.c"" break ;# line 3706 ""grammar.c"" default : break ;",743
1039,if ( roishift == 0 && bgshift == 0 ) {return ;,"if ( roishift < 0 ) {jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\\roishift = 0 ;}if ( roishift == 0 && bgshift == 0 ) {return ;",744
1040,mask = ( 1 << numbps ) - 1 ;if ( mag & ( ~ mask ) ) {,"mask = ( JAS_CAST ( uint_fast32_t , 1 ) << numbps ) - 1 ;if ( mag & ( ~ mask ) ) {",744
1041,"static void get_frame_stats ( vpx_codec_ctx_t * ctx ,  const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline ,  vpx_fixed_buf_t * stats ) {vpx_codec_iter_t iter = NULL ;if ( pkt -> kind == VPX_CODEC_STATS_PKT ) {const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ;}","static int get_frame_stats ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , vpx_fixed_buf_t * stats ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_STATS_PKT ) {const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ;return got_pkts ;}",745
1042,"int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) {LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ;( void ) arg2 ;vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd ,  lf_data -> start , lf_data -> stop , lf_data -> y_only ) ;","int vp9_loop_filter_worker ( LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ;( void ) arg2 ;vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , lf_data -> planes , lf_data -> start , lf_data -> stop , lf_data -> y_only ) ;",746
1043,"while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ;while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 )  ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ;for ( ;","while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( cp ) - 1 ) ;while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 ) ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ;for ( ;",747
1044,"if ( ( e -> target_offset == sizeof ( struct arpt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> arp ) ) ||  visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",748
1045,int event_id = event -> attr . config ;if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;,u64 event_id = event -> attr . config ;if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ;,749
1046,alarm_timer = alarm_new ( ) ;if ( ! alarm_timer ) {,btif_config_devcache_cleanup ( ) ;alarm_timer = alarm_new ( ) ;if ( ! alarm_timer ) {,750
1047,int groups_per_flex = 0 ;size_t size ;groups_per_flex = 1 << sbi -> s_log_groups_per_flex ;if ( groups_per_flex < 2 ) {sbi -> s_log_groups_per_flex = 0 ;return 1 ;},unsigned int groups_per_flex = 0 ;size_t size ;,751
1048,for ( k = passIC + 2 ;k < passIC + 2 + passInstructions [ passIC + 1 ] ;k ++ )  if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ;,for ( k = passIC + 2 ;( ( k < passIC + 2 + passInstructions [ passIC + 1 ] ) && ( kk < input -> length ) ) ;k ++ ) if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ;,752
1049,rx_drop :  kfree_skb ( skb ) ;rcv_stats -> rx_dropped ++ ;,rx_drop : rcv_stats -> rx_dropped ++ ;,753
1050,"int rc ;unsigned char key2 [ 8 ] ;struct crypto_skcipher * tfm_des ;struct scatterlist sgin , sgout ;tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ;if ( IS_ERR ( tfm_des ) ) {rc = PTR_ERR ( tfm_des ) ;cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\\goto smbhash_err ;}","unsigned char key2 [ 8 ] ;struct crypto_skcipher * tfm_des ;struct scatterlist sgin , sgout ;tfm_des = crypto_alloc_cipher ( ""des"" , 0 , CRYPTO_ALG_ASYNC ) ;if ( IS_ERR ( tfm_des ) ) {rc = PTR_ERR ( tfm_des ) ;cifs_dbg ( VFS , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\\goto smbhash_err ;}",754
1051,"sg_init_one ( & sgin , in , 8 ) ;sg_init_one ( & sgout , out , 8 ) ;skcipher_request_set_callback ( req , 0 , NULL , NULL ) ;skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ;rc = crypto_skcipher_encrypt ( req ) ;smbhash_err :  return rc ;","sg_init_one ( & sgin , in , 8 ) ;sg_init_one ( & sgout , out , 8 ) ;skcipher_request_set_callback ( req , 0 , 0 ) ;return 0 ;",754
1052,"
",if ( band -> prec ) {,755
1053,Jpeg2000Prec * prec = band -> prec + precno ;av_freep ( & prec -> zerobits ) ;av_freep ( & band -> prec ) ;},Jpeg2000Prec * prec = band -> prec + precno ;av_freep ( & prec -> zerobits ) ;}av_freep ( & band -> prec ) ;},755
1054,"return - ENOEXEC ;}if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) {if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ;ret = fdt_check_full ( fit , size ) ;if ( ret ) {log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\\return - EINVAL ;}","if ( ret ) ret = - EINVAL ;if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) {ret = fdt_check_no_at ( fit , 0 ) ;return ret ;}}if ( ret ) {log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\\return ret ;}",756
1055,"if ( len > BUFSIZE + sizeof ( struct nbd_reply ) )  err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ;","if ( len > BUFSIZE - sizeof ( struct nbd_reply ) ) err ( ""Request<S2SV_blank>too<S2SV_blank>big!"" ) ;",757
1056,"int ret = 0 ;bh = udf_read_tagged ( sb , block , block , & ident ) ;lvd = ( struct logicalVolDesc * ) bh -> b_data ;ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ;i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ;i ++ , offset += gpm -> partitionMapLength ) {","unsigned int table_len ;int ret = 0 ;bh = udf_read_tagged ( sb , block , block , & ident ) ;lvd = ( struct logicalVolDesc * ) bh -> b_data ;table_len = le32_to_cpu ( lvd -> mapTableLength ) ;if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) {udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\\goto out_bh ;}ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ;i < sbi -> s_partitions && offset < table_len ;i ++ , offset += gpm -> partitionMapLength ) {",758
1057,"int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ;size_t bytes_left = br -> user_buffer_end - bufptr ;size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ;br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ;","int shift = VP8_BD_VALUE_SIZE - CHAR_BIT - ( count + 8 ) ;size_t bytes_left = br -> user_buffer_end - bufptr ;size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) ;br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ;",759
1058,"if ( in ) {dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;dev -> out_pipe = usb_sndbulkpipe ( udev ,  out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;}if ( iso_in ) {","if ( in ) dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;if ( iso_in ) {",760
1059,for ( y = 0 ;uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ;,av_assert0 ( s -> bit_depth > 1 ) ;for ( y = 0 ;uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ;,761
1060,"static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags )  {if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) {rcu_read_unlock ( ) ;","static void nfs4_return_incompatible_delegation ( struct inode * inode , fmode_t fmode ) {if ( delegation == NULL || ( delegation -> type & fmode ) == fmode ) {rcu_read_unlock ( ) ;",762
1061,"void jslTokenAsString ( int token , char * str , size_t len ) {if ( token > 32 && token < 128 ) {","void jslTokenAsString ( int token , char * str , size_t len ) {assert ( len > 28 ) ;if ( token > 32 && token < 128 ) {",763
1062,"case LEX_EOF : strncpy ( str , ""EOF"" , len ) ;case LEX_ID : strncpy ( str , ""ID"" , len ) ;case LEX_INT : strncpy ( str , ""INT"" , len ) ;case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ;case LEX_STR : strncpy ( str , ""STRING"" , len ) ;case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ;case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ;case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ;case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ;}","case LEX_EOF : strcpy ( str , ""EOF"" , len ) ;case LEX_ID : strcpy ( str , ""ID"" , len ) ;case LEX_INT : strcpy ( str , ""INT"" , len ) ;case LEX_FLOAT : strcpy ( str , ""FLOAT"" , len ) ;case LEX_STR : strcpy ( str , ""STRING"" , len ) ;case LEX_UNFINISHED_STR : strcpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ;case LEX_TEMPLATE_LITERAL : strcpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ;case LEX_REGEX : strcpy ( str , ""REGEX"" , len ) ;case LEX_UNFINISHED_REGEX : strcpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ;case LEX_UNFINISHED_COMMENT : strcpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ;}",763
1063,"strncpy ( str , & tokenNames [ p ] , len ) ;return ;assert ( len >= 10 ) ;espruino_snprintf ( str , len , ""?[%d]"" , token ) ;","strcpy ( str , & tokenNames [ p ] ) ;return ;assert ( len >= 10 ) ;espruino_snprintf ( str , len , ""?[%d]"" , token ) ;",763
1064,if ( ! handle )  return NULL ;,if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ;,764
1065,"
","memset ( sax , 0 , sizeof ( sax ) ) ;",765
1066,"sax -> sax25_family = AF_NETROM ;skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;","sax -> sax25_family = AF_NETROM ;skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ;",765
1067,"static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val )  {","static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) {",766
1068,return res ;cleanup : if ( hdl ) {,cleanup : return res ;cleanup : if ( hdl ) {,767
1069,"}if ( section == & service_options || section == & new_service_options )   s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>defaults"" ) ;else s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>[%s]"" , section -> servname ) ;","if ( section == & service_options ) s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ;else if ( section == & new_service_options ) s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ;else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , section -> servname ) ;}if ( section == & service_options || section == & new_service_options ) s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>temporary<S2SV_blank>section<S2SV_blank>defaults"" ) ;else s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>[%s]"" , section -> servname ) ;",768
1070,switch ( cmd ) {,"# if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) {case CMD_SET_DEFAULTS : section -> security_level = - 1 ;break ;case CMD_SET_COPY : section -> security_level = new_service_options . security_level ;break ;case CMD_FREE : break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""securityLevel"" ) ) break ;{char * tmp_str ;int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ;if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return ""Illegal<S2SV_blank>security<S2SV_blank>level"" ;section -> security_level = tmp_int ;}return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d"" , ""securityLevel"" , DEFAULT_SECURITY_LEVEL ) ;break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>set<S2SV_blank>the<S2SV_blank>security<S2SV_blank>level"" , ""securityLevel"" ) ;break ;}# endif switch ( cmd ) {",768
1071,}# ifndef USE_WIN32 switch ( cmd ) {,}# ifndef USE_WIN32 switch ( cmd ) {,768
1072,"case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>level<S2SV_blank>of<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>verification"" , ""verify"" ) ;s_log ( LOG_NOTICE ,  ""%25slevel<S2SV_blank>0<S2SV_blank>-<S2SV_blank>request<S2SV_blank>and<S2SV_blank>ignore<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ;s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>1<S2SV_blank>-<S2SV_blank>only<S2SV_blank>validate<S2SV_blank>peer<S2SV_blank>cert<S2SV_blank>if<S2SV_blank>present"" , """" ) ;s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>2<S2SV_blank>-<S2SV_blank>always<S2SV_blank>require<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ;s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>3<S2SV_blank>-<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>with<S2SV_blank>locally<S2SV_blank>installed<S2SV_blank>cert"" , """" ) ;s_log ( LOG_NOTICE , ""%25slevel<S2SV_blank>4<S2SV_blank>-<S2SV_blank>ignore<S2SV_blank>CA<S2SV_blank>chain<S2SV_blank>and<S2SV_blank>only<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>cert"" , """" ) ;break ;","
",768
1073,"if ( section == & service_options )  memset ( section , 0 , sizeof ( SERVICE_OPTIONS ) ) ;","if ( section == & service_options || section == & new_service_options ) memset ( section , 0 , sizeof ( SERVICE_OPTIONS ) ) ;",768
1074,lockdep_assert_irqs_disabled ( ) ;if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ;preempt_count_sub ( cnt ) ;},"lockdep_assert_irqs_disabled ( ) ;if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) ) ;if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ;__preempt_count_sub ( cnt ) ;}",769
1075,"vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ;br = ref_mv -> as_mv . row ;bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX )  + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","( void ) mvcost ;vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ;br = ref_mv -> as_mv . row ;bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",770
1076,"# endif  CHECK_BOUNDS ( 2 ) if ( all_in ) {thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","# else ( void ) search_param ;# endif CHECK_BOUNDS ( 2 ) if ( all_in ) {thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1077,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1078,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1079,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1080,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1081,"thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ;CHECK_BETTER }","thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride ) ;CHECK_BETTER }",770
1082,"struct mount * child , * p ;struct hlist_node * n ;if ( IS_MNT_SHARED ( dest_mnt ) ) {err = invent_group_ids ( source_mnt , true ) ;err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;lock_mount_hash ( ) ;","struct mnt_namespace * ns = dest_mnt -> mnt_ns ;struct mount * child , * p ;struct hlist_node * n ;if ( ! parent_path ) {err = count_mounts ( ns , source_mnt ) ;}if ( IS_MNT_SHARED ( dest_mnt ) ) {err = invent_group_ids ( source_mnt , true ) ;if ( err ) goto out ;err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ;lock_mount_hash ( ) ;",771
1083,"
",child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ;,771
1084,"umount_tree ( child , UMOUNT_SYNC ) ;}out :  return err ;}","umount_tree ( child , UMOUNT_SYNC ) ;}out : ns -> pending_mounts = 0 ;return err ;}",771
1085,int contentlen = 0 ;int isform = 0 ;,unsigned contentlen = 0 ;int isform = 0 ;,772
1086,"if ( ! * sb || strncasecmp ( sb , ""basic"" , 5 ) ) {continue ;}sb += 5 ;while ( isspace ( * sb ) ) sb ++ ;i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ;if ( i <= 0 ) continue ;username [ i ] = 0 ;sb = strchr ( ( char * ) username , \':\' ) ;if ( sb ) {* sb = 0 ;if ( param -> password ) myfree ( param -> password ) ;param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ;}if ( param -> username ) myfree ( param -> username ) ;param -> username = ( unsigned char * ) mystrdup ( username ) ;continue ;contentlen = atoi ( sb ) ;}","sscanf ( sb , ""%u"" , & contentlen ) ;if ( contentlen > LINESIZE * 1024 ) contentlen = 0 ;contentlen = atoi ( sb ) ;}",772
1087,"printstr ( & pp , authreq ) ;RETURN ( res ) ;}if ( param -> srv -> singlepacket || param -> redirected ) {if ( * req == \'C\' ) req [ 1 ] = 0 ;else * req = 0 ;}sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : """" ) ;if ( * req != \'S\' ) printstr ( & pp , buf ) ;switch ( * req ) {case \'C\' : printstr ( & pp , counters ) ;{struct trafcount * cp ;int num = 0 ;for ( cp = conf . trafcounter ;cp ;cp = cp -> next , num ++ ) {int inbuf = 0 ;if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) {if ( ! ACLmatches ( cp -> ace , param ) ) continue ;}if ( req [ 1 ] == \'S\' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ;if ( req [ 1 ] == \'D\' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ;inbuf += sprintf ( buf , ""<tr>"" ""<td>%s</td><td><A<S2SV_blank>HREF=\\\\\\\'/C%c%d\\\\\\\'>%s</A></td><td>"" , ( cp -> comment ) ? cp -> comment : ""&nbsp;"" , ( cp -> disabled ) ? \'S\' : \'D\' , num , ( cp -> disabled ) ? ""NO"" : ""YES"" ) ;if ( ! cp -> ace || ! cp -> ace -> users ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> src ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> dst ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> ports ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , "",<br<S2SV_blank>/>\\\\r\\\}if ( cp -> type == NONE ) {inbuf += sprintf ( buf + inbuf , ""</td><td<S2SV_blank>colspan=\\\\\\\'6\\\\\\\'<S2SV_blank>align=\\\\\\\'center\\\\\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\\\r\\\}else {inbuf += sprintf ( buf + inbuf , ""</td><td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>MB%s</td>"" ""<td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>%s</td>"" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : ""never"" ) ;inbuf += sprintf ( buf + inbuf , ""<td>%s</td>"" ""<td>%i</td>"" ""</tr>\\\\r\\\}printstr ( & pp , buf ) ;}}printstr ( & pp , counterstail ) ;break ;case \'R\' : conf . needreload = 1 ;printstr ( & pp , ""<h3>Reload<S2SV_blank>scheduled</h3>"" ) ;break ;case \'S\' : {if ( req [ 1 ] == \'X\' ) {printstr ( & pp , style ) ;break ;}printstr ( & pp , xml ) ;printval ( conf . services , TYPE_SERVER , 0 , & pp ) ;printstr ( & pp , postxml ) ;}break ;case \'F\' : {FILE * fp ;char buf [ 256 ] ;fp = confopen ( ) ;if ( ! fp ) {printstr ( & pp , ""<h3><font<S2SV_blank>color=\\\\""red\\\\"">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>"" ) ;break ;}printstr ( & pp , ""<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>"" ) ;printstr ( & pp , ""<form<S2SV_blank>method=\\\\""POST\\\\""<S2SV_blank>action=\\\\""/U\\\\""><textarea<S2SV_blank>cols=\\\\""80\\\\""<S2SV_blank>rows=\\\\""30\\\\""<S2SV_blank>name=\\\\""conffile\\\\"">"" ) ;while ( fgets ( buf , 256 , fp ) ) {","printstr ( & pp , ""<form<S2SV_blank>method=\\\\""POST\\\\""<S2SV_blank>action=\\\\""/U\\\\""<S2SV_blank>enctype=\\\\""application/x-www-form-urlencoded\\\\""><textarea<S2SV_blank>cols=\\\\""80\\\\""<S2SV_blank>rows=\\\\""30\\\\""<S2SV_blank>name=\\\\""conffile\\\\"">"" ) ;while ( fgets ( buf , 256 , fp ) ) {",772
1088,"int l = 0 ;int error = 0 ;if ( ! writable || fseek ( writable , 0 , 0 ) ) {error = 1 ;}while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , \'+\' , conf . timeouts [ STRING_S ] ) ) > 0 ) {if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ;buf [ i ] = 0 ;if ( ! l ) {if ( ! error ) {decodeurl ( ( unsigned char * ) buf , 1 ) ;l += i ;if ( l >= contentlen ) break ;","int l = 0 ;int error = 0 ;if ( ! writable || ! contentlen || fseek ( writable , 0 , 0 ) ) {error = 1 ;}while ( l < contentlen && ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , ( contentlen - l ) > LINESIZE - 1 ? LINESIZE - 1 : contentlen - l , \'+\' , conf . timeouts [ STRING_S ] ) ) > 0 ) {if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ;buf [ i ] = 0 ;if ( ! l ) {if ( ! error ) {buf [ i ] = 0 ;decodeurl ( ( unsigned char * ) buf , 1 ) ;l += i ;if ( l >= contentlen ) break ;",772
1089,"__skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ;sock_put ( sk ) ;","__skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND , false ) ;sock_put ( sk ) ;",773
1090,"static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state )  {if ( nd -> intent . open . flags & FMODE_EXEC ) {ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ;","static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state , fmode_t fmode ) {if ( fmode & FMODE_EXEC ) {ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ;",774
1091,"out_close :  nfs4_close_sync ( path , state , nd -> intent . open . flags ) ;return ret ;","out_close : nfs4_close_sync ( path , state , fmode & ( FMODE_READ | FMODE_WRITE ) ) ;return ret ;",774
1092,"bpf_map_inc ( map , true ) ;fdput ( f ) ;","map = bpf_map_inc ( map , true ) ;fdput ( f ) ;",775
1093,"value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ;value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ;value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ;value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ;}","value -> x = MagickMin ( 1.0f , MaxF ( 0.0f , value -> x ) ) ;value -> y = MinF ( 1.0f , MagickMax ( 0.0f , value -> y ) ) ;value -> z = MinF ( 1.0f , MagickMax ( 0.0f , value -> z ) ) ;value -> w = MinF ( 1.0f , MagickMax ( 0.0f , value -> w ) ) ;}",776
1094,"int col_offset , end_col_offset ;if ( ( ps = PyParser_New ( g , start ) ) == NULL ) {# ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL )  ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ;# endif for ( ;","int col_offset , end_col_offset ;growable_int_array type_ignores ;if ( ! growable_int_array_init ( & type_ignores , 10 ) ) {if ( ( ps = PyParser_New ( g , start ) ) == NULL ) {err_ret -> error = E_NOMEM ;PyTokenizer_Free ( tok ) ;return NULL ;}# ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ;if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS ;# endif for ( ;",777
1095,"
","if ( type == TYPE_IGNORE ) {if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) {err_ret -> error = E_NOMEM ;break ;}continue ;}",777
1096,"if ( ( err_ret -> error =  PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) {","if ( ( err_ret -> error = PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) {",777
1097,ps -> p_tree = NULL ;# ifndef PGEN if ( start == single_input ) {,"ps -> p_tree = NULL ;if ( n -> n_type == file_input ) {int num ;node * ch ;size_t i ;num = NCH ( n ) ;ch = CHILD ( n , num - 1 ) ;REQ ( ch , ENDMARKER ) ;for ( i = 0 ;i < type_ignores . num_items ;i ++ ) {PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ;}}growable_int_array_deallocate ( & type_ignores ) ;# ifndef PGEN if ( start == single_input ) {",777
1098,"vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ;cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ;","memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ;cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ;",778
1099,cpi -> common . last_frame_type = cpi -> common . frame_type ;cpi -> rc . frames_since_key ++ ;},cpi -> rc . frames_since_key ++ ;cpi -> rc . rc_2_frame = 0 ;cpi -> rc . rc_1_frame = 0 ;},779
1100,"if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;count = ReadBlob ( image , image -> colors , sun_colormap ) ;if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;for ( i = 0 ;i < ( ssize_t ) image -> colors ;i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}case RMT_RAW : {unsigned char * sun_colormap ;sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ;if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ;if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ;image -> columns = sun_info . width ;image -> rows = sun_info . height ;if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( GetFirstImageInList ( image ) ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;","if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;",780
1101,"if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;","if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line += 15 ;if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;bytes_per_line >>= 4 ;if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ;else {if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ;( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ;}sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ;",780
1102,"total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) )  return 0 ;do_wakeup = 0 ;","struct iov_iter iter ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) ) return 0 ;iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) ;do_wakeup = 0 ;",781
1103,"void * addr ;size_t chars = buf -> len ;int error , atomic ;if ( chars > total_len ) chars = total_len ;atomic = ! iov_fault_in_pages_write ( iov , chars ) ;redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ;else addr = kmap ( buf -> page ) ;error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ;if ( atomic ) kunmap_atomic ( addr ) ;else kunmap ( buf -> page ) ;if ( unlikely ( error ) ) {if ( atomic ) {atomic = 0 ;goto redo ;}if ( ! ret ) ret = error ;","size_t chars = buf -> len ;size_t written ;int error ;if ( chars > total_len ) chars = total_len ;written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ;if ( unlikely ( written < chars ) ) {if ( ! ret ) ret = - EFAULT ;",781
1104,"ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ;st -> st_oakley . group = lookup_group ( ke -> isak_group ) ;if ( st -> st_oakley . group == NULL ) {libreswan_log (  ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return v2N_INVALID_KE_PAYLOAD ;}","libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ;return STF_FAIL + v2N_INVALID_KE_PAYLOAD ;}",782
1105,if ( count < DJREPORT_SHORT_LENGTH - 2 )  count = DJREPORT_SHORT_LENGTH - 2 ;,if ( count > DJREPORT_SHORT_LENGTH - 2 ) count = DJREPORT_SHORT_LENGTH - 2 ;,783
1106,"record_and_restart ( event , val , regs , nmi ) ;}","record_and_restart ( event , val , regs ) ;}",784
1107,"id = idr_alloc ( & ids -> ipcs_idr , new ,  ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ;","current_euid_egid ( & euid , & egid ) ;new -> cuid = new -> uid = euid ;new -> gid = new -> cgid = egid ;id = idr_alloc ( & ids -> ipcs_idr , new , ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ;",785
1108,"current_euid_egid ( & euid , & egid ) ;new -> cuid = new -> uid = euid ;new -> gid = new -> cgid = egid ;","
",785
1109,break ;case XDR_ENCODE : tl = * tl_data_head ;,* tl_data_head = NULL ;break ;case XDR_ENCODE : tl = * tl_data_head ;,786
1110,"spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;","int length = urb -> actual_length ;spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;",787
1111,"desc -> reslength = urb -> actual_length ;memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ;desc -> length += desc -> reslength ;","if ( length + desc -> length > desc -> wMaxCommand ) {set_bit ( WDM_OVERFLOW , & desc -> flags ) ;}else {if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) {memmove ( desc -> ubuf + desc -> length , desc -> inbuf , length ) ;desc -> length += length ;desc -> reslength = length ;}}",787
1112,"if ( smd == NULL || buffer_len == 0 ) {KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ;SCReturnInt ( 0 ) ;if ( smd -> type == DETECT_CONTENT ) {DetectContentData * cd = ( DetectContentData * ) smd -> ctx ;SCLogDebug ( ""inspecting<S2SV_blank>content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>buffer_len<S2SV_blank>%"" PRIu32 , cd -> id , buffer_len ) ;# ifdef DEBUG BUG_ON ( cd -> depth != 0 && cd -> depth <= cd -> offset ) ;# endif uint8_t * found = NULL ;uint32_t offset = 0 ;uint32_t depth = buffer_len ;uint32_t prev_offset = 0 ;uint32_t prev_buffer_offset = det_ctx -> buffer_offset ;do {if ( ( cd -> flags & DETECT_CONTENT_DISTANCE ) || ( cd -> flags & DETECT_CONTENT_WITHIN ) ) {",if ( smd -> is_last ) {goto match ;,788
1113,"
","SCLogDebug ( ""no<S2SV_blank>match<S2SV_blank>for<S2SV_blank>\\\'next<S2SV_blank>sm\\\'"" ) ;",788
1114,goto no_match ;},goto no_match ;},788
1115,"if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) {SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ;","if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) {SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ;",788
1116,if ( det_ctx -> discontinue_matching )  goto no_match ;,"if ( det_ctx -> discontinue_matching ) {SCLogDebug ( ""\\\'next<S2SV_blank>sm\\\'<S2SV_blank>said<S2SV_blank>to<S2SV_blank>discontinue<S2SV_blank>this<S2SV_blank>right<S2SV_blank>now"" ) ;goto no_match ;}if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) {SCLogDebug ( ""\\\'next<S2SV_blank>sm\\\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>depend<S2SV_blank>on<S2SV_blank>me,<S2SV_blank>so<S2SV_blank>we<S2SV_blank>can<S2SV_blank>give<S2SV_blank>up"" ) ;det_ctx -> discontinue_matching = 1 ;goto no_match ;}SCLogDebug ( ""\\\'next<S2SV_blank>sm\\\'<S2SV_blank>depends<S2SV_blank>on<S2SV_blank>me<S2SV_blank>%p,<S2SV_blank>lets<S2SV_blank>see<S2SV_blank>what<S2SV_blank>we<S2SV_blank>can<S2SV_blank>do<S2SV_blank>(flags<S2SV_blank>%u)"" , cd , cd -> flags ) ;",788
1117,"}usleep ( 10000 ) ;kill ( getpid ( ) , SIGKILL ) ;","TEMP_FAILURE_RETRY ( }usleep ( 10000 ) ) ;kill ( getpid ( ) , SIGKILL ) ;",789
1118,struct trusted_key_payload * p = key -> payload . data [ 0 ] ;struct trusted_key_payload * new_p ;struct trusted_key_options * new_o ;,"struct trusted_key_payload * p ;struct trusted_key_payload * new_p ;struct trusted_key_options * new_o ;if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ;p = key -> payload . data [ 0 ] ;",790
1119,"return ( xdr_opaque ( xdrs , * objp , size ) ) ;case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ;","if ( ! xdr_opaque ( xdrs , * objp , size ) ) return FALSE ;if ( ( * objp ) [ size - 1 ] != '\\\\0' ) return FALSE ;if ( memchr ( * objp , '\\\\0' , size - 1 ) != NULL ) return FALSE ;return TRUE ;case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ;",791
1120,FreeStmt ( ( ParseCommon * ) & append ) ;return expr ;,FreeStmt ( ( ParseCommon * ) append ) ;return expr ;,792
1121,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",793
1122,avio_rl64 ( pb ) ;count = avio_rl32 ( pb ) ;avio_rl16 ( pb ) ;name_len = avio_rl16 ( pb ) ;for ( i = 0 ;i ++ )  avio_r8 ( pb ) ;int name_len ;avio_rl64 ( pb ) ;,"avio_skip ( pb , name_len ) ;for ( i = 0 ;i ++ ) avio_r8 ( pb ) ;int name_len ;if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;avio_rl64 ( pb ) ;",794
1123,"int len ;if ( ! * path ) path = ""INBOX"" ;imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ;if ( ! imapc -> mailbox )  return CURLE_OUT_OF_MEMORY ;return CURLE_OK ;","if ( ! * path ) path = ""INBOX"" ;return Curl_urldecode ( data , path , 0 , & len ) ;if ( ! imapc -> mailbox , NULL , TRUE ) ;",795
1124,if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,if ( ! npages || base_gfn != old . base_gfn ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ;,796
1125,if ( ! npages ) {struct kvm_memory_slot * slot ;,if ( ! npages ) {struct kvm_memory_slot * slot ;,796
1126,return FALSE ;},transport -> credssp = NULL ;return FALSE ;},797
1127,"if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",798
1128,"# endif rc = renameParseSql ( & sParse , zDb , 0 , db , zSql , bTemp ) ;memset ( & sWalker , 0 , sizeof ( Walker ) ) ;sWalker . pParse = & sParse ;sWalker . xExprCallback = renameColumnExprCb ;sWalker . xSelectCallback = renameColumnSelectCb ;sWalker . u . pRename = & sCtx ;sCtx . pTab = pTab ;if ( rc != SQLITE_OK ) goto renameColumnFunc_done ;if ( sParse . pNewTable ) {Select * pSelect = sParse . pNewTable -> pSelect ;if ( pSelect ) {sParse . rc = SQLITE_OK ;sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ;rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ;","# endif rc = renameParseSql ( & sParse , pSelect , 0 ) ;rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ;",799
1129,"pthread_mutex_lock ( & lock ) ;config_save ( config , CONFIG_FILE_PATH ) ;pthread_mutex_unlock ( & lock ) ;",btif_config_write ( ) ;,800
1130,"gctx = group_leader -> ctx ;mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ;}mutex_lock ( & ctx -> mutex ) ;","gctx = __perf_event_ctx_lock_double ( group_leader , ctx ) ;if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) {if ( gctx != ctx ) {err = - EINVAL ;goto err_locked ;}perf_event_ctx_unlock ( group_leader , gctx ) ;move_group = 0 ;}}}else {mutex_lock ( & ctx -> mutex ) ;",801
1131,"WARN_ON_ONCE ( move_group ) ;err = - EBUSY ;goto err_locked ;}WARN_ON_ONCE ( ctx -> parent_ctx ) ;if ( move_group ) {perf_remove_from_context ( group_leader , 0 ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_remove_from_context ( sibling , 0 ) ;put_ctx ( gctx ) ;}synchronize_rcu ( ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_event__state_init ( sibling ) ;perf_install_in_context ( ctx , sibling , sibling -> cpu ) ;get_ctx ( ctx ) ;}perf_event__state_init ( group_leader ) ;perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ;get_ctx ( ctx ) ;put_ctx ( gctx ) ;}perf_event__header_size ( event ) ;perf_event__id_header_size ( event ) ;event -> owner = current ;perf_install_in_context ( ctx , event , event -> cpu ) ;perf_unpin_context ( ctx ) ;if ( move_group )  mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;","WARN_ON_ONCE ( move_group ) perf_event_ctx_unlock ( group_leader , gctx ) ;mutex_unlock ( & ctx -> mutex ) ;",801
1132,err_locked : if ( move_group )  mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;,err_locked : if ( move_group ) mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;,801
1133,"EVP_MD_CTX_init ( & ctx ) ;if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) {","if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;return - 1 ;}EVP_MD_CTX_init ( & ctx ) ;if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) {",802
1134,"return ""DPC""  # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL )  ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT )  ""<S2SV_blank>HDRI""  # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif  ;}","return ""DPC"" # if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) ""<S2SV_blank>HDRI"" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif ;}",803
1135,"vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ;vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ;vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ;","unsigned long cr4 ;vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ;cr4 = read_cr4 ( ) ;vmcs_writel ( HOST_CR4 , cr4 ) ;vmx -> host_state . vmcs_host_cr4 = cr4 ;",804
1136,"int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd ,  int64_t * time_stamp , int64_t * time_end_stamp ,   vp9_ppflags_t * flags ) {int ret = - 1 ;if ( pbi -> ready_for_new_data == 1 ) return ret ;if ( pbi -> common . show_frame == 0 )  return ret ;* time_stamp = pbi -> last_time_stamp ;* time_end_stamp = 0 ;# if CONFIG_VP9_POSTPROC   ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ;# else  * sd = * pbi -> common . frame_to_show ;sd -> y_width = pbi -> common . width ;# endif  vp9_clear_system_state ( ) ;return ret ;","int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , vp9_ppflags_t * flags ) {VP9_COMMON * const cm = & pbi -> common ;int ret = - 1 ;# if ! CONFIG_VP9_POSTPROC ( void ) * flags ;# endif if ( pbi -> ready_for_new_data == 1 ) return ret ;if ( ! cm -> show_frame ) return ret ;pbi -> ready_for_new_data = 1 ;# if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) {ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ;}else {* sd = * cm -> frame_to_show ;ret = 0 ;}# else * sd = * pbi -> common . frame_to_show ;sd -> y_width = pbi -> common . width ;# endif vpx_clear_system_state ( ) ;return ret ;",805
1137,"dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;","err = dev_get_valid_name ( net , dev , name ) ;if ( err ) goto err_free_dev ;dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;",806
1138,"case PPP_OSI :  isoclns_print ( ndo , p , length , length ) ;break ;","case PPP_OSI : isoclns_print ( ndo , p , length , length ) ;break ;",807
1139,"SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ;int n ;if ( r -> req . aiocb != NULL ) {r -> req . aiocb = NULL ;bdrv_acct_done ( s -> bs , & r -> acct ) ;}if ( ret ) {if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) {return ;}}DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\\n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}","SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> qiov . size ) ;n = r -> iov . iov_len / 512 ;r -> sector += n ;scsi_req_data ( & r -> req , r -> iov . iov_len ) ;}",808
1140,"if ( ( cm -> current_video_frame == 0 ||  ( cm -> frame_flags & FRAMEFLAGS_KEY ) ||  rc -> frames_to_key == 0 ||  ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) {cm -> frame_type = KEY_FRAME ;rc -> frames_to_key = cpi -> key_frame_frequency ;rc -> kf_boost = DEFAULT_KF_BOOST ;rc -> source_alt_ref_active = 0 ;target = calc_iframe_target_size_one_pass_cbr ( cpi ) ;target = calc_pframe_target_size_one_pass_cbr ( cpi ) ;}vp9_rc_set_frame_target ( cpi , target ) ;rc -> frames_till_gf_update_due = INT_MAX ;rc -> baseline_gf_interval = INT_MAX ;","if ( ( cm -> current_video_frame == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) || rc -> frames_to_key == 0 || ( cpi -> oxcf . auto_key && 0 ) ) ) ) {cm -> frame_type = KEY_FRAME ;rc -> frames_to_key = cpi -> oxcf . key_freq ;rc -> kf_boost = DEFAULT_KF_BOOST ;rc -> source_alt_ref_active = 0 ;target = calc_pframe_target_size_one_pass_cbr ( cpi ) ;vp9_rc_set_frame_target ( cpi , target ) ;if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ;else cpi -> resize_pending = 0 ;",809
1141,"u8 * data , * output ;u32 pck_size , prev_pck_size ;u64 cts = GF_FILTER_NO_TS ;","u8 * data = NULL , * output ;u32 pck_size = 0 , prev_pck_size ;u64 cts = GF_FILTER_NO_TS ;",810
1142,"}data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ;if ( ctx -> timescale && pck ) {","else {}data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ;}if ( ctx -> timescale && pck ) {",810
1143,if ( radiotap_header -> it_version )  return - EINVAL ;iterator -> _rtheader = radiotap_header ;,if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ;if ( radiotap_header -> it_version ) return - EINVAL ;iterator -> _rtheader + sizeof ( uint32_t ) = radiotap_header ;,811
1144,if ( ( unsigned long ) iterator -> _arg -  ( unsigned long ) iterator -> _rtheader >  ( unsigned long ) iterator -> _max_length ) return - EINVAL ;,if ( ( unsigned long ) iterator -> _arg - ( unsigned long ) iterator -> _rtheader > ( unsigned long ) iterator -> _max_length ) return - EINVAL ;,811
1145,"
",rcu_read_lock ( ) ;,812
1146,"opt = flowlabel ? flowlabel -> opt : np -> opt ;final_p = fl6_update_dst ( & fl6 , opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","opt = flowlabel ? flowlabel -> opt : rcu_dereference ( np -> opt ) ;final_p = fl6_update_dst ( & fl6 , opt , & final ) ;rcu_read_unlock ( ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",812
1147,int pkt_len ;char line [ COSINE_LINE_LENGTH ] ;,char line [ COSINE_LINE_LENGTH ] ;,813
1148,"pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err ,  err_info ) ;","return parse_cosine_packet ( wth -> random_fh , phdr , pkt_len , buf , err , err_info ) ;",813
1149,"if ( class == BPF_ALU || class == BPF_ALU64 ) {err = check_alu_op ( env , insn ) ;","env -> insn_aux_data [ insn_idx ] . seen = true ;if ( class == BPF_ALU || class == BPF_ALU64 ) {err = check_alu_op ( env , insn ) ;",814
1150,"
",env -> insn_aux_data [ insn_idx ] . seen = true ;,814
1151,"}verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\\","}verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\\",814
1152,int i ;int j ;int rowstep ;jas_seqent_t * data ;,jas_matind_t i ;jas_matind_t j ;jas_matind_t rowstep ;jas_seqent_t * data ;,815
1153,"Huff_transmit ( & huff , ch , seq ) ;Huff_addRef ( & huff , ( byte ) ch ) ;","Huff_transmit ( & huff , ch , seq , size << 3 ) ;Huff_addRef ( & huff , ( byte ) ch ) ;",816
1154,"( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) {","( void ) TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & shortv ) ;if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) {",817
1155,"# define ThrowPICTException ( exception , message ) {}char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;","# define ThrowPICTException ( exception , message ) \\\\\\\\\\char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;",818
1156,if ( length != 0x000a )  {,"if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length != 0x000a ) {",818
1157,"
","if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",818
1158,"if ( ReadRectangle ( image , & frame ) == MagickFalse )  ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;",818
1159,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,"if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;length = ReadBlobMSBShort ( image ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;for ( i = 0 ;",818
1160,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,818
1161,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,818
1162,if ( length == 0 )  break ;,if ( length == 0 ) break ;,818
1163,if ( length > 154 )  {,if ( length > 154 ) {,818
1164,for ( i = 0 ;i ++ )  if ( ReadBlobByte ( image ) == EOF ) break ;for ( i = 0 ;i ++ )  if ( ReadBlobByte ( image ) == EOF ) break ;,"for ( i = 0 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;for ( i = 0 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;",818
1165,"stmt_ty  Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int  end_lineno , int end_col_offset , PyArena * arena ) {","stmt_ty Assign ( asdl_seq * targets , expr_ty value , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",819
1166,p -> lineno = lineno ;p -> col_offset = col_offset ;,p -> v . Assign . type_comment = type_comment ;p -> lineno = lineno ;p -> col_offset = col_offset ;,819
1167,if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 4 ;}if ( context -> curY >= p -> height ) {context -> pass ++ ;if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 1 ;}break ;},if ( context -> curY >= p -> height ) {context -> pass ++ ;break ;}while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) {switch ( ++ context -> pass ) {case 2 : context -> curY = i -> posY + 4 ;break ;case 3 : context -> curY = i -> posY + 2 ;break ;case 4 : context -> curY = i -> posY + 1 ;break ;}},820
1168,"static void do_perf_sw_event ( enum perf_type_id type , u32 event_id ,  u64 nr , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , u64 nr , struct perf_sample_data * data , struct pt_regs * regs ) {",821
1169,"if ( perf_swevent_match ( event , type , event_id , data , regs ) )  perf_swevent_event ( event , nr , nmi , data , regs ) ;}","if ( perf_swevent_match ( event , type , event_id , data , regs ) ) perf_swevent_event ( event , nr , data , regs ) ;}",821
1170,"uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) {uint32_t ret_cnt = 0 ;if ( event_data [ 0 ] >= 0x80 ) {command = * event_data & 0xf0 ;ret_cnt ++ ;}case 0x80 : _SETUP_NOTEOFF :  data_1 = * event_data ++ ;data_2 = * event_data ++ ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;case 0xa0 :  data_1 = * event_data ++ ;data_2 = * event_data ++ ;case 0xb0 :  data_1 = * event_data ++ ;data_2 = * event_data ++ ;","uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint32_t siz , uint8_t running_event ) {uint32_t ret_cnt = 0 ;if ( ! siz ) goto shortbuf ;if ( event_data [ 0 ] >= 0x80 ) {command = * event_data & 0xf0 ;ret_cnt ++ ;if ( -- siz == 0 ) goto shortbuf ;}case 0x80 : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;case 0xa0 : if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;case 0xb0 : if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;",822
1171,"case 0xe0 :  data_1 = * event_data ++ ;data_2 = * event_data ++ ;midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ;ret_cnt += 4 ;if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","case 0xe0 : if ( siz < 2 ) goto shortbuf ;data_1 = * event_data ++ ;data_2 = * event_data ++ ;if ( siz < 4 ) goto shortbuf ;midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ;ret_cnt += 4 ;if ( -- siz && * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1172,if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;if ( mdi -> extra_info . copyright ) {,if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;if ( -- siz && -- siz < tmp_length ) goto shortbuf ;if ( ! tmp_length ) break ;if ( mdi -> extra_info . copyright ) {,822
1173,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1174,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1175,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1176,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( -- siz && ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;",822
1177,"if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;}midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ;midi_setup_portprefix ( mdi , event_data [ 2 ] ) ;ret_cnt += 3 ;_WM_midi_setup_endoftrack ( mdi ) ;ret_cnt += 2 ;_WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ;ret_cnt += 5 ;}midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ;midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ;ret_cnt += 6 ;midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ;ret_cnt += 4 ;if ( * event_data > 0x7f ) {do {tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;ret_cnt ++ ;}}tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;}}do {sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ;ret_cnt ++ ;}}sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ;if ( ! sysex_len ) break ;ret_cnt ++ ;","if ( * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;if ( ! tmp_length ) break ;text = malloc ( tmp_length + 1 ) ;memcpy ( text , event_data , tmp_length ) ;}if ( siz < 3 ) goto shortbuf ;midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ;if ( siz < 3 ) goto shortbuf ;midi_setup_portprefix ( mdi , event_data [ 2 ] ) ;ret_cnt += 3 ;if ( siz < 2 ) goto shortbuf ;_WM_midi_setup_endoftrack ( mdi ) ;ret_cnt += 2 ;if ( siz < 5 ) goto shortbuf ;_WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ;ret_cnt += 5 ;}if ( siz < 7 ) goto shortbuf ;midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ;if ( siz < 6 ) goto shortbuf ;midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ;ret_cnt += 6 ;if ( siz < 4 ) goto shortbuf ;midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ;ret_cnt += 4 ;if ( -- siz && * event_data > 0x7f ) {do {if ( ! siz ) break ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ;if ( -- siz < tmp_length ) goto shortbuf ;}}do {if ( ! siz ) break ;sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ;siz -- ;ret_cnt ++ ;}}if ( ! siz ) goto shortbuf ;sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ;ret_cnt ++ ;if ( -- siz < sysex_len ) goto shortbuf ;if ( ! sysex_len ) break ;",822
1178,},"shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ;return 0 ;}",822
1179,"sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ;outfile = fopen ( outfilename , ""wb"" ) ;","int num = snprintf ( outfilename , sizeof ( outfilename ) , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ;if ( num >= sizeof ( outfilename ) ) {fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\\return 1 ;}outfile = fopen ( outfilename , ""wb"" ) ;",823
1180,"memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;","rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;",824
1181,"if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & target , arena ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""target\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & iter , arena ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""iter\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ;","if ( lookup_attr_id ( obj , & PyId_target ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_target , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""target\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;return 1 ;}else {int res ;res = obj2ast_expr ( tmp , & target , arena ) ;}if ( lookup_attr_id ( obj , & PyId_iter ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_iter , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""iter\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;else {int res ;res = obj2ast_expr ( tmp , & iter , arena ) ;}if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""ifs\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;return 1 ;}else {Py_ssize_t i ;",825
1182,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( ifs , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""ifs\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & is_async , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {","expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( ifs , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_is_async ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_is_async , & tmp ) < 0 ) {if ( tmp == NULL ) {else {int res ;res = obj2ast_int ( tmp , & is_async , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",825
1183,"hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;nexthdr = * prevhdr ;","hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ;if ( hlen < 0 ) {err = hlen ;goto fail ;}nexthdr = * prevhdr ;",826
1184,"static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x ,  const TileInfo * const tile ,  BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) {VP9_COMMON * cm = & cpi -> common ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = {0 }int bestsme = INT_MAX ;int further_steps , step_param ;int sadpb = x -> sadperbit16 ;MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ;int tmp_col_min = x -> mv_col_min ;int tmp_row_max = x -> mv_row_max ;const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ;pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ;pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ;pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ;if ( scaled_ref_frame ) {","static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) {const VP9_COMMON * cm = & cpi -> common ;MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = {0 , 0 }int bestsme = INT_MAX ;int step_param ;int sadpb = x -> sadperbit16 ;MV ref_mv = x -> mbmi_ext -> ref_mvs [ ref ] [ 0 ] . as_mv ;int tmp_col_min = x -> mv_col_min ;int tmp_row_max = x -> mv_row_max ;int cost_list [ 5 ] ;const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ;pred_mv [ 0 ] = x -> mbmi_ext -> ref_mvs [ ref ] [ 0 ] . as_mv ;pred_mv [ 1 ] = x -> mbmi_ext -> ref_mvs [ ref ] ;if ( scaled_ref_frame ) {",827
1185,"if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) {step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) +   cpi -> mv_step_param ) >> 1 ;}if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 &&  cpi -> common . show_frame ) {int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) ,  b_width_log2 ( bsize ) ) ) ;int bhl = b_height_log2_lookup [ bsize ] ;int i ;for ( i = LAST_FRAME ;i <= ALTREF_FRAME && cpi -> common . show_frame ;if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) {x -> pred_mv [ ref ] . as_int = 0 ;tmp_mv -> as_int = INVALID_MV ;for ( i = 0 ;i ++ )  xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ;return ;}mvp_full . row >>= 3 ;further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ;if ( cpi -> sf . search_method == FAST_DIAMOND ) {if ( bestsme < INT_MAX )  bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv ,   & cpi -> fn_ptr [ bsize ] , 1 ) ;}else if ( cpi -> sf . search_method == FAST_HEX ) {bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ;if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ;}else if ( cpi -> sf . search_method == HEX ) {bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ;else if ( cpi -> sf . search_method == SQUARE ) {else if ( cpi -> sf . search_method == BIGDIA ) {bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ;if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ;}else {bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , sadpb , further_steps , 1 , & cpi -> fn_ptr [ bsize ] , & ref_mv , & tmp_mv -> as_mv ) ;x -> mv_col_min = tmp_col_min ;x -> mv_col_max = tmp_col_max ;x -> mv_row_min = tmp_row_min ;x -> mv_row_max = tmp_row_max ;if ( bestsme < INT_MAX ) {int dis ;cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . subpel_force_stop , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost ,  & dis , & x -> pred_sse [ ref ] ) ;}if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame )   x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ;if ( scaled_ref_frame ) {","if ( cpi -> sf . mv . auto_mv_step_size && cm -> show_frame ) {step_param = ( vp9_init_search_range ( x -> max_mv_context [ ref ] ) + cpi -> mv_step_param ) / 2 ;}if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 ) {int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] ) ) ;if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) {int i ;for ( i = LAST_FRAME ;i <= ALTREF_FRAME && cm -> show_frame ;if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) {x -> pred_mv [ ref ] . row = 0 ;x -> pred_mv [ ref ] . col = 0 ;tmp_mv -> as_int = INVALID_MV ;for ( i = 0 ;++ i ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ;}return ;}bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ;x -> mv_col_min = tmp_col_min ;x -> mv_col_max = tmp_col_max ;x -> mv_row_min = tmp_row_min ;x -> mv_row_max = tmp_row_max ;if ( cpi -> sf . search_method == FAST_DIAMOND ) {if ( bestsme < INT_MAX ) {int dis ;cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . search_method == FAST_HEX ) {bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ;else if ( cpi -> sf . mv . subpel_force_stop , cpi -> sf . search_method == SQUARE ) {else if ( cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref ] , NULL , 0 , 0 ) ;if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ;if ( scaled_ref_frame ) {",827
1186,u16 offset = sizeof ( struct ipv6hdr ) ;unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,unsigned int offset = sizeof ( struct ipv6hdr ) ;unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ;unsigned int len ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,828
1187,offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;,len = ipv6_optlen ( exthdr ) ;if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ;offset += len ;* nexthdr = & exthdr -> nexthdr ;,828
1188,"memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ;memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name ,  sizeof ( ualg -> cru_driver_name ) ) ;memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) ,   CRYPTO_MAX_ALG_NAME ) ;ualg -> cru_flags = alg -> cra_flags ;snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;","strncpy ( ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ;strncpy ( ualg -> cru_driver_name , & alg -> cra_driver_name , sizeof ( ualg -> cru_driver_name ) ) ;strncpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ;ualg -> cru_type = 0 ;ualg -> cru_mask = 0 ;ualg -> cru_flags = alg -> cra_flags ;strncpy ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ;",829
1189,"
","if ( is_url ( source ) ) {pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ;goto error ;}",830
1190,"if ( ( fp = pcap_open_live ( source ,  1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ;","if ( ( fp = pcap_open_live ( source , 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ;",830
1191,"imap_quote_string ( dest , dlen , buf ) ;FREE ( & buf ) ;","imap_quote_string ( dest , dlen , buf , false ) ;FREE ( & buf ) ;",831
1192,"static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt ,  u16 selector , int seg , u8 cpl , bool in_task_switch )  {","static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg , u8 cpl , bool in_task_switch , struct desc_struct * desc ) {",832
1193,"
",if ( desc ) * desc = seg_desc ;,832
1194,"return X86EMUL_CONTINUE ;exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ;","return X86EMUL_CONTINUE ;exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ;",832
1195,"struct blkif_response resp ;unsigned long flags ;resp . id = id ;resp . operation = op ;resp . status = st ;case BLKIF_PROTOCOL_NATIVE :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;case BLKIF_PROTOCOL_X86_32 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;case BLKIF_PROTOCOL_X86_64 :  memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ,  & resp , sizeof ( resp ) ) ;}blk_rings -> common . rsp_prod_pvt ++ ;","struct blkif_response * resp ;unsigned long flags ;case BLKIF_PROTOCOL_NATIVE : resp = RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) ;case BLKIF_PROTOCOL_X86_32 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) ;case BLKIF_PROTOCOL_X86_64 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) ;}resp -> id = id ;resp -> operation = op ;resp -> status = st ;blk_rings -> common . rsp_prod_pvt ++ ;",833
1196,"fprintf ( dump , ""%s"" , sdp ) ;fprintf ( dump , ""\\\\r\\\","if ( sdp && size ) fprintf ( dump , ""%s"" , sdp ) ;fprintf ( dump , ""\\\\r\\\",834
1197,entry . uncompressed_filesize = PHAR_GET_32 ( zipentry . uncompsize ) ;,entry . uncompressed_filesize || read <= 8 = PHAR_GET_32 ( zipentry . uncompsize ) ;,835
1198,if ( read != entry . uncompressed_filesize ) {php_stream_close ( sigfile ) ;,if ( read != entry . uncompressed_filesize ) {php_stream_close ( sigfile ) ;,835
1199,r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ;r1 . tstamp = tstamp ;,"memset ( & r1 , 0 , sizeof ( r1 ) ) ;r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ;r1 . tstamp = tstamp ;",0
1200,"ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata ,   ext4_get_block ) ;if ( ! ret && ext4_should_journal_data ( inode ) ) {","if ( ext4_should_dioread_nolock ( inode ) ) ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , ext4_get_block_write ) ;else ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , ext4_get_block ) ;if ( ! ret && ext4_should_journal_data ( inode ) ) {",1
1201,"int16_t vp9_ac_quant ( int qindex , int delta ) {return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;}","int16_t vp9_ac_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) {# if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) {case VPX_BITS_8 : return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;case VPX_BITS_10 : return ac_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ;case VPX_BITS_12 : return ac_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ;default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ;return - 1 ;}# else ( void ) bit_depth ;return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;# endif }",2
1202,"int  add_mibfile ( const char * tmpstr , const char * d_name , FILE * ip )  {return 1 ;}DEBUGMSGTL ( ( ""parse-mibs"" , ""Checking<S2SV_blank>file:<S2SV_blank>%s...\\\mibLine = 1 ;File = tmpstr ;if ( get_token ( fp , token , MAXTOKEN ) != LABEL ) {if ( ip )  fprintf ( ip , ""%s<S2SV_blank>%s\\\","int add_mibfile ( const char * tmpstr , const char * d_name ) {if ( ip ) fprintf ( ip , ""%s<S2SV_blank>%s\\\",3
1203,"if ( wp -> listening_socket != STDIN_FILENO ) {if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) {zlog ( ZLOG_SYSERROR , ""failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>child<S2SV_blank>stdio:<S2SV_blank>dup2()"" ) ;return - 1 ;}}","
",4
1204,"int i , retval ;bzrtpPacket_t * zrtpPacket ;bzrtpContext_t * context87654321 = bzrtp_createBzrtpContext ( 0x87654321 ) ;bzrtpContext_t * context12345678 = bzrtp_createBzrtpContext ( 0x12345678 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 0 ] , H12345678 [ 0 ] , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 1 ] , H12345678 [ 1 ] , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 2 ] , H12345678 [ 2 ] , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 3 ] , H12345678 [ 3 ] , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 0 ] , H87654321 [ 0 ] , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 1 ] , H87654321 [ 1 ] , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 2 ] , H87654321 [ 2 ] , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 3 ] , H87654321 [ 3 ] , 32 ) ;context87654321 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ;context12345678 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ;context87654321 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ;context12345678 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ;context87654321 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256 ;context12345678 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256 ;updateCryptoFunctionPointers ( context87654321 -> channelContext [ 0 ] ) ;updateCryptoFunctionPointers ( context12345678 -> channelContext [ 0 ] ) ;context87654321 -> channelContext [ 0 ] -> mackeyi = ( uint8_t * ) malloc ( 32 ) ;context12345678 -> channelContext [ 0 ] -> mackeyi = ( uint8_t * ) malloc ( 32 ) ;context87654321 -> channelContext [ 0 ] -> mackeyr = ( uint8_t * ) malloc ( 32 ) ;context12345678 -> channelContext [ 0 ] -> mackeyr = ( uint8_t * ) malloc ( 32 ) ;context87654321 -> channelContext [ 0 ] -> zrtpkeyi = ( uint8_t * ) malloc ( 16 ) ;context12345678 -> channelContext [ 0 ] -> zrtpkeyi = ( uint8_t * ) malloc ( 16 ) ;context87654321 -> channelContext [ 0 ] -> zrtpkeyr = ( uint8_t * ) malloc ( 16 ) ;context12345678 -> channelContext [ 0 ] -> zrtpkeyr = ( uint8_t * ) malloc ( 16 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> mackeyi , mackeyi , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> mackeyr , mackeyr , 32 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> zrtpkeyi , zrtpkeyi , 16 ) ;memcpy ( context12345678 -> channelContext [ 0 ] -> zrtpkeyr , zrtpkeyr , 16 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> mackeyi , mackeyi , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> mackeyr , mackeyr , 32 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> zrtpkeyi , zrtpkeyi , 16 ) ;memcpy ( context87654321 -> channelContext [ 0 ] -> zrtpkeyr , zrtpkeyr , 16 ) ;context12345678 -> channelContext [ 0 ] -> role = RESPONDER ;for ( i = 0 ;i < TEST_PACKET_NUMBER ;i ++ ) {uint8_t freePacketFlag = 1 ;zrtpPacket = bzrtp_packetCheck ( patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] , ( patternZRTPMetaData [ i ] [ 1 ] ) - 1 , & retval ) ;retval += bzrtp_packetParser ( ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) ? context12345678 : context87654321 , ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) ? context12345678 -> channelContext [ 0 ] : context87654321 -> channelContext [ 0 ] , patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] , zrtpPacket ) ;if ( zrtpPacket -> messageType == MSGTYPE_HELLO ) {if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) {context12345678 -> channelContext [ 0 ] -> peerPackets [ HELLO_MESSAGE_STORE_ID ] = zrtpPacket ;}else {context87654321 -> channelContext [ 0 ] -> peerPackets [ HELLO_MESSAGE_STORE_ID ] = zrtpPacket ;}freePacketFlag = 0 ;}if ( zrtpPacket -> messageType == MSGTYPE_COMMIT ) {if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) {context12345678 -> channelContext [ 0 ] -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] = zrtpPacket ;}else {context87654321 -> channelContext [ 0 ] -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] = zrtpPacket ;}freePacketFlag = 0 ;}if ( zrtpPacket -> messageType == MSGTYPE_DHPART1 || zrtpPacket -> messageType == MSGTYPE_DHPART2 ) {if ( patternZRTPMetaData [ i ] [ 2 ] == 0x87654321 ) {context12345678 -> channelContext [ 0 ] -> peerPackets [ DHPART_MESSAGE_STORE_ID ] = zrtpPacket ;}else {context87654321 -> channelContext [ 0 ] -> peerPackets [ DHPART_MESSAGE_STORE_ID ] = zrtpPacket ;}freePacketFlag = 0 ;}free ( zrtpPacket -> packetString ) ;retval = bzrtp_packetBuild ( ( patternZRTPMetaData [ i ] [ 2 ] == 0x12345678 ) ? context12345678 : context87654321 , ( patternZRTPMetaData [ i ] [ 2 ] == 0x12345678 ) ? context12345678 -> channelContext [ 0 ] : context87654321 -> channelContext [ 0 ] , zrtpPacket , patternZRTPMetaData [ i ] [ 1 ] ) ;if ( zrtpPacket -> packetString != NULL ) {CU_ASSERT_TRUE ( memcmp ( zrtpPacket -> packetString , patternZRTPPackets [ i ] , patternZRTPMetaData [ i ] [ 0 ] ) == 0 ) ;}else {CU_FAIL ( ""Unable<S2SV_blank>to<S2SV_blank>build<S2SV_blank>packet"" ) ;}if ( freePacketFlag == 1 ) {bzrtp_freeZrtpPacket ( zrtpPacket ) ;}}bzrtp_destroyBzrtpContext ( context87654321 , 0x87654321 ) ;bzrtp_destroyBzrtpContext ( context12345678 , 0x12345678 ) ;",test_parser_param ( 0 ) ;,5
1205,"assert ( c != NULL ) ;if ( c -> rcurr != c -> rbuf ) {if ( c -> rbytes >= c -> rsize ) {char * new_rbuf = realloc ( c -> rbuf , c -> rsize * 2 ) ;","int num_allocs = 0 ;assert ( c != NULL ) ;if ( c -> rcurr != c -> rbuf ) {if ( c -> rbytes >= c -> rsize ) {if ( num_allocs == 4 ) {return gotdata ;}++ num_allocs ;char * new_rbuf = realloc ( c -> rbuf , c -> rsize * 2 ) ;",6
1206,"Rd_WP_DWORD ( image , & Rec . RecordLength ) ;if ( EOFBlob ( image ) ) break ;","Rd_WP_DWORD ( image , & Rec . RecordLength ) ;if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( EOFBlob ( image ) ) break ;",7
1207,"int len , err = - ENOBUFS ;int alloc_min_size ;","struct module * module ;int len , err = - ENOBUFS ;int alloc_min_size ;",8
1208,mutex_unlock ( nlk -> cb_mutex ) ;module_put ( cb -> module ) ;consume_skb ( cb -> skb ) ;return 0 ;,module = cb -> module ;skb = cb -> skb ;mutex_unlock ( nlk -> cb_mutex ) ;module_put ( module ) ;consume_skb ( cb -> skb ) ;return 0 ;,8
1209,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",9
1210,"
",if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) {PUSH_ENV ( HTML_DL ) ;},10
1211,"if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) {if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ;","if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) {if ( obuf -> pos > envs [ h_env -> envc ] . indent ) flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ;",10
1212,if ( * p ) {if ( p [ 0 ] == \'@\' ) {,char op0 = 0 ;if ( * p ) {if ( p [ 0 ] == \'@\' ) {,11
1213,* q = 0 ;},op0 = * q ;* q = 0 ;},11
1214,"cmd = p + 1 ;cmd = p + 1 ;}* p = \\\'""\\\' ;cmd = p ;",cmd = p ;cmd = p + 1 ;}* p = op0 ;cmd = p ;,11
1215,return AUTH_FOUND ;},fclose ( opwfile ) ;return AUTH_FOUND ;},12
1216,return parser_flags ;},if ( flags -> cf_flags & PyCF_TYPE_COMMENTS ) parser_flags |= PyPARSE_TYPE_COMMENTS ;return parser_flags ;},13
1217,"
",ND_TCHECK ( bp -> bp_flags ) ;,14
1218,"ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" ,  bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ;","ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ;",14
1219,"if ( cid <= 0 )  continue ;dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( dctx -> remaining <= 0 ) {dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( dctx -> remaining <= 0 )   return dctx -> remaining ;}","int remaining ;if ( cid <= 0 ) continue ;remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( remaining <= 0 ) {dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( remaining <= 0 ) return dctx -> remaining ;}",15
1220,blockcnt = ( ( len + pos ) + blocksize - 1 ) >>  ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ;,if ( len < 1 || len == 0xffffffff ) {return - 1 ;}blockcnt = ( ( len + pos ) + blocksize - 1 ) >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ;,16
1221,int expected_count = 1 + extra_count ;void * * pslot ;,"struct zone * oldzone , * newzone ;int dirty ;int expected_count = 1 + extra_count ;void * * pslot ;",17
1222,}spin_lock_irq ( & mapping -> tree_lock ) ;,}oldzone = page_zone ( page ) ;newzone = page_zone ( newpage ) ;spin_lock_irq ( & mapping -> tree_lock ) ;,17
1223,"radix_tree_replace_slot ( pslot , newpage ) ;page_unfreeze_refs ( page , expected_count - 1 ) ;__dec_zone_page_state ( page , NR_FILE_PAGES ) ;__inc_zone_page_state ( newpage , NR_FILE_PAGES ) ;if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) {__dec_zone_page_state ( page , NR_SHMEM ) ;__inc_zone_page_state ( newpage , NR_SHMEM ) ;spin_unlock_irq ( & mapping -> tree_lock ) ;","dirty = PageDirty ( page ) ;if ( dirty ) {ClearPageDirty ( page ) ;SetPageDirty ( newpage ) ;radix_tree_replace_slot ( pslot , newpage ) ;page_unfreeze_refs ( page , expected_count - 1 ) ;spin_unlock ( & mapping -> tree_lock ) ;if ( newzone != oldzone ) {__dec_zone_state ( oldzone , NR_FILE_PAGES ) ;__inc_zone_state ( newzone , NR_FILE_PAGES ) ;if ( PageSwapBacked ( page ) ) {__dec_zone_state ( oldzone , NR_SHMEM ) ;__inc_zone_state ( newzone , NR_SHMEM ) ;}if ( dirty && mapping_cap_account_dirty ( mapping ) ) {__dec_zone_state ( oldzone , NR_FILE_DIRTY ) ;__inc_zone_state ( newzone , NR_FILE_DIRTY ) ;}}local_irq_enable ( ) ;",17
1224,"guint32 off = offset ;guint32 len ;DebugLog ( ( ""parse_wbxml_attr_defined<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\while ( off < tvb_len ) {","guint32 off = offset , last_off ;guint32 len ;DebugLog ( ( ""parse_wbxml_attr_defined<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\last_off = off ;while ( off < tvb_len ) {",18
1225,"
",if ( off < last_off ) {THROW ( ReportedBoundsError ) ;}last_off = off ;,18
1226,"}DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\","}DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\",18
1227,"Stream_Read_UINT32 ( s , scopeCount ) ;scopeList -> count = scopeCount ;","Stream_Read_UINT32 ( s , scopeCount ) ;if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE ;scopeList -> count = scopeCount ;",19
1228,"count = be32_to_cpu ( aclp -> acl_cnt ) ;acl = posix_acl_alloc ( count , GFP_KERNEL ) ;","count = be32_to_cpu ( aclp -> acl_cnt ) ;if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ;acl = posix_acl_alloc ( count , GFP_KERNEL ) ;",20
1229,# ifdef KEY_DEBUGGING  key -> magic = KEY_DEBUG_MAGIC ;,if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;# ifdef KEY_DEBUGGING key -> magic = KEY_DEBUG_MAGIC ;,21
1230,if ( ! send && ! SSL_USE_ETM ( ssl ) &&  EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) {,if ( ! send && ! SSL_READ_ETM ( ssl ) && EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) {,22
1231,"if ( ! send && ! SSL_USE_ETM ( ssl ) && FIPS_mode ( ) )  if ( ! tls_fips_digest_extra ( ssl -> enc_read_ctx , mac_ctx , rec -> input , rec -> length , rec -> orig_len ) ) {","if ( ! send && ! SSL_READ_ETM ( ssl ) && FIPS_mode ( ) ) if ( ! tls_fips_digest_extra ( ssl -> enc_read_ctx , mac_ctx , rec -> input , rec -> length , rec -> orig_len ) ) {",22
1232,int retval ;int remount_ro ;if ( sb -> s_writers . frozen != SB_UNFROZEN ) return - EBUSY ;# ifdef CONFIG_BLOCK if ( ! ( flags & MS_RDONLY ) && bdev_read_only ( sb -> s_bdev ) ) return - EACCES ;# endif if ( flags & MS_RDONLY ) acct_auto_close ( sb ) ;shrink_dcache_sb ( sb ) ;sync_filesystem ( sb ) ;remount_ro = ( flags & MS_RDONLY ) && ! ( sb -> s_flags & MS_RDONLY ) ;if ( remount_ro ) {if ( force ) {mark_files_ro ( sb ) ;},sb -> s_readonly_remount = 1 ;smp_wmb ( ) ;},23
1233,g_object_unref ( subdir ) ;dir = GSF_INFILE_TAR ( subdir ) ;},dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ;g_object_unref ( subdir ) ;},24
1234,"int i ;memset ( cfg , 0 , sizeof ( cfg_t ) ) ;","struct stat st ;FILE * file = NULL ;int fd = - 1 ;int i ;memset ( cfg , 0 , sizeof ( cfg_t ) ) ;",25
1235,"struct stat st ;FILE * file ;if ( lstat ( filename , & st ) == 0 ) {if ( S_ISREG ( st . st_mode ) ) {file = fopen ( filename , ""a"" ) ;if ( file != NULL ) {}}","fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ;if ( fd >= 0 && ( fstat ( fd , & st ) == 0 ) && S_ISREG ( st . st_mode ) ) {file = fdopen ( fd , ""a"" ) ;if ( file != NULL ) {cfg -> is_custom_debug_file = 1 ;file = NULL ;fd = - 1 ;}}",25
1236,"
",if ( fd != - 1 ) close ( fd ) ;if ( file != NULL ) fclose ( file ) ;,25
1237,},},25
1238,RBinWasmGlobalEntry * ptr = NULL ;int buflen = bin -> buf -> length ;if ( sec -> payload_data + 32 > buflen ) {return NULL ;},RBinWasmGlobalEntry * ptr = NULL ;int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ;,26
1239,gdFree ( tmp_im ) ;},gdImageDestroy ( tmp_im ) ;},27
1240,if ( SCTP_CID_SHUTDOWN_ACK == ch -> type )  ootb_shut_ack = 1 ;,"ch_end = ( ( __u8 * ) ch ) + SCTP_PAD4 ( ntohs ( ch -> length ) ) ;if ( ch_end > skb_tail_pointer ( skb ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ;if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ;",28
1241,"ch_end = ( ( __u8 * ) ch ) + SCTP_PAD4 ( ntohs ( ch -> length ) ) ;if ( ch_end > skb_tail_pointer ( skb ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ;ch = ( sctp_chunkhdr_t * ) ch_end ;}",ch = ( sctp_chunkhdr_t * ) ch_end ;},28
1242,"static vpx_codec_err_t ctrl_set_scale_mode ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vpx_scaling_mode_t * const mode = va_arg ( args , vpx_scaling_mode_t * ) ;","static vpx_codec_err_t ctrl_set_scale_mode ( vpx_codec_alg_priv_t * ctx , va_list args ) {vpx_scaling_mode_t * const mode = va_arg ( args , vpx_scaling_mode_t * ) ;",29
1243,"if ( len < 0 )  goto unlock ;l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , len , rsp ) ;l2cap_pi ( sk ) -> conf_len = 0 ;","if ( len < 0 ) {struct l2cap_disconn_req req ;req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ;req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ;l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ;goto unlock ;}l2cap_send_cmd ( conn , cmd -> ident , L2CAP_CONF_RSP , len , rsp ) ;l2cap_pi ( sk ) -> num_conf_rsp ++ ;l2cap_pi ( sk ) -> conf_len = 0 ;",30
1244,}unlock : bh_unlock_sock ( sk ) ;,l2cap_pi ( sk ) -> num_conf_req ++ ;}unlock : bh_unlock_sock ( sk ) ;,30
1245,"static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de ,  struct inode * inode , int regard_xa )  {int cnt , sig ;struct inode * reloc ;if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ;init_rock_state ( & rs , inode ) ;setup_rock_ridge ( de , inode , & rs ) ;if ( regard_xa ) {rs . chr += 14 ;","static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , struct inode * inode , int flags ) {int cnt , sig ;unsigned int reloc_block ;struct inode * reloc ;if ( flags & RR_REGARD_XA ) {rs . chr += 14 ;",31
1246,"case SIG ( \'S\' , \'L\' ) : {","case SIG ( \'S\' , \'L\' ) : if ( flags & RR_RELOC_DE ) {printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\\goto eio ;}reloc_block = isonum_733 ( rr -> u . CL . location ) ;if ( reloc_block == {",31
1247,"case SIG ( \'C\' , \'L\' ) :  ISOFS_I ( inode ) -> i_first_extent =  isonum_733 ( rr -> u . CL . location ) ;reloc =  isofs_iget ( inode -> i_sb ,   ISOFS_I ( inode ) -> i_first_extent ,  0 ) ;","case SIG ( \'C\' , \'L\' ) : ISOFS_I ( inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) {printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\\goto eio ;}ISOFS_I ( inode ) -> i_first_extent = reloc_block ;reloc = isofs_iget_reloc ( inode -> i_sb , ISOFS_I ( inode ) -> i_first_extent , 0 ) ;",31
1248,"struct variable_list * vb ;const data_set_t * ds ;size_t oid_list_len = data -> values_len + 1 ;oid_t oid_list [ oid_list_len ] ;_Bool oid_list_todo [ oid_list_len ] ;int status ;size_t i ;csnmp_list_instances_t * instance_list_head ;csnmp_list_instances_t * instance_list_tail ;csnmp_table_values_t * * value_list_head ;csnmp_table_values_t * * value_list_tail ;DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table<S2SV_blank>(host<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>data<S2SV_blank>=<S2SV_blank>%s)"" , host -> name , data -> name ) ;if ( host -> sess_handle == NULL ) {DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table:<S2SV_blank>host->sess_handle<S2SV_blank>==<S2SV_blank>NULL"" ) ;return ( - 1 ) ;}ds = plugin_get_ds ( data -> type ) ;if ( ! ds ) {ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>DataSet<S2SV_blank>`%s\\\'<S2SV_blank>not<S2SV_blank>defined."" , data -> type ) ;return ( - 1 ) ;}if ( ds -> ds_num != data -> values_len ) {ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>DataSet<S2SV_blank>`%s\\\'<S2SV_blank>requires<S2SV_blank>%zu<S2SV_blank>values,<S2SV_blank>but<S2SV_blank>config<S2SV_blank>talks<S2SV_blank>"" ""about<S2SV_blank>%zu"" , data -> type , ds -> ds_num , data -> values_len ) ;return ( - 1 ) ;}assert ( data -> values_len > 0 ) ;memcpy ( oid_list , data -> values , data -> values_len * sizeof ( oid_t ) ) ;if ( data -> instance . oid . oid_len > 0 ) memcpy ( oid_list + data -> values_len , & data -> instance . oid , sizeof ( oid_t ) ) ;else oid_list_len -- ;for ( i = 0 ;i < oid_list_len ;i ++ ) oid_list_todo [ i ] = 1 ;value_list_head = calloc ( data -> values_len , sizeof ( * value_list_head ) ) ;value_list_tail = calloc ( data -> values_len , sizeof ( * value_list_tail ) ) ;if ( ( value_list_head == NULL ) || ( value_list_tail == NULL ) ) {ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>csnmp_read_table:<S2SV_blank>calloc<S2SV_blank>failed."" ) ;sfree ( value_list_head ) ;sfree ( value_list_tail ) ;return ( - 1 ) ;}instance_list_head = NULL ;instance_list_tail = NULL ;status = 0 ;while ( status == 0 ) {int oid_list_todo_num ;req = snmp_pdu_create ( SNMP_MSG_GETNEXT ) ;if ( req == NULL ) {ERROR ( ""snmp<S2SV_blank>plugin:<S2SV_blank>snmp_pdu_create<S2SV_blank>failed."" ) ;status = - 1 ;break ;}oid_list_todo_num = 0 ;for ( i = 0 ;i < oid_list_len ;i ++ ) {if ( ! oid_list_todo [ i ] ) continue ;oid_list_todo_num ++ ;snmp_add_null_var ( req , oid_list [ i ] . oid , oid_list [ i ] . oid_len ) ;}if ( oid_list_todo_num == 0 ) {DEBUG ( ""snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree"" ) ;status = 0 ;break ;}res = NULL ;status = snmp_sess_synch_response ( host -> sess_handle , req , & res ) ;if ( ( status != STAT_SUCCESS ) || ( res == NULL ) ) {char * errstr = NULL ;snmp_sess_error ( host -> sess_handle , NULL , NULL , & errstr ) ;c_complain ( LOG_ERR , & host -> complaint , ""snmp<S2SV_blank>plugin:<S2SV_blank>host<S2SV_blank>%s:<S2SV_blank>snmp_sess_synch_response<S2SV_blank>failed:<S2SV_blank>%s"" , host -> name , ( errstr == NULL ) ? ""Unknown<S2SV_blank>problem"" : errstr ) ;if ( res != NULL ) snmp_free_pdu ( res ) ;res = NULL ;req = NULL ;sfree ( errstr ) ;",sfree ( errstr ) ;,32
1249,if ( req != NULL )  snmp_free_pdu ( req ) ;req = NULL ;,"
",32
1250,"int res ;const void * data ;int len ;u_int32_t vendor ;if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) {return ;res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ;if ( res == - 1 ) {add_assoc_long ( return_value , ""attr"" , res ) ;add_assoc_long ( return_value , ""vendor"" , vendor ) ;add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ;return ;","const void * data , * raw ;int len ;u_int32_t vendor ;unsigned char type ;size_t data_len ;if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & raw , & len ) == FAILURE ) {return ;if ( rad_get_vendor_attr ( & vendor , & type , & data , & data_len , raw , len ) == - 1 ) {add_assoc_long ( return_value , ""attr"" , type ) ;add_assoc_long ( return_value , ""vendor"" , vendor ) ;add_assoc_stringl ( return_value , ""data"" , ( char * ) data , data_len , 1 ) ;return ;",33
1251,if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) {avctx -> pix_fmt = AV_PIX_FMT_PAL8 ;,if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) {avctx -> pix_fmt = AV_PIX_FMT_PAL8 ;,34
1252,"if ( strchr ( "",<S2SV_blank>\\\\t"" , param -> value [ i + n ] ) )  break ;","if ( osStrchr ( "",<S2SV_blank>\\\\t"" , param -> value [ i + n ] ) != NULL ) {break ;}",35
1253,"print_fmt ( ""codec_tag"" , ""0x%04"" PRIx32 , par -> codec_tag ) ;switch ( par -> codec_type ) {case AVMEDIA_TYPE_VIDEO : print_int ( ""width"" , par -> width ) ;print_int ( ""height"" , par -> height ) ;if ( dec_ctx ) {print_int ( ""coded_width"" , dec_ctx -> coded_width ) ;print_int ( ""coded_height"" , dec_ctx -> coded_height ) ;}print_int ( ""has_b_frames"" , par -> video_delay ) ;sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ;if ( sar . den ) {print_q ( ""sample_aspect_ratio"" , sar , \':\' ) ;av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ;print_q ( ""display_aspect_ratio"" , dar , \':\' ) ;}else {print_str_opt ( ""sample_aspect_ratio"" , ""N/A"" ) ;print_str_opt ( ""display_aspect_ratio"" , ""N/A"" ) ;}s = av_get_pix_fmt_name ( par -> format ) ;if ( s ) print_str ( ""pix_fmt"" , s ) ;else print_str_opt ( ""pix_fmt"" , ""unknown"" ) ;print_int ( ""level"" , par -> level ) ;if ( par -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( par -> color_range ) ) ;else print_str_opt ( ""color_range"" , ""N/A"" ) ;if ( par -> color_space != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ;else print_str_opt ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ;if ( par -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ;else print_str_opt ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ;if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED )  print_str ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ;","print_primaries ( w , par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) print_str ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ;",36
1254,}fpp = & fpl -> fp [ fpl -> count ] ;,fpl -> user = NULL ;}fpp = & fpl -> fp [ fpl -> count ] ;,37
1255,return num ;},if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;return num ;},37
1256,"static void show_object ( struct object * object , struct strbuf * path ,   const char * last , void * data )  {","static void show_object ( struct object * object , const char * last , void * data ) {",38
1257,"assert ( c != NULL ) ;if ( c -> rcurr != c -> rbuf ) {if ( c -> rbytes >= c -> rsize ) {char * new_rbuf = realloc ( c -> rbuf , c -> rsize * 2 ) ;","int num_allocs = 0 ;assert ( c != NULL ) ;if ( c -> rcurr != c -> rbuf ) {if ( c -> rbytes >= c -> rsize ) {if ( num_allocs == 4 ) {return gotdata ;}++ num_allocs ;char * new_rbuf = realloc ( c -> rbuf , c -> rsize * 2 ) ;",39
1258,"draw_info -> geometry = AcquireString ( geometry ) ;status = AnnotateImage ( image , draw_info ) ;","( void ) CloneString ( & draw_info -> geometry = AcquireString ( geometry ) ;status = AnnotateImage ( image , draw_info ) ;",40
1259,__be32 * pdata = ( __be32 * ) data ;if ( * pdata == ctx -> from ) {,__be32 * pdata ;if ( datalen != 4 ) return - EINVAL ;pdata = ( __be32 * ) data ;if ( * pdata == ctx -> from ) {,41
1260,"if ( dctx -> bytes ) {int n = min ( srclen , dctx -> bytes ) ;","if ( ! ctx -> gf128 ) return - ENOKEY ;if ( dctx -> bytes ) {int n = min ( srclen , dctx -> bytes ) ;",42
1261,int i ;wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ;,"int i ;if ( ! config -> sample_rate ) {strcpy ( wpc -> error_message , ""sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!"" ) ;return FALSE ;}wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ;",43
1262,"return ast_for_funcdef_impl ( c , n , decorator_seq ,  0 ) ;}","return ast_for_funcdef_impl ( c , n , decorator_seq , false ) ;}",44
1263,uint32_t len ;uint32_t n ;,uint32_t n ;,45
1264,"n = r -> iov . iov_len / 512 ;r -> sector += n ;len = r -> sector_count * 512 ;if ( len > SCSI_DMA_BUF_SIZE ) {len = SCSI_DMA_BUF_SIZE ;r -> iov . iov_len = len ;DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\\scsi_req_data ( & r -> req , len ) ;}","n = r -> qiov . size / 512 ;r -> sector += n ;scsi_init_iovec ( r ) ;DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\\scsi_req_data ( & r -> req , len ) ;",45
1265,"static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image )  {size_t  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ;( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;for ( i = 0 ;i ++ )  {pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns ,  sizeof ( * * pixels ) ) ;for ( j = 0 ;j < ( ssize_t ) image -> columns ;j ++ )   GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ;}","static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) {const Image * next ;size_t columns , number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;columns = images -> columns ;for ( next = images ;next != ( Image * ) NULL ;next = next -> next ) columns = MagickMax ( next -> columns , columns ) ;for ( i = 0 ;i ++ ) {pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ;for ( j = 0 ;j < ( ssize_t ) columns ;j ++ ) GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ;}",46
1266,"vpx_memset ( oci -> ref_frame_sign_bias , 0 , sizeof ( oci -> ref_frame_sign_bias ) ) ;oci -> copy_buffer_to_gf = 0 ;","memset ( oci -> ref_frame_sign_bias , 0 , sizeof ( oci -> ref_frame_sign_bias ) ) ;oci -> copy_buffer_to_gf = 0 ;",47
1267,if ( ! ext_dp -> icmp_length ) {vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . len = hlen ;hlen -= 4 ;obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;,"if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) {vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) {}vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . len = hlen ;hlen -= 4 ;obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;",48
1268,"u64 nsec = ( u64 ) jiffies * TICK_NSEC ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ;}","u32 rem ;value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) ;value -> tv_nsec = rem ;}",49
1269,"duplexMode = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PHYDPX ;if ( duplexMode ) {enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER |  MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x15 ) ;}enc624j600WriteReg ( interface , ENC624J600_REG_MACON2 , MACON2_DEFER |  MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x12 ) ;}","duplexMode = enc624j600ReadReg ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PHYDPX ;if ( duplexMode ) {enc624j600WriteReg ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MABBIPG , 0x15 ) ;}enc624j600WriteReg ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_FD ) ;}",50
1270,"
","if ( ctx -> hdr . frame_size < ctx -> hdr . hdr_size ) {GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( ""[ADTSDmx]<S2SV_blank>Corrupted<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>resyncing\\\ctx -> nb_frames = 0 ;goto drop_byte ;}",51
1271,"adts_dmx_check_pid ( filter , ctx ) ;if ( ! ctx -> is_playing ) {","adts_dmx_check_pid ( filter , ctx ) ;if ( ! ctx -> is_playing ) {",51
1272,"void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi , int damp_var ) {const VP9_COMMON * const cm = & cpi -> common ;vp9_clear_system_state ( ) ;projected_size_based_on_q = estimate_bits_at_q ( cm -> frame_type , cm -> base_qindex , cm -> MBs ,  rate_correction_factor ) ;if ( projected_size_based_on_q > 0 )  correction_factor = ( 100 * cpi -> rc . projected_frame_size ) / projected_size_based_on_q ;switch ( damp_var ) {case 0 : adjustment_limit = 0.75 ;break ;case 1 : adjustment_limit = 0.375 ;break ;case 2 : default : adjustment_limit = 0.25 ;break ;","void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi ) {const VP9_COMMON * const cm = & cpi -> common ;if ( cpi -> rc . is_src_frame_alt_ref ) return ;vpx_clear_system_state ( ) ;if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cpi -> common . seg . enabled ) {projected_size_based_on_q = vp9_cyclic_refresh_estimate_bits_at_q ( cpi , rate_correction_factor ) ;else {projected_size_based_on_q = vp9_estimate_bits_at_q ( cpi -> common . frame_type , cm -> base_qindex , cm -> MBs , rate_correction_factor , cm -> bit_depth ) ;}if ( projected_size_based_on_q > FRAME_OVERHEAD_BITS ) correction_factor = ( int ) ( ( 100 * ( int64_t ) cpi -> rc . projected_frame_size ) / projected_size_based_on_q ) ;adjustment_limit = 0.25 + 0.5 * MIN ( 1 , fabs ( log10 ( 0.01 * correction_factor ) ) ) ;cpi -> rc . q_2_frame = cpi -> rc . q_1_frame ;cpi -> rc . q_1_frame = cm -> base_qindex ;cpi -> rc . rc_2_frame = cpi -> rc . rc_1_frame ;if ( correction_factor > 110 ) cpi -> rc . rc_1_frame = - 1 ;else if ( correction_factor < 90 ) cpi -> rc . rc_1_frame = 1 ;else cpi -> rc . rc_1_frame = 0 ;",52
1273,"if ( isparam ( ""value"" ) && * getparam ( ""value"" ) )   rsputs ( loc ( getparam ( ""value"" ) ) ) ;s = loc ( ""Drop<S2SV_blank>attachments<S2SV_blank>here..."" ) ;","if ( isparam ( ""value"" ) && * getparam ( ""value"" ) ) {strencode2 ( str , getparam ( ""value"" ) , sizeof ( str ) ) ;rsputs ( loc ( str ) ) ;}s = loc ( ""Drop<S2SV_blank>attachments<S2SV_blank>here..."" ) ;",53
1274,for ( k = 0 ;k < bufsize - 1 ;k ++ )   {if ( psf -> headindex < psf -> headend )  {ptr [ k ] = psf -> header [ psf -> headindex ] ;else  {ptr [ k ] = psf -> header [ psf -> headindex ] ;psf -> headindex = psf -> headend ;,if ( psf -> header . indx < psf -> headend ) {ptr [ k ] = psf -> header . ptr [ psf -> headindex ] ;else {ptr [ k ] = psf -> header . ptr [ psf -> header . indx ] ;psf -> header . indx = psf -> header . end ;,54
1275,"delim = strchr ( pat -> p . str , \':\' ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , delim ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;mutt_error ( _ ( ""Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s"" ) , pat -> p . str ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;","delim = strchr ( pat -> p . str , false , \':\' ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , delim , false ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str , false ) ;mutt_buffer_addstr ( buf , term ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str , false ) ;mutt_buffer_addstr ( buf , term ) ;mutt_error ( _ ( ""Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s"" ) , pat -> p . str , false ) ;imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ;mutt_buffer_addstr ( buf , term ) ;",55
1276,"int jas_matrix_resize ( jas_matrix_t * matrix , int numrows , int numcols )  {int size ;int i ;","int jas_matrix_resize ( jas_matrix_t * matrix , jas_matind_t numrows , jas_matind_t numcols ) {int size ;int i ;",56
1277,if ( info -> stagemasks [ ( int ) partword [ j ] [ i ] ] & ( 1 << s ) ) {codebook * stagebook = ci -> book_param + info -> stagebooks [ ( partword [ j ] [ i ] << 3 ) + s ] ;,int idx = ( int ) partword [ j ] [ i ] ;if ( idx < info -> partitions && info -> stagemasks [ idx ] & ( 1 << s ) ) {codebook * stagebook = ci -> book_param + info -> stagebooks [ ( partword [ j ] [ i ] << 3 ) + s ] ;,57
1278,"ssize_t oe_recvfrom ( int sockfd , void * buf , size_t len , int flags ,  const struct oe_sockaddr * src_addr ,  oe_socklen_t * addrlen ) {","ssize_t oe_recvfrom ( int sockfd , void * buf , size_t len , int flags , struct oe_sockaddr * src_addr , oe_socklen_t * addrlen ) {",58
1279,"err = ops -> cee_peer_getpg ( netdev , & pg ) ;if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PG , sizeof ( pg ) , & pg ) ) goto nla_put_failure ;struct cee_pfc pfc ;err = ops -> cee_peer_getpfc ( netdev , & pfc ) ;","memset ( & pg , 0 , sizeof ( pg ) ) ;err = ops -> cee_peer_getpg ( netdev , & pg ) ;if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PG , sizeof ( pg ) , & pg ) ) goto nla_put_failure ;struct cee_pfc pfc ;memset ( & pfc , 0 , sizeof ( pfc ) ) ;err = ops -> cee_peer_getpfc ( netdev , & pfc ) ;",59
1280,"frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ;len = min ( 8u , frag -> len ) ;if ( ! vcpu -> mmio_is_write ) memcpy ( frag -> data , run -> mmio . data , len ) ;if ( frag -> len <= 8 ) {frag ++ ;vcpu -> mmio_cur_fragment ++ ;}else {frag -> data += len ;frag -> gpa += len ;frag -> len -= len ;}if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) {vcpu -> mmio_needed = 0 ;",frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment >= vcpu -> mmio_nr_fragments ) {vcpu -> mmio_needed = 0 ;,60
1281,"ret = get_tag ( * der , len , tag_out , & contents , & clen , & remainder , & rlen ) ;if ( ret ) return ret ;","ret = get_tag ( * der , len , tag_out , & contents , & clen , & remainder , & rlen , 0 ) ;if ( ret ) return ret ;",61
1282,free ( name ) ;return 0 ;,"if ( ! strcmp ( key , ""path"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , ""disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s"" , value ) ;free ( name ) ;return 0 ;",62
1283,unsigned long flags ;if ( ! timeout ) timeout = ( HZ * EDGE_CLOSING_WAIT ) / 100 ;,unsigned long flags ;if ( ! tty ) return ;if ( ! timeout ) timeout = ( HZ * EDGE_CLOSING_WAIT ) / 100 ;,63
1284,unsigned char buffer [ 3 ] ;int ret ;,"unsigned char * buffer ;int ret ;buffer = kmalloc ( 3 , GFP_KERNEL ) ;if ( ! buffer ) return - ENOMEM ;",64
1285,return ret ;},kfree ( buffer ) ;return ret ;},64
1286,"# ifdef _WIN32  HANDLE Token ;if ( LogonUser ( username , ""."" , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 )  {pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE ,   GetLastError ( ) , ""LogonUser()<S2SV_blank>failed"" ) ;return - 1 ;if ( ImpersonateLoggedOnUser ( Token ) == 0 )  {return - 1 ;}# else  struct passwd * user ;pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ;return - 1 ;pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ;return - 1 ;# endif  crypt_password = crypt ( password , user_password ) ;if ( crypt_password == NULL ) {pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;return - 1 ;pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect"" ) ;return - 1 ;pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE ,   errno , ""setuid"" ) ;return - 1 ;}","# ifdef _WIN32 DWORD error ;HANDLE Token ;char errmsgbuf [ PCAP_ERRBUF_SIZE ] ;if ( LogonUser ( username , ""."" , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) {pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;error = GetLastError ( ) ;if ( error != ERROR_LOGON_FAILURE ) {pcap_fmt_errmsg_for_win32_err ( errmsgbuf , PCAP_ERRBUF_SIZE , error , ""LogonUser()<S2SV_blank>failed"" ) ;rpcapd_log ( LOGPRIO_ERROR , ""%s"" , errmsgbuf ) ;return - 1 ;}if ( ImpersonateLoggedOnUser ( Token ) == 0 ) {pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;pcap_fmt_errmsg_for_win32_err ( errmsgbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , ""ImpersonateLoggedOnUser()<S2SV_blank>failed"" ) ;rpcapd_log ( LOGPRIO_ERROR , ""%s"" , errmsgbuf ) ;CloseHandle ( Token ) == 0 ) {return - 1 ;}# else int error ;struct passwd * user ;pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;return - 1 ;pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;return - 1 ;# endif errno = 0 ;crypt_password = crypt ( password , user_password ) ;if ( crypt_password == NULL ) {error = errno ;pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;if ( error == 0 ) {rpcapd_log ( LOGPRIO_ERROR , ""crypt()<S2SV_blank>failed"" ) ;}else {rpcapd_log ( LOGPRIO_ERROR , ""crypt()<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( error ) ) ;}return - 1 ;pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;return - 1 ;error = errno ;pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , error , ""setuid"" ) ;rpcapd_log ( LOGPRIO_ERROR , ""setuid()<S2SV_blank>failed:<S2SV_blank>%s"" , strerror ( error ) ) ;return - 1 ;}",65
1287,"static PyObject *  _Unpickler_MemoGet ( UnpicklerObject * self , Py_ssize_t idx )  {if ( idx < 0 || idx >= self -> memo_size )  return NULL ;","static PyObject * _Unpickler_MemoGet ( UnpicklerObject * self , size_t idx ) {if ( idx < 0 || idx >= self -> memo_size ) return NULL ;",66
1288,sas_port_delete ( port -> port ) ;port -> port = NULL ;,sas_destruct_devices ( port ) ;sas_port_delete ( port -> port ) ;port -> port = NULL ;,67
1289,"static stmt_ty  ast_for_with_stmt ( struct compiling * c , const node * n , int is_async )   {int i , n_items , nch_minus_type , has_type_comment ;","static stmt_ty ast_for_with_stmt ( struct compiling * c , const node * n0 , bool is_async ) {const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ;int i , n_items , nch_minus_type , has_type_comment ;",68
1290,"if ( is_async )  return AsyncWith ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ;else return With ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ;","if ( is_async ) return AsyncWith ( items , body , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , c -> c_arena ) ;else return With ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ;",68
1291,"struct request * rq = tags -> rqs [ tag ] ;struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ;if ( ! is_flush_request ( rq , fq , tag ) ) return rq ;return fq -> flush_rq ;",return tags -> rqs [ tag ] ;,69
1292,"found :  if ( f -> map & ( 1 << rec ) ) {ldm_error ( ""Duplicate<S2SV_blank>VBLK,<S2SV_blank>part<S2SV_blank>%d."" , rec ) ;","found : if ( rec >= f -> num ) {ldm_error ( ""REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)"" , rec , f -> num ) ;return false ;}if ( f -> map & ( 1 << rec ) ) {ldm_error ( ""Duplicate<S2SV_blank>VBLK,<S2SV_blank>part<S2SV_blank>%d."" , rec ) ;",70
1293,goto retry_rebind ;},switch ( task -> tk_status ) {case - EACCES : case - EIO : goto die ;default : goto retry_rebind ;}},71
1294,if ( ! chan ) {err = - EINVAL ;goto out_free ;}if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ;request -> channels [ i ] = chan ;,request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;,72
1295,if ( request -> ssids [ i ] . ssid_len >  IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;,if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;,72
1296,if ( iter > CIPSO_V4_TAG_MAXCNT )  return - EINVAL ;if ( iter < CIPSO_V4_TAG_MAXCNT )   doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ;return 0 ;,if ( iter >= CIPSO_V4_TAG_MAXCNT ) return - EINVAL ;while ( iter < CIPSO_V4_TAG_MAXCNT ) doi_def -> tags [ iter ++ ] = CIPSO_V4_TAG_INVALID ;return 0 ;,73
1297,"int is_async ;count_comp_for : is_async = 0 ;n_fors ++ ;if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) {is_async = 1 ;if ( NCH ( n ) == ( 5 + is_async ) ) {n = CHILD ( n , 4 + is_async ) ;}count_comp_iter : REQ ( n , comp_iter ) ;","count_comp_for : n_fors ++ ;if ( TYPE ( CHILD ( n , 0 ) ) == ASYNC ) {is_async = 1 ;}if ( NCH ( n ) == ( 5 ) ) {n = CHILD ( n , 4 ) ;error : count_comp_iter : REQ ( n , comp_iter ) ;",74
1298,"}PyErr_SetString ( PyExc_SystemError , ""logic<S2SV_blank>error<S2SV_blank>in<S2SV_blank>count_comp_fors"" ) ;","}PyErr_SetString ( PyExc_SystemError , ""logic<S2SV_blank>error<S2SV_blank>in<S2SV_blank>count_comp_fors"" ) ;",74
1299,"ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & e , ext , sizeof ( e ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ;if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , ntohs ( e . len ) - 4 ) ) goto trunc ;}else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) )  goto trunc ;return ( const u_char * ) ext + ntohs ( e . len ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;","ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%u"" , ntohs ( e . len ) - 4 ) ) ;if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ntohs ( e . len ) > 4 ) {if ( ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( ext + 1 ) , ep ) ) goto trunc ;}return ( const u_char * ) ext + ntohs ( e . len ) ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ;",75
1300,"futex_wait_queue_me ( hb , & q , to ) ;spin_lock ( & hb -> lock ) ;","if ( match_futex ( & q . key , & key2 ) ) {ret = - EINVAL ;goto out_put_keys ;}futex_wait_queue_me ( hb , & q , to ) ;spin_lock ( & hb -> lock ) ;",76
1301,last_source = source_mnt ;mp = dest_mp ;,first_source = source_mnt ;last_source = source_mnt ;mp = dest_mp ;,77
1302,"struct dw2102_state * state = d -> priv ;u8 obuf [ 3 ] = {0xe , 0x80 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x02 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 300 ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;m88ds3103_pdata . clk = 27000000 ;","struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0x0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x02 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;obuf [ 1 ] = 0x83 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;state -> data [ 1 ] = 0x83 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;mutex_unlock ( & d -> data_mutex ) ;m88ds3103_pdata . clk = 27000000 ;",78
1303,"u8 * gb_cur , * version_tlv , version , version_length ;u8 * lto_tlv , lto_length ;u8 * wks_tlv , wks_length ;u8 * miux_tlv , miux_length ;gb_len += version_length ;lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ;gb_len += lto_length ;pr_debug ( ""Local<S2SV_blank>wks<S2SV_blank>0x%lx\\\gb_len += wks_length ;miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 ,  & miux_length ) ;gb_len += miux_length ;","u8 * gb_cur , version , version_length ;u8 lto_length , wks_length , miux_length ;u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL ;if ( ! version_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += version_length ;lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ;if ( ! lto_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += lto_length ;pr_debug ( ""Local<S2SV_blank>wks<S2SV_blank>0x%lx\\\if ( ! wks_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += wks_length ;miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 , & miux_length ) ;if ( ! miux_tlv ) {ret = - ENOMEM ;goto out ;}gb_len += miux_length ;",79
1304,* state = CCS_VALUE ;* type = CCV_CLASS ;,if ( * state != CCS_START ) * state = CCS_VALUE ;* type = CCV_CLASS ;,80
1305,"int pkt_len , pktnum , hr , min , sec , csec ;char channel [ 10 ] , direction [ 10 ] ;","guint pkt_len ;int pktnum , hr , min , sec , csec ;char channel [ 10 ] , direction [ 10 ] ;",81
1306,"num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {phdr -> rec_type = REC_TYPE_PACKET ;phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ;","num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {if ( pkt_len > WTAP_MAX_PACKET_SIZE ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ;return FALSE ;}phdr -> rec_type = REC_TYPE_PACKET ;phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ;",81
1307,"ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ;pd = ws_buffer_start_ptr ( buf ) ;","ws_buffer_assure_space ( buf , pkt_len ) ;pd = ws_buffer_start_ptr ( buf ) ;",81
1308,"void * p = au -> reply_buf ;void * end = p + sizeof ( au -> reply_buf ) ;ret = ceph_x_decrypt ( & th -> session_key , & p , end , & reply , sizeof ( reply ) ) ;if ( ret < 0 ) return ret ;","void * preply = & reply ;void * p = au -> reply_buf ;void * end = p + sizeof ( au -> reply_buf ) ;ret = ceph_x_decrypt ( & th -> session_key , & p , end , & preply , sizeof ( reply ) ) ;if ( ret < 0 ) return ret ;",82
1309,if ( length > 0 )  {,if ( length > 1 ) {,83
1310,"case PPP_OSI :  isoclns_print ( ndo , p , length , length ) ;break ;","case PPP_OSI : isoclns_print ( ndo , p , length , length ) ;break ;",84
1311,"case BPF_TYPE_PROG :  atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ;break ;case BPF_TYPE_MAP :  bpf_map_inc ( raw , true ) ;break ;","case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw ) ;break ;case BPF_TYPE_MAP : raw = bpf_map_inc ( raw , true ) ;break ;",85
1312,"static void predict_and_reconstruct_intra_block ( int plane , int block ,  BLOCK_SIZE plane_bsize ,  TX_SIZE tx_size , void * arg ) {struct intra_args * const args = ( struct intra_args * ) arg ;VP9_COMMON * const cm = args -> cm ;MACROBLOCKD * const xd = args -> xd ;MODE_INFO * const mi = xd -> mi [ 0 ] ;const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block )  : mi -> mbmi . uv_mode ;txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ;vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) ,  b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ;if ( ! mi -> mbmi . skip ) {const int eob = vp9_decode_block_tokens ( cm , xd , plane , block ,  plane_bsize , x , y , tx_size , args -> r ) ;inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ;","static void predict_and_reconstruct_intra_block ( MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col , TX_SIZE tx_size ) {MODE_INFO * const mi = xd -> mi [ 0 ] ;const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) : mi -> mbmi . uv_mode ;dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * col ] ;if ( mbmi -> sb_type < BLOCK_8X8 ) if ( plane == 0 ) mode = xd -> mi [ 0 ] -> bmi [ ( row << 1 ) + col ] . as_mode ;vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , col , row , plane ) ;if ( ! mbmi -> skip ) {const TX_TYPE tx_type = ( plane || xd -> lossless ) ? DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ;const scan_order * sc = ( plane || xd -> lossless ) ? & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ;const int eob = vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ;inverse_transform_block_intra ( xd , plane , tx_type , tx_size , dst , pd -> dst . stride , eob ) ;",86
1313,"impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ;return ;","if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) {ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ;ps_dec -> u2_header_done = 0 ;ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ;ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ;}impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ;return ;",87
1314,const uint8_t * src = in -> data [ 0 ] ;,const uint8_t * src = in -> data [ plane ] && in -> linesize [ 0 ] ;,88
1315,for ( plane = 0 ;uint8_t * dst = out -> data [ plane ] ;,for ( plane = 0 ;uint8_t * dst = out -> data [ plane ] ;,88
1316,"static int em_loop ( struct x86_emulate_ctxt * ctxt )  {register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ;if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;return X86EMUL_CONTINUE ;}","static int em_loop ( struct x86_emulate_ctxt * ctxt ) {int rc = X86EMUL_CONTINUE ;register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ;if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;return rc ;}",89
1317,"char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}switch ( data [ 0 ] ) {return - EIO ;}return snprintf ( buf , PAGE_SIZE , ""%s\\\","char * data ;data = kmalloc ( 2 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}switch ( data [ 0 ] ) {ret = - EIO ;goto out ;}ret = snprintf ( buf , PAGE_SIZE , ""%s\\\out : kfree ( data ) ;return ret ;",90
1318,"cntsize ( in , & sumlen , & nnode ) ;len = COMPUTESIZE ( nnode , sumlen ) ;","cntsize ( in , & sumlen , & nnode ) ;if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;len = COMPUTESIZE ( nnode , sumlen ) ;",91
1319,line = picture -> data [ plane ] + y * picture -> linesize [ plane ] ;for ( ;dst = line + x * pixelsize + compno * ! planar ;if ( codsty -> transform == FF_DWT97 ) {,line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ] ;for ( ;dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar ;if ( codsty -> transform == FF_DWT97 ) {,92
1320,linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ) ;for ( ;dst = linel + ( x * pixelsize + compno * ! planar ) ;if ( codsty -> transform == FF_DWT97 ) {,linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ) ;for ( ;dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ) ;if ( codsty -> transform == FF_DWT97 ) {,92
1321,"void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc ,   int length , int offset , int total_size )  {","void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , u8 status , const u8 * desc , u8 length , u16 offset , u16 total_size ) {",93
1322,int copy_len ;int required_size = urb -> transfer_buffer_length ;if ( required_size > total_size ) required_size = total_size ;,unsigned int copy_len ;unsigned int required_size = urb -> transfer_buffer_length ;if ( required_size > total_size ) required_size = total_size ;,93
1323,"int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;BIO_write ( bio , obj_txt , len ) ;BIO_write ( bio , ""\\\","OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;BIO_printf ( bio , obj_txt , len ) ;BIO_write ( bio , ""%s\\\",94
1324,if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) )  return - EINVAL ;param . regd = hwsim_world_regdom_custom [ idx ] ;},if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) {kfree ( hwname ) ;return - EINVAL ;}param . regd = hwsim_world_regdom_custom [ idx ] ;},95
1325,"static int candidate_refresh_aq ( const CYCLIC_REFRESH * cr , const MB_MODE_INFO * mbmi ,  BLOCK_SIZE bsize , int use_rd ) {if ( use_rd ) {if ( cr -> projected_rate_sb < cr -> thresh_rate_sb ) return 1 ;else if ( bsize < cr -> min_block_size ||  ( mbmi -> mv [ 0 ] . as_int != 0 &&   cr -> projected_dist_sb > cr -> thresh_dist_sb ) ||   ! is_inter_block ( mbmi ) )  return 0 ;if ( bsize < cr -> min_block_size ||   mbmi -> mv [ 0 ] . as_int != 0 ||  ! is_inter_block ( mbmi ) ) return 0 ;else  return 1 ;}","static int candidate_refresh_aq ( const CYCLIC_REFRESH * cr , const MB_MODE_INFO * mbmi , int64_t rate , int64_t dist , int bsize ) {MV mv = mbmi -> mv [ 0 ] . as_int != 0 && cr -> projected_dist_sb > cr -> thresh_dist_sb ) || ! is_inter_block ( mbmi ) ) return 0 ;if ( bsize < cr -> thresh_rate_sb && is_inter_block ( mbmi ) && mbmi -> mv [ 0 ] . as_int == 0 && cr -> rate_boost_fac > 10 ) return CR_SEGMENT_ID_BOOST2 ;else return CR_SEGMENT_ID_BOOST1 ;",96
1326,"int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {","static int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {",97
1327,"int midi_synth_load_patch ( int dev , int format , const char __user * addr ,  int offs , int count , int pmgr_flag )  {","int midi_synth_load_patch ( int dev , int format , const char __user * addr , int count , int pmgr_flag ) {",98
1328,"if ( format != SYSEX_PATCH )  {return - EINVAL ;}if ( count < hdr_size )  {return - EINVAL ;}count -= hdr_size ;if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) )  return - EFAULT ;if ( count < sysex . len )   {sysex . len = count ;}left = sysex . len ;",if ( format != SYSEX_PATCH ) return - EINVAL ;}if ( count < hdr_size ) {return - EINVAL ;if ( count < sysex . len ) {sysex . len = count ;}left = sysex . len ;,98
1329,"
",userfaultfd_ctx_get ( fork_nctx ) ;,99
1330,spin_unlock ( & ctx -> event_wqh . lock ) ;ret = 0 ;,spin_unlock ( & ctx -> event_wqh . lock ) ;ret = 0 ;,99
1331,"if ( ! ret ) {spin_lock ( & ctx -> event_wqh . lock ) ;uwq = list_first_entry ( & fork_event ,  typeof ( * uwq ) , wq . entry ) ;userfaultfd_event_complete ( ctx , uwq ) ;}spin_unlock ( & ctx -> event_wqh . lock ) ;}","spin_lock ( & ctx -> event_wqh . lock ) ;userfaultfd_ctx_put ( fork_nctx ) ;uwq = list_first_entry ( & fork_event , typeof ( * uwq ) , wq . entry ) ;if ( likely ( ! ret ) ) userfaultfd_event_complete ( ctx , uwq ) ;}else {if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ;}spin_unlock ( & ctx -> event_wqh . lock ) ;",99
1332,"static int decode_coefs ( VP9_COMMON * cm , const MACROBLOCKD * xd , PLANE_TYPE type ,   int16_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq ,  int ctx , const int16_t * scan , const int16_t * nb ,  vp9_reader * r ) {const int max_eob = 16 << ( tx_size << 1 ) ;const FRAME_CONTEXT * const fc = & cm -> fc ;FRAME_COUNTS * const counts = & cm -> counts ;const vp9_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] =  fc -> coef_probs [ tx_size ] [ type ] [ ref ] ;const vp9_prob * prob ;unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] =  counts -> coef [ tx_size ] [ type ] [ ref ] ;unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] =  counts -> eob_branch [ tx_size ] [ type ] [ ref ] ;uint8_t token_cache [ 32 * 32 ] ;const uint8_t * cat6 ;int val ;band = * band_translate ++ ;if ( ! cm -> frame_parallel_decoding_mode )  ++ eob_branch_count [ band ] [ ctx ] ;if ( ! vp9_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) {INCREMENT_COUNT ( EOB_MODEL_TOKEN ) ;while ( ! vp9_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) {INCREMENT_COUNT ( ZERO_TOKEN ) ;","static int decode_coefs ( const MACROBLOCKD * xd , PLANE_TYPE type , int16_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq , int ctx , const int16_t * scan , const int16_t * nb , vpx_reader * r ) {FRAME_COUNTS * counts = xd -> counts ;const int max_eob = 16 << ( tx_size << 1 ) ;const FRAME_CONTEXT * const fc = xd -> fc ;const vpx_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = fc -> coef_probs [ tx_size ] [ type ] [ ref ] ;const vpx_prob * prob ;unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] ;unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] ;uint8_t token_cache [ 32 * 32 ] ;const uint8_t * band_translate = get_band_translate ( tx_size ) ;const int dq_shift = ( tx_size == TX_32X32 ) ;int v , token ;int16_t dqv = dq [ 0 ] ;const uint8_t * cat1_prob ;const uint8_t * cat2_prob ;const uint8_t * cat3_prob ;const uint8_t * cat4_prob ;const uint8_t * cat5_prob ;const uint8_t * cat6_prob ;if ( counts ) {coef_counts = counts -> coef [ tx_size ] [ type ] [ ref ] ;eob_branch_count = counts -> eob_branch [ tx_size ] [ type ] [ ref ] ;uint8_t token_cache [ 32 * 32 ] ;const uint8_t * cat6 ;int val = - 1 ;band = * band_translate ++ ;if ( counts ) ++ eob_branch_count [ band ] [ ctx ] ;if ( ! vpx_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) {INCREMENT_COUNT ( EOB_MODEL_TOKEN ) ;while ( ! vpx_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) {INCREMENT_COUNT ( ZERO_TOKEN ) ;",100
1333,"if ( ! vp9_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) {INCREMENT_COUNT ( ONE_TOKEN ) ;WRITE_COEF_CONTINUE ( 1 , ONE_TOKEN ) ;}INCREMENT_COUNT ( TWO_TOKEN ) ;prob = vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ;if ( ! vp9_read ( r , prob [ LOW_VAL_CONTEXT_NODE ] ) ) {if ( ! vp9_read ( r , prob [ TWO_CONTEXT_NODE ] ) ) {WRITE_COEF_CONTINUE ( 2 , TWO_TOKEN ) ;}if ( ! vp9_read ( r , prob [ THREE_CONTEXT_NODE ] ) ) {WRITE_COEF_CONTINUE ( 3 , THREE_TOKEN ) ;WRITE_COEF_CONTINUE ( 4 , FOUR_TOKEN ) ;}if ( ! vp9_read ( r , prob [ HIGH_LOW_CONTEXT_NODE ] ) ) {if ( ! vp9_read ( r , prob [ CAT_ONE_CONTEXT_NODE ] ) ) {val = CAT1_MIN_VAL ;ADJUST_COEF ( CAT1_PROB0 , 0 ) ;WRITE_COEF_CONTINUE ( val , CATEGORY1_TOKEN ) ;}val = CAT2_MIN_VAL ;ADJUST_COEF ( CAT2_PROB1 , 1 ) ;ADJUST_COEF ( CAT2_PROB0 , 0 ) ;WRITE_COEF_CONTINUE ( val , CATEGORY2_TOKEN ) ;}if ( ! vp9_read ( r , prob [ CAT_THREEFOUR_CONTEXT_NODE ] ) ) {if ( ! vp9_read ( r , prob [ CAT_THREE_CONTEXT_NODE ] ) ) {val = CAT3_MIN_VAL ;ADJUST_COEF ( CAT3_PROB2 , 2 ) ;ADJUST_COEF ( CAT3_PROB1 , 1 ) ;ADJUST_COEF ( CAT3_PROB0 , 0 ) ;WRITE_COEF_CONTINUE ( val , CATEGORY3_TOKEN ) ;val = CAT4_MIN_VAL ;ADJUST_COEF ( CAT4_PROB3 , 3 ) ;ADJUST_COEF ( CAT4_PROB2 , 2 ) ;ADJUST_COEF ( CAT4_PROB1 , 1 ) ;ADJUST_COEF ( CAT4_PROB0 , 0 ) ;WRITE_COEF_CONTINUE ( val , CATEGORY4_TOKEN ) ;if ( ! vp9_read ( r , prob [ CAT_FIVE_CONTEXT_NODE ] ) ) {val = CAT5_MIN_VAL ;ADJUST_COEF ( CAT5_PROB4 , 4 ) ;ADJUST_COEF ( CAT5_PROB3 , 3 ) ;ADJUST_COEF ( CAT5_PROB2 , 2 ) ;ADJUST_COEF ( CAT5_PROB1 , 1 ) ;ADJUST_COEF ( CAT5_PROB0 , 0 ) ;WRITE_COEF_CONTINUE ( val , CATEGORY5_TOKEN ) ;val = 0 ;cat6 = cat6_prob ;while ( * cat6 ) val = ( val << 1 ) | vp9_read ( r , * cat6 ++ ) ;val += CAT6_MIN_VAL ;WRITE_COEF_CONTINUE ( val , CATEGORY6_TOKEN ) ;","if ( ! vpx_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) {INCREMENT_COUNT ( ONE_TOKEN ) ;token = ONE_TOKEN ;val = 1 ;else {INCREMENT_COUNT ( TWO_TOKEN ) ;token = vpx_read_tree ( r , vp9_coef_con_tree , vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ) ;switch ( token ) {case TWO_TOKEN : case THREE_TOKEN : case FOUR_TOKEN : val = token ;break ;case CATEGORY1_TOKEN : val = CAT1_MIN_VAL + read_coeff ( cat1_prob , 1 , r ) ;break ;case CATEGORY2_TOKEN : val = CAT2_MIN_VAL + read_coeff ( cat2_prob , 2 , r ) ;break ;case CATEGORY3_TOKEN : val = CAT3_MIN_VAL + read_coeff ( cat3_prob , 3 , r ) ;break ;case CATEGORY4_TOKEN : val = CAT4_MIN_VAL + read_coeff ( cat4_prob , 4 , r ) ;break ;case CATEGORY5_TOKEN : val = CAT5_MIN_VAL + read_coeff ( cat5_prob , 5 , r ) ;break ;case CATEGORY6_TOKEN : # if CONFIG_VP9_HIGHBITDEPTH switch ( xd -> bd ) {case VPX_BITS_8 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ;break ;case VPX_BITS_10 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 16 , r ) ;break ;case VPX_BITS_12 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 18 , r ) ;break ;default : assert ( 0 ) ;return - 1 ;# else val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ;# endif break ;v = ( val * dqv ) >> dq_shift ;# if CONFIG_COEFFICIENT_RANGE_CHECKING # if CONFIG_VP9_HIGHBITDEPTH dqcoeff [ scan [ c ] ] = highbd_check_range ( ( vpx_read_bit ( r ) ? - v : v ) , xd -> bd ) ;# else dqcoeff [ scan [ c ] ] = check_range ( vpx_read_bit ( r ) ? - v : v ) ;# endif # else dqcoeff [ scan [ c ] ] = vpx_read_bit ( r ) ? - v : v ;# endif token_cache [ scan [ c ] ] = vp9_pt_energy_class [ token ] ;++ c ;ctx = get_coef_context ( nb , token_cache , c ) ;dqv = dq [ 1 ] ;",100
1334,}if ( ! hquery -> remaining ) {,return ;}if ( ! hquery -> remaining ) {,101
1335,"void vp9_fht4x4_sse2 ( const int16_t * input , int16_t * output ,  int stride , int tx_type ) {case DCT_DCT :  vp9_fdct4x4_sse2 ( input , output , stride ) ;break ;","void vp9_fht4x4_sse2 ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {case DCT_DCT : vpx_fdct4x4_sse2 ( input , output , stride ) ;break ;",102
1336,error_t mqttSnClientDisconnect ( MqttSnClientContext * context )  {,"error_t mqttSnClientDisconnect ( MqttSnClientContext * context , systime_t duration ) {",103
1337,"error = mqttSnClientSendDisconnect ( context , 0 ) ;}error = mqttSnClientSendDisconnect ( context , 0 ) ;}","error = mqttSnClientSendDisconnect ( context , duration / 1000 ) ;}error = mqttSnClientSendDisconnect ( context , duration / 1000 ) ;}",103
1338,"case 1 :  hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset ,  fd . entrylength ) ;","case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) {err = - EIO ;goto out ;}if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) {err = - EIO ;goto out ;}hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , fd . entrylength ) ;",104
1339,"hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset ,  fd . entrylength ) ;","hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , fd . entrylength ) ;",104
1340,"SET_NETDEV_DEV ( dev , dmdev ) ;reset_card ( dev , 1 ) ;","dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;SET_NETDEV_DEV ( dev , dmdev ) ;reset_card ( dev , 1 ) ;",105
1341,sd -> gspca_dev . usb_err = - EIO ;return ;,sd -> gspca_dev . usb_err = - EIO ;return ;}if ( alt -> desc . bNumEndpoints < 1 ) {sd -> gspca_dev . usb_err = - ENODEV ;return ;,106
1342,"num = port >= 0 ? port : 0 ;mutex_lock ( & client -> ports_mutex ) ;write_lock_irqsave ( & client -> ports_lock , flags ) ;list_for_each_entry ( p , & client -> ports_list_head , list ) {if ( p -> addr . port > num ) break ;if ( port < 0 ) num = p -> addr . port + 1 ;}list_add_tail ( & new_port -> list , & p -> list ) ;client -> num_ports ++ ;new_port -> addr . port = num ;write_unlock_irqrestore ( & client -> ports_lock , flags ) ;mutex_unlock ( & client -> ports_mutex ) ;sprintf ( new_port -> name , ""port-%d"" , num ) ;",snd_use_lock_use ( & new_port -> use_lock ) ;num = port >= 0 ? port : 0 ;mutex_lock ( & client -> ports_mutex ) ;,107
1343,"
",msg -> msg_namelen = 0 ;,108
1344,"lock_sock ( sk ) ;for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ;","lock_sock ( sk ) ;for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ;",108
1345,"dev = btrfs_find_device ( fs_info -> fs_devices , di_args -> devid , s_uuid ,  NULL ) ;if ( ! dev ) {","dev = btrfs_find_device ( fs_info -> fs_devices , di_args -> devid , s_uuid , NULL , true ) ;if ( ! dev ) {",109
1346,"umode_t mode = inode -> i_mode ;ret = posix_acl_equiv_mode ( acl , & mode ) ;if ( ret < 0 ) return ret ;","umode_t mode ;ret = posix_acl_update_mode ( inode , & mode ) ;if ( ret < 0 ) return ret ;",110
1347,"
",ND_TCHECK ( rhp -> rh_short . sh_flags ) ;,111
1348,mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ;},mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ;},111
1349,char aacFileName [ 255 ] ;char audioFileName [ 255 ] ;char adtsFileName [ 255 ] ;,char * aacFileName = NULL ;char * audioFileName = NULL ;char * adtsFileName = NULL ;,112
1350,"strcpy ( audioFileName , optarg ) ;}strcpy ( adtsFileName , optarg ) ;}","audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ;if ( audioFileName == NULL ) {faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\\return 1 ;}strcpy ( audioFileName , optarg ) ;}adtsFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ;if ( adtsFileName == NULL ) {faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>adtsFileName.\\\return 1 ;}strcpy ( adtsFileName , optarg ) ;}",112
1351,"# endif  strcpy ( aacFileName , argv [ optind ] ) ;strcpy ( audioFileName , aacFileName ) ;fnp = ( char * ) strrchr ( audioFileName , \'.\' ) ;","# endif aacFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( argv [ optind ] ) + 1 ) ) ;if ( aacFileName == NULL ) {faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>aacFileName.\\\return 1 ;}strcpy ( aacFileName , argv [ optind ] ) ;audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( aacFileName ) + strlen ( file_ext [ format ] ) + 1 ) ) ;if ( audioFileName == NULL ) {faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\\return 1 ;}strcpy ( audioFileName , aacFileName ) ;fnp = ( char * ) strrchr ( audioFileName , \'.\' ) ;if ( audioFileName != NULL ) free ( audioFileName ) ;if ( adtsFileName != NULL ) free ( adtsFileName ) ;",112
1352,"
",if ( aacFileName != NULL ) free ( aacFileName ) ;,112
1353,}if ( ! result && ! infoOnly ) {return 0 ;},}if ( ! result && ! infoOnly ) {return 0 ;},112
1354,key_put ( ci -> ci_keyring_key ) ;crypto_free_skcipher ( ci -> ci_ctfm ) ;,crypto_free_skcipher ( ci -> ci_ctfm ) ;,113
1355,"DBGPRINTF ( ""imzmq3:<S2SV_blank>socket<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>created<S2SV_blank>successfully\\\if ( info -> sndBuf > - 1 ) zsocket_set_sndbuf ( * sock , info -> sndBuf ) ;","DBGPRINTF ( ""imzmq3:<S2SV_blank>socket<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>created<S2SV_blank>successfully\\\if ( info -> sndBuf > - 1 ) zsocket_set_sndbuf ( * sock , ""%s"" , info -> sndBuf ) ;",114
1356,"rv = zsocket_connect ( * sock , info -> description ) ;if ( rv == - 1 ) {rv = zsocket_bind ( * sock , info -> description ) ;if ( rv == - 1 ) {","rv = zsocket_connect ( * sock , info -> description ) ;if ( rv == - 1 ) {rv = zsocket_bind ( * sock , info -> description ) ;if ( rv == - 1 ) {",114
1357,fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ;fptr -> frag_off = htons ( offset ) ;,if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ;fptr -> frag_off = htons ( offset ) ;,115
1358,"if ( ipv6_hdr ( skb ) -> payload_len == 0 ) {pr_debug ( ""payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\\return skb ;}if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ;clone = skb_clone ( skb , GFP_ATOMIC ) ;if ( clone == NULL ) {pr_debug ( ""Can\\\'t<S2SV_blank>clone<S2SV_blank>skb\\\return skb ;}NFCT_FRAG6_CB ( clone ) -> orig = skb ;if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) {pr_debug ( ""message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\\goto ret_orig ;}skb_set_transport_header ( clone , fhoff ) ;hdr = ipv6_hdr ( clone ) ;fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ;if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) {pr_debug ( ""Invalid<S2SV_blank>fragment<S2SV_blank>offset\\\goto ret_orig ;}","
",116
1359,"client -> auth_end_offset = AUTH_END_INIT_OFFSET ;client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ;","client -> auth_buffer = g_byte_array_new ( ) ;client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ;",117
1360,"if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) )  return 0 ;if ( ! ( mask & MAY_WRITE ) )  if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) )  return 0 ;if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) )  if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) )  return 0 ;if ( mask == MAY_READ )  if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) )  return 0 ;","if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_OVERRIDE ) ) return 0 ;if ( ! ( mask & MAY_WRITE ) ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ;if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_OVERRIDE ) ) return 0 ;if ( mask == MAY_READ ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ;",118
1361,"key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ;for ( i = 0 , j = 0 ;","if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ;for ( i = 0 , j = 0 ;",119
1362,"struct ip_options * opt = NULL ;if ( optlen > 40 ) goto e_inval ;if ( err )  break ;if ( inet -> is_icsk ) {# endif  if ( inet -> opt )   icsk -> icsk_ext_hdr_len -= inet -> opt -> optlen ;if ( opt )  icsk -> icsk_ext_hdr_len += opt -> optlen ;icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ;opt = xchg ( & inet -> opt , opt ) ;kfree ( opt ) ;","struct ip_options_rcu * old , * opt = NULL ;if ( optlen > 40 ) goto e_inval ;if ( err ) break ;old = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet -> is_icsk ) {# endif if ( old ) icsk -> icsk_ext_hdr_len -= inet -> opt -> optlen ;if ( opt ) icsk -> icsk_ext_hdr_len += opt -> opt . optlen ;icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ;rcu_assign_pointer ( inet -> inet_opt , opt ) ;if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu ) ;",120
1363,"static void  l2tp_framing_cap_print ( netdissect_options * ndo , const u_char * dat )  {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_CAP_ASYNC_MASK ) {","static void l2tp_framing_cap_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_CAP_ASYNC_MASK ) {",121
1364,"}else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) {s -> filesize = strtoll ( p , NULL , 10 ) ;}","}else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == UINT64_MAX ) {s -> filesize = strtoll ( p , NULL , 10 ) ;}",122
1365,"s -> filesize = - 1 ;s -> chunksize = 0 ;}else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) {ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) {ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) {ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ;}else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) {if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ;","s -> filesize = strtoull ( p , ""close"" ) ) s -> willclose = 1 ;",122
1366,"s -> icy_metaint = strtoll ( p , NULL , 10 ) ;}","s -> icy_metaint = strtoull ( p , NULL , 10 ) ;}",122
1367,"if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse )  return ( ( void * ) NULL ) ;","if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) return ( ( void * ) NULL ) ;",123
1368,"
","xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;",124
1369,out_dqrele :  xfs_qm_dqrele ( udqp ) ;,out_dqrele : xfs_qm_dqrele ( udqp ) ;,124
1370,"case \'c\' : return getnum ( fmt , 1 ) ;case \'i\' : case \'I\' : {int sz = getnum ( fmt , sizeof ( int ) ) ;if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ;","case \'c\' : return getnum ( L , fmt , 1 ) ;case \'i\' : case \'I\' : {int sz = getnum ( L , fmt , sizeof ( int ) ) ;if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ;",125
1371,# endif  if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) {,# else ( void ) mb_idx ;# endif if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) {,126
1372,"vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_conceal_corrupt_mb ( xd ) ;vpx_memset ( xd -> eobs , 0 , 25 ) ;}","memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ;vp8_conceal_corrupt_mb ( xd ) ;memset ( xd -> eobs , 0 , 25 ) ;}",126
1373,"if ( xd -> mode_info_context -> mbmi . mb_skip_coeff )  vpx_memset ( xd -> eobs , 0 , 25 ) ;intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ;","if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) memset ( xd -> eobs , 0 , 25 ) ;intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ;",126
1374,"else {vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}","memset ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ;vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;",126
1375,"vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}","memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ;}",126
1376,"case VTP_SUBSET_ADV :  ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ;tptr += 4 ;while ( tptr < ( pptr + length ) ) {len = * tptr ;","case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ;tptr += 4 ;while ( tptr < ( pptr + length ) ) {ND_TCHECK_8BITS ( tptr ) ;len = * tptr ;",127
1377,"ssize_t count ;if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ;","ssize_t count ;if ( bytes == 0 || items == 0 ) return 0 ;if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ;",128
1378,"ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" ,  ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ;","if ( length < 2 ) {ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ;return ;}if ( ! ND_TTEST_16BITS ( p ) ) {ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ;return ;}ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ;",129
1379,"
","if ( rar -> dictionary_size == 0 ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size"" ) ;return ( ARCHIVE_FATAL ) ;}",130
1380,"if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context ,  rar -> dictionary_size , & g_szalloc ) ) {","if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , rar -> dictionary_size , & g_szalloc ) ) {",130
1381,"static int opl3_load_patch ( int dev , int format , const char __user * addr ,  int offs , int count , int pmgr_flag )  {if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) )  return - EFAULT ;","static int opl3_load_patch ( int dev , int format , const char __user * addr , int count , int pmgr_flag ) {if ( copy_from_user ( & ins , addr , sizeof ( ins ) - offs ) ) return - EFAULT ;",131
1382,"if ( dctx -> bytes ) {int n = min ( srclen , dctx -> bytes ) ;","if ( ! ctx -> gf128 ) return - ENOKEY ;if ( dctx -> bytes ) {int n = min ( srclen , dctx -> bytes ) ;",132
1383,"if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) {return - EACCES ;","if ( cgroup ) {if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ;if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) return - EACCES ;",133
1384,"if ( len > INT_MAX )  len = INT_MAX ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;","if ( len > INT_MAX ) len = INT_MAX ;if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;",134
1385,"ret = perf_output_begin ( & handle , event ,  throttle_event . header . size , 1 , 0 ) ;if ( ret ) return ;","ret = perf_output_begin ( & handle , event , throttle_event . header . size , 0 ) ;if ( ret ) return ;",135
1386,"if ( svm_set_msr ( & svm -> vcpu , & msr ) ) {trace_kvm_msr_write_ex ( ecx , data ) ;","if ( kvm_set_msr ( & svm -> vcpu , & msr ) ) {trace_kvm_msr_write_ex ( ecx , data ) ;",136
1387,"
",if ( Stream_GetRemainingLength ( licenseStream ) < 8 ) goto out_free_stream ;,137
1388,"Stream_Read_UINT16 ( licenseStream , os_minor ) ;Stream_Read_UINT16 ( licenseStream , os_major ) ;Stream_Read_UINT32 ( licenseStream , cbCompanyName ) ;if ( Stream_GetRemainingLength ( licenseStream ) < cbCompanyName ) goto out_free_stream ;Stream_Read_UINT32 ( licenseStream , cbProductId ) ;if ( Stream_GetRemainingLength ( licenseStream ) < cbProductId ) goto out_free_stream ;Stream_Read_UINT32 ( licenseStream , cbLicenseInfo ) ;if ( Stream_GetRemainingLength ( licenseStream ) < cbLicenseInfo ) goto out_free_stream ;","Stream_Read_UINT16 ( licenseStream , os_minor ) ;Stream_Read_UINT16 ( licenseStream , os_major ) ;if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ;Stream_Read_UINT32 ( licenseStream , cbCompanyName ) ;if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ;if ( Stream_GetRemainingLength ( licenseStream ) < cbCompanyName ) goto out_free_stream ;Stream_Read_UINT32 ( licenseStream , cbProductId ) ;if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ;if ( Stream_GetRemainingLength ( licenseStream ) < cbProductId ) goto out_free_stream ;Stream_Read_UINT32 ( licenseStream , cbLicenseInfo ) ;if ( Stream_GetRemainingLength ( licenseStream ) < cbLicenseInfo ) goto out_free_stream ;",137
1389,"umode_t mode = inode -> i_mode ;error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error < 0 ) {gossip_err ( ""%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\\if ( error == 0 )  acl = NULL ;","umode_t mode ;error = posix_acl_update_mode ( inode , & mode ) ;if ( error < 0 ) {gossip_err ( ""%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\\",138
1390,return SECURE_ELEMENT_ERROR_NPE ;},return SECURE_ELEMENT_ERROR_NPE ;}if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) {return SECURE_ELEMENT_ERROR_BUF_SIZE ;},139
1391,if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ;,if ( skb_is_err_queue ( skb ) && need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ;,140
1392,"if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) )  put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ;","if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ;",140
1393,while ( f != upto ) ;},while ( f && f != upto ) ;},141
1394,"len = netlink_send ( fd , message ) ;syslog ( LOG_ERR , ""netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ;pfd . events = POLLIN ;pfd . revents = 0 ;len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ;if ( len < 0 ) {syslog ( LOG_ERR , ""recv<S2SV_blank>failed;close ( fd ) ;","len = recvfrom ( fd , message ) ;syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) ) ;struct sockaddr * addr_p = ( struct sockaddr * ) & addr ;socklen_t addr_l = sizeof ( addr ) ;pfd . events = POLLIN ;pfd . revents = 0 ;len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ) ;if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recv<S2SV_blank>failed;close ( fd ) ;",142
1395,inode_init_once ( & ei -> vfs_inode ) ;},init_rwsem ( & ei -> i_mmap_sem ) ;inode_init_once ( & ei -> vfs_inode ) ;},143
1396,# else  if ( pbi -> common . frame_to_show )  {,# else ( void ) flags ;if ( pbi -> common . frame_to_show ) {,144
1397,"viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;","viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * viff_colormap ) ) ;",145
1398,"pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets ,  bytes_per_pixel * sizeof ( * pixels ) ) ;","pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , bytes_per_pixel * sizeof ( * pixels ) ) ;",145
1399,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;",146
1400,ReflectionMethodBuilder rmb ;MonoMethodSignature * sig ;int i ;sig = dynamic_method_to_signature ( mb ) ;,"MonoReferenceQueue * queue ;MonoMethod * handle ;DynamicMethodReleaseData * release_data ;ReflectionMethodBuilder rmb ;MonoMethodSignature * sig ;int i ;if ( mono_runtime_is_shutting_down ( ) ) mono_raise_exception ( mono_get_exception_invalid_operation ( """" ) ) ;if ( ! ( queue = dynamic_method_queue ) ) {mono_loader_lock ( ) ;if ( ! ( queue = dynamic_method_queue ) ) queue = dynamic_method_queue = mono_gc_reference_queue_new ( free_dynamic_method ) ;mono_loader_unlock ( ) ;}sig = dynamic_method_to_signature ( mb ) ;",147
1401,"mb -> mhandle = reflection_methodbuilder_to_mono_method ( klass , & rmb , sig ) ;for ( l = mb -> referenced_by ;","mb -> mhandle = handle = reflection_methodbuilder_to_mono_method ( klass , & rmb , sig ) ;release_data = g_new ( DynamicMethodReleaseData , 1 ) ;release_data -> handle = handle ;release_data -> domain = mono_object_get_domain ( ( MonoObject * ) mb ) ;if ( ! mono_gc_reference_queue_add ( queue , ( MonoObject * ) mb , release_data ) ) g_free ( release_data ) ;for ( l = mb -> referenced_by ;",147
1402,"int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex ,  double correction_factor ) {const double q = vp9_convert_qindex_to_q ( qindex ) ;int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ;enumerator += ( int ) ( enumerator * q ) >> 12 ;return ( int ) ( 0.5 + ( enumerator * correction_factor / q ) ) ;}","int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , double correction_factor , vpx_bit_depth_t bit_depth ) {const double q = vp9_convert_qindex_to_q ( qindex , bit_depth ) ;int enumerator = frame_type == KEY_FRAME ? 2700000 : 1800000 ;assert ( correction_factor <= MAX_BPB_FACTOR && correction_factor >= MIN_BPB_FACTOR ) ;enumerator += ( int ) ( enumerator * correction_factor / q ) ;}",148
1403,"
",ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;,149
1404,"ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" ,  EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ;","ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ;",149
1405,int retval ;int remount_ro ;if ( sb -> s_writers . frozen != SB_UNFROZEN ) return - EBUSY ;# ifdef CONFIG_BLOCK if ( ! ( flags & MS_RDONLY ) && bdev_read_only ( sb -> s_bdev ) ) return - EACCES ;# endif if ( flags & MS_RDONLY ) acct_auto_close ( sb ) ;shrink_dcache_sb ( sb ) ;sync_filesystem ( sb ) ;remount_ro = ( flags & MS_RDONLY ) && ! ( sb -> s_flags & MS_RDONLY ) ;if ( remount_ro ) {if ( force ) {mark_files_ro ( sb ) ;},sb -> s_readonly_remount = 1 ;smp_wmb ( ) ;},150
1406,"while ( ( s = mcs_recv ( & channel , is_fastpath , & fastpath_hdr ) ) != NULL )   {if ( * is_fastpath == True ) {if ( fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED )  {in_uint8s ( s , 8 ) ;","struct stream packet ;while ( ( s = mcs_recv ( & channel , is_fastpath , & fastpath_hdr ) ) != NULL ) {packet = * s ;if ( * is_fastpath == True ) {if ( fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED ) {if ( ! s_check_rem ( s , 8 ) ) {rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>fastpath<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , 8 ) ;",151
1407,"in_uint8s ( s , 8 ) ;sec_decrypt ( s -> p , s -> end - s -> p ) ;uint8 swapbyte ;in_uint8s ( s , 8 ) ;","if ( ! s_check_rem ( s , 8 ) ) {rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>encrypt<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , 8 ) ;sec_decrypt ( s -> p , s -> end - s -> p ) ;uint8 swapbyte ;if ( ! s_check_rem ( s , 8 ) ) {rdp_protocol_error ( ""sec_recv(),<S2SV_blank>consume<S2SV_blank>redirect<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , 8 ) ;",151
1408,"static void ip6_append_data_mtu ( int * mtu ,  int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb ,  struct rt6_info * rt )  {* mtu = * mtu - rt -> dst . header_len ;* mtu = dst_mtu ( rt -> dst . path ) ;}","static void ip6_append_data_mtu ( unsigned int * mtu , int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb , struct rt6_info * rt , bool pmtuprobe ) {* mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : * mtu - rt -> dst . header_len ;* mtu = dst_mtu ( rt -> dst . path ) ) ;}",152
1409,"vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ;index += 8 ;* above_y |= ( size_mask [ block_size ] & above_64x64_txform_mask [ tx_size_y ] ) << shift_y ;if ( tx_size_y == TX_4X4 )  * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ;}","memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ;index += 8 ;* above_y |= ( size_mask [ block_size ] & 0xffffffffffffffffULL ) << shift_y ;if ( tx_size_y == TX_4X4 ) * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ;}",153
1410,rfcomm_dlc_accept ( d ) ;return 0 ;,rfcomm_dlc_accept ( d ) ;msg -> msg_namelen = 0 ;return 0 ;,154
1411,"if ( ! vct_iscrlf ( hp -> rxbuf [ l ] ) )  vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[0]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l ] & 0xff ) ;if ( ! vct_iscrlf ( hp -> rxbuf [ l + 1 ] ) )  vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[1]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l + 1 ] & 0xff ) ;","if ( ! vct_iscrlf ( & hp -> rxbuf [ l ] ) ) vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[0]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l ] & 0xff ) ;if ( ! vct_iscrlf ( & hp -> rxbuf [ l + 1 ] ) ) vtc_log ( hp -> vl , hp -> fatal , ""Wrong<S2SV_blank>chunk<S2SV_blank>tail[1]<S2SV_blank>=<S2SV_blank>%02x"" , hp -> rxbuf [ l + 1 ] & 0xff ) ;",155
1412,"
","if ( samples_in_chunk < 1 ) {av_log ( s , AV_LOG_ERROR , ""fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\\return AVERROR_PATCHWELCOME ;}",156
1413,if ( trk -> vos_len == 0 && par -> extradata_size > 0 &&  ! TAG_IS_AVCI ( trk -> tag ) && ( par -> codec_id != AV_CODEC_ID_DNXHD ) ) {,if ( trk -> vos_len == 0 && par -> extradata_size > 0 && ! TAG_IS_AVCI ( trk -> tag ) && ( par -> codec_id != AV_CODEC_ID_DNXHD ) ) {,156
1414,"ND_TCHECK2 ( * data1 , 2 ) ;bcc = EXTRACT_LE_16BITS ( data1 ) ;ND_PRINT ( ( ndo , ""smb_bcc=%u\\\if ( bcc > 0 ) {smb_fdata ( ndo , data1 + 2 , f2 , maxbuf - ( paramlen + datalen ) , unicodestr ) ;if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\\\\\MAILSLOT\\\\\\\\BROWSE"" ) == 0 ) {print_browse ( ndo , param , paramlen , data , datalen ) ;if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\\\\\PIPE\\\\\\\\LANMAN"" ) == 0 ) {print_ipc ( ndo , param , paramlen , data , datalen ) ;if ( paramlen )  smb_fdata ( ndo , param , f3 , min ( param + paramlen , maxbuf ) , unicodestr ) ;","# define MAILSLOT_BROWSE_STR ""\\\\\\\\MAILSLOT\\\\\\\\BROWSE"" ND_TCHECK2 ( * ( data1 + 2 ) , MAILSLOT_BROWSE_STR ) == 0 ) {print_browse ( ndo , param , paramlen , data , datalen ) ;# undef MAILSLOT_BROWSE_STR # define PIPE_LANMAN_STR ""\\\\\\\\PIPE\\\\\\\\LANMAN"" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( PIPE_LANMAN_STR ) + 1 ) ;if ( strcmp ( ( const char * ) ( data1 + 2 ) , ""\\\\\\\\PIPE\\\\\\\\LANMAN"" ) == 0 ) {print_ipc ( ndo , param , paramlen , data , datalen ) ;# undef PIPE_LANMAN_STR if ( paramlen ) smb_fdata ( ndo , param , f3 , min ( param + paramlen , maxbuf ) , unicodestr ) ;",157
1415,"void open_input_file ( struct VpxInputContext * input ) {input -> file = strcmp ( input -> filename , ""-"" ) ? fopen ( input -> filename , ""rb"" ) : set_binary_mode ( stdin ) ;input -> detect . buf_read = fread ( input -> detect . buf , 1 , 4 , input -> file ) ;input -> detect . position = 0 ;if ( input -> detect . buf_read == 4 && file_is_y4m ( input -> detect . buf ) ) {if ( y4m_input_open ( & input -> y4m , input -> file , input -> detect . buf , 4 , input -> only_i420 ) >= 0 ) {input -> file_type = FILE_TYPE_Y4M ;input -> width = input -> y4m . pic_w ;input -> height = input -> y4m . pic_h ;input -> framerate . numerator = input -> y4m . fps_n ;input -> framerate . denominator = input -> y4m . fps_d ;input -> use_i420 = 0 ;}","static void open_input_file ( struct VpxInputContext * input ) {input -> file = strcmp ( input -> filename , ""-"" ) ? fopen ( input -> filename , ""rb"" ) : set_binary_mode ( stdin ) ;input -> pixel_aspect_ratio . numerator = 1 ;input -> fmt = input -> y4m . vpx_fmt ;input -> bit_depth = input -> y4m . bit_depth ;}",158
1416,"# if ENABLE_BGP_VNC  bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ;","# if ENABLE_BGP_VNC_ATTR bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ;",159
1417,"err = ops -> ieee_getets ( netdev , & ets ) ;if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ;err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ;if ( ! err ) {struct ieee_pfc pfc ;err = ops -> ieee_getpfc ( netdev , & pfc ) ;","memset ( & ets , 0 , sizeof ( ets ) ) ;err = ops -> ieee_getets ( netdev , & ets ) ;if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ;memset ( & maxrate , 0 , sizeof ( maxrate ) ) ;err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ;if ( ! err ) {struct ieee_pfc pfc ;memset ( & pfc , 0 , sizeof ( pfc ) ) ;err = ops -> ieee_getpfc ( netdev , & pfc ) ;",160
1418,"err = ops -> ieee_peer_getets ( netdev , & ets ) ;if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ;struct ieee_pfc pfc ;err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ;","memset ( & ets , 0 , sizeof ( ets ) ) ;err = ops -> ieee_peer_getets ( netdev , & ets ) ;if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ;struct ieee_pfc pfc ;memset ( & pfc , 0 , sizeof ( pfc ) ) ;err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ;",160
1419,"return ;}ND_PRINT ( ( ndo , ""CFMv%u<S2SV_blank>%s,<S2SV_blank>MD<S2SV_blank>Level<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , tok2str ( cfm_opcode_values , ""unknown<S2SV_blank>(%u)"" , cfm_common_header -> opcode ) , CFM_EXTRACT_MD_LEVEL ( cfm_common_header -> mdlevel_version ) , length ) ) ;if ( ndo -> ndo_vflag < 1 ) {return ;}ND_PRINT ( ( ndo , ""\\\tptr += sizeof ( const struct cfm_common_header_t ) ;tlen = length - sizeof ( struct cfm_common_header_t ) ;if ( cfm_common_header -> first_tlv_offset > tlen ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , tlen ) ) ;return ;}switch ( cfm_common_header -> opcode ) {case CFM_OPCODE_CCM : msg_ptr . cfm_ccm = ( const struct cfm_ccm_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ccm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>1,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ccm ) ) ) ;return ;if ( tlen < sizeof ( * msg_ptr . cfm_ccm ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ccm ) ;ccm_interval = CFM_EXTRACT_CCM_INTERVAL ( cfm_common_header -> flags ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[CCM<S2SV_blank>Interval<S2SV_blank>%u%s]"" , ccm_interval , cfm_common_header -> flags & CFM_CCM_RDI_FLAG ? "",<S2SV_blank>RDI"" : """" ) ) ;if ( ccm_interval ) {ND_PRINT ( ( ndo , ""\\\}ND_PRINT ( ( ndo , ""\\\namesp = msg_ptr . cfm_ccm -> names ;names_data_remaining = sizeof ( msg_ptr . cfm_ccm -> names ) ;md_nameformat = * namesp ;namesp ++ ;names_data_remaining -- ;if ( md_nameformat != CFM_CCM_MD_FORMAT_NONE ) {md_namelength = * namesp ;namesp ++ ;names_data_remaining -- ;ND_PRINT ( ( ndo , ""\\\if ( md_namelength > names_data_remaining - 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining - 2 ) ) ;return ;}md_name = namesp ;ND_PRINT ( ( ndo , ""\\\switch ( md_nameformat ) {case CFM_CCM_MD_FORMAT_DNS : case CFM_CCM_MD_FORMAT_CHAR : safeputs ( ndo , md_name , md_namelength ) ;break ;case CFM_CCM_MD_FORMAT_MAC : if ( md_namelength == 6 ) {ND_PRINT ( ( ndo , ""\\\}else {ND_PRINT ( ( ndo , ""\\\}break ;case CFM_CCM_MA_FORMAT_8021 : default : print_unknown_data ( ndo , md_name , ""\\\}namesp += md_namelength ;names_data_remaining -= md_namelength ;}else {ND_PRINT ( ( ndo , ""\\\}ma_nameformat = * namesp ;namesp ++ ;names_data_remaining -- ;ma_namelength = * namesp ;namesp ++ ;names_data_remaining -- ;ND_PRINT ( ( ndo , ""\\\if ( ma_namelength > names_data_remaining ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)"" , names_data_remaining ) ) ;return ;}ma_name = namesp ;ND_PRINT ( ( ndo , ""\\\switch ( ma_nameformat ) {case CFM_CCM_MA_FORMAT_CHAR : safeputs ( ndo , ma_name , ma_namelength ) ;break ;case CFM_CCM_MA_FORMAT_8021 : case CFM_CCM_MA_FORMAT_VID : case CFM_CCM_MA_FORMAT_INT : case CFM_CCM_MA_FORMAT_VPN : default : print_unknown_data ( ndo , ma_name , ""\\\}break ;case CFM_OPCODE_LTM : msg_ptr . cfm_ltm = ( const struct cfm_ltm_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltm ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>4,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltm ) ) ) ;return ;}if ( tlen < sizeof ( * msg_ptr . cfm_ltm ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ltm ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltm_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case CFM_OPCODE_LTR : msg_ptr . cfm_ltr = ( const struct cfm_ltr_t * ) tptr ;if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltr ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>5,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)"" , ( unsigned long ) sizeof ( * msg_ptr . cfm_ltr ) ) ) ;return ;}if ( tlen < sizeof ( * msg_ptr . cfm_ltr ) ) goto tooshort ;ND_TCHECK ( * msg_ptr . cfm_ltr ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( cfm_ltr_flag_values , ""none"" , cfm_common_header -> flags ) ) ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;case CFM_OPCODE_LBR : case CFM_OPCODE_LBM : default : print_unknown_data ( ndo , tptr , ""\\\break ;}tptr += cfm_common_header -> first_tlv_offset ;tlen -= cfm_common_header -> first_tlv_offset ;while ( tlen > 0 ) {cfm_tlv_header = ( const struct cfm_tlv_header_t * ) tptr ;ND_TCHECK2 ( * tptr , 1 ) ;cfm_tlv_type = cfm_tlv_header -> type ;ND_PRINT ( ( ndo , ""\\\if ( cfm_tlv_type == CFM_TLV_END ) {return ;}if ( tlen < sizeof ( struct cfm_tlv_header_t ) ) goto tooshort ;ND_TCHECK2 ( * tptr , sizeof ( struct cfm_tlv_header_t ) ) ;cfm_tlv_len = EXTRACT_16BITS ( & cfm_tlv_header -> length ) ;ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , cfm_tlv_len ) ) ;tptr += sizeof ( struct cfm_tlv_header_t ) ;tlen -= sizeof ( struct cfm_tlv_header_t ) ;tlv_ptr = tptr ;if ( tlen < cfm_tlv_len ) goto tooshort ;ND_TCHECK2 ( * tptr , cfm_tlv_len ) ;hexdump = FALSE ;switch ( cfm_tlv_type ) {case CFM_TLV_PORT_STATUS : if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_port_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ;break ;case CFM_TLV_INTERFACE_STATUS : if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( cfm_tlv_interface_status_values , ""Unknown"" , * tptr ) , * tptr ) ) ;break ;case CFM_TLV_PRIVATE : if ( cfm_tlv_len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ;return ;}ND_PRINT ( ( ndo , "",<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Sub-Type<S2SV_blank>%u"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( tptr ) ) , EXTRACT_24BITS ( tptr ) , * ( tptr + 3 ) ) ) ;hexdump = TRUE ;break ;case CFM_TLV_SENDER_ID : {u_int chassis_id_type , chassis_id_length ;u_int mgmt_addr_length ;if ( cfm_tlv_len < 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)"" ) ) ;return ;}",goto next_tlv ;,161
1420,"return ;}return ;}case CFM_CHASSIS_ID_MAC_ADDRESS :  ND_PRINT ( ( ndo , ""\\\case CFM_CHASSIS_ID_NETWORK_ADDRESS :  hexdump |= cfm_network_addr_print ( ndo , tptr ) ;break ;","return ;}return ;}case CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , ""\\\break ;case CFM_CHASSIS_ID_NETWORK_ADDRESS : hexdump |= cfm_network_addr_print ( ndo , tptr ) ;",161
1421,"return ;}if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {return ;}cfm_tlv_len -= mgmt_addr_length ;tptr += mgmt_addr_length ;ND_PRINT ( ( ndo , ""\\\return ;if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {cfm_tlv_len -= mgmt_addr_length ;tptr += mgmt_addr_length ;","return ;}ND_PRINT ( ( ndo , ""\\\if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {return ;}cfm_tlv_len -= mgmt_addr_length ;hex_print ( ndo , ""\\\tptr += mgmt_addr_length ;ND_PRINT ( ( ndo , ""\\\return ;ND_PRINT ( ( ndo , ""\\\if ( mgmt_addr_length ) {if ( cfm_tlv_len < mgmt_addr_length ) {cfm_tlv_len -= mgmt_addr_length ;hex_print ( ndo , ""\\\tptr += mgmt_addr_length ;",161
1422,tptr += cfm_tlv_len ;tlen -= cfm_tlv_len ;,next_tlv : tptr += cfm_tlv_len ;tlen -= cfm_tlv_len ;,161
1423,"void fadst4_sse2 ( __m128i * in ) {const __m128i k__sinpi_p01_p02 = pair_set_epi16 ( sinpi_1_9 , sinpi_2_9 ) ;const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( sinpi_3_9 ) ;const __m128i kZero = _mm_set1_epi16 ( 0 ) ;","static void fadst4_sse2 ( __m128i * in ) {const __m128i k__sinpi_p01_p02 = pair_set_epi16 ( sinpi_1_9 , sinpi_2_9 ) ;const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( ( int16_t ) sinpi_3_9 ) ;const __m128i kZero = _mm_set1_epi16 ( 0 ) ;",162
1424,"printf ( ""Using<S2SV_blank>%s\\\if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ;","printf ( ""Using<S2SV_blank>%s\\\if ( vpx_codec_dec_init ( & codec , decoder -> codec_interface ( ) , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ;",163
1425,"int copied , error = - EINVAL ;if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ;","int copied , error = - EINVAL ;msg -> msg_namelen = 0 ;if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ;",164
1426,"case XCOL_SOURCE_RECV_OP :  rc = target_xcopy_locate_se_dev_e4 ( xop -> dst_tid_wwn ,   & xop -> dst_dev ) ;break ;case XCOL_DEST_RECV_OP :  rc = target_xcopy_locate_se_dev_e4 ( xop -> src_tid_wwn ,   & xop -> src_dev ) ;break ;","case XCOL_SOURCE_RECV_OP : rc = target_xcopy_locate_se_dev_e4 ( se_cmd -> se_sess , xop -> dst_tid_wwn , & xop -> dst_dev , & xop -> remote_lun_ref ) ;break ;case XCOL_DEST_RECV_OP : rc = target_xcopy_locate_se_dev_e4 ( se_cmd -> se_sess , xop -> src_tid_wwn , & xop -> src_dev , & xop -> remote_lun_ref ) ;break ;",165
1427,"void ipc_rcu_getref ( void * ptr )  {container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount ++ ;}","int ipc_rcu_getref ( void * ptr ) {return atomic_inc_not_zero ( & container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount ) ;}",166
1428,"if ( NULL == siocb -> scm ) siocb -> scm = & scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;","if ( NULL == siocb -> scm , true ) siocb -> scm = & scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;",167
1429,"viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;","viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * viff_colormap ) ) ;",168
1430,"pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets ,  bytes_per_pixel * sizeof ( * pixels ) ) ;","pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , bytes_per_pixel * sizeof ( * pixels ) ) ;",168
1431,"size_t size ;if ( jpg_dec_parseopts ( optstr , & opts ) ) {memset ( & cinfo , 0 , sizeof ( struct jpeg_decompress_struct ) ) ;memset ( dest_mgr , 0 , sizeof ( jpg_dest_t ) ) ;dest_mgr -> data = 0 ;image = 0 ;input_file = 0 ;if ( ! ( input_file = tmpfile ( ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>make<S2SV_blank>temporary<S2SV_blank>file\\\goto error ;}if ( jpg_copystreamtofile ( input_file , in ) ) {jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>stream\\\goto error ;}rewind ( input_file ) ;JAS_DBGLOG ( 10 , ( ""jpeg_std_error(%p)\\\cinfo . err = jpeg_std_error ( & jerr ) ;JAS_DBGLOG ( 10 , ( ""jpeg_create_decompress(%p)\\\jpeg_create_decompress ( & cinfo ) ;JAS_DBGLOG ( 10 , ( ""jpeg_stdio_src(%p,<S2SV_blank>%p)\\\jpeg_stdio_src ( & cinfo , input_file ) ;JAS_DBGLOG ( 10 , ( ""jpeg_read_header(%p,<S2SV_blank>TRUE)\\\ret = jpeg_read_header ( & cinfo , TRUE ) ;JAS_DBGLOG ( 10 , ( ""jpeg_read_header<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d\\\if ( ret != JPEG_HEADER_OK ) {jas_eprintf ( ""jpeg_read_header<S2SV_blank>did<S2SV_blank>not<S2SV_blank>return<S2SV_blank>JPEG_HEADER_OK\\\}JAS_DBGLOG ( 10 , ( ""header:<S2SV_blank>image_width<S2SV_blank>%d;<S2SV_blank>image_height<S2SV_blank>%d;<S2SV_blank>num_components<S2SV_blank>%d\\\JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress(%p)\\\ret = jpeg_start_decompress ( & cinfo ) ;JAS_DBGLOG ( 10 , ( ""jpeg_start_decompress<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d\\\JAS_DBGLOG ( 10 , ( ""header:<S2SV_blank>output_width<S2SV_blank>%d;<S2SV_blank>output_height<S2SV_blank>%d;<S2SV_blank>output_components<S2SV_blank>%d\\\if ( opts . max_size ) {if ( ! jas_safe_size_mul ( cinfo . output_width , cinfo . output_height ,  & size ) || ! jas_safe_size_mul ( size , cinfo . output_components , & size ) ) {if ( size > opts . max_size ) {jas_eprintf ( ""image<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\goto error ;}if ( ! ( image = jpg_mkimage ( & cinfo ) ) ) {","size_t num_samples ;JAS_DBGLOG ( 100 , ( ""jpg_decode(%p,<S2SV_blank>\\\\""%s\\\\"")\\\if ( opts . max_size ) {if ( ! jas_safe_size_mul ( cinfo . output_width , cinfo . output_height , & size ) || ! jas_safe_size_mul ( size , cinfo . output_components , & size ) ) {if ( size > opts . max_size ) {jas_eprintf ( ""image<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\if ( ! ( image = jpg_mkimage ( & cinfo ) ) ) {",169
1432,"jas_eprintf ( ""error<S2SV_blank>during<S2SV_blank>decoding\\\","jas_eprintf ( ""image<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%zu<S2SV_blank>><S2SV_blank>%zu)\\\",169
1433,mutex_lock ( & tu -> tread_sem ) ;if ( tu -> timeri ) {,if ( tu -> timeri ) {,170
1434,__err :  mutex_unlock ( & tu -> tread_sem ) ;return err ;,__err : return err ;,170
1435,"
",len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ;,171
1436,"if ( IS_NOT_NULL ( Else ) ) {len += SIZE_OP_JUMP ;tlen = compile_length_tree ( Else , reg ) ;","if ( IS_NOT_NULL ( Else ) ) {len += SIZE_OP_JUMP ;tlen = compile_length_tree ( Else , reg ) ;",171
1437,dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;dev -> tx_queue_len = 0 ;,dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;dev -> tx_queue_len = 0 ;,172
1438,"int i , protocol ;host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ;","int i , protocol ;int rest_bytes ;host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ;",173
1439,"switch ( protocol ) {default : dev_warn ( & dev -> dev , ""unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\\if ( ! h1 -> bInCollection ) {dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\\return - EINVAL ;","rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ;if ( rest_bytes < sizeof ( * h1 ) ) {dev_err ( & dev -> dev , ""too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\\return - EINVAL ;}if ( rest_bytes <= 0 ) {dev_err ( & dev -> dev , ""invalid<S2SV_blank>control<S2SV_blank>header\\\return - EINVAL ;}switch ( protocol ) {default : dev_warn ( & dev -> dev , ""unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\\if ( ! h1 -> bInCollection ) {dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\\return - EINVAL ;}if ( rest_bytes < h1 -> bLength ) {dev_err ( & dev -> dev , ""invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\\return - EINVAL ;",173
1440,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",174
1441,"
",if ( sk != rcvr -> sk ) {sctp_bh_unlock_sock ( sk ) ;sk = rcvr -> sk ;sctp_bh_lock_sock ( sk ) ;},175
1442,if ( sock_owned_by_user ( sk ) ) {SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ;,if ( sock_owned_by_user ( sk ) ) {SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ;,175
1443,"Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",176
1444,"static void  horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 4 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 4 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff32"" , ""%s"" , ""(cc%(4*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",177
1445,},return 1 ;},177
1446,"struct r_bin_dyldcache_obj_t * bin ;if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) {return NULL ;memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ;if ( ! buf ) {if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) {return r_bin_dyldcache_free ( bin ) ;","struct r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) ;if ( ! bin ) {return NULL ;memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ;if ( ! bin -> b || ! buf ) {if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) {return r_bin_dyldcache_free ( bin ) ;",178
1447,"static unsigned short len = 0 ;char buff [ 13 ] , * ret_msg = NULL ;","static size_t len = 0 ;char buff [ 13 ] , * ret_msg = NULL ;",179
1448,"static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key ,  unsigned int keylen ) {","int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , unsigned int keylen ) {",180
1449,"tile -> mi_row_start = get_tile_offset ( row , cm -> mi_rows , cm -> log2_tile_rows ) ;tile -> mi_row_end = get_tile_offset ( row + 1 , cm -> mi_rows , cm -> log2_tile_rows ) ;tile -> mi_col_start = get_tile_offset ( col , cm -> mi_cols , cm -> log2_tile_cols ) ;tile -> mi_col_end = get_tile_offset ( col + 1 , cm -> mi_cols , cm -> log2_tile_cols ) ;","vp9_tile_set_row ( tile , cm , row ) ;vp9_tile_set_col ( tile , cm , col ) ;",181
1450,static double get_rate_correction_factor ( const VP9_COMP * cpi ) {if ( cpi -> common . frame_type == KEY_FRAME ) {return cpi -> rc . key_frame_rate_correction_factor ;}if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) &&  ! cpi -> rc . is_src_frame_alt_ref &&   ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) )  return cpi -> rc . gf_rate_correction_factor ;else return cpi -> rc . rate_correction_factor ;,"static double get_rate_correction_factor ( const VP9_COMP * cpi ) {const RATE_CONTROL * const rc = & cpi -> rc ;double rcf ;if ( cpi -> common . frame_type == KEY_FRAME ) {rcf = rc -> rate_correction_factors [ KF_STD ] ;}else if ( cpi -> oxcf . pass == 2 ) {RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ;rcf = rc -> rate_correction_factors [ rf_lvl ] ;}if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && ! rc -> is_src_frame_alt_ref && ! ( cpi -> use_svc && ( cpi -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rcf = rc -> rate_correction_factors [ GF_ARF_STD ] ;else rcf = rc -> rate_correction_factors [ INTER_NORMAL ] ;rcf *= rcf_mult [ rc -> frame_size_selector ] ;return fclamp ( rcf , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ;",182
1451,"# define ThrowDCMException ( exception , message ) {","# define ThrowDCMException ( exception , message ) \\\\\",183
1452,"}char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;","\\\\\char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;",183
1453,"
","if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",183
1454,if ( tag == 0xFFFEE0DD )  break ;,if ( tag == 0xFFFEE0DD ) break ;,183
1455,"int val = 1 ;cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ;","int val = 1 ;if ( ssocket == NULL ) return - ENOTSOCK ;cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ;",184
1456,}awaiting_character = false ;,}recovery_started = false ;awaiting_character = false ;,185
1457,"char query [ 255 ] , rows [ NAME_LEN ] , fields [ 16 ] ;MYSQL_FIELD * field ;","char query [ NAME_LEN + 100 ] , rows [ NAME_LEN ] , fields [ 16 ] ;MYSQL_FIELD * field ;",186
1458,"sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , row [ 0 ] ) ;if ( ! ( mysql_query ( mysql , query ) ) ) {","my_snprintf ( query , sizeof ( query ) , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , row [ 0 ] ) ;if ( ! ( mysql_query ( mysql , query ) ) ) {",186
1459,mlock_vma_page ( page ) ;if ( page == check_page )   ret = SWAP_MLOCK ;continue ;,if ( page == check_page ) {mlock_vma_page ( page ) ;ret = SWAP_MLOCK ;}else if ( trylock_page ( page ) ) {mlock_vma_page ( page ) ;unlock_page ( page ) ;}continue ;,187
1460,if ( rs -> rs_bound_addr == 0 ) {ret = - ENOTCONN ;,if ( rs -> rs_bound_addr == 0 || ! rs -> rs_transport ) {ret = - ENOTCONN ;,188
1461,int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 )  / body -> unit_size ;,int n ;if ( ! body -> unit_size ) break ;n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ;,189
1462,"data = malloc ( blk_sz * n_blks ) ;memset ( data , 0 , blk_sz * n_blks ) ;","data = safe_calloc ( blk_sz * n_blks ) ;memset ( data , 0 , blk_sz * n_blks ) ;",190
1463,"int vp8_denoiser_filter_sse2 ( YV12_BUFFER_CONFIG * mc_running_avg ,  YV12_BUFFER_CONFIG * running_avg , MACROBLOCK * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) {unsigned char * sig = signal -> thismb ;int sig_stride = 16 ;unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ;int mc_avg_y_stride = mc_running_avg -> y_stride ;unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ;int avg_y_stride = running_avg -> y_stride ;__m128i acc_diff = _mm_setzero_si128 ( ) ;const __m128i k_0 = _mm_setzero_si128 ( ) ;const __m128i k_4 = _mm_set1_epi8 ( 4 ) ;const __m128i k_8 = _mm_set1_epi8 ( 8 ) ;const __m128i k_16 = _mm_set1_epi8 ( 16 ) ;const __m128i l3 = _mm_set1_epi8 (  ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 : 6 ) ;const __m128i l32 = _mm_set1_epi8 ( 2 ) ;","int vp8_denoiser_filter_sse2 ( unsigned char * sig = signal -> thismb ;int sig_stride = 16 ;unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ;int mc_avg_y_stride = mc_running_avg -> y_stride ;unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) {unsigned char * running_avg_y_start = running_avg_y ;unsigned char * sig_start = sig ;unsigned int sum_diff_thresh ;int shift_inc = ( increase_denoising && motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 : 6 ) ;const __m128i l32 = _mm_set1_epi8 ( 2 ) ;",191
1464,"union sum_union s ;int sum_diff = 0 ;s . v = acc_diff ;sum_diff = s . e [ 0 ] + s . e [ 1 ] + s . e [ 2 ] + s . e [ 3 ] + s . e [ 4 ] + s . e [ 5 ]  + s . e [ 6 ] + s . e [ 7 ] + s . e [ 8 ] + s . e [ 9 ] + s . e [ 10 ] + s . e [ 11 ] + s . e [ 12 ] + s . e [ 13 ] + s . e [ 14 ] + s . e [ 15 ] ;if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD )  {}vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride ,  signal -> thismb , sig_stride ) ;return FILTER_BLOCK ;","unsigned int abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) ;sum_diff_thresh = SUM_DIFF_THRESHOLD ;if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ;if ( abs_sum_diff > sum_diff_thresh ) {int delta = ( ( abs_sum_diff - sum_diff_thresh ) >> 8 ) + 1 ;if ( delta < 4 ) {const __m128i k_delta = _mm_set1_epi8 ( delta ) ;sig -= sig_stride * 16 ;mc_running_avg_y -= mc_avg_y_stride * 16 ;running_avg_y -= avg_y_stride * 16 ;for ( r = 0 ;r < 16 ;++ r ) {__m128i v_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & running_avg_y [ 0 ] ) ) ;const __m128i v_sig = _mm_loadu_si128 ( ( __m128i * ) ( & sig [ 0 ] ) ) ;const __m128i v_mc_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & mc_running_avg_y [ 0 ] ) ) ;const __m128i pdiff = _mm_subs_epu8 ( v_mc_running_avg_y , v_sig ) ;const __m128i ndiff = _mm_subs_epu8 ( v_sig , v_mc_running_avg_y ) ;const __m128i diff_sign = _mm_cmpeq_epi8 ( pdiff , k_0 ) ;const __m128i adj = _mm_min_epu8 ( _mm_or_si128 ( pdiff , ndiff ) , k_delta ) ;__m128i padj , nadj ;padj = _mm_andnot_si128 ( diff_sign , adj ) ;nadj = _mm_and_si128 ( diff_sign , adj ) ;v_running_avg_y = _mm_subs_epu8 ( v_running_avg_y , padj ) ;v_running_avg_y = _mm_adds_epu8 ( v_running_avg_y , nadj ) ;_mm_storeu_si128 ( ( __m128i * ) running_avg_y , v_running_avg_y ) ;acc_diff = _mm_subs_epi8 ( acc_diff , padj ) ;acc_diff = _mm_adds_epi8 ( acc_diff , nadj ) ;sig += sig_stride ;mc_running_avg_y += mc_avg_y_stride ;running_avg_y += avg_y_stride ;}abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) ;if ( abs_sum_diff > sum_diff_thresh ) {}vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , avg_y_stride , sig_start , sig_stride ) ;return FILTER_BLOCK ;",191
1465,"r = vapic_enter ( vcpu ) ;if ( r ) {srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;return r ;}kvm_vcpu_block ( vcpu ) ;vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ;if ( kvm_check_request ( KVM_REQ_UNHALT , vcpu ) ) {kvm_apic_accept_events ( vcpu ) ;switch ( vcpu -> arch . mp_state ) {case KVM_MP_STATE_HALTED : vcpu -> arch . pv . pv_unhalted = false ;vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ;case KVM_MP_STATE_RUNNABLE : vcpu -> arch . apf . halted = false ;break ;case KVM_MP_STATE_INIT_RECEIVED : break ;default : r = - EINTR ;break ;}}}if ( r <= 0 ) break ;clear_bit ( KVM_REQ_PENDING_TIMER , & vcpu -> requests ) ;if ( kvm_cpu_has_pending_timer ( vcpu ) ) kvm_inject_pending_timer_irqs ( vcpu ) ;if ( dm_request_for_irq_injection ( vcpu ) ) {r = - EINTR ;vcpu -> run -> exit_reason = KVM_EXIT_INTR ;++ vcpu -> stat . request_irq_exits ;}kvm_check_async_pf_completion ( vcpu ) ;if ( signal_pending ( current ) ) {r = - EINTR ;vcpu -> run -> exit_reason = KVM_EXIT_INTR ;++ vcpu -> stat . signal_exits ;}if ( need_resched ( ) ) {srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;kvm_resched ( vcpu ) ;vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ;}}srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;vapic_exit ( vcpu ) ;return r ;",+ vcpu -> stat . request_irq_exits ;+ vcpu -> stat . signal_exits ;return r ;,192
1466,"int __usb_get_extra_descriptor ( char * buffer , unsigned size ,  unsigned char type , void * * ptr )  {if ( header -> bLength < 2 ) {printk ( KERN_ERR ""%s:<S2SV_blank>bogus<S2SV_blank>descriptor,<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\\if ( header -> bDescriptorType == type ) {* ptr = header ;","int __usb_get_extra_descriptor ( char * buffer , unsigned size , unsigned char type , void * * ptr , size_t minsize ) {if ( header -> bLength < 2 || header -> bLength > size ) {printk ( KERN_ERR ""%s:<S2SV_blank>bogus<S2SV_blank>descriptor,<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\\if ( header -> bDescriptorType == type && header -> bLength >= minsize ) {* ptr = header ;",193
1467,case DH6OPT_RECONF_MSG :  tp = ( const u_char * ) ( dh6o + 1 ) ;,"case DH6OPT_RECONF_MSG : if ( optlen != 1 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ;break ;}tp = ( const u_char * ) ( dh6o + 1 ) ;",194
1468,"wait_event_interruptible_timeout ( sunkbd -> wait , sunkbd -> reset >= 0 , HZ ) ;serio_write ( sunkbd -> serio , SUNKBD_CMD_SETLED ) ;serio_write ( sunkbd -> serio , ( ! ! test_bit ( LED_CAPSL , sunkbd -> dev -> led ) << 3 ) | ( ! ! test_bit ( LED_SCROLLL , sunkbd -> dev -> led ) << 2 ) | ( ! ! test_bit ( LED_COMPOSE , sunkbd -> dev -> led ) << 1 ) | ! ! test_bit ( LED_NUML , sunkbd -> dev -> led ) ) ;serio_write ( sunkbd -> serio , SUNKBD_CMD_NOCLICK - ! ! test_bit ( SND_CLICK , sunkbd -> dev -> snd ) ) ;serio_write ( sunkbd -> serio , SUNKBD_CMD_BELLOFF - ! ! test_bit ( SND_BELL , sunkbd -> dev -> snd ) ) ;","wait_event_interruptible_timeout ( sunkbd -> wait , sunkbd -> reset >= 0 || ! sunkbd -> enabled , HZ ) ;if ( sunkbd -> serio , SUNKBD_CMD_SETLED ) ;serio_write ( sunkbd -> reset >= 0 && sunkbd -> enabled ) sunkbd_set_leds_beeps ( sunkbd ) ;",195
1469,"if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) )  MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;filepos = TellBlob ( image ) ;","if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) {MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}filepos = TellBlob ( image ) ;",196
1470,"buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ;buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ;","if ( uri_ptr [ alias_len ] == '.' ) {char * s = uri_ptr + alias_len + 1 ;if ( * s == '.' ) ++ s ;if ( * s == '/' || * s == '\\\\0' ) {size_t vlen = buffer_string_length ( ds -> value ) ;if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) {con -> http_status = 403 ;return HANDLER_FINISHED ;}}}buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ;buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ;",197
1471,"unsigned int len ;unsigned long start = 0 , off ;fbdev = to_au1100fb_device ( fbi ) ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {",fbdev = to_au1100fb_device ( fbi ) ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {,198
1472,"if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) {return - EAGAIN ;}return 0 ;","return vm_iomap_memory ( vma , fbdev -> fb_phys , fbdev -> fb_len ) ;",198
1473,"if ( mount ( ""none"" , path , ""tmpfs"" , 0 , ""size=100000,mode=755"" ) ) {SYSERROR ( ""Failed<S2SV_blank>mounting<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s\\\","if ( safe_mount ( ""none"" , path , ""tmpfs"" , 0 , ""size=100000,mode=755"" , rootfs -> path ? rootfs -> mount : NULL ) ) {SYSERROR ( ""Failed<S2SV_blank>mounting<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s\\\",199
1474,"
",assert ( pExpr -> y . pTab != 0 ) ;,200
1475,assert ( pMatch -> iCursor == pExpr -> iTable ) ;pMatch -> colUsed |= ( ( Bitmask ) 1 ) << n ;,assert ( pMatch -> iCursor == pExpr -> iTable ) ;if ( pExpr -> y . pTab -> tabFlags & TF_HasGenerated ) {Column * pCol = pExpr -> y . pTab -> aCol + pExpr -> iColumn ;if ( pCol -> colFlags & COLFLAG_GENERATED ) n = BMS - 1 ;}pMatch -> colUsed |= ( ( Bitmask ) 1 ) << n ;,200
1476,"void vp9_tokens_from_tree ( struct vp9_token * tokens ,  const vp9_tree_index * tree ) {tree2tok ( tokens , tree , 0 , 0 , 0 ) ;","void vp9_tokens_from_tree ( struct vp9_token * tokens , const vpx_tree_index * tree ) {tree2tok ( tokens , tree , 0 , 0 , 0 ) ;",201
1477,"# ifdef _WITH_VRRP_  fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\\","fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\\# ifdef _WITH_VRRP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\\",202
1478,"
",if ( conf . have_hashseed ) json_object_seed ( conf . hashseed ) ;,203
1479,if ( conf . strip ) {buffer = loadfile ( infile ) ;,if ( conf . strip ) {buffer = loadfile ( infile ) ;,203
1480,"if ( cid <= 0 )  continue ;dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( dctx -> remaining <= 0 ) {dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( dctx -> remaining <= 0 )   return dctx -> remaining ;}","int remaining ;if ( cid <= 0 ) continue ;remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( remaining <= 0 ) {dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( remaining <= 0 ) return dctx -> remaining ;}",204
1481,slave -> master = master ;slave -> timer = master -> timer ;spin_unlock_irq ( & slave_active_lock ) ;},spin_lock ( & master -> timer -> lock ) ;slave -> master = master ;slave -> timer = master -> timer ;spin_unlock ( & master -> timer -> lock ) ;spin_unlock_irq ( & slave_active_lock ) ;},205
1482,"static int opl3_load_patch ( int dev , int format , const char __user * addr ,  int offs , int count , int pmgr_flag )  {if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) )  return - EFAULT ;","static int opl3_load_patch ( int dev , int format , const char __user * addr , int count , int pmgr_flag ) {if ( copy_from_user ( & ins , addr , sizeof ( ins ) - offs ) ) return - EFAULT ;",206
1483,for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ;,for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ;,207
1484,"int hours , minutes , seconds ;int64_t time ;","int64_t hours , minutes , seconds ;int64_t time ;",208
1485,# ifndef PGEN  Py_INCREF ( err_ret -> filename ) ;,if ( * flags & PyPARSE_TYPE_COMMENTS ) {tok -> type_comments = 1 ;}# ifndef PGEN Py_INCREF ( err_ret -> filename ) ;,209
1486,case USB_DEVICE_ID_KYE_ERGO_525V :  if ( * rsize >= 74 &&   rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 &&  rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) {,case USB_DEVICE_ID_KYE_ERGO_525V : if ( * rsize >= 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) {,210
1487,"char * ksep , * vsep , * val ;size_t klen , vlen ;vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {return 0 ;","char * start , * ksep , * vsep , * val ;size_t klen , vlen ;start = var -> ptr + var -> already_scanned ;vsep = memchr ( start , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {var -> already_scanned = var -> end - var -> ptr ;return 0 ;",211
1488,return 1 ;},var -> already_scanned = 0 ;return 1 ;},211
1489,"LONGSEEK ( mp4 -> mediafp , mp4 -> metaoffsets [ index ] , SEEK_SET ) ;fread ( MP4buffer , 1 , mp4 -> metasizes [ index ] , mp4 -> mediafp ) ;return MP4buffer ;}","if ( mp4 -> filesize > mp4 -> metaoffsets [ index ] + mp4 -> metasizes [ index ] ) {LONGSEEK ( mp4 -> mediafp , mp4 -> metaoffsets [ index ] , SEEK_SET ) ;fread ( MP4buffer , 1 , mp4 -> metasizes [ index ] , mp4 -> mediafp ) ;mp4 -> filepos = mp4 -> metaoffsets [ index ] + mp4 -> metasizes [ index ] ;return MP4buffer ;}}",212
1490,RefBuffer * ref_buf = NULL ;if ( ref_frame_flag == VP9_LAST_FLAG ) {,RefBuffer * ref_buf = NULL ;RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ;if ( ref_frame_flag == VP9_LAST_FLAG ) {,213
1491,"cm -> frame_bufs [ free_fb ] . ref_count -- ;ref_cnt_fb ( cm -> frame_bufs , ref_fb_ptr , free_fb ) ;ref_buf -> buf = & cm -> frame_bufs [ * ref_fb_ptr ] . buf ;vp8_yv12_copy_frame ( sd , ref_buf -> buf ) ;","if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ;-- frame_bufs [ free_fb ] . ref_count ;ref_cnt_fb ( cm -> frame_bufs , ref_fb_ptr , free_fb ) ;ref_buf -> buf = & frame_bufs [ * ref_fb_ptr ] . buf ;vp8_yv12_copy_frame ( sd , ref_buf -> buf ) ;",213
1492,}i2_cur_mb_addr ++ ;,if ( ! uc_more_data_flag && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) {return ERROR_EOB_FLUSHBITS_T ;}}i2_cur_mb_addr ++ ;,214
1493,"static int write_skip ( const VP9_COMP * cpi , int segment_id , const MODE_INFO * mi ,   vp9_writer * w ) {const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;if ( vp9_segfeature_active ( & cpi -> common . seg , segment_id , SEG_LVL_SKIP ) ) {vp9_write ( w , skip , vp9_get_skip_prob ( & cpi -> common , xd ) ) ;return skip ;","static int write_skip ( const VP9_COMMON * cm , const MACROBLOCKD * xd , int segment_id , const MODE_INFO * mi , vpx_writer * w ) {const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;if ( vp9_segfeature_active ( & cpi -> common . seg , segment_id , SEG_LVL_SKIP ) ) {vpx_write ( w , skip , vp9_get_skip_prob ( cm , xd ) ) ;return skip ;",215
1494,"case IPOPT_TS :  ip_printts ( ndo , cp , option_len ) ;break ;case IPOPT_RA :  if ( option_len < 4 ) {","case IPOPT_TS : if ( ip_printts ( ndo , cp , option_len ) ;break ;case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ;break ;case IPOPT_RA : if ( option_len < 4 ) {",216
1495,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_INET_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",217
1496,if ( plen > PAGE_SIZE ) goto error ;payload = NULL ;if ( _payload ) {ret = - ENOMEM ;,if ( plen ) {ret = - ENOMEM ;,218
1497,"error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ;if ( error ) return ( error ) ;leaf = bp -> b_addr ;entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ;ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ;# ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ;ASSERT ( args -> index < ichdr . count ) ;ASSERT ( args -> index >= 0 ) ;if ( entry -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ;namelen = name_loc -> namelen ;name = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ;namelen = name_rmt -> namelen ;name = ( char * ) name_rmt -> name ;}ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ;ASSERT ( namelen == args -> namelen ) ;ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ;# endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ;if ( args -> rmtblkno ) {ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ;name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ;name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ;name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ;","error = xfs_attr3_leaf_read ( args -> rmtvaluelen ) ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ;",219
1498,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;down_read ( & mm -> mmap_sem ) ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;down_read ( & mm -> mmap_sem ) ;",220
1499,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , regs , address ) ;",220
1500,"if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K )  return 0 ;if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ;if ( aux -> alu_state &&  ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) )  return - EACCES ;aux -> alu_state = alu_state ;","if ( can_skip_alu_sanitation ( env , insn ) ) return 0 ;if ( update_alu_sanitation_state ( aux , alu_state , alu_limit ) ) return - EACCES ;aux -> alu_state = alu_state ;",221
1501,"if ( _PyObject_HasAttrId ( obj , & PyId_name ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_name ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_identifier ( tmp , & name , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""name\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>alias"" ) ;if ( exists_not_none ( obj , & PyId_asname ) ) {res = obj2ast_identifier ( tmp , & asname , arena ) ;if ( res != 0 ) goto failed ;else {","if ( lookup_attr_id ( obj , & PyId_name ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_name , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""name\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>alias"" ) ;else {if ( lookup_attr_id ( obj , & PyId_asname , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;else {int res ;res = obj2ast_identifier ( tmp , & asname , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",222
1502,"offset += q -> buf_offset ;skb_add_rx_frag ( skb , skb_shinfo ( skb ) -> nr_frags , page , offset , len ,   q -> buf_size ) ;if ( more ) return ;","struct skb_shared_info * shinfo = skb_shinfo ( skb ) ;if ( shinfo -> nr_frags < ARRAY_SIZE ( shinfo -> frags ) ) {offset += q -> buf_offset ;skb_add_rx_frag ( skb , shinfo -> nr_frags , page , offset , len , q -> buf_size ) ;}if ( more ) return ;",223
1503,"int mutt_b64_decode ( char * out , const char * in )  {","int mutt_b64_decode ( char * out , const char * in , size_t olen ) {",224
1504,* out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;len ++ ;* out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;len ++ ;* out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;len ++ ;,if ( len == olen ) return len ;* out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ;len ++ ;if ( len == olen ) return len ;* out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ;len ++ ;if ( len == olen ) return len ;* out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ;len ++ ;,224
1505,"err = security_sb_remount ( sb , data ) ;if ( err ) return err ;","if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) {return - EPERM ;}if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) {return - EPERM ;}err = security_sb_remount ( sb , data ) ;if ( err ) return err ;",225
1506,bool recovery_cipher_abort ( void )  {if ( awaiting_character ) {,bool recovery_cipher_abort ( void ) {recovery_started = false ;if ( awaiting_character ) {,226
1507,"device = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ;if ( ! device ) {","device = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL , true ) ;if ( ! device ) {",227
1508,for ( i = 0 ;ptr = picture -> data [ i ] + ( ymax * picture -> linesize [ i ] ) ;,if ( ymax < avctx -> height ) for ( i = 0 ;ptr = picture -> data [ i ] + ( ymax * picture -> linesize [ i ] ) ;,228
1509,"
",if ( ( count < 0 ) || ( ( size_t ) count > length ) ) {length = 0 ;continue ;},229
1510,"if ( ( * name != \'\\\\0\' ) && ( * name != \'#\' ) )  if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) {","if ( ( * name != \'\\\\0\' ) && ( * name != \'#\' ) ) if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) {",229
1511,port -> exists = false ;synchronize_irq ( I8042_AUX_IRQ ) ;port -> serio = NULL ;},spin_lock_irq ( & i8042_lock ) ;port -> exists = false ;port -> serio = NULL ;spin_unlock_irq ( & i8042_lock ) ;synchronize_irq ( I8042_AUX_IRQ ) ;},230
1512,goto out ;}if ( unlikely ( error ) ) goto out ;,goto out2 ;}out2 : if ( unlikely ( error ) ) goto out ;,231
1513,if ( ! ( opened & FILE_OPENED ) ) {BUG_ON ( ! error ) ;,if ( ! ( opened & FILE_OPENED ) ) {BUG_ON ( ! error ) ;,231
1514,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;__get_user ( insn . word , pc ) ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;__get_user ( insn . word , pc ) ;",232
1515,while ( begin && isspace ( ( ut8 ) str [ * begin ] ) ) {++ ( * begin ) ;if ( ! str [ * begin ] ) {return TT_EOF ;}else if ( isalpha ( ( ut8 ) str [ * begin ] ) ) {* end = * begin ;while ( end && isalnum ( ( ut8 ) str [ * end ] ) ) {++ ( * end ) ;}* end = * begin ;,+ ( * begin ) ;if ( * begin > strlen ( str ) ) {return TT_EOF ;if ( isalpha ( ( ut8 ) str [ * begin ] ) ) {+ ( * end ) ;while ( end && str [ * end ] && isalnum ( ( ut8 ) str [ * end ] ) ) {++ ( * end ) ;}* end = * begin ;,233
1516,int contentlen = 0 ;int isform = 0 ;,unsigned contentlen = 0 ;int isform = 0 ;,234
1517,"if ( ! * sb || strncasecmp ( sb , ""basic"" , 5 ) ) {continue ;}sb += 5 ;while ( isspace ( * sb ) ) sb ++ ;i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ;if ( i <= 0 ) continue ;username [ i ] = 0 ;sb = strchr ( ( char * ) username , \':\' ) ;if ( sb ) {* sb = 0 ;if ( param -> password ) myfree ( param -> password ) ;param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ;}if ( param -> username ) myfree ( param -> username ) ;param -> username = ( unsigned char * ) mystrdup ( username ) ;continue ;contentlen = atoi ( sb ) ;}","sscanf ( sb , ""%u"" , & contentlen ) ;if ( contentlen > LINESIZE * 1024 ) contentlen = 0 ;contentlen = atoi ( sb ) ;}",234
1518,"printstr ( & pp , authreq ) ;RETURN ( res ) ;}if ( param -> srv -> singlepacket || param -> redirected ) {if ( * req == \'C\' ) req [ 1 ] = 0 ;else * req = 0 ;}sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : ""3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy"" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : """" ) ;if ( * req != \'S\' ) printstr ( & pp , buf ) ;switch ( * req ) {case \'C\' : printstr ( & pp , counters ) ;{struct trafcount * cp ;int num = 0 ;for ( cp = conf . trafcounter ;cp ;cp = cp -> next , num ++ ) {int inbuf = 0 ;if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) {if ( ! ACLmatches ( cp -> ace , param ) ) continue ;}if ( req [ 1 ] == \'S\' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ;if ( req [ 1 ] == \'D\' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ;inbuf += sprintf ( buf , ""<tr>"" ""<td>%s</td><td><A<S2SV_blank>HREF=\\\\\\\'/C%c%d\\\\\\\'>%s</A></td><td>"" , ( cp -> comment ) ? cp -> comment : ""&nbsp;"" , ( cp -> disabled ) ? \'S\' : \'D\' , num , ( cp -> disabled ) ? ""NO"" : ""YES"" ) ;if ( ! cp -> ace || ! cp -> ace -> users ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> src ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> dst ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , "",<br<S2SV_blank>/>\\\\r\\\}inbuf += sprintf ( buf + inbuf , ""</td><td>"" ) ;if ( ! cp -> ace || ! cp -> ace -> ports ) {inbuf += sprintf ( buf + inbuf , ""<center>ANY</center>"" ) ;}else {inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , "",<br<S2SV_blank>/>\\\\r\\\}if ( cp -> type == NONE ) {inbuf += sprintf ( buf + inbuf , ""</td><td<S2SV_blank>colspan=\\\\\\\'6\\\\\\\'<S2SV_blank>align=\\\\\\\'center\\\\\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\\\r\\\}else {inbuf += sprintf ( buf + inbuf , ""</td><td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>MB%s</td>"" ""<td>%"" PRINTF_INT64_MODIFIER ""u</td>"" ""<td>%s</td>"" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : ""never"" ) ;inbuf += sprintf ( buf + inbuf , ""<td>%s</td>"" ""<td>%i</td>"" ""</tr>\\\\r\\\}printstr ( & pp , buf ) ;}}printstr ( & pp , counterstail ) ;break ;case \'R\' : conf . needreload = 1 ;printstr ( & pp , ""<h3>Reload<S2SV_blank>scheduled</h3>"" ) ;break ;case \'S\' : {if ( req [ 1 ] == \'X\' ) {printstr ( & pp , style ) ;break ;}printstr ( & pp , xml ) ;printval ( conf . services , TYPE_SERVER , 0 , & pp ) ;printstr ( & pp , postxml ) ;}break ;case \'F\' : {FILE * fp ;char buf [ 256 ] ;fp = confopen ( ) ;if ( ! fp ) {printstr ( & pp , ""<h3><font<S2SV_blank>color=\\\\""red\\\\"">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>"" ) ;break ;}printstr ( & pp , ""<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>"" ) ;printstr ( & pp , ""<form<S2SV_blank>method=\\\\""POST\\\\""<S2SV_blank>action=\\\\""/U\\\\""><textarea<S2SV_blank>cols=\\\\""80\\\\""<S2SV_blank>rows=\\\\""30\\\\""<S2SV_blank>name=\\\\""conffile\\\\"">"" ) ;while ( fgets ( buf , 256 , fp ) ) {","printstr ( & pp , ""<form<S2SV_blank>method=\\\\""POST\\\\""<S2SV_blank>action=\\\\""/U\\\\""<S2SV_blank>enctype=\\\\""application/x-www-form-urlencoded\\\\""><textarea<S2SV_blank>cols=\\\\""80\\\\""<S2SV_blank>rows=\\\\""30\\\\""<S2SV_blank>name=\\\\""conffile\\\\"">"" ) ;while ( fgets ( buf , 256 , fp ) ) {",234
1519,"int l = 0 ;int error = 0 ;if ( ! writable || fseek ( writable , 0 , 0 ) ) {error = 1 ;}while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , \'+\' , conf . timeouts [ STRING_S ] ) ) > 0 ) {if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ;buf [ i ] = 0 ;if ( ! l ) {if ( ! error ) {decodeurl ( ( unsigned char * ) buf , 1 ) ;l += i ;if ( l >= contentlen ) break ;","int l = 0 ;int error = 0 ;if ( ! writable || ! contentlen || fseek ( writable , 0 , 0 ) ) {error = 1 ;}while ( l < contentlen && ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , ( contentlen - l ) > LINESIZE - 1 ? LINESIZE - 1 : contentlen - l , \'+\' , conf . timeouts [ STRING_S ] ) ) > 0 ) {if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ;buf [ i ] = 0 ;if ( ! l ) {if ( ! error ) {buf [ i ] = 0 ;decodeurl ( ( unsigned char * ) buf , 1 ) ;l += i ;if ( l >= contentlen ) break ;",234
1520,struct mlx5_ib_create_qp_resp resp ;struct mlx5_ib_cq * send_cq ;,struct mlx5_ib_create_qp_resp resp = {};struct mlx5_ib_cq * send_cq ;,235
1521,"static void pack_inter_mode_mvs ( VP9_COMP * cpi , const MODE_INFO * mi ,  vp9_writer * w ) {VP9_COMMON * const cm = & cpi -> common ;const nmv_context * nmvc = & cm -> fc . nmvc ;const MACROBLOCK * const x = & cpi -> mb ;const MB_PREDICTION_MODE mode = mbmi -> mode ;const int segment_id = mbmi -> segment_id ;","static void pack_inter_mode_mvs ( VP9_COMP * cpi , const MODE_INFO * mi , vpx_writer * w ) {VP9_COMMON * const cm = & cpi -> common ;const nmv_context * nmvc = & cm -> fc -> nmvc ;const MACROBLOCK * const x = & cpi -> td . mb ;const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ;const PREDICTION_MODE mode = mbmi -> mode ;const int segment_id = mbmi -> segment_id ;",236
1522,"vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ;vp9_write ( w , pred_flag , pred_prob ) ;if ( ! pred_flag ) write_segment_id ( w , seg , segment_id ) ;skip = write_skip ( cpi , segment_id , mi , w ) ;if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) )   vp9_write ( w , is_inter , vp9_get_intra_inter_prob ( cm , xd ) ) ;if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT && ! ( is_inter &&  ( skip || vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) ) ) {write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ;}write_intra_mode ( w , mode , cm -> fc . y_mode_prob [ size_group_lookup [ bsize ] ] ) ;}","vpx_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ;vpx_write ( w , pred_flag , pred_prob ) ;if ( ! pred_flag ) write_segment_id ( w , seg , segment_id ) ;skip = write_skip ( cm , xd , segment_id , mi , w ) ;if ( ! segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) vpx_write ( w , is_inter , vp9_get_intra_inter_prob ( cm , xd ) ) ;if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT && ! ( is_inter && skip ) ) {write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ;}write_intra_mode ( w , mode , cm -> fc -> y_mode_prob [ size_group_lookup [ bsize ] ] ) ;}",236
1523,"const MB_PREDICTION_MODE b_mode = mi -> bmi [ idy * 2 + idx ] . as_mode ;write_intra_mode ( w , b_mode , cm -> fc . y_mode_prob [ 0 ] ) ;}write_intra_mode ( w , mbmi -> uv_mode , cm -> fc . uv_mode_prob [ mode ] ) ;}const int mode_ctx = mbmi -> mode_context [ mbmi -> ref_frame [ 0 ] ] ;const vp9_prob * const inter_probs = cm -> fc . inter_mode_probs [ mode_ctx ] ;write_ref_frames ( cpi , w ) ;if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) {if ( bsize >= BLOCK_8X8 ) {++ cm -> counts . inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ;}vp9_write_token ( w , vp9_switchable_interp_tree ,  cm -> fc . switchable_interp_prob [ ctx ] ,   & switchable_interp_encodings [ mbmi -> interp_filter ] ) ;}","const PREDICTION_MODE b_mode = mi -> bmi [ idy * 2 + idx ] . as_mode ;write_intra_mode ( w , b_mode , cm -> fc -> y_mode_prob [ 0 ] ) ;}}write_intra_mode ( w , mbmi -> uv_mode , cm -> fc -> uv_mode_prob [ mode ] ) ;const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ;const vpx_prob * const inter_probs = cm -> fc -> inter_mode_probs [ mode_ctx ] ;write_ref_frames ( cm , xd , w ) ;if ( ! segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) {if ( bsize >= BLOCK_8X8 ) {+ cm -> counts . inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ;}vp9_write_token ( w , vp9_switchable_interp_tree , cm -> fc -> switchable_interp_prob [ ctx ] , & switchable_interp_encodings [ mbmi -> interp_filter ] ) ;++ cpi -> interp_filter_selected [ 0 ] [ mbmi -> interp_filter ] ;}",236
1524,"const MB_PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ;write_inter_mode ( w , b_mode , inter_probs ) ;++ cm -> counts . inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ;++ ref ) vp9_encode_mv ( cpi , w , & mi -> bmi [ j ] . as_mv [ ref ] . as_mv ,  & mbmi -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv ,  nmvc , allow_hp ) ;","+ cm -> counts . inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ;const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ;write_inter_mode ( w , b_mode , inter_probs ) ;+ ref ) vp9_encode_mv ( cpi , w , & mi -> bmi [ j ] . as_mv [ ref ] . as_mv ,  & mbmi -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv ,  nmvc , allow_hp ) ;++ ref ) vp9_encode_mv ( cpi , w , & mi -> bmi [ j ] . as_mv [ ref ] . as_mv , & mbmi_ext -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , nmvc , allow_hp ) ;",236
1525,"++ ref ) vp9_encode_mv ( cpi , w , & mbmi -> mv [ ref ] . as_mv ,  & mbmi -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , nmvc ,  allow_hp ) ;","+ ref ) vp9_encode_mv ( cpi , w , & mbmi -> mv [ ref ] . as_mv ,  & mbmi -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , nmvc ,  allow_hp ) ;++ ref ) vp9_encode_mv ( cpi , w , & mbmi -> mv [ ref ] . as_mv , & mbmi_ext -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , nmvc , allow_hp ) ;",236
1526,"unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ;ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ;ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) ,  GFP_KERNEL ) ;memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ;INIT_LIST_HEAD ( & ctx -> tsgl ) ;","struct skcipher_tfm * tfm = private ;struct crypto_skcipher * skcipher = tfm -> skcipher ;unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( skcipher ) ;if ( ! tfm -> has_key ) return - ENOKEY ;ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ;ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( skcipher ) , GFP_KERNEL ) ;memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( skcipher ) ) ;INIT_LIST_HEAD ( & ctx -> tsgl ) ;",237
1527,"skcipher_request_set_tfm ( & ctx -> req , private ) ;skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ;","skcipher_request_set_tfm ( & ctx -> req , skcipher ) ;skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ;",237
1528,while ( ( c != \'\\\,while ( ( c != \'\\\,238
1529,"( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" ,  & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] ,  & white_point [ 0 ] , & white_point [ 1 ] ) ;image -> chromaticity . red_primary . x = chromaticity [ 0 ] ;break ;}","if ( sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , & white_point [ 0 ] , & white_point [ 1 ] ) == 8 ) {image -> chromaticity . red_primary . x = chromaticity [ 0 ] ;}break ;}",238
1530,"( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ;image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;break ;","if ( sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) == 2 ) {image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;}break ;",238
1531,"return mutt_bcache_del ( bcache , id ) ;}","return mutt_bcache_del ( bcache , cache_id ( id ) ) ;}",239
1532,"uint16_t keylen ;rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ;","int keylen ;rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ;",240
1533,"uint16_t keylen ;rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ;","int keylen ;rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ;",240
1534,"# define ThrowCUTReaderException ( severity , tag ) {}Image * image , * palette ;","# define ThrowCUTReaderException ( severity , tag ) \\\\\\\\\\Image * image , * palette ;",241
1535,"
","( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;",241
1536,"offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {","offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {",241
1537,"NOEXPORT char * parse_global_option ( CMD cmd , char * opt , char * arg ) {void * tmp ;case CMD_SET_DEFAULTS :  new_global_options . chroot_dir = NULL ;break ;case CMD_FREE :  tmp = global_options . chroot_dir ;global_options . chroot_dir = NULL ;new_global_options . chroot_dir = str_dup ( arg ) ;return NULL ;case CMD_SET_DEFAULTS :  new_global_options . compression = COMP_NONE ;break ;# endif if ( ! strcasecmp ( arg , ""deflate"" ) )  new_global_options . compression = COMP_DEFLATE ;else if ( ! strcasecmp ( arg , ""zlib"" ) )  new_global_options . compression = COMP_ZLIB ;else return ""Specified<S2SV_blank>compression<S2SV_blank>type<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ;","NOEXPORT char * parse_global_option ( CMD cmd , GLOBAL_OPTIONS * options , char * opt , char * arg ) {void * tmp ;case CMD_SET_DEFAULTS : options -> chroot_dir = NULL ;break ;case CMD_FREE : tmp = options -> chroot_dir ;options -> chroot_dir = NULL ;options -> chroot_dir = str_dup ( arg ) ;return NULL ;case CMD_SET_DEFAULTS : options -> compression = COMP_NONE ;break ;# endif if ( ! strcasecmp ( arg , ""deflate"" ) ) options -> compression = COMP_DEFLATE ;else if ( ! strcasecmp ( arg , ""zlib"" ) ) options -> compression = COMP_ZLIB ;else return ""Specified<S2SV_blank>compression<S2SV_blank>type<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ;",242
1538,case CMD_SET_DEFAULTS : # ifdef EGD_SOCKET  new_global_options . egd_sock = EGD_SOCKET ;# else  new_global_options . egd_sock = NULL ;# endif break ;case CMD_FREE :  tmp = global_options . egd_sock ;global_options . egd_sock = NULL ;new_global_options . egd_sock = str_dup ( arg ) ;return NULL ;,case CMD_SET_DEFAULTS : # ifdef EGD_SOCKET options -> egd_sock = EGD_SOCKET ;# else options -> egd_sock = NULL ;# endif break ;case CMD_FREE : tmp = options -> egd_sock ;options -> egd_sock = NULL ;options -> egd_sock = str_dup ( arg ) ;return NULL ;,242
1539,"case CMD_SET_DEFAULTS : # ifdef USE_FIPS  new_global_options . option . fips = 0 ;# endif break ;case CMD_SET_COPY : break ;case CMD_FREE : break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""fips"" ) )  break ;# ifdef USE_FIPS  if ( ! strcasecmp ( arg , ""yes"" ) )  new_global_options . option . fips = 1 ;else if ( ! strcasecmp ( arg , ""no"" ) )   new_global_options . option . fips = 0 ;else  return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;# else  if ( strcasecmp ( arg , ""no"" ) ) return ""FIPS<S2SV_blank>support<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ;# endif return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS :  break ;case CMD_PRINT_HELP : # ifdef USE_FIPS  s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>FIPS<S2SV_blank>140-2<S2SV_blank>mode"" ,  ""fips"" ) ;}# ifndef USE_WIN32 switch ( cmd ) {case CMD_SET_DEFAULTS :  new_global_options . option . foreground = 0 ;new_global_options . option . log_stderr = 0 ;break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""foreground"" ) ) break ;new_global_options . option . foreground = 1 ;new_global_options . option . log_stderr = 1 ;}else if ( ! strcasecmp ( arg , ""quiet"" ) ) {new_global_options . option . foreground = 1 ;new_global_options . option . log_stderr = 0 ;}else if ( ! strcasecmp ( arg , ""no"" ) ) {new_global_options . option . foreground = 0 ;new_global_options . option . log_stderr = 0 ;}else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\',<S2SV_blank>\\\'quiet\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS : break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|quiet|no<S2SV_blank>foreground<S2SV_blank>mode<S2SV_blank>(don\\\'t<S2SV_blank>fork,<S2SV_blank>log<S2SV_blank>to<S2SV_blank>stderr)"" , ""foreground"" ) ;break ;}# endif # ifdef ICON_IMAGE switch ( cmd ) {case CMD_SET_DEFAULTS :  new_global_options . icon [ ICON_ACTIVE ] = load_icon_default ( ICON_ACTIVE ) ;break ;case CMD_SET_COPY : break ;case CMD_FREE : break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""iconActive"" ) ) break ;if ( ! ( new_global_options . icon [ ICON_ACTIVE ] = load_icon_file ( arg ) ) )  return ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>icon"" ;return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS : break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>icon<S2SV_blank>when<S2SV_blank>connections<S2SV_blank>are<S2SV_blank>established"" , ""iconActive"" ) ;break ;}switch ( cmd ) {case CMD_SET_DEFAULTS :  new_global_options . icon [ ICON_ERROR ] = load_icon_default ( ICON_ERROR ) ;break ;case CMD_SET_COPY : break ;case CMD_FREE : break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""iconError"" ) ) break ;if ( ! ( new_global_options . icon [ ICON_ERROR ] = load_icon_file ( arg ) ) )  return ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>icon"" ;return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS : break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>icon<S2SV_blank>for<S2SV_blank>invalid<S2SV_blank>configuration<S2SV_blank>file"" , ""iconError"" ) ;break ;}switch ( cmd ) {case CMD_SET_DEFAULTS :  new_global_options . icon [ ICON_IDLE ] = load_icon_default ( ICON_IDLE ) ;break ;case CMD_SET_COPY : break ;case CMD_FREE : break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""iconIdle"" ) ) break ;if ( ! ( new_global_options . icon [ ICON_IDLE ] = load_icon_file ( arg ) ) )  return ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>icon"" ;return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS : break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>icon<S2SV_blank>when<S2SV_blank>no<S2SV_blank>connections<S2SV_blank>were<S2SV_blank>established"" , ""iconIdle"" ) ;break ;}# endif switch ( cmd ) {case CMD_SET_DEFAULTS :  new_global_options . log_file_mode = FILE_MODE_APPEND ;break ;case CMD_SET_COPY : break ;case CMD_FREE : break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""log"" ) ) break ;if ( ! strcasecmp ( arg , ""append"" ) )  new_global_options . log_file_mode = FILE_MODE_APPEND ;else if ( ! strcasecmp ( arg , ""overwrite"" ) )  new_global_options . log_file_mode = FILE_MODE_OVERWRITE ;else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'append\\\'<S2SV_blank>or<S2SV_blank>\\\'overwrite\\\'"" ;return NULL ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>append|overwrite<S2SV_blank>log<S2SV_blank>file"" , ""log"" ) ;break ;}switch ( cmd ) {case CMD_SET_DEFAULTS :  new_global_options . output_file = NULL ;break ;case CMD_SET_COPY : break ;case CMD_FREE :  tmp = global_options . output_file ;global_options . output_file = NULL ;str_free ( tmp ) ;break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""output"" ) ) break ;new_global_options . output_file = str_dup ( arg ) ;return NULL ;case CMD_INITIALIZE : # ifndef USE_WIN32  if ( ! new_global_options . option . foreground &&   new_global_options . output_file &&  new_global_options . output_file [ 0 ] != \'/\' ) return ""Log<S2SV_blank>file<S2SV_blank>must<S2SV_blank>include<S2SV_blank>full<S2SV_blank>path<S2SV_blank>name"" ;case CMD_PRINT_DEFAULTS : break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>file<S2SV_blank>to<S2SV_blank>append<S2SV_blank>log<S2SV_blank>messages"" , ""output"" ) ;break ;case CMD_SET_DEFAULTS :  new_global_options . pidfile = NULL ;break ;case CMD_SET_COPY : break ;case CMD_FREE :  tmp = global_options . pidfile ;global_options . pidfile = NULL ;str_free ( tmp ) ;break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""pid"" ) ) break ;if ( arg [ 0 ] )  new_global_options . pidfile = str_dup ( arg ) ;else  new_global_options . pidfile = NULL ;return NULL ;case CMD_INITIALIZE :  if ( ! new_global_options . option . foreground &&   new_global_options . pidfile &&  new_global_options . pidfile [ 0 ] != \'/\' ) return ""Pid<S2SV_blank>file<S2SV_blank>must<S2SV_blank>include<S2SV_blank>full<S2SV_blank>path<S2SV_blank>name"" ;case CMD_PRINT_DEFAULTS : break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>pid<S2SV_blank>file"" , ""pid"" ) ;break ;}# endif switch ( cmd ) {case CMD_SET_DEFAULTS :  new_global_options . random_bytes = RANDOM_BYTES ;break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""RNDbytes"" ) ) break ;{char * tmp_str ;new_global_options . random_bytes = ( long ) strtol ( arg , & tmp_str , 10 ) ;if ( tmp_str == arg || * tmp_str ) return ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>files"" ;}case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d"" , ""RNDbytes"" , RANDOM_BYTES ) ;break ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>files"" , ""RNDbytes"" ) ;break ;}switch ( cmd ) {case CMD_SET_DEFAULTS : # ifdef RANDOM_FILE  new_global_options . rand_file = str_dup ( RANDOM_FILE ) ;# else  new_global_options . rand_file = NULL ;# endif break ;case CMD_SET_COPY : break ;case CMD_FREE :  tmp = global_options . rand_file ;global_options . rand_file = NULL ;str_free ( tmp ) ;break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""RNDfile"" ) ) break ;new_global_options . rand_file = str_dup ( arg ) ;return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS : # ifdef RANDOM_FILE s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""RNDfile"" , RANDOM_FILE ) ;case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>path<S2SV_blank>to<S2SV_blank>file<S2SV_blank>with<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>data"" , ""RNDfile"" ) ;break ;}switch ( cmd ) {case CMD_SET_DEFAULTS :  new_global_options . option . rand_write = 1 ;break ;case CMD_SET_COPY : break ;case CMD_FREE : break ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""RNDoverwrite"" ) ) break ;if ( ! strcasecmp ( arg , ""yes"" ) )  new_global_options . option . rand_write = 1 ;else if ( ! strcasecmp ( arg , ""no"" ) )  new_global_options . option . rand_write = 0 ;else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;return NULL ;case CMD_INITIALIZE : break ;case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes"" , ""RNDoverwrite"" ) ;case CMD_SET_DEFAULTS :  new_global_options . option . log_syslog = 1 ;break ;case CMD_FREE : break ;if ( ! strcasecmp ( arg , ""yes"" ) )  new_global_options . option . log_syslog = 1 ;else if ( ! strcasecmp ( arg , ""no"" ) )  new_global_options . option . log_syslog = 0 ;else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;","case CMD_SET_DEFAULTS : # ifdef USE_FIPS options -> option . fips = FIPS_mode ( ) ? 1 : 0 ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""fips"" ) ) break ;# ifdef USE_FIPS options -> option . fips = 1 ;else if ( ! strcasecmp ( arg , ""no"" ) ) new_global_options . option . fips = 0 ;else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;# else if ( strcasecmp ( arg , ""no"" ) ) return ""FIPS<S2SV_blank>support<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ;# endif return NULL ;case CMD_PRINT_HELP : # ifdef USE_FIPS s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>FIPS<S2SV_blank>140-2<S2SV_blank>mode"" , ""fips"" ) ;case CMD_SET_DEFAULTS : new_global_options . option . foreground = 0 ;new_global_options . option . log_stderr = 0 ;case CMD_SET_VALUE : if ( strcasecmp ( opt , ""foreground"" ) ) break ;if ( ! strcasecmp ( arg , ""yes"" ) ) {new_global_options . option . foreground = 1 ;# else return ""FIPS<S2SV_blank>support<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ;# endif }else if ( ! strcasecmp ( arg , ""quiet"" ) ) {new_global_options . option . foreground = 1 ;new_global_options . option . log_stderr = 0 ;# endif }else {return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%s"" , ""fips"" , FIPS_mode ( ) ? ""yes"" : ""no"" ) ;case CMD_PRINT_HELP : # ifdef USE_FIPS s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>yes"" , ""RNDoverwrite"" ) ;case CMD_SET_DEFAULTS : new_global_options . option . log_syslog = 1 ;break ;case CMD_FREE : memset ( options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ;break ;if ( ! strcasecmp ( arg , ""yes"" ) ) new_global_options . option . log_syslog = 1 ;else if ( ! strcasecmp ( arg , ""no"" ) ) new_global_options . option . log_syslog = 0 ;else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;",242
1540,"case CMD_SET_DEFAULTS :  new_global_options . option . taskbar = 1 ;break ;if ( ! strcasecmp ( arg , ""yes"" ) )  new_global_options . option . taskbar = 1 ;else if ( ! strcasecmp ( arg , ""no"" ) )  new_global_options . option . taskbar = 0 ;else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;","case CMD_SET_DEFAULTS : new_global_options . option . taskbar = 1 ;break ;if ( ! strcasecmp ( arg , ""yes"" ) ) new_global_options . option . taskbar = 1 ;else if ( ! strcasecmp ( arg , ""no"" ) ) new_global_options . option . taskbar = 0 ;else return ""The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;",242
1541,"case CMD_FREE :  break ;case CMD_SET_VALUE : return option_not_found ;case CMD_INITIALIZE :  if ( ssl_configure ( & new_global_options ) )  return ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>TLS"" ;","case CMD_FREE : break ;case CMD_SET_VALUE : return option_not_found ;case CMD_INITIALIZE : if ( ssl_configure ( & new_global_options ) ) return ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>TLS"" ;",242
1542,"len = strlen ( ""/lock/lxc/"" ) + strlen ( n ) + strlen ( p ) + 3 ;rundir = get_rundir ( ) ;ret = snprintf ( dest , len , ""%s/lock/lxc/%s"" , rundir , p ) ;if ( ret < 0 || ret >= len ) {int l2 = 22 + strlen ( n ) + strlen ( p ) ;if ( l2 > len ) {free ( rundir ) ;","len = strlen ( ""/lxc/lock/"" ) + strlen ( n ) + strlen ( p ) + 3 ;rundir = get_rundir ( ) ;ret = snprintf ( dest , len , ""%s/lxc/lock/%s"" , rundir , p ) ;if ( ret < 0 || ret >= len ) {free ( dest ) ;free ( rundir ) ;return NULL ;}ret = snprintf ( dest , len , ""%s/lxc/lock/%s/.%s"" , rundir , p , n ) ;free ( rundir ) ;if ( l2 > len ) {",243
1543,free ( rundir ) ;return NULL ;,free ( rundir ) ;return NULL ;,243
1544,"static int target_xcopy_locate_se_dev_e4_iter ( struct se_device * se_dev ,  void * data )  {struct xcopy_dev_search_info * info = data ;if ( ! se_dev -> dev_attrib . emulate_3pc )   return 0 ;memset ( & tmp_dev_wwn [ 0 ] , 0 , XCOPY_NAA_IEEE_REGEX_LEN ) ;target_xcopy_gen_naa_ieee ( se_dev , & tmp_dev_wwn [ 0 ] ) ;rc = memcmp ( & tmp_dev_wwn [ 0 ] , info -> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ;if ( rc != 0 )  return 0 ;info -> found_dev = se_dev ;pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\\rc = target_depend_item ( & se_dev -> dev_group . cg_item ) ;if ( rc != 0 ) {pr_err ( ""configfs_depend_item<S2SV_blank>attempt<S2SV_blank>failed:<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p\\\return rc ;pr_debug ( ""Called<S2SV_blank>configfs_depend_item<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\\","static int target_xcopy_locate_se_dev_e4_iter ( struct se_device * se_dev , const unsigned char * dev_wwn ) {if ( ! se_dev -> dev_attrib . emulate_3pc ) {pr_debug ( ""XCOPY:<S2SV_blank>emulate_3pc<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>se_dev<S2SV_blank>%p\\\return 0 ;memset ( & tmp_dev_wwn [ 0 ] , dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN ) ;if ( rc != 0 ) {pr_debug ( ""XCOPY:<S2SV_blank>skip<S2SV_blank>non-matching:<S2SV_blank>%*ph\\\return 0 ;info -> found_dev = se_dev ;pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\\",244
1545,struct i2s_platform_data * i2s_pdata ;struct amdgpu_device * adev = ( struct amdgpu_device * ) handle ;,struct i2s_platform_data * i2s_pdata = NULL ;struct amdgpu_device * adev = ( struct amdgpu_device * ) handle ;,245
1546,"if ( adev -> acp . acp_genpd == NULL ) return - ENOMEM ;if ( adev -> acp . acp_cell == NULL )  return - ENOMEM ;adev -> acp . acp_res = kcalloc ( 5 , sizeof ( struct resource ) , GFP_KERNEL ) ;if ( adev -> acp . acp_res == NULL ) {kfree ( adev -> acp . acp_cell ) ;return - ENOMEM ;}i2s_pdata = kcalloc ( 3 , sizeof ( struct i2s_platform_data ) , GFP_KERNEL ) ;kfree ( adev -> acp . acp_res ) ;kfree ( adev -> acp . acp_cell ) ;return - ENOMEM ;","if ( adev -> acp . acp_genpd == NULL ) {r = - ENOMEM ;goto failure ;}if ( adev -> acp . acp_cell == NULL ) return - ENOMEM ;adev -> acp . acp_res = kcalloc ( 5 , sizeof ( struct resource ) , GFP_KERNEL ) ;if ( adev -> acp . acp_res == NULL ) {r = - ENOMEM ;goto failure ;}i2s_pdata = kcalloc ( 3 , sizeof ( struct i2s_platform_data ) , GFP_KERNEL ) ;r = - ENOMEM ;goto failure ;",245
1547,if ( r )  return r ;for ( i = 0 ;return r ;},if ( r ) goto failure ;for ( i = 0 ;goto failure ;},245
1548,return - ETIMEDOUT ;},r = - ETIMEDOUT ;goto failure ;},245
1549,return - ETIMEDOUT ;}},r = - ETIMEDOUT ;goto failure ;}failure : kfree ( i2s_pdata ) ;kfree ( adev -> acp . acp_res ) ;kfree ( adev -> acp . acp_cell ) ;kfree ( adev -> acp . acp_genpd ) ;return r ;},245
1550,"int old_bin_num , bin_num ;old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ;bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ;if ( old_bin_num == bin_num ) {# endif  return ptr ;}",int old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ;if ( size <= ZEND_MM_MAX_SMALL_SIZE ) {int bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ;if ( old_bin_num == bin_num ) {# endif return ptr ;}},246
1551,coerce_reg_to_32 ( dst_reg ) ;coerce_reg_to_32 ( & src_reg ) ;},"coerce_reg_to_size ( dst_reg , 4 ) ;coerce_reg_to_size ( & src_reg , 4 ) ;}",247
1552,free ( p ) ;return 0 ;,* pp = p -> next ;free ( p ) ;return 0 ;,248
1553,"struct oabi_flock64 user ;struct flock64 kernel ;mm_segment_t fs = USER_DS ;unsigned long local_arg = arg ;int ret ;case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 :  if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg ,  sizeof ( user ) ) ) return - EFAULT ;","case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 : if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , sizeof ( user ) ) ) return - EFAULT ;",249
1554,"ret = sys_fcntl64 ( fd , cmd , local_arg ) ;switch ( cmd ) {case F_GETLK64 : if ( ! ret ) {user . l_type = kernel . l_type ;user . l_whence = kernel . l_whence ;user . l_start = kernel . l_start ;user . l_len = kernel . l_len ;user . l_pid = kernel . l_pid ;if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - EFAULT ;case F_SETLK64 : case F_SETLKW64 : set_fs ( fs ) ;return ret ;}","ret = sys_fcntl64 ( fd , cmd , arg ) ;",249
1555,"state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;if ( ! state -> frame [ 0 ] ) {init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ;for ( ;;) {struct bpf_insn * insn ;u8 class ;int err ;if ( env -> insn_idx >= insn_cnt ) {verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\\verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\\return - E2BIG ;}err = is_state_visited ( env , env -> insn_idx ) ;if ( do_print_state )  verbose ( env , ""\\\else verbose ( env , ""%d:<S2SV_blank>safe\\\","state -> speculative = false ;state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;if ( ! state -> frame [ 0 ] ) {init_func_state ( env , ""\\\verbose ( env , ""\\\if ( do_print_state ) verbose ( env , ""\\\else verbose ( env , ""%d:<S2SV_blank>safe\\\",250
1556,"else  verbose ( env , ""\\\print_verifier_state ( env , state -> frame [ state -> curframe ] ) ;","else verbose ( env , ""\\\print_verifier_state ( env , state -> frame [ state -> curframe ] ) ;",250
1557,"
",if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ;,251
1558,"input = xmlNewEntityInputStream ( ctxt , entity ) ;if ( xmlPushInput ( ctxt , input ) < 0 ) return ;","input = xmlNewEntityInputStream ( ctxt , entity ) ;if ( xmlPushInput ( ctxt , input ) < 0 ) return ;",251
1559,"static void dist_block ( int plane , int block , TX_SIZE tx_size ,   struct rdcost_block_args * args ) {const int ss_txfrm_size = tx_size << 1 ;MACROBLOCK * const x = args -> x ;int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;args -> dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size ,   & this_sse ) >> shift ;args -> sse = this_sse >> shift ;int64_t p = ( pd -> dequant [ 1 ] * pd -> dequant [ 1 ] *  ( 1 << ss_txfrm_size ) ) >> ( shift + 2 ) ;args -> dist += ( p >> 4 ) ;args -> sse += p ;}","static void dist_block ( MACROBLOCK * x , int plane , int block , TX_SIZE tx_size , int64_t * out_dist , int64_t * out_sse ) {const int ss_txfrm_size = tx_size << 1 ;tran_low_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;# if CONFIG_VP9_HIGHBITDEPTH const int bd = ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd : 8 ;* out_dist = vp9_highbd_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse , bd ) >> shift ;# else * out_dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse ) >> shift ;# endif * out_sse = this_sse >> shift ;int64_t p = ( pd -> dequant [ 1 ] * pd -> dequant [ 1 ] * ( 1 << ss_txfrm_size ) ) >> # if CONFIG_VP9_HIGHBITDEPTH ( shift + 2 + ( bd - 8 ) * 2 ) ;# else ( shift + 2 ) ;# endif * out_dist += ( p >> 4 ) ;* out_sse += p ;}",252
1560,"return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , apr_psprintf ( r -> pool ,  ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" ,  r -> args ) , HTTP_INTERNAL_SERVER_ERROR ) ;","return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , apr_psprintf ( r -> pool , ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request"" ) , HTTP_INTERNAL_SERVER_ERROR ) ;",253
1561,"ps_dec -> u4_cur_bs_mb_num = 0 ;DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\\","ps_dec -> u4_cur_bs_mb_num = 0 ;ps_dec -> u4_start_recon_deblk = 0 ;DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\\",254
1562,for ( i = scm -> fp -> count - 1 ;,"for ( i = scm -> fp -> user , scm -> fp -> count - 1 ;",255
1563,i -- )  unix_inflight ( scm -> fp -> fp [ i ] ) ;return max_level ;,i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ;return max_level ;,255
1564,"static int cipso_v4_delopt ( struct ip_options * * opt_ptr )  {struct ip_options * opt = * opt_ptr ;if ( opt -> srr || opt -> rr || opt -> ts || opt -> router_alert ) {u8 cipso_len ;cipso_off = opt -> cipso - sizeof ( struct iphdr ) ;cipso_ptr = & opt -> __data [ cipso_off ] ;cipso_len = cipso_ptr [ 1 ] ;if ( opt -> srr > opt -> cipso )  opt -> srr -= cipso_len ;if ( opt -> rr > opt -> cipso )  opt -> rr -= cipso_len ;if ( opt -> ts > opt -> cipso )  opt -> ts -= cipso_len ;if ( opt -> router_alert > opt -> cipso )  opt -> router_alert -= cipso_len ;opt -> cipso = 0 ;memmove ( cipso_ptr , cipso_ptr + cipso_len ,  opt -> optlen - cipso_off - cipso_len ) ;iter = 0 ;while ( iter < opt -> optlen )  if ( opt -> __data [ iter ] != IPOPT_NOP ) {iter += opt -> __data [ iter + 1 ] ;optlen_new = iter ;hdr_delta = opt -> optlen ;opt -> optlen = ( optlen_new + 3 ) & ~ 3 ;hdr_delta -= opt -> optlen ;}hdr_delta = opt -> optlen ;kfree ( opt ) ;","static int cipso_v4_delopt ( struct ip_options_rcu * * opt_ptr ) {struct ip_options_rcu * opt = * opt_ptr ;if ( opt -> opt . srr || opt -> opt . rr || opt -> opt . ts || opt -> opt . router_alert ) {u8 cipso_len ;cipso_off = opt -> opt . cipso - sizeof ( struct iphdr ) ;cipso_ptr = & opt -> opt . __data [ cipso_off ] ;cipso_len = cipso_ptr [ 1 ] ;if ( opt -> opt . srr > opt -> opt . cipso ) opt -> opt . srr -= cipso_len ;if ( opt -> opt . rr > opt -> opt . cipso ) opt -> opt . rr -= cipso_len ;if ( opt -> opt . ts > opt -> opt . cipso ) opt -> opt . ts -= cipso_len ;if ( opt -> opt . router_alert > opt -> opt . cipso ) opt -> opt . router_alert -= cipso_len ;opt -> opt . cipso = 0 ;memmove ( cipso_ptr , cipso_ptr + cipso_len , opt -> opt . optlen - cipso_off - cipso_len ) ;iter = 0 ;while ( iter < opt -> opt . optlen ) if ( opt -> opt . __data [ iter ] != IPOPT_NOP ) {iter += opt -> opt . __data [ iter + 1 ] ;optlen_new = iter ;hdr_delta = opt -> opt . optlen ;opt -> opt . optlen = ( optlen_new + 3 ) & ~ 3 ;hdr_delta -= opt -> opt . optlen ;}hdr_delta = opt -> opt . optlen ;call_rcu ( & opt -> rcu , opt_kfree_rcu ) ;",256
1565,"char * command , * args = value ;size_t arg_size ;if ( size == 0 )  return - EINVAL ;if ( args [ size - 1 ] != \'\\\\0\' ) {if ( size == PAGE_SIZE )   return - EINVAL ;args [ size ] = \'\\\\0\' ;}args = value ;if ( ! args ) return - EINVAL ;if ( ! * args ) return - EINVAL ;if ( strcmp ( name , ""current"" ) == 0 ) {if ( strcmp ( command , ""changehat"" ) == 0 ) {}error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ;","char * command , * largs = NULL , * args = value ;size_t arg_size ;if ( size == 0 ) return - EINVAL ;if ( args [ size - 1 ] != \'\\\\0\' ) {largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ;if ( ! args ) return - ENOMEM ;memcpy ( args , value , size ) ;args [ size ] = \'\\\\0\' ;}error = - EINVAL ;if ( ! args ) goto out ;if ( ! * args ) goto out ;if ( strcmp ( name , ""current"" ) == 0 ) {if ( strcmp ( command , ""changehat"" ) == 0 ) {}error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ;",257
1566,"}if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ;}else  return - EINVAL ;","}else if ( strcmp ( name , ""exec"" ) == 0 ) {if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ;}else if ( strcmp ( command , ""permhat"" ) == 0 ) {error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ;else goto fail ;}if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ;}else return - EINVAL ;",257
1567,"aad . error = - EINVAL ;aa_audit_msg ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ;return - EINVAL ;}","aad . error = error = - EINVAL ;aa_audit_msg ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ;goto out ;}",257
1568,long timeo ;msg -> msg_namelen = 0 ;,long timeo ;,258
1569,"void vp9_write_prob_diff_update ( vp9_writer * w , vp9_prob newp , vp9_prob oldp ) {const int delp = remap_prob ( newp , oldp ) ;","void vp9_write_prob_diff_update ( vpx_writer * w , vp9_prob newp , vp9_prob oldp ) {const int delp = remap_prob ( newp , oldp ) ;",259
1570,"static int getnum ( lua_State * L , const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - \'0\' ) ) )  luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>overflow"" ) ;","static int getnum ( const char * * fmt , int df ) {if ( ! isdigit ( * * fmt ) ) return df ;",260
1571,usb_kill_urb ( mixer -> urb ) ;usb_kill_urb ( mixer -> rc_urb ) ;},if ( mixer -> disconnected ) return ;if ( mixer -> urb ) usb_kill_urb ( mixer -> urb ) ;if ( mixer -> rc_urb ) usb_kill_urb ( mixer -> rc_urb ) ;mixer -> disconnected = true ;},261
1572,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;va_end ( va ) ;",262
1573,"memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) ,  vs_ie , vs_ie -> len + 2 ) ;","if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , vs_ie , vs_ie -> len + 2 ) ;",263
1574,"ssize_t ret = write ( uart_fd , data + transmitted_length , length ) ;switch ( ret ) {","ssize_t ret = TEMP_FAILURE_RETRY ( write ( uart_fd , data + transmitted_length , length ) ) ;switch ( ret ) {",264
1575,col ++ )  evtchn_to_irq [ row ] [ col ] = - 1 ;},"col ++ ) WRITE_ONCE ( evtchn_to_irq [ row ] [ col ] , - 1 ) ;}",265
1576,"CALL_AND_WAIT ( error = bt_interface -> enable ( ) , adapter_state_changed ) ;TASSERT ( error == BT_STATUS_SUCCESS , ""Error<S2SV_blank>enabling<S2SV_blank>Bluetooth:<S2SV_blank>%d"" , error ) ;","CALL_AND_WAIT ( error = bt_interface -> enable ( false ) , adapter_state_changed ) ;TASSERT ( error == BT_STATUS_SUCCESS , ""Error<S2SV_blank>enabling<S2SV_blank>Bluetooth:<S2SV_blank>%d"" , error ) ;",266
1577,"void usage_exit ( ) {int i ;fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><options><S2SV_blank>-o<S2SV_blank>dst_filename<S2SV_blank>src_filename<S2SV_blank>\\\","void usage_exit ( void ) {int i ;const int num_encoder = get_vpx_encoder_count ( ) ;fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><options><S2SV_blank>-o<S2SV_blank>dst_filename<S2SV_blank>src_filename<S2SV_blank>\\\",267
1578,"# endif  fprintf ( stderr , ""\\\for ( i = 0 ;i < get_vpx_encoder_count ( ) ;const VpxInterface * const encoder = get_vpx_encoder_by_index ( i ) ;fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\\}exit ( EXIT_FAILURE ) ;","# endif # if CONFIG_VP10_ENCODER fprintf ( stderr , ""\\\arg_show_usage ( stderr , vp10_args ) ;# endif fprintf ( stderr , ""\\\for ( i = 0 ;i < num_encoder ;const VpxInterface * const encoder = get_vpx_encoder_by_index ( i ) ;const char * defstr = ( i == ( num_encoder - 1 ) ) ? ""(default)"" : """" ;fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>%s\\\}fprintf ( stderr , ""\\\fprintf ( stderr , ""Use<S2SV_blank>--codec<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>a<S2SV_blank>non-default<S2SV_blank>encoder.\\\exit ( EXIT_FAILURE ) ;",267
1579,"while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ;while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 )  ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ;for ( ;","while ( strncmp ( file , ""./"" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( cp ) - 1 ) ;while ( ( cp = strstr ( file , ""/./"" ) ) != ( char * ) 0 ) ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ;for ( ;",268
1580,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,269
1581,if ( ! ( buf = g_try_malloc ( size ) ) ) {# ifdef DEBUG g_assert_not_reached ( ) ;,if ( ! ( buf = g_try_malloc0 ( size ) ) ) {# ifdef DEBUG g_assert_not_reached ( ) ;,270
1582,while ( u4_mmco != END_OF_MMCO )  {ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ;,"while ( u4_mmco != END_OF_MMCO ) {if ( j >= MAX_REF_BUFS ) {ALOGE ( ""b/25818142"" ) ;android_errorWriteLog ( 0x534e4554 , ""25818142"" ) ;ps_dpb_cmds -> u1_num_of_commands = 0 ;return - 1 ;}ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ;",271
1583,read_lock ( & evtchn_rwlock ) ;do {xen_evtchn_handle_events ( cpu ) ;BUG_ON ( ! irqs_disabled ( ) ) ;},"struct evtchn_loop_ctrl ctrl = {0 };read_lock ( & evtchn_rwlock ) ;do {xen_evtchn_handle_events ( cpu , & ctrl ) ;BUG_ON ( ! irqs_disabled ( ) ) ;__this_cpu_inc ( irq_epoch ) ;}",272
1584,if ( header -> flags & TCP_FLAG_SYN )  length = 1 ;else if ( header -> flags & TCP_FLAG_FIN )  length = queueItem -> length + 1 ;else  length = queueItem -> length ;,if ( header -> flags & TCP_FLAG_SYN ) {length = 1 ;}else if ( header -> flags & TCP_FLAG_FIN ) {length = queueItem -> length + 1 ;}else {length = queueItem -> length ;},273
1585,"struct user_struct * user = group -> inotify_data . user ;pr_debug ( ""%s:<S2SV_blank>group=%p\\\atomic_dec ( & user -> inotify_devs ) ;return 0 ;","pr_debug ( ""%s:<S2SV_blank>group=%p\\\return 0 ;",274
1586,"atomic_set ( & new -> count , 0 ) ;spin_lock_irq ( & ucounts_lock ) ;","new -> count , 0 ) ;spin_lock_irq ( & ucounts_lock ) ;",275
1587,"if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) )  ucounts = NULL ;","if ( ucounts -> count , 1 , INT_MAX ) ) ucounts = NULL ;",275
1588,"* skipped_file = TRUE ;return ;}unique_name_nr = 1 ;handled_invalid_filename = * dest_fs_type != NULL ;if ( unique_names ) {dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ;}else if ( copy_job -> target_name != NULL ) {dest = get_target_file_with_custom_name ( src , dest_dir , * dest_fs_type , same_fs , copy_job -> target_name ) ;}else {dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ;}if ( test_dir_is_parent ( dest_dir , src ) ) {if ( job -> skip_all_error ) {goto out ;}primary = copy_job -> is_move ? g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself."" ) ) : g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself."" ) ) ;secondary = g_strdup ( _ ( ""The<S2SV_blank>destination<S2SV_blank>folder<S2SV_blank>is<S2SV_blank>inside<S2SV_blank>the<S2SV_blank>source<S2SV_blank>folder."" ) ) ;response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;","mark_desktop_file_executable ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ;",276
1589,"mark_desktop_file_trusted ( job ,  job -> cancellable , dest , FALSE ) ;","mark_desktop_file_trusted ( job , job -> cancellable , dest , FALSE ) ;",276
1590,get_page ( page ) ;spin_unlock ( ptl ) ;,if ( unlikely ( ! try_get_page ( page ) ) ) {spin_unlock ( ptl ) ;return ERR_PTR ( - ENOMEM ) ;}spin_unlock ( ptl ) ;,277
1591,"case 0 :  # ifdef HAVE_ZLIB_H case 8 : # endif break ;archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" ,  ( intmax_t ) rsrc -> uncompressed_size ) ;return ( ARCHIVE_WARN ) ;","case 0 : if ( rsrc -> uncompressed_size ) ;return ( ARCHIVE_WARN ) ;}if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> compressed_size != rsrc -> compressed_size ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size"" ) ;return ( ARCHIVE_FATAL ) ;}# ifdef HAVE_ZLIB_H case 8 : # endif break ;archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> uncompressed_size ) ;return ( ARCHIVE_WARN ) ;",278
1592,"case 0 :  memcpy ( mp , p , bytes_avail ) ;bytes_used = ( size_t ) bytes_avail ;","case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;memcpy ( mp , p , bytes_avail ) ;bytes_used = ( size_t ) bytes_avail ;",278
1593,"jas_eprintf ( ""error:<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>box\\\jas_eprintf ( ""error:<S2SV_blank>expecting<S2SV_blank>signature<S2SV_blank>box\\\","jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\\jas_eprintf ( ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\\",279
1594,"jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\}if ( ! jas_image_numcmpts ( dec -> image ) ) {jas_eprintf ( ""error:<S2SV_blank>no<S2SV_blank>components\\\samedtype = true ;dtype = jas_image_cmptdtype ( dec -> image , 0 ) ;for ( i = 1 ;i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;++ i ) {if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) {samedtype = false ;break ;jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\\}if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts (  dec -> image ) ) ) {jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\\}","jas_eprintf ( ""error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\\+ i ) {if ( ! jas_image_numcmpts ( dec -> image ) ) {jas_eprintf ( ""error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\\goto error ;jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\\}if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) {jas_eprintf ( ""warning:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch\\\jas_eprintf ( ""warning:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\\}",279
1595,char lowstr [ MAXDATELEN + 1 ] ;char * realptr ;if ( strlen ( str ) >= sizeof ( lowstr ) )  {,char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ;char * realptr ;if ( strlen ( str ) > MAXDATELEN ) {,280
1596,int i ;int opts ;,int result ;int i ;int opts ;,281
1597,"if ( ! js_regexec ( re -> prog , text , & m , opts ) ) {js_newarray ( J ) ;","result = js_regexec ( re -> prog , text , & m , opts ) ;if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ;if ( result == 0 ) {js_newarray ( J ) ;",281
1598,"if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) &&   ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) ||   ! same_thread_group ( rtn , current ) ||  ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_SIGNAL ) ) return NULL ;if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) &&   ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) )   return NULL ;return task_pid ( rtn ) ;}","switch ( event -> sigev_notify & SIGEV_THREAD_ID ) && ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ;if ( ! rtn || ! same_thread_group ( rtn , current ) ) return NULL ;if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && ( ( event -> sigev_signo <= 0 || event -> sigev_signo > SIGRTMAX ) ) ) return NULL ;case SIGEV_NONE : return task_pid ( rtn ) ;default : return NULL ;}}",282
1599,"# ifdef __linux__   sun . sun_path [ 0 ] = \'\\\\0\' ;memcpy ( sun . sun_path + 1 , path , strlen ( path ) ) ;sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ;remove_control_socket ( path ) ;# endif if ( bind ( fd , ( const struct sockaddr * ) & sun , sun_len ) < 0 ) {","memcpy ( sun . sun_path [ 0 ] = \'\\\\0\' ;memcpy ( sun . sun_path , path , strlen ( path ) ) ;sun_len = sizeof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ;remove_control_socket ( path ) ;if ( bind ( fd , ( const struct sockaddr * ) & sun , sun_len ) < 0 ) {",283
1600,local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ;for ( i = 0 ;,local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ;if ( args -> nr_local == 0 ) return - EINVAL ;for ( i = 0 ;,284
1601,"vpx_memset ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG ) ) ;}","memset ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG ) ) ;}",285
1602,"rc = RPMRC_FAIL ;headerMergeLegacySigs ( h , sigh ) ;applyRetrofits ( h ) ;","if ( rc = RPMRC_FAIL ;headerMergeLegacySigs ( h , sigh , & msg ) ) goto exit ;applyRetrofits ( h ) ;",286
1603,"rcu_read_lock ( ) ;head -> dev = dev_get_by_index_rcu ( net , qp -> iif ) ;if ( ! head -> dev )  goto out_rcu_unlock ;if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) {const struct iphdr * iph = ip_hdr ( head ) ;int err = ip_route_input ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ;if ( unlikely ( err ) ) goto out_rcu_unlock ;if ( skb_rtable ( head ) -> rt_type != RTN_LOCAL ) goto out_rcu_unlock ;}icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ;","const struct iphdr * iph ;int err ;rcu_read_lock ( ) ;head -> dev ) goto out_rcu_unlock ;skb_dst_drop ( head ) ;iph = ip_hdr ( head ) ;err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ;if ( err = dev_get_by_index_rcu ( net , qp -> iif ) ;if ( ! head -> dev ) goto out_rcu_unlock ;if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && skb_rtable ( head ) -> rt_type != RTN_LOCAL ) goto out_rcu_unlock ;}icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ;",287
1604,"u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;smin_val = src_reg . smin_value ;smax_val = src_reg . smax_value ;umin_val = src_reg . umin_value ;umax_val = src_reg . umax_value ;src_known = tnum_is_const ( src_reg . var_off ) ;dst_known = tnum_is_const ( dst_reg -> var_off ) ;if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) {__mark_reg_unknown ( dst_reg ) ;return 0 ;}switch ( opcode ) {case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value += smin_val ;dst_reg -> smax_value += smax_val ;}if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value += umin_val ;dst_reg -> umax_value += umax_val ;}dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ;break ;case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value -= smax_val ;dst_reg -> smax_value -= smin_val ;}if ( dst_reg -> umin_value < umax_val ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value -= umax_val ;dst_reg -> umax_value -= umin_val ;}dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ;break ;case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ;if ( smin_val < 0 || dst_reg -> smin_value < 0 ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}break ;case BPF_AND : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = dst_reg -> var_off . value ;dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ;dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_LSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) {dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;}else {dst_reg -> umin_value <<= umin_val ;dst_reg -> umax_value <<= umax_val ;}dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ;__update_reg_bounds ( dst_reg ) ;break ;case BPF_RSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ;dst_reg -> umin_value >>= umax_val ;dst_reg -> umax_value >>= umin_val ;__update_reg_bounds ( dst_reg ) ;break ;case BPF_ARSH : if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}dst_reg -> smin_value >>= umin_val ;dst_reg -> smax_value >>= umin_val ;dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ;dst_reg -> umin_value = 0 ;dst_reg -> umax_value = U64_MAX ;__update_reg_bounds ( dst_reg ) ;break ;default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;}if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( & src_reg , 4 ) ;}",u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;if ( insn_bitness == 32 ) {},288
1605,"for ( ac = 0 ;int count = skb_queue_len ( & pending ) , tmp ;","spin_lock ( & sta -> ps_lock ) ;for ( ac = 0 ;int count = skb_queue_len ( & pending ) , tmp ;",289
1606,"ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ;if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) {","ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ;spin_unlock ( & sta -> ps_lock ) ;if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) {",289
1607,"if ( test -> settings -> mss )  cJSON_AddIntToObject ( test -> json_start , ""tcp_mss"" , test -> settings -> mss ) ;else {cJSON_AddIntToObject ( test -> json_start , ""tcp_mss_default"" , opt ) ;}","if ( test -> settings -> mss ) cJSON_AddNumberToObject ( test -> json_start , ""tcp_mss"" , test -> settings -> mss ) ;else {cJSON_AddNumberToObject ( test -> json_start , ""tcp_mss_default"" , opt ) ;}",290
1608,ret = fscrypt_get_crypt_info ( dir ) ;if ( ret && ret != - EOPNOTSUPP ) return ret ;,ret = fscrypt_get_encryption_info ( dir ) ;if ( ret && ret != - EOPNOTSUPP ) return ret ;,291
1609,"
",if ( len > 1024 || len < 0 ) continue ;,292
1610,if ( nh . nh_type == 1 && i == 0 )  {,if ( nh . nh_type == 1 && i == 0 ) {,292
1611,"static void send ( node_t * node , node_t * child , byte * fout ) {if ( node -> parent ) {send ( node -> parent , node , fout ) ;}if ( child ) {if ( node -> right == child ) {","static void send ( node_t * node , node_t * child , byte * fout , int maxoffset ) {if ( node -> parent ) {send ( node -> parent , node , fout , maxoffset ) ;}if ( child ) {if ( bloc >= maxoffset ) {bloc = maxoffset + 1 ;return ;}if ( node -> right == child ) {",293
1612,"BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;addr -> sa_family = AF_BLUETOOTH ;","BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ;memset ( la , 0 , sizeof ( struct sockaddr_l2 ) ) ;addr -> sa_family = AF_BLUETOOTH ;",294
1613,"if ( js_regexec ( re -> prog , text , & m , 0 ) ) {if ( len == limit ) return ;js_pushliteral ( J , """" ) ;js_setindex ( J , - 2 , 0 ) ;}return ;}p = a = text ;while ( a < e ) {if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) )  break ;","if ( js_doregexec ( J , re -> prog , text , & m , 0 ) ) {if ( js_doregexec ( J , re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) break ;",295
1614,"if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 )  OE_RAISE_ERRNO ( OE_EINVAL ) ;","size_t data_size = 0 ;if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ;",296
1615,JSObjectRef globalobject ;JSStringRef var_name ;,JSObjectRef globalobject ;,297
1616,"globalobject = JSContextGetGlobalObject ( context ) ;var_name = JSStringCreateWithUTF8CString ( ""Uzbl"" ) ;JSObjectSetProperty ( context , globalobject , var_name , JSObjectMake ( context , uzbl . js . classref , NULL ) , kJSClassAttributeNone , NULL ) ;",globalobject = JSContextGetGlobalObject ( context ) ;,297
1617,"JSStringRelease ( js_result_string ) ;}JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ;JSStringRelease ( var_name ) ;","
",297
1618,"ut8 * directory_base ;struct minidump_directory * entry ;directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ;for ( i = 0 ;entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ;r_bin_mdmp_init_directory_entry ( obj , entry ) ;}","struct minidump_directory entry ;ut64 rvadir = obj -> hdr -> stream_directory_rva ;for ( i = 0 ;ut32 delta = i * sizeof ( struct minidump_directory ) ;int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory ) ) ;if ( r ) {r_bin_mdmp_init_directory_entry ( obj , & entry ) ;}}",298
1619,intra_pred_var = vp8_get_mb_ss ( x -> src_diff ) ;return intra_pred_var ;,intra_pred_var = vpx_get_mb_ss ( x -> src_diff ) ;return intra_pred_var ;,299
1620,"
","memset ( ps_dec -> ps_cur_slice , 0 , sizeof ( dec_slice_params_t ) ) ;",300
1621,ih264d_init_arch ( ps_dec ) ;ih264d_init_function_ptr ( ps_dec ) ;,ih264d_init_arch ( ps_dec ) ;ih264d_init_function_ptr ( ps_dec ) ;,300
1622,if ( pin_code == NULL )  return BT_STATUS_FAIL ;,if ( pin_code == NULL || pin_len > PIN_CODE_LEN ) return BT_STATUS_FAIL ;,301
1623,"pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 2 ) ;if ( pathlen < 0 ) {","pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 1 ) ;if ( pathlen < 0 ) {",302
1624,"if ( chunk_header . ckSize < sizeof ( DS64Chunk ) ||  ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) ||   bcount != chunk_header . ckSize ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) &&  ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) {error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ;","if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) {error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ;",303
1625,# endif  return res ;,# else ( void ) cfg ;( void ) mem_loc ;# endif return res ;,304
1626,"unsigned long kflags = key -> flags ;kenter ( ""{","unsigned long kflags = READ_ONCE ( key -> flags ) ;short state = READ_ONCE ( key -> state ) ;kenter ( ""{",305
1627,if ( kflags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) ) ) {if ( ! ( ctx -> flags & KEYRING_SEARCH_SKIP_EXPIRED ) ) ctx -> result = ERR_PTR ( - EKEYEXPIRED ) ;,if ( state < 0 ) {if ( ! ( ctx -> flags & KEYRING_SEARCH_SKIP_EXPIRED ) ) ctx -> result = ERR_PTR ( state ) ;,305
1628,"if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) {smp_rmb ( ) ;ctx -> result = ERR_PTR ( key -> reject_error ) ;kleave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]"" , ctx -> skipped_ret ) ;","if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) {smp_rmb ( ) ;ctx -> result = ERR_PTR ( key -> reject_error ) ;kleave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]"" , ctx -> skipped_ret ) ;",305
1629,"char b64 [ len + 1 ] ;memcpy ( b64 , start , len ) ;i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ;if ( i_data <= 9 ) {","char * b64 = malloc ( len + 1 ) ;if ( ! b64 ) return VLC_EGENERIC ;memcpy ( b64 , start , len ) ;i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ;free ( b64 ) ;if ( i_data <= 9 ) {",306
1630,"if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ;","if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ;",307
1631,"case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS :  isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ;break ;","case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS : isoclns_print ( ndo , p - 1 , length + 1 ) ;break ;case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p + 1 ) ;break ;",307
1632,record = addStyleRecord ( shape ) ;record . record . stateChange -> leftFill = idx ;,"else if ( idx >= 255 && shape -> useVersion == SWF_SHAPE1 ) {SWF_error ( ""Too<S2SV_blank>many<S2SV_blank>fills<S2SV_blank>for<S2SV_blank>SWFShape<S2SV_blank>V1.\\\}record = addStyleRecord ( shape ) ;record . record . stateChange -> leftFill = idx ;",308
1633,struct sock * sk = sock -> sk ;struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ;,struct sock * sk = sock -> sk ;,309
1634,if ( ! err ) {if ( sat ) {}msg -> msg_namelen = sizeof ( * sat ) ;,if ( ! err && msg -> msg_name ) {struct sockaddr_at * sat = msg -> msg_name ;msg -> msg_namelen = sizeof ( * sat ) ;,309
1635,"umount_tree ( mnt , 0 ) ;}","if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) {struct mount * p , * tmp ;list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) {hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ;umount_mnt ( p ) ;}}else umount_tree ( mnt , 0 ) ;}",310
1636,# else  if ( cpi -> common . frame_to_show )  {,# else ( void ) flags ;if ( cpi -> common . frame_to_show ) {,311
1637,"rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ;if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ;","rq = hctx -> tags , off + bit ) ;if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ;",312
1638,"MODE new_qc = MODE_BESTQUALITY ;if ( deadline ) {const uint64_t duration_us = ( uint64_t ) duration * 1000000 *  ( uint64_t ) ctx -> cfg . g_timebase . num /   ( uint64_t ) ctx -> cfg . g_timebase . den ;new_qc = ( deadline > duration_us ) ? MODE_GOODQUALITY : MODE_REALTIME ;}if ( ctx -> oxcf . mode != new_qc ) {ctx -> oxcf . mode = new_qc ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;","MODE new_mode = BEST ;switch ( ctx -> cfg . g_pass ) {case VPX_RC_ONE_PASS : if ( deadline > 0 ) {const vpx_codec_enc_cfg_t * const cfg = & ctx -> cfg ;const uint64_t duration_us = ( uint64_t ) cfg -> g_timebase . num / ( uint64_t ) ctx -> cfg . g_timebase . den ;new_mode = ( deadline > duration_us ) ? GOOD : REALTIME ;}else {new_mode = BEST ;}break ;case VPX_RC_FIRST_PASS : break ;case VPX_RC_LAST_PASS : new_mode = deadline > 0 ? GOOD : BEST ;break ;}if ( ctx -> oxcf . mode != new_mode ) {ctx -> oxcf . mode = new_mode ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;",313
1639,"static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) {int i ;for ( i = 0 ;i ++ )   if ( minqtarget <= vp9_convert_qindex_to_q ( i ) )   return i ;return QINDEX_RANGE - 1 ;","static int get_minq_index ( double maxq , double x3 , double x2 , double x1 , vpx_bit_depth_t bit_depth ) {int i ;for ( i = 0 ;i ++ ) {if ( minqtarget <= vp9_convert_qindex_to_q ( i , bit_depth ) ) return i ;}return QINDEX_RANGE - 1 ;",314
1640,"
","if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",315
1641,bmp_info . number_colors = ReadBlobLSBLong ( image ) ;bmp_info . colors_important = ReadBlobLSBLong ( image ) ;,bmp_info . number_colors = ReadBlobLSBLong ( image ) ;bmp_info . colors_important = ReadBlobLSBLong ( image ) ;,315
1642,"static void show_object ( struct object * obj ,  struct strbuf * path , const char * component ,  void * cb_data ) {finish_object ( obj , path , component , cb_data ) ;if ( info -> flags & REV_LIST_QUIET ) return ;show_object_with_name ( stdout , obj , path , component ) ;}","static void show_object ( struct object * obj , const char * component , void * cb_data ) {finish_object ( obj , name , cb_data ) ;if ( info -> flags & REV_LIST_QUIET ) return ;show_object_with_name ( stdout , obj , name ) ;}",316
1643,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct inet_sock * newinet ;,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt ;struct inet_sock * newinet ;,317
1644,"dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ;return newsk ;}if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ;if ( ! dst ) {struct flowi6 fl6 ;dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ;if ( ! dst ) goto out ;}newsk = dccp_create_openreq_child ( sk , req , skb ) ;if ( newsk == NULL ) goto out_nonewsk ;__ip6_dst_store ( newsk , dst , NULL , NULL ) ;newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ;newdp6 = ( struct dccp6_sock * ) newsk ;newinet = inet_sk ( newsk ) ;newinet -> pinet6 = & newdp6 -> inet6 ;newnp = inet6_sk ( newsk ) ;memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ;newnp -> saddr = ireq -> ir_v6_loc_addr ;newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ;newsk -> sk_bound_dev_if = ireq -> ir_iif ;newinet -> inet_opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;newnp -> pktoptions = NULL ;newnp -> opt = NULL ;newnp -> mcast_oif = inet6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;if ( np -> opt != NULL )   newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ;inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( newnp -> opt != NULL )   inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen +   newnp -> opt -> opt_flen ) ;dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ;","opt = rcu_dereference ( np -> opt != NULL ) newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ;inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ;dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ;",317
1645,if ( SCTP_CID_SHUTDOWN_ACK == ch -> type )  ootb_shut_ack = 1 ;,"ch_end = ( ( __u8 * ) ch ) + SCTP_PAD4 ( ntohs ( ch -> length ) ) ;if ( ch_end > skb_tail_pointer ( skb ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ;if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ;",318
1646,"ch_end = ( ( __u8 * ) ch ) + SCTP_PAD4 ( ntohs ( ch -> length ) ) ;if ( ch_end > skb_tail_pointer ( skb ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ;ch = ( sctp_chunkhdr_t * ) ch_end ;}",ch = ( sctp_chunkhdr_t * ) ch_end ;},318
1647,"up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & kctl -> id ) ;return 0 ;","struct snd_ctl_elem_id id = kctl -> id ;up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & id ) ;return 0 ;",319
1648,"printf ( ""Boot<S2SV_blank>sector<S2SV_blank>contents:\\\if ( ! atari_format ) {char id [ 9 ] ;strncpy ( id , ( const char * ) b -> system_id , 8 ) ;id [ 8 ] = 0 ;printf ( ""System<S2SV_blank>ID<S2SV_blank>\\\\""%s\\\\""\\\}else {printf ( ""Serial<S2SV_blank>number<S2SV_blank>0x%x\\\}printf ( ""Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\\printf ( ""%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\\printf ( ""First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\\printf ( ""%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\\printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\\if ( ! fs -> root_cluster ) {","printf ( ""%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\\if ( ! fs -> root_cluster ) {",320
1649,"if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) )  return - EFAULT ;","memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) ) return - EFAULT ;",321
1650,"unsigned int maxw , maxh , max , i ;int offset , upb ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;","size_t maxw , maxh , max , i ;int offset , upb ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;if ( r == NULL || g == NULL || b == NULL ) goto fails ;",322
1651,return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;,img -> color_space = OPJ_CLRSPC_SRGB ;return ;fails : free ( r ) ;free ( g ) ;free ( b ) ;,322
1652,"sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ;sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ;","memset ( & sync , 0 , sizeof ( sync ) ) ;sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ;sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ;",323
1653,"int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;unsigned v = get_symbol ( c , state , 0 ) ;","int chroma_planes , chroma_h_shift , chroma_v_shift , transparency , colorspace , bits_per_raw_sample ;unsigned v = get_symbol ( c , state , 0 ) ;",324
1654,"f -> colorspace = get_symbol ( c , state , 0 ) ;if ( f -> version > 0 )   f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;chroma_planes = get_rac ( c , state ) ;chroma_h_shift = get_symbol ( c , state , 0 ) ;chroma_v_shift = get_symbol ( c , state , 0 ) ;if ( chroma_planes != f -> chroma_planes  || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) {}f -> chroma_planes = chroma_planes ;","colorspace = get_symbol ( c , state , 0 ) ;bits_per_raw_sample = f -> version > 0 ) f -> avctx -> bits_per_raw_sample ;chroma_planes = get_rac ( c , state ) ;chroma_h_shift = get_symbol ( c , state , 0 ) ;chroma_v_shift = get_symbol ( c , state , 0 ) ;if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) {}f -> colorspace = colorspace ;f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;f -> chroma_planes = chroma_planes ;",324
1655,struct fscrypt_info * ci = inode -> i_crypt_info ;if ( ! ci ||  ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ) return fscrypt_get_crypt_info ( inode ) ;return 0 ;,"struct fscrypt_info * crypt_info ;struct fscrypt_context ctx ;struct crypto_skcipher * ctfm ;const char * cipher_str ;int keysize ;u8 * raw_key = NULL ;int res ;if ( inode -> i_crypt_info ) return 0 ;res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ;if ( res ) return res ;if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ;res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ;if ( res < 0 ) {if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ;memset ( & ctx , 0 , sizeof ( ctx ) ) ;ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ;ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ;ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ;memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ;}else if ( res != sizeof ( ctx ) ) {return - EINVAL ;}if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ;if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ;crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ;if ( ! crypt_info ) return - ENOMEM ;crypt_info -> ci_flags = ctx . flags ;crypt_info -> ci_data_mode = ctx . contents_encryption_mode ;crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ;crypt_info -> ci_ctfm = NULL ;memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ;res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ;if ( res ) goto out ;res = - ENOMEM ;raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ;if ( ! raw_key ) goto out ;res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ;if ( res && inode -> i_sb -> s_cop -> key_prefix ) {int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ;if ( res2 ) {if ( res2 == - ENOKEY ) res = - ENOKEY ;goto out ;}}else if ( res ) {goto out ;}ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ;if ( ! ctfm || IS_ERR ( ctfm ) ) {res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ;printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\\goto out ;}crypt_info -> ci_ctfm = ctfm ;crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ;crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ;res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ;if ( res ) goto out ;if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ;out : if ( res == - ENOKEY ) res = 0 ;put_crypt_info ( crypt_info ) ;kzfree ( raw_key ) ;return res ;",325
1656,"static void update_skip_probs ( VP9_COMMON * cm , vp9_writer * w ) {int k ;++ k )  vp9_cond_prob_diff_update ( w , & cm -> fc . skip_probs [ k ] , cm -> counts . skip [ k ] ) ;}","static void update_skip_probs ( VP9_COMMON * cm , vpx_writer * w , FRAME_COUNTS * counts ) {int k ;+ k )  vp9_cond_prob_diff_update ( w , & cm -> fc . skip_probs [ k ] , cm -> counts . skip [ k ] ) ;++ k ) vp9_cond_prob_diff_update ( w , & cm -> fc -> skip_probs [ k ] , cm -> counts . skip [ k ] ) ;}",326
1657,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ;switch ( asi ) {","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , addr ) ;switch ( asi ) {",327
1658,if ( ret ) goto out ;touch_atime ( & path ) ;path_put ( & path ) ;,if ( ! IS_ERR ( raw ) ) if ( ret ) goto out ;touch_atime ( & path ) ;path_put ( & path ) ;,328
1659,"if ( ! state )  return NULL ;screen = vterm_allocator_malloc ( vt , sizeof ( VTermScreen ) ) ;vterm_get_size ( vt , & rows , & cols ) ;","if ( state == NULL ) return NULL ;screen = vterm_allocator_malloc ( vt , sizeof ( VTermScreen ) ) ;if ( screen == NULL ) return NULL ;vterm_get_size ( vt , & rows , & cols ) ;if ( screen -> buffer == NULL || screen -> sb_buffer == NULL ) {vterm_screen_free ( screen ) ;return NULL ;}",329
1660,"vterm_state_set_callbacks ( screen -> state , & state_cbs , screen ) ;return screen ;","vterm_state_set_callbacks ( screen -> state , & state_cbs , screen ) ;return screen ;",329
1661,"list_add ( & mnt -> mnt_list , & new_ns -> list ) ;}","new_ns -> mounts ++ ;list_add ( & mnt -> mnt_list , & new_ns -> list ) ;}",330
1662,"
","if ( len < j + msg -> len + 1 ) {LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\\return - 1 ;}",331
1663,"memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\\","memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;LM_DBG ( ""msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\\",331
1664,msg -> msg_namelen = sizeof ( * sipx ) ;if ( sipx ) {,if ( sipx ) {msg -> msg_namelen = sizeof ( * sipx ) ;,332
1665,vhost_net_ubuf_put_and_wait ( oldubufs ) ;mutex_lock ( & vq -> mutex ) ;,vhost_net_ubuf_put_wait_and_free ( oldubufs ) ;mutex_lock ( & vq -> mutex ) ;,333
1666,if ( ubufs )  vhost_net_ubuf_put_and_wait ( ubufs ) ;err_ubufs : fput ( sock -> file ) ;,if ( ubufs ) vhost_net_ubuf_put_wait_and_free ( ubufs ) ;err_ubufs : fput ( sock -> file ) ;,333
1667,"size_t buf_size = 0 ;if ( ! file || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 )  OE_RAISE_ERRNO ( OE_EINVAL ) ;","size_t buf_size = 0 ;size_t data_size = 0 ;if ( ! file || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_readv_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ;",334
1668,str_free ( b64 ) ;return NULL ;,BIO_free ( b64 ) ;return NULL ;,335
1669,"JAS_DBGLOG ( 101 , ( ""jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\\result = malloc ( size ) ;","JAS_DBGLOG ( 101 , ( ""jas_malloc(%zu)\\\result = malloc ( size ) ;",336
1670,"if ( len > INT_MAX )  len = INT_MAX ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;","if ( len > INT_MAX ) len = INT_MAX ;if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;",337
1671,"err = ops -> ieee_getets ( netdev , & ets ) ;if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ;err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ;if ( ! err ) {struct ieee_pfc pfc ;err = ops -> ieee_getpfc ( netdev , & pfc ) ;","memset ( & ets , 0 , sizeof ( ets ) ) ;err = ops -> ieee_getets ( netdev , & ets ) ;if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ;memset ( & maxrate , 0 , sizeof ( maxrate ) ) ;err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ;if ( ! err ) {struct ieee_pfc pfc ;memset ( & pfc , 0 , sizeof ( pfc ) ) ;err = ops -> ieee_getpfc ( netdev , & pfc ) ;",338
1672,"err = ops -> ieee_peer_getets ( netdev , & ets ) ;if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ;struct ieee_pfc pfc ;err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ;","memset ( & ets , 0 , sizeof ( ets ) ) ;err = ops -> ieee_peer_getets ( netdev , & ets ) ;if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ;struct ieee_pfc pfc ;memset ( & pfc , 0 , sizeof ( pfc ) ) ;err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ;",338
1673,msg -> msg_namelen = 0 ;release_sock ( sk ) ;,release_sock ( sk ) ;,339
1674,c -> req -> res = NULL ;if ( c -> up -> on_msg ) {,"memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;c -> req -> res = NULL ;if ( c -> up -> on_msg ) {",340
1675,WORD32 ret ;ps_dec -> u1_first_pb_nal_in_pic = 1 ;,WORD32 ret ;ps_dec -> u1_first_pb_nal_in_pic = 1 ;,341
1676,if ( ctx -> state == BODY_CHUNK_END ) {if ( c == LF ) {ctx -> state = BODY_CHUNK ;}return APR_EGENERAL ;}ctx -> chunkbits = sizeof ( long ) * 8 ;ctx -> chunk_used = 0 ;if ( c == ';' || c == CR ) {ctx -> state = BODY_CHUNK_EXT ;}else if ( c == LF ) {if ( ctx -> remaining ) {else if ( ctx -> state != BODY_CHUNK_EXT ) {int xvalue = 0 ;if ( ! ctx -> remaining && c == '0' ) {continue ;},if ( ctx -> state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF ) {if ( c == LF ) {ctx -> state = BODY_CHUNK ;}else if ( c == CR && ctx -> state == BODY_CHUNK_END ) {ctx -> state = BODY_CHUNK_END_LF ;}else {return APR_EINVAL ;}return APR_EINVAL ;}ctx -> chunkbits = sizeof ( apr_off_t ) * 8 ;ctx -> chunk_used = 0 ;if ( c == LF ) {if ( ctx -> remaining ) {else if ( ctx -> state == BODY_CHUNK_EXT ) {if ( c != '\\\\t' && apr_iscntrl ( c ) ) {return APR_EINVAL ;}}else if ( ctx -> state == BODY_CHUNK_PART ) {int xvalue = 0 ;if ( ! ctx -> remaining && c == '0' ) {continue ;}ctx -> chunkbits -= 4 ;if ( ctx -> chunkbits < 0 ) {return APR_ENOSPC ;},342
1677,return APR_EGENERAL ;}ctx -> chunkbits -= 4 ;if ( ctx -> chunkbits <= 0 || ctx -> remaining < 0 ) {}},return APR_EINVAL ;}if ( ctx -> remaining < 0 ) {}}else {return APR_EGENERAL ;},342
1678,"FD_SET ( sock , & mset ) ;max = sock > max ? sock : max ;}}for ( i = 0 ;i < modernsocks -> len ;i ++ ) {int sock = g_array_index ( modernsocks , int , i ) ;FD_SET ( sock , & mset ) ;max = sock > max ? sock : max ;}for ( ;;) {if ( is_sighup_caught ) {int n ;GError * gerror = NULL ;msg ( LOG_INFO , ""reconfiguration<S2SV_blank>request<S2SV_blank>received"" ) ;is_sighup_caught = 0 ;n = append_new_servers ( servers , & gerror ) ;if ( n == - 1 ) msg ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>new<S2SV_blank>servers:<S2SV_blank>%s"" , gerror -> message ) ;for ( i = servers -> len - n ;i < servers -> len ;++ i ) {const SERVER server = g_array_index ( servers , SERVER , i ) ;if ( server . socket >= 0 ) {FD_SET ( server . socket , & mset ) ;max = server . socket > max ? server . socket : max ;}msg ( LOG_INFO , ""reconfigured<S2SV_blank>new<S2SV_blank>server:<S2SV_blank>%s"" , server . servename ) ;}}memcpy ( & rset , & mset , sizeof ( fd_set ) ) ;if ( select ( max + 1 , & rset , NULL , NULL , NULL ) > 0 ) {int net ;DEBUG ( ""accept,<S2SV_blank>"" ) ;","+ i ) {DEBUG ( ""accept,<S2SV_blank>"" ) ;",343
1679,"CLIENT * client ;if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) {err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ;client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ;if ( ! client ) {","CLIENT * client ;if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) {err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ;client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ;if ( ! client ) {",343
1680,"if ( ! CU_add_test ( pSuite , ""pq"" , test_nghttp2_pq ) || ! CU_add_test ( pSuite , ""pq_update"" , test_nghttp2_pq_update ) || ! CU_add_test ( pSuite , ""pq_remove"" , test_nghttp2_pq_remove ) || ! CU_add_test ( pSuite , ""map"" , test_nghttp2_map ) || ! CU_add_test ( pSuite , ""map_functional"" , test_nghttp2_map_functional ) || ! CU_add_test ( pSuite , ""map_each_free"" , test_nghttp2_map_each_free ) || ! CU_add_test ( pSuite , ""queue"" , test_nghttp2_queue ) || ! CU_add_test ( pSuite , ""npn"" , test_nghttp2_npn ) || ! CU_add_test ( pSuite , ""session_recv"" , test_nghttp2_session_recv ) || ! CU_add_test ( pSuite , ""session_recv_invalid_stream_id"" , test_nghttp2_session_recv_invalid_stream_id ) || ! CU_add_test ( pSuite , ""session_recv_invalid_frame"" , test_nghttp2_session_recv_invalid_frame ) || ! CU_add_test ( pSuite , ""session_recv_eof"" , test_nghttp2_session_recv_eof ) || ! CU_add_test ( pSuite , ""session_recv_data"" , test_nghttp2_session_recv_data ) || ! CU_add_test ( pSuite , ""session_recv_data_no_auto_flow_control"" , test_nghttp2_session_recv_data_no_auto_flow_control ) || ! CU_add_test ( pSuite , ""session_recv_continuation"" , test_nghttp2_session_recv_continuation ) || ! CU_add_test ( pSuite , ""session_recv_headers_with_priority"" , test_nghttp2_session_recv_headers_with_priority ) || ! CU_add_test ( pSuite , ""session_recv_headers_with_padding"" , test_nghttp2_session_recv_headers_with_padding ) || ! CU_add_test ( pSuite , ""session_recv_headers_early_response"" , test_nghttp2_session_recv_headers_early_response ) || ! CU_add_test ( pSuite , ""session_recv_headers_for_closed_stream"" , test_nghttp2_session_recv_headers_for_closed_stream ) || ! CU_add_test ( pSuite , ""session_server_recv_push_response"" , test_nghttp2_session_server_recv_push_response ) || ! CU_add_test ( pSuite , ""session_recv_premature_headers"" , test_nghttp2_session_recv_premature_headers ) || ! CU_add_test ( pSuite , ""session_recv_unknown_frame"" , test_nghttp2_session_recv_unknown_frame ) || ! CU_add_test ( pSuite , ""session_recv_unexpected_continuation"" , test_nghttp2_session_recv_unexpected_continuation ) || ! CU_add_test ( pSuite , ""session_recv_settings_header_table_size"" , test_nghttp2_session_recv_settings_header_table_size ) || ! CU_add_test ( pSuite , ""session_recv_too_large_frame_length"" , test_nghttp2_session_recv_too_large_frame_length ) || ! CU_add_test ( pSuite , ""session_recv_extension"" , test_nghttp2_session_recv_extension ) || ! CU_add_test ( pSuite , ""session_recv_altsvc"" , test_nghttp2_session_recv_altsvc ) || ! CU_add_test ( pSuite , ""session_recv_origin"" , test_nghttp2_session_recv_origin ) || ! CU_add_test ( pSuite , ""session_continue"" , test_nghttp2_session_continue ) || ! CU_add_test ( pSuite , ""session_add_frame"" , test_nghttp2_session_add_frame ) || ! CU_add_test ( pSuite , ""session_on_request_headers_received"" , test_nghttp2_session_on_request_headers_received ) || ! CU_add_test ( pSuite , ""session_on_response_headers_received"" , test_nghttp2_session_on_response_headers_received ) || ! CU_add_test ( pSuite , ""session_on_headers_received"" , test_nghttp2_session_on_headers_received ) || ! CU_add_test ( pSuite , ""session_on_push_response_headers_received"" , test_nghttp2_session_on_push_response_headers_received ) || ! CU_add_test ( pSuite , ""session_on_priority_received"" , test_nghttp2_session_on_priority_received ) || ! CU_add_test ( pSuite , ""session_on_rst_stream_received"" , test_nghttp2_session_on_rst_stream_received ) || ! CU_add_test ( pSuite , ""session_on_settings_received"" , test_nghttp2_session_on_settings_received ) || ! CU_add_test ( pSuite , ""session_on_push_promise_received"" , test_nghttp2_session_on_push_promise_received ) || ! CU_add_test ( pSuite , ""session_on_ping_received"" , test_nghttp2_session_on_ping_received ) || ! CU_add_test ( pSuite , ""session_on_goaway_received"" , test_nghttp2_session_on_goaway_received ) || ! CU_add_test ( pSuite , ""session_on_window_update_received"" , test_nghttp2_session_on_window_update_received ) || ! CU_add_test ( pSuite , ""session_on_data_received"" , test_nghttp2_session_on_data_received ) || ! CU_add_test ( pSuite , ""session_on_data_received_fail_fast"" , test_nghttp2_session_on_data_received_fail_fast ) || ! CU_add_test ( pSuite , ""session_on_altsvc_received"" , test_nghttp2_session_on_altsvc_received ) || ! CU_add_test ( pSuite , ""session_send_headers_start_stream"" , test_nghttp2_session_send_headers_start_stream ) || ! CU_add_test ( pSuite , ""session_send_headers_reply"" , test_nghttp2_session_send_headers_reply ) || ! CU_add_test ( pSuite , ""session_send_headers_frame_size_error"" , test_nghttp2_session_send_headers_frame_size_error ) || ! CU_add_test ( pSuite , ""session_send_headers_push_reply"" , test_nghttp2_session_send_headers_push_reply ) || ! CU_add_test ( pSuite , ""session_send_rst_stream"" , test_nghttp2_session_send_rst_stream ) || ! CU_add_test ( pSuite , ""session_send_push_promise"" , test_nghttp2_session_send_push_promise ) || ! CU_add_test ( pSuite , ""session_is_my_stream_id"" , test_nghttp2_session_is_my_stream_id ) || ! CU_add_test ( pSuite , ""session_upgrade2"" , test_nghttp2_session_upgrade2 ) || ! CU_add_test ( pSuite , ""session_reprioritize_stream"" , test_nghttp2_session_reprioritize_stream ) || ! CU_add_test ( pSuite , ""session_reprioritize_stream_with_idle_stream_dep"" , test_nghttp2_session_reprioritize_stream_with_idle_stream_dep ) || ! CU_add_test ( pSuite , ""submit_data"" , test_nghttp2_submit_data ) || ! CU_add_test ( pSuite , ""submit_data_read_length_too_large"" , test_nghttp2_submit_data_read_length_too_large ) || ! CU_add_test ( pSuite , ""submit_data_read_length_smallest"" , test_nghttp2_submit_data_read_length_smallest ) || ! CU_add_test ( pSuite , ""submit_data_twice"" , test_nghttp2_submit_data_twice ) || ! CU_add_test ( pSuite , ""submit_request_with_data"" , test_nghttp2_submit_request_with_data ) || ! CU_add_test ( pSuite , ""submit_request_without_data"" , test_nghttp2_submit_request_without_data ) || ! CU_add_test ( pSuite , ""submit_response_with_data"" , test_nghttp2_submit_response_with_data ) || ! CU_add_test ( pSuite , ""submit_response_without_data"" , test_nghttp2_submit_response_without_data ) || ! CU_add_test ( pSuite , ""Submit_response_push_response"" , test_nghttp2_submit_response_push_response ) || ! CU_add_test ( pSuite , ""submit_trailer"" , test_nghttp2_submit_trailer ) || ! CU_add_test ( pSuite , ""submit_headers_start_stream"" , test_nghttp2_submit_headers_start_stream ) || ! CU_add_test ( pSuite , ""submit_headers_reply"" , test_nghttp2_submit_headers_reply ) || ! CU_add_test ( pSuite , ""submit_headers_push_reply"" , test_nghttp2_submit_headers_push_reply ) || ! CU_add_test ( pSuite , ""submit_headers"" , test_nghttp2_submit_headers ) || ! CU_add_test ( pSuite , ""submit_headers_continuation"" , test_nghttp2_submit_headers_continuation ) || ! CU_add_test ( pSuite , ""submit_headers_continuation_extra_large"" , test_nghttp2_submit_headers_continuation_extra_large ) || ! CU_add_test ( pSuite , ""submit_priority"" , test_nghttp2_submit_priority ) || ! CU_add_test ( pSuite , ""session_submit_settings"" , test_nghttp2_submit_settings ) || ! CU_add_test ( pSuite , ""session_submit_settings_update_local_window_size"" , test_nghttp2_submit_settings_update_local_window_size ) || ! CU_add_test ( pSuite , ""session_submit_settings_multiple_times"" , test_nghttp2_submit_settings_multiple_times ) || ! CU_add_test ( pSuite , ""session_submit_push_promise"" , test_nghttp2_submit_push_promise ) || ! CU_add_test ( pSuite , ""submit_window_update"" , test_nghttp2_submit_window_update ) || ! CU_add_test ( pSuite , ""submit_window_update_local_window_size"" , test_nghttp2_submit_window_update_local_window_size ) || ! CU_add_test ( pSuite , ""submit_shutdown_notice"" , test_nghttp2_submit_shutdown_notice ) || ! CU_add_test ( pSuite , ""submit_invalid_nv"" , test_nghttp2_submit_invalid_nv ) || ! CU_add_test ( pSuite , ""submit_extension"" , test_nghttp2_submit_extension ) || ! CU_add_test ( pSuite , ""submit_altsvc"" , test_nghttp2_submit_altsvc ) || ! CU_add_test ( pSuite , ""submit_origin"" , test_nghttp2_submit_origin ) || ! CU_add_test ( pSuite , ""session_open_stream"" , test_nghttp2_session_open_stream ) || ! CU_add_test ( pSuite , ""session_open_stream_with_idle_stream_dep"" , test_nghttp2_session_open_stream_with_idle_stream_dep ) || ! CU_add_test ( pSuite , ""session_get_next_ob_item"" , test_nghttp2_session_get_next_ob_item ) || ! CU_add_test ( pSuite , ""session_pop_next_ob_item"" , test_nghttp2_session_pop_next_ob_item ) || ! CU_add_test ( pSuite , ""session_reply_fail"" , test_nghttp2_session_reply_fail ) || ! CU_add_test ( pSuite , ""session_max_concurrent_streams"" , test_nghttp2_session_max_concurrent_streams ) || ! CU_add_test ( pSuite , ""session_stop_data_with_rst_stream"" , test_nghttp2_session_stop_data_with_rst_stream ) || ! CU_add_test ( pSuite , ""session_defer_data"" , test_nghttp2_session_defer_data ) || ! CU_add_test ( pSuite , ""session_flow_control"" , test_nghttp2_session_flow_control ) || ! CU_add_test ( pSuite , ""session_flow_control_data_recv"" , test_nghttp2_session_flow_control_data_recv ) || ! CU_add_test ( pSuite , ""session_flow_control_data_with_padding_recv"" , test_nghttp2_session_flow_control_data_with_padding_recv ) || ! CU_add_test ( pSuite , ""session_data_read_temporal_failure"" , test_nghttp2_session_data_read_temporal_failure ) || ! CU_add_test ( pSuite , ""session_on_stream_close"" , test_nghttp2_session_on_stream_close ) || ! CU_add_test ( pSuite , ""session_on_ctrl_not_send"" , test_nghttp2_session_on_ctrl_not_send ) || ! CU_add_test ( pSuite , ""session_get_outbound_queue_size"" , test_nghttp2_session_get_outbound_queue_size ) || ! CU_add_test ( pSuite , ""session_get_effective_local_window_size"" , test_nghttp2_session_get_effective_local_window_size ) || ! CU_add_test ( pSuite , ""session_set_option"" , test_nghttp2_session_set_option ) || ! CU_add_test ( pSuite , ""session_data_backoff_by_high_pri_frame"" , test_nghttp2_session_data_backoff_by_high_pri_frame ) || ! CU_add_test ( pSuite , ""session_pack_data_with_padding"" , test_nghttp2_session_pack_data_with_padding ) || ! CU_add_test ( pSuite , ""session_pack_headers_with_padding"" , test_nghttp2_session_pack_headers_with_padding ) || ! CU_add_test ( pSuite , ""pack_settings_payload"" , test_nghttp2_pack_settings_payload ) || ! CU_add_test ( pSuite , ""session_stream_dep_add"" , test_nghttp2_session_stream_dep_add ) || ! CU_add_test ( pSuite , ""session_stream_dep_remove"" , test_nghttp2_session_stream_dep_remove ) || ! CU_add_test ( pSuite , ""session_stream_dep_add_subtree"" , test_nghttp2_session_stream_dep_add_subtree ) || ! CU_add_test ( pSuite , ""session_stream_dep_remove_subtree"" , test_nghttp2_session_stream_dep_remove_subtree ) || ! CU_add_test ( pSuite , ""session_stream_dep_all_your_stream_are_belong_to_us"" , test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us ) || ! CU_add_test ( pSuite , ""session_stream_attach_item"" , test_nghttp2_session_stream_attach_item ) || ! CU_add_test ( pSuite , ""session_stream_attach_item_subtree"" , test_nghttp2_session_stream_attach_item_subtree ) || ! CU_add_test ( pSuite , ""session_stream_get_state"" , test_nghttp2_session_stream_get_state ) || ! CU_add_test ( pSuite , ""session_stream_get_something"" , test_nghttp2_session_stream_get_something ) || ! CU_add_test ( pSuite , ""session_find_stream"" , test_nghttp2_session_find_stream ) || ! CU_add_test ( pSuite , ""session_keep_closed_stream"" , test_nghttp2_session_keep_closed_stream ) || ! CU_add_test ( pSuite , ""session_keep_idle_stream"" , test_nghttp2_session_keep_idle_stream ) || ! CU_add_test ( pSuite , ""session_detach_idle_stream"" , test_nghttp2_session_detach_idle_stream ) || ! CU_add_test ( pSuite , ""session_large_dep_tree"" , test_nghttp2_session_large_dep_tree ) || ! CU_add_test ( pSuite , ""session_graceful_shutdown"" , test_nghttp2_session_graceful_shutdown ) || ! CU_add_test ( pSuite , ""session_on_header_temporal_failure"" , test_nghttp2_session_on_header_temporal_failure ) || ! CU_add_test ( pSuite , ""session_recv_client_magic"" , test_nghttp2_session_recv_client_magic ) || ! CU_add_test ( pSuite , ""session_delete_data_item"" , test_nghttp2_session_delete_data_item ) || ! CU_add_test ( pSuite , ""session_open_idle_stream"" , test_nghttp2_session_open_idle_stream ) || ! CU_add_test ( pSuite , ""session_cancel_reserved_remote"" , test_nghttp2_session_cancel_reserved_remote ) || ! CU_add_test ( pSuite , ""session_reset_pending_headers"" , test_nghttp2_session_reset_pending_headers ) || ! CU_add_test ( pSuite , ""session_send_data_callback"" , test_nghttp2_session_send_data_callback ) || ! CU_add_test ( pSuite , ""session_on_begin_headers_temporal_failure"" , test_nghttp2_session_on_begin_headers_temporal_failure ) || ! CU_add_test ( pSuite , ""session_defer_then_close"" , test_nghttp2_session_defer_then_close ) || ! CU_add_test ( pSuite , ""session_detach_item_from_closed_stream"" , test_nghttp2_session_detach_item_from_closed_stream ) || ! CU_add_test ( pSuite , ""session_flooding"" , test_nghttp2_session_flooding ) || ! CU_add_test ( pSuite , ""session_change_stream_priority"" , test_nghttp2_session_change_stream_priority ) || ! CU_add_test ( pSuite , ""session_create_idle_stream"" , test_nghttp2_session_create_idle_stream ) || ! CU_add_test ( pSuite , ""session_repeated_priority_change"" , test_nghttp2_session_repeated_priority_change ) || ! CU_add_test ( pSuite , ""session_repeated_priority_submission"" , test_nghttp2_session_repeated_priority_submission ) || ! CU_add_test ( pSuite , ""session_set_local_window_size"" , test_nghttp2_session_set_local_window_size ) || ! CU_add_test ( pSuite , ""session_cancel_from_before_frame_send"" , test_nghttp2_session_cancel_from_before_frame_send ) ||  ! CU_add_test ( pSuite , ""session_removed_closed_stream"" ,  test_nghttp2_session_removed_closed_stream ) || ! CU_add_test ( pSuite , ""session_pause_data"" , test_nghttp2_session_pause_data ) || ! CU_add_test ( pSuite , ""session_no_closed_streams"" , test_nghttp2_session_no_closed_streams ) || ! CU_add_test ( pSuite , ""session_set_stream_user_data"" , test_nghttp2_session_set_stream_user_data ) || ! CU_add_test ( pSuite , ""http_mandatory_headers"" , test_nghttp2_http_mandatory_headers ) || ! CU_add_test ( pSuite , ""http_content_length"" , test_nghttp2_http_content_length ) || ! CU_add_test ( pSuite , ""http_content_length_mismatch"" , test_nghttp2_http_content_length_mismatch ) || ! CU_add_test ( pSuite , ""http_non_final_response"" , test_nghttp2_http_non_final_response ) || ! CU_add_test ( pSuite , ""http_trailer_headers"" , test_nghttp2_http_trailer_headers ) || ! CU_add_test ( pSuite , ""http_ignore_regular_header"" , test_nghttp2_http_ignore_regular_header ) || ! CU_add_test ( pSuite , ""http_ignore_content_length"" , test_nghttp2_http_ignore_content_length ) || ! CU_add_test ( pSuite , ""http_record_request_method"" , test_nghttp2_http_record_request_method ) || ! CU_add_test ( pSuite , ""http_push_promise"" , test_nghttp2_http_push_promise ) || ! CU_add_test ( pSuite , ""http_head_method_upgrade_workaround"" , test_nghttp2_http_head_method_upgrade_workaround ) || ! CU_add_test ( pSuite , ""frame_pack_headers"" , test_nghttp2_frame_pack_headers ) || ! CU_add_test ( pSuite , ""frame_pack_headers_frame_too_large"" , test_nghttp2_frame_pack_headers_frame_too_large ) || ! CU_add_test ( pSuite , ""frame_pack_priority"" , test_nghttp2_frame_pack_priority ) || ! CU_add_test ( pSuite , ""frame_pack_rst_stream"" , test_nghttp2_frame_pack_rst_stream ) || ! CU_add_test ( pSuite , ""frame_pack_settings"" , test_nghttp2_frame_pack_settings ) || ! CU_add_test ( pSuite , ""frame_pack_push_promise"" , test_nghttp2_frame_pack_push_promise ) || ! CU_add_test ( pSuite , ""frame_pack_ping"" , test_nghttp2_frame_pack_ping ) || ! CU_add_test ( pSuite , ""frame_pack_goaway"" , test_nghttp2_frame_pack_goaway ) || ! CU_add_test ( pSuite , ""frame_pack_window_update"" , test_nghttp2_frame_pack_window_update ) || ! CU_add_test ( pSuite , ""frame_pack_altsvc"" , test_nghttp2_frame_pack_altsvc ) || ! CU_add_test ( pSuite , ""frame_pack_origin"" , test_nghttp2_frame_pack_origin ) || ! CU_add_test ( pSuite , ""nv_array_copy"" , test_nghttp2_nv_array_copy ) || ! CU_add_test ( pSuite , ""iv_check"" , test_nghttp2_iv_check ) || ! CU_add_test ( pSuite , ""hd_deflate"" , test_nghttp2_hd_deflate ) || ! CU_add_test ( pSuite , ""hd_deflate_same_indexed_repr"" , test_nghttp2_hd_deflate_same_indexed_repr ) || ! CU_add_test ( pSuite , ""hd_inflate_indexed"" , test_nghttp2_hd_inflate_indexed ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_noinc"" , test_nghttp2_hd_inflate_indname_noinc ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_inc"" , test_nghttp2_hd_inflate_indname_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_inc_eviction"" , test_nghttp2_hd_inflate_indname_inc_eviction ) || ! CU_add_test ( pSuite , ""hd_inflate_newname_noinc"" , test_nghttp2_hd_inflate_newname_noinc ) || ! CU_add_test ( pSuite , ""hd_inflate_newname_inc"" , test_nghttp2_hd_inflate_newname_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_clearall_inc"" , test_nghttp2_hd_inflate_clearall_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_zero_length_huffman"" , test_nghttp2_hd_inflate_zero_length_huffman ) || ! CU_add_test ( pSuite , ""hd_inflate_expect_table_size_update"" , test_nghttp2_hd_inflate_expect_table_size_update ) || ! CU_add_test ( pSuite , ""hd_inflate_unexpected_table_size_update"" , test_nghttp2_hd_inflate_unexpected_table_size_update ) || ! CU_add_test ( pSuite , ""hd_ringbuf_reserve"" , test_nghttp2_hd_ringbuf_reserve ) || ! CU_add_test ( pSuite , ""hd_change_table_size"" , test_nghttp2_hd_change_table_size ) || ! CU_add_test ( pSuite , ""hd_deflate_inflate"" , test_nghttp2_hd_deflate_inflate ) || ! CU_add_test ( pSuite , ""hd_no_index"" , test_nghttp2_hd_no_index ) || ! CU_add_test ( pSuite , ""hd_deflate_bound"" , test_nghttp2_hd_deflate_bound ) || ! CU_add_test ( pSuite , ""hd_public_api"" , test_nghttp2_hd_public_api ) || ! CU_add_test ( pSuite , ""hd_deflate_hd_vec"" , test_nghttp2_hd_deflate_hd_vec ) || ! CU_add_test ( pSuite , ""hd_decode_length"" , test_nghttp2_hd_decode_length ) || ! CU_add_test ( pSuite , ""hd_huff_encode"" , test_nghttp2_hd_huff_encode ) || ! CU_add_test ( pSuite , ""hd_huff_decode"" , test_nghttp2_hd_huff_decode ) || ! CU_add_test ( pSuite , ""adjust_local_window_size"" , test_nghttp2_adjust_local_window_size ) || ! CU_add_test ( pSuite , ""check_header_name"" , test_nghttp2_check_header_name ) || ! CU_add_test ( pSuite , ""check_header_value"" , test_nghttp2_check_header_value ) || ! CU_add_test ( pSuite , ""bufs_add"" , test_nghttp2_bufs_add ) || ! CU_add_test ( pSuite , ""bufs_add_stack_buffer_overflow_bug"" , test_nghttp2_bufs_add_stack_buffer_overflow_bug ) || ! CU_add_test ( pSuite , ""bufs_addb"" , test_nghttp2_bufs_addb ) || ! CU_add_test ( pSuite , ""bufs_orb"" , test_nghttp2_bufs_orb ) || ! CU_add_test ( pSuite , ""bufs_remove"" , test_nghttp2_bufs_remove ) || ! CU_add_test ( pSuite , ""bufs_reset"" , test_nghttp2_bufs_reset ) || ! CU_add_test ( pSuite , ""bufs_advance"" , test_nghttp2_bufs_advance ) || ! CU_add_test ( pSuite , ""bufs_next_present"" , test_nghttp2_bufs_next_present ) || ! CU_add_test ( pSuite , ""bufs_realloc"" , test_nghttp2_bufs_realloc ) ) {","if ( ! CU_add_test ( pSuite , ""session_too_many_settings"" , test_nghttp2_session_too_many_settings ) || ! CU_add_test ( pSuite , ""pq"" , test_nghttp2_pq ) || ! CU_add_test ( pSuite , ""pq_update"" , test_nghttp2_pq_update ) || ! CU_add_test ( pSuite , ""pq_remove"" , test_nghttp2_pq_remove ) || ! CU_add_test ( pSuite , ""map"" , test_nghttp2_map ) || ! CU_add_test ( pSuite , ""map_functional"" , test_nghttp2_map_functional ) || ! CU_add_test ( pSuite , ""map_each_free"" , test_nghttp2_map_each_free ) || ! CU_add_test ( pSuite , ""queue"" , test_nghttp2_queue ) || ! CU_add_test ( pSuite , ""npn"" , test_nghttp2_npn ) || ! CU_add_test ( pSuite , ""session_recv"" , test_nghttp2_session_recv ) || ! CU_add_test ( pSuite , ""session_recv_invalid_stream_id"" , test_nghttp2_session_recv_invalid_stream_id ) || ! CU_add_test ( pSuite , ""session_recv_invalid_frame"" , test_nghttp2_session_recv_invalid_frame ) || ! CU_add_test ( pSuite , ""session_recv_eof"" , test_nghttp2_session_recv_eof ) || ! CU_add_test ( pSuite , ""session_recv_data"" , test_nghttp2_session_recv_data ) || ! CU_add_test ( pSuite , ""session_recv_data_no_auto_flow_control"" , test_nghttp2_session_recv_data_no_auto_flow_control ) || ! CU_add_test ( pSuite , ""session_recv_continuation"" , test_nghttp2_session_recv_continuation ) || ! CU_add_test ( pSuite , ""session_recv_headers_with_priority"" , test_nghttp2_session_recv_headers_with_priority ) || ! CU_add_test ( pSuite , ""session_recv_headers_with_padding"" , test_nghttp2_session_recv_headers_with_padding ) || ! CU_add_test ( pSuite , ""session_recv_headers_early_response"" , test_nghttp2_session_recv_headers_early_response ) || ! CU_add_test ( pSuite , ""session_recv_headers_for_closed_stream"" , test_nghttp2_session_recv_headers_for_closed_stream ) || ! CU_add_test ( pSuite , ""session_server_recv_push_response"" , test_nghttp2_session_server_recv_push_response ) || ! CU_add_test ( pSuite , ""session_recv_premature_headers"" , test_nghttp2_session_recv_premature_headers ) || ! CU_add_test ( pSuite , ""session_recv_unknown_frame"" , test_nghttp2_session_recv_unknown_frame ) || ! CU_add_test ( pSuite , ""session_recv_unexpected_continuation"" , test_nghttp2_session_recv_unexpected_continuation ) || ! CU_add_test ( pSuite , ""session_recv_settings_header_table_size"" , test_nghttp2_session_recv_settings_header_table_size ) || ! CU_add_test ( pSuite , ""session_recv_too_large_frame_length"" , test_nghttp2_session_recv_too_large_frame_length ) || ! CU_add_test ( pSuite , ""session_recv_extension"" , test_nghttp2_session_recv_extension ) || ! CU_add_test ( pSuite , ""session_recv_altsvc"" , test_nghttp2_session_recv_altsvc ) || ! CU_add_test ( pSuite , ""session_recv_origin"" , test_nghttp2_session_recv_origin ) || ! CU_add_test ( pSuite , ""session_continue"" , test_nghttp2_session_continue ) || ! CU_add_test ( pSuite , ""session_add_frame"" , test_nghttp2_session_add_frame ) || ! CU_add_test ( pSuite , ""session_on_request_headers_received"" , test_nghttp2_session_on_request_headers_received ) || ! CU_add_test ( pSuite , ""session_on_response_headers_received"" , test_nghttp2_session_on_response_headers_received ) || ! CU_add_test ( pSuite , ""session_on_headers_received"" , test_nghttp2_session_on_headers_received ) || ! CU_add_test ( pSuite , ""session_on_push_response_headers_received"" , test_nghttp2_session_on_push_response_headers_received ) || ! CU_add_test ( pSuite , ""session_on_priority_received"" , test_nghttp2_session_on_priority_received ) || ! CU_add_test ( pSuite , ""session_on_rst_stream_received"" , test_nghttp2_session_on_rst_stream_received ) || ! CU_add_test ( pSuite , ""session_on_settings_received"" , test_nghttp2_session_on_settings_received ) || ! CU_add_test ( pSuite , ""session_on_push_promise_received"" , test_nghttp2_session_on_push_promise_received ) || ! CU_add_test ( pSuite , ""session_on_ping_received"" , test_nghttp2_session_on_ping_received ) || ! CU_add_test ( pSuite , ""session_on_goaway_received"" , test_nghttp2_session_on_goaway_received ) || ! CU_add_test ( pSuite , ""session_on_window_update_received"" , test_nghttp2_session_on_window_update_received ) || ! CU_add_test ( pSuite , ""session_on_data_received"" , test_nghttp2_session_on_data_received ) || ! CU_add_test ( pSuite , ""session_on_data_received_fail_fast"" , test_nghttp2_session_on_data_received_fail_fast ) || ! CU_add_test ( pSuite , ""session_on_altsvc_received"" , test_nghttp2_session_on_altsvc_received ) || ! CU_add_test ( pSuite , ""session_send_headers_start_stream"" , test_nghttp2_session_send_headers_start_stream ) || ! CU_add_test ( pSuite , ""session_send_headers_reply"" , test_nghttp2_session_send_headers_reply ) || ! CU_add_test ( pSuite , ""session_send_headers_frame_size_error"" , test_nghttp2_session_send_headers_frame_size_error ) || ! CU_add_test ( pSuite , ""session_send_headers_push_reply"" , test_nghttp2_session_send_headers_push_reply ) || ! CU_add_test ( pSuite , ""session_send_rst_stream"" , test_nghttp2_session_send_rst_stream ) || ! CU_add_test ( pSuite , ""session_send_push_promise"" , test_nghttp2_session_send_push_promise ) || ! CU_add_test ( pSuite , ""session_is_my_stream_id"" , test_nghttp2_session_is_my_stream_id ) || ! CU_add_test ( pSuite , ""session_upgrade2"" , test_nghttp2_session_upgrade2 ) || ! CU_add_test ( pSuite , ""session_reprioritize_stream"" , test_nghttp2_session_reprioritize_stream ) || ! CU_add_test ( pSuite , ""session_reprioritize_stream_with_idle_stream_dep"" , test_nghttp2_session_reprioritize_stream_with_idle_stream_dep ) || ! CU_add_test ( pSuite , ""submit_data"" , test_nghttp2_submit_data ) || ! CU_add_test ( pSuite , ""submit_data_read_length_too_large"" , test_nghttp2_submit_data_read_length_too_large ) || ! CU_add_test ( pSuite , ""submit_data_read_length_smallest"" , test_nghttp2_submit_data_read_length_smallest ) || ! CU_add_test ( pSuite , ""submit_data_twice"" , test_nghttp2_submit_data_twice ) || ! CU_add_test ( pSuite , ""submit_request_with_data"" , test_nghttp2_submit_request_with_data ) || ! CU_add_test ( pSuite , ""submit_request_without_data"" , test_nghttp2_submit_request_without_data ) || ! CU_add_test ( pSuite , ""submit_response_with_data"" , test_nghttp2_submit_response_with_data ) || ! CU_add_test ( pSuite , ""submit_response_without_data"" , test_nghttp2_submit_response_without_data ) || ! CU_add_test ( pSuite , ""Submit_response_push_response"" , test_nghttp2_submit_response_push_response ) || ! CU_add_test ( pSuite , ""submit_trailer"" , test_nghttp2_submit_trailer ) || ! CU_add_test ( pSuite , ""submit_headers_start_stream"" , test_nghttp2_submit_headers_start_stream ) || ! CU_add_test ( pSuite , ""submit_headers_reply"" , test_nghttp2_submit_headers_reply ) || ! CU_add_test ( pSuite , ""submit_headers_push_reply"" , test_nghttp2_submit_headers_push_reply ) || ! CU_add_test ( pSuite , ""submit_headers"" , test_nghttp2_submit_headers ) || ! CU_add_test ( pSuite , ""submit_headers_continuation"" , test_nghttp2_submit_headers_continuation ) || ! CU_add_test ( pSuite , ""submit_headers_continuation_extra_large"" , test_nghttp2_submit_headers_continuation_extra_large ) || ! CU_add_test ( pSuite , ""submit_priority"" , test_nghttp2_submit_priority ) || ! CU_add_test ( pSuite , ""session_submit_settings"" , test_nghttp2_submit_settings ) || ! CU_add_test ( pSuite , ""session_submit_settings_update_local_window_size"" , test_nghttp2_submit_settings_update_local_window_size ) || ! CU_add_test ( pSuite , ""session_submit_settings_multiple_times"" , test_nghttp2_submit_settings_multiple_times ) || ! CU_add_test ( pSuite , ""session_submit_push_promise"" , test_nghttp2_submit_push_promise ) || ! CU_add_test ( pSuite , ""submit_window_update"" , test_nghttp2_submit_window_update ) || ! CU_add_test ( pSuite , ""submit_window_update_local_window_size"" , test_nghttp2_submit_window_update_local_window_size ) || ! CU_add_test ( pSuite , ""submit_shutdown_notice"" , test_nghttp2_submit_shutdown_notice ) || ! CU_add_test ( pSuite , ""submit_invalid_nv"" , test_nghttp2_submit_invalid_nv ) || ! CU_add_test ( pSuite , ""submit_extension"" , test_nghttp2_submit_extension ) || ! CU_add_test ( pSuite , ""submit_altsvc"" , test_nghttp2_submit_altsvc ) || ! CU_add_test ( pSuite , ""submit_origin"" , test_nghttp2_submit_origin ) || ! CU_add_test ( pSuite , ""session_open_stream"" , test_nghttp2_session_open_stream ) || ! CU_add_test ( pSuite , ""session_open_stream_with_idle_stream_dep"" , test_nghttp2_session_open_stream_with_idle_stream_dep ) || ! CU_add_test ( pSuite , ""session_get_next_ob_item"" , test_nghttp2_session_get_next_ob_item ) || ! CU_add_test ( pSuite , ""session_pop_next_ob_item"" , test_nghttp2_session_pop_next_ob_item ) || ! CU_add_test ( pSuite , ""session_reply_fail"" , test_nghttp2_session_reply_fail ) || ! CU_add_test ( pSuite , ""session_max_concurrent_streams"" , test_nghttp2_session_max_concurrent_streams ) || ! CU_add_test ( pSuite , ""session_stop_data_with_rst_stream"" , test_nghttp2_session_stop_data_with_rst_stream ) || ! CU_add_test ( pSuite , ""session_defer_data"" , test_nghttp2_session_defer_data ) || ! CU_add_test ( pSuite , ""session_flow_control"" , test_nghttp2_session_flow_control ) || ! CU_add_test ( pSuite , ""session_flow_control_data_recv"" , test_nghttp2_session_flow_control_data_recv ) || ! CU_add_test ( pSuite , ""session_flow_control_data_with_padding_recv"" , test_nghttp2_session_flow_control_data_with_padding_recv ) || ! CU_add_test ( pSuite , ""session_data_read_temporal_failure"" , test_nghttp2_session_data_read_temporal_failure ) || ! CU_add_test ( pSuite , ""session_on_stream_close"" , test_nghttp2_session_on_stream_close ) || ! CU_add_test ( pSuite , ""session_on_ctrl_not_send"" , test_nghttp2_session_on_ctrl_not_send ) || ! CU_add_test ( pSuite , ""session_get_outbound_queue_size"" , test_nghttp2_session_get_outbound_queue_size ) || ! CU_add_test ( pSuite , ""session_get_effective_local_window_size"" , test_nghttp2_session_get_effective_local_window_size ) || ! CU_add_test ( pSuite , ""session_set_option"" , test_nghttp2_session_set_option ) || ! CU_add_test ( pSuite , ""session_data_backoff_by_high_pri_frame"" , test_nghttp2_session_data_backoff_by_high_pri_frame ) || ! CU_add_test ( pSuite , ""session_pack_data_with_padding"" , test_nghttp2_session_pack_data_with_padding ) || ! CU_add_test ( pSuite , ""session_pack_headers_with_padding"" , test_nghttp2_session_pack_headers_with_padding ) || ! CU_add_test ( pSuite , ""pack_settings_payload"" , test_nghttp2_pack_settings_payload ) || ! CU_add_test ( pSuite , ""session_stream_dep_add"" , test_nghttp2_session_stream_dep_add ) || ! CU_add_test ( pSuite , ""session_stream_dep_remove"" , test_nghttp2_session_stream_dep_remove ) || ! CU_add_test ( pSuite , ""session_stream_dep_add_subtree"" , test_nghttp2_session_stream_dep_add_subtree ) || ! CU_add_test ( pSuite , ""session_stream_dep_remove_subtree"" , test_nghttp2_session_stream_dep_remove_subtree ) || ! CU_add_test ( pSuite , ""session_stream_dep_all_your_stream_are_belong_to_us"" , test_nghttp2_session_stream_dep_all_your_stream_are_belong_to_us ) || ! CU_add_test ( pSuite , ""session_stream_attach_item"" , test_nghttp2_session_stream_attach_item ) || ! CU_add_test ( pSuite , ""session_stream_attach_item_subtree"" , test_nghttp2_session_stream_attach_item_subtree ) || ! CU_add_test ( pSuite , ""session_stream_get_state"" , test_nghttp2_session_stream_get_state ) || ! CU_add_test ( pSuite , ""session_stream_get_something"" , test_nghttp2_session_stream_get_something ) || ! CU_add_test ( pSuite , ""session_find_stream"" , test_nghttp2_session_find_stream ) || ! CU_add_test ( pSuite , ""session_keep_closed_stream"" , test_nghttp2_session_keep_closed_stream ) || ! CU_add_test ( pSuite , ""session_keep_idle_stream"" , test_nghttp2_session_keep_idle_stream ) || ! CU_add_test ( pSuite , ""session_detach_idle_stream"" , test_nghttp2_session_detach_idle_stream ) || ! CU_add_test ( pSuite , ""session_large_dep_tree"" , test_nghttp2_session_large_dep_tree ) || ! CU_add_test ( pSuite , ""session_graceful_shutdown"" , test_nghttp2_session_graceful_shutdown ) || ! CU_add_test ( pSuite , ""session_on_header_temporal_failure"" , test_nghttp2_session_on_header_temporal_failure ) || ! CU_add_test ( pSuite , ""session_recv_client_magic"" , test_nghttp2_session_recv_client_magic ) || ! CU_add_test ( pSuite , ""session_delete_data_item"" , test_nghttp2_session_delete_data_item ) || ! CU_add_test ( pSuite , ""session_open_idle_stream"" , test_nghttp2_session_open_idle_stream ) || ! CU_add_test ( pSuite , ""session_cancel_reserved_remote"" , test_nghttp2_session_cancel_reserved_remote ) || ! CU_add_test ( pSuite , ""session_reset_pending_headers"" , test_nghttp2_session_reset_pending_headers ) || ! CU_add_test ( pSuite , ""session_send_data_callback"" , test_nghttp2_session_send_data_callback ) || ! CU_add_test ( pSuite , ""session_on_begin_headers_temporal_failure"" , test_nghttp2_session_on_begin_headers_temporal_failure ) || ! CU_add_test ( pSuite , ""session_defer_then_close"" , test_nghttp2_session_defer_then_close ) || ! CU_add_test ( pSuite , ""session_detach_item_from_closed_stream"" , test_nghttp2_session_detach_item_from_closed_stream ) || ! CU_add_test ( pSuite , ""session_flooding"" , test_nghttp2_session_flooding ) || ! CU_add_test ( pSuite , ""session_change_stream_priority"" , test_nghttp2_session_change_stream_priority ) || ! CU_add_test ( pSuite , ""session_create_idle_stream"" , test_nghttp2_session_create_idle_stream ) || ! CU_add_test ( pSuite , ""session_repeated_priority_change"" , test_nghttp2_session_repeated_priority_change ) || ! CU_add_test ( pSuite , ""session_repeated_priority_submission"" , test_nghttp2_session_repeated_priority_submission ) || ! CU_add_test ( pSuite , ""session_set_local_window_size"" , test_nghttp2_session_set_local_window_size ) || ! CU_add_test ( pSuite , ""session_cancel_from_before_frame_send"" , test_nghttp2_session_cancel_from_before_frame_send ) || ! CU_add_test ( pSuite , ""session_removed_closed_stream"" , test_nghttp2_session_removed_closed_stream ) || ! CU_add_test ( pSuite , ""session_pause_data"" , test_nghttp2_session_pause_data ) || ! CU_add_test ( pSuite , ""session_no_closed_streams"" , test_nghttp2_session_no_closed_streams ) || ! CU_add_test ( pSuite , ""session_set_stream_user_data"" , test_nghttp2_session_set_stream_user_data ) || ! CU_add_test ( pSuite , ""http_mandatory_headers"" , test_nghttp2_http_mandatory_headers ) || ! CU_add_test ( pSuite , ""http_content_length"" , test_nghttp2_http_content_length ) || ! CU_add_test ( pSuite , ""http_content_length_mismatch"" , test_nghttp2_http_content_length_mismatch ) || ! CU_add_test ( pSuite , ""http_non_final_response"" , test_nghttp2_http_non_final_response ) || ! CU_add_test ( pSuite , ""http_trailer_headers"" , test_nghttp2_http_trailer_headers ) || ! CU_add_test ( pSuite , ""http_ignore_regular_header"" , test_nghttp2_http_ignore_regular_header ) || ! CU_add_test ( pSuite , ""http_ignore_content_length"" , test_nghttp2_http_ignore_content_length ) || ! CU_add_test ( pSuite , ""http_record_request_method"" , test_nghttp2_http_record_request_method ) || ! CU_add_test ( pSuite , ""http_push_promise"" , test_nghttp2_http_push_promise ) || ! CU_add_test ( pSuite , ""http_head_method_upgrade_workaround"" , test_nghttp2_http_head_method_upgrade_workaround ) || ! CU_add_test ( pSuite , ""frame_pack_headers"" , test_nghttp2_frame_pack_headers ) || ! CU_add_test ( pSuite , ""frame_pack_headers_frame_too_large"" , test_nghttp2_frame_pack_headers_frame_too_large ) || ! CU_add_test ( pSuite , ""frame_pack_priority"" , test_nghttp2_frame_pack_priority ) || ! CU_add_test ( pSuite , ""frame_pack_rst_stream"" , test_nghttp2_frame_pack_rst_stream ) || ! CU_add_test ( pSuite , ""frame_pack_settings"" , test_nghttp2_frame_pack_settings ) || ! CU_add_test ( pSuite , ""frame_pack_push_promise"" , test_nghttp2_frame_pack_push_promise ) || ! CU_add_test ( pSuite , ""frame_pack_ping"" , test_nghttp2_frame_pack_ping ) || ! CU_add_test ( pSuite , ""frame_pack_goaway"" , test_nghttp2_frame_pack_goaway ) || ! CU_add_test ( pSuite , ""frame_pack_window_update"" , test_nghttp2_frame_pack_window_update ) || ! CU_add_test ( pSuite , ""frame_pack_altsvc"" , test_nghttp2_frame_pack_altsvc ) || ! CU_add_test ( pSuite , ""frame_pack_origin"" , test_nghttp2_frame_pack_origin ) || ! CU_add_test ( pSuite , ""nv_array_copy"" , test_nghttp2_nv_array_copy ) || ! CU_add_test ( pSuite , ""iv_check"" , test_nghttp2_iv_check ) || ! CU_add_test ( pSuite , ""hd_deflate"" , test_nghttp2_hd_deflate ) || ! CU_add_test ( pSuite , ""hd_deflate_same_indexed_repr"" , test_nghttp2_hd_deflate_same_indexed_repr ) || ! CU_add_test ( pSuite , ""hd_inflate_indexed"" , test_nghttp2_hd_inflate_indexed ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_noinc"" , test_nghttp2_hd_inflate_indname_noinc ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_inc"" , test_nghttp2_hd_inflate_indname_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_indname_inc_eviction"" , test_nghttp2_hd_inflate_indname_inc_eviction ) || ! CU_add_test ( pSuite , ""hd_inflate_newname_noinc"" , test_nghttp2_hd_inflate_newname_noinc ) || ! CU_add_test ( pSuite , ""hd_inflate_newname_inc"" , test_nghttp2_hd_inflate_newname_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_clearall_inc"" , test_nghttp2_hd_inflate_clearall_inc ) || ! CU_add_test ( pSuite , ""hd_inflate_zero_length_huffman"" , test_nghttp2_hd_inflate_zero_length_huffman ) || ! CU_add_test ( pSuite , ""hd_inflate_expect_table_size_update"" , test_nghttp2_hd_inflate_expect_table_size_update ) || ! CU_add_test ( pSuite , ""hd_inflate_unexpected_table_size_update"" , test_nghttp2_hd_inflate_unexpected_table_size_update ) || ! CU_add_test ( pSuite , ""hd_ringbuf_reserve"" , test_nghttp2_hd_ringbuf_reserve ) || ! CU_add_test ( pSuite , ""hd_change_table_size"" , test_nghttp2_hd_change_table_size ) || ! CU_add_test ( pSuite , ""hd_deflate_inflate"" , test_nghttp2_hd_deflate_inflate ) || ! CU_add_test ( pSuite , ""hd_no_index"" , test_nghttp2_hd_no_index ) || ! CU_add_test ( pSuite , ""hd_deflate_bound"" , test_nghttp2_hd_deflate_bound ) || ! CU_add_test ( pSuite , ""hd_public_api"" , test_nghttp2_hd_public_api ) || ! CU_add_test ( pSuite , ""hd_deflate_hd_vec"" , test_nghttp2_hd_deflate_hd_vec ) || ! CU_add_test ( pSuite , ""hd_decode_length"" , test_nghttp2_hd_decode_length ) || ! CU_add_test ( pSuite , ""hd_huff_encode"" , test_nghttp2_hd_huff_encode ) || ! CU_add_test ( pSuite , ""hd_huff_decode"" , test_nghttp2_hd_huff_decode ) || ! CU_add_test ( pSuite , ""adjust_local_window_size"" , test_nghttp2_adjust_local_window_size ) || ! CU_add_test ( pSuite , ""check_header_name"" , test_nghttp2_check_header_name ) || ! CU_add_test ( pSuite , ""check_header_value"" , test_nghttp2_check_header_value ) || ! CU_add_test ( pSuite , ""bufs_add"" , test_nghttp2_bufs_add ) || ! CU_add_test ( pSuite , ""bufs_add_stack_buffer_overflow_bug"" , test_nghttp2_bufs_add_stack_buffer_overflow_bug ) || ! CU_add_test ( pSuite , ""bufs_addb"" , test_nghttp2_bufs_addb ) || ! CU_add_test ( pSuite , ""bufs_orb"" , test_nghttp2_bufs_orb ) || ! CU_add_test ( pSuite , ""bufs_remove"" , test_nghttp2_bufs_remove ) || ! CU_add_test ( pSuite , ""bufs_reset"" , test_nghttp2_bufs_reset ) || ! CU_add_test ( pSuite , ""bufs_advance"" , test_nghttp2_bufs_advance ) || ! CU_add_test ( pSuite , ""bufs_next_present"" , test_nghttp2_bufs_next_present ) || ! CU_add_test ( pSuite , ""bufs_realloc"" , test_nghttp2_bufs_realloc ) ) {",344
1681,WORD32 slice_address ;if ( ps_codec -> i4_slice_error == 1 ) return ret ;,WORD32 slice_address ;WORD32 prev_slice_incomplete_flag = 0 ;if ( ps_codec -> i4_slice_error == 1 ) return ret ;,345
1682,slice_header_t * ps_slice_hdr_next ;ps_codec -> i4_slice_error = 1 ;ps_codec -> s_parse . i4_cur_slice_idx -- ;if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ;ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ;ps_slice_hdr_next -> i2_ctb_x = 0 ;ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ;return ret ;,prev_slice_incomplete_flag = 1 ;,345
1683,"}ps_slice_hdr -> i1_dependent_slice_flag = value ;}else {ps_slice_hdr -> i1_dependent_slice_flag = 0 ;}ps_slice_hdr -> i1_nal_unit_type = i1_nal_unit_type ;ps_slice_hdr -> i1_pps_id = pps_id ;ps_slice_hdr -> i1_first_slice_in_pic_flag = first_slice_in_pic_flag ;ps_slice_hdr -> i1_no_output_of_prior_pics_flag = 1 ;if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) {ps_slice_hdr -> i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag ;}ps_slice_hdr -> i1_pps_id = pps_id ;if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) {WORD32 num_bits ;num_bits = 32 - CLZ ( ps_sps -> i4_pic_size_in_ctb - 1 ) ;BITS_PARSE ( ""slice_address"" , value , ps_bitstrm , num_bits ) ;slice_address = value ;if ( value >= ps_sps -> i4_pic_size_in_ctb ) return IHEVCD_IGNORE_SLICE ;}else {slice_address = 0 ;}if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) {ps_slice_hdr -> i1_pic_output_flag = 1 ;ps_slice_hdr -> i4_pic_order_cnt_lsb = 0 ;ps_slice_hdr -> i1_num_long_term_sps = 0 ;ps_slice_hdr -> i1_num_long_term_pics = 0 ;for ( i = 0 ;i < ps_pps -> i1_num_extra_slice_header_bits ;i ++ ) {BITS_PARSE ( ""slice_reserved_undetermined_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ;}UEV_PARSE ( ""slice_type"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_slice_type = value ;if ( ( ps_slice_hdr -> i1_nal_unit_type >= NAL_BLA_W_LP ) && ( ps_slice_hdr -> i1_nal_unit_type <= NAL_RSV_RAP_VCL23 ) ) ps_slice_hdr -> i1_slice_type = ISLICE ;if ( ( ps_slice_hdr -> i1_slice_type < 0 ) || ( ps_slice_hdr -> i1_slice_type > 2 ) ) return IHEVCD_IGNORE_SLICE ;if ( ps_pps -> i1_output_flag_present_flag ) {BITS_PARSE ( ""pic_output_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_pic_output_flag = value ;}ps_slice_hdr -> i1_colour_plane_id = 0 ;if ( 1 == ps_sps -> i1_separate_colour_plane_flag ) {BITS_PARSE ( ""colour_plane_id"" , value , ps_bitstrm , 2 ) ;ps_slice_hdr -> i1_colour_plane_id = value ;}ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = 0 ;if ( ! idr_pic_flag ) {WORD32 st_rps_idx ;WORD32 num_neg_pics ;WORD32 num_pos_pics ;WORD8 * pi1_used ;BITS_PARSE ( ""pic_order_cnt_lsb"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ;ps_slice_hdr -> i4_pic_order_cnt_lsb = value ;BITS_PARSE ( ""short_term_ref_pic_set_sps_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag = value ;if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) {WORD32 numbits ;ps_slice_hdr -> i1_short_term_ref_pic_set_idx = 0 ;if ( ps_sps -> i1_num_short_term_ref_pic_sets > 1 ) {numbits = 32 - CLZ ( ps_sps -> i1_num_short_term_ref_pic_sets - 1 ) ;BITS_PARSE ( ""short_term_ref_pic_set_idx"" , value , ps_bitstrm , numbits ) ;ps_slice_hdr -> i1_short_term_ref_pic_set_idx = value ;}st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ;num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ;num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ;pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ;}else {ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , ps_sps -> i1_num_short_term_ref_pic_sets , & ps_slice_hdr -> s_stref_picset ) ;st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ;num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ;num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ;pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ;}if ( ps_sps -> i1_long_term_ref_pics_present_flag ) {if ( ps_sps -> i1_num_long_term_ref_pics_sps > 0 ) {UEV_PARSE ( ""num_long_term_sps"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_num_long_term_sps = value ;ps_slice_hdr -> i1_num_long_term_sps = CLIP3 ( ps_slice_hdr -> i1_num_long_term_sps , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics ) ;}UEV_PARSE ( ""num_long_term_pics"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_num_long_term_pics = value ;ps_slice_hdr -> i1_num_long_term_pics = CLIP3 ( ps_slice_hdr -> i1_num_long_term_pics , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics - ps_slice_hdr -> i1_num_long_term_sps ) ;for ( i = 0 ;i < ( ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ) ;i ++ ) {if ( i < ps_slice_hdr -> i1_num_long_term_sps ) {if ( ps_sps -> i1_num_long_term_ref_pics_sps > 1 ) {WORD32 num_bits = 32 - CLZ ( ps_sps -> i1_num_long_term_ref_pics_sps - 1 ) ;BITS_PARSE ( ""lt_idx_sps[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , num_bits ) ;}else {value = 0 ;}ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = ps_sps -> au2_lt_ref_pic_poc_lsb_sps [ value ] ;ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ value ] ;}else {BITS_PARSE ( ""poc_lsb_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ;ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = value ;BITS_PARSE ( ""used_by_curr_pic_lt_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = value ;}BITS_PARSE ( ""delta_poc_msb_present_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] = value ;ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = 0 ;if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) {UEV_PARSE ( ""delata_poc_msb_cycle_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ;ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = value ;}if ( ( i != 0 ) && ( i != ps_slice_hdr -> i1_num_long_term_sps ) ) {ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] += ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i - 1 ] ;}}}for ( i = 0 ;i < num_neg_pics + num_pos_pics ;i ++ ) {if ( pi1_used [ i ] ) {num_poc_total_curr ++ ;}}for ( i = 0 ;i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ;i ++ ) {if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) {num_poc_total_curr ++ ;}}if ( ps_sps -> i1_sps_temporal_mvp_enable_flag ) {BITS_PARSE ( ""enable_temporal_mvp_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = value ;}}ps_slice_hdr -> i1_slice_sao_luma_flag = 0 ;ps_slice_hdr -> i1_slice_sao_chroma_flag = 0 ;if ( ps_sps -> i1_sample_adaptive_offset_enabled_flag ) {BITS_PARSE ( ""slice_sao_luma_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_slice_sao_luma_flag = value ;BITS_PARSE ( ""slice_sao_chroma_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_slice_sao_chroma_flag = value ;}ps_slice_hdr -> i1_max_num_merge_cand = 1 ;ps_slice_hdr -> i1_cabac_init_flag = 0 ;ps_slice_hdr -> i1_num_ref_idx_l0_active = 0 ;ps_slice_hdr -> i1_num_ref_idx_l1_active = 0 ;ps_slice_hdr -> i1_slice_cb_qp_offset = 0 ;ps_slice_hdr -> i1_slice_cr_qp_offset = 0 ;if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) {BITS_PARSE ( ""num_ref_idx_active_override_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_num_ref_idx_active_override_flag = value ;if ( ps_slice_hdr -> i1_num_ref_idx_active_override_flag ) {UEV_PARSE ( ""num_ref_idx_l0_active_minus1"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_num_ref_idx_l0_active = value + 1 ;if ( BSLICE == ps_slice_hdr -> i1_slice_type ) {UEV_PARSE ( ""num_ref_idx_l1_active_minus1"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_num_ref_idx_l1_active = value + 1 ;}}else {ps_slice_hdr -> i1_num_ref_idx_l0_active = ps_pps -> i1_num_ref_idx_l0_default_active ;if ( BSLICE == ps_slice_hdr -> i1_slice_type ) {ps_slice_hdr -> i1_num_ref_idx_l1_active = ps_pps -> i1_num_ref_idx_l1_default_active ;}}ps_slice_hdr -> i1_num_ref_idx_l0_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l0_active , 0 , MAX_DPB_SIZE - 1 ) ;ps_slice_hdr -> i1_num_ref_idx_l1_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l1_active , 0 , MAX_DPB_SIZE - 1 ) ;if ( 0 == num_poc_total_curr ) return IHEVCD_IGNORE_SLICE ;if ( ( ps_pps -> i1_lists_modification_present_flag ) && ( num_poc_total_curr > 1 ) ) {ihevcd_ref_pic_list_modification ( ps_bitstrm , ps_slice_hdr , num_poc_total_curr ) ;}else {ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 = 0 ;ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 = 0 ;}if ( BSLICE == ps_slice_hdr -> i1_slice_type ) {BITS_PARSE ( ""mvd_l1_zero_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_mvd_l1_zero_flag = value ;}ps_slice_hdr -> i1_cabac_init_flag = 0 ;if ( ps_pps -> i1_cabac_init_present_flag ) {BITS_PARSE ( ""cabac_init_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_cabac_init_flag = value ;}ps_slice_hdr -> i1_collocated_from_l0_flag = 1 ;ps_slice_hdr -> i1_collocated_ref_idx = 0 ;if ( ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag ) {if ( BSLICE == ps_slice_hdr -> i1_slice_type ) {BITS_PARSE ( ""collocated_from_l0_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_collocated_from_l0_flag = value ;}if ( ( ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l0_active > 1 ) ) || ( ! ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l1_active > 1 ) ) ) {UEV_PARSE ( ""collocated_ref_idx"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_collocated_ref_idx = value ;}}ps_slice_hdr -> i1_collocated_ref_idx = CLIP3 ( ps_slice_hdr -> i1_collocated_ref_idx , 0 , MAX_DPB_SIZE - 1 ) ;if ( ( ps_pps -> i1_weighted_pred_flag && ( PSLICE == ps_slice_hdr -> i1_slice_type ) ) || ( ps_pps -> i1_weighted_bipred_flag && ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) ) {ihevcd_parse_pred_wt_ofst ( ps_bitstrm , ps_sps , ps_pps , ps_slice_hdr ) ;}UEV_PARSE ( ""five_minus_max_num_merge_cand"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_max_num_merge_cand = 5 - value ;}ps_slice_hdr -> i1_max_num_merge_cand = CLIP3 ( ps_slice_hdr -> i1_max_num_merge_cand , 1 , 5 ) ;SEV_PARSE ( ""slice_qp_delta"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_slice_qp_delta = value ;if ( ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag ) {SEV_PARSE ( ""slice_cb_qp_offset"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_slice_cb_qp_offset = value ;SEV_PARSE ( ""slice_cr_qp_offset"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_slice_cr_qp_offset = value ;}ps_slice_hdr -> i1_deblocking_filter_override_flag = 0 ;ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ;ps_slice_hdr -> i1_beta_offset_div2 = ps_pps -> i1_beta_offset_div2 ;ps_slice_hdr -> i1_tc_offset_div2 = ps_pps -> i1_tc_offset_div2 ;disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ;if ( ps_pps -> i1_deblocking_filter_control_present_flag ) {if ( ps_pps -> i1_deblocking_filter_override_enabled_flag ) {BITS_PARSE ( ""deblocking_filter_override_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_deblocking_filter_override_flag = value ;}if ( ps_slice_hdr -> i1_deblocking_filter_override_flag ) {BITS_PARSE ( ""slice_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = value ;disable_deblocking_filter_flag = ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ;if ( ! ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) {SEV_PARSE ( ""beta_offset_div2"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_beta_offset_div2 = value ;SEV_PARSE ( ""tc_offset_div2"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_tc_offset_div2 = value ;}}}ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = ps_pps -> i1_loop_filter_across_slices_enabled_flag ;if ( ps_pps -> i1_loop_filter_across_slices_enabled_flag && ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag || ! disable_deblocking_filter_flag ) ) {BITS_PARSE ( ""slice_loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ;ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = value ;}}if ( ( ! first_slice_in_pic_flag ) && ( ps_codec -> i4_pic_present ) ) {slice_header_t * ps_slice_hdr_base = ps_codec -> ps_slice_hdr_base ;if ( ( ps_slice_hdr_base -> i1_pps_id != ps_slice_hdr -> i1_pps_id ) || ( ps_slice_hdr_base -> i4_pic_order_cnt_lsb != ps_slice_hdr -> i4_pic_order_cnt_lsb ) ) {return IHEVCD_IGNORE_SLICE ;}}if ( 0 == ps_codec -> i4_pic_present ) {ps_slice_hdr -> i4_abs_pic_order_cnt = ihevcd_calc_poc ( ps_codec , ps_nal , ps_sps -> i1_log2_max_pic_order_cnt_lsb , ps_slice_hdr -> i4_pic_order_cnt_lsb ) ;}else {ps_slice_hdr -> i4_abs_pic_order_cnt = ps_codec -> s_parse . i4_abs_pic_order_cnt ;}if ( ! first_slice_in_pic_flag ) {if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) {if ( slice_address > ps_codec -> s_parse . i4_next_ctb_indx ) {if ( ps_codec -> i4_pic_present ) {slice_header_t * ps_slice_hdr_next ;ps_codec -> i4_slice_error = 1 ;ps_codec -> s_parse . i4_cur_slice_idx -- ;if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ;ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ;ps_slice_hdr_next -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ;ps_slice_hdr_next -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ;return ret ;}else {return IHEVCD_IGNORE_SLICE ;}}else if ( slice_address < ps_codec -> s_parse . i4_next_ctb_indx ) {return IHEVCD_IGNORE_SLICE ;}else {ps_codec -> i4_slice_error = 0 ;}}else {if ( ps_codec -> i4_pic_present ) {slice_header_t * ps_slice_hdr_next ;ps_codec -> i4_slice_error = 1 ;ps_codec -> s_parse . i4_cur_slice_idx -- ;if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ;ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ;ps_slice_hdr_next -> i2_ctb_x = 0 ;ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ;return ret ;}else {if ( ps_slice_hdr -> i1_dependent_slice_flag ) return IHEVCD_IGNORE_SLICE ;ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ;}}}else {if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) return IHEVCD_IGNORE_SLICE ;ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ;}ps_slice_hdr -> i4_num_entry_point_offsets = 0 ;if ( ( ps_pps -> i1_tiles_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) {UEV_PARSE ( ""num_entry_point_offsets"" , value , ps_bitstrm ) ;ps_slice_hdr -> i4_num_entry_point_offsets = value ;{WORD32 max_num_entry_point_offsets ;if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) {max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ;}else if ( ps_pps -> i1_tiles_enabled_flag ) {max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ps_pps -> i1_num_tile_rows ;}else {max_num_entry_point_offsets = ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ;}ps_slice_hdr -> i4_num_entry_point_offsets = CLIP3 ( ps_slice_hdr -> i4_num_entry_point_offsets , 0 , max_num_entry_point_offsets ) ;}if ( ps_slice_hdr -> i4_num_entry_point_offsets > 0 ) {UEV_PARSE ( ""offset_len_minus1"" , value , ps_bitstrm ) ;ps_slice_hdr -> i1_offset_len = value + 1 ;for ( i = 0 ;i < ps_slice_hdr -> i4_num_entry_point_offsets ;i ++ ) {BITS_PARSE ( ""entry_point_offset"" , value , ps_bitstrm , ps_slice_hdr -> i1_offset_len ) ;}}}if ( ps_pps -> i1_slice_header_extension_present_flag ) {UEV_PARSE ( ""slice_header_extension_length"" , value , ps_bitstrm ) ;ps_slice_hdr -> i2_slice_header_extension_length = value ;for ( i = 0 ;i < ps_slice_hdr -> i2_slice_header_extension_length ;i ++ ) {BITS_PARSE ( ""slice_header_extension_data_byte"" , value , ps_bitstrm , 8 ) ;}}ihevcd_bits_flush_to_byte_boundary ( ps_bitstrm ) ;if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) return IHEVCD_INVALID_PARAMETER ;{dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ;WORD32 r_idx ;if ( ( NAL_IDR_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_IDR_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_DLP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( 0 == ps_codec -> u4_pic_cnt ) ) {for ( i = 0 ;i < MAX_DPB_BUFS ;i ++ ) {if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) {pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ;mv_buf_t * ps_mv_buf ;ihevc_dpb_mgr_del_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ;ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ;for ( j = 0 ;j < ps_codec -> i4_max_dpb_size ;j ++ ) {if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , j , BUF_MGR_REF ) ;break ;}ps_mv_buf ++ ;}}}for ( r_idx = 0 ;r_idx < MAX_DPB_SIZE ;r_idx ++ ) {ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = NULL ;ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = NULL ;ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = NULL ;ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = NULL ;}}else {ret = ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ;if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) {return ret ;}}}if ( ps_codec -> i4_pic_present ) {pic_buf_t * ps_pic_buf_ref ;mv_buf_t * ps_mv_buf_ref ;WORD32 r_idx ;dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ;buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ;ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ps_slice_hdr -> i4_abs_pic_order_cnt ) ;if ( NULL == ps_pic_buf_ref ) {ps_pic_buf_ref = ps_codec -> as_process [ 0 ] . ps_cur_pic ;ps_mv_buf_ref = ps_codec -> s_parse . ps_cur_mv_buf ;}else {ps_mv_buf_ref = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf_ref -> i4_abs_poc ) ;}for ( r_idx = 0 ;r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ;r_idx ++ ) {if ( NULL == ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ) {ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ;ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ;}}for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l0_active ;r_idx < MAX_DPB_SIZE ;r_idx ++ ) {ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ;ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ;}for ( r_idx = 0 ;r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ;r_idx ++ ) {if ( NULL == ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ) {ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ;ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ;}}for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l1_active ;r_idx < MAX_DPB_SIZE ;r_idx ++ ) {ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ;ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ;}}if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) {ps_slice_hdr -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ;ps_slice_hdr -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ;if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) {ps_slice_hdr -> i2_independent_ctb_x = ps_slice_hdr -> i2_ctb_x ;ps_slice_hdr -> i2_independent_ctb_y = ps_slice_hdr -> i2_ctb_y ;}}else {ps_slice_hdr -> i2_ctb_x = 0 ;ps_slice_hdr -> i2_ctb_y = 0 ;ps_slice_hdr -> i2_independent_ctb_x = 0 ;ps_slice_hdr -> i2_independent_ctb_y = 0 ;}if ( ( ! first_slice_in_pic_flag ) && ( 0 == ps_codec -> i4_pic_present ) ) {slice_header_t * ps_slice_hdr_prev = ps_codec -> s_parse . ps_slice_hdr_base ;ihevcd_copy_slice_hdr ( ps_codec , 0 , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ;ps_codec -> i4_slice_error = 1 ;ps_slice_hdr_prev -> i2_ctb_x = 0 ;",prev_slice_incomplete_flag = 1 ;ASSERT ( ps_codec -> s_parse . i4_cur_slice_idx == 1 ) ;ps_slice_hdr_prev -> i2_ctb_x = 0 ;,345
1684,"
",if ( prev_slice_incomplete_flag ) {ps_codec -> i4_slice_error = 1 ;ps_codec -> s_parse . i4_cur_slice_idx -- ;if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ;},345
1685,return ret ;},return ret ;},345
1686,"eprintf ( ""Can\\\'t<S2SV_blank>find<S2SV_blank>debug<S2SV_blank>filename\\\return 1 ;","eprintf ( ""Can\\\'t<S2SV_blank>find<S2SV_blank>debug<S2SV_blank>filename\\\return 1 ;}if ( ! is_valid_guid ( info -> guid ) ) {eprintf ( ""Invalid<S2SV_blank>GUID<S2SV_blank>for<S2SV_blank>file\\\return 1 ;",346
1687,"if ( msg -> msg_name && msg -> msg_namelen > 0 )  memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , sizeof ( call -> conn -> trans -> peer -> srx ) ) ;","if ( msg -> msg_name ) {size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ;memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ;msg -> msg_namelen = len ;}",347
1688,"virCheckDomainReturn ( dom , - 1 ) ;if ( dom -> conn -> driver -> domainGetTime ) {","virCheckDomainReturn ( dom , - 1 ) ;virCheckReadOnlyGoto ( dom -> conn -> flags , error ) ;if ( dom -> conn -> driver -> domainGetTime ) {",348
1689,"struct mount * n , * p ;for ( n = m ;if ( p == dest_master || IS_MNT_MARKED ( p ) ) {while ( last_dest -> mnt_master != p ) {last_source = last_source -> mnt_master ;last_dest = last_source -> mnt_parent ;if ( ! peers ( n , last_dest ) ) {last_dest = last_source -> mnt_parent ;}break ;}","struct mount * n , * p ;bool done ;for ( n = m ;if ( p == dest_master || IS_MNT_MARKED ( p ) ) break ;do {struct mount * parent = last_source -> mnt_parent ;if ( last_source == first_source ) break ;done = parent -> mnt_master == p ;if ( done && peers ( n , parent ) ) break ;while ( ! done ) ;",349
1690,"disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;","disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || IS_MNT_LOCKED_AND_LAZY ( p ) ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;",350
1691,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\return - EINVAL ;}err = check_entry ( e ) ;if ( err ) return err ;for ( h = 0 ;h < NF_INET_NUMHOOKS ;h ++ ) {if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ;if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ;if ( ( unsigned char * ) e - base == underflows [ h ] ) {if ( ! check_underflow ( e ) ) {pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>""  ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\","pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\\",351
1692,"static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel )  {assign_eip_near ( ctxt , ctxt -> _eip + rel ) ;}","static inline int jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) {return assign_eip_near ( ctxt , ctxt -> _eip + rel ) ;}",352
1693,"struct ext4_extent * ex , newex , orig_ex ;struct ext4_extent * ex1 = NULL ;struct ext4_extent * ex2 = NULL ;struct ext4_extent * ex3 = NULL ;struct ext4_extent_header * eh ;ext4_fsblk_t newblock ;int err = 0 ;int ret = 0 ;int may_zeroout ;eh = path [ depth ] . p_hdr ;ex = path [ depth ] . p_ext ;newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ;ex2 = ex ;orig_ex . ee_block = ex -> ee_block ;orig_ex . ee_len = cpu_to_le16 ( ee_len ) ;ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ;may_zeroout = ee_block + ee_len <= eof_block ;err = ext4_ext_get_access ( handle , inode , path + depth ) ;if ( ee_len <= 2 * EXT4_EXT_ZERO_LEN && may_zeroout ) {err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err )  goto fix_extent_len ;ex -> ee_block = orig_ex . ee_block ;return allocated ;}","struct ext4_map_blocks split_map ;struct ext4_extent zero_ex ;struct ext4_extent * ex1 = NULL ;struct ext4_extent * ex ;ext4_fsblk_t newblock ;int err = 0 ;int split_flag = 0 ;ex = path [ depth ] . p_ext ;WARN_ON ( map -> m_lblk < ee_block ) ;split_flag |= ee_block + ee_len <= eof_block ;err = ext4_ext_get_access ( handle , inode , path + depth ) ;if ( ee_len <= 2 * EXT4_EXT_ZERO_LEN && may_zeroout ) {err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;ex -> ee_block = orig_ex . ee_block ;return allocated ;}",353
1694,"if ( allocated <= EXT4_EXT_ZERO_LEN && may_zeroout ) {ex -> ee_block = orig_ex . ee_block ;ex -> ee_len = cpu_to_le16 ( ee_len - allocated ) ;ext4_ext_mark_uninitialized ( ex ) ;ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ;ext4_ext_dirty ( handle , inode , path + depth ) ;err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err )  goto fix_extent_len ;ex -> ee_block = orig_ex . ee_block ;}else if ( err )  goto fix_extent_len ;err = ext4_ext_zeroout ( inode , ex3 ) ;if ( err ) {","if ( allocated <= EXT4_EXT_ZERO_LEN && may_zeroout ) {ex -> ee_block = orig_ex . ee_block ;ex -> ee_len = cpu_to_le16 ( ee_len - allocated ) ;ext4_ext_mark_uninitialized ( ex ) ;ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ;ext4_ext_dirty ( handle , inode , path + depth ) ;err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;ex -> ee_block = orig_ex . ee_block ;}else if ( err ) goto fix_extent_len ;err = ext4_ext_zeroout ( inode , ex3 ) ;if ( err ) {",353
1695,"may_zeroout = ee_block + ee_len <= eof_block ;depth = newdepth ;ext4_ext_drop_refs ( path ) ;path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ;eh = path [ depth ] . p_hdr ;ex = path [ depth ] . p_ext ;err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;ex -> ee_block = orig_ex . ee_block ;ex -> ee_len = orig_ex . ee_len ;ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ;ext4_ext_dirty ( handle , inode , path + depth ) ;ex1 -> ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ;ext4_ext_mark_uninitialized ( ex1 ) ;ex2 = & newex ;}ex2 -> ee_block = cpu_to_le32 ( map -> m_lblk ) ;","may_zeroout = ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ;eh = path [ depth ] . p_hdr ;ex = path [ depth ] . p_ext ;err = ext4_ext_zeroout ( inode , ex ) ;if ( err ) goto out ;err = ext4_ext_get_access ( handle , inode , path + depth ) ;if ( err ) goto out ;ext4_ext_mark_initialized ( ex ) ;ext4_ext_try_to_merge ( inode , path , ex ) ;err = ext4_ext_dirty ( handle , inode , path + depth ) ;ex1 -> ee_len = cpu_to_le16 ( allocated - map -> m_len ) ;",353
1696,"if ( err == - ENOSPC && may_zeroout ) {err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;ex -> ee_block = orig_ex . ee_block ;ex -> ee_len = orig_ex . ee_len ;ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ;ext4_ext_dirty ( handle , inode , path + depth ) ;return allocated ;out :  ext4_ext_show_leaf ( inode , path ) ;return err ? err : allocated ;fix_extent_len : ex -> ee_block = orig_ex . ee_block ;ex -> ee_len = orig_ex . ee_len ;ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ;ext4_ext_mark_uninitialized ( ex ) ;ext4_ext_dirty ( handle , inode , path + depth ) ;return err ;","if ( err == - ENOSPC && may_zeroout ) {err = ext4_ext_zeroout ( inode , & zero_ex ) ;if ( err ) goto out ;split_map . m_lblk = map -> m_lblk ;split_map . m_len = allocated ;out : ext4_ext_show_leaf ( inode , path ) ;return err ? err : allocated ;",353
1697,"# endif  return parsetok ( tok , g , start , err_ret , flags ) ;}","# endif if ( * flags & PyPARSE_ASYNC_ALWAYS ) tok -> async_always = 1 ;return parsetok ( tok , g , start , err_ret , flags ) ;}",354
1698,"
","if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) {av_log ( NULL , AV_LOG_ERROR , ""RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\\ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ;prev_pkt [ channel_id ] . read = 0 ;}",355
1699,"if ( ! prev_pkt [ channel_id ] . read ) {if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ;","if ( ! prev_pkt [ channel_id ] . read ) {if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ;",355
1700,"static VALUE read_memory ( VALUE klass , VALUE content )  {xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt ( ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content )  ) ;xmlRelaxNGPtr schema ;VALUE errors = rb_ary_new ( ) ;VALUE rb_schema ;","static VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) {VALUE content ;VALUE parse_options ;xmlRelaxNGParserCtxtPtr ctx ;xmlRelaxNGPtr schema ;VALUE errors ;VALUE rb_schema ;int scanned_args = 0 ;scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ;if ( scanned_args == 1 ) {parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ;}ctx = xmlRelaxNGNewMemParserCtxt ( ( const char * ) StringValuePtr ( content ) ) ;errors = rb_ary_new ( ) ;VALUE rb_schema ;rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;",356
1701,return rb_schema ;},return rb_schema ;},356
1702,case '+' :  case '@' : case '!' : if ( * string == '(' ) return ( 1 ) ;else if ( * string == 0 )  return ( 0 ) ;,case '/' : if ( open ) open = 0 ;case '+' : case '@' : case '!' : if ( * string == '(' ) return ( 1 ) ;else if ( open && * string == '/' ) {string ++ ;continue ;}else if ( * string == 0 ) return ( 0 ) ;,357
1703,"memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ;rate_len = rate_ie -> len ;if ( rate_ie )   memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ;return ;","if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ;memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ;rate_len = rate_ie -> len ;if ( rate_ie ) {if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ;memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ;}return ;",358
1704,"
",hdr -> sadb_msg_reserved = 0 ;,359
1705,"pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;","pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;",359
1706,"enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , MICMD_MIIRD ) ;usleep ( 100 ) ;while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 )   {}enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , 0x00 ) ;return enc624j600ReadReg ( interface , ENC624J600_REG_MIRD ) ;}","uint16_t status ;enc624j600WriteReg ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT | address ) ;enc624j600WriteReg ( interface , ENC624J600_MICMD , ENC624J600_MICMD_MIIRD ) ;usleep ( 100 ) ;do {status = enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) ;enc624j600WriteReg ( interface , ENC624J600_REG_MICMD , 0x00 ) ;return enc624j600ReadReg ( interface , ENC624J600_MIRD ) ;}",360
1707,"( * respond ) ( arg , 0 , NULL , NULL , NULL ) ;return ;","( * respond ) ( arg , EINVAL , NULL , NULL , NULL ) ;return ;",361
1708,"( * respond ) ( arg , 0 , NULL , NULL , NULL ) ;return ;","( * respond ) ( arg , 0 , NULL , NULL , NULL ) ;return ;",361
1709,"static u32 ip6_proxy_idents_hashrnd __read_mostly ;struct in6_addr buf [ 2 ] ;net_get_random_once ( & ip6_proxy_idents_hashrnd ,  sizeof ( ip6_proxy_idents_hashrnd ) ) ;id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd ,  & addrs [ 1 ] , & addrs [ 0 ] ) ;","struct in6_addr buf [ 2 ] ;id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , & addrs [ 1 ] , & addrs [ 0 ] ) ;",362
1710,"int64_t time , offset ;if ( version == 1 ) {","int64_t time , offset ;if ( avio_feof ( f ) ) {index -> item_count = 0 ;av_freep ( & index -> items ) ;return AVERROR_INVALIDDATA ;}if ( version == 1 ) {",363
1711,dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;random_ether_addr ( dev -> dev_addr ) ;,dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;random_ether_addr ( dev -> dev_addr ) ;,364
1712,"opj_write_bytes ( p_data , J2K_MS_SOD ,  2 ) ;","if ( p_total_data_size < 4 ) {opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\\return OPJ_FALSE ;}opj_write_bytes ( p_data , J2K_MS_SOD , 2 ) ;",365
1713,"perror ( ""malloc<S2SV_blank>(ret)"" ) ;return NULL ;if ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) {image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ;dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ;liboff = image_infos [ idx ] . address - dyld_vmbase ;if ( image_infos [ idx ] . pathFileOffset > bin -> size ) {eprintf ( ""corrupted<S2SV_blank>file\\\free ( ret ) ;libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ;data = bin -> b -> buf + liboff ;","return NULL ;int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ;image_infos = malloc ( sz ) ;if ( ! image_infos ) {free ( ret ) ;return NULL ;}r_buf_read_at ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) {image_infos = ( struct dyld_cache_image_info * ) ( bin -> b , bin -> hdr . startaddr , ( ut8 * ) image_infos , sz ) ;dyld_vmbase = r_buf_read64le ( bin -> b -> buf + bin -> hdr . baseaddroff ) ;liboff = image_infos [ idx ] . address - dyld_vmbase ;int pfo = image_infos [ idx ] . pathFileOffset ;if ( pfo < 0 || pfo > bin -> size ) {eprintf ( ""corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\\free ( ret ) ;libname = r_buf_read_string ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ;data = bin -> b -> buf + liboff ;",366
1714,"pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns ,  4 * sizeof ( * pixels ) ) ;","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ;",367
1715,"int length ;STREAM s ;RD_BOOL is_fastpath ;ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ;ber_parse_header ( s , BER_TAG_RESULT , & length ) ;","uint32 length ;STREAM s ;struct stream packet ;RD_BOOL is_fastpath ;packet = * s ;ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}ber_parse_header ( s , BER_TAG_RESULT , & length ) ;",368
1716,"mcs_parse_domain_params ( s ) ;ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ;","mcs_parse_domain_params ( s ) ;ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ;",368
1717,e . ifindex = port -> dev -> ifindex ;e . state = p -> state ;,"memset ( & e , 0 , sizeof ( e ) ) ;e . ifindex = port -> dev -> ifindex ;e . state = p -> state ;",369
1718,if ( * length < 2 ) return ( ( unsigned short ) ~ 0 ) ;for ( i = 0 ;i < 2 ;i ++ ) {c = ( int ) ( * ( * p ) ++ ) ;( * length ) -- ;buffer [ i ] = ( unsigned char ) c ;}value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ;value |= buffer [ 1 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,if ( * length < 2 ) return ( ( unsigned short ) buffer [ 0 ] << 8 ) ;value |= ( unsigned short ) buffer [ 1 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,370
1719,"enc28j60WriteReg ( interface , ENC28J60_REG_EHT0 , hashTable [ 0 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT1 , hashTable [ 1 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT2 , hashTable [ 2 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT3 , hashTable [ 3 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT4 , hashTable [ 4 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT5 , hashTable [ 5 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT6 , hashTable [ 6 ] ) ;enc28j60WriteReg ( interface , ENC28J60_REG_EHT7 , hashTable [ 7 ] ) ;TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\return NO_ERROR ;","enc28j60WriteReg ( interface , ENC28J60_EHT0 , hashTable [ 0 ] ) ;enc28j60WriteReg ( interface , ENC28J60_EHT1 , hashTable [ 1 ] ) ;enc28j60WriteReg ( interface , ENC28J60_EHT2 , hashTable [ 2 ] ) ;enc28j60WriteReg ( interface , ENC28J60_EHT3 , hashTable [ 3 ] ) ;enc28j60WriteReg ( interface , ENC28J60_EHT4 , hashTable [ 4 ] ) ;enc28j60WriteReg ( interface , ENC28J60_EHT5 , hashTable [ 5 ] ) ;enc28j60WriteReg ( interface , ENC28J60_EHT6 , hashTable [ 6 ] ) ;enc28j60WriteReg ( interface , ENC28J60_EHT7 , hashTable [ 7 ] ) ;TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT0<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%02"" PRIX8 ""\\\\r\\\return NO_ERROR ;",371
1720,"char * sockaddr_url , * stratum_port , * tmp ;char * url , * port , address [ 256 ] ;if ( opt_disable_client_reconnect ) {applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>forbidden,<S2SV_blank>aborting."" ) ;memset ( address , 0 , 255 ) ;url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ;if ( ! url ) url = pool -> sockaddr_url ;sprintf ( address , ""%s:%s"" , url , port ) ;if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ;","if ( opt_disable_client_reconnect ) {applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting."" ) ;char * url , * port , address [ 256 ] ;char * sockaddr_url , * stratum_port , * tmp ;url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ;if ( ! url ) url = pool -> sockaddr_url ;sprintf ( address , ""%s:%s"" , url , port ) ;if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ;",372
1721,goto out ;},goto out2 ;},373
1722,"
",if ( total_subobj_len < 4 ) goto invalid ;,374
1723,subobj_len = EXTRACT_16BITS ( obj_tptr ) ;subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ;if ( subobj_len == 0 )  goto invalid ;,subobj_len = EXTRACT_16BITS ( obj_tptr ) ;subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ;if ( subobj_len < 4 || subobj_len > total_subobj_len ) goto invalid ;,374
1724,# define REMAIN ( buf -> length - ( ptr - bufstart ) )  if ( REMAIN > INT_MAX )  return GSS_S_DEFECTIVE_TOKEN ;,# define REMAIN ( buf -> length - ( ptr - bufstart ) ) if ( REMAIN == 0 || REMAIN > INT_MAX ) return GSS_S_DEFECTIVE_TOKEN ;,375
1725,"if ( disk != NULL ) {const int blocksize = 512 ;int ret ;if ( bio ) iob = bio ;ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) ,   ( ut8 * ) buf , size * blocksize ) ;if ( ret == - 1 )  return 1 ;}return 0 ;","if ( ! disk ) {eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\\return 1 ;}const int blocksize = 512 ;if ( bio ) {iob = bio ;}if ( iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , ( ut8 * ) buf , size * blocksize ) == - 1 ) {return 1 ;}return 0 ;",376
1726,"sas_unregister_dev ( port , dev ) ;continue ;","sas_unregister_dev ( port , dev ) ;sas_destruct_devices ( port ) ;continue ;",377
1727,ps_dec -> u2_total_mbs_coded ++ ;u1_num_mbsNby2 ++ ;,u1_num_mbsNby2 ++ ;,378
1728,if ( u1_tfr_n_mb )  u1_num_mbs = 0 ;,ps_dec -> u2_total_mbs_coded += u1_num_mbs ;if ( u1_tfr_n_mb ) u1_num_mbs = 0 ;,378
1729,"buffer = malloc ( rect . r . w ) ;if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) {free ( buffer ) ;return FALSE ;}free ( buffer ) ;continue ;}if ( rect . encoding == rfbEncodingServerIdentity ) {char * buffer ;buffer = malloc ( rect . r . w + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) {free ( buffer ) ;return FALSE ;}buffer [ rect . r . w ] = 0 ;rfbClientLog ( ""Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\\\""%s\\\\""\\\free ( buffer ) ;continue ;}if ( rect . encoding != rfbEncodingUltraZip ) {if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) {rfbClientLog ( ""Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\\return FALSE ;}client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ;}switch ( rect . encoding ) {case rfbEncodingRaw : {int y = rect . r . y , h = rect . r . h ;bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ;linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ;while ( linesToRead && h > 0 ) {if ( linesToRead > h ) linesToRead = h ;if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ;client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ;h -= linesToRead ;y += linesToRead ;}break ;}case rfbEncodingCopyRect : {rfbCopyRect cr ;if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ;cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ;cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ;client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ;client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ;break ;}case rfbEncodingRRE : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}break ;}case rfbEncodingCoRRE : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}break ;}case rfbEncodingHextile : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}break ;}case rfbEncodingUltra : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}break ;}case rfbEncodingUltraZip : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}break ;}case rfbEncodingTRLE : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( client -> si . format . greenMax > 0x1F ) {if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}else {if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}break ;case 32 : {uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ;if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) {if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) {if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) {if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}}break ;}# ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}break ;}# ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}break ;}# endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ;case rfbEncodingZYWRLE : {switch ( client -> format . bitsPerPixel ) {case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;case 16 : if ( client -> si . format . greenMax > 0x1F ) {if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}else {if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}break ;case 32 : {uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ;if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) {if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) {if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) {if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;}else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ;break ;}}break ;}# endif default : {rfbBool handled = FALSE ;rfbClientProtocolExtension * e ;for ( e = rfbClientExtensions ;! handled && e ;e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ;if ( ! handled ) {rfbClientLog ( ""Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\\return FALSE ;}}}client -> SoftCursorUnlockScreen ( client ) ;client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ;}if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ;if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ;break ;}case rfbBell : {client -> Bell ( client ) ;break ;}case rfbServerCutText : {char * buffer ;if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ;msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ;buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) {","buffer = malloc ( msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ;buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) {",379
1730,"if ( obj == Py_None ) {* out = NULL ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) TypeIgnore_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & lineno , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( lookup_attr_id ( obj , ( PyObject * ) TypeIgnore_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_lineno , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""lineno\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>TypeIgnore"" ) ;return 1 ;}else {int res ;res = obj2ast_int ( tmp , & lineno , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}* out = TypeIgnore ( lineno , arena ) ;if ( * out == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",380
1731,"printf ( ""Using<S2SV_blank>%s\\\if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder"" ) ;","printf ( ""Using<S2SV_blank>%s\\\if ( vpx_codec_dec_init ( & codec , decoder -> codec_interface ( ) , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder"" ) ;",381
1732,"static vpx_codec_err_t ctrl_set_postproc ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {# if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ;","static vpx_codec_err_t ctrl_set_postproc ( vpx_codec_alg_priv_t * ctx , va_list args ) {# if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ;",382
1733,# else  return VPX_CODEC_INCAPABLE ;# endif },# else ( void ) ctx ;( void ) args ;return VPX_CODEC_INCAPABLE ;# endif },382
1734,ACPI_FUNCTION_TRACE ( NsTerminate ) ;# ifdef ACPI_EXEC_APP {ACPI_OPERAND_OBJECT * Next ;Next = AcpiGbl_ModuleCodeList ;}# endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ;,ACPI_OPERAND_OBJECT * Next ;ACPI_FUNCTION_TRACE ( NsTerminate ) ;Next = AcpiGbl_ModuleCodeList ;AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ;,383
1735,uint_t i ;size_t paddingSize ;if ( ( segment -> dataOffset * 4 + length ) > TCP_MAX_HEADER_LENGTH )  return ERROR_FAILURE ;i = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ;paddingSize = ( length % 4 ) ? 4 - ( length % 4 ) : 0 ;while ( paddingSize -- )  segment -> options [ i ++ ] = TCP_OPTION_NOP ;option = ( TcpOption * ) ( segment -> options + i ) ;option -> kind = kind ;return NO_ERROR ;},error_t error ;size_t i ;size_t paddingSize ;if ( ( segment -> dataOffset * 4 + length ) <= TCP_MAX_HEADER_LENGTH ) {i = ( segment -> dataOffset * 4 ) - sizeof ( TcpHeader ) ;paddingSize = ( length % 4 ) ? 4 - ( length % 4 ) : 0 ;while ( paddingSize -- ) {segment -> options [ i ++ ] = TCP_OPTION_NOP ;}option = ( TcpOption * ) ( segment -> options + i ) ;option -> kind = kind ;error = NO_ERROR ;}else {error = ERROR_FAILURE ;}return error ;},384
1736,"return crypto_skcipher_setkey ( private , key , keylen ) ;}","struct skcipher_tfm * tfm = private ;int err ;err = crypto_skcipher_setkey ( tfm -> skcipher , key , keylen ) ;tfm -> has_key = ! err ;return err ;}",385
1737,# ifdef FEAT_TERMINAL  if ( bt_terminal ( wp -> w_buffer ) )  redraw_mode = TRUE ;,# ifdef FEAT_TERMINAL if ( bt_terminal ( curwin -> w_buffer ) ) redraw_mode = TRUE ;,386
1738,for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ;,for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ;,387
1739,struct twopass_rc * const twopass = & cpi -> twopass ;const FIRSTPASS_STATS first_frame = * this_frame ;const FIRSTPASS_STATS * start_position = twopass -> stats_in ;FIRSTPASS_STATS next_frame ;double decay_accumulator = 1.0 ;double zero_motion_accumulator = 1.0 ;,TWO_PASS * const twopass = & cpi -> twopass ;GF_GROUP * const gf_group = & twopass -> gf_group ;const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;const FIRSTPASS_STATS first_frame = * this_frame ;const FIRSTPASS_STATS * const start_position = twopass -> stats_in ;FIRSTPASS_STATS next_frame ;int kf_bits = 0 ;int loop_decay_counter = 0 ;double decay_accumulator = 1.0 ;double av_decay_accumulator = 0.0 ;double zero_motion_accumulator = 1.0 ;,388
1740,"rc -> this_key_frame_forced = rc -> next_key_frame_forced ;rc -> source_alt_ref_active = 0 ;rc -> frames_till_gf_update_due = 0 ;rc -> frames_to_key = 1 ;kf_mod_err = calculate_modified_err ( cpi , this_frame ) ;i = 0 ;while ( twopass -> stats_in < twopass -> stats_in_end ) {kf_group_err += calculate_modified_err ( cpi , this_frame ) ;last_frame = * this_frame ;if ( cpi -> oxcf . auto_key &&  lookup_next_frame_stats ( twopass , & next_frame ) != EOF ) {double loop_decay_rate ;if ( test_candidate_kf ( twopass , & last_frame , this_frame , & next_frame ) )  break ;loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ;recent_loop_decay [ i % 8 ] = loop_decay_rate ;if ( detect_transition_to_still ( twopass , i , cpi -> key_frame_frequency - i ,  loop_decay_rate , decay_accumulator ) ) break ;if ( rc -> frames_to_key >= 2 * ( int ) cpi -> key_frame_frequency )  break ;if ( cpi -> oxcf . auto_key &&  rc -> frames_to_key > ( int ) cpi -> key_frame_frequency ) {FIRSTPASS_STATS tmp_frame = first_frame ;kf_group_err = 0 ;for ( i = 0 ;kf_group_err += calculate_modified_err ( cpi , & tmp_frame ) ;input_stats ( twopass , & tmp_frame ) ;}else if ( twopass -> stats_in == twopass -> stats_in_end ) {rc -> next_key_frame_forced = 1 ;if ( twopass -> stats_in >= twopass -> stats_in_end ) {kf_group_err += calculate_modified_err ( cpi , this_frame ) ;}","vp9_zero ( * gf_group ) ;rc -> this_key_frame_forced = rc -> next_key_frame_forced ;rc -> source_alt_ref_active = 0 ;cpi -> multi_arf_last_grp_enabled = 0 ;rc -> frames_till_gf_update_due = 0 ;rc -> frames_to_key = 1 ;kf_mod_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ;i = 0 ;while ( twopass -> stats_in < twopass -> stats_in_end && rc -> frames_to_key < cpi -> oxcf . key_freq ) {kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ;last_frame = * this_frame ;if ( cpi -> oxcf . auto_key && twopass -> stats_in < twopass -> stats_in_end ) {double loop_decay_rate ;if ( test_candidate_kf ( twopass , & last_frame , this_frame , twopass -> stats_in ) ) break ;loop_decay_rate = get_prediction_decay_rate ( cpi , twopass -> stats_in ) ;recent_loop_decay [ i % 8 ] = loop_decay_rate ;if ( detect_transition_to_still ( cpi , i , cpi -> key_frame_frequency - i , loop_decay_rate , decay_accumulator ) ) break ;if ( rc -> frames_to_key >= 2 * cpi -> oxcf . key_freq ) break ;if ( cpi -> oxcf . auto_key && rc -> frames_to_key > cpi -> oxcf . key_freq ) {FIRSTPASS_STATS tmp_frame = first_frame ;kf_group_err = 0.0 ;for ( i = 0 ;kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , & tmp_frame ) ;input_stats ( twopass , & tmp_frame ) ;}else if ( twopass -> stats_in == twopass -> stats_in_end || rc -> frames_to_key >= cpi -> oxcf . key_freq ) {rc -> next_key_frame_forced = 1 ;if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) {int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ;int new_frame_to_key = ( rc -> frames_to_key + count ) & ( ~ count ) ;int j ;for ( j = 0 ;j < new_frame_to_key - rc -> frames_to_key ;++ j ) {if ( EOF == input_stats ( twopass , this_frame ) ) break ;kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ;}rc -> frames_to_key = new_frame_to_key ;}if ( twopass -> stats_in >= twopass -> stats_in_end ) {kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ;}",388
1741,"reset_fpf_position ( twopass , start_position ) ;decay_accumulator = 1.0 ;for ( i = 0 ;i < rc -> frames_to_key ;if ( EOF == input_stats ( twopass , & next_frame ) ) break ;if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) <  zero_motion_accumulator ) {zero_motion_accumulator = ( next_frame . pcnt_inter - next_frame . pcnt_motion ) ;}if ( i <= ( rc -> max_gf_interval * 2 ) ) {double r ;const double loop_decay_rate = get_prediction_decay_rate ( & cpi -> common ,  & next_frame ) ;}boost_score += ( decay_accumulator * r ) ;}{FIRSTPASS_STATS sectionstats ;zero_stats ( & sectionstats ) ;for ( i = 0 ;input_stats ( twopass , & next_frame ) ;twopass -> section_intra_rating = ( int ) ( sectionstats . intra_error /  DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ;if ( 1 ) {int kf_boost = ( int ) boost_score ;int allocation_chunks ;if ( kf_boost < ( rc -> frames_to_key * 3 ) )  kf_boost = ( rc -> frames_to_key * 3 ) ;if ( kf_boost < MIN_KF_BOOST ) kf_boost = MIN_KF_BOOST ;rc -> kf_boost = kf_boost ;if ( zero_motion_accumulator >= 0.99 ) {allocation_chunks = ( ( rc -> frames_to_key - 1 ) * 10 ) + kf_boost ;}else {allocation_chunks = ( ( rc -> frames_to_key - 1 ) * 100 ) + kf_boost ;}if ( kf_boost > 1028 ) {const int divisor = kf_boost >> 10 ;kf_boost /= divisor ;allocation_chunks /= divisor ;}twopass -> kf_group_bits = MAX ( 0 , twopass -> kf_group_bits ) ;","twopass -> kf_group_bits = MAX ( 0 , twopass -> kf_group_bits ) ;reset_fpf_position ( twopass , start_position ) ;decay_accumulator = 1.0 ;for ( i = 0 ;i < ( rc -> frames_to_key - 1 ) ;if ( EOF == input_stats ( twopass , & next_frame ) ) break ;zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ;if ( ( i <= ( rc -> max_gf_interval * 2 ) ) {double r ;const double loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ;av_decay_accumulator += decay_accumulator ;++ loop_decay_counter ;}boost_score += ( decay_accumulator * frame_boost ) ;}av_decay_accumulator /= ( double ) loop_decay_counter ;for ( i = 0 ;input_stats ( twopass , & next_frame ) ;twopass -> section_intra_rating = ( int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ;",388
1742,"twopass -> kf_group_bits -= twopass -> kf_bits ;vp9_rc_set_frame_target ( cpi , twopass -> kf_bits ) ;}}",twopass -> kf_group_bits -= kf_bits ;gf_group -> bit_allocation [ 0 ] = kf_bits ;gf_group -> update_type [ 0 ] = KF_UPDATE ;gf_group -> rf_level [ 0 ] = KF_STD ;if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) {cpi -> rc . next_frame_size_selector = UNSCALED ;}},388
1743,"static inline bool unconditional ( const struct ip6t_ip6 * ipv6 )  {return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ;}","static inline bool unconditional ( const struct ip6t_entry * e ) {return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> ipv6 , & uncond , sizeof ( uncond ) ) == 0 ;}",389
1744,if ( i > ( sizeof ( outbuff ) - 20 ) ) {outbuff [ i ] = \'\\\\0\' ;,if ( i > ( sizeof ( outbuff ) - 128 ) ) {outbuff [ i ] = \'\\\\0\' ;,390
1745,"assert ( pow ( ( float ) r + 1 , dim ) > entries ) ;assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ;return r ;","if ( pow ( ( float ) r + 1 , dim ) <= entries ) return - 1 ;if ( ( int ) floor ( pow ( ( float ) r , dim ) ) > entries ) return - 1 ;return r ;",391
1746,"sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ;sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ;","sctp_add_cmd_sf ( commands , SCTP_CMD_SET_ASOC , SCTP_ASOC ( new_asoc ) ) ;sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ;",392
1747,"case TYPE_RDP_NEG_RSP :  nego_process_negotiation_response ( nego , s ) ;WLog_DBG ( TAG , ""selected_protocol:<S2SV_blank>%"" PRIu32 """" , nego -> SelectedProtocol ) ;","case TYPE_RDP_NEG_RSP : if ( ! nego_process_negotiation_response ( nego , s ) ) return - 1 ;WLog_DBG ( TAG , ""selected_protocol:<S2SV_blank>%"" PRIu32 """" , nego -> SelectedProtocol ) ;",393
1748,"case TYPE_RDP_NEG_FAILURE :  nego_process_negotiation_failure ( nego , s ) ;break ;","case TYPE_RDP_NEG_FAILURE : if ( ! nego_process_negotiation_failure ( nego , s ) ) return - 1 ;break ;",393
1749,"static void swap_block_ptr ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ,  int max_plane ) {struct macroblock_plane * const p = x -> plane ;struct macroblockd_plane * const pd = x -> e_mbd . plane ;int i ;for ( i = 0 ;p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ;p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ;pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ;p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ;ctx -> coeff_pbuf [ i ] [ 1 ] = ctx -> coeff_pbuf [ i ] [ 0 ] ;ctx -> qcoeff_pbuf [ i ] [ 1 ] = ctx -> qcoeff_pbuf [ i ] [ 0 ] ;ctx -> dqcoeff_pbuf [ i ] [ 1 ] = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ;ctx -> eobs_pbuf [ i ] [ 1 ] = ctx -> eobs_pbuf [ i ] [ 0 ] ;ctx -> coeff_pbuf [ i ] [ 0 ] = p [ i ] . coeff ;ctx -> qcoeff_pbuf [ i ] [ 0 ] = p [ i ] . qcoeff ;ctx -> dqcoeff_pbuf [ i ] [ 0 ] = pd [ i ] . dqcoeff ;ctx -> eobs_pbuf [ i ] [ 0 ] = p [ i ] . eobs ;}","static void swap_block_ptr ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int m , int n , int min_plane , int max_plane ) {int i ;for ( i = min_plane ;struct macroblock_plane * const p = & x -> plane [ i ] ;struct macroblockd_plane * const pd = & x -> e_mbd . plane [ i ] ;p -> coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ;p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ m ] ;pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ m ] ;p -> eobs = ctx -> eobs_pbuf [ i ] [ m ] ;ctx -> coeff_pbuf [ i ] [ m ] = ctx -> coeff_pbuf [ i ] [ n ] ;ctx -> qcoeff_pbuf [ i ] [ m ] = ctx -> qcoeff_pbuf [ i ] [ n ] ;ctx -> dqcoeff_pbuf [ i ] [ m ] = ctx -> dqcoeff_pbuf [ i ] [ n ] ;ctx -> eobs_pbuf [ i ] [ m ] = ctx -> eobs_pbuf [ i ] [ n ] ;ctx -> coeff_pbuf [ i ] [ n ] = p -> coeff ;ctx -> qcoeff_pbuf [ i ] [ n ] = p -> qcoeff ;ctx -> dqcoeff_pbuf [ i ] [ n ] = pd [ i ] . dqcoeff ;ctx -> eobs_pbuf [ i ] [ n ] = p -> eobs ;}",394
1750,"memset ( mp4 , 0 , sizeof ( mp4object ) ) ;# ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ;","struct stat64 mp4stat ;stat64 ( filename , & mp4stat ) ;mp4 -> filesize = mp4stat . st_size ;if ( mp4 -> filesize < 64 ) return 0 ;memset ( mp4 , 0 , sizeof ( mp4object ) ) ;# ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ;",395
1751,"if ( len == 8 )  {LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ;NESTSIZE ( lastsize - 8 ) ;continue ;fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ;qtsize = BYTESWAP64 ( qtsize ) - 8 ;","mp4 -> filepos += len ;if ( len == 8 && mp4 -> filepos < mp4 -> filesize ) {CloseSource ( ( size_t ) mp4 ) ;mp4 = NULL ;break ;len = fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ;mp4 -> filepos += len ;qtsize = BYTESWAP64 ( qtsize ) - 8 ;",395
1752,"if ( qttag == MAKEID ( \'m\' , \'d\' , \'a\' , \'t\' ) || qttag == MAKEID ( \'f\' , \'t\' , \'y\' , \'p\' ) ||  qttag == MAKEID ( \'u\' , \'d\' , \'t\' , \'a\' ) )  {LONGSEEK ( mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;# else if ( qttag != MAKEID ( \'m\' , \'o\' , \'o\' , \'v\' ) && qttag != MAKEID ( \'m\' , \'v\' , \'h\' , \'d\' ) && qttag != MAKEID ( \'t\' , \'r\' , \'a\' , \'k\' ) && qttag != MAKEID ( \'m\' , \'d\' , \'i\' , \'a\' ) && qttag != MAKEID ( \'m\' , \'d\' , \'h\' , \'d\' ) && qttag != MAKEID ( \'m\' , \'i\' , \'n\' , \'f\' ) && qttag != MAKEID ( \'g\' , \'m\' , \'i\' , \'n\' ) && qttag != MAKEID ( \'d\' , \'i\' , \'n\' , \'f\' ) && qttag != MAKEID ( \'a\' , \'l\' , \'i\' , \'s\' ) && qttag != MAKEID ( \'s\' , \'t\' , \'s\' , \'d\' ) &&  qttag != MAKEID ( \'a\' , \'l\' , \'i\' , \'s\' ) &&   qttag != MAKEID ( \'a\' , \'l\' , \'i\' , \'s\' ) &&   qttag != MAKEID ( \'s\' , \'t\' , \'b\' , \'l\' ) &&   qttag != MAKEID ( \'s\' , \'t\' , \'t\' , \'s\' ) &&   qttag != MAKEID ( \'s\' , \'t\' , \'s\' , \'c\' ) &&   qttag != MAKEID ( \'s\' , \'t\' , \'s\' , \'z\' ) &&   qttag != MAKEID ( \'s\' , \'t\' , \'c\' , \'o\' ) &&  qttag != MAKEID ( \'c\' , \'o\' , \'6\' , \'4\' ) && qttag != MAKEID ( \'h\' , \'d\' , \'l\' , \'r\' ) ) {LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;","if ( qttag == MAKEID ( \'m\' , \'d\' , \'a\' , \'t\' ) || qttag == MAKEID ( \'f\' , \'t\' , \'y\' , \'p\' ) || qttag == MAKEID ( \'u\' , \'d\' , \'t\' , \'a\' ) || qttag == MAKEID ( \'f\' , \'r\' , \'e\' , \'e\' ) ) {LongSeek ( mp4 , qtsize - 8 ) ;NESTSIZE ( qtsize ) ;# else if ( qttag != MAKEID ( \'s\' , \'t\' , \'b\' , \'l\' ) && qttag != MAKEID ( \'s\' , \'t\' , \'t\' , \'s\' ) && qttag != MAKEID ( \'s\' , \'t\' , \'s\' , \'d\' ) && qttag != MAKEID ( \'a\' , \'l\' , \'i\' , \'s\' ) && qttag != MAKEID ( \'a\' , \'l\' , \'i\' , \'s\' ) && qttag != MAKEID ( \'s\' , \'t\' , \'b\' , \'l\' ) && qttag != MAKEID ( \'s\' , \'t\' , \'t\' , \'s\' ) && qttag != MAKEID ( \'s\' , \'t\' , \'s\' , \'c\' ) && qttag != MAKEID ( \'s\' , \'t\' , \'s\' , \'z\' ) && qttag != MAKEID ( \'s\' , \'t\' , \'s\' , \'c\' ) && qttag != MAKEID ( \'c\' , \'o\' , \'6\' , \'4\' ) && qttag != MAKEID ( \'h\' , \'d\' , \'l\' , \'r\' ) ) {LongSeek ( mp4 , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;",395
1753,"LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;","LONGSEEK ( mp4 -> mediafp , qtsize - 8 ) ;NESTSIZE ( qtsize ) ;",395
1754,"LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;if ( temp != MAKEID ( \'a\' , \'l\' , \'i\' , \'s\' ) )  type = temp ;LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;","LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len ) ;NESTSIZE ( qtsize ) ;if ( temp != MAKEID ( \'a\' , \'l\' , \'i\' , \'s\' ) ) type = temp ;LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;",395
1755,"LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;}else  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;if ( num * 12 <= qtsize - 8 - len ) {mp4 -> metastsc_count = num ;if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ;mp4 -> metastsc = ( SampleToChunk * ) malloc ( num * 12 ) ;if ( mp4 -> metastsc ) {uint32_t total_stsc = num ;len += fread ( mp4 -> metastsc , 1 , num * sizeof ( SampleToChunk ) , mp4 -> mediafp ) ;do {num -- ;mp4 -> metastsc [ num ] . chunk_num = BYTESWAP32 ( mp4 -> metastsc [ num ] . chunk_num ) ;mp4 -> metastsc [ num ] . samples = BYTESWAP32 ( mp4 -> metastsc [ num ] . samples ) ;mp4 -> metastsc [ num ] . id = BYTESWAP32 ( mp4 -> metastsc [ num ] . id ) ;}while ( num > 0 ) ;}if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 )  {if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ;mp4 -> metastsc = NULL ;mp4 -> metastsc_count = 0 ;}}LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;}else  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;","mp4 -> filepos += len ;LongSeek ( mp4 , qtsize - 8 - len ) ;NESTSIZE ( qtsize ) ;if ( num * 12 <= qtsize - 8 - len ) ;NESTSIZE ( qtsize ) ;",395
1756,mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ;if ( mp4 -> metasizes ) {,mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ;if ( mp4 -> metasizes ) {,395
1757,"LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;}else  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;else if ( qttag == MAKEID ( \'s\' , \'t\' , \'c\' , \'o\' ) ) {if ( type == traktype ) {len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ;len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ;num = BYTESWAP32 ( num ) ;if ( num * 4 <= qtsize - 8 - len ) {if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count )  {mp4 -> indexcount = mp4 -> metasize_count ;if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ;mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ;if ( mp4 -> metaoffsets ) {uint32_t * metaoffsets32 = NULL ;metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ;if ( metaoffsets32 ) {uint64_t fileoffset = 0 ;int stsc_pos = 0 ;int stco_pos = 0 ;int repeat = 1 ;len += fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ;do {num -- ;metaoffsets32 [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ;while ( num > 0 ) ;mp4 -> metaoffsets [ 0 ] = fileoffset = metaoffsets32 [ stco_pos ] ;num = 1 ;while ( num < mp4 -> metasize_count )  {if ( stsc_pos + 1 < ( int ) mp4 -> metastsc_count && num == stsc_pos ) {stco_pos ++ ;stsc_pos ++ ;fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ;repeat = 1 ;}else if ( repeat == mp4 -> metastsc [ stsc_pos ] . samples ) {stco_pos ++ ;fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ;repeat = 1 ;}else {fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ;repeat ++ ;}mp4 -> metaoffsets [ num ] = fileoffset ;num ++ ;}if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ;mp4 -> metastsc = NULL ;mp4 -> metastsc_count = 0 ;free ( metaoffsets32 ) ;}}}else {mp4 -> indexcount = num ;if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ;mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ;if ( mp4 -> metaoffsets ) {uint32_t * metaoffsets32 = NULL ;metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ;if ( metaoffsets32 ) {size_t readlen = fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ;len += readlen ;do {num -- ;mp4 -> metaoffsets [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ;}while ( num > 0 ) ;free ( metaoffsets32 ) ;}}}}LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;}else  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;if ( num * 8 <= qtsize - 8 - len )  {if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ;mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ;","mp4 -> filepos += len ;LongSeek ( mp4 , qtsize - 8 - len ) ;else LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;else LongSeek ( mp4 , qtsize - 8 - len , SEEK_CUR ) ;else LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;if ( num * 8 <= qtsize - 8 - len ) {if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ;mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ;",395
1758,mp4 -> indexcount = num ;if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ;,mp4 -> indexcount = num ;if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ;,395
1759,"LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;}else  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;else if ( qttag == MAKEID ( \'s\' , \'t\' , \'t\' , \'s\' ) ) {if ( num * 8 <= qtsize - 8 - len ) {entries = num ;mp4 -> meta_clockdemon = mp4 -> trak_clockdemon ;mp4 -> meta_clockcount = mp4 -> trak_clockcount ;while ( entries > 0 ) {int32_t samplecount ;int32_t duration ;len += fread ( & samplecount , 1 , 4 , mp4 -> mediafp ) ;samplecount = BYTESWAP32 ( samplecount ) ;len += fread ( & duration , 1 , 4 , mp4 -> mediafp ) ;duration = BYTESWAP32 ( duration ) ;samples += samplecount ;entries -- ;totaldur += duration ;mp4 -> metadatalength += ( double ) ( ( double ) samplecount * ( double ) duration / ( double ) mp4 -> meta_clockdemon ) ;}mp4 -> basemetadataduration = mp4 -> metadatalength * ( double ) mp4 -> meta_clockdemon / ( double ) samples ;}LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;}else  LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;","LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ;else LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ;NESTSIZE ( qtsize ) ;}else if ( qttag == MAKEID ( \'s\' , \'t\' , \'t\' , \'s\' ) && temp != MAKEID ( \'u\' , \'r\' , \'l\' , \'<S2SV_blank>\' ) ) {if ( num * 8 <= qtsize - 8 ) ;NESTSIZE ( qtsize ) ;}else {CloseSource ( ( size_t ) mp4 ) ;mp4 = NULL ;break ;}}else {CloseSource ( ( size_t ) mp4 ) ;mp4 = NULL ;break ;}",395
1760,}else {,if ( mp4 ) {if ( mp4 -> metasizes == NULL || mp4 -> metaoffsets == NULL ) {CloseSource ( ( size_t ) mp4 ) ;mp4 = NULL ;}}}else {,395
1761,line = picture -> data [ plane ] + y * picture -> linesize [ plane ] ;for ( ;dst = line + x * pixelsize + compno * ! planar ;if ( codsty -> transform == FF_DWT97 ) {,line = picture -> data [ plane ] + y / s -> cdy [ compno ] * picture -> linesize [ plane ] ;for ( ;dst = line + x / s -> cdx [ compno ] * pixelsize + compno * ! planar ;if ( codsty -> transform == FF_DWT97 ) {,396
1762,linel = ( uint16_t * ) picture -> data [ plane ] + y * ( picture -> linesize [ plane ] >> 1 ) ;for ( ;dst = linel + ( x * pixelsize + compno * ! planar ) ;if ( codsty -> transform == FF_DWT97 ) {,linel = ( uint16_t * ) picture -> data [ plane ] + y / s -> cdy [ compno ] * ( picture -> linesize [ plane ] >> 1 ) ;for ( ;dst = linel + ( x / s -> cdx [ compno ] * pixelsize + compno * ! planar ) ;if ( codsty -> transform == FF_DWT97 ) {,396
1763,"split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ;err = ext4_split_extent_at ( handle , inode , path ,  map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ;split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ;","split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ;if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ;err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ;split_flag1 = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) ;",397
1764,"err = bnep_add_connection ( & ca , nsock ) ;if ( ! err ) {","ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;err = bnep_add_connection ( & ca , nsock ) ;if ( ! err ) {",398
1765,"strcpy ( buf , mode ) ;p = & buf [ 0 ] ;","else strcpy ( mode , """" ) ;strcpy ( buf , mode ) ;p = & buf [ 0 ] ;",399
1766,"if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\","if ( q < p ) {DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\\goto out ;}if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\",400
1767,"ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ;u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) {return ERROR_CORRUPTED_SLICE ;}if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) {return ERROR_CORRUPTED_SLICE ;}COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ;u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ;u1_slice_type = u4_temp ;COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ;ps_dec -> u1_sl_typ_5_9 = 0 ;if ( u1_slice_type > 4 ) {u1_slice_type -= 5 ;ps_dec -> u1_sl_typ_5_9 = 1 ;}{UWORD32 skip ;if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) {UWORD32 u4_bit_stream_offset = 0 ;if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) {skip = 0 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ;}else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) {skip = 0 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ;}else {skip = 1 ;}if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) {skip = 0 ;}if ( skip ) {ps_dec -> u4_prev_nal_skipped = 1 ;ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ;return 0 ;}else {if ( 1 == ps_dec -> u4_prev_nal_skipped ) {ps_dec -> u4_return_to_app = 1 ;return 0 ;}}}}u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SPS_PPS_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ;ps_pps = & ps_dec -> ps_pps [ u4_temp ] ;if ( FALSE == ps_pps -> u1_is_valid ) {return ERROR_INV_SPS_PPS_T ;}ps_seq = ps_pps -> ps_sps ;if ( ! ps_seq ) return ERROR_INV_SPS_PPS_T ;if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SPS_PPS_T ;u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ;if ( ! ps_seq -> u1_frame_mbs_only_flag ) {u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ;u1_bottom_field_flag = 0 ;if ( u1_field_pic_flag ) {ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ;u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ;}else {ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ;}}else {u1_field_pic_flag = 0 ;u1_bottom_field_flag = 0 ;ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ;}u1_nal_unit_type = SLICE_NAL ;if ( u1_is_idr_slice ) {if ( 0 == u1_field_pic_flag ) {ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ;}u1_nal_unit_type = IDR_SLICE_NAL ;u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SPS_PPS_T ;COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ;}i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ;s_tmp_poc . i4_pic_order_cnt_lsb = 0 ;s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ;u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ;if ( u1_pic_order_cnt_type == 0 ) {i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ;if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SPS_PPS_T ;s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ;COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ;if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) {s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ;}}s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ;s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ;if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) {s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ;if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) {s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ;}}if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) {u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ;if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SPS_PPS_T ;u1_redundant_pic_cnt = u4_temp ;COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ;}i1_is_end_of_poc = 0 ;if ( ! ps_dec -> u1_first_slice_in_stream ) {i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ;if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) {ps_dec -> ps_dec_err_status -> u1_err_flag |= REJECT_CUR_PIC ;i1_is_end_of_poc = 1 ;}else {ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ;}}u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;prev_slice_err = 0 ;if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) {if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) {ps_dec -> u1_dangling_field = 1 ;if ( ps_dec -> u4_first_slice_in_pic ) {prev_slice_err = 1 ;}else {prev_slice_err = 2 ;}if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ;else ps_cur_slice -> u1_bottom_field_flag = 0 ;num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & ps_dec -> s_cur_pic_poc ;u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ;}else if ( ps_dec -> u4_first_slice_in_pic == 2 ) {if ( u2_first_mb_in_slice > 0 ) {prev_slice_err = 1 ;num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ;ps_cur_poc = & s_tmp_poc ;ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ;ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ;ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ;ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ;ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ;ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ;ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ;ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ;}}else {if ( ps_dec -> u4_first_slice_in_pic ) {prev_slice_err = 1 ;num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ;}else {prev_slice_err = 2 ;num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ;}ps_cur_poc = & s_tmp_poc ;}}else {if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) {prev_slice_err = 2 ;num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & s_tmp_poc ;}else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) {return ERROR_CORRUPTED_SLICE ;}}if ( prev_slice_err ) {ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ;if ( ps_dec -> u1_dangling_field == 1 ) {ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ;ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ;ps_dec -> u2_prv_frame_num = u2_frame_num ;ps_dec -> u1_first_slice_in_stream = 0 ;return ERROR_DANGLING_FIELD_IN_PIC ;}if ( prev_slice_err == 2 ) {ps_dec -> u1_first_slice_in_stream = 0 ;return ERROR_INCOMPLETE_FRAME ;}if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) {ps_dec -> u1_first_slice_in_stream = 0 ;return ERROR_IN_LAST_SLICE_OF_PIC ;}if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) {ih264d_err_pic_dispbuf_mgr ( ps_dec ) ;return ERROR_NEW_FRAME_EXPECTED ;}if ( ret != OK ) return ret ;i1_is_end_of_poc = 0 ;}if ( ps_dec -> u4_first_slice_in_pic == 0 )  ps_dec -> ps_parse_cur_slice ++ ;ps_dec -> u1_slice_header_done = 0 ;if ( ! ps_dec -> u1_first_slice_in_stream ) {UWORD8 uc_mbs_exceed = 0 ;if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) {if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ;}if ( i1_is_end_of_poc || uc_mbs_exceed ) {if ( 1 == ps_dec -> u1_last_pic_not_decoded ) {ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ;if ( ret != OK ) return ret ;ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ;if ( ret != OK ) return ret ;# if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\\# endif return RET_LAST_SKIP ;}else {ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ;if ( ret != OK ) return ret ;}}}if ( u1_field_pic_flag ) {ps_dec -> u2_prv_frame_num = u2_frame_num ;}if ( ps_cur_slice -> u1_mmco_equalto5 ) {WORD32 i4_temp_poc ;WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ;if ( ! ps_cur_slice -> u1_field_pic_flag ) {i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ;}else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ;ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ;}if ( ps_dec -> u4_first_slice_in_pic == 2 ) {ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ;if ( ret != OK ) return ret ;if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ;if ( i4_poc == 0 ) {ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ;ps_dec -> i4_max_poc = 0 ;}}ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ;ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ;ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ;ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ;ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ;ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ;ps_cur_slice -> u1_slice_type = u1_slice_type ;ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ;ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ;ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ;ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ;ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ;if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ;else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ;if ( u1_slice_type == B_SLICE ) {ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ;if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ;else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ;if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ;}else {if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ;}if ( ps_dec -> u4_first_slice_in_pic == 2 ) {if ( u2_first_mb_in_slice == 0 ) {ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ;if ( ret != OK ) return ret ;}ps_dec -> u4_output_present = 0 ;{ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ;if ( 0 != ps_dec -> s_disp_op . u4_error_code ) {ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ;}else ps_dec -> u4_output_present = 1 ;}if ( ps_dec -> u1_separate_parse == 1 ) {if ( ps_dec -> u4_dec_thread_created == 0 ) {ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ;ps_dec -> u4_dec_thread_created = 1 ;}if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) {ps_dec -> u4_start_recon_deblk = 0 ;ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ;ps_dec -> u4_bs_deblk_thread_created = 1 ;}}}{UWORD8 uc_nofield_nombaff ;uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ;if ( uc_nofield_nombaff ) {ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ;ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ;}else {ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ;ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ;}}{dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ;if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) {ps_err -> u1_err_flag = ACCEPT_ALL_PICS ;ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ;}ps_err -> u4_cur_frm = u2_frame_num ;}{WORD32 i4_skip_b_pic , i4_skip_p_pic ;i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ;i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ;if ( i4_skip_b_pic ) {ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ;ps_dec -> u1_last_pic_not_decoded = 1 ;return OK ;}if ( i4_skip_p_pic ) {ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ;ps_dec -> u1_last_pic_not_decoded = 1 ;return OK ;}}{UWORD16 u2_mb_x , u2_mb_y ;ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ;if ( u2_first_mb_in_slice ) {UWORD8 u1_mb_aff ;UWORD8 u1_field_pic ;UWORD16 u2_frm_wd_in_mbs ;u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ;u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ;u1_field_pic = ps_cur_slice -> u1_field_pic_flag ;{UWORD32 x_offset ;UWORD32 y_offset ;UWORD32 u4_frame_stride ;tfr_ctxt_t * ps_trns_addr ;if ( ps_dec -> u1_separate_parse ) {ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ;}else {ps_trns_addr = & ps_dec -> s_tran_addrecon ;}u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ;u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ;u2_mb_y <<= u1_mb_aff ;if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) {return ERROR_CORRUPTED_SLICE ;}u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ;x_offset = u2_mb_x << 4 ;y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ;ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ;u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ;x_offset >>= 1 ;y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ;x_offset *= YUV420SP_FACTOR ;ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ;ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ;ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ;ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ;ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ;if ( ps_dec -> u1_separate_parse == 1 ) {ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ;}else {ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ;}ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ;ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ;}}else {tfr_ctxt_t * ps_trns_addr ;if ( ps_dec -> u1_separate_parse ) {ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ;}else {ps_trns_addr = & ps_dec -> s_tran_addrecon ;}u2_mb_x = 0xffff ;u2_mb_y = 0 ;ps_dec -> u2_cur_mb_addr = 0 ;ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ;ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ;ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ;ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ;ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ;ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ;ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ;ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ;}ps_dec -> ps_part = ps_dec -> ps_parse_part_params ;ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ;ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ;ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ;","
",401
1768,ps_dec -> u2_cur_slice_num ++ ;ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ;,ps_dec -> u2_cur_slice_num ++ ;ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ;,401
1769,"
","if ( sqlite3VdbeGetOp ( v , - 1 ) -> opcode == OP_Column ) {",402
1770,"
",},402
1771,"sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ;jmp2 = sqlite3VdbeAddOp1 ( v , OP_NotNull , 3 ) ;","sqlite3VdbeChangeP5 ( v , OPFLAG_TYPEOFARG ) ;jmp2 = sqlite3VdbeAddOp1 ( v , OP_NotNull , 3 ) ;",402
1772,"if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) >  ( Rec2 . RecordLength - 2 - 2 ) / 3 )  ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;","if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;",403
1773,"if ( js_regexec ( re -> prog , source , & m , 0 ) ) {js_copy ( J , 0 ) ;","if ( js_doregexec ( J , re -> prog , source , & m , 0 ) ) {js_copy ( J , 0 ) ;",404
1774,"if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) )  goto loop ;","if ( ! js_doregexec ( J , re -> prog , source , & m , REG_NOTBOL ) ) goto loop ;",404
1775,while ( 0xff == u4_bits )  {while ( 0xff == u4_bits )  {,while ( 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) ) {while ( 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) ) {,405
1776,while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) )  {,while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) && ! EXCEED_OFFSET ( ps_bitstrm ) ) {,405
1777,"}entity = ( video_entity_t * ) wmem_tree_lookup32 ( video_conv_info -> entities , entity_id ) ;","usb_conv_info -> class_data_type = USB_CONV_VIDEO ;}else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) {return descriptor_len ;}entity = ( video_entity_t * ) wmem_tree_lookup32 ( video_conv_info -> entities , entity_id ) ;",406
1778,while ( header_buf [ i ] == '\\\\r' || header_buf [ i ] == '\\\,while ( ( i < ( int ) header_buf_used ) && ( header_buf [ i ] == '\\\\r' || header_buf [ i ] == '\\\,407
1779,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,408
1780,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",408
1781,if ( ! static_key_enabled ( work -> key ) )  static_key_slow_inc ( work -> key ) ;,BUG_ON ( ! static_key_enabled ( work -> key ) ) ;static_key_slow_dec ( work -> key ) ;,409
1782,"if ( strchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL )  {","if ( osStrchr ( topicName , '#' ) == NULL && osStrchr ( topicName , '+' ) == NULL ) {",410
1783,"pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * PIPE_DEF_BUFFERS , GFP_KERNEL ) ;if ( pipe -> bufs ) {pipe -> buffers = PIPE_DEF_BUFFERS ;mutex_init ( & pipe -> mutex ) ;kfree ( pipe ) ;}","unsigned long pipe_bufs = PIPE_DEF_BUFFERS ;struct user_struct * user = get_current_user ( ) ;if ( ! too_many_pipe_buffers_hard ( user ) ) {if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ;pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * pipe_bufs , GFP_KERNEL ) ;}if ( pipe -> bufs ) {pipe -> buffers = pipe_bufs ;pipe -> user = user ;account_pipe_buffers ( pipe , 0 , pipe_bufs ) ;mutex_init ( & pipe -> mutex ) ;free_uid ( user ) ;kfree ( pipe ) ;}",411
1784,"
","if ( samples_in_chunk < 1 ) {av_log ( s , AV_LOG_ERROR , ""fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\\return AVERROR_PATCHWELCOME ;}",412
1785,if ( trk -> vos_len == 0 && par -> extradata_size > 0 &&  ! TAG_IS_AVCI ( trk -> tag ) && ( par -> codec_id != AV_CODEC_ID_DNXHD ) ) {,if ( trk -> vos_len == 0 && par -> extradata_size > 0 && ! TAG_IS_AVCI ( trk -> tag ) && ( par -> codec_id != AV_CODEC_ID_DNXHD ) ) {,412
1786,xmlNodePtr cur = NULL ;long val ;xmlXPathObjectPtr obj ;xmlNodeSetPtr nodelist ;,xmlNodePtr cur = NULL ;xmlXPathObjectPtr obj = NULL ;long val ;xmlNodeSetPtr nodelist ;,413
1787,xmlXPathFreeObject ( obj ) ;},},413
1788,val = ( long ) ( ( char * ) cur - ( char * ) doc ) ;if ( val >= 0 ) {,if ( obj ) xmlXPathFreeObject ( obj ) ;val = ( long ) ( ( char * ) cur - ( char * ) doc ) ;if ( val >= 0 ) {,413
1789,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",414
1790,"walk -> private += __mincore_unmapped_range ( addr , end ,  walk -> vma , walk -> private ) ;","unsigned char * vec = walk -> private ;unsigned long nr = ( end - addr ) >> PAGE_SHIFT ;memset ( vec , 0 , nr ) ;walk -> private += nr ;",415
1791,static void  ast_clear ( AST_object * self ) {},static int ast_clear ( AST_object * self ) {return 0 ;},416
1792,"int rc ;sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ;rc = ecryptfs_parse_options ( sbi , raw_data ) ;if ( rc ) {","uid_t check_ruid ;int rc ;sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ;rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ;if ( rc ) {",417
1793,"ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ;s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ;","if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) {rc = - EPERM ;printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\\goto out_free ;}ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ;s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ;",417
1794,return AUTH_FOUND ;},fclose ( opwfile ) ;return AUTH_FOUND ;},418
1795,"static void  horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 4 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 4 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",419
1796,},return 1 ;},419
1797,"
",dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;,420
1798,random_ether_addr ( dev -> dev_addr ) ;dev -> tx_queue_len = TUN_READQ_SIZE ;,random_ether_addr ( dev -> dev_addr ) ;dev -> tx_queue_len = TUN_READQ_SIZE ;,420
1799,"# endif  timr -> it_overrun += ( unsigned int )  hrtimer_forward ( timer , now , timr -> it_interval ) ;","# endif timr -> it_overrun += hrtimer_forward ( timer , now , timr -> it_interval ) ;",421
1800,tlv = cp + i ;type = EXTRACT_16BITS ( tlv ) ;,if ( i + 4 > length ) return - 1 ;tlv = cp + i ;type = EXTRACT_16BITS ( tlv ) ;,422
1801,"ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ;switch ( type ) {","ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ;if ( i + 4 + optlen > length ) return - 1 ;switch ( type ) {",422
1802,"yleft_col [ i ] = yleft [ i * left_stride ] ;}switch ( x -> mode_info_context -> mbmi . mode ) {case DC_PRED : {int expected_dc ;int shift ;int average = 0 ;if ( x -> up_available || x -> left_available ) {if ( x -> up_available ) {for ( i = 0 ;i < 16 ;i ++ ) {average += yabove_row [ i ] ;}}if ( x -> left_available ) {for ( i = 0 ;i < 16 ;i ++ ) {average += yleft_col [ i ] ;}}shift = 3 + x -> up_available + x -> left_available ;expected_dc = ( average + ( 1 << ( shift - 1 ) ) ) >> shift ;}else {expected_dc = 128 ;}for ( r = 0 ;r < 16 ;r ++ ) {vpx_memset ( ypred_ptr , expected_dc , 16 ) ;ypred_ptr += y_stride ;","memset ( ypred_ptr , expected_dc , 16 ) ;ypred_ptr += y_stride ;",423
1803,"vpx_memset ( ypred_ptr , yleft_col [ r ] , 16 ) ;ypred_ptr += y_stride ;","vpx_memset ( ypred_ptr , yleft_col [ r ] , 16 ) ;ypred_ptr += y_stride ;",423
1804,if ( ! asoc -> temp ) {list_del ( & asoc -> asocs ) ;,if ( ! list_empty ( & asoc -> asocs ) ) {list_del ( & asoc -> asocs ) ;,424
1805,"
","case Opt_dioread_nolock : set_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ;break ;case Opt_dioread_lock : clear_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ;break ;",425
1806,"default :  ext4_msg ( sb , KERN_ERR , ""Unrecognized<S2SV_blank>mount<S2SV_blank>option<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>"" ""or<S2SV_blank>missing<S2SV_blank>value"" , p ) ;","default : ext4_msg ( sb , KERN_ERR , ""Unrecognized<S2SV_blank>mount<S2SV_blank>option<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>"" ""or<S2SV_blank>missing<S2SV_blank>value"" , p ) ;",425
1807,if ( noblock )  return - EAGAIN ;,cond_resched ( ) ;,426
1808,"static TX_SIZE read_selected_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd ,  TX_SIZE max_tx_size , vp9_reader * r ) {const int ctx = vp9_get_tx_size_context ( xd ) ;const vp9_prob * tx_probs = get_tx_probs ( max_tx_size , ctx , & cm -> fc . tx_probs ) ;int tx_size = vp9_read ( r , tx_probs [ 0 ] ) ;if ( tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) {tx_size += vp9_read ( r , tx_probs [ 1 ] ) ;if ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 )  tx_size += vp9_read ( r , tx_probs [ 2 ] ) ;}if ( ! cm -> frame_parallel_decoding_mode )   ++ get_tx_counts ( max_tx_size , ctx , & cm -> counts . tx ) [ tx_size ] ;return ( TX_SIZE ) tx_size ;","static TX_SIZE read_selected_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_SIZE max_tx_size , vpx_reader * r ) {FRAME_COUNTS * counts = xd -> counts ;const int ctx = get_tx_size_context ( xd ) ;const vp9_prob * tx_probs = get_tx_probs ( max_tx_size , ctx , & cm -> fc -> tx_probs ) ;int tx_size = vpx_read ( r , tx_probs [ 0 ] ) ;if ( tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) {tx_size += vpx_read ( r , tx_probs [ 1 ] ) ;if ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 ) tx_size += vpx_read ( r , tx_probs [ 2 ] ) ;}if ( counts ) ++ get_tx_counts ( max_tx_size , ctx , & counts -> tx ) [ tx_size ] ;return ( TX_SIZE ) tx_size ;",427
1809,evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ;if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ;,evt -> event . lun [ 1 ] = tpg -> tport_tpgt ;if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ;,428
1810,int64_t cur_offset = avio_tell ( pb ) ;if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ;,"int64_t cur_offset = avio_tell ( pb ) ;if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) {av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\\return AVERROR ( EINVAL ) ;}if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ;",429
1811,"if ( ! sock_flag ( sk , SOCK_ZAPPED ) )  return - EINVAL ;","if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ;",430
1812,if ( sk -> sk_state != TCP_CLOSE )  goto out_unlock ;,if ( sk -> sk_state != TCP_CLOSE ) goto out_unlock ;,430
1813,"strncpy ( result , ""undefined"" , 10 ) ;}","strcpy ( result , ""undefined"" , 10 ) ;}",431
1814,"GsmXSMPClient * client ;if ( server -> priv -> xsmp_sockets == NULL ) {client = ice_conn -> context ;g_return_val_if_fail ( client != NULL , TRUE ) ;gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ;return TRUE ;","GsmClient * client ;GsmIceConnectionWatch * data ;if ( server -> priv -> xsmp_sockets == NULL ) {data = ice_conn -> context ;g_return_val_if_fail ( client != NULL , TRUE ) ;gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) , sms_conn , mask_ret , callbacks_ret ) ;return TRUE ;",432
1815,"udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ;brelse ( bh ) ;up_read ( & iinfo -> i_data_sem ) ;","err = udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p , PAGE_SIZE ) ;brelse ( bh ) ;if ( err ) goto out_unlock_inode ;up_read ( & iinfo -> i_data_sem ) ;",433
1816,"static char * print_array ( cJSON * item , int depth , int fmt )  {while ( child ) {++ numentries ;child = child -> next ;}if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) )  return 0 ;while ( child && ! fail ) {ret = print_value ( child , depth + 1 , fmt ) ;entries [ i ++ ] = ret ;}if ( ! fail ) {out = ( char * ) cJSON_malloc ( len ) ;}if ( fail ) {for ( i = 0 ;++ i )  if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ;for ( i = 0 ;++ i ) {strcpy ( ptr , entries [ i ] ) ;ptr += strlen ( entries [ i ] ) ;if ( i != numentries - 1 ) {* ptr ++ = ',' ;cJSON_free ( entries [ i ] ) ;}* ptr ++ = 0 ;return out ;","static char * print_array ( cJSON * item , int depth , int fmt , printbuffer * p ) {+ numentries ;size_t tmplen = 0 ;while ( child ) numentries ++ , child = child -> next ;}if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ;while ( child && ! fail ) {ret = print_value ( child , depth + 1 , fmt ) ;entries [ i ++ ] = ret ;if ( ! numentries ) {if ( p ) out = ensure ( p , 3 ) ;else out = ( char * ) cJSON_malloc ( len ) ;if ( fail ) {for ( i = 0 ;+ i )  if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ;i ++ ) if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ;for ( i = 0 ;+ i ) {i ++ ) {tmplen = strlen ( entries [ i ] ) ;memcpy ( ptr , entries [ i ] , tmplen ) ;ptr += tmplen ;if ( i != numentries - 1 ) {* ptr ++ = ',' ;cJSON_free ( entries [ i ] ) ;}cJSON_free ( entries [ i ] ) ;}* ptr ++ = 0 ;return out ;",434
1817,"
",WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;,435
1818,if ( ! vma -> vm_userfaultfd_ctx . ctx )  goto skip ;,if ( ! vma -> vm_userfaultfd_ctx . ctx ) goto skip ;,435
1819,"
","if ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) {ret = - ENOENT ;goto out ;}",436
1820,"if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) {ret = - EACCES ;","if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) {ret = - EACCES ;",436
1821,# if CONFIG_ALPHA  xd -> plane [ 3 ] . plane_type = PLANE_TYPE_Y ;xd -> plane [ 3 ] . subsampling_x = 0 ;xd -> plane [ 3 ] . subsampling_y = 0 ;# endif },},437
1822,if ( serial -> port [ 0 ] == usbcons_info . port ) {usb_serial_console_exit ( ) ;,if ( serial -> port [ 0 ] && serial -> port [ 0 ] == usbcons_info . port ) {usb_serial_console_exit ( ) ;,438
1823,"static int ion_handle_put ( struct ion_handle * handle )  {ret = kref_put ( & handle -> ref , ion_handle_destroy ) ;mutex_unlock ( & client -> lock ) ;",int ion_handle_put ( struct ion_handle * handle ) {ret = ion_handle_put_nolock ( handle ) ;mutex_unlock ( & client -> lock ) ;,439
1824,DEFINE_WAKE_Q ( wake_q ) ;if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ;,DEFINE_WAKE_Q ( wake_q ) ;if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL ;if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ;,440
1825,"vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ;vpx_memcpy ( dest_ptr1 + el , src_ptr1 , w ) ;vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , er ) ;","memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ;memcpy ( dest_ptr1 + el , src_ptr1 , w ) ;memset ( dest_ptr2 , src_ptr2 [ 0 ] , er ) ;",441
1826,"vpx_memcpy ( dest_ptr1 , src_ptr1 , linesize ) ;dest_ptr1 += dp ;vpx_memcpy ( dest_ptr2 , src_ptr2 , linesize ) ;dest_ptr2 += dp ;","memcpy ( dest_ptr1 , src_ptr1 , linesize ) ;dest_ptr1 += dp ;memcpy ( dest_ptr2 , src_ptr2 , linesize ) ;dest_ptr2 += dp ;",441
1827,"if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 )  goto end ;","if ( ! my_disable_copystat_in_redel && my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) goto end ;",442
1828,"static inline int  addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) {","int addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) {",443
1829,"}entity = ( video_entity_t * ) wmem_tree_lookup32 ( video_conv_info -> entities , entity_id ) ;","usb_conv_info -> class_data_type = USB_CONV_VIDEO ;}else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) {return descriptor_len ;}entity = ( video_entity_t * ) wmem_tree_lookup32 ( video_conv_info -> entities , entity_id ) ;",444
1830,"if ( ret >= 0 ) close ( ret ) ;if ( console -> master < 0 ) {INFO ( ""no<S2SV_blank>console"" ) ;return 0 ;}if ( mount ( console -> name , lxcpath , ""none"" , MS_BIND , 0 ) ) {ERROR ( ""failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\\\'%s\\\'<S2SV_blank>on<S2SV_blank>\\\'%s\\\'"" , console -> name , lxcpath ) ;","if ( safe_mount ( console -> name , lxcpath ) ;",445
1831,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,446
1832,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : return ( & ret ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;return ( & ret ) ;",446
1833,"ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]"" , len ) ) ;","ND_PRINT ( ( ndo , ""%s"" , mldv2_tstr ) ) ;",447
1834,"trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;return ;","trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;return ;",447
1835,"strcpy ( m , name ) ;for ( p = path ;","memcpy ( m , name , nlen + 1 ) ;for ( p = path ;",448
1836,"if ( j == - 1 ) {return ERROR_INV_SLICE_HDR_T ;if ( ps_dec -> u4_pic_buf_got == 0 ) {ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ;ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ;ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ;ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ;if ( ret != OK ) {return ret ;}}ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ;ps_dec -> u4_output_present = 0 ;{ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ;if ( 0 != ps_dec -> s_disp_op . u4_error_code ) {ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ;}else ps_dec -> u4_output_present = 1 ;}if ( ps_dec -> u1_separate_parse == 1 ) {if ( ps_dec -> u4_dec_thread_created == 0 ) {ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ;ps_dec -> u4_dec_thread_created = 1 ;}if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) {ps_dec -> u4_start_recon_deblk = 0 ;ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ;ps_dec -> u4_bs_deblk_thread_created = 1 ;}}}ps_dec -> u4_first_slice_in_pic = 0 ;}","
",449
1837,"static int  mptctl_eventenable ( unsigned long arg )  {struct mpt_ioctl_eventenable karg ;MPT_ADAPTER * ioc ;int iocnum ;return - EFAULT ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventenable()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;","static int mptctl_eventenable ( MPT_ADAPTER * ioc , unsigned long arg ) {struct mpt_ioctl_eventenable karg ;return - EFAULT ;",450
1838,if ( ! sock || ( count && ! buf ) )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! sock || ( count && ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,451
1839,MACROBLOCKD * const xd = args -> xd ;struct macroblock_plane * p = & args -> cpi -> mb . plane [ plane ] ;struct macroblockd_plane * pd = & xd -> plane [ plane ] ;,ThreadData * const td = args -> td ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;struct macroblock_plane * p = & x -> plane [ plane ] ;struct macroblockd_plane * pd = & xd -> plane [ plane ] ;,452
1840,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,453
1841,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",453
1842,"ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ;impeg2d_bit_stream_flush ( ps_stream , 18 ) ;","if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) {return IMPEG2D_FRM_HDR_DECODE_ERR ;}ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ;impeg2d_bit_stream_flush ( ps_stream , 18 ) ;",454
1843,"return print_value ( item , 0 , 0 ) ;}","return print_value ( item , 0 , 0 , 0 ) ;}",455
1844,"if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""arguments<S2SV_blank>field<S2SV_blank>\\\\""args\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;}len = PyList_GET_SIZE ( tmp ) ;args = _Ta3_asdl_seq_new ( len , arena ) ;if ( args == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {arg_ty value ;res = obj2ast_arg ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""arguments<S2SV_blank>field<S2SV_blank>\\\\""args\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;asdl_seq_SET ( args , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""args\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ;if ( exists_not_none ( obj , & PyId_vararg ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_vararg ) ;if ( tmp == NULL ) goto failed ;","if ( lookup_attr_id ( obj , & PyId_args ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_args , & tmp ) < 0 ) {return 1 ;if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""args\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ;else {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_vararg ) ;if ( tmp == NULL ) goto failed ;",456
1845,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_kwonlyargs ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_kwonlyargs ) ;",456
1846,"arg_ty value ;res = obj2ast_arg ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( kwonlyargs , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""kwonlyargs\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_kw_defaults ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_kw_defaults ) ;","arg_ty value ;res = obj2ast_arg ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( kwonlyargs , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""kwonlyargs\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_kw_defaults ) ) {int res ;Py_ssize_t i ;",456
1847,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( kw_defaults , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""kw_defaults\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ;if ( exists_not_none ( obj , & PyId_kwarg ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_kwarg ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_arg ( tmp , & kwarg , arena ) ;if ( res != 0 ) goto failed ;kwarg = NULL ;if ( _PyObject_HasAttrId ( obj , & PyId_defaults ) ) {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_defaults ) ;","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( kw_defaults , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_vararg , & tmp ) < 0 ) {if ( tmp == NULL || tmp == Py_None ) {vararg = NULL ;int res ;res = obj2ast_arg ( tmp , & vararg , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_kwonlyargs , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""kwonlyargs\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ;return 1 ;else {Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_defaults ) ;",456
1848,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( defaults , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""defaults\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments"" ) ;return 1 ;* out = arguments ( args , vararg , kwonlyargs , kw_defaults , kwarg , defaults ,  arena ) ;return 0 ;failed : Py_XDECREF ( tmp ) ;","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( defaults , i , val ) ;}if ( lookup_attr_id ( obj , & PyId_kw_defaults , & tmp ) < 0 ) {",456
1849,if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) {struct in_ifaddr * * ifap1 = & ifa1 -> ifa_next ;,if ( in_dev -> dead ) goto no_promotions ;if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) {struct in_ifaddr * * ifap1 = & ifa1 -> ifa_next ;,457
1850,else {,no_promotions : else {,457
1851,}* ifap = ifa1 -> ifa_next ;,}* ifap = ifa1 -> ifa_next ;,457
1852,"if ( likely ( walk . nbytes == nbytes ) )  {salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ;return blkcipher_walk_done ( desc , & walk , 0 ) ;}","
",458
1853,"
",rcu_read_lock ( ) ;,459
1854,"final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ;if ( ! dst ) {","final_p = fl6_update_dst ( fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ;if ( ! dst ) {",459
1855,"if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse )  return ( ( void * ) NULL ) ;","if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) return ( ( void * ) NULL ) ;",460
1856,"size_t bits_per_pixel , map_length , number_colormaps ,  number_planes ,  one , offset , pixel_info_length ;","size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ;",461
1857,"if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ;pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ;","number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ;if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * number_planes_filled ;pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ;",461
1858,"final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;fl6 -> saddr = ireq -> ir_v6_loc_addr ;fl6 -> flowi6_oif = ireq -> ir_iif ;","rcu_read_lock ( ) ;final_p = fl6_update_dst ( fl6 , rcu_dereference ( np -> opt ) , & final ) ;rcu_read_unlock ( ) ;fl6 -> saddr = ireq -> ir_v6_loc_addr ;fl6 -> flowi6_oif = ireq -> ir_iif ;",462
1859,assert ( 0 ) ;# endif },abort ( ) ;# endif },463
1860,"char * ksep , * vsep , * val ;size_t klen , vlen ;vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {return 0 ;","char * start , * ksep , * vsep , * val ;size_t klen , vlen ;start = var -> ptr + var -> already_scanned ;vsep = memchr ( start , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {var -> already_scanned = var -> end - var -> ptr ;return 0 ;",464
1861,return 1 ;},var -> already_scanned = 0 ;return 1 ;},464
1862,"
","if ( ! ape -> totalframes ) {av_log ( s , AV_LOG_ERROR , ""No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\\return AVERROR ( EINVAL ) ;}",465
1863,"if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) {av_log ( s , AV_LOG_ERROR , ""Too<S2SV_blank>many<S2SV_blank>frames:<S2SV_blank>%d\\\","if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) {av_log ( s , AV_LOG_ERROR , ""Too<S2SV_blank>many<S2SV_blank>frames:<S2SV_blank>%d\\\",465
1864,return 0 ;},hrtimer_try_to_cancel ( & stime -> hrt ) ;return 0 ;},466
1865,"static void update_state_rt ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx ,  int mi_row , int mi_col , int bsize ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;const struct segmentation * const seg = & cm -> seg ;* ( xd -> mi [ 0 ] ) = ctx -> mic ;if ( ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) && seg -> enabled ) {vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi ,   mi_row , mi_col , bsize , 1 ) ;vp9_init_plane_quantizers ( cpi , x ) ;vp9_update_mv_count ( cm , xd ) ;if ( cm -> interp_filter == SWITCHABLE ) {++ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ;}}x -> skip = ctx -> skip ;}","static void update_state_rt ( VP9_COMP * cpi , ThreadData * td , PICK_MODE_CONTEXT * ctx , int mi_row , int mi_col , int bsize ) {MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;MODE_INFO * const mi = xd -> mi [ 0 ] ;MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;const struct segmentation * const seg = & cm -> seg ;const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ;const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ;const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ;const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ;* ( xd -> mi [ 0 ] ) = ctx -> mic ;* ( x -> mbmi_ext ) = ctx -> mbmi_ext ;if ( seg -> enabled && cpi -> oxcf . aq_mode ) {if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ || cpi -> oxcf . aq_mode == VARIANCE_AQ ) {const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ;mbmi -> segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}else {vp9_cyclic_refresh_update_segment ( cpi , mbmi , mi_row , mi_col , bsize , 1 ) ;vp9_init_plane_quantizers ( cpi , x ) ;vp9_update_mv_count ( td ) ;if ( cm -> interp_filter == SWITCHABLE ) {+ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ;++ td -> counts -> switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ;}if ( mbmi -> sb_type < BLOCK_8X8 ) {mbmi -> mv [ 0 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 0 ] . as_int ;mbmi -> mv [ 1 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 1 ] . as_int ;}}if ( cm -> use_prev_frame_mvs ) {MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ;int w , h ;for ( h = 0 ;h < y_mis ;++ h ) {MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ;for ( w = 0 ;w < x_mis ;++ w ) {MV_REF * const mv = frame_mv + w ;mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ;mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ;mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ;mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ;}}}x -> skip = ctx -> skip ;x -> skip_txfm [ 0 ] = mbmi -> segment_id ? 0 : ctx -> skip_txfm [ 0 ] ;}",467
1866,"p ++ ;len = min_t ( unsigned int , len , NFSSVC_MAXBLKSIZE_V2 ) ;","p ++ ;if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;len = min_t ( unsigned int , len , NFSSVC_MAXBLKSIZE_V2 ) ;",468
1867,"return xdr_argsize_check ( rqstp , p ) ;}",return 1 ;},468
1868,"# ifndef _MSC_VER   char filename [ dirent . namelen + 1 ] ;# else char * filename = grub_malloc ( dirent . namelen + 1 ) ;# endif struct grub_fshelp_node * fdiro ;enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ;grub_ext2_read_file ( diro , 0 , 0 , 0 , fpos + sizeof ( struct ext2_dirent ) , dirent . namelen , filename ) ;if ( grub_errno )  return 0 ;fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) ) ;if ( ! fdiro )  return 0 ;fdiro -> data = diro -> data ;","char * filename = grub_malloc ( dirent . namelen + 1 ] ;# else char * filename = grub_malloc ( dirent . namelen + 1 ) ;struct grub_fshelp_node * fdiro ;enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ;if ( ! filename ) {break ;}grub_ext2_read_file ( diro , 0 , 0 , 0 , fpos + sizeof ( struct ext2_dirent ) , dirent . namelen , filename ) ;if ( grub_errno ) {free ( filename ) ;return 0 ;}fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) ) ;if ( ! fdiro ) {free ( filename ) ;return 0 ;}fdiro -> data = diro -> data ;",469
1869,if ( grub_errno )  {grub_free ( fdiro ) ;,if ( grub_errno ) {free ( filename ) ;grub_free ( fdiro ) ;,469
1870,"if ( hook ( filename , type , fdiro , closure ) )  return 1 ;","if ( hook ( filename , type , fdiro , closure ) ) {free ( filename ) ;return 1 ;}free ( filename ) ;",469
1871,if ( o == NULL ) return ;s = o -> ptr ;,"if ( o == NULL || checkType ( c , o , OBJ_STREAM ) ) return ;s = o -> ptr ;",470
1872,"if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",471
1873,"int  rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len )  {attr = ( struct vendor_attribute * ) * data ;* vendor = ntohl ( attr -> vendor_value ) ;* data = attr -> attrib_data ;return ( attr -> attrib_type ) ;}","int rad_get_vendor_attr ( u_int32_t * vendor , unsigned char * type , const void * * data , size_t * len , const void * raw , size_t raw_len ) {if ( raw_len < sizeof ( struct vendor_attribute ) ) {return - 1 ;}attr = ( struct vendor_attribute * ) raw ;* vendor = ntohl ( attr -> vendor_value ) ;* type = attr -> attrib_type ;* data = attr -> attrib_data ;if ( ( attr -> attrib_len + 4 ) > raw_len ) {return - 1 ;}return ( attr -> attrib_type ) ;}",472
1874,END_OF_READING :  if ( clone_info )  clone_info = DestroyImageInfo ( clone_info ) ;CloseBlob ( image ) ;,END_OF_READING : CloseBlob ( image ) ;,473
1875,DeleteImageFromList ( & tmp ) ;},if ( tmp == image2 ) image2 = ( Image * ) NULL ;DeleteImageFromList ( & tmp ) ;},473
1876,"buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) {","if ( msg . sct . length > 1 << 20 ) {rfbClientErr ( ""Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\\return FALSE ;}buffer = malloc ( ( uint64_t ) msg . sct . length + 1 ) ;if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) {",474
1877,"error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error < 0 ) return error ;if ( mode != inode -> i_mode ) {inode -> i_mode = mode ;mark_inode_dirty ( inode ) ;}}","error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ;if ( error ) return error ;if ( error < 0 ) return error ;if ( mode != inode -> i_mode ) mark_inode_dirty ( inode ) ;}}",475
1878,"int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ;if ( ( ! s -> willclose || s -> chunksize < 0 ) &&  target_end >= 0 && s -> off >= target_end ) return AVERROR_EOF ;if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) &&  target_end >= 0 && s -> off < target_end ) {av_log ( h , AV_LOG_ERROR ,  ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\\","uint64_t target_end = s -> end_off ? s -> end_off : s -> filesize ;if ( ( ! s -> willclose || s -> chunksize == UINT64_MAX ) && s -> off >= target_end ) return AVERROR_EOF ;if ( ! len && ( ! s -> willclose || s -> chunksize == UINT64_MAX ) && s -> off < target_end ) {av_log ( h , AV_LOG_ERROR , ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 ""\\\",476
1879,},( void ) cpi ;},477
1880,if ( length > 0 )  {,if ( length > 1 ) {,478
1881,"if ( ! bin )  return - ENOMEM ;ret = v3d_job_init ( v3d , file_priv , & bin -> base ,  v3d_job_free , args -> in_sync_bcl ) ;v3d_job_put ( & render -> base ) ;return ret ;","if ( ! bin ) {v3d_job_put ( & render -> base ) ;return - ENOMEM ;}ret = v3d_job_init ( v3d , file_priv , & bin -> base , v3d_job_free , args -> in_sync_bcl ) ;v3d_job_put ( & render -> base ) ;kfree ( bin ) ;return ret ;",479
1882,"stmt_ty  With ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int  end_lineno , int end_col_offset , PyArena * arena ) {p -> lineno = lineno ;p -> col_offset = col_offset ;","stmt_ty With ( asdl_seq * items , asdl_seq * body , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {p -> v . With . type_comment = type_comment ;p -> lineno = lineno ;p -> col_offset = col_offset ;",480
1883,"static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec ,  bool compat )  {return 0 ;}","static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec , bool compat , struct iov_iter * iter ) {iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;return 0 ;}",481
1884,"struct tpacket_req * req = & req_u -> req ;if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) {rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ;rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ;err = - EBUSY ;if ( ! closing ) {if ( atomic_read ( & po -> mapped ) ) goto out ;if ( packet_read_pending ( rb ) ) goto out ;}if ( req -> tp_block_nr ) {err = - EBUSY ;if ( unlikely ( rb -> pg_vec ) ) goto out ;switch ( po -> tp_version ) {case TPACKET_V1 : po -> tp_hdrlen = TPACKET_HDRLEN ;break ;case TPACKET_V2 : po -> tp_hdrlen = TPACKET2_HDRLEN ;break ;case TPACKET_V3 : po -> tp_hdrlen = TPACKET3_HDRLEN ;break ;}err = - EINVAL ;if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) goto out ;if ( unlikely ( ! PAGE_ALIGNED ( req -> tp_block_size ) ) ) goto out ;if ( po -> tp_version >= TPACKET_V3 && ( int ) ( req -> tp_block_size - BLK_PLUS_PRIV ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) goto out ;if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + po -> tp_reserve ) ) goto out ;if ( unlikely ( req -> tp_frame_size & ( TPACKET_ALIGNMENT - 1 ) ) ) goto out ;rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ;if ( unlikely ( rb -> frames_per_block == 0 ) ) goto out ;if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != req -> tp_frame_nr ) ) goto out ;err = - ENOMEM ;order = get_order ( req -> tp_block_size ) ;pg_vec = alloc_pg_vec ( req , order ) ;if ( unlikely ( ! pg_vec ) ) goto out ;switch ( po -> tp_version ) {case TPACKET_V3 : if ( ! tx_ring ) init_prb_bdqc ( po , rb , pg_vec , req_u ) ;break ;default : break ;}}else {err = - EINVAL ;if ( unlikely ( req -> tp_frame_nr ) ) goto out ;}lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;spin_unlock ( & po -> bind_lock ) ;","struct tpacket_req * req = & req_u -> req ;lock_sock ( sk ) ;if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) {spin_lock ( & po -> bind_lock ) ;if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;out : spin_unlock ( & po -> bind_lock ) ;",482
1885,"release_sock ( sk ) ;if ( pg_vec )  free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;","release_sock ( sk ) ;if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ;",482
1886,if ( blockSize == 16 )  request -> txBlockSzx = COAP_BLOCK_SIZE_16 ;else if ( blockSize == 32 )   request -> txBlockSzx = COAP_BLOCK_SIZE_32 ;else if ( blockSize == 64 )   request -> txBlockSzx = COAP_BLOCK_SIZE_64 ;else if ( blockSize == 128 )   request -> txBlockSzx = COAP_BLOCK_SIZE_128 ;else if ( blockSize == 256 )   request -> txBlockSzx = COAP_BLOCK_SIZE_256 ;else if ( blockSize == 512 )   request -> txBlockSzx = COAP_BLOCK_SIZE_512 ;else   request -> txBlockSzx = COAP_BLOCK_SIZE_1024 ;if ( request -> txBlockSzx > coapClientGetMaxBlockSize ( ) )  request -> txBlockSzx = coapClientGetMaxBlockSize ( ) ;osReleaseMutex ( & request -> context -> mutex ) ;,if ( blockSize == 16 ) {request -> txBlockSzx = COAP_BLOCK_SIZE_16 ;}else if ( blockSize == 32 ) {request -> txBlockSzx = COAP_BLOCK_SIZE_32 ;}else if ( blockSize == 64 ) {request -> txBlockSzx = COAP_BLOCK_SIZE_64 ;}else if ( blockSize == 128 ) {request -> txBlockSzx = COAP_BLOCK_SIZE_128 ;}else if ( blockSize == 256 ) {request -> txBlockSzx = COAP_BLOCK_SIZE_256 ;}else if ( blockSize == 512 ) {request -> txBlockSzx = COAP_BLOCK_SIZE_512 ;}else {request -> txBlockSzx = COAP_BLOCK_SIZE_1024 ;}if ( request -> txBlockSzx > coapClientGetMaxBlockSize ( ) ) {request -> txBlockSzx = coapClientGetMaxBlockSize ( ) ;}osReleaseMutex ( & request -> context -> mutex ) ;,483
1887,"struct sas_task * task = TO_SAS_TASK ( cmd ) ;sas_end_task ( cmd , task ) ;scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ;}","struct domain_device * dev = cmd_to_domain_dev ( cmd ) ;struct sas_task * task = TO_SAS_TASK ( cmd ) ;sas_end_task ( cmd , task ) ;if ( dev_is_sata ( dev ) ) {list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ;return ;}scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ;}",484
1888,"char * * subtreelist = NULL ;char * user = NULL , * subtree = NULL , * principal_dn = NULL ;char * * values = NULL , * strval [ 10 ] = {char * filtuser = NULL ;krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ;char * standalone_principal_dn = NULL ;",char * strval [ 10 ] = {char * filtuser = NULL ;krb5_boolean establish_links = FALSE ;char * standalone_principal_dn = NULL ;,485
1889,"int dnlen = 0 , subtreelen = 0 ;char * dn = NULL ;krb5_boolean outofsubtree = TRUE ;if ( xargs . dn != NULL ) {dn = xargs . dn ;}else if ( xargs . linkdn != NULL ) {dn = xargs . linkdn ;}else if ( standalone_principal_dn != NULL ) {dn = standalone_principal_dn ;}if ( st )  goto cleanup ;}","if ( st ) goto cleanup ;}st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , ntrees ) ;if ( st ) goto cleanup ;}",485
1890,"snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ;st = translate_ldap_error ( st , OP_ADD ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;","snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) goto cleanup ;",485
1891,"if ( table_base + v != ipt_next_entry ( e ) &&  ! ( e -> ip . flags & IPT_F_GOTO ) )  jumpstack [ stackidx ++ ] = e ;e = get_entry ( table_base , v ) ;continue ;","if ( table_base + v != ipt_next_entry ( e ) && ! ( e -> ip . flags & IPT_F_GOTO ) ) {if ( unlikely ( stackidx >= private -> stacksize ) ) {verdict = NF_DROP ;break ;}jumpstack [ stackidx ++ ] = e ;}e = get_entry ( table_base , v ) ;continue ;",486
1892,"if ( user_ns != mnt_ns -> user_ns )  copy_flags |= CL_SHARED_TO_SLAVE ;new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ;","if ( user_ns != mnt_ns -> user_ns ) copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED ;new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ;",487
1893,"if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ;if ( copy > size ) {++ from ;-- count ;offset = 0 ;}else offset += size ;copy -= size ;offset1 += size ;}if ( len == offset1 ) return 0 ;while ( count -- ) {struct page * page [ MAX_SKB_FRAGS ] ;int num_pages ;unsigned long base ;unsigned long truesize ;len = from -> iov_len - offset ;if ( ! len ) {offset = 0 ;++ from ;continue ;}base = ( unsigned long ) from -> iov_base + offset ;size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ;num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ;if ( ( num_pages != size ) ||  ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) {",+ from ;+ from ;if ( num_pages != size ) || ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) {,488
1894,for ( y = 0 ;uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ;,av_assert0 ( s -> bit_depth > 1 ) ;for ( y = 0 ;uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ;,489
1895,"static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up )  {","static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , struct tee_ta_param * p , struct utee_params * up ) {",490
1896,"switch ( TEE_PARAM_TYPE_GET ( types , n ) ) {case TEE_PARAM_TYPE_MEMREF_INPUT :  case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : p -> u [ n ] . mem . mobj = & mobj_virt ;break ;case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ;}}","uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ;switch ( TEE_PARAM_TYPE_GET ( types , n ) ) {case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ;case TEE_PARAM_TYPE_MEMREF_INPUT : p -> u [ n ] . mem . mobj = & mobj_virt ;if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ;break ;case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ;}return TEE_SUCCESS ;}",490
1897,if ( sk != asoc -> base . sk )  goto do_error ;,"
",491
1898,"gchar * filename ;GFile * file ;gimp_assert_mainimage ( image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ;filename = g_build_filename ( g_get_tmp_dir ( ) , ""gimp-test.xcf"" , NULL ) ;file = g_file_new_for_path ( filename ) ;","gchar * filename = NULL ;gint file_handle ;GFile * file ;file_handle = g_file_open_tmp ( ""gimp-test-XXXXXX.xcf"" , & filename , NULL ) ;g_assert ( file_handle != - 1 ) ;close ( file_handle ) ;file = g_file_new_for_path ( filename ) ;",492
1899,"
",if ( Info_h . biWidth == 0 || Info_h . biHeight == 0 ) {fclose ( IN ) ;return NULL ;}if ( Info_h . biBitCount > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) {fclose ( IN ) ;return NULL ;},493
1900,"stride = ( ( Info_h . biWidth * Info_h . biBitCount + 31U ) / 32U ) * 4U ;if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) {stride = ( ( Info_h . biWidth * 8U + 31U ) / 32U ) * 4U ;pData = ( OPJ_UINT8 * ) calloc ( 1 , stride * Info_h . biHeight * sizeof ( OPJ_UINT8 ) ) ;if ( pData == NULL ) {","stride = ( ( Info_h . biWidth * Info_h . biBitCount + 31U ) / 32U ) * 4U ;if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) {if ( 8 > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) {fclose ( IN ) ;return NULL ;}stride = ( ( Info_h . biWidth * 8U + 31U ) / 32U ) * 4U ;}if ( stride > ( ( OPJ_UINT32 ) - 1 ) / sizeof ( OPJ_UINT8 ) / Info_h . biHeight ) {fclose ( IN ) ;return NULL ;pData = ( OPJ_UINT8 * ) calloc ( 1 , stride * Info_h . biHeight * sizeof ( OPJ_UINT8 ) ) ;if ( pData == NULL ) {",493
1901,"pte_unmap ( page_table ) ;if ( ! ( flags & FAULT_FLAG_WRITE ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ;","pte_unmap ( page_table ) ;if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS ;if ( ! ( flags & FAULT_FLAG_WRITE ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ;",494
1902,"struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode )  {","struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , fmode_t mode ) {",495
1903,if ( event -> type == et_close ) {}if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) {,"if ( event -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) {sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ;}else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) {sd -> fv -> script_unsaved = false ;}else if ( event -> type == et_close ) {}if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) {",496
1904,"for ( i = 0 ;data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ;assert ( data [ i ] ) ;","assert ( numcmpts <= 3 ) ;for ( i = 0 ;i < 3 ;++ i ) {if ( ! ( data [ i ] = 0 ;}for ( i = 0 ;data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ) ) {goto error ;}",497
1905,return - 1 ;},goto error ;},497
1906,return - 1 ;}nz -= 8 ;z &= RAS_ONES ( nz ) ;return - 1 ;return - 1 ;,goto error ;}nz -= 8 ;z &= RAS_ONES ( nz ) ;goto error ;goto error ;,497
1907,"
",data [ i ] = 0 ;error : for ( i = 0 ;i < numcmpts ;++ i ) {if ( data [ i ] ) {jas_matrix_destroy ( data [ i ] ) ;}}return - 1 ;,497
1908,"if ( unlikely ( ! hex2bin ( pool -> header_bin , header , 128 ) ) )  quit ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify"" ) ;cb1 = ( unsigned char * ) calloc ( cb1_len , 1 ) ;","if ( unlikely ( ! hex2bin ( pool -> header_bin , header , 128 ) ) ) {applog ( LOG_WARNING , ""%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s"" , __func__ , header ) ;pool_failed ( pool ) ;return false ;}cb1 = ( unsigned char * ) calloc ( cb1_len , 1 ) ;",498
1909,"vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;","vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ;vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;",499
1910,"if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) {return 0 ;memset ( box , 0 , sizeof ( jp2_box_t ) ) ;box -> type = type ;",if ( ! ( box = jp2_box_create0 ( ) ) ) ) {return 0 ;box -> type = type ;,500
1911,"unsigned int h , w , s , xcs , ycs , bps ;int align ;if ( ! buf_align ) buf_align = 1 ;if ( buf_align & ( buf_align - 1 ) ) goto fail ;if ( ! stride_align ) stride_align = 1 ;if ( stride_align & ( stride_align - 1 ) ) goto fail ;switch ( fmt ) {case VPX_IMG_FMT_RGB32 : case VPX_IMG_FMT_RGB32_LE : case VPX_IMG_FMT_ARGB : case VPX_IMG_FMT_ARGB_LE : bps = 32 ;break ;case VPX_IMG_FMT_RGB24 : case VPX_IMG_FMT_BGR24 : bps = 24 ;break ;case VPX_IMG_FMT_RGB565 : case VPX_IMG_FMT_RGB565_LE : case VPX_IMG_FMT_RGB555 : case VPX_IMG_FMT_RGB555_LE : case VPX_IMG_FMT_UYVY : case VPX_IMG_FMT_YUY2 : case VPX_IMG_FMT_YVYU : bps = 16 ;break ;case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : bps = 12 ;break ;default :  bps = 16 ;break ;}switch ( fmt ) {case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 :  xcs = 1 ;break ;default : xcs = 0 ;break ;}switch ( fmt ) {case VPX_IMG_FMT_I420 :  case VPX_IMG_FMT_YV12 :  case VPX_IMG_FMT_VPXI420 :  case VPX_IMG_FMT_VPXYV12 :  ycs = 1 ;break ;default : ycs = 0 ;break ;}align = ( 1 << xcs ) - 1 ;w = ( d_w + align ) & ~ align ;align = ( 1 << ycs ) - 1 ;h = ( d_h + align ) & ~ align ;s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ;if ( ! img ) {img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;","const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) w : bps * w / 8 ;stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ;if ( ! img ) {img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;",501
1912,"img -> img_data = img_buf_memalign ( buf_align , ( ( fmt & VPX_IMG_FMT_PLANAR ) ?   h * s * bps / 8 : h * s ) ) ;img -> img_data_owner = 1 ;img -> fmt = fmt ;img -> w = w ;img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = s ;img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = s >> xcs ;if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ;","img -> img_data = img_buf_memalign ( buf_align , ( ( fmt & VPX_IMG_FMT_PLANAR ) ? h * s * bps / 8 : ( uint64_t ) h * s ) ) ;img -> img_data_owner = 1 ;img -> fmt = fmt ;img -> w = w ;img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = s ;img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = s >> xcs ;if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ;",501
1913,"static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out )  {int i ;Rune c ;for ( ;switch ( pc -> opcode ) {case I_END :  return 1 ;case I_JUMP : pc = pc -> x ;if ( match ( pc -> x , sp , bol , flags , & scratch ) ) {* out = scratch ;return 1 ;}case I_PLA :  if ( ! match ( pc -> x , sp , bol , flags , out ) )  return 0 ;if ( match ( pc -> x , sp , bol , flags , & scratch ) )  return 0 ;if ( c == 0 )  return 0 ;pc = pc + 1 ;break ;case I_ANY : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( isnewline ( c ) )  return 0 ;pc = pc + 1 ;break ;case I_CHAR : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) c = canon ( c ) ;if ( c != pc -> c )  return 0 ;pc = pc + 1 ;break ;case I_CCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) {if ( ! incclasscanon ( pc -> cc , canon ( c ) ) )  return 0 ;}else {if ( ! incclass ( pc -> cc , c ) )  return 0 ;}case I_NCCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) {if ( incclasscanon ( pc -> cc , canon ( c ) ) )  return 0 ;}else {if ( incclass ( pc -> cc , c ) )  return 0 ;}case I_REF : i = out -> sub [ pc -> n ] . ep - out -> sub [ pc -> n ] . sp ;if ( strncmpcanon ( sp , out -> sub [ pc -> n ] . sp , i ) )  return 0 ;}else {if ( strncmp ( sp , out -> sub [ pc -> n ] . sp , i ) )  return 0 ;}if ( i > 0 ) sp += i ;","static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out , int depth ) {int result ;int i ;Rune c ;if ( depth > MAXREC ) return - 1 ;for ( ;switch ( pc -> opcode ) {case I_END : return 0 ;case I_JUMP : pc = pc -> x ;result = match ( pc -> x , sp , bol , flags , & scratch , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 0 ) {* out = scratch ;return 0 ;}case I_PLA : result = match ( pc -> x , sp , bol , flags , out , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 1 ) return 1 ;result = match ( pc -> x , sp , bol , flags , & scratch , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 0 ) return 1 ;if ( c == 0 ) return 1 ;if ( c == 0 ) return 0 ;if ( isnewline ( c ) ) return 0 ;case I_CHAR : sp += chartorune ( & c , sp ) ;if ( c == 0 ) return 0 ;if ( flags & REG_ICASE ) c = canon ( c ) ;if ( c != pc -> c ) return 0 ;case I_CCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 ) return 0 ;if ( ! incclasscanon ( pc -> cc , canon ( c ) ) ) return 1 ;",502
1914,return 0 ;case I_EOL : if ( * sp == 0 ) {,return 0 ;case I_EOL : if ( * sp == 0 ) {,502
1915,return 0 ;case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ;if ( ! i )  return 0 ;pc = pc + 1 ;if ( i )  return 0 ;pc = pc + 1 ;,return 0 ;case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ;if ( ! i ) return 0 ;pc = pc + 1 ;if ( i ) return 0 ;pc = pc + 1 ;,502
1916,default :  return 0 ;},default : return 1 ;},502
1917,"unix_state_double_unlock ( sk , other ) ;if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ;","unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;unix_state_double_unlock ( sk , other ) ;if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ;",503
1918,"if ( nargs == 0 )  return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ;buf = mp_buf_new ( L ) ;","if ( nargs == 0 ) return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ;if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."" ) ;buf = mp_buf_new ( L ) ;",504
1919,# undef _  default : switch ( variable & 0xff ) {,_ ( NPNVprivateModeBool ) ;_ ( NPNVsupportsAdvancedKeyHandling ) ;# undef _ default : switch ( variable & 0xff ) {,505
1920,tilebuf = _TIFFmalloc ( tile_buffsize ) ;if ( tilebuf == 0 )  return 0 ;dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ;,"if ( tile_buffsize > 0xFFFFFFFFU - 3 ) {TIFFError ( ""readContigTilesIntoBuffer"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size."" ) ;exit ( - 1 ) ;}tilebuf = _TIFFmalloc ( tile_buffsize + 3 ) ;if ( tilebuf == 0 ) return 0 ;tilebuf [ tile_buffsize ] = 0 ;tilebuf [ tile_buffsize + 1 ] = 0 ;tilebuf [ tile_buffsize + 2 ] = 0 ;dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ;",506
1921,"
","size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;",507
1922,params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,507
1923,"for ( cnt = 0 , i = 0 ;cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;","for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;",508
1924,"
","if ( ( st32 ) verdef -> vd_next < 1 ) {eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\break ;}",508
1925,i += verdef -> vd_next ;},i += verdef -> vd_next ;},508
1926,"( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ;return 1 ;}","return ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ;}",509
1927,"for ( i = 0 ;mechbuf [ i ] ;host = xhash_get ( c2s -> hosts , s -> req_to ) ;","for ( i = 0 ;mechbuf [ i ] ) ;log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf ;host = xhash_get ( c2s -> hosts , s -> req_to ) ;",510
1928,"static int jas_iccputsint ( jas_stream_t * out , int n , longlong val )  {ulonglong tmp ;tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ;","static int jas_iccputsint ( jas_stream_t * out , int n , jas_longlong val ) {ulonglong tmp ;tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ;",511
1929,"size_t buf_size = 0 ;if ( ! sock || ! msg || ( msg -> msg_iovlen && ! msg -> msg_iov ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 )  OE_RAISE_ERRNO ( OE_ENOMEM ) ;{if ( oe_syscall_recvmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen ,  & msg -> msg_namelen ,  buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen ,  & msg -> msg_controllen ,  flags ) != OE_OK ) {if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 )  OE_RAISE_ERRNO ( OE_EINVAL ) ;","size_t buf_size = 0 ;size_t data_size = 0 ;oe_socklen_t namelen_out = 0 ;size_t controllen_out = 0 ;if ( ! sock || ! msg || ( msg -> msg_iovlen && ! msg -> msg_iov ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;{if ( oe_syscall_recvmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , & namelen_out , buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , & controllen_out , flags ) != OE_OK ) {OE_RAISE_ERRNO ( OE_EINVAL ) ;}if ( ! msg -> msg_name ) msg -> msg_namelen = 0 ;else {if ( namelen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( msg -> msg_namelen >= namelen_out ) msg -> msg_namelen = namelen_out ;}if ( ! msg -> msg_control ) msg -> msg_controllen = 0 ;else {if ( msg -> msg_controllen >= controllen_out ) msg -> msg_controllen = controllen_out ;else msg -> msg_flags |= OE_MSG_CTRUNC ;}if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ;",512
1930,"struct usb_serial * serial = port -> serial ;struct usb_serial_port * wport ;wport = serial -> port [ 1 ] ;tty_port_tty_set ( & wport -> port , tty ) ;","
",513
1931,if ( ! handle -> h_transaction ) {err = jbd2_journal_stop ( handle ) ;return handle -> h_err ? handle -> h_err : err ;}sb = handle -> h_transaction -> t_journal -> j_private ;err = handle -> h_err ;,err = handle -> h_err ;if ( ! handle -> h_transaction ) {rc = jbd2_journal_stop ( handle ) ;return err ? err : rc ;}sb = handle -> h_transaction -> t_journal -> j_private ;,514
1932,"if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",515
1933,"char buf [ L_BUF_SIZE ] ;char * cmdname ;# ifndef _WIN32  snprintf ( buf , L_BUF_SIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ;# else  snprintf ( buf , L_BUF_SIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ;# endif # ifndef OS_IOS ignore = system ( buf ) ;","char buf [ L_BUFSIZE ] ;char * cmdname ;# ifndef _WIN32 snprintf ( buf , L_BUFSIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ;# else snprintf ( buf , L_BUFSIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ;# endif # ifndef OS_IOS ignore = system ( buf ) ;",516
1934,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) {",517
1935,"char * * subtreelist = NULL ;char * user = NULL , * subtree = NULL , * principal_dn = NULL ;char * * values = NULL , * strval [ 10 ] = {char * filtuser = NULL ;krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ;char * standalone_principal_dn = NULL ;",char * strval [ 10 ] = {char * filtuser = NULL ;krb5_boolean establish_links = FALSE ;char * standalone_principal_dn = NULL ;,518
1936,"int dnlen = 0 , subtreelen = 0 ;char * dn = NULL ;krb5_boolean outofsubtree = TRUE ;if ( xargs . dn != NULL ) {dn = xargs . dn ;}else if ( xargs . linkdn != NULL ) {dn = xargs . linkdn ;}else if ( standalone_principal_dn != NULL ) {dn = standalone_principal_dn ;}if ( st )  goto cleanup ;}","if ( st ) goto cleanup ;}st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , ntrees ) ;if ( st ) goto cleanup ;}",518
1937,"snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ;st = translate_ldap_error ( st , OP_ADD ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;","snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) goto cleanup ;",518
1938,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 )  return 0 ;if ( error == 0 ) acl = NULL ;","error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ;if ( error ) return error ;",519
1939,bufsize = file -> size ;sc_file_free ( file ) ;,"bufsize = MIN ( file -> size , sizeof buf ) ;sc_file_free ( file ) ;",520
1940,}},"break ;default : fastd_buffer_free ( buffer ) ;pr_debug ( ""received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>unknown<S2SV_blank>address<S2SV_blank>%I"" , remote_addr ) ;}}",521
1941,static LAYER_CONTEXT * get_layer_context ( SVC * svc ) {return svc -> number_temporal_layers > 1 ?  & svc -> layer_context [ svc -> temporal_layer_id ] :  & svc -> layer_context [ svc -> spatial_layer_id ] ;},static LAYER_CONTEXT * get_layer_context ( VP9_COMP * const cpi ) {if ( is_one_pass_cbr_svc ( cpi ) ) return & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers + cpi -> svc . temporal_layer_id ] ;else return ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) ? & cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] : & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] ;},522
1942,void unix_inflight ( struct file * fp )  {,"void unix_inflight ( struct user_struct * user , struct file * fp ) {",523
1943,fp -> f_cred -> user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;,user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;,523
1944,"SCV_NB10_HEADER nb10_hdr ;init_cv_nb10_header ( & nb10_hdr ) ;snprintf ( res -> guidstr , sizeof ( res -> guidstr ) ,  ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ;strncpy ( res -> file_name , ( const char * )  nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ;res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ;","if ( dbg_data_len < 20 ) {eprintf ( ""Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\\return 0 ;}SCV_NB10_HEADER nb10_hdr = {{0 }};init_cv_nb10_header ( & nb10_hdr ) ;snprintf ( res -> guidstr , sizeof ( res -> guidstr ) , ""%x%x"" , nb10_hdr . timestamp , nb10_hdr . age ) ;res -> file_name [ 0 ] = 0 ;if ( nb10_hdr . file_name ) {strncpy ( res -> file_name , ( const char * ) nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ;}res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ;",524
1945,"
",if ( dcfg -> xml_external_entity == NOT_SET ) dcfg -> xml_external_entity = 0 ;,525
1946,},},525
1947,"Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",526
1948,num ++ ;curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ;,"num ++ ;if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) ) ;curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ;",527
1949,"case MFR_CTRL_IE_MAGIC_NUM :  ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ;","case MFR_CTRL_IE_MAGIC_NUM : if ( ie_len != 4 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>length)"" ) ) ;break ;}ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ;",528
1950,}is_request = ( pinfo -> srcport == NO_ENDPOINT ) ;,usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ;}else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) {return 0 ;}is_request = ( pinfo -> srcport == NO_ENDPOINT ) ;,529
1951,port -> exists = true ;mb ( ) ;return 0 ;,spin_lock_irq ( & i8042_lock ) ;port -> exists = true ;spin_unlock_irq ( & i8042_lock ) ;return 0 ;,530
1952,"nl_parse ( pipenum , & config ) ;update_oom_score_adj ( config . oom_score_adj , config . oom_score_adj_len ) ;","if ( ensure_cloned_binary ( ) < 0 ) bail ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>we<S2SV_blank>are<S2SV_blank>a<S2SV_blank>cloned<S2SV_blank>binary"" ) ;nl_parse ( pipenum , & config ) ;update_oom_score_adj ( config . oom_score_adj , config . oom_score_adj_len ) ;",531
1953,"perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS ,  1 , 0 , regs , regs -> cp0_badvaddr ) ;if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ;","perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , regs -> cp0_badvaddr ) ;if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ;",532
1954,case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ;case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ;,case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE | VM_NO_THP ) ) return - EINVAL ;case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE | VM_NO_THP ) ) return - EINVAL ;,533
1955,"rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ;if ( rsrc . type_count < 1 ) {","if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) {psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\\goto parse_rsrc_fork_cleanup ;};rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ;if ( rsrc . type_count < 1 ) {",534
1956,k ++ )  {if ( marker == STR_MARKER ) {,"k ++ ) {if ( rsrc . type_offset + k * 8 > rsrc . rsrc_len ) {psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\\goto parse_rsrc_fork_cleanup ;};if ( marker == STR_MARKER ) {",534
1957,return HTTP_FORBIDDEN ;},"SSL_set_verify ( ssl , verify_old , ssl_callback_SSLVerify ) ;return HTTP_FORBIDDEN ;}",535
1958,"vpx_codec_ctx_t codec = {vpx_codec_enc_cfg_t cfg = {int frame_count = 0 ;vpx_image_t raw = {0 };vpx_codec_err_t res ;VpxVideoInfo info = {0 };VpxVideoWriter * writer = NULL ;if ( argc != 6 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments"" ) ;encoder = get_vpx_encoder_by_name ( argv [ 1 ] ) ;if ( ! encoder )   die ( ""Unsupported<S2SV_blank>codec."" ) ;info . codec_fourcc = encoder -> fourcc ;","vpx_codec_ctx_t codec ;vpx_codec_enc_cfg_t cfg = {int frame_count = 0 ;vpx_image_t raw ;vpx_codec_err_t res ;VpxVideoInfo info = {VpxVideoWriter * writer = NULL ;if ( encoder == NULL ) {die ( ""Unsupported<S2SV_blank>codec."" ) ;}assert ( encoder != NULL ) ;info . codec_fourcc = encoder -> fourcc ;",536
1959,"printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ;if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ;","printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ;if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ;",536
1960,"if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;else if ( frame_count == 33 ) {encode_frame ( & codec , & raw , frame_count , writer ) ;encode_frame ( & codec , NULL , - 1 , writer ) ;printf ( ""\\\","if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;while ( else if ( frame_count == 33 ) {encode_frame ( & codec , & raw , frame_count , writer ) ) {printf ( ""\\\",536
1961,if ( vcpu -> arch . time_page ) {kvm_release_page_dirty ( vcpu -> arch . time_page ) ;vcpu -> arch . time_page = NULL ;},vcpu -> arch . pv_time_enabled = false ;,537
1962,void close_connection ( h2o_http2_conn_t * conn )  {}},int close_connection ( h2o_http2_conn_t * conn ) {return - 1 ;}return 0 ;},538
1963,"avio_skip ( pb , 4 ) ;avio_skip ( pb , 4 ) ;","int ret ;avio_skip ( pb , 4 ) ;avio_skip ( pb , 4 ) ;",539
1964,"strncpy ( codec_name , val , sizeof ( codec_name ) - 1 ) ;","ret = strncpy ( codec_name , val , sizeof ( codec_name ) - 1 ) ;",539
1965,"sscanf ( val , ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ,  & header_key_part [ 0 ] , & header_key_part [ 1 ] , & header_key_part [ 2 ] , & header_key_part [ 3 ] ) ;for ( idx = 0 ;AV_WB32 ( & header_key [ idx * 4 ] , header_key_part [ idx ] ) ;","sscanf ( val , ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 , & header_key_part [ 0 ] , & header_key_part [ 1 ] , & header_key_part [ 2 ] , & header_key_part [ 3 ] ) ;if ( ret != 4 ) return AVERROR_INVALIDDATA ;for ( idx = 0 ;AV_WB32 ( & header_key [ idx * 4 ] , header_key_part [ idx ] ) ;",539
1966,"static size_t read_uncompressed_header ( VP9Decoder * pbi ,  struct vp9_read_bit_buffer * rb ) {VP9_COMMON * const cm = & pbi -> common ;size_t sz ;int i ;cm -> last_frame_type = cm -> frame_type ;if ( vp9_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER )  vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>marker"" ) ;cm -> profile = read_profile ( rb ) ;if ( cm -> profile >= MAX_PROFILES ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ;cm -> show_existing_frame = vp9_rb_read_bit ( rb ) ;if ( cm -> show_existing_frame ) {const int frame_to_show = cm -> ref_frame_map [ vp9_rb_read_literal ( rb , 3 ) ] ;if ( cm -> frame_bufs [ frame_to_show ] . ref_count < 1 )  vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Buffer<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>decoded<S2SV_blank>frame"" , frame_to_show ) ;ref_cnt_fb ( cm -> frame_bufs , & cm -> new_fb_idx , frame_to_show ) ;pbi -> refresh_frame_flags = 0 ;return 0 ;}cm -> frame_type = ( FRAME_TYPE ) vp9_rb_read_bit ( rb ) ;cm -> show_frame = vp9_rb_read_bit ( rb ) ;cm -> error_resilient_mode = vp9_rb_read_bit ( rb ) ;if ( cm -> frame_type == KEY_FRAME ) {check_sync_code ( cm , rb ) ;if ( cm -> profile > PROFILE_1 ) cm -> bit_depth = vp9_rb_read_bit ( rb ) ? BITS_12 : BITS_10 ;cm -> color_space = ( COLOR_SPACE ) vp9_rb_read_literal ( rb , 3 ) ;if ( cm -> color_space != SRGB ) {vp9_rb_read_bit ( rb ) ;if ( cm -> profile >= PROFILE_1 ) {cm -> subsampling_x = vp9_rb_read_bit ( rb ) ;cm -> subsampling_y = vp9_rb_read_bit ( rb ) ;vp9_rb_read_bit ( rb ) ;else {cm -> subsampling_y = cm -> subsampling_x = 1 ;else {if ( cm -> profile >= PROFILE_1 ) {cm -> subsampling_y = cm -> subsampling_x = 0 ;vp9_rb_read_bit ( rb ) ;}else {vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM ,  ""RGB<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>0"" ) ;}cm -> frame_refs [ i ] . idx = cm -> new_fb_idx ;cm -> frame_refs [ i ] . buf = get_frame_new_buffer ( cm ) ;}setup_frame_size ( cm , rb ) ;}cm -> intra_only = cm -> show_frame ? 0 : vp9_rb_read_bit ( rb ) ;cm -> reset_frame_context = cm -> error_resilient_mode ?  0 : vp9_rb_read_literal ( rb , 2 ) ;if ( cm -> intra_only ) {check_sync_code ( cm , rb ) ;pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ;setup_frame_size ( cm , rb ) ;}pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ;for ( i = 0 ;const int ref = vp9_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ;const int idx = cm -> ref_frame_map [ ref ] ;cm -> frame_refs [ i ] . idx = idx ;cm -> frame_refs [ i ] . buf = & cm -> frame_bufs [ idx ] . buf ;cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vp9_rb_read_bit ( rb ) ;}cm -> allow_high_precision_mv = vp9_rb_read_bit ( rb ) ;cm -> interp_filter = read_interp_filter ( rb ) ;vp9_setup_scale_factors_for_frame ( & ref_buf -> sf ,  ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height ,  cm -> width , cm -> height ) ;if ( vp9_is_scaled ( & ref_buf -> sf ) )   vp9_extend_frame_borders ( ref_buf -> buf ) ;}cm -> coding_use_prev_mi = 1 ;cm -> refresh_frame_context = vp9_rb_read_bit ( rb ) ;cm -> frame_parallel_decoding_mode = vp9_rb_read_bit ( rb ) ;cm -> coding_use_prev_mi = 0 ;cm -> refresh_frame_context = 0 ;}cm -> frame_context_idx = vp9_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ;setup_tile_info ( cm , rb ) ;sz = vp9_rb_read_literal ( rb , 16 ) ;if ( sz == 0 ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ;","static size_t read_uncompressed_header ( VP9Decoder * pbi , struct vpx_read_bit_buffer * rb ) {VP9_COMMON * const cm = & pbi -> common ;BufferPool * const pool = cm -> buffer_pool ;RefCntBuffer * const frame_bufs = pool -> frame_bufs ;int i , mask , ref_index = 0 ;size_t sz ;cm -> last_frame_type = cm -> frame_type ;if ( vp9_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid<S2SV_blank>frame<S2SV_blank>marker"" ) ;cm -> profile = vp9_read_profile ( rb ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> profile >= MAX_PROFILES ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ;# else if ( cm -> profile >= PROFILE_2 ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Unsupported<S2SV_blank>bitstream<S2SV_blank>profile"" ) ;# endif cm -> show_existing_frame = vpx_rb_read_bit ( rb ) ;if ( cm -> show_existing_frame ) {const int frame_to_show = cm -> ref_frame_map [ vpx_rb_read_literal ( rb , 3 ) ] ;lock_buffer_pool ( pool ) ;if ( frame_to_show < 0 || frame_bufs [ frame_to_show ] . ref_count < 1 ) {unlock_buffer_pool ( pool ) ;vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Buffer<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>decoded<S2SV_blank>frame"" , frame_to_show ) ;}ref_cnt_fb ( frame_bufs , & cm -> new_fb_idx , frame_to_show ) ;unlock_buffer_pool ( pool ) ;pbi -> refresh_frame_flags = 0 ;if ( pbi -> frame_parallel_decode ) {for ( i = 0 ;i < REF_FRAMES ;++ i ) cm -> next_ref_frame_map [ i ] = cm -> ref_frame_map [ i ] ;return 0 ;cm -> frame_type = ( FRAME_TYPE ) vpx_rb_read_bit ( rb ) ;cm -> show_frame = vpx_rb_read_bit ( rb ) ;cm -> error_resilient_mode = vpx_rb_read_bit ( rb ) ;if ( cm -> frame_type == KEY_FRAME ) {if ( ! vp9_read_sync_code ( rb ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""RGB<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>0"" ) ;cm -> frame_refs [ i ] . idx = cm -> new_fb_idx ;cm -> frame_refs [ i ] . buf = get_frame_new_buffer ( cm ) ;}setup_frame_size ( cm , rb ) ;}cm -> intra_only = cm -> show_frame ? 0 : vp9_rb_read_bit ( rb ) ;cm -> reset_frame_context = cm -> error_resilient_mode ? 0 : vp9_rb_read_literal ( rb , 2 ) ;if ( cm -> intra_only ) {check_sync_code ( cm , rb ) ;pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ;setup_frame_size ( cm , rb ) ;}pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ;for ( i = 0 ;const int ref = vp9_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ;const int idx = cm -> ref_frame_map [ ref ] ;cm -> frame_refs [ i ] . idx = INVALID_IDX ;cm -> frame_refs [ i ] . buf ;cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vp9_rb_read_bit ( rb ) ;if ( pbi -> need_resync ) {memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ;pbi -> need_resync = 0 ;}}cm -> allow_high_precision_mv = vpx_rb_read_bit ( rb ) ;cm -> interp_filter = read_interp_filter ( rb ) ;# if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , ref_buf -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , cm -> width , cm -> height , cm -> use_highbitdepth ) ;# else vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , ref_buf -> buf ) ;}cm -> refresh_frame_context = vpx_rb_read_bit ( rb ) ;cm -> frame_parallel_decoding_mode = vpx_rb_read_bit ( rb ) ;cm -> refresh_frame_context = 0 ;}cm -> frame_context_idx = vpx_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ;lock_buffer_pool ( pool ) ;for ( mask = pbi -> refresh_frame_flags ;mask ;mask >>= 1 ) {if ( mask & 1 ) {cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ;}if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ;++ ref_index ;}for ( ;ref_index < REF_FRAMES ;++ ref_index ) {cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ;if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ;}unlock_buffer_pool ( pool ) ;pbi -> hold_ref_buf = 1 ;setup_segmentation_dequant ( cm ) ;setup_tile_info ( cm , rb ) ;sz = vpx_rb_read_literal ( rb , 16 ) ;if ( sz == 0 ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Invalid<S2SV_blank>header<S2SV_blank>size"" ) ;",540
1967,"break ;case PT_RREQ : if ( wb_rreq ( ndo , ( const struct pkt_rreq * ) ( ph + 1 ) , len ) >= 0 ) return ;break ;case PT_RREP : if ( wb_rrep ( ndo , ( const struct pkt_rrep * ) ( ph + 1 ) , len ) >= 0 ) return ;break ;case PT_DRAWOP : if ( wb_drawop ( ndo , ( const struct pkt_dop * ) ( ph + 1 ) , len ) >= 0 ) return ;break ;case PT_PREQ : if ( wb_preq ( ndo , ( const struct pkt_preq * ) ( ph + 1 ) , len ) >= 0 ) return ;break ;case PT_PREP : if ( wb_prep ( ndo , ( const struct pkt_prep * ) ( ph + 1 ) , len ) >= 0 )  return ;break ;","ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_RREQ : if ( wb_rreq ( ndo , ( const struct pkt_rreq * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_RREP : if ( wb_rrep ( ndo , ( const struct pkt_rrep * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_DRAWOP : if ( wb_drawop ( ndo , ( const struct pkt_dop * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_PREQ : if ( wb_preq ( ndo , ( const struct pkt_preq * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_PREP : if ( wb_prep ( ndo , ( const struct pkt_prep * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;",541
1968,if ( tu -> timeri )   snd_timer_close ( tu -> timeri ) ;kfree ( tu -> queue ) ;,mutex_lock ( & tu -> ioctl_lock ) ;if ( tu -> timeri ) ;mutex_unlock ( & tu -> ioctl_lock ) snd_timer_close ( tu -> timeri ) ;kfree ( tu -> queue ) ;,542
1969,"if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) {fprintf ( tf , ""%d\\\","if ( ( tf = fopen_safe ( tfile -> file_path , ""w"" ) ) ) {fprintf ( tf , ""%d\\\",543
1970,kfree ( user ) ;},cleanup_srcu_struct ( & user -> release_barrier ) ;kfree ( user ) ;},544
1971,int blockstodecode ;av_assert0 ( s -> samples >= 0 ) ;,int blockstodecode ;uint64_t decoded_buffer_size ;av_assert0 ( s -> samples >= 0 ) ;,545
1972,"if ( ! nblocks || nblocks > INT_MAX ) {av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\\","if ( ! nblocks || nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 ) {av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\\",545
1973,"av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size ,   2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ;if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ;","decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ;av_assert0 ( decoded_buffer_size <= INT_MAX ) ;av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , decoded_buffer_size ) ;if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ;",545
1974,if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal )  return 0 ;,if ( ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS ) ) return 0 ;,546
1975,signed long personality ;if ( ! options ) options = & attach_static_default_options ;,int procfd ;signed long personality ;if ( ! options ) options = & attach_static_default_options ;,547
1976,"
","procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ;shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ;rexit ( - 1 ) ;}",547
1977,"ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ;if ( ret < 0 ) {","ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ;if ( ret < 0 ) {",547
1978,". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function ,  . exec_payload = exec_payload  }",". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload , . procfd = procfd }",547
1979,"static void fdct4 ( const int16_t * input , int16_t * output ) {int16_t step [ 4 ] ;int temp1 , temp2 ;step [ 0 ] = input [ 0 ] + input [ 3 ] ;step [ 1 ] = input [ 1 ] + input [ 2 ] ;step [ 2 ] = input [ 1 ] - input [ 2 ] ;step [ 3 ] = input [ 0 ] - input [ 3 ] ;temp1 = ( step [ 0 ] + step [ 1 ] ) * cospi_16_64 ;temp2 = ( step [ 0 ] - step [ 1 ] ) * cospi_16_64 ;output [ 0 ] = fdct_round_shift ( temp1 ) ;output [ 2 ] = fdct_round_shift ( temp2 ) ;output [ 1 ] = fdct_round_shift ( temp1 ) ;output [ 3 ] = fdct_round_shift ( temp2 ) ;","static void fdct4 ( const tran_low_t * input , int16_t * output ) {tran_high_t step [ 4 ] ;int temp1 , temp2 ;step [ 0 ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ;output [ 2 ] = ( tran_low_t ) fdct_round_shift ( temp2 ) ;output [ 1 ] = fdct_round_shift ( temp1 ) ;output [ 3 ] = fdct_round_shift ( temp2 ) ;",548
1980,char buf [ L_BUF_SIZE ] ;l_int32 badchar ;,char buf [ L_BUFSIZE ] ;l_int32 badchar ;,549
1981,"snprintf ( buf , L_BUF_SIZE , ""%s.cmd"" , rootname ) ;gplot -> cmdname = stringNew ( buf ) ;if ( outformat == GPLOT_PNG )  snprintf ( buf , L_BUF_SIZE , ""%s.png"" , newroot ) ;else if ( outformat == GPLOT_PS )  snprintf ( buf , L_BUF_SIZE , ""%s.ps"" , newroot ) ;else if ( outformat == GPLOT_EPS )  snprintf ( buf , L_BUF_SIZE , ""%s.eps"" , newroot ) ;else if ( outformat == GPLOT_LATEX )  snprintf ( buf , L_BUF_SIZE , ""%s.tex"" , newroot ) ;gplot -> outname = stringNew ( buf ) ;","snprintf ( buf , L_BUFSIZE , ""%s.cmd"" , rootname ) ;gplot -> cmdname = stringNew ( buf ) ;if ( outformat == GPLOT_PNG ) snprintf ( buf , L_BUFSIZE , ""%s.png"" , newroot ) ;else if ( outformat == GPLOT_PS ) snprintf ( buf , L_BUFSIZE , ""%s.ps"" , newroot ) ;else if ( outformat == GPLOT_EPS ) snprintf ( buf , L_BUFSIZE , ""%s.eps"" , newroot ) ;else if ( outformat == GPLOT_LATEX ) snprintf ( buf , L_BUFSIZE , ""%s.tex"" , newroot ) ;gplot -> outname = stringNew ( buf ) ;",549
1982,if ( tlen < 1 ) {,if ( tlen < 1U + 1 ) {,550
1983,if ( tlen < oid_len ) {return 0 ;,if ( tlen < oid_len ) {return 0 ;,550
1984,"client -> auth_end_offset = AUTH_END_INIT_OFFSET ;client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ;","client -> auth_buffer = g_byte_array_new ( ) ;client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ;",551
1985,void usage_exit ( ) {int i ;,void usage_exit ( void ) {int i ;,552
1986,"fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\\}","fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\\}",552
1987,"if ( ( read = recv ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 )  {","if ( ( read = TEMP_FAILURE_RETRY ( recv ( fd , p , len , MSG_NOSIGNAL ) ) ) == - 1 ) {",553
1988,"YV12_BUFFER_CONFIG * lst_yv12 =  & cpi -> common . yv12_fb [ cpi -> common . lst_fb_idx ] ;double dr = ( double ) cpi -> bytes_in_layer [ i ] * 8.0 / 1000.0 / time_encoded ;double samples = 3.0 / 2 * cpi -> frames_in_layer [ i ] *  lst_yv12 -> y_width * lst_yv12 -> y_height ;double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_error2 [ i ] ) ;double samples = 3.0 / 2 * cpi -> count *  lst_yv12 -> y_width * lst_yv12 -> y_height ;double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_sq_error ) ;","double dr = ( double ) cpi -> bytes_in_layer [ i ] * cpi -> common . Width * cpi -> common . Height ;double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_error2 [ i ] ) ;double samples = 3.0 / 2 * cpi -> count * cpi -> common . Width * cpi -> common . Height ;double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_sq_error ) ;",554
1989,vp8_remove_common ( & cpi -> common ) ;vpx_free ( cpi ) ;# endif  # if 0  if ( keyfile ) fclose ( keyfile ) ;,vpx_free ( cpi -> consec_zero_last ) ;vpx_free ( cpi -> consec_zero_last_mvbias ) ;vp8_remove_common ( & cpi -> common ) ;vpx_free ( cpi ) ;# endif # ifdef OUTPUT_YUV_DENOISED fclose ( yuv_denoised_file ) ;# endif # if 0 if ( keyfile ) fclose ( keyfile ) ;,554
1990,static void init_decoder ( vpx_codec_alg_priv_t * ctx ) {VP9D_CONFIG oxcf ;oxcf . width = ctx -> si . w ;oxcf . height = ctx -> si . h ;oxcf . version = 9 ;oxcf . max_threads = ctx -> cfg . threads ;oxcf . inv_tile_order = ctx -> invert_tile_order ;ctx -> pbi = vp9_decoder_create ( & oxcf ) ;if ( ctx -> pbi == NULL )  return ;vp9_initialize_dec ( ) ;},"static vpx_codec_err_t init_decoder ( vpx_codec_alg_priv_t * ctx ) {int i ;const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ;ctx -> last_show_frame = - 1 ;ctx -> next_submit_worker_id = 0 ;ctx -> last_submit_worker_id = 0 ;ctx -> next_output_worker_id = 0 ;ctx -> frame_cache_read = 0 ;ctx -> frame_cache_write = 0 ;ctx -> num_cache_frames = 0 ;ctx -> need_resync = 1 ;ctx -> num_frame_workers = ( ctx -> frame_parallel_decode == 1 ) ? ctx -> cfg . threads : 1 ;if ( ctx -> num_frame_workers > MAX_DECODE_THREADS ) ctx -> num_frame_workers = MAX_DECODE_THREADS ;ctx -> available_threads = ctx -> num_frame_workers ;ctx -> flushed = 0 ;ctx -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ;if ( ctx -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ;# if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & ctx -> buffer_pool -> pool_mutex , NULL ) ) {set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>pool<S2SV_blank>mutex"" ) ;return VPX_CODEC_MEM_ERROR ;}# endif ctx -> frame_workers = ( VPxWorker * ) vpx_malloc ( ctx -> num_frame_workers * sizeof ( * ctx -> frame_workers ) ) ;if ( ctx -> frame_workers == NULL ) {set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_workers"" ) ;return VPX_CODEC_MEM_ERROR ;}for ( i = 0 ;i < ctx -> num_frame_workers ;++ i ) {VPxWorker * const worker = & ctx -> frame_workers [ i ] ;FrameWorkerData * frame_worker_data = NULL ;winterface -> init ( worker ) ;worker -> data1 = vpx_memalign ( 32 , sizeof ( FrameWorkerData ) ) ;if ( worker -> data1 == NULL ) {set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data"" ) ;return VPX_CODEC_MEM_ERROR ;}frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;frame_worker_data -> pbi = vp9_decoder_create ( ctx -> buffer_pool ) ;if ( frame_worker_data -> pbi == NULL ) {set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data"" ) ;return VPX_CODEC_MEM_ERROR ;}frame_worker_data -> pbi -> frame_worker_owner = worker ;frame_worker_data -> worker_id = i ;frame_worker_data -> scratch_buffer = NULL ;frame_worker_data -> scratch_buffer_size = 0 ;frame_worker_data -> frame_context_ready = 0 ;frame_worker_data -> received_frame = 0 ;# if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & frame_worker_data -> stats_mutex , NULL ) ) {set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>mutex"" ) ;return VPX_CODEC_MEM_ERROR ;}if ( pthread_cond_init ( & frame_worker_data -> stats_cond , NULL ) ) {set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>cond"" ) ;return VPX_CODEC_MEM_ERROR ;}# endif frame_worker_data -> pbi -> max_threads = ( ctx -> frame_parallel_decode == 0 ) ? ctx -> cfg . threads : 0 ;frame_worker_data -> pbi -> inv_tile_order = ctx -> invert_tile_order ;frame_worker_data -> pbi -> frame_parallel_decode = ctx -> frame_parallel_decode ;frame_worker_data -> pbi -> common . frame_parallel_decode = ctx -> frame_parallel_decode ;worker -> hook = ( VPxWorkerHook ) frame_worker_hook ;if ( ! winterface -> reset ( worker ) ) {set_error_detail ( ctx , ""Frame<S2SV_blank>Worker<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ;return VPX_CODEC_MEM_ERROR ;}}return VPX_CODEC_OK ;}",555
1991,"static int  mptctl_eventreport ( unsigned long arg )  {MPT_ADAPTER * ioc ;int iocnum ;return - EFAULT ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventreport()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;","static int mptctl_eventreport ( MPT_ADAPTER * ioc , unsigned long arg ) {return - EFAULT ;",556
1992,"char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}return - EIO ;}return snprintf ( buf , PAGE_SIZE , ""%d\\\","char * data ;data = kmalloc ( 8 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}ret = - EIO ;goto out ;}ret = snprintf ( buf , PAGE_SIZE , ""%d\\\out : kfree ( data ) ;return ret ;",557
1993,int r = - ENOTTY ;,int r = - EINVAL ;if ( atomic_read ( & kvm -> online_vcpus ) ) goto create_irqchip_unlock ;r = - ENOTTY ;,558
1994,r = - ENOMEM ;vpic = kvm_create_pic ( kvm ) ;,r = - ENOMEM ;vpic = kvm_create_pic ( kvm ) ;,558
1995,if ( node -> v == & node -> sorted )  {tr_free ( node -> sorted . val . l . vals ) ;}},TR_ASSERT ( node != NULL ) ;if ( node -> sorted != NULL ) {tr_free ( node -> sorted . val . l . vals ) ;tr_free ( node -> sorted ) ;}},559
1996,params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;",560
1997,"if ( fscanf ( fp , ""\\\if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( ""invalid<S2SV_blank>pta<S2SV_blank>version"" , procName , NULL ) ;if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\\","if ( fscanf ( fp , ""<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\\",561
1998,"r_return_val_if_fail ( arg , NULL ) ;char * a = malloc ( strlen ( arg ) + 1 ) ;if ( ! a ) {return NULL ;}char * b = a ;while ( * arg ) {switch ( * arg ) {case '@' : case '`' : case '|' : case ';' :  case '\\\default :  * b ++ = * arg ;break ;",char ch = * arg ;switch ( ch ) {case '@' : case '`' : case '|' : case ';' : case '=' : case '\\\default : * b ++ = * arg ;break ;,562
1999,"if ( count != ( ssize_t ) length )  ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ;","if ( count != ( ssize_t ) length ) {quantum_info = DestroyQuantumInfo ( quantum_info ) ;ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;}( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ;",563
2000,return in ;},return NULL ;},564
2001,"if ( setpwnam ( pw ) < 0 )  err ( EXIT_FAILURE , _ ( ""setpwnam<S2SV_blank>failed\\\","if ( setpwnam ( pw , "".chsh"" ) < 0 ) err ( EXIT_FAILURE , _ ( ""setpwnam<S2SV_blank>failed\\\",565
2002,"diff = ndpi_min ( packet -> payload_packet_len - a1 , sizeof ( flow -> initial_binary_bytes ) ) ;if ( diff > 0 ) {memcpy ( & flow -> initial_binary_bytes , & packet -> payload [ a1 ] , diff ) ;","diff = packet -> payload_packet_len - a1 , sizeof ( flow -> initial_binary_bytes ) ) ;if ( diff > 0 ) {diff = ndpi_min ( diff , sizeof ( flow -> initial_binary_bytes ) ) ;memcpy ( & flow -> initial_binary_bytes , & packet -> payload [ a1 ] , diff ) ;",566
2003,"if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) {return NULL ;ut32 len = sec -> payload_len ;ut32 count = sec -> count ;while ( i < len && r < count ) {if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) {return ret ;if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) {free ( ptr ) ;return ret ;if ( ! ( n = consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) {free ( ptr ) ;return ret ;free ( ptr ) ;return ret ;}","ut32 len = sec -> payload_len ;if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) {return NULL ;int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ;ut32 count = sec -> count ;while ( i < len && len < buflen && r < count ) {if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) {goto beach ;if ( i + 4 >= buflen ) {goto beach ;if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) {goto beach ;free ( ptr ) ;return ret ;beach : free ( ptr ) ;return ret ;}",567
2004,if ( string -> space == 0 )  string -> space = 1 ;else  string -> space *= 2 ;if ( string -> space < 0 )  {new_len = string -> space = G_MAXINT - 8 ;},"if ( string -> space == 0 ) {string -> space = 4 ;}else {const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ;guint more_space = ( guint ) string -> space * 2 ;if ( string -> space < 0 ) {new_len = string -> space = more_space ;}",568
2005,"if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) {return NULL ;ut32 len = sec -> payload_len ;ut32 count = sec -> count ;while ( i < len && r < count ) {if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) {return ret ;if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) {free ( ptr ) ;return ret ;if ( ! ( n = consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) {free ( ptr ) ;return ret ;free ( ptr ) ;return ret ;}","ut32 len = sec -> payload_len ;if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) {return NULL ;int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ;ut32 count = sec -> count ;while ( i < len && len < buflen && r < count ) {if ( ! ( ptr = R_NEW0 ( RBinWasmDataEntry ) ) ) {goto beach ;if ( i + 4 >= buflen ) {goto beach ;if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) {goto beach ;free ( ptr ) ;return ret ;beach : free ( ptr ) ;return ret ;}",569
2006,ufs -> upper_mnt = clone_private_mount ( & upperpath ) ;err = PTR_ERR ( ufs -> upper_mnt ) ;,"sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ;err = - EINVAL ;if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) {pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\\goto out_put_workpath ;}ufs -> upper_mnt = clone_private_mount ( & upperpath ) ;err = PTR_ERR ( ufs -> upper_mnt ) ;",570
2007,"if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;","if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;return 1 ;}if ( vmx_get_cpl ( vcpu ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;",571
2008,"r = verify_vc_device ( fd ) ;r = verify_vc_kbmode ( fd ) ;if ( r < 0 ) return log_error_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , src_vc ) ;","r = vt_verify_kbmode ( fd ) ;r = verify_vc_kbmode ( fd ) ;if ( r < 0 ) return log_error_errno ( r , ""Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m"" , src_vc ) ;",572
2009,"static void  ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ;}ptr = cp [ 2 ] - 1 ;len = 0 ;switch ( cp [ 3 ] & 0xF ) {case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ;","static int ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) {return ( 0 ) ;}ND_TCHECK ( cp [ 2 ] ) ;ND_TCHECK ( cp [ 3 ] ) ;ptr = cp [ 2 ] - 1 ;len = 0 ;switch ( cp [ 3 ] & 0xF ) {case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , ""TSONLY"" ) ) ;",573
2010,"if ( ptr == len )  type = ""<S2SV_blank>^<S2SV_blank>"" ;ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ;","if ( ptr == len ) type = ""<S2SV_blank>^<S2SV_blank>"" ;ND_TCHECK2 ( cp [ len ] , hoplen ) ;ND_PRINT ( ( ndo , ""%s%d@%s"" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? """" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ;return ( 0 ) ;trunc : return ( - 1 ) ;",573
2011,},},573
2012,"struct sctp_endpoint * ep ;struct sctp_association * asoc ;struct list_head * pos , * temp ;unsigned int data_was_unread ;pr_debug ( ""%s:<S2SV_blank>sk:%p,<S2SV_blank>timeout:%ld\\\lock_sock ( sk ) ;sk -> sk_shutdown = SHUTDOWN_MASK ;sk -> sk_state = SCTP_SS_CLOSING ;ep = sctp_sk ( sk ) -> ep ;data_was_unread = sctp_queue_purge_ulpevents ( & sk -> sk_receive_queue ) ;data_was_unread += sctp_queue_purge_ulpevents ( & sctp_sk ( sk ) -> pd_lobby ) ;list_for_each_safe ( pos , temp , & ep -> asocs ) {asoc = list_entry ( pos , struct sctp_association , asocs ) ;if ( sctp_style ( sk , TCP ) ) {if ( sctp_state ( asoc , CLOSED ) ) {sctp_unhash_established ( asoc ) ;sctp_association_free ( asoc ) ;continue ;}}if ( data_was_unread || ! skb_queue_empty ( & asoc -> ulpq . lobby ) || ! skb_queue_empty ( & asoc -> ulpq . reasm ) || ( sock_flag ( sk , SOCK_LINGER ) && ! sk -> sk_lingertime ) ) {struct sctp_chunk * chunk ;chunk = sctp_make_abort_user ( asoc , NULL , 0 ) ;if ( chunk ) sctp_primitive_ABORT ( net , asoc , chunk ) ;}else sctp_primitive_SHUTDOWN ( net , asoc , NULL ) ;}if ( sctp_style ( sk , TCP ) && timeout ) sctp_wait_for_close ( sk , timeout ) ;release_sock ( sk ) ;local_bh_disable ( ) ;bh_lock_sock ( sk ) ;local_bh_enable ( ) ;sock_put ( sk ) ;",spin_lock_bh ( & net -> sctp . addr_wq_lock ) ;bh_lock_sock ( sk ) ;local_bh_enable ( ) ;sock_put ( sk ) ;,574
2013,"hlist_add_head ( & mp -> mglist , & br -> mglist ) ;mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ;","if ( hlist_unhashed ( & mp -> mglist ) ) hlist_add_head ( & mp -> mglist , & br -> mglist ) ;mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ;",575
2014,vt -> allocator = funcs ;vt -> allocdata = allocdata ;,if ( vt == NULL ) return NULL ;vt -> allocator = funcs ;vt -> allocdata = allocdata ;,576
2015,"vt -> outbuffer_len = 200 ;vt -> outbuffer_cur = 0 ;vt -> outbuffer = vterm_allocator_malloc ( vt , vt -> outbuffer_len ) ;return vt ;","if ( vt -> parser . strbuffer == NULL ) {vterm_allocator_free ( vt , vt ) ;return NULL ;}vt -> outbuffer_len = 200 ;vt -> outbuffer_cur = 0 ;vt -> outbuffer = vterm_allocator_malloc ( vt , vt -> outbuffer_len ) ;if ( vt -> outbuffer == NULL ) {vterm_allocator_free ( vt , vt -> parser . strbuffer ) ;vterm_allocator_free ( vt , vt ) ;return NULL ;}return vt ;",576
2016,"struct ext4_extent * ex , newex , orig_ex ;struct ext4_extent * ex1 = NULL ;struct ext4_extent * ex2 = NULL ;struct ext4_extent * ex3 = NULL ;ext4_lblk_t ee_block , eof_block ;unsigned int allocated , ee_len , depth ;ext4_fsblk_t newblock ;","ext4_lblk_t eof_block ;ext4_lblk_t ee_block ;struct ext4_extent * ex ;unsigned int allocated , ee_len , depth ;ext4_fsblk_t newblock ;",577
2017,"allocated = ee_len - ( map -> m_lblk - ee_block ) ;newblock = map -> m_lblk - ee_block + ext4_ext_pblock ( ex ) ;ex2 = ex ;orig_ex . ee_block = ex -> ee_block ;orig_ex . ee_len = cpu_to_le16 ( ee_len ) ;ext4_ext_store_pblock ( & orig_ex , ext4_ext_pblock ( ex ) ) ;may_zeroout = ee_block + ee_len <= eof_block ;if ( ( map -> m_lblk == ee_block ) && ( allocated <= map -> m_len ) ) return allocated ;err = ext4_ext_get_access ( handle , inode , path + depth ) ;if ( err ) goto out ;","split_flag |= ee_block + ee_len <= eof_block ;if ( ( map -> m_lblk == ee_block ) && ( allocated <= map -> m_len ) ) return allocated ;err = ext4_ext_get_access ( handle , inode , path + depth ) ;if ( err ) goto out ;",577
2018,"err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ;if ( err == - ENOSPC && may_zeroout ) {","err = ext4_ext_insert_extent ( handle , inode , path , ex3 , flags ) ;if ( err == - ENOSPC && may_zeroout ) {",577
2019,"may_zeroout = ee_block + ee_len <= eof_block ;depth = newdepth ;ext4_ext_drop_refs ( path ) ;path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ;if ( IS_ERR ( path ) ) {err = PTR_ERR ( path ) ;goto out ;}ex = path [ depth ] . p_ext ;if ( ex2 != & newex ) ex2 = ex ;err = ext4_ext_get_access ( handle , inode , path + depth ) ;","may_zeroout = ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ;split_flag |= EXT4_EXT_MARK_UNINIT2 ;flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path + depth ) ;",577
2020,"err = ext4_ext_dirty ( handle , inode , path + depth ) ;ext_debug ( ""out<S2SV_blank>here\\\goto out ;insert : err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ;if ( err == - ENOSPC && may_zeroout ) {err = ext4_ext_zeroout ( inode , & orig_ex ) ;if ( err ) goto fix_extent_len ;ex -> ee_block = orig_ex . ee_block ;ex -> ee_len = orig_ex . ee_len ;ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ;ext4_ext_dirty ( handle , inode , path + depth ) ;return allocated ;}else if ( err ) goto fix_extent_len ;out : ext4_ext_show_leaf ( inode , path ) ;return err ? err : allocated ;fix_extent_len : ex -> ee_block = orig_ex . ee_block ;ex -> ee_len = orig_ex . ee_len ;ext4_ext_store_pblock ( ex , ext4_ext_pblock ( & orig_ex ) ) ;ext4_ext_mark_uninitialized ( ex ) ;ext4_ext_dirty ( handle , inode , path + depth ) ;return err ;","err = ext4_ext_dirty ( handle , inode , path , map , split_flag , flags ) ;",577
2021,"# ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds ,  encT ) ;# elif defined ( USE_ARM_ASM )  return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ;# else return do_encrypt_fn ( ctx , bx , ax ) ;","# ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , enc_tables . T ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , enc_tables . T ) ;# else return do_encrypt_fn ( ctx , bx , ax ) ;",578
2022,"static void show_object ( struct object * obj ,  struct strbuf * path , const char * component ,  void * cb_data ) {finish_object ( obj , path , component , cb_data ) ;if ( info -> flags & REV_LIST_QUIET ) return ;show_object_with_name ( stdout , obj , path , component ) ;}","static void show_object ( struct object * obj , const char * component , void * cb_data ) {finish_object ( obj , name , cb_data ) ;if ( info -> flags & REV_LIST_QUIET ) return ;show_object_with_name ( stdout , obj , name ) ;}",579
2023,"if ( rt -> rt_flags & RTCF_NOTIFY )  r -> rtm_flags |= RTM_F_NOTIFY ;if ( nla_put_be32 ( skb , RTA_DST , dst ) ) goto nla_put_failure ;","if ( rt -> rt_flags & RTCF_NOTIFY ) r -> rtm_flags |= RTM_F_NOTIFY ;if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT ;if ( nla_put_be32 ( skb , RTA_DST , dst ) ) goto nla_put_failure ;",580
2024,"SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ;# ifdef HAVE_X509_CHECK_HOST  if ( X509_check_host ( cert , common_name , FIELD_SIZE , 0 , NULL ) )  cert_valid = 1 ;","SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) == 1 ;# ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , common_name , FIELD_SIZE , 0 , NULL ) ) cert_valid = 1 ;",581
2025,"static inline bool unconditional ( const struct ipt_ip * ip )  {return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ;# undef FWINV }","static inline bool unconditional ( const struct ipt_entry * e ) {return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> ip , & uncond , sizeof ( uncond ) ) == 0 ;# undef FWINV }",582
2026,return 0 ;},av_freep ( & x -> buf ) ;x -> buf_size = 0 ;return 0 ;},583
2027,"u64 nsec = ( u64 ) jiffies * TICK_NSEC ;long tv_usec ;value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ;tv_usec /= NSEC_PER_USEC ;value -> tv_usec = tv_usec ;}","u32 rem ;value -> tv_sec = div_u64_rem ( ( u64 ) jiffies * TICK_NSEC , NSEC_PER_SEC , & tv_usec ) ;tv_usec /= NSEC_PER_USEC ;value -> tv_usec = rem / NSEC_PER_USEC ;}",584
2028,},tty -> disc_data = NULL ;tty -> receive_room = 0 ;},585
2029,"init_thread :  fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ;","if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;init_thread : fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , ""f2fs_flush-%u:%u"" , MAJOR ( dev ) , MINOR ( dev ) ) ;",586
2030,"}got_buffer_from_side ( side , buffer ) ;","else if ( auth_end == FIND_AUTH_END_ABORT ) {buffer_unref ( buffer ) ;if ( client -> proxy -> log_messages ) g_print ( ""Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\\side_closed ( side ) ;break ;}}got_buffer_from_side ( side , buffer ) ;",587
2031,"struct mb_cache_entry * ce = NULL ;int error = 0 ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;if ( ce )  mb_cache_entry_free ( ce ) ;if ( ce )  mb_cache_entry_release ( ce ) ;","int error = 0 ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;__u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ;ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr ) ;",588
2032,p -> y . pTab = pItem -> pTab ;p -> iTable = pItem -> iCursor ;testcase ( iCol == BMS ) ;testcase ( iCol == BMS - 1 ) ;return p ;},Table * pTab = p -> y . pTab = pItem -> pTab ;p -> iTable = pItem -> iCursor ;if ( pTab -> tabFlags & TF_HasGenerated ) {Column * pColumn = pTab -> aCol + iCol ;if ( pColumn -> colFlags & COLFLAG_GENERATED ) {testcase ( pTab -> nCol == 63 ) ;testcase ( pTab -> nCol == 64 ) ;if ( pTab -> nCol >= 64 ) {pItem -> colUsed = ALLBITS ;}else {pItem -> colUsed = MASKBIT ( pTab -> nCol ) - 1 ;}}}}else {testcase ( iCol == BMS ) ;testcase ( iCol == BMS - 1 ) ;return p ;},589
2033,pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ;if ( ! pStorage -> mbLayer ) return HANTRO_NOK ;,"pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size , 1 ) ;if ( ! pStorage -> mbLayer ) return HANTRO_NOK ;",590
2034,"vpx_memcpy ( mbd -> segment_feature_data , xd -> segment_feature_data , sizeof ( xd -> segment_feature_data ) ) ;vpx_memcpy ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , sizeof ( xd -> ref_lf_deltas ) ) ;vpx_memcpy ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , sizeof ( xd -> mode_lf_deltas ) ) ;mbd -> mode_ref_lf_delta_enabled = xd -> mode_ref_lf_delta_enabled ;vpx_memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ;vpx_memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ;vpx_memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ;vpx_memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ;mbd -> fullpixel_mask = 0xffffffff ;","memcpy ( mbd -> segment_feature_data , xd -> segment_feature_data , sizeof ( xd -> segment_feature_data ) ) ;memcpy ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , sizeof ( xd -> ref_lf_deltas ) ) ;memcpy ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , sizeof ( xd -> mode_lf_deltas ) ) ;mbd -> mode_ref_lf_delta_enabled = xd -> mode_ref_lf_delta_enabled ;memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ;memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ;memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ;memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ;mbd -> fullpixel_mask = 0xffffffff ;",591
2035,"raw_ptr = ( unsigned char * ) ( raw_buffer -> y_buffer + recon_yoffset  + d -> offset ) ;vp8_mse16x16 ( src_ptr , src_stride , raw_ptr , raw_stride ,  ( unsigned int * ) ( raw_motion_err ) ) ;vp8_mse16x16 ( src_ptr , src_stride , ref_ptr , ref_stride ,  ( unsigned int * ) ( best_motion_err ) ) ;","( void ) cpi ;raw_ptr = ( unsigned char * ) ( raw_buffer -> y_buffer + recon_yoffset + d -> offset ) ;vpx_mse16x16 ( src_ptr , src_stride , raw_ptr , raw_stride , ( unsigned int * ) ( raw_motion_err ) ) ;vpx_mse16x16 ( src_ptr , src_stride , ref_ptr , ref_stride , ( unsigned int * ) ( best_motion_err ) ) ;",592
2036,"static vpx_codec_err_t vp8e_set_roi_map ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_set_roi_map ( vpx_codec_alg_priv_t * ctx , va_list args ) {",593
2037,"int cflags = REG_EXTENDED | REG_NOSUB ;if ( strncmp ( pattern , ""(?i)"" , 4 ) == 0 ) {if ( regexec ( & preg , string , 0 , NULL , 0 ) != 0 )  return ( 0 ) ;","int cflags = REG_EXTENDED | REG_NOSUB ;int ret ;if ( strncmp ( pattern , ""(?i)"" , 4 ) == 0 ) {ret = regexec ( & preg , string , 0 , NULL , 0 ) ;regfree ( & preg ) ;if ( ret != 0 ) return ( 0 ) ;",594
2038,"if ( max_recs == 0 ) max_recs = 1 ;sess = s -> session ;do {if ( ( RECORD_LAYER_get_rstate ( & s -> rlayer ) != SSL_ST_READ_BODY ) || ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) < SSL3_RT_HEADER_LENGTH ) ) {n = ssl3_read_n ( s , SSL3_RT_HEADER_LENGTH , SSL3_BUFFER_get_len ( rbuf ) , 0 , num_recs == 0 ? 1 : 0 ) ;if ( n <= 0 ) return ( n ) ;RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_BODY ) ;p = RECORD_LAYER_get_packet ( & s -> rlayer ) ;if ( s -> server && RECORD_LAYER_is_first_record ( & s -> rlayer ) && ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {rr [ num_recs ] . type = SSL3_RT_HANDSHAKE ;rr [ num_recs ] . rec_version = SSL2_VERSION ;rr [ num_recs ] . length = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;if ( rr [ num_recs ] . length > SSL3_BUFFER_get_len ( rbuf ) - SSL2_RT_HEADER_LENGTH ) {al = SSL_AD_RECORD_OVERFLOW ;SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_PACKET_LENGTH_TOO_LONG ) ;goto f_err ;}if ( rr [ num_recs ] . length < MIN_SSL2_RECORD_LEN ) {al = SSL_AD_HANDSHAKE_FAILURE ;SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ;goto f_err ;}}else {if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , 5 , s , s -> msg_callback_arg ) ;rr [ num_recs ] . type = * ( p ++ ) ;ssl_major = * ( p ++ ) ;ssl_minor = * ( p ++ ) ;version = ( ssl_major << 8 ) | ssl_minor ;rr [ num_recs ] . rec_version = version ;n2s ( p , rr [ num_recs ] . length ) ;if ( ! s -> first_packet && version != s -> version ) {SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ;if ( ( s -> version & 0xFF00 ) == ( version & 0xFF00 ) && ! s -> enc_write_ctx && ! s -> write_hash ) {if ( rr -> type == SSL3_RT_ALERT ) {goto err ;}s -> version = ( unsigned short ) version ;}al = SSL_AD_PROTOCOL_VERSION ;goto f_err ;}if ( ( version >> 8 ) != SSL3_VERSION_MAJOR ) {if ( RECORD_LAYER_is_first_record ( & s -> rlayer ) ) {p = RECORD_LAYER_get_packet ( & s -> rlayer ) ;if ( strncmp ( ( char * ) p , ""GET<S2SV_blank>"" , 4 ) == 0 || strncmp ( ( char * ) p , ""POST<S2SV_blank>"" , 5 ) == 0 || strncmp ( ( char * ) p , ""HEAD<S2SV_blank>"" , 5 ) == 0 || strncmp ( ( char * ) p , ""PUT<S2SV_blank>"" , 4 ) == 0 ) {SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_HTTP_REQUEST ) ;goto err ;}else if ( strncmp ( ( char * ) p , ""CONNE"" , 5 ) == 0 ) {SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_HTTPS_PROXY_REQUEST ) ;goto err ;}SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ;goto err ;}else {SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ;al = SSL_AD_PROTOCOL_VERSION ;goto f_err ;}}if ( rr [ num_recs ] . length > SSL3_BUFFER_get_len ( rbuf ) - SSL3_RT_HEADER_LENGTH ) {al = SSL_AD_RECORD_OVERFLOW ;SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_PACKET_LENGTH_TOO_LONG ) ;goto f_err ;}}}if ( rr [ num_recs ] . rec_version == SSL2_VERSION ) {i = rr [ num_recs ] . length + SSL2_RT_HEADER_LENGTH - SSL3_RT_HEADER_LENGTH ;}else {i = rr [ num_recs ] . length ;}if ( i > 0 ) {n = ssl3_read_n ( s , i , i , 1 , 0 ) ;if ( n <= 0 ) return ( n ) ;}RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_HEADER ) ;if ( rr [ num_recs ] . rec_version == SSL2_VERSION ) {rr [ num_recs ] . input = & ( RECORD_LAYER_get_packet ( & s -> rlayer ) [ SSL2_RT_HEADER_LENGTH ] ) ;}else {rr [ num_recs ] . input = & ( RECORD_LAYER_get_packet ( & s -> rlayer ) [ SSL3_RT_HEADER_LENGTH ] ) ;}if ( rr [ num_recs ] . length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) {al = SSL_AD_RECORD_OVERFLOW ;SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_ENCRYPTED_LENGTH_TOO_LONG ) ;goto f_err ;}rr [ num_recs ] . data = rr [ num_recs ] . input ;rr [ num_recs ] . orig_len = rr [ num_recs ] . length ;rr [ num_recs ] . read = 0 ;num_recs ++ ;RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;RECORD_LAYER_clear_first_record ( & s -> rlayer ) ;}while ( num_recs < max_recs && rr [ num_recs - 1 ] . type == SSL3_RT_APPLICATION_DATA && SSL_USE_EXPLICIT_IV ( s ) && s -> enc_read_ctx != NULL && ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_read_ctx ) ) & EVP_CIPH_FLAG_PIPELINE ) && ssl3_record_app_data_waiting ( s ) ) ;if ( SSL_USE_ETM ( s ) && s -> read_hash ) {unsigned char * mac ;",if ( SSL_READ_ETM ( s ) && s -> enc_read_ctx != NULL && ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_read_ctx ) ) & EVP_CIPH_FLAG_PIPELINE ) && ssl3_record_app_data_waiting ( s ) ) ;if ( SSL_USE_ETM ( s ) && s -> read_hash ) {unsigned char * mac ;,595
2039,# endif if ( ( sess != NULL ) && ( s -> enc_read_ctx != NULL ) &&  ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) && ! SSL_USE_ETM ( s ) ) {unsigned char * mac = NULL ;,# endif if ( ( sess != NULL ) && ( ! SSL_READ_ETM ( s ) && s -> enc_read_ctx != NULL ) && ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) && ! SSL_USE_ETM ( s ) ) {unsigned char * mac = NULL ;,595
2040,"static unsigned int XBMInteger ( Image * image , short int * hex_digits )  {if ( c == EOF )  return ( 0 ) ;}","static int XBMInteger ( Image * image , short int * hex_digits ) {if ( c == EOF ) return ( - 1 ) ;}",596
2041,if ( c == EOF )  return ( 0 ) ;}return ( value ) ;},if ( c == EOF ) return ( - 1 ) ;}return ( ( int ) value ) ;},596
2042,"struct completion * vfork_done = tsk -> vfork_done ;deactivate_mm ( tsk , mm ) ;","struct completion * vfork_done = tsk -> vfork_done ;# ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ;# ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ;# endif # endif deactivate_mm ( tsk , mm ) ;",597
2043,"status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}else if ( image -> storage_class == PseudoClass ) for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}else {number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;for ( y = 0 ;y < ( ssize_t ) image -> rows ;y ++ ) {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ;SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ;SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ;if ( image -> colors != 0 ) {ssize_t index ;index = ( ssize_t ) GetPixelRed ( image , q ) ;SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red ) , q ) ;index = ( ssize_t ) GetPixelGreen ( image , q ) ;SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green ) , q ) ;index = ( ssize_t ) GetPixelBlue ( image , q ) ;SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue ) , q ) ;}SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ;p ++ ;q += GetPixelChannels ( image ) ;}if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;if ( image -> previous == ( Image * ) NULL ) {status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;if ( status == MagickFalse ) break ;}}}pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;count = ReadBlob ( image , 1 , & viff_info . identifier ) ;if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) {AcquireNextImage ( image_info , image , exception ) ;if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;}",status = MagickFalse ;,598
2044,"len = min_t ( unsigned int , len , sizeof ( sec ) ) ;if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ;","sec . key_size = 0 ;len = min_t ( unsigned int , len , sizeof ( sec ) ) ;if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ;",599
2045,"char buf [ MAX_PKT_SIZE ] ;memset ( buf , 0 , sizeof ( buf ) ) ;len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ;if ( len > 0 ) {buf [ len ] = 0 ;if ( sa . sa_family != AF_INET ) return ;","char buf [ MAX_PKT_SIZE + 1 ] ;memset ( buf , 0 , sizeof ( buf ) - 1 ) ;len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ;if ( len > 0 ) {if ( sa . sa_family != AF_INET ) return ;",600
2046,"* prev = NULL ;if ( vma -> vm_flags & ( VM_LOCKED | VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ;if ( ! vma -> vm_file || ! vma -> vm_file -> f_mapping   || ! vma -> vm_file -> f_mapping -> host ) {return - EINVAL ;up_read ( & current -> mm -> mmap_sem ) ;error = do_fallocate ( vma -> vm_file ,  FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE ,  offset , end - start ) ;down_read ( & current -> mm -> mmap_sem ) ;","struct file * f ;* prev = NULL ;if ( vma -> vm_flags & ( VM_LOCKED | VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ;f = vma -> vm_file ;if ( ! f || ! f -> f_mapping || ! vma -> vm_file -> f_mapping -> host ) {return - EINVAL ;get_file ( f ) ;up_read ( & current -> mm -> mmap_sem ) ;error = do_fallocate ( f , FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , offset , end - start ) ;fput ( f ) ;down_read ( & current -> mm -> mmap_sem ) ;",601
2047,"err = - EMSGSIZE ;if ( len > 0xFFFF )  goto out ;err = - EOPNOTSUPP ;if ( msg -> msg_flags & MSG_OOB ) goto out ;if ( msg -> msg_namelen ) {DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ;err = - EINVAL ;if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ;if ( usin -> sin_family != AF_INET ) {pr_info_once ( ""%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\\err = - EAFNOSUPPORT ;if ( usin -> sin_family ) goto out ;}daddr = usin -> sin_addr . s_addr ;}else {err = - EDESTADDRREQ ;if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ;daddr = inet -> inet_daddr ;}ipc . sockc . tsflags = sk -> sk_tsflags ;ipc . addr = inet -> inet_saddr ;ipc . opt = NULL ;ipc . tx_flags = 0 ;ipc . ttl = 0 ;ipc . tos = - 1 ;ipc . oif = sk -> sk_bound_dev_if ;if ( msg -> msg_controllen ) {err = ip_cmsg_send ( sk , msg , & ipc , false ) ;if ( unlikely ( err ) ) {kfree ( ipc . opt ) ;goto out ;}if ( ipc . opt ) free = 1 ;}saddr = ipc . addr ;ipc . addr = daddr ;if ( ! ipc . opt ) {struct ip_options_rcu * inet_opt ;rcu_read_lock ( ) ;inet_opt = rcu_dereference ( inet -> inet_opt ) ;if ( inet_opt ) {memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ;ipc . opt = & opt_copy . opt ;}rcu_read_unlock ( ) ;}if ( ipc . opt ) {err = - EINVAL ;if ( inet -> hdrincl )  goto done ;",int hdrincl ;err = - EMSGSIZE ;if ( hdrincl ) goto done ;,602
2048,"flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE ,  inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol ,  inet_sk_flowi_flags ( sk ) |  ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) ,  daddr , saddr , 0 , 0 , sk -> sk_uid ) ;if ( ! inet -> hdrincl ) {rfv . msg = msg ;","flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , inet_sk_flowi_flags ( sk ) | ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , daddr , saddr , 0 , 0 , sk -> sk_uid ) ;if ( ! inet -> hdrincl ) {rfv . msg = msg ;",602
2049,"back_from_confirm :  if ( inet -> hdrincl )  err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ;","back_from_confirm : if ( inet -> hdrincl ) err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ;",602
2050,"private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info ,  size_t count , const uint64_t clsid [ 2 ] )  {","private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , size_t count , const cdf_directory_t * root_storage ) {",603
2051,"if ( ! NOTMIME ( ms ) )   str = cdf_clsid_to_mime ( clsid , clsid2mime ) ;for ( i = 0 ;","if ( ! NOTMIME ( ms ) && root_storage ) str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid , clsid2mime ) ;for ( i = 0 ;",603
2052,struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ;if ( mnt != parent ) {,struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ;if ( dentry != vfsmnt -> mnt_root ) {bptr = * buffer ;blen = * buflen ;error = 3 ;break ;}if ( mnt != parent ) {,604
2053,"return ( mhlen ) ;break ;if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ;return ( mhlen ) ;trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ( mhlen ) ;}",return ( - 1 ) ;,605
2054,"static bool tailmatch ( const char * little , const char * bigone )  {size_t littlelen = strlen ( little ) ;size_t biglen = strlen ( bigone ) ;if ( littlelen > biglen )  return FALSE ;return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;}","static bool tailmatch ( const char * cooke_domain , const char * bigone ) {size_t cookie_domain_len = strlen ( little ) ;size_t hostname_len = strlen ( bigone ) ;if ( hostname_len < cookie_domain_len ) return FALSE ;return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;}",606
2055,if ( ! values [ k ] . name )  continue ;,if ( ! values [ k ] . name ) {continue ;},607
2056,"
","if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) {jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\\jas_free ( siz -> comps ) ;return - 1 ;}if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) {jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\\jas_free ( siz -> comps ) ;return - 1 ;}",608
2057,siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ;siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ;,siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ;siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ;,608
2058,# endif s -> tlsext_ticket_expected = 0 ;OPENSSL_free ( s -> s3 -> alpn_selected ) ;# endif  s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ;s -> s3 -> flags &= ~ TLS1_FLAGS_RECEIVED_EXTMS ;,# endif s -> tlsext_use_etm = 0 ;# endif s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ;s -> s3 -> flags &= ~ TLS1_FLAGS_RECEIVED_EXTMS ;,609
2059,"if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 1 , type , data , size , s -> tlsext_debug_arg ) ;if ( type == TLSEXT_TYPE_renegotiate ) {if ( ! ssl_parse_serverhello_renegotiate_ext ( s , & spkt , al ) ) return 0 ;renegotiate_seen = 1 ;",if ( s -> tlsext_debug_cb ) s -> tlsext_use_etm = 1 ;,609
2060,if ( s -> s3 -> tmp . new_cipher -> algorithm_mac != SSL_AEAD && s -> s3 -> tmp . new_cipher -> algorithm_enc != SSL_RC4 )  s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ;},if ( s -> s3 -> tmp . new_cipher -> algorithm_mac != SSL_AEAD && s -> s3 -> tmp . new_cipher -> algorithm_enc != SSL_RC4 ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ;},609
2061,"int cond_len , then_len , jump_len ;Node * cond = NODE_BAG_BODY ( node ) ;","int cond_len , then_len , else_len , jump_len ;Node * cond = NODE_BAG_BODY ( node ) ;",610
2062,jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ;if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ;,jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP ;,610
2063,"r = compile_tree ( Then , reg , env ) ;if ( r != 0 ) return r ;if ( IS_NOT_NULL ( Else ) ) {int else_len = compile_length_tree ( Else , reg ) ;r = add_op ( reg , OP_JUMP ) ;COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ;r = compile_tree ( Else , reg , env ) ;}","else_len = compile_length_tree ( Else , reg ) ;if ( else_len < 0 ) return else_len ;else else_len = 0 ;r = add_op ( reg , OP_JUMP ) ;COP ( reg ) -> jump . addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP ;r = add_op ( reg , OP_ATOMIC_END ) ;if ( r != 0 ) return r ;if ( IS_NOT_NULL ( Else ) ) {r = compile_tree ( Else , reg , env ) ;}",610
2064,int valuelen = args -> valuelen ;int nmap ;ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ;while ( valuelen > 0 ) {,int valuelen ;int nmap ;ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ;ASSERT ( args -> rmtvaluelen == args -> valuelen ) ;valuelen = args -> rmtvaluelen ;while ( valuelen > 0 ) {,611
2065,"if ( -- container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount > 0 )  return ;","if ( ! atomic_dec_and_test ( & container_of ( ptr , struct ipc_rcu_hdr , data ) -> refcount ) ) return ;",612
2066,"ND_TCHECK ( * ext ) ;UNALIGNED_MEMCPY ( & ke , ext , sizeof ( ke ) ) ;","ND_TCHECK ( * k ) ;UNALIGNED_MEMCPY ( & ke , ext , sizeof ( ke ) ) ;",613
2067,"static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int nodigest , int nocontent )  {wfd = Fopen ( dest , ""w.ufdio"" ) ;umask ( old_umask ) ;}","static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int exclusive , int nodigest , int nocontent ) {wfd = Fopen ( dest , exclusive ? ""wx.ufdio"" : ""a.ufdio"" ) ;umask ( old_umask ) ;if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) {rc = RPMERR_OPEN_FAILED ;goto exit ;}}",614
2068,image -> tly_ = 0 ;image -> brx_ = 0 ;image -> bry_ = 0 ;image -> clrspc_ = JAS_CLRSPC_UNKNOWN ;image -> numcmpts_ = 0 ;image -> maxcmpts_ = 0 ;image -> cmpts_ = 0 ;image -> inmem_ = true ;image -> cmprof_ = 0 ;,image -> cmprof_ = 0 ;,615
2069,"if ( prefixlen >= MAX_MAILBOX_NAME ) {r = IMAP_MAILBOX_BADNAME ;goto done ;}char c = firstpat [ prefixlen ] ;for ( i = 1 ;i < patterns -> count ;i ++ ) {const char * pat = strarray_nth ( patterns , i ) ;if ( pat [ prefixlen ] != c ) break ;}if ( i < patterns -> count ) break ;if ( c == \'*\' || c == \'%\' || c == \'?\' ) break ;commonpat [ prefixlen ] = c ;}commonpat [ prefixlen ] = \'\\\\0\' ;if ( patterns -> count == 1 ) {if ( ! strcmp ( firstpat + prefixlen , ""%"" ) ) rock -> singlepercent = 2 ;if ( ! strcmp ( firstpat + prefixlen , ""*%"" ) ) rock -> singlepercent = 1 ;}if ( userid && ! isadmin ) {rock -> mb_category = MBNAME_INBOX ;r = cyrusdb_forone ( rock -> db , inbox , inboxlen , & find_p , & find_cb , rock , NULL ) ;if ( r == CYRUSDB_DONE ) r = 0 ;if ( r ) goto done ;if ( rock -> namespace -> isalt ) {rock -> mb_category = MBNAME_INBOXSUB ;r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 7 , & find_p , & find_cb , rock , NULL ) ;if ( r == CYRUSDB_DONE ) r = 0 ;if ( r ) goto done ;r = ( * rock -> proc ) ( NULL , rock -> procrock ) ;if ( r ) goto done ;}rock -> mb_category = MBNAME_OWNER ;r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 1 , & find_p , & find_cb , rock , NULL ) ;if ( r == CYRUSDB_DONE ) r = 0 ;if ( r ) goto done ;if ( rock -> namespace -> isalt ) {r = ( * rock -> proc ) ( NULL , rock -> procrock ) ;if ( r ) goto done ;rock -> mb_category = MBNAME_ALTINBOX ;r = cyrusdb_forone ( rock -> db , inbox , inboxlen + 6 , & find_p , & find_cb , rock , NULL ) ;if ( r == CYRUSDB_DONE ) goto skipalt ;if ( r ) goto done ;rock -> mb_category = MBNAME_ALTPREFIX ;r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 1 , & find_p , & find_cb , rock , NULL ) ;skipalt : if ( r == CYRUSDB_DONE ) r = 0 ;if ( r ) goto done ;}}if ( isadmin || rock -> namespace -> accessible [ NAMESPACE_USER ] ) {len = strlen ( rock -> namespace -> prefix [ NAMESPACE_USER ] ) ;if ( len ) len -- ;if ( ! strncmp ( rock -> namespace -> prefix [ NAMESPACE_USER ] , commonpat , MIN ( len , prefixlen ) ) ) {if ( prefixlen < len ) {strlcpy ( domainpat + domainlen , ""user."" , sizeof ( domainpat ) - domainlen ) ;","if ( prefixlen <= len ) {strlcpy ( domainpat + domainlen , ""user."" , sizeof ( domainpat ) - domainlen ) ;",616
2070,"
","if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ;",617
2071,"if ( label_exec ( opt_exec_label ) == - 1 )  die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ;","if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( ""label_exec<S2SV_blank>%s"" , argv [ 0 ] ) ;",617
2072,"chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ;if ( chip -> data_buffer == NULL ) {","chip -> data_buffer = kzalloc ( TPM_BUFSIZE , GFP_KERNEL ) ;if ( chip -> data_buffer == NULL ) {",618
2073,"set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ;err = hci_uart_register_dev ( hu ) ;clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ;return err ;}","err = hci_uart_register_dev ( hu ) ;clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ;",619
2074,"
",if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;,620
2075,line += PKT_LEN_SIZE ;if ( len == PKT_LEN_SIZE ) {,line += PKT_LEN_SIZE ;if ( len == PKT_LEN_SIZE ) {,620
2076,"return NULL ;}ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ;ut32 len = sec -> payload_len ;ut32 count = sec -> count ;ut32 i = 0 , r = 0 ;while ( i < len && r < count ) {if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) {return ret ;free ( ptr ) ;return ret ;free ( ptr ) ;return ret ;free ( ptr ) ;return ret ;",goto beach ;free ( ptr ) ;return ret ;free ( ptr ) ;return ret ;goto beach ;,621
2077,},beach : free ( ptr ) ;return ret ;},621
2078,"if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( image -> colors + 1 , sizeof ( * image -> colormap ) ) ;if ( image -> colormap == ( PixelPacket * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",622
2079,"status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse )  {InheritException ( exception , & image -> exception ) ;","if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) {InheritException ( exception , & image -> exception ) ;",622
2080,"struct ip_options * sopt ;unsigned char * sptr , * dptr ;if ( sopt -> optlen == 0 ) {dopt -> optlen = 0 ;return 0 ;}sptr = skb_network_header ( skb ) ;","const struct ip_options * sopt ;unsigned char * sptr , * dptr ;if ( sopt -> optlen == 0 ) return 0 ;}sptr = skb_network_header ( skb ) ;",623
2081,"static pfn_t kvm_pin_pages ( struct kvm_memory_slot * slot , gfn_t gfn ,  unsigned long size )  {end_gfn = gfn + ( size >> PAGE_SHIFT ) ;gfn += 1 ;","static pfn_t kvm_pin_pages ( struct kvm_memory_slot * slot , gfn_t gfn , unsigned long npages ) {end_gfn = gfn + npages ;gfn += 1 ;",624
2082,"else  res = ctx -> iface -> enc . cfg_set ( ctx -> priv -> alg_priv , cfg ) ;return SAVE_STATUS ( ctx , res ) ;","else res = ctx -> iface -> enc . cfg_set ( get_alg_priv ( ctx ) , cfg ) ;return SAVE_STATUS ( ctx , res ) ;",625
2083,"
",status = register_pernet_subsys ( & sctp_ctrlsock_ops ) ;if ( status ) goto err_register_ctrlsock ;,626
2084,status = sctp_v4_protosw_init ( ) ;if ( status ) goto err_protosw_init ;status = register_pernet_subsys ( & sctp_net_ops ) ;if ( status ) goto err_register_pernet_subsys ;err_add_protocol :  unregister_pernet_subsys ( & sctp_net_ops ) ;err_register_pernet_subsys : sctp_v6_protosw_exit ( ) ;err_protosw_init :  sctp_v4_pf_exit ( ) ;,status = sctp_v4_protosw_init ( ) ;if ( status ) goto err_protosw_init ;status = register_pernet_subsys ( & sctp_net_ops ) ;if ( status ) goto err_register_pernet_subsys ;err_add_protocol : unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ;err_register_ctrlsock : sctp_v6_protosw_exit ( ) ;err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ;err_register_defaults : sctp_v4_pf_exit ( ) ;,626
2085,bpm = nlmsg_data ( nlh ) ;bpm -> ifindex = dev -> ifindex ;,"bpm = nlmsg_data ( nlh ) ;memset ( bpm , 0 , sizeof ( * bpm ) ) ;bpm -> ifindex = dev -> ifindex ;",627
2086,if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) )  * flags &= ~ FOLL_WRITE ;return 0 ;,if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) * flags |= FOLL_COW ;return 0 ;,628
2087,"struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;int i , j ;if ( p -> eobs [ block ] > 0 )  xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;}","tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;int i , j ;if ( p -> eobs [ block ] > 0 ) {# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ;return ;}# endif x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;}}",629
2088,"void vp9_idct8x8_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {if ( eob == 1 )  vp9_idct8x8_1_add ( input , dest , stride ) ;else if ( eob <= 10 )  vp9_idct8x8_10_add ( input , dest , stride ) ;else  vp9_idct8x8_64_add ( input , dest , stride ) ;}","void vp9_idct8x8_add ( const tran_low_t * input , uint8_t * dest , int stride , int eob ) {if ( eob == 1 ) vpx_idct8x8_1_add ( input , dest , stride ) ;else if ( eob <= 12 ) vpx_idct8x8_12_add ( input , dest , stride ) ;else vpx_idct8x8_64_add ( input , dest , stride ) ;}",630
2089,"hide_shell ( shell_visible ? 1 : 0 ) ;if ( shell_visible ) gui_mode = 2 ;}break ;default : break ;}}return 0 ;}switch ( evt -> type ) {case GF_EVENT_DURATION : Duration = ( u64 ) ( 1000 * ( s64 ) evt -> duration . duration ) ;CanSeek = evt -> duration . can_seek ;break ;case GF_EVENT_MESSAGE : {const char * servName ;if ( ! evt -> message . service || ! strcmp ( evt -> message . service , the_url ) ) {servName = """" ;}else if ( ! strnicmp ( evt -> message . service , ""data:"" , 5 ) ) {servName = ""(embedded<S2SV_blank>data)"" ;}else {servName = evt -> message . service ;}if ( ! evt -> message . message ) return 0 ;if ( evt -> message . error ) {if ( ! is_connected ) last_error = evt -> message . error ;if ( evt -> message . error == GF_SCRIPT_INFO ) {GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s\\\}else {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s:<S2SV_blank>%s\\\}}else if ( ! be_quiet ) GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s\\\}break ;case GF_EVENT_PROGRESS : {char * szTitle = """" ;if ( evt -> progress . progress_type == 0 ) {szTitle = ""Buffer<S2SV_blank>"" ;if ( bench_mode && ( bench_mode != 3 ) ) {if ( evt -> progress . done >= evt -> progress . total ) bench_buffer = 0 ;else bench_buffer = 1 + 100 * evt -> progress . done / evt -> progress . total ;break ;}}else if ( evt -> progress . progress_type == 1 ) {if ( bench_mode ) break ;szTitle = ""Download<S2SV_blank>"" ;}else if ( evt -> progress . progress_type == 2 ) szTitle = ""Import<S2SV_blank>"" ;gf_set_progress ( szTitle , evt -> progress . done , evt -> progress . total ) ;}break ;case GF_EVENT_DBLCLICK : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ;return 0 ;case GF_EVENT_MOUSEDOWN : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) {right_down = 1 ;last_x = evt -> mouse . x ;last_y = evt -> mouse . y ;}return 0 ;case GF_EVENT_MOUSEUP : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) {right_down = 0 ;last_x = evt -> mouse . x ;last_y = evt -> mouse . y ;}return 0 ;case GF_EVENT_MOUSEMOVE : if ( right_down && ( user . init_flags & GF_TERM_WINDOWLESS ) ) {GF_Event move ;move . move . x = evt -> mouse . x - last_x ;move . move . y = last_y - evt -> mouse . y ;move . type = GF_EVENT_MOVE ;move . move . relative = 1 ;gf_term_user_event ( term , & move ) ;}return 0 ;case GF_EVENT_KEYUP : switch ( evt -> key . key_code ) {case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) switch_bench ( ! bench_mode ) ;break ;}break ;case GF_EVENT_KEYDOWN : gf_term_process_shortcut ( term , evt ) ;switch ( evt -> key . key_code ) {case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) {if ( ! bench_mode ) switch_bench ( ! bench_mode ) ;}break ;case GF_KEY_PAGEDOWN : case GF_KEY_MEDIANEXTTRACK : request_next_playlist_item = 1 ;break ;case GF_KEY_MEDIAPREVIOUSTRACK : break ;case GF_KEY_ESCAPE : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ;break ;case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) {hide_shell ( shell_visible ? 1 : 0 ) ;if ( ! shell_visible ) gui_mode = 1 ;}break ;case GF_KEY_F : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Rendering<S2SV_blank>rate:<S2SV_blank>%f<S2SV_blank>FPS\\\break ;case GF_KEY_T : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Scene<S2SV_blank>Time:<S2SV_blank>%f<S2SV_blank>\\\break ;case GF_KEY_D : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_DRAW_MODE , ( gf_term_get_option ( term , GF_OPT_DRAW_MODE ) == GF_DRAW_MODE_DEFER ) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER ) ;break ;case GF_KEY_4 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ;break ;case GF_KEY_5 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ;break ;case GF_KEY_6 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ;break ;case GF_KEY_7 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ;break ;case GF_KEY_O : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {if ( gf_term_get_option ( term , GF_OPT_MAIN_ADDON ) ) {fprintf ( stderr , ""Resuming<S2SV_blank>to<S2SV_blank>main<S2SV_blank>content\\\gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ;}else {fprintf ( stderr , ""Main<S2SV_blank>addon<S2SV_blank>not<S2SV_blank>enabled\\\}}break ;case GF_KEY_P : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {u32 pause_state = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ;fprintf ( stderr , ""[Status:<S2SV_blank>%s]\\\if ( ( pause_state == GF_STATE_PAUSED ) && ( evt -> key . flags & GF_KEY_MOD_SHIFT ) ) {gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ;}else {gf_term_set_option ( term , GF_OPT_PLAY_STATE , ( pause_state == GF_STATE_PAUSED ) ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ;}}break ;case GF_KEY_S : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ;fprintf ( stderr , ""Step<S2SV_blank>time:<S2SV_blank>"" ) ;PrintTime ( gf_term_get_time_in_ms ( term ) ) ;fprintf ( stderr , ""\\\}break ;case GF_KEY_B : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 1 ) ;break ;case GF_KEY_M : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 0 ) ;break ;case GF_KEY_H : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_switch_quality ( term , 1 ) ;}break ;case GF_KEY_L : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_switch_quality ( term , 0 ) ;}break ;case GF_KEY_F5 : if ( is_connected ) reload = 1 ;break ;case GF_KEY_A : addon_visible = ! addon_visible ;gf_term_toggle_addons ( term , addon_visible ) ;break ;case GF_KEY_UP : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( playback_speed * 2 ) ;}break ;case GF_KEY_DOWN : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( playback_speed / 2 ) ;}break ;case GF_KEY_LEFT : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( - 1 * playback_speed ) ;}break ;}break ;case GF_EVENT_CONNECT : if ( evt -> connect . is_connected ) {is_connected = 1 ;fprintf ( stderr , ""Service<S2SV_blank>Connected\\\eos_seen = GF_FALSE ;if ( playback_speed != FIX_ONE ) gf_term_set_speed ( term , playback_speed ) ;}else if ( is_connected ) {fprintf ( stderr , ""Service<S2SV_blank>%s\\\is_connected = 0 ;Duration = 0 ;}if ( init_w && init_h ) {gf_term_set_size ( term , init_w , init_h ) ;}ResetCaption ( ) ;break ;case GF_EVENT_EOS : eos_seen = GF_TRUE ;if ( playlist ) {if ( Duration > 1500 ) request_next_playlist_item = GF_TRUE ;}else if ( loop_at_end ) {restart = 1 ;}break ;case GF_EVENT_SIZE : if ( user . init_flags & GF_TERM_WINDOWLESS ) {GF_Event move ;move . type = GF_EVENT_MOVE ;move . move . align_x = align_mode & 0xFF ;move . move . align_y = ( align_mode >> 8 ) & 0xFF ;move . move . relative = 2 ;gf_term_user_event ( term , & move ) ;}break ;case GF_EVENT_SCENE_SIZE : if ( forced_width && forced_height ) {GF_Event size ;size . type = GF_EVENT_SIZE ;size . size . width = forced_width ;size . size . height = forced_height ;gf_term_user_event ( term , & size ) ;}break ;case GF_EVENT_METADATA : ResetCaption ( ) ;break ;case GF_EVENT_RELOAD : if ( is_connected ) reload = 1 ;break ;case GF_EVENT_DROPFILE : {u32 i , pos ;if ( readonly_playlist ) {gf_fclose ( playlist ) ;playlist = NULL ;}readonly_playlist = 0 ;if ( ! playlist ) {readonly_playlist = 0 ;playlist = gf_temp_file_new ( NULL ) ;}pos = ftell ( playlist ) ;i = 0 ;while ( i < evt -> open_file . nb_files ) {if ( evt -> open_file . files [ i ] != NULL ) {fprintf ( playlist , ""%s\\\}i ++ ;}fseek ( playlist , pos , SEEK_SET ) ;request_next_playlist_item = 1 ;}return 1 ;case GF_EVENT_QUIT : if ( evt -> message . error ) {fprintf ( stderr , ""A<S2SV_blank>fatal<S2SV_blank>error<S2SV_blank>was<S2SV_blank>encoutered:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>exiting<S2SV_blank>...\\\}Run = 0 ;break ;case GF_EVENT_DISCONNECT : gf_term_disconnect ( term ) ;break ;case GF_EVENT_MIGRATE : {}break ;case GF_EVENT_NAVIGATE_INFO : if ( evt -> navigate . to_url ) fprintf ( stderr , ""Go<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>\\\\""%s\\\\""\\\\r"" , evt -> navigate . to_url ) ;break ;case GF_EVENT_NAVIGATE : if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) {strcpy ( the_url , evt -> navigate . to_url ) ;fprintf ( stderr , ""Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\\","strncpy ( the_url , evt -> navigate . to_url ) ;fprintf ( stderr , ""Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\\",631
2090,}i = 0 ;,i = 0 ;,632
2091,keymap -> num_key_aliases = num_key_aliases ;keymap -> key_aliases = key_aliases ;,}keymap -> num_key_aliases = num_key_aliases ;keymap -> key_aliases = key_aliases ;,632
2092,"static inline struct enamemem *  lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , const unsigned int nlen ) {struct enamemem * tp ;register u_int i , j , k ;","static inline struct bsnamemem * lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , const unsigned int nlen ) {struct bsnamemem * tp ;register u_int i , j , k ;",633
2093,"while ( tp -> e_nxt )  if ( tp -> e_addr0 == i &&  tp -> e_addr1 == j &&   tp -> e_addr2 == k &&   memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 )  return tp ;else  tp = tp -> e_nxt ;tp -> e_addr0 = i ;tp -> e_addr1 = j ;tp -> e_addr2 = k ;tp -> e_bs = ( u_char * ) calloc ( 1 , nlen + 1 ) ;if ( tp -> e_bs == NULL )  ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ;memcpy ( tp -> e_bs , bs , nlen ) ;tp -> e_nxt = ( struct enamemem * ) calloc ( 1 , sizeof ( * tp ) ) ;if ( tp -> e_nxt == NULL )  ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ;","while ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes && tp -> e_addr1 == j && tp -> bs_addr1 == j && tp -> bs_addr2 == k && memcmp ( ( const char * ) bs , ( const char * ) ( tp -> bs_bytes ) , nlen ) == 0 ) return tp ;else tp = tp -> bs_nxt ;tp -> bs_addr0 = i ;tp -> bs_addr1 = j ;tp -> bs_addr2 = k ;tp -> bs_bytes = ( u_char * ) calloc ( 1 , nlen + 1 ) ;if ( tp -> bs_bytes == NULL ) ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ;memcpy ( tp -> bs_bytes , bs , nlen ) ;tp -> bs_nbytes = nlen ;tp -> bs_nxt = ( struct bsnamemem * ) calloc ( 1 , sizeof ( * tp ) ) ;if ( tp -> bs_nxt == NULL ) ( * ndo -> ndo_error ) ( ndo , ""lookup_bytestring:<S2SV_blank>calloc"" ) ;",633
2094,"printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ;if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ;","printf ( ""Using<S2SV_blank>%s\\\res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ;if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ;",634
2095,"if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) )  die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;encode_frame ( & codec , NULL , - 1 , 0 , writer ) ;printf ( ""\\\","if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , & cfg , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ;while ( encode_frame ( & codec , NULL , - 1 , 0 , writer ) ) {};printf ( ""\\\",634
2096,avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;while ( len && avail && * old ) {,if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ;while ( len && avail && * old ) {,635
2097,"recv ( signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ;return ( int ) sig_recv ;","TEMP_FAILURE_RETRY ( recv ( signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ) ;return ( int ) sig_recv ;",636
2098,"void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) {bloc = * offset ;send ( huff -> loc [ ch ] , NULL , fout ) ;* offset = bloc ;","void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset , int maxoffset ) {bloc = * offset ;send ( huff -> loc [ ch ] , NULL , fout , maxoffset ) ;* offset = bloc ;",637
2099,"box -> info = boxinfo ;box -> ops = & boxinfo -> ops ;if ( extlen > 0xffffffffUL ) {jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\\extlen = 0xffffffffUL ;}box -> len = extlen ;box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ;}else {box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ;}if ( box -> len != 0 && box -> len < 8 ) {goto error ;}dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ;if ( dataflag ) {if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) {goto error ;}if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) {box -> ops = & jp2_boxinfo_unk . ops ;jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;}jas_stream_rewind ( tmpstream ) ;if ( box -> ops -> getdata ) {","box -> info = boxinfo ;box -> ops = & boxinfo -> ops ;jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\jas_stream_rewind ( tmpstream ) ;box -> ops = & boxinfo -> ops ;if ( box -> ops -> getdata ) {",638
2100,"static void record_recent_object ( struct object * obj ,  struct strbuf * path ,   const char * last ,  void * data ) {","static void record_recent_object ( struct object * obj , const char * last , void * data ) {",639
2101,"if ( key_is_instantiated ( key ) &&  ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ;","if ( key_is_positive ( key ) && ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ;",640
2102,"int res , bytes , i , indexes , index_bytes , ids ;long long * index , start , end ;if ( res == 0 ) return 0 ;SQUASHFS_INSWAP_XATTR_TABLE ( & id_table ) ;if ( flag ) {* table_start = id_table . xattr_table_start ;return id_table . xattr_ids ;}index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ids ) ;indexes = SQUASHFS_XATTR_BLOCKS ( ids ) ;res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) ,  index_bytes , index ) ;bytes = SQUASHFS_XATTR_BYTES ( ids ) ;xattr_ids = malloc ( bytes ) ;int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) +  ( i * SQUASHFS_METADATA_SIZE ) ) ;TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>"" ""%d\\\","int res , i , indexes , index_bytes ;unsigned int ids ;long long bytes ;long long * index , start , end ;return id_table . xattr_ids ;}ids = id_table . xattr_ids ;xattr_table_start = id_table . xattr_table_start ;index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ;indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ;if ( index_bytes != ( sBlk -> bytes_used - ( sBlk -> xattr_id_table_start + sizeof ( id_table ) ) ) ) {ERROR ( ""read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\\return 0 ;}if ( table_start != NULL ) * table_start = id_table . xattr_table_start ;if ( flag ) return id_table . xattr_ids ;res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) , index_bytes , index ) ;bytes = SQUASHFS_XATTR_BYTES ( ( long long ) ids ) ;xattr_ids = malloc ( bytes ) ;int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) + ( ( long long ) i * SQUASHFS_METADATA_SIZE ) ) ;TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>"" ""%d\\\",641
2103,int result = RLC_OK ;bn_t t ;,int result = RLC_ERR ;bn_t t ;,642
2104,"break ;case RSA_ENC_FIN : rand_bytes ( h1 , RLC_MD_LEN ) ;","result = RLC_OK ;break ;case RSA_ENC_FIN : rand_bytes ( h1 , RLC_MD_LEN ) ;",642
2105,break ;case RSA_DEC : m_len = k_len - 1 ;if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;},result = RLC_OK ;break ;case RSA_DEC : m_len = k_len - 1 ;if ( bn_is_zero ( t ) ) {result = RLC_ERR ;},642
2106,"h1 [ i ] ^= h2 [ i ] ;}md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ;bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ;for ( int i = 0 ;i < t -> used ;i ++ ) {m -> dp [ i ] ^= t -> dp [ i ] ;m_len -= RLC_MD_LEN ;bn_rsh ( t , m , 8 * m_len ) ;bn_write_bin ( h2 , RLC_MD_LEN , t ) ;md_map ( h1 , NULL , 0 ) ;pad = 0 ;for ( int i = 0 ;i < RLC_MD_LEN ;i ++ ) {pad |= h1 [ i ] - h2 [ i ] ;}if ( result == RLC_OK ) {result = ( pad ? RLC_ERR : RLC_OK ) ;bn_mod_2b ( m , m , 8 * m_len ) ;* p_len = bn_size_bin ( m ) ;","h1 [ i ] ^ h2 [ i ] ;bn_mod_2b ( m , m , 8 * m_len ) ;* p_len = bn_size_bin ( m ) ;( * p_len ) -- ;bn_rsh ( t , m , * p_len * 8 ) ;if ( pad == 0 && bn_cmp_dig ( t , 1 ) == RLC_EQ ) {result = RLC_OK ;bn_mod_2b ( m , m , 8 * m_len ) ;* p_len = bn_size_bin ( m ) ;",642
2107,"bn_lsh ( m , m , 64 ) ;bn_lsh ( m , m , RLC_MD_LEN * 8 ) ;break ;case RSA_SIG_FIN : memset ( mask , 0 , 8 ) ;bn_write_bin ( mask + 8 , RLC_MD_LEN , m ) ;md_map ( h1 , mask , RLC_MD_LEN + 8 ) ;bn_read_bin ( m , h1 , RLC_MD_LEN ) ;md_mgf ( mask , k_len - RLC_MD_LEN - 1 , h1 , RLC_MD_LEN ) ;bn_read_bin ( t , mask , k_len - RLC_MD_LEN - 1 ) ;t -> dp [ 0 ] ^= 0x01 ;bn_lsh ( t , t , 8 * RLC_MD_LEN ) ;bn_add ( m , t , m ) ;bn_lsh ( m , m , 8 ) ;bn_add_dig ( m , m , RSA_PSS ) ;for ( int i = m_len - 1 ;i < 8 * k_len ;i ++ ) {bn_set_bit ( m , i , 0 ) ;}break ;case RSA_VER : case RSA_VER_HASH : bn_mod_2b ( t , m , 8 ) ;if ( bn_cmp_dig ( t , RSA_PSS ) != RLC_EQ ) {result = RLC_ERR ;else {result = RLC_ERR ;","bn_lsh ( m , m , * p_len * 8 ) ;result = RLC_OK ;* p_len = k_len - * p_len ;break ;case RSA_SIG_FIN : memset ( mask , 0 , 8 ) ;pad = ( uint8_t ) t -> dp [ 0 ] ;if ( pad == RSA_PSS ) {int r = 1 ;r = 0 ;",642
2108,if ( ! bn_is_zero ( m ) ) {result = RLC_ERR ;},if ( r == 1 && bn_is_zero ( m ) ) {result = RLC_OK ;},642
2109,"void vp9_setup_mask ( VP9_COMMON * const cm , const int mi_row , const int mi_col ,  MODE_INFO * * mi_8x8 , const int mode_info_stride ,  LOOP_FILTER_MASK * lfm ) {MODE_INFO * * mip = mi_8x8 ;MODE_INFO * * mip2 = mi_8x8 ;const int offset_32 [ ] = {","void vp9_setup_mask ( VP9_COMMON * const cm , const int mi_row , const int mi_col , MODE_INFO * * mi , const int mode_info_stride , LOOP_FILTER_MASK * lfm ) {MODE_INFO * * mip = mi ;MODE_INFO * * mip2 = mi ;const int offset_32 [ ] = {",643
2110,vp9_zero ( * lfm ) ;switch ( mip [ 0 ] -> mbmi . sb_type ) {,vp9_zero ( * lfm ) ;assert ( mip [ 0 ] != NULL ) ;switch ( mip [ 0 ] -> mbmi . sb_type ) {,643
2111,const uint64_t mask_y = ( ( ( 1 << columns ) - 1 ) ) * 0x0101010101010101 ;const uint16_t mask_uv = ( ( 1 << ( ( columns + 1 ) >> 1 ) ) - 1 ) * 0x1111 ;lfm -> left_y [ i ] &= mask_y ;,const uint64_t mask_y = ( ( ( 1 << columns ) - 1 ) ) * 0x0101010101010101ULL ;const uint16_t mask_uv = ( ( 1 << ( ( columns + 1 ) >> 1 ) ) - 1 ) * 0x1111 ;lfm -> left_y [ i ] &= 0xfefefefefefefefeULL ;,643
2112,lfm -> left_y [ i ] &= 0xfefefefefefefefe ;lfm -> left_uv [ i ] &= 0xeeee ;,lfm -> left_y [ i ] &= 0xfefefefefefefefe ;lfm -> left_uv [ i ] &= 0xeeee ;,643
2113,},"cl_assert_equal_b ( false , git_path_isvalid ( NULL , "".gitmodules<S2SV_blank>.<S2SV_blank>.::$DATA"" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ;}",644
2114,redisAssert ( ! server . vm_enabled || obj -> storage == REDIS_VM_MEMORY ) ;if ( obj -> encoding == REDIS_ENCODING_RAW ) {,redisAssert ( ! server . ds_enabled || obj -> storage == REDIS_VM_MEMORY ) ;if ( obj -> encoding == REDIS_ENCODING_RAW ) {,645
2115,"
",r -> expect_tested = 1 ;if ( ngx_http_discard_request_body ( r ) != NGX_OK ) {r -> keepalive = 0 ;},646
2116,location = ngx_list_push ( & r -> headers_out . headers ) ;if ( location == NULL ) {,location = ngx_list_push ( & r -> headers_out . headers ) ;if ( location == NULL ) {,646
2117,if ( ! unconditional ( & e -> ipv6 ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,647
2118,# endif  },"conf_write ( fp , ""<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o"" , global_data -> umask ) ;# endif }",648
2119,"err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen ,  transhdrlen , mtu , flags ) ;if ( err ) goto error ;","err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , mtu , flags , rt ) ;if ( err ) goto error ;",649
2120,"if ( js_regexec ( re -> prog , text , & m , 0 ) ) {if ( len == limit ) return ;js_pushliteral ( J , """" ) ;js_setindex ( J , - 2 , 0 ) ;}return ;}p = a = text ;while ( a < e ) {if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) )  break ;","if ( js_doregexec ( J , re -> prog , text , & m , 0 ) ) {if ( js_doregexec ( J , re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) break ;",650
2121,"for ( i = 0 ;i ++ )   nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;}if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {",651
2122,"static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf )  {","static bool do_write_pids ( pid_t tpid , uid_t tuid , const char * contrl , const char * cg , const char * file , const char * buf ) {",652
2123,"if ( v == \'0\' ) {if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 )  fail = true ;","if ( ! may_move_pid ( tpid , tuid , cred . pid ) ) {fail = true ;break ;}if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) fail = true ;",652
2124,"u64 t = ca -> sum_rtt ;do_div ( t , ca -> cnt_rtt ) ;info . tcpv_rtt = t ;nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ;","if ( info . tcpv_rttcnt > 0 ) {u64 t = ca -> sum_rtt ;do_div ( t , info . tcpv_rttcnt ) ;info . tcpv_rtt = t ;}nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ;",653
2125,"put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;}","aux . tp_padding = 0 ;put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ;}",654
2126,BUG_ON ( sk != asoc -> base . sk ) ;lock_sock ( sk ) ;,if ( sk != asoc -> base . sk ) goto do_error ;lock_sock ( sk ) ;,655
2127,# undef _  default : switch ( variable & 0xff ) {,_ ( NPNVprivateModeBool ) ;_ ( NPNVsupportsAdvancedKeyHandling ) ;# undef _ default : switch ( variable & 0xff ) {,656
2128,"alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save , NULL ) ;}","alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save_cb , NULL ) ;}",657
2129,"while ( c && cJSON_strcasecmp ( c -> string , string ) ) {++ i ;c = c -> next ;}if ( c ) return cJSON_DetachItemFromArray ( object , i ) ;","+ i ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) i ++ , c = c -> next ;}if ( c ) return cJSON_DetachItemFromArray ( object , i ) ;",658
2130,facilities -> source_ndigis = 1 ;}else if ( * p == FAC_NATIONAL_SRC_DIGI ) {if ( ! fac_national_digis_received ) {,else {if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ;},659
2131,"if ( pt [ 6 ] & AX25_HBIT )  memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;else   memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;}","if ( pt [ 6 ] & AX25_HBIT ) {if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ;memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;else memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ;}",659
2132,"
",h . h2 -> tp_padding = 0 ;,660
2133,hdrlen = sizeof ( * h . h2 ) ;break ;,hdrlen = sizeof ( * h . h2 ) ;break ;,660
2134,"if ( err < 0 )  goto out ;exp2 = rqst_exp_get_by_name ( rqstp , & path ) ;","if ( err < 0 ) goto out ;if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) {path_put ( & path ) ;goto out ;}exp2 = rqst_exp_get_by_name ( rqstp , & path ) ;",661
2135,"list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) {ctx -> chain = chain ;err = nft_delchain ( ctx ) ;if ( err < 0 ) goto out ;list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) {if ( set -> flags & NFT_SET_ANONYMOUS &&  ! list_empty ( & set -> bindings ) ) continue ;","list_for_each_entry ( chain , & ctx -> table -> chains , list ) {ctx -> chain = chain ;list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) {if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ;err = nft_delset ( ctx , set ) ;if ( err < 0 ) goto out ;}list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) {if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ;",662
2136,if ( stringset == ETH_SS_STATS )  return ARRAY_SIZE ( g_gmac_stats_string ) ;,if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_gmac_stats_string ) ;,663
2137,if ( ( ubridge_config = iniparser_load ( filename ) ) == NULL ) {return FALSE ;,"if ( ( ubridge_config = iniparser_load ( filename , HIDE_ERRORED_LINE_CONTENT ) ) == NULL ) {return FALSE ;",664
2138,"if ( ( skb_headroom ( skb ) < frag_hdr_sz ) &&  pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;","if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;",665
2139,if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 4 ;}if ( context -> curY >= p -> height ) {context -> pass ++ ;if ( context -> curY >= p -> height ) {context -> pass ++ ;context -> curY = i -> posY + 1 ;}break ;},if ( context -> curY >= p -> height ) {context -> pass ++ ;break ;}while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) {switch ( ++ context -> pass ) {case 2 : context -> curY = i -> posY + 4 ;break ;case 3 : context -> curY = i -> posY + 2 ;break ;case 4 : context -> curY = i -> posY + 1 ;break ;}},666
2140,else  bitlen = slen * 4 ;if ( atttypmod <= 0 ) atttypmod = bitlen ;,"else {if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ;bitlen = slen * 4 ;}if ( atttypmod <= 0 ) atttypmod = bitlen ;",667
2141,"int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname ,   int flen )  {if ( udf_build_ustr_exact ( unifilename , sname , flen ) )  goto out2 ;","int udf_get_filename ( struct super_block * sb , uint8_t * sname , int slen , uint8_t * dname , int dlen ) {if ( udf_build_ustr_exact ( unifilename , sname , slen ) ) goto out2 ;",668
2142,"len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len ,  unifilename -> u_name , unifilename -> u_len ) ;","len = udf_translate_to_linux ( dname , dlen , filename -> u_name , filename -> u_len , unifilename -> u_name , unifilename -> u_len ) ;",668
2143,if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ;,"if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ;",669
2144,"if ( Stream_GetRemainingLength ( irp -> input ) < PathLength )   return ERROR_INVALID_DATA ;Stream_Seek ( irp -> input , PathLength ) ;",if ( Stream_GetRemainingLength ( irp -> input ) < PathLength ) return ERROR_INVALID_DATA ;,669
2145,"case PIMV2_HELLO_OPTION_HOLDTIME :  unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;break ;","case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ;break ;",670
2146,"case PIMV2_HELLO_OPTION_GENID :  ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ;break ;case PIMV2_HELLO_OPTION_REFRESH_CAP :  ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ;if ( * ( bp + 1 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ;}","case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ;break ;case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) {ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ;}}else {ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ;if ( * ( bp + 1 ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ;}",670
2147,"if ( ! strlen ( text ) ) return ""empty<S2SV_blank>string"" ;for ( out = escaped , len = 0 ;","if ( ! strlen ( text ) ) return """" ;for ( out = escaped , len = 0 ;",671
2148,"i += 2 ;}else {asdl_seq_SET ( kwdefaults , j , NULL ) ;}if ( NCH ( ch ) == 3 ) {annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ;if ( ! annotation ) goto error ;}else {annotation = NULL ;}ch = CHILD ( ch , 0 ) ;argname = NEW_IDENTIFIER ( ch ) ;if ( ! argname ) goto error ;if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ;arg = arg ( argname , annotation , LINENO ( ch ) , ch -> n_col_offset ,  ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ;if ( ! arg ) goto error ;asdl_seq_SET ( kwonlyargs , j ++ , arg ) ;i += 2 ;break ;","i += 1 ;if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;break ;case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ;if ( ! arg -> type_comment ) goto error ;i += 1 ;break ;",672
2149,"memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}","memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) | txp -> offset ) , data_len ) ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",673
2150,"BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ;if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ;if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",674
2151,"if ( strcmp ( tokens [ 1 ] . value , ""tune"" ) == 0 && ntokens >= 7 ) {if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) {out_string ( c , ""ERROR"" ) ;}else {if ( pct_hot + pct_warm > 80 ) {out_string ( c , ""ERROR<S2SV_blank>hot<S2SV_blank>and<S2SV_blank>warm<S2SV_blank>pcts<S2SV_blank>must<S2SV_blank>not<S2SV_blank>exceed<S2SV_blank>80"" ) ;}else if ( factor <= 0 || hot_factor <= 0 ) {out_string ( c , ""ERROR<S2SV_blank>hot/warm<S2SV_blank>age<S2SV_blank>factors<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ;}else {settings . hot_lru_pct = pct_hot ;settings . warm_lru_pct = pct_warm ;settings . hot_max_factor = hot_factor ;settings . warm_max_factor = factor ;out_string ( c , ""OK"" ) ;}}}else if ( strcmp ( tokens [ 1 ] . value , ""mode"" ) == 0 && ntokens >= 3 &&  settings . lru_maintainer_thread ) {","if ( strcmp ( tokens [ 1 ] . value , ""tune"" ) == 0 && ntokens >= 4 && settings . lru_maintainer_thread ) {",675
2152,"}else if ( strcmp ( tokens [ 1 ] . value , ""temp_ttl"" ) == 0 && ntokens >= 3 &&  settings . lru_maintainer_thread ) {","}else if ( strcmp ( tokens [ 1 ] . value , ""temp_ttl"" ) == 0 && ntokens >= 3 && settings . lru_maintainer_thread ) {",675
2153,for ( i = - 8 ;i < 0 ;i ++ ) s [ i * pitch ] = s [ 0 ] ;for ( i = rows ;i ++ )  s [ i * pitch ] = s [ ( rows - 1 ) * pitch ] ;,for ( i = 0 ;i < 17 ;i ++ ) s [ ( i + rows ) * pitch ] = s [ 0 ] ;for ( i = rows ;i ++ ) s [ i * pitch ] = s [ ( rows - 1 ) * pitch ] ;,676
2154,"if ( name && memchr ( name , '\\\\0' , namelen ) )  return 0 ;","if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ;if ( name && memchr ( name , '\\\\0' , namelen ) ) return 0 ;",677
2155,"# endif # ifdef FEAT_MBYTE if ( eap != NULL ) set_forced_fenc ( eap ) ;# endif # ifdef FEAT_AUTOCMD apply_autocmds_exarg ( EVENT_BUFNEWFILE , sfname , sfname , FALSE , curbuf , eap ) ;# endif save_file_ff ( curbuf ) ;# if defined ( FEAT_AUTOCMD ) && defined ( FEAT_EVAL ) if ( aborting ( ) ) return FAIL ;# endif return OK ;}else {filemess ( curbuf , sfname , ( char_u * ) ( # ifdef EFBIG ( errno == EFBIG ) ? _ ( ""[File<S2SV_blank>too<S2SV_blank>big]"" ) : # endif # ifdef EOVERFLOW ( errno == EOVERFLOW ) ? _ ( ""[File<S2SV_blank>too<S2SV_blank>big]"" ) : # endif _ ( ""[Permission<S2SV_blank>Denied]"" ) ) , 0 ) ;curbuf -> b_p_ro = TRUE ;}}return FAIL ;if ( ( check_readonly && file_readonly ) || curbuf -> b_help ) curbuf -> b_p_ro = TRUE ;if ( set_options ) {if ( ! read_buffer ) {curbuf -> b_p_eol = TRUE ;curbuf -> b_start_eol = TRUE ;# ifdef FEAT_MBYTE curbuf -> b_p_bomb = FALSE ;curbuf -> b_start_bomb = FALSE ;# ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif {check_need_swap ( newfile ) ;# ifdef FEAT_AUTOCMD if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) ) {EMSG ( _ ( e_auchangedbuf ) ) ;if ( ! read_buffer ) close ( fd ) ;return FAIL ;}# endif # ifdef UNIX if ( swap_mode > 0 && curbuf -> b_ml . ml_mfp != NULL && curbuf -> b_ml . ml_mfp -> mf_fname != NULL )  ( void ) mch_setperm ( curbuf -> b_ml . ml_mfp -> mf_fname , ( long ) swap_mode ) ;# endif }","# endif # ifdef FEAT_MBYTE if ( eap != NULL ) {char_u * swap_fname = curbuf -> b_ml . ml_mfp != NULL && curbuf -> b_ml . ml_mfp -> mf_fname ;if ( ( swap_mode & 044 ) == 040 ) {stat_T swap_st ;if ( mch_stat ( ( char * ) swap_fname , & swap_st ) >= 0 && st . st_gid != swap_st . st_gid && fchown ( curbuf -> b_ml . ml_mfp -> mf_fd , - 1 , st . st_gid ) == - 1 ) swap_mode &= 0600 ;( void ) mch_setperm ( swap_fname != NULL ) ( void ) mch_setperm ( curbuf -> b_ml . ml_mfp -> mf_fname , ( long ) swap_mode ) ;",678
2156,bpm = nlmsg_data ( nlh ) ;bpm -> ifindex = dev -> ifindex ;,"bpm = nlmsg_data ( nlh ) ;memset ( bpm , 0 , sizeof ( * bpm ) ) ;bpm -> ifindex = dev -> ifindex ;",679
2157,rect . x = Z_LVAL_PP ( tmp ) ;}rect . y = Z_LVAL_PP ( tmp ) ;}rect . width = Z_LVAL_PP ( tmp ) ;}rect . height = Z_LVAL_PP ( tmp ) ;},if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . x = Z_LVAL ( lval ) ;}else {rect . x = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . y = Z_LVAL ( lval ) ;}else {rect . y = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . width = Z_LVAL ( lval ) ;}else {rect . width = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . height = Z_LVAL ( lval ) ;}else {rect . height = Z_LVAL_PP ( tmp ) ;}},680
2158,"int temporal_layer = 0 ;int current_temporal_layer = svc -> temporal_layer_id ;for ( temporal_layer = current_temporal_layer + 1 ;temporal_layer < svc -> number_temporal_layers ;++ temporal_layer ) {LAYER_CONTEXT * lc = & svc -> layer_context [ temporal_layer ] ;RATE_CONTROL * lrc = & lc -> rc ;lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lc -> maximum_buffer_size ) ;lrc -> buffer_level = lrc -> bits_off_target ;","+ temporal_layer ) {int i = 0 ;int current_temporal_layer = svc -> temporal_layer_id ;for ( i = current_temporal_layer + 1 ;temporal_layer < svc -> number_temporal_layers ;++ i ) {const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ;LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ;RATE_CONTROL * lrc = & lc -> rc ;lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ;lrc -> buffer_level = lrc -> bits_off_target ;",681
2159,if ( peer )  get_net ( peer ) ;spin_unlock_bh ( & net -> nsid_lock ) ;,if ( peer ) peer = maybe_get_net ( peer ) ;spin_unlock_bh ( & net -> nsid_lock ) ;,682
2160,lock_sock ( sk ) ;if ( ctx -> more ) {,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;if ( ctx -> more ) {,683
2161,"speakup_tty = tty ;ldisc_data = kmalloc ( sizeof ( * ldisc_data ) , GFP_KERNEL ) ;if ( ! ldisc_data )   return - ENOMEM ;init_completion ( & ldisc_data -> completion ) ;return 0 ;}","mutex_lock ( & speakup_tty_mutex ) ;if ( speakup_tty ) {mutex_unlock ( & speakup_tty_mutex ) ;return - EBUSY ;}speakup_tty = tty ;ldisc_data = kmalloc ( sizeof ( * ldisc_data ) , GFP_KERNEL ) ;if ( ! ldisc_data ) {speakup_tty = NULL ;mutex_unlock ( & speakup_tty_mutex ) ;return - ENOMEM ;}init_completion ( & ldisc_data -> completion ) ;mutex_unlock ( & speakup_tty_mutex ) ;return 0 ;}",684
2162,case SO_SNDBUF :  if ( val > sysctl_wmem_max )  val = sysctl_wmem_max ;if ( ( val * 2 ) < SOCK_MIN_SNDBUF )  sk -> sk_sndbuf = SOCK_MIN_SNDBUF ;else sk -> sk_sndbuf = val * 2 ;,"case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ;sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ;",685
2163,case SO_RCVBUF :  if ( val > sysctl_rmem_max )  val = sysctl_rmem_max ;if ( ( val * 2 ) < SOCK_MIN_RCVBUF )  sk -> sk_rcvbuf = SOCK_MIN_RCVBUF ;else sk -> sk_rcvbuf = val * 2 ;,"case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ;sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ;",685
2164,uchar buf [ 2 ] ;if ( ( c = jas_stream_getc ( in ) ) == EOF ) {,jas_uchar buf [ 2 ] ;if ( ( c = jas_stream_getc ( in ) ) == EOF ) {,686
2165,"newtok = PyMem_MALLOC ( buflen + 1 ) ;strcpy ( newtok , buf ) ;","newtok = PyMem_MALLOC ( buflen + 1 ) ;if ( newtok == NULL ) {Py_DECREF ( u ) ;tok -> done = E_NOMEM ;return EOF ;}strcpy ( newtok , buf ) ;",687
2166,"first_block_offset = round_up ( offset , sb -> s_blocksize ) ;last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;ext4_std_error ( sb , ret ) ;goto out_dio ;}ret = ext4_zero_partial_blocks ( handle , inode , offset , length ) ;if ( ret ) goto out_stop ;first_block = ( offset + sb -> s_blocksize - 1 ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ;stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ;if ( first_block >= stop_block ) goto out_stop ;down_write ( & EXT4_I ( inode ) -> i_data_sem ) ;ext4_discard_preallocations ( inode ) ;ret = ext4_es_remove_extent ( inode , first_block , stop_block - first_block ) ;if ( ret ) {up_write ( & EXT4_I ( inode ) -> i_data_sem ) ;goto out_stop ;}if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ret = ext4_ext_remove_space ( inode , first_block , stop_block - 1 ) ;else ret = ext4_ind_remove_space ( handle , inode , first_block , stop_block ) ;up_write ( & EXT4_I ( inode ) -> i_data_sem ) ;if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ;if ( last_block_offset > first_block_offset )  truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ;out_dio :  ext4_inode_resume_unlocked_dio ( inode ) ;out_mutex : mutex_unlock ( & inode -> i_mutex ) ;","ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;first_block_offset = round_up ( offset , sb -> s_blocksize ) ;last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ;out_dio : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;ext4_inode_resume_unlocked_dio ( inode ) ;out_mutex : mutex_unlock ( & inode -> i_mutex ) ;",688
2167,kiocb -> ki_nr_segs = kiocb -> ki_nbytes ;kiocb -> ki_cur_seg = 0 ;,"ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ;if ( ret < 0 ) goto out ;kiocb -> ki_nr_segs = kiocb -> ki_nbytes ;kiocb -> ki_cur_seg = 0 ;",689
2168,"YV12_BUFFER_CONFIG sd = {0 };int64_t time_stamp = 0 , time_end_stamp = 0 ;vp9_ppflags_t flags = {0 };VP9_COMMON * cm = NULL ;ctx -> img_avail = 0 ;const vpx_codec_err_t res =   ctx -> base . iface -> dec . peek_si ( * data , data_sz , & ctx -> si ) ;if ( res != VPX_CODEC_OK ) return res ;}if ( ! ctx -> decoder_init ) {init_decoder ( ctx ) ;if ( ctx -> pbi == NULL )  return VPX_CODEC_ERROR ;ctx -> decoder_init = 1 ;}cm = & ctx -> pbi -> common ;if ( vp9_receive_compressed_data ( ctx -> pbi , data_sz , data , deadline ) ) return update_error_state ( ctx , & cm -> error ) ;if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) set_ppflags ( ctx , & flags ) ;if ( vp9_get_raw_frame ( ctx -> pbi , & sd , & time_stamp , & time_end_stamp , & flags ) ) return update_error_state ( ctx , & cm -> error ) ;yuvconfig2image ( & ctx -> img , & sd , user_priv ) ;ctx -> img . fb_priv = cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ;ctx -> img_avail = 1 ;","const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ;( void ) deadline ;int is_intra_only = 0 ;const vpx_codec_err_t res = ctx -> base . iface -> dec . peek_si ( * data , data_sz , & ctx -> si , & is_intra_only , ctx -> decrypt_cb , ctx -> decrypt_state ) ;if ( res != VPX_CODEC_OK ) return res ;if ( ! ctx -> frame_parallel_decode ) {VPxWorker * const worker = ctx -> frame_workers ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;frame_worker_data -> data = * data ;frame_worker_data -> data_size = data_sz ;frame_worker_data -> user_priv = user_priv ;frame_worker_data -> received_frame = 1 ;frame_worker_data -> pbi -> decrypt_cb = ctx -> decrypt_cb ;frame_worker_data -> pbi -> decrypt_state = ctx -> decrypt_state ;worker -> had_error = 0 ;winterface -> execute ( worker ) ;* data = frame_worker_data -> data_end ;if ( worker -> had_error ) return update_error_state ( ctx , & frame_worker_data -> pbi -> common . error ) ;check_resync ( ctx , frame_worker_data -> pbi ) ;}else {VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_submit_worker_id ] ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) vp9_frameworker_copy_context ( & ctx -> frame_workers [ ctx -> next_submit_worker_id ] , & ctx -> frame_workers [ ctx -> last_submit_worker_id ] ) ;frame_worker_data -> pbi -> ready_for_new_data = 0 ;if ( frame_worker_data -> scratch_buffer_size < data_sz ) {frame_worker_data -> scratch_buffer = ( uint8_t * ) vpx_realloc ( frame_worker_data -> scratch_buffer , data_sz ) ;if ( frame_worker_data -> scratch_buffer == NULL ) {set_error_detail ( ctx , ""Failed<S2SV_blank>to<S2SV_blank>reallocate<S2SV_blank>scratch<S2SV_blank>buffer"" ) ;return VPX_CODEC_MEM_ERROR ;}frame_worker_data -> scratch_buffer_size = data_sz ;}frame_worker_data -> data_size = data_sz ;memcpy ( frame_worker_data -> scratch_buffer , * data , data_sz ) ;frame_worker_data -> frame_decoded = 0 ;frame_worker_data -> frame_context_ready = 0 ;frame_worker_data -> received_frame = 1 ;frame_worker_data -> data = frame_worker_data -> scratch_buffer ;frame_worker_data -> user_priv = user_priv ;if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) ctx -> last_submit_worker_id = ( ctx -> last_submit_worker_id + 1 ) % ctx -> num_frame_workers ;ctx -> next_submit_worker_id = ( ctx -> next_submit_worker_id + 1 ) % ctx -> num_frame_workers ;-- ctx -> available_threads ;worker -> had_error = 0 ;winterface -> launch ( worker ) ;}",690
2169,"CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ||  ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) ||  bcount != caf_chunk_header . mChunkSize ) {","CAFChannelLayout * caf_channel_layout ;if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) {error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\\\'chan\\\'<S2SV_blank>chunk!"" ) ;return WAVPACK_SOFT_ERROR ;}if ( debug_logging_mode ) error_line ( ""\\\'chan\\\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ;caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {",691
2170,"config -> qmode |= QMODE_REORDERED_CHANS ;channel_layout = num_descriptions ;}if ( ! idents ) {free ( channel_identities ) ;channel_identities = NULL ;}else channel_identities [ idents ] = 0 ;if ( debug_logging_mode ) {error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS"" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;if ( channel_reorder && num_descriptions <= 8 ) {char reorder_string [ ] = ""12345678"" ;for ( i = 0 ;i < num_descriptions ;++ i ) reorder_string [ i ] = channel_reorder [ i ] + \'1\' ;reorder_string [ i ] = 0 ;error_line ( ""reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\""\\\}}}break ;case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ;if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x"" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;break ;default : for ( i = 0 ;i < NUM_LAYOUTS ;++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {config -> channel_mask = layouts [ i ] . mChannelBitmap ;channel_layout = layouts [ i ] . mChannelLayoutTag ;if ( layouts [ i ] . mChannelReorder ) {channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;config -> qmode |= QMODE_REORDERED_CHANS ;}if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;if ( debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s"" , channel_layout , config -> channel_mask , channel_reorder ? ""yes"" : ""no"" , channel_identities ? ""yes"" : ""no"" ) ;break ;}if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( ""layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned"" , caf_channel_layout -> mChannelLayoutTag ) ;break ;}free ( caf_channel_layout ) ;}else if ( ! strncmp ( caf_chunk_header . mChunkType , ""data"" , 4 ) ) {uint32_t mEditCount ;if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) {else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) {error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ;return WAVPACK_SOFT_ERROR ;}if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) {config -> qmode |= QMODE_IGNORE_LENGTH ;if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ;else total_samples = - 1 ;}else {if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) {error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) {error_line ( "".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ;if ( ! total_samples ) {error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ;return WAVPACK_SOFT_ERROR ;}if ( total_samples > MAX_WAVPACK_SAMPLES ) {error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}}break ;}else {int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;","+ i ) reorder_string [ i ] = channel_reorder [ i ] + \'1\' ;+ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;char * buff ;if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) {buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;",691
2171,"usleep ( 200000 ) ;toggle_os_keylockstates ( p_dev -> fd , keylockstates ) ;","TEMP_FAILURE_RETRY ( usleep ( 200000 ) ) ;toggle_os_keylockstates ( p_dev -> fd , keylockstates ) ;",692
2172,"MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride ,   xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ,  INT_MAX ) ;","MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;err = vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ) ;",693
2173,"pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ;void * memory ;","pgprot_t prot = __get_dma_pgprot ( attrs , PAGE_KERNEL ) ;void * memory ;",694
2174,"emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , xcp , 0 ) ;MIPS_FPU_EMU_INC_STATS ( emulated ) ;","emul : perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , xcp , 0 ) ;MIPS_FPU_EMU_INC_STATS ( emulated ) ;",695
2175,"if ( recvd ) {clear_sock ( pool ) ;sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;}else {if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\"",<S2SV_blank>\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\""]}"" , swork_id ++ ) ;}if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) {",if ( n2size < 1 ) {,696
2176,"if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;","if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;",696
2177,"cifs_small_buf_release ( req ) ;rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ;free_rsp_buf ( resp_buftype , rsp ) ;return rc ;","rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ;cifs_small_buf_release ( req ) ;free_rsp_buf ( resp_buftype , rsp ) ;return rc ;",697
2178,addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;addr . sin_port = htons ( port ) ;,addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;addr . sin_port = htons ( port ) ;,698
2179,"
","if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",699
2180,bmp_info . number_colors = ReadBlobLSBLong ( image ) ;bmp_info . colors_important = ReadBlobLSBLong ( image ) ;,bmp_info . number_colors = ReadBlobLSBLong ( image ) ;bmp_info . colors_important = ReadBlobLSBLong ( image ) ;,699
2181,ufs -> upper_mnt = clone_private_mount ( & upperpath ) ;err = PTR_ERR ( ufs -> upper_mnt ) ;,"sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ;err = - EINVAL ;if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) {pr_err ( ""overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\\goto out_put_workpath ;}ufs -> upper_mnt = clone_private_mount ( & upperpath ) ;err = PTR_ERR ( ufs -> upper_mnt ) ;",700
2182,static const int16_t * filter = vp9_down2_symodd_half_filter ;const int filter_len_half = sizeof ( vp9_down2_symodd_half_filter ) / 2 ;,const int16_t * filter = vp9_down2_symodd_half_filter ;const int filter_len_half = sizeof ( vp9_down2_symodd_half_filter ) / 2 ;,701
2183,"mutt_error ( ""%s"" , s + 3 ) ;}","mutt_error ( ""%s"" , s + 2 ) ;}",702
2184,"bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ;if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\\free ( bin -> dyld_info ) ;return false ;","bin -> dyld_info = calloc ( 1 , sizeof ( struct dyld_info_command ) ) ;if ( bin -> dyld_info ) {if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\\R_FREE ( bin -> dyld_info ) ;return false ;",703
2185,"break ;case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ;","}break ;case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ;",703
2186,int n ;int ret ;long newbufsize ;long newpos ;,size_t n ;int ret ;size_t newbufsize ;size_t newpos ;,704
2187,"newbufsize <<= 1 ;assert ( newbufsize >= 0 ) ;JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%z\\\JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%ul\\\if ( m -> pos_ > m -> len_ ) {n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ;","if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) {JAS_DBGLOG ( 100 , ( ""new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\\return - 1 ;}JAS_DBGLOG ( 100 , ( ""mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\\assert ( newbufsize > 0 ) ;if ( m -> pos_ > m -> len_ ) {n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ;",704
2188,"void * dllhandle ;if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\","void * dllhandle ;if ( COM_CompareExtension ( name , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , name ) ;return NULL ;}if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\",705
2189,rfcomm_dlc_accept ( d ) ;msg -> msg_namelen = 0 ;,rfcomm_dlc_accept ( d ) ;,706
2190,"d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ;d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ;q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ;","d0u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 0 ] ) ;d1u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 1 ] ) ;q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ;",707
2191,# endif  },"conf_write ( fp , ""<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o"" , global_data -> umask ) ;# endif }",708
2192,"char sbuf [ 128 ] ;void * mbuf = NULL ;void * parg = ( void * ) arg ;long err = - EINVAL ;bool has_array_args ;size_t array_size = 0 ;void __user * user_ptr = NULL ;void * * kernel_ptr = NULL ;if ( _IOC_DIR ( cmd ) != _IOC_NONE ) {if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) {parg = sbuf ;}else {mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ;if ( NULL == mbuf ) return - ENOMEM ;parg = mbuf ;}err = - EFAULT ;if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) {unsigned long n = cmd_input_size ( cmd ) ;if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ;if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ;}else {memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ;}}err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ;if ( err < 0 ) goto out ;has_array_args = err ;if ( has_array_args ) {mbuf = kmalloc ( array_size , GFP_KERNEL ) ;err = - ENOMEM ;if ( NULL == mbuf ) goto out_array_args ;err = - EFAULT ;if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ;* kernel_ptr = mbuf ;}err = __video_do_ioctl ( file , cmd , parg ) ;if ( err == - ENOIOCTLCMD ) err = - EINVAL ;if ( has_array_args ) {* kernel_ptr = user_ptr ;if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ;goto out_array_args ;}if ( err < 0 ) goto out ;out_array_args : switch ( _IOC_DIR ( cmd ) ) {case _IOC_READ : case ( _IOC_WRITE | _IOC_READ ) : if ( copy_to_user ( ( void __user * ) arg , parg , _IOC_SIZE ( cmd ) ) ) err = - EFAULT ;break ;}out : kfree ( mbuf ) ;return err ;","return video_usercopy ( file , cmd , arg , __video_do_ioctl ) ;",709
2193,# endif  return tok ;},# endif tok -> type_comments = 0 ;return tok ;},710
2194,break ;default : break ;,strict = true ;break ;default : break ;,711
2195,"static void read_inter_mode_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) {int i , j ;","static void read_inter_mode_probs ( FRAME_CONTEXT * fc , vpx_reader * r ) {int i , j ;",712
2196,"static void get_sb_partition_size_range ( VP9_COMP * cpi , MODE_INFO * * mi_8x8 ,  BLOCK_SIZE * min_block_size ,  BLOCK_SIZE * max_block_size ) {MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;","static void get_sb_partition_size_range ( MACROBLOCKD * xd , MODE_INFO * * mi_8x8 , BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size , int bs_hist [ BLOCK_SIZES ] ) {",713
2197,"* min_block_size = MIN ( * min_block_size , sb_type ) ;* max_block_size = MAX ( * max_block_size , sb_type ) ;","bs_hist [ sb_type ] ++ ;* min_block_size = MIN ( * min_block_size , sb_type ) ;* max_block_size = MAX ( * max_block_size , sb_type ) ;",713
2198,"unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ;ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ;ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) ,  GFP_KERNEL ) ;memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ;INIT_LIST_HEAD ( & ctx -> tsgl ) ;","struct skcipher_tfm * tfm = private ;struct crypto_skcipher * skcipher = tfm -> skcipher ;unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( skcipher ) ;if ( ! tfm -> has_key ) return - ENOKEY ;ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ;ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( skcipher ) , GFP_KERNEL ) ;memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( skcipher ) ) ;INIT_LIST_HEAD ( & ctx -> tsgl ) ;",714
2199,"skcipher_request_set_tfm ( & ctx -> req , private ) ;skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ;","skcipher_request_set_tfm ( & ctx -> req , skcipher ) ;skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , af_alg_complete , & ctx -> completion ) ;",714
2200,uint32_t tag = 0 ;int tcm_tmr ;,int tcm_tmr ;,715
2201,"if ( tcm_tmr < 0 ) {send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED ;goto fail ;}if ( srp_tsk -> tsk_mgmt_func == SRP_TSK_ABORT_TASK ) {rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ;if ( rc < 0 ) {tag = srp_tsk -> task_tag ;}rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , tag , TARGET_SCF_ACK_KREF ) ;","rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , srp_tsk -> task_tag ) ;if ( rc < 0 ) {tag = srp_tsk -> task_tag , TARGET_SCF_ACK_KREF ) ;",715
2202,"char * command , * args = value ;size_t arg_size ;if ( size == 0 )  return - EINVAL ;if ( args [ size - 1 ] != \'\\\\0\' ) {if ( size == PAGE_SIZE )   return - EINVAL ;args [ size ] = \'\\\\0\' ;}args = value ;if ( ! args ) return - EINVAL ;if ( ! * args ) return - EINVAL ;if ( strcmp ( name , ""current"" ) == 0 ) {if ( strcmp ( command , ""changehat"" ) == 0 ) {}error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ;","char * command , * largs = NULL , * args = value ;size_t arg_size ;if ( size == 0 ) return - EINVAL ;if ( args [ size - 1 ] != \'\\\\0\' ) {largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ;if ( ! args ) return - ENOMEM ;memcpy ( args , value , size ) ;args [ size ] = \'\\\\0\' ;}error = - EINVAL ;if ( ! args ) goto out ;if ( ! * args ) goto out ;if ( strcmp ( name , ""current"" ) == 0 ) {if ( strcmp ( command , ""changehat"" ) == 0 ) {}error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ;",716
2203,"}if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ;}else  return - EINVAL ;","}else if ( strcmp ( name , ""exec"" ) == 0 ) {if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ;}else if ( strcmp ( command , ""permhat"" ) == 0 ) {error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ;else goto fail ;}if ( strcmp ( command , ""exec"" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ;}else return - EINVAL ;",716
2204,"aad . error = - EINVAL ;aa_audit_msg ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ;return - EINVAL ;}","aad . error = error = - EINVAL ;aa_audit_msg ( AUDIT_APPARMOR_DENIED , & sa , NULL ) ;goto out ;}",716
2205,ret = 0 ;goto error2 ;,key_put ( keyring ) ;ret = 0 ;goto error2 ;,717
2206,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",718
2207,"if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) {","if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , p_total_data_size , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) {",718
2208,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",718
2209,"int ret = select ( ( max_curr_s + 1 ) , & curr_set , NULL , NULL , NULL ) ;BTIF_TRACE_DEBUG ( ""select<S2SV_blank>unblocked<S2SV_blank>ret=%d"" , ret ) ;","int ret = TEMP_FAILURE_RETRY ( select ( ( max_curr_s + 1 ) , & curr_set , NULL , NULL , NULL ) ) ;BTIF_TRACE_DEBUG ( ""select<S2SV_blank>unblocked<S2SV_blank>ret=%d"" , ret ) ;",719
2210,"ssize_t sent = send ( fd , p_buf -> data + p_buf -> offset , p_buf -> len , MSG_DONTWAIT ) ;if ( sent == - 1 ) {","ssize_t sent = TEMP_FAILURE_RETRY ( send ( fd , p_buf -> data + p_buf -> offset , p_buf -> len , MSG_DONTWAIT ) ) ;if ( sent == - 1 ) {",720
2211,"spin_lock ( & inode -> i_lock ) ;inode -> i_blocks -= ( blocks_per_huge_page ( h ) * freed ) ;spin_unlock ( & inode -> i_lock ) ;hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ;hugetlb_acct_memory ( h , - ( chg - freed ) ) ;","struct hugepage_subpool * spool = subpool_inode ( inode ) ;spin_lock ( & inode -> i_lock ) ;hugepage_subpool_put_pages ( spool , ( chg - freed ) ) ;hugetlb_acct_memory ( h , - ( chg - freed ) ) ;",721
2212,"static void  _copy_from_pages ( char * p , struct page * * pages , size_t pgbase , size_t len ) {","void _copy_from_pages ( char * p , struct page * * pages , size_t pgbase , size_t len ) {",722
2213,"struct in6_addr * saddr = NULL , * final_p , final ;struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;if ( np -> sndflow ) {fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ;IP6_ECN_flow_init ( fl6 . flowlabel ) ;if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) {struct ip6_flowlabel * flowlabel ;flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ;if ( ! flowlabel ) return - EINVAL ;fl6_sock_release ( flowlabel ) ;}}if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 0x1 ;addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ;if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ;if ( addr_type & IPV6_ADDR_LINKLOCAL ) {if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) {if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ;sk -> sk_bound_dev_if = usin -> sin6_scope_id ;}if ( ! sk -> sk_bound_dev_if ) return - EINVAL ;}if ( tp -> rx_opt . ts_recent_stamp && ! ipv6_addr_equal ( & sk -> sk_v6_daddr , & usin -> sin6_addr ) ) {tp -> rx_opt . ts_recent = 0 ;tp -> rx_opt . ts_recent_stamp = 0 ;tp -> write_seq = 0 ;}sk -> sk_v6_daddr = usin -> sin6_addr ;np -> flow_label = fl6 . flowlabel ;if ( addr_type == IPV6_ADDR_MAPPED ) {u32 exthdrlen = icsk -> icsk_ext_hdr_len ;struct sockaddr_in sin ;SOCK_DEBUG ( sk , ""connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\\if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ;sin . sin_family = AF_INET ;sin . sin_port = usin -> sin6_port ;sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ;icsk -> icsk_af_ops = & ipv6_mapped ;sk -> sk_backlog_rcv = tcp_v4_do_rcv ;# ifdef CONFIG_TCP_MD5SIG tp -> af_specific = & tcp_sock_ipv6_mapped_specific ;# endif err = tcp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ;if ( err ) {icsk -> icsk_ext_hdr_len = exthdrlen ;icsk -> icsk_af_ops = & ipv6_specific ;sk -> sk_backlog_rcv = tcp_v6_do_rcv ;# ifdef CONFIG_TCP_MD5SIG tp -> af_specific = & tcp_sock_ipv6_specific ;# endif goto failure ;}np -> saddr = sk -> sk_v6_rcv_saddr ;return err ;}if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ;fl6 . flowi6_proto = IPPROTO_TCP ;fl6 . daddr = sk -> sk_v6_daddr ;fl6 . saddr = saddr ? * saddr : np -> saddr ;fl6 . flowi6_oif = sk -> sk_bound_dev_if ;fl6 . flowi6_mark = sk -> sk_mark ;fl6 . fl6_dport = usin -> sin6_port ;fl6 . fl6_sport = inet -> inet_sport ;final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;","struct in6_addr * saddr = NULL , * final_p , final ;struct ipv6_txoptions * opt ;struct flowi6 fl6 ;memset ( & fl6 , opt , & final ) ;security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;",723
2214,if ( np -> opt )   icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen +   np -> opt -> opt_nflen ) ;tp -> rx_opt . mss_clamp = IPV6_MIN_MTU - sizeof ( struct tcphdr ) - sizeof ( struct ipv6hdr ) ;,if ( np -> opt ) icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + np -> opt -> opt_nflen ) ;tp -> rx_opt . mss_clamp = IPV6_MIN_MTU - sizeof ( struct tcphdr ) - sizeof ( struct ipv6hdr ) ;,723
2215,"dwc3_gadget_giveback ( dep , req , ret ) ;return ret ;","dwc3_gadget_del_and_unmap_request ( dep , req , ret ) ;return ret ;",724
2216,if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) )  break ;switch ( image_info -> interlace ) {,"status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;switch ( image_info -> interlace ) {",725
2217,if ( border < 0 ) {return ;,if ( border < 0 || color < 0 ) {return ;,726
2218,state -> indent = NULL ;state -> indent_len = 0 ;}}else {if ( state -> indent ) ruby_xfree ( state -> indent ) ;state -> indent = strdup ( RSTRING_PTR ( indent ) ) ;state -> indent_len = len ;,"state -> indent = fstrndup ( RSTRING_PTR ( indent ) , len ) ;state -> indent_len = len ;",727
2219,"if ( settings . verbose > 1 ) {fprintf ( stderr , ""%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\\}}if ( c -> protocol == binary_prot ) {if ( c -> rbytes < sizeof ( c -> binary_header ) ) {return 0 ;}else {# ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) {memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ;c -> rcurr = c -> rbuf ;if ( settings . verbose > 1 ) {fprintf ( stderr , ""%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\\}}# endif protocol_binary_request_header * req ;req = ( protocol_binary_request_header * ) c -> rcurr ;if ( settings . verbose > 1 ) {int ii ;fprintf ( stderr , ""<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:"" , c -> sfd ) ;for ( ii = 0 ;ii < sizeof ( req -> bytes ) ;++ ii ) {if ( ii % 4 == 0 ) {fprintf ( stderr , ""\\\}fprintf ( stderr , ""<S2SV_blank>0x%02x"" , req -> bytes [ ii ] ) ;}fprintf ( stderr , ""\\\}c -> binary_header = * req ;c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ;c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ;c -> binary_header . request . cas = ntohll ( req -> request . cas ) ;if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) {if ( settings . verbose ) {fprintf ( stderr , ""Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\\}return - 1 ;}c -> msgcurr = 0 ;c -> msgused = 0 ;c -> iovused = 0 ;if ( add_msghdr ( c ) != 0 ) {out_string ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ;return 0 ;}c -> cmd = c -> binary_header . request . opcode ;c -> keylen = c -> binary_header . request . keylen ;c -> opaque = c -> binary_header . request . opaque ;c -> cas = 0 ;dispatch_bin_command ( c ) ;c -> rbytes -= sizeof ( c -> binary_header ) ;c -> rcurr += sizeof ( c -> binary_header ) ;}}else {char * el , * cont ;if ( c -> rbytes == 0 ) return 0 ;el = memchr ( c -> rcurr , \'\\\if ( ! el ) {if ( c -> rbytes > 1024 ) {char * ptr = c -> rcurr ;while ( * ptr == \'<S2SV_blank>\' ) {++ ptr ;}if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) {conn_set_state ( c , conn_closing ) ;","+ ii ) {if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr , ""get<S2SV_blank>"" , 4 ) && strncmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" , 5 ) ) ) {+ ptr ;",728
2220,struct futex_hash_bucket * hb ;get_futex_key_refs ( & q -> key ) ;,struct futex_hash_bucket * hb ;,729
2221,"addModuleArgument ( db , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ;addModuleArgument ( db , pTable , 0 ) ;addModuleArgument ( db , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ;assert ( ( pParse -> sNameToken . z == pName2 -> z && pName2 -> z != 0 ) || ( pParse -> sNameToken . z == pName1 -> z && pName2 -> z == 0 ) ) ;","addModuleArgument ( pParse , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ;addModuleArgument ( pParse , pTable , 0 ) ;addModuleArgument ( pParse , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ;assert ( ( pParse -> sNameToken . z == pName2 -> z && pName2 -> z != 0 ) || ( pParse -> sNameToken . z == pName1 -> z && pName2 -> z == 0 ) ) ;",730
2222,"switch ( type )  {case - 1 : {SetPixelAlpha ( image , pixel , q ) ;break ;case - 2 : case 0 : {SetPixelRed ( image , pixel , q ) ;if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ;if ( image -> storage_class == PseudoClass ) {if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ;else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;if ( image -> depth == 1 ) {SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) &   ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;x -- ;continue ;}}break ;}case 1 : {if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ;else SetPixelGreen ( image , pixel , q ) ;break ;case 2 : {if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ;else SetPixelBlue ( image , pixel , q ) ;break ;}case 3 : {if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ;else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ;break ;}case 4 : {if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ;if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ;break ;}default : break ;}q += GetPixelChannels ( image ) ;","if ( image -> depth > 1 ) {SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ;q += GetPixelChannels ( image ) ;else {SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;if ( x != image -> columns ) x -- ;continue ;",731
2223,"if ( ! mp -> ports && ! mp -> mglist &&  netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;","if ( ! mp -> ports && ! mp -> mglist && mp -> timer_armed && netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;",732
2224,"int sec ;int dsec ;guint pkt_len ;char cap_src [ 13 ] ;guint offset = 0 ;gchar dststr [ 13 ] ;if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" ,  & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) {return - 1 ;}","int pkt_len ;int sec ;int dsec ;char cap_src [ 13 ] ;int offset = 0 ;gchar dststr [ 13 ] ;if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/"" , & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) {return - 1 ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;}",733
2225,},"id_key_set = rb_intern_const ( ""key_set"" ) ;}",734
2226,# if CONFIG_MULTI_RES_ENCODING  cpi -> current_ref_frames [ GOLDEN_FRAME ] = cm -> current_video_frame ;cpi -> current_ref_frames [ ALTREF_FRAME ] = cm -> current_video_frame ;# endif  }# if CONFIG_MULTI_RES_ENCODING  cpi -> current_ref_frames [ ALTREF_FRAME ] = cm -> current_video_frame ;# endif  },cpi -> current_ref_frames [ GOLDEN_FRAME ] = cm -> current_video_frame ;}cpi -> current_ref_frames [ ALTREF_FRAME ] = cm -> current_video_frame ;},735
2227,# if CONFIG_MULTI_RES_ENCODING  cpi -> current_ref_frames [ ALTREF_FRAME ] = cpi -> current_ref_frames [ LAST_FRAME ] ;# endif  }# if CONFIG_MULTI_RES_ENCODING  cpi -> current_ref_frames [ ALTREF_FRAME ] = cpi -> current_ref_frames [ GOLDEN_FRAME ] ;# endif  },cpi -> current_ref_frames [ ALTREF_FRAME ] = cpi -> current_ref_frames [ LAST_FRAME ] ;}cpi -> current_ref_frames [ ALTREF_FRAME ] = cpi -> current_ref_frames [ GOLDEN_FRAME ] ;},735
2228,# if CONFIG_MULTI_RES_ENCODING  cpi -> current_ref_frames [ GOLDEN_FRAME ] = cm -> current_video_frame ;# endif  },cpi -> current_ref_frames [ GOLDEN_FRAME ] = cm -> current_video_frame ;},735
2229,# if CONFIG_MULTI_RES_ENCODING  cpi -> current_ref_frames [ GOLDEN_FRAME ] = cpi -> current_ref_frames [ LAST_FRAME ] ;# endif  }# if CONFIG_MULTI_RES_ENCODING  cpi -> current_ref_frames [ GOLDEN_FRAME ] = cpi -> current_ref_frames [ ALTREF_FRAME ] ;# endif  },cpi -> current_ref_frames [ GOLDEN_FRAME ] = cpi -> current_ref_frames [ LAST_FRAME ] ;}cpi -> current_ref_frames [ GOLDEN_FRAME ] = cpi -> current_ref_frames [ ALTREF_FRAME ] ;},735
2230,"# if CONFIG_MULTI_RES_ENCODING  cpi -> current_ref_frames [ LAST_FRAME ] = cm -> current_video_frame ;# endif  }vp8_yv12_copy_frame (  cpi -> Source , & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] ) ;vp8_yv12_extend_frame_borders ( & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] ) ;for ( i = 2 ;i ++ )  vp8_yv12_copy_frame (  & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] ,  & cpi -> denoiser . yv12_running_avg [ i ] ) ;","cpi -> current_ref_frames [ LAST_FRAME ] = cm -> current_video_frame ;}for ( i = LAST_FRAME ;i ++ ) vp8_yv12_copy_frame ( & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] , & cpi -> denoiser . yv12_running_avg [ i ] ) ;",735
2231,}# endif },"if ( cpi -> oxcf . noise_sensitivity == 4 ) vp8_yv12_copy_frame ( cpi -> Source , & cpi -> denoiser . yv12_last_source ) ;}# endif }",735
2232,# endif  msg -> msg_namelen = 0 ;copied = data_skb -> len ;,# endif copied = data_skb -> len ;,736
2233,"for ( i = 0 ;data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ;assert ( data [ i ] ) ;","assert ( numcmpts <= 3 ) ;for ( i = 0 ;i < 3 ;++ i ) {if ( ! ( data [ i ] = 0 ;}for ( i = 0 ;data [ i ] = jas_matrix_create ( jas_image_height ( image ) , jas_image_width ( image ) ) ) ) {goto error ;}",737
2234,return - 1 ;},goto error ;},737
2235,return - 1 ;}nz -= 8 ;z &= RAS_ONES ( nz ) ;return - 1 ;return - 1 ;,goto error ;}nz -= 8 ;z &= RAS_ONES ( nz ) ;goto error ;goto error ;,737
2236,"
",data [ i ] = 0 ;error : for ( i = 0 ;i < numcmpts ;++ i ) {if ( data [ i ] ) {jas_matrix_destroy ( data [ i ] ) ;}}return - 1 ;,737
2237,case CIPSO_V4_TAG_RBITMAP : if ( tag_len < CIPSO_V4_TAG_RBM_BLEN ) {,case CIPSO_V4_TAG_RBITMAP : if ( skb == NULL || tag_len < CIPSO_V4_TAG_RBM_BLEN ) {,738
2238,case CIPSO_V4_TAG_LOCAL :  if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) {err_offset = opt_iter ;,case CIPSO_V4_TAG_LOCAL : if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) {err_offset = opt_iter ;,738
2239,"if ( rcu_use_vmalloc ( size ) ) {out = vmalloc ( HDRLEN_VMALLOC + size ) ;if ( out ) {out += HDRLEN_VMALLOC ;container_of ( out , struct ipc_rcu_hdr , data ) -> refcount = 1 ;}if ( out ) {out += HDRLEN_KMALLOC ;container_of ( out , struct ipc_rcu_hdr , data ) -> refcount = 1 ;}return out ;","if ( ! out ) goto done ;out += HDRLEN_VMALLOC ;container_of ( out , struct ipc_rcu_hdr , data ) -> refcount = 1 ;if ( ! out ) goto done ;out += HDRLEN_KMALLOC ;atomic_set ( & container_of ( out , struct ipc_rcu_hdr , data ) -> refcount , 1 ) ;done : return out ;",739
2240,if ( swapped == 1 ) {pcap_fh . version_major = SWAPSHORT ( pcap_fh . version_major ) ;pcap_fh . version_minor = SWAPSHORT ( pcap_fh . version_minor ) ;pcap_fh . thiszone = SWAPLONG ( pcap_fh . thiszone ) ;pcap_fh . sigfigs = SWAPLONG ( pcap_fh . sigfigs ) ;pcap_fh . snaplen = SWAPLONG ( pcap_fh . snaplen ) ;pcap_fh . linktype = SWAPLONG ( pcap_fh . linktype ) ;,"if ( caplentoobig ) {printf ( ""\\\close ( fd ) ;break ;",740
2241,if ( last_sec > 0 && last_usec > 0 ) {if ( ( pcap_ph . ts . tv_sec == last_sec ) ? ( pcap_ph . ts . tv_usec < last_usec ) : ( pcap_ph . ts . tv_sec < last_sec ) ) {,if ( last_sec > 0 && last_usec > 0 ) {if ( ( pcap_ph . ts . tv_sec == last_sec ) ? ( pcap_ph . ts . tv_usec < last_usec ) : ( pcap_ph . ts . tv_sec < last_sec ) ) {,740
2242,continue ;},continue ;},740
2243,uchar buf [ MIF_MAGICLEN ] ;uint_fast32_t magic ;,jas_uchar buf [ MIF_MAGICLEN ] ;uint_fast32_t magic ;,741
2244,"static void write_selected_tx_size ( const VP9_COMP * cpi ,  TX_SIZE tx_size , BLOCK_SIZE bsize ,  vp9_writer * w ) {const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ;const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;const vp9_prob * const tx_probs = get_tx_probs2 ( max_tx_size , xd ,  & cpi -> common . fc . tx_probs ) ;vp9_write ( w , tx_size != TX_4X4 , tx_probs [ 0 ] ) ;if ( tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) {vp9_write ( w , tx_size != TX_8X8 , tx_probs [ 1 ] ) ;if ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 )  vp9_write ( w , tx_size != TX_16X16 , tx_probs [ 2 ] ) ;}","static void write_selected_tx_size ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) {TX_SIZE tx_size = xd -> mi [ 0 ] -> mbmi . tx_size ;BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ;const vpx_prob * const tx_probs = get_tx_probs2 ( max_tx_size , xd , & cpi -> common . fc . tx_probs ) ;vpx_write ( w , tx_size != TX_4X4 , tx_probs [ 0 ] ) ;if ( tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) {vpx_write ( w , tx_size != TX_8X8 , tx_probs [ 1 ] ) ;if ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 ) vpx_write ( w , tx_size != TX_16X16 , tx_probs [ 2 ] ) ;}",742
2245,"static void set_source_var_based_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  MODE_INFO * * mi_8x8 ,  int mi_row , int mi_col ) {MACROBLOCK * x = & cpi -> mb ;const int mis = cm -> mi_stride ;int row8x8_remaining = tile -> mi_row_end - mi_row ;int col8x8_remaining = tile -> mi_col_end - mi_col ;int r , c ;MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ;assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ;const int src_stride = x -> plane [ 0 ] . src . stride ;const int pre_stride = cpi -> Last_Source -> y_stride ;const uint8_t * src = x -> plane [ 0 ] . src . buf ;const int pre_offset = ( mi_row * MI_SIZE ) * pre_stride + ( mi_col * MI_SIZE ) ;const uint8_t * pre_src = cpi -> Last_Source -> y_buffer + pre_offset ;const int thr_32x32 = cpi -> sf . source_var_thresh ;const int thr_64x64 = thr_32x32 << 1 ;int use16x16 = 0 ;for ( i = 0 ;diff d16 [ 4 ] ;for ( j = 0 ;int b_offset = b_mi_row * MI_SIZE * src_stride + b_mi_col * MI_SIZE ;vp9_get_sse_sum_16x16 ( src + b_offset , src_stride , pre_src + b_offset ,  pre_stride , & d16 [ j ] . sse , & d16 [ j ] . sum ) ;d16 [ j ] . var = d16 [ j ] . sse -  ( ( ( uint32_t ) d16 [ j ] . sum * d16 [ j ] . sum ) >> 8 ) ;index = b_mi_row * mis + b_mi_col ;if ( d16 [ 0 ] . var < thr_32x32 && d16 [ 1 ] . var < thr_32x32 && d16 [ 2 ] . var < thr_32x32 && d16 [ 3 ] . var < thr_32x32 ) {d32 [ i ] . sse = d16 [ 0 ] . sse ;d32 [ i ] . sum = d16 [ 0 ] . sum ;for ( j = 1 ;d32 [ i ] . sse += d16 [ j ] . sse ;if ( ! ( ( cm -> current_video_frame - 1 ) %  cpi -> sf . search_type_check_frequency ) ) cpi -> use_large_partition_rate += 1 ;else {use16x16 = 1 ;}if ( ! use16x16 ) {if ( d32 [ 0 ] . var < thr_64x64 && d32 [ 1 ] . var < thr_64x64 && d32 [ 2 ] . var < thr_64x64 && d32 [ 3 ] . var < thr_64x64 ) {BLOCK_SIZE bsize = BLOCK_16X16 ;int bh = num_8x8_blocks_high_lookup [ bsize ] ;int bw = num_8x8_blocks_wide_lookup [ bsize ] ;for ( r = 0 ;r < MI_BLOCK_SIZE ;r += bh ) {for ( c = 0 ;c < MI_BLOCK_SIZE ;c += bw ) {int index = r * mis + c ;bsize = find_partition_size ( bsize , ( row8x8_remaining - r ) , ( col8x8_remaining - c ) , & bh , & bw ) ;mi_8x8 [ index ] = mi_upper_left + index ;mi_8x8 [ index ] -> mbmi . sb_type = bsize ;}}","static void set_source_var_based_partition ( VP9_COMP * cpi , const TileInfo * const tile , MACROBLOCK * const x , MODE_INFO * * mi_8x8 , int mi_row , int mi_col ) {const int mis = cm -> mi_stride ;const int row8x8_remaining = tile -> mi_row_end - mi_row ;const int col8x8_remaining = tile -> mi_col_end - mi_col ;MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ;vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ;assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ;const int offset = ( mi_row >> 1 ) * cm -> mb_cols + ( mi_col >> 1 ) ;int is_larger_better = 0 ;int use32x32 = 0 ;unsigned int thr = cpi -> source_var_thresh ;memset ( d32 , 0 , 4 * sizeof ( diff ) ) ;for ( i = 0 ;diff * d16 [ 4 ] ;for ( j = 0 ;int boffset = b_mi_row / 2 * cm -> mb_cols + b_mi_col / 2 ;d16 [ j ] = cpi -> source_diff_var + offset + boffset ;index = b_mi_row * mis + b_mi_col ;is_larger_better = ( d16 [ 0 ] -> var < thr ) && ( d16 [ 1 ] -> var < thr ) && ( d16 [ 2 ] -> var < thr ) && ( d16 [ 3 ] -> var < thr ) ;if ( is_larger_better ) {use32x32 += 1 ;for ( j = 0 ;j < 4 ;j ++ ) {diff d16 [ 4 ] ;for ( j = 0 ;d32 [ i ] . sse , & d16 [ j ] . sum ) ;d16 [ j ] . var = d16 [ j ] . sse - ( ( ( uint32_t ) d16 [ j ] . sum * d16 [ j ] . sum ) >> 8 ) ;index = b_mi_row * mis + b_mi_col ;mi_8x8 [ index ] = mi_upper_left + index ;mi_8x8 [ index ] -> mbmi . sb_type = BLOCK_16X16 ;}if ( d16 [ 0 ] . var < thr_32x32 && d16 [ 1 ] . var < thr_32x32 && d16 [ 2 ] . var < thr_32x32 && d16 [ 3 ] . var < thr_32x32 ) {d32 [ i ] . sse += d16 [ j ] -> sse ;d32 [ i ] . sum = d16 [ 0 ] . sum += d16 [ j ] -> sum ;}d32 [ i ] . var = d32 [ i ] . sse += d16 [ j ] . sse ;if ( use32x32 == 4 ) {thr <<= 1 ;is_larger_better = ( d32 [ 0 ] . var < thr ) && ( d32 [ 1 ] . var < thr ) && ( d32 [ 2 ] . var < thr ) && ( d32 [ 3 ] . var < thr ) ;if ( is_larger_better ) {int bh = num_8x8_blocks_high_lookup [ BLOCK_16X16 ] ;int bw = num_8x8_blocks_wide_lookup [ BLOCK_16X16 ] ;set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , BLOCK_16X16 , mi_8x8 ) ;",743
2246,unsigned long flags ;if ( ! timeout ) timeout = ( HZ * EDGE_CLOSING_WAIT ) / 100 ;,unsigned long flags ;if ( ! tty ) return ;if ( ! timeout ) timeout = ( HZ * EDGE_CLOSING_WAIT ) / 100 ;,744
2247,static void parse_input ( h2o_http2_conn_t * conn )  {,static int parse_input ( h2o_http2_conn_t * conn ) {,745
2248,close_connection ( conn ) ;return ;return ;EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ;},return close_connection ( conn ) ;return 0 ;EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ;return 0 ;},745
2249,"IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len )  DecodedValue = gau2_impeg2d_tab_one_1_9 [ u4_bits >> 8 ] ;","IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) lead_zeros = CLZ ( u4_bits ) - 15 ;if ( lead_zeros > 11 ) {return IMPEG2D_MB_DATA_DECODE_ERR ;}DecodedValue = gau2_impeg2d_tab_one_1_9 [ u4_bits >> 8 ] ;",746
2250,"IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) }IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len )  DecodedValue = gau2_impeg2d_tab_zero_1_9 [ u4_bits >> 8 ] ;u4_sym_len = BITS ( DecodedValue , 3 , 0 ) ;","IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) lead_zeros = CLZ ( u4_bits ) - 15 ;if ( lead_zeros > 11 ) {return IMPEG2D_MB_DATA_DECODE_ERR ;}}IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) DecodedValue = gau2_impeg2d_tab_zero_1_9 [ u4_bits >> 8 ] ;u4_sym_len = BITS ( DecodedValue , 3 , 0 ) ;",746
2251,"security_decrypt ( s -> p , length , rdp ) ;if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ;","if ( ! security_decrypt ( s -> p , length , rdp ) ) return FALSE ;if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ;",747
2252,"if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( sock -> our_fd , FIONREAD , & size )  == 0 && size ) ) {int count = recv ( fd , buffer , L2CAP_MAX_SDU_LENGTH ,   MSG_NOSIGNAL | MSG_DONTWAIT ) ;APPL_TRACE_DEBUG ( ""btsock_l2cap_signaled<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>received<S2SV_blank>from<S2SV_blank>socket"" , count ) ;","if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( TEMP_FAILURE_RETRY ( ioctl ( sock -> our_fd , FIONREAD , & size ) ) == 0 && size ) ) {int count = TEMP_FAILURE_RETRY ( recv ( fd , buffer , L2CAP_MAX_SDU_LENGTH , MSG_NOSIGNAL | MSG_DONTWAIT ) ) ;APPL_TRACE_DEBUG ( ""btsock_l2cap_signaled<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>received<S2SV_blank>from<S2SV_blank>socket"" , count ) ;",748
2253,"if ( drop_it || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) {if ( drop_it || ioctl ( sock -> our_fd , FIONREAD , & size ) != 0 || size == 0 )  btsock_l2cap_free_l ( sock ) ;","if ( drop_it || TEMP_FAILURE_RETRY ( ( flags & SOCK_THREAD_FD_EXCEPTION ) ) {if ( drop_it || ioctl ( sock -> our_fd , FIONREAD , & size ) ) != 0 || size == 0 ) btsock_l2cap_free_l ( sock ) ;",748
2254,"
",struct mnt_namespace * ns ;,749
2255,"bool disconnect ;p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;list_del_init ( & p -> mnt_expire ) ;list_del_init ( & p -> mnt_list ) ;__touch_mnt_namespace ( p -> mnt_ns ) ;p -> mnt_ns = NULL ;","bool disconnect ;p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;ns = p -> mnt_ns ;if ( ns ) {ns -> mounts -- ;__touch_mnt_namespace ( ns ) ;}p -> mnt_ns ) ;p -> mnt_ns = NULL ;",749
2256,"static int renameColumnSelectCb ( Walker * pWalker , Select * p ) {renameWalkWith ( pWalker , p ) ;","static int renameColumnSelectCb ( Walker * pWalker , Select * p ) {if ( p -> selFlags & SF_View ) return WRC_Prune ;renameWalkWith ( pWalker , p ) ;",750
2257,"s -> packet_length = 0 ;goto err ;}# ifdef TLS_DEBUG printf ( ""dec<S2SV_blank>%d\\\{unsigned int z ;for ( z = 0 ;z < rr -> length ;z ++ ) printf ( ""%02X%c"" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? \'<S2SV_blank>\' : \'\\\}printf ( ""\\\# endif if ( ( sess != NULL ) && ( s -> enc_read_ctx != NULL ) && ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) ) {unsigned char * mac = NULL ;unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ;mac_size = EVP_MD_CTX_size ( s -> read_hash ) ;OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ;if ( rr -> orig_len < mac_size || ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && rr -> orig_len < mac_size + 1 ) ) {al = SSL_AD_DECODE_ERROR ;SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_LENGTH_TOO_SHORT ) ;goto f_err ;}if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) {mac = mac_tmp ;ssl3_cbc_copy_mac ( mac_tmp , rr , mac_size ) ;rr -> length -= mac_size ;}else {rr -> length -= mac_size ;mac = & rr -> data [ rr -> length ] ;}i = s -> method -> ssl3_enc -> mac ( s , md , 0 ) ;if ( i < 0 || mac == NULL || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) enc_err = - 1 ;if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) enc_err = - 1 ;}if ( enc_err < 0 ) {rr -> length = 0 ;s -> packet_length = 0 ;goto err ;}if ( s -> expand != NULL ) {if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH ) {al = SSL_AD_RECORD_OVERFLOW ;SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ;goto f_err ;}if ( ! ssl3_do_uncompress ( s ) ) {al = SSL_AD_DECOMPRESSION_FAILURE ;SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_BAD_DECOMPRESSION ) ;goto f_err ;}}if ( rr -> length > SSL3_RT_MAX_PLAIN_LENGTH ) {al = SSL_AD_RECORD_OVERFLOW ;SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ;goto f_err ;}rr -> off = 0 ;s -> packet_length = 0 ;dtls1_record_bitmap_update ( s , & ( s -> d1 -> bitmap ) ) ;return ( 1 ) ;",return ( 1 ) ;,751
2258,int iSrc ;res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;,int iSrc ;,752
2259,for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},res -> ContribRow [ u ] . Left = iLeft ;res -> ContribRow [ u ] . Right = iRight ;for ( iSrc = iLeft ;dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ;},752
2260,guint32 off = offset ;guint32 len ;,"guint32 off = offset , last_off ;guint32 len ;",753
2261,"DebugLog ( ( ""parse_wbxml_tag_defined<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\while ( off < tvb_len ) {","DebugLog ( ( ""parse_wbxml_tag_defined<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\\last_off = off ;while ( off < tvb_len ) {",753
2262,"
",if ( off < last_off ) {THROW ( ReportedBoundsError ) ;}last_off = off ;,753
2263,"}DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\","}DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\\",753
2264,# endif  if ( sk_acceptq_is_full ( sk ) )  goto exit_overflow ;,# endif struct ip_options_rcu * inet_opt ;if ( sk_acceptq_is_full ( sk ) ) goto exit_overflow ;,754
2265,newinet -> inet_saddr = ireq -> loc_addr ;newinet -> opt = ireq -> opt ;ireq -> opt = NULL ;if ( newinet -> opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = newinet -> opt -> optlen ;,"inet_opt = ireq -> opt ;rcu_assign_pointer ( newinet -> inet_opt , inet_opt ) ;ireq -> opt = NULL ;if ( inet_opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ;",754
2266,"result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ,  USB_DT_SECURITY , ( void * * ) & secd ) ;if ( result == - 1 ) {","result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , USB_DT_SECURITY , ( void * * ) & secd , sizeof ( * secd ) ) ;if ( result == - 1 ) {",755
2267,"static void set_rt_speed_feature ( VP9_COMMON * cm , SPEED_FEATURES * sf ,   int speed ) {sf -> static_segmentation = 0 ;sf -> adaptive_rd_thresh = 1 ;sf -> encode_breakout_thresh = 1 ;sf -> use_fast_coef_costing = 1 ;if ( speed == 1 ) {sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ;if ( MIN ( cm -> width , cm -> height ) >= 720 )  sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ;else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ;sf -> adaptive_motion_search = 1 ;sf -> auto_mv_step_size = 1 ;sf -> adaptive_rd_thresh = 2 ;sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ;sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;sf -> encode_breakout_thresh = 8 ;sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ;sf -> less_rectangular_check = 1 ;sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ;sf -> use_rd_breakout = 1 ;sf -> adaptive_motion_search = 1 ;sf -> auto_mv_step_size = 1 ;sf -> reference_masking = 1 ;sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ;sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ;sf -> adjust_partitioning_from_last_frame = 1 ;sf -> last_partitioning_redo_frequency = 3 ;sf -> adaptive_rd_thresh = 2 ;sf -> use_lp32x32fdct = 1 ;sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ;sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;sf -> encode_breakout_thresh = 200 ;sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ;sf -> constrain_copy_partition = 1 ;sf -> skip_encode_sb = 1 ;sf -> subpel_iters_per_step = 1 ;sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ;sf -> adaptive_rd_thresh = 4 ;sf -> lpf_pick = LPF_PICK_FROM_Q ;sf -> encode_breakout_thresh = 700 ;","static void set_rt_speed_feature ( VP9_COMP * cpi , SPEED_FEATURES * sf , int speed , vp9e_tune_content content ) {VP9_COMMON * const cm = & cpi -> common ;const int is_keyframe = cm -> frame_type == KEY_FRAME ;const int frames_since_key = is_keyframe ? 0 : cpi -> rc . frames_since_key ;sf -> use_fast_coef_costing = 1 ;if ( speed == 1 ) {sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ;sf -> mv . adaptive_motion_search = 1 ;sf -> auto_mv_step_size = 1 ;sf -> adaptive_rd_thresh = 2 ;sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ;sf -> less_rectangular_check = 1 ;sf -> auto_mv_step_size = 1 ;sf -> reference_masking = 1 ;sf -> reference_masking = ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC && cpi -> svc . number_spatial_layers == 1 ) ? 1 : 0 ;sf -> lf_motion_threshold = LOW_MOTION_THRESHOLD ;sf -> adjust_partitioning_from_last_frame = 1 ;sf -> use_lp32x32fdct = 1 ;sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ;sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ;sf -> mv . skip_encode_sb = 1 ;sf -> subpel_iters_per_step = 1 ;sf -> adaptive_rd_thresh = 4 ;sf -> lpf_pick = LPF_PICK_FROM_Q ;",756
2268,sf -> adjust_partitioning_from_last_frame = cm -> last_frame_type != cm -> frame_type || ( 0 ==  ( cm -> current_video_frame + 1 ) % sf -> last_partitioning_redo_frequency ) ;sf -> subpel_force_stop = 1 ;for ( i = 0 ;sf -> intra_y_mode_mask [ i ] = INTRA_DC_H_V ;sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ;}sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_ONLY ;sf -> frame_parameter_update = 0 ;sf -> encode_breakout_thresh = 1000 ;sf -> search_method = FAST_HEX ;sf -> disable_inter_mode_mask [ BLOCK_32X32 ] = 1 << INTER_OFFSET ( ZEROMV ) ;sf -> disable_inter_mode_mask [ BLOCK_32X64 ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ;sf -> disable_inter_mode_mask [ BLOCK_64X32 ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ;sf -> disable_inter_mode_mask [ BLOCK_64X64 ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ;sf -> max_intra_bsize = BLOCK_32X32 ;sf -> max_partition_size = BLOCK_32X32 ;sf -> min_partition_size = BLOCK_8X8 ;sf -> partition_check =  ( cm -> current_video_frame % sf -> last_partitioning_redo_frequency == 1 ) ;sf -> max_delta_qindex = ( cm -> frame_type == KEY_FRAME ) ? 20 : 15 ;sf -> partition_search_type = REFERENCE_PARTITION ;sf -> use_nonrd_pick_mode = 1 ;sf -> search_method = FAST_DIAMOND ;sf -> allow_skip_recode = 0 ;}sf -> partition_search_type = SOURCE_VAR_BASED_PARTITION ;sf -> search_type_check_frequency = 50 ;sf -> source_var_thresh = 360 ;sf -> use_nonrd_pick_mode = 1 ;sf -> search_method = FAST_DIAMOND ;}int i ;for ( i = 0 ;i < BLOCK_SIZES ;++ i ) sf -> disable_inter_mode_mask [ i ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ;,sf -> adjust_partitioning_from_last_frame = cm -> last_frame_type != cm -> frame_type || ( 0 == ( frames_since_key + 1 ) % sf -> last_partitioning_redo_frequency ) ;sf -> mv . subpel_force_stop = 1 ;for ( i = 0 ;sf -> intra_y_mode_mask [ i ] = INTRA_DC ;}sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_ONLY ;sf -> frame_parameter_update = 0 ;sf -> mv . search_method = FAST_HEX ;sf -> disable_inter_mode_mask [ BLOCK_32X32 ] = INTER_NEAREST_NEAR_NEW ;sf -> inter_mode_mask [ BLOCK_32X64 ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ;sf -> disable_inter_mode_mask [ BLOCK_64X32 ] = INTER_NEAREST ;sf -> inter_mode_mask [ BLOCK_64X64 ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ;sf -> max_intra_bsize = BLOCK_32X32 ;sf -> use_quant_fp = ! is_keyframe ;sf -> default_min_partition_size = BLOCK_8X8 ;sf -> partition_check = ( cm -> current_video_frame % sf -> last_partitioning_redo_frequency == 1 ) ;sf -> max_delta_qindex = is_keyframe ? 20 : 15 ;sf -> partition_search_type = REFERENCE_PARTITION ;sf -> allow_skip_recode = 0 ;sf -> inter_mode_mask [ BLOCK_32X32 ] = INTER_NEAREST_NEW_ZERO ;sf -> inter_mode_mask [ BLOCK_32X64 ] = INTER_NEAREST_NEW_ZERO ;sf -> inter_mode_mask [ BLOCK_64X32 ] = INTER_NEAREST_NEW_ZERO ;sf -> inter_mode_mask [ BLOCK_64X64 ] = INTER_NEAREST_NEW_ZERO ;sf -> adaptive_rd_thresh = 2 ;sf -> reuse_inter_pred_sby = 1 ;sf -> partition_search_breakout_rate_thr = 200 ;sf -> coeff_prob_appx_step = 4 ;sf -> use_fast_coef_updates = is_keyframe ? TWO_LOOP : ONE_LOOP_REDUCED ;sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH ;sf -> tx_size_search_method = is_keyframe ? USE_LARGESTALL : USE_TX_8X8 ;sf -> simple_model_rd_from_var = 1 ;if ( ! is_keyframe ) {int i ;if ( content == VP9E_CONTENT_SCREEN ) {for ( i = 0 ;i < BLOCK_SIZES ;++ i ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_TM_H_V ;}else {for ( i = 0 ;i < BLOCK_SIZES ;++ i ) if ( i >= BLOCK_16X16 ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC ;else sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_H_V ;}}}sf -> partition_search_type = VAR_BASED_PARTITION ;sf -> search_type_check_frequency = 50 ;sf -> mv . search_method = NSTEP ;sf -> mv . reduce_first_step_size = 1 ;sf -> skip_encode_sb = 0 ;}+ i ) sf -> disable_inter_mode_mask [ i ] = ~ ( 1 << INTER_OFFSET ( NEARESTMV ) ) ;sf -> adaptive_rd_thresh = 3 ;sf -> mv . search_method = FAST_DIAMOND ;sf -> mv . fullpel_search_step_param = 10 ;if ( cpi -> svc . number_temporal_layers > 2 && cpi -> svc . temporal_layer_id == 0 ) {sf -> mv . search_method = NSTEP ;sf -> mv . fullpel_search_step_param = 6 ;}}if ( speed >= 8 ) {sf -> adaptive_rd_thresh = 4 ;sf -> mv . subpel_force_stop = 2 ;sf -> lpf_pick = LPF_PICK_MINIMAL_LPF ;,756
2269,"zend_throw_error ( exception_ce , message ) ;}","zend_throw_error ( exception_ce , ""%s"" , message ) ;}",757
2270,box -> len = len ;if ( box -> len == 1 ) {,"box -> len = len ;JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\\if ( box -> len == 1 ) {box -> ops = & jp2_boxinfo_unk . ops ;",758
2271,"jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;","jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;",758
2272,msg -> msg_namelen = 0 ;copied = skb -> len ;,copied = skb -> len ;,759
2273,"}if ( options . compression ) {ssh_packet_set_compress_hooks ( ssh , pmonitor -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ;","
",760
2274,# endif  newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;,# endif newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;,761
2275,newinet -> inet_opt = NULL ;newnp -> ipv6_ac_list = NULL ;,newinet -> inet_opt = NULL ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;,761
2276,for ( i = scm -> fp -> count - 1 ;i -- )  unix_notinflight ( scm -> fp -> fp [ i ] ) ;},"for ( i = scm -> fp -> user , scm -> fp -> count - 1 ;i -- ) unix_notinflight ( scm -> fp -> fp [ i ] ) ;}",762
2277,"void vp8_denoiser_denoise_mb ( VP8_DENOISER * denoiser , MACROBLOCK * x , unsigned int best_sse , unsigned int zero_mv_sse , int recon_yoffset ,  int recon_uvoffset )  {unsigned int motion_magnitude2 ;MV_REFERENCE_FRAME frame = x -> best_reference_frame ;if ( zero_frame )  {int sse_diff = zero_mv_sse - best_sse ;saved_mbmi = * mbmi ;if ( frame == INTRA_FRAME ||   ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col )  <= NOISE_MOTION_THRESHOLD && sse_diff < ( int ) SSE_DIFF_THRESHOLD ) ) {","void vp8_denoiser_denoise_mb ( VP8_DENOISER * denoiser , MACROBLOCK * x , unsigned int best_sse , unsigned int zero_mv_sse , int recon_yoffset , int recon_uvoffset , loop_filter_info_n * lfi_n , int mb_row , int mb_col , int block_index ) {unsigned int motion_threshold ;unsigned int motion_magnitude2 ;unsigned int sse_thresh ;int sse_diff_thresh = 0 ;int apply_spatial_loop_filter = 1 ;MV_REFERENCE_FRAME frame = x -> best_reference_frame ;enum vp8_denoiser_decision decision_u = COPY_BLOCK ;enum vp8_denoiser_decision decision_v = COPY_BLOCK ;if ( zero_frame ) {int sse_diff = 0 ;const int zero_bias = denoiser -> denoise_pars . denoise_mv_bias ;zero_mv_sse = ( unsigned int ) ( ( int64_t ) zero_mv_sse * zero_bias / 100 ) ;sse_diff = zero_mv_sse - best_sse ;saved_mbmi = * mbmi ;if ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) <= NOISE_MOTION_THRESHOLD ) sse_diff_thresh = ( int ) SSE_DIFF_THRESHOLD ;if ( frame == INTRA_FRAME || sse_diff <= sse_diff_thresh ) {x -> denoise_zeromv = 1 ;",763
2278,"if ( best_sse > SSE_THRESHOLD || motion_magnitude2   > 8 * NOISE_MOTION_THRESHOLD )  {}if ( decision == FILTER_BLOCK ) {decision = vp8_denoiser_filter ( & denoiser -> yv12_mc_running_avg ,  & denoiser -> yv12_running_avg [ INTRA_FRAME ] , x , motion_magnitude2 , recon_yoffset , recon_uvoffset ) ;vp8_copy_mem16x16 (  x -> thismb , 16 , denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ) ;}}","motion_threshold = denoiser -> denoise_pars . scale_motion_thresh * NOISE_MOTION_THRESHOLD ;if ( x -> is_skin ) motion_threshold = 1 ;if ( motion_magnitude2 < denoiser -> denoise_pars . scale_increase_filter * NOISE_MOTION_THRESHOLD ) x -> increase_denoising = 1 ;sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD ;if ( x -> increase_denoising ) sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD_HIGH ;if ( ! x -> skip ) {vp8_build_inter_predictors_mb ( filter_xd ) ;}else {vp8_build_inter16x16_predictors_mb ( filter_xd , filter_xd -> dst . y_buffer , filter_xd -> dst . u_buffer , filter_xd -> dst . v_buffer , filter_xd -> dst . y_stride , filter_xd -> dst . uv_stride ) ;}filter_xd -> pre = saved_pre ;filter_xd -> dst = saved_dst ;* mbmi = saved_mbmi ;}mv_row = x -> best_sse_mv . as_mv . row ;mv_col = x -> best_sse_mv . as_mv . col ;motion_magnitude2 = mv_row * mv_row + mv_col * mv_col ;if ( best_sse > sse_thresh || motion_magnitude2 > 8 * NOISE_MOTION_THRESHOLD ) {if ( decision == FILTER_BLOCK ) {unsigned char * mc_running_avg_y = denoiser -> yv12_mc_running_avg . y_buffer + recon_yoffset ;int mc_avg_y_stride = denoiser -> yv12_mc_running_avg . y_stride ;unsigned char * running_avg_y = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset ;int avg_y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ;decision = vp8_denoiser_filter ( mc_running_avg_y , mc_avg_y_stride , running_avg_y , avg_y_stride , x -> thismb , 16 , motion_magnitude2 , x -> increase_denoising ) ;denoiser -> denoise_state [ block_index ] = motion_magnitude2 > 0 ? kFilterNonZeroMV : kFilterZeroMV ;if ( denoiser -> denoiser_mode != kDenoiserOnYOnly && motion_magnitude2 == 0 && decision == FILTER_BLOCK ) {unsigned char * mc_running_avg_u = denoiser -> yv12_mc_running_avg . u_buffer + recon_uvoffset ;unsigned char * running_avg_u = denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset ;unsigned char * mc_running_avg_v = denoiser -> yv12_mc_running_avg . v_buffer + recon_uvoffset ;unsigned char * running_avg_v = denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset ;int mc_avg_uv_stride = denoiser -> yv12_mc_running_avg . uv_stride ;int avg_uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ;int signal_stride = x -> block [ 16 ] . src_stride ;decision_u = vp8_denoiser_filter_uv ( mc_running_avg_u , mc_avg_uv_stride , running_avg_u , avg_uv_stride , x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , signal_stride , motion_magnitude2 , 0 ) ;decision_v = vp8_denoiser_filter_uv ( mc_running_avg_v , mc_avg_uv_stride , running_avg_v , avg_uv_stride , x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , signal_stride , motion_magnitude2 , 0 ) ;}x -> denoise_zeromv = 0 ;vp8_copy_mem16x16 ( x -> thismb , 16 , denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ) ;denoiser -> denoise_state [ block_index ] = kNoFilter ;}if ( denoiser -> denoiser_mode != kDenoiserOnYOnly ) {if ( decision_u == COPY_BLOCK ) {vp8_copy_mem8x8 ( x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , x -> block [ 16 ] . src_stride , denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ;}if ( decision_v == COPY_BLOCK ) {vp8_copy_mem8x8 ( x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , x -> block [ 16 ] . src_stride , denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ;}}if ( apply_spatial_loop_filter ) {loop_filter_info lfi ;int apply_filter_col = 0 ;int apply_filter_row = 0 ;int apply_filter = 0 ;int y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ;int uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ;int filter_level = 48 ;int hev_index = lfi_n -> hev_thr_lut [ INTER_FRAME ] [ filter_level ] ;lfi . mblim = lfi_n -> mblim [ filter_level ] ;lfi . blim = lfi_n -> blim [ filter_level ] ;lfi . lim = lfi_n -> lim [ filter_level ] ;lfi . hev_thr = lfi_n -> hev_thr [ hev_index ] ;if ( mb_col > 0 ) {apply_filter_col = ! ( ( denoiser -> denoise_state [ block_index ] == denoiser -> denoise_state [ block_index - 1 ] ) && denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ;if ( apply_filter_col ) {apply_filter = 1 ;vp8_loop_filter_mbv ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , NULL , NULL , y_stride , uv_stride , & lfi ) ;}}if ( mb_row > 0 ) {apply_filter_row = ! ( ( denoiser -> denoise_state [ block_index ] == denoiser -> denoise_state [ block_index - denoiser -> num_mb_cols ] ) && denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ;if ( apply_filter_row ) {apply_filter = 1 ;vp8_loop_filter_mbh ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , NULL , NULL , y_stride , uv_stride , & lfi ) ;}}if ( apply_filter ) {vp8_copy_mem16x16 ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , y_stride , x -> thismb , 16 ) ;}}}",763
2279,"return mutt_bcache_del ( bcache , id ) ;}","return mutt_bcache_del ( bcache , cache_id ( id ) ) ;}",764
2280,if ( ! unconditional ( & e -> ip ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,765
2281,"
",lsa -> l2tp_conn_id = 0 ;,766
2282,if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL )  lsa -> l2tp_scope_id = IP6CB ( skb ) -> iif ;,if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) lsa -> l2tp_scope_id = IP6CB ( skb ) -> iif ;,766
2283,kvm_async_pf_hash_reset ( vcpu ) ;kvm_pmu_init ( vcpu ) ;,vcpu -> arch . pv_time_enabled = false ;kvm_async_pf_hash_reset ( vcpu ) ;kvm_pmu_init ( vcpu ) ;,767
2284,tcon -> bad_network_name = true ;},if ( tcon ) tcon -> bad_network_name = true ;},768
2285,"__skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ;sock_put ( sk ) ;","__skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND , false ) ;sock_put ( sk ) ;",769
2286,if ( pxEnd == NULL ) {if ( xWantedSize > 0 )  {xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ;mtCOVERAGE_TEST_MARKER ( ) ;},if ( ( pxEnd == NULL ) {if ( xWantedSize > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) {if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) {xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ;configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ;xWantedSize = 0 ;}}else {xWantedSize = 0 ;},770
2287,"if ( realms == NULL || realms [ 0 ] == \'\\\\0\' ||  data_eq_string ( srealm , realms [ 0 ] ) ) {","if ( realms == NULL || realms [ 0 ] == NULL || * realms [ 0 ] == \'\\\\0\' || data_eq_string ( srealm , realms [ 0 ] ) ) {",771
2288,"static int read_mv_component ( vp9_reader * r ,  const nmv_component * mvcomp , int usehp ) {const int sign = vp9_read ( r , mvcomp -> sign ) ;const int mv_class = vp9_read_tree ( r , vp9_mv_class_tree , mvcomp -> classes ) ;const int class0 = mv_class == MV_CLASS_0 ;d = vp9_read_tree ( r , vp9_mv_class0_tree , mvcomp -> class0 ) ;}++ i )  d |= vp9_read ( r , mvcomp -> bits [ i ] ) << i ;}fr = vp9_read_tree ( r , vp9_mv_fp_tree , class0 ? mvcomp -> class0_fp [ d ]  : mvcomp -> fp ) ;hp = usehp ? vp9_read ( r , class0 ? mvcomp -> class0_hp : mvcomp -> hp )  : 1 ;mag = vp9_get_mv_mag ( mv_class , ( d << 3 ) | ( fr << 1 ) | hp ) + 1 ;return sign ? - mag : mag ;","static int read_mv_component ( vpx_reader * r , const nmv_component * mvcomp , int usehp ) {const int sign = vpx_read ( r , mvcomp -> sign ) ;const int mv_class = vpx_read_tree ( r , vp9_mv_class_tree , mvcomp -> classes ) ;const int class0 = mv_class == MV_CLASS_0 ;d = vpx_read_tree ( r , vp9_mv_class0_tree , mvcomp -> class0 ) ;mag = 0 ;}+ i )  d |= vp9_read ( r , mvcomp -> bits [ i ] ) << i ;++ i ) d |= vpx_read ( r , mvcomp -> bits [ i ] ) << i ;mag = CLASS0_SIZE << ( mv_class + 2 ) ;}fr = vpx_read_tree ( r , vp9_mv_fp_tree , class0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp ) ;hp = usehp ? vpx_read ( r , class0 ? mvcomp -> class0_hp : mvcomp -> hp ) : 1 ;mag += ( ( d << 3 ) | ( fr << 1 ) | hp ) + 1 ;return sign ? - mag : mag ;",772
2289,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |  NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ;if ( ses -> server -> sign ) {flags |= NTLMSSP_NEGOTIATE_SIGN ;}sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ;,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL ;if ( ses -> server -> sign ) flags |= NTLMSSP_NEGOTIATE_SIGN ;sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ;,773
2290,if ( info . si_code >= 0 )   return - EPERM ;info . si_signo = sig ;,if ( info . si_code != SI_QUEUE ) {WARN_ON_ONCE ( info . si_code < 0 ) ;return - EPERM ;}info . si_signo = sig ;,774
2291,lxc_attach_options_t * options = payload -> options ;struct lxc_proc_context_info * init_ctx = payload -> init_ctx ;,int procfd = payload -> procfd ;lxc_attach_options_t * options = payload -> options ;struct lxc_proc_context_info * init_ctx = payload -> init_ctx ;,775
2292,"if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) ) {int on_exec ;int proc_mounted ;on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;proc_mounted = mount_proc_if_needed ( ""/"" ) ;if ( proc_mounted == - 1 ) {ERROR ( ""Error<S2SV_blank>mounting<S2SV_blank>a<S2SV_blank>sane<S2SV_blank>/proc"" ) ;rexit ( - 1 ) ;}ret = lsm_process_label_set ( init_ctx -> lsm_label ,  init_ctx -> container -> lxc_conf , 0 , on_exec ) ;","if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) {int on_exec ;on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ;if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label , init_ctx -> container -> lxc_conf , 0 , on_exec ) ;",775
2293,rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;},close ( procfd ) ;rexit ( payload -> exec_function ( payload -> exec_payload ) ) ;},775
2294,static void evtchn_2l_handle_events ( unsigned cpu )  {,"static void evtchn_2l_handle_events ( unsigned cpu , struct evtchn_loop_ctrl * ctrl ) {",776
2295,irq = get_evtchn_to_irq ( port ) ;if ( irq != - 1 ) generic_handle_irq ( irq ) ;,"handle_irq_for_port ( port , ctrl ) ;",776
2296,state -> space = NULL ;state -> space_len = 0 ;}}else {if ( state -> space ) ruby_xfree ( state -> space ) ;state -> space = strdup ( RSTRING_PTR ( space ) ) ;state -> space_len = len ;,"state -> space = fstrndup ( RSTRING_PTR ( space ) , len ) ;state -> space_len = len ;",777
2297,"memcpy ( name , fp + n , name_len ) ;name [ name_len ] = \'\\\\0\' ;attr_len = fp [ n ++ ] ;memcpy ( attr , fp + n , attr_len ) ;","IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ;) ;memcpy ( name , fp + n , name_len ) ;name [ name_len ] = \'\\\\0\' ;attr_len = fp [ n ++ ] ;IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ;) ;memcpy ( attr , fp + n , attr_len ) ;",778
2298,assert ( n >= 0 && n < 32 ) ;assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ;,if ( n < 0 || n >= 32 ) {return EOF ;}assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ;,779
2299,"const VP9_CONFIG * const oxcf = & cpi -> oxcf ;int active_best_quality ;int active_worst_quality = cpi -> twopass . active_worst_quality ;if ( frame_is_intra_only ( cm ) ) {# if ! CONFIG_MULTIPLE_ARF  if ( rc -> this_key_frame_forced ) {int qindex = rc -> last_boosted_qindex ;double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q ,  last_boosted_q * 0.75 ) ;active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;}double q_adj_factor = 1.0 ;double q_val ;active_best_quality = get_active_quality ( active_worst_quality ,  rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val ,  q_val * q_adj_factor ) ;}# else double current_q ;current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ;active_best_quality = active_worst_quality + vp9_compute_qdelta ( rc , current_q , current_q * 0.3 ) ;# endif }","const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;const GF_GROUP * gf_group = & cpi -> twopass . gf_group ;const int cq_level = get_active_cq_level ( rc , oxcf ) ;int active_best_quality ;int active_worst_quality = cpi -> twopass . active_worst_quality ;int * inter_minq ;ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ;if ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) {if ( rc -> this_key_frame_forced ) {double last_boosted_q ;int delta_qindex ;int qindex ;if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) {qindex = MIN ( rc -> last_kf_qindex , rc -> last_boosted_qindex ) ;active_best_quality = qindex ;last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 1.25 , cm -> bit_depth ) ;active_worst_quality = MIN ( qindex + delta_qindex , active_worst_quality ) ;}qindex = rc -> last_boosted_qindex ;last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ;active_best_quality = get_kf_active_quality ( rc , active_worst_quality , cm -> bit_depth ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor , cm -> bit_depth ) ;}}",780
2300,"if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) {if ( q < cpi -> cq_target_quality )  q = cpi -> cq_target_quality ;if ( rc -> frames_since_key > 1 ) {active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ;}else {active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ;}}if ( ! cpi -> refresh_alt_ref_frame ) {active_best_quality = cpi -> cq_target_quality ;}","if ( oxcf -> rc_mode == VPX_CQ ) {if ( q < cq_level ) q = cq_level ;active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ;}if ( ! cpi -> refresh_alt_ref_frame ) {active_best_quality = cpi -> cq_target_quality ;}",780
2301,if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) {active_best_quality = cpi -> cq_target_quality ;}else {active_best_quality = inter_minq [ active_worst_quality ] ;if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) &&   ( active_best_quality < cpi -> cq_target_quality ) ) {if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ;,if ( oxcf -> rc_mode == VPX_Q ) {if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ;,780
2302,"# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY  if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) {* top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ;}else if ( ! rc -> is_src_frame_alt_ref && ( oxcf -> end_usage != USAGE_STREAM_FROM_SERVER ) && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) {* top_index = ( active_worst_quality + active_best_quality ) / 2 ;# endif if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) {q = active_best_quality ;q = rc -> last_boosted_qindex ;}if ( q > * top_index ) {if ( rc -> this_frame_target >= rc -> max_frame_bandwidth )  * top_index = q ;else q = * top_index ;}}# if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled && ( cm -> frame_type != KEY_FRAME ) && cpi -> oxcf . end_usage != USAGE_CONSTANT_QUALITY ) {double new_q ;double current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ;int level = cpi -> this_frame_weight ;assert ( level >= 0 ) ;new_q = current_q * ( 1.0 - ( 0.2 * ( cpi -> max_arf_level - level ) ) ) ;q = active_worst_quality + vp9_compute_qdelta ( rc , current_q , new_q ) ;* bottom_index = q ;* top_index = q ;","# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) {* top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ;else if ( ! rc -> is_src_frame_alt_ref && ( oxcf -> rc_mode == VPX_Q ) {active_best_quality = cq_level ;q = rc -> last_boosted_qindex ;}if ( q > active_worst_quality ) {if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) active_worst_quality = q ;else q = active_worst_quality ;}}clamp ( q , active_best_quality , active_worst_quality ) ;* top_index = active_worst_quality ;* bottom_index = q ;* top_index = q ;",780
2303,"static void rate_block ( int plane , int block , BLOCK_SIZE plane_bsize ,  TX_SIZE tx_size , struct rdcost_block_args * args ) {args -> rate = cost_coeffs ( args -> x , plane , block , args -> t_above + x_idx ,  args -> t_left + y_idx , tx_size , args -> so -> scan , args -> so -> neighbors , args -> use_fast_coef_costing ) ;","static int rate_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , struct rdcost_block_args * args ) {return cost_coeffs ( args -> x , plane , block , args -> t_above + x_idx , args -> t_left + y_idx , tx_size , args -> so -> scan , args -> so -> neighbors , args -> use_fast_coef_costing ) ;",781
2304,int is_udplite = IS_UDPLITE ( sk ) ;bool slow ;,bool checksum_valid = false ;int is_udplite = IS_UDPLITE ( sk ) ;bool slow ;,782
2305,"if ( udp_lib_checksum_complete ( skb ) )  goto csum_copy_err ;if ( skb_csum_unnecessary ( skb ) )  err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;","checksum_valid = ! udp_lib_checksum_complete ( skb ) ;if ( ! checksum_valid ) goto csum_copy_err ;if ( checksum_valid || skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;",782
2306,"static void udf_pc_to_char ( struct super_block * sb , unsigned char * from ,   int fromlen , unsigned char * to )  {unsigned char * p = to ;while ( elen < fromlen ) {case 2 :  p = to ;* p ++ = \'/\' ;break ;case 3 : memcpy ( p , ""../"" , 3 ) ;break ;case 4 :  memcpy ( p , ""./"" , 2 ) ;p += 2 ;break ;case 5 :  p += udf_get_filename ( sb , pc -> componentIdent , p ,  pc -> lengthComponentIdent ) ;* p ++ = \'/\' ;break ;}","static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) {int comp_len ;unsigned char * p = to ;tolen -- ;while ( elen < fromlen ) {case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ;p = to ;* p ++ = \'/\' ;tolen -- ;break ;case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ;memcpy ( p , ""../"" , 3 ) ;tolen -= 3 ;break ;case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ;memcpy ( p , ""./"" , 2 ) ;p += 2 ;tolen -= 2 ;break ;case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ;p += comp_len ;tolen -= comp_len ;if ( tolen == 0 ) return - ENAMETOOLONG ;* p ++ = \'/\' ;tolen -- ;break ;return 0 ;}",783
2307,"memset ( sax , 0 , sizeof ( sax ) ) ;sax -> sax25_family = AF_NETROM ;","memset ( sax , 0 , sizeof ( * sax ) ) ;sax -> sax25_family = AF_NETROM ;",784
2308,"if ( is_authenticated ( req , res ) ) {if ( IS ( req -> method , METHOD_GET ) ) Impl . doGet ( req , res ) ;","if ( is_authenticated ( req , res ) ) {set_header ( res , ""Set-Cookie"" , ""securitytoken=%s;<S2SV_blank>Max-Age=600;<S2SV_blank>HttpOnly;<S2SV_blank>SameSite=strict%s"" , res -> token , Run . httpd . flags & Httpd_Ssl ? "";<S2SV_blank>Secure"" : """" ) ;if ( IS ( req -> method , METHOD_GET ) ) Impl . doGet ( req , res ) ;",785
2309,"xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ;obj_id = 0 ;",xref -> entries = safe_calloc ( xref -> n_entries * sizeof ( struct _xref_entry ) ) ;obj_id = 0 ;,786
2310,"memory_length += extra_length - available_length + BLOCK_QUEUE ;cp = new_memory ( memory_length , sizeof ( char ) ) ;if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , cp ) ;if ( qp -> d_read > qp -> d_write ) {size_t tail_len = qp -> d_memory_end - qp -> d_read ;memcpy ( cp , qp -> d_read , tail_len ) ;memcpy ( cp + tail_len , qp -> d_memory , ( size_t ) ( qp -> d_write - qp -> d_memory ) ) ;memcpy ( cp , qp -> d_memory , memory_length ) ;qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ;","size_t original_length = memory_length ;memory_length += extra_length - available_length + BLOCK_QUEUE ;cp = new_memory ( memory_length , sizeof ( char ) ) ;if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , original_length ) ;memcpy ( cp , qp -> d_memory , memory_length ) ;qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ;",787
2311,"if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) {","if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ! use_privsep || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) {",788
2312,if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0  || no_port_forwarding_flag || options . disable_forwarding ) {success = 0 ;,if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding ) {success = 0 ;,788
2313,"baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ;baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ;","if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ;baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ;",789
2314,kret = 0 ;if ( kdc_numrealms > 1 ) {,kret = 0 ;if ( sprinc == NULL ) return NULL ;if ( kdc_numrealms > 1 ) {,790
2315,"if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ;if ( NULL == siocb -> scm ) siocb -> scm = & scm ;err = scm_send ( sock , msg , siocb -> scm , true ) ;if ( err < 0 ) return err ;if ( msg -> msg_namelen ) {err = - EINVAL ;if ( addr -> nl_family != AF_NETLINK ) goto out ;dst_pid = addr -> nl_pid ;dst_group = ffs ( addr -> nl_groups ) ;err = - EPERM ;if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) )  goto out ;","if ( ( dst_group || dst_pid ) && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) goto out ;",791
2316,"MB_PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi ,  const MODE_INFO * above_mi , int b ) {","PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO * above_mi , int b ) {",792
2317,"
","size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;",793
2318,params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,793
2319,"}IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) if ( u4_numCoeffs > 64 ) {}}","if ( u4_numCoeffs > 64 ) {}}IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) }",794
2320,}if ( u4_numCoeffs > 64 ) {return IMPEG2D_MB_TEX_DECODE_ERR ;},if ( u4_numCoeffs > 64 ) {return IMPEG2D_MB_TEX_DECODE_ERR ;}},794
2321,"enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;armor_key = cb -> fast_armor ( context , rock ) ;","armor_key = cb -> fast_armor ( context , rock ) ;",795
2322,"rs -> respond = respond ;retval = cb -> get_string ( context , rock , ""otp"" , & config ) ;","rs -> respond = respond ;rs -> enc_tkt_reply = enc_tkt_reply ;retval = cb -> get_string ( context , rock , ""otp"" , & config ) ;",795
2323,image -> colorspace = RGBColorspace ;if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( samples_per_pixel == 1 ) ) {,"status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;break ;}image -> colorspace = RGBColorspace ;if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( samples_per_pixel == 1 ) ) {",796
2324,"const int w = vpx_img_plane_width ( img , plane ) ;const int h = vpx_img_plane_height ( img , plane ) ;","const int w = vpx_img_plane_width ( img , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ;const int h = vpx_img_plane_height ( img , plane ) ;",797
2325,inline void update_rq_clock ( struct rq * rq )  {if ( ! rq -> skip_clock_update ) {u64 irq_time ;rq -> clock = sched_clock_cpu ( cpu ) ;},inline void update_rq_clock ( struct rq * rq ) {u64 irq_time ;if ( rq -> skip_clock_update ) return ;rq -> clock = sched_clock_cpu ( cpu ) ;,798
2326,"void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {","static void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {",799
2327,"skb = sock_alloc_send_skb ( sk ,  hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;","struct frag_hdr fhdr ;skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;",800
2328,"skb -> csum = 0 ;}err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;if ( ! err ) {struct frag_hdr fhdr ;return 0 ;}kfree_skb ( skb ) ;return err ;","skb -> csum = 0 ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",800
2329,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ;",801
2330,"Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ;","if ( length > INT_MAX ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ;RETURN_FALSE ;}Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ;",802
2331,inode_init_once ( & ei -> vfs_inode ) ;},init_rwsem ( & ei -> i_mmap_sem ) ;inode_init_once ( & ei -> vfs_inode ) ;},803
2332,"return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ;}","return __load_segment_descriptor ( ctxt , selector , seg , cpl , false , NULL ) ;}",804
2333,"char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ;int dlen = mutt_b64_decode ( out , it ) ;if ( dlen == - 1 ) {","const int olen = 3 * len / 4 + 1 ;char * out = mutt_mem_malloc ( olen ) ;int dlen = mutt_b64_decode ( out , it , olen ) ;if ( dlen == - 1 ) {",805
2334,"static void open_output_file ( struct stream_state * stream ,  struct VpxEncoderConfig * global ) {const char * fn = stream -> config . out_fn ;","static void open_output_file ( struct stream_state * stream , struct VpxEncoderConfig * global , const struct VpxRational * pixel_aspect_ratio ) {const char * fn = stream -> config . out_fn ;",806
2335,"write_webm_file_header ( & stream -> ebml , cfg , & global -> framerate , stream -> config . stereo_fmt ,  global -> codec -> fourcc ) ;}","write_webm_file_header ( & stream -> ebml , cfg , & global -> framerate , stream -> config . stereo_fmt , global -> codec -> fourcc , pixel_aspect_ratio ) ;}",806
2336,"free_ep_req ( midi -> out_ep , req ) ;return err ;","if ( req -> buf != NULL ) free_ep_req ( midi -> out_ep , req ) ;return err ;",807
2337,if ( ctx -> might_cancel ) {ctx -> might_cancel = false ;spin_lock ( & cancel_lock ) ;list_del_rcu ( & ctx -> clist ) ;spin_unlock ( & cancel_lock ) ;}},spin_lock ( & ctx -> cancel_lock ) ;list_del_rcu ( & ctx -> clist ) ;spin_unlock ( & cancel_lock ) ;}},808
2338,"vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ;}","vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ;}else {# ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ;# endif }",809
2339,"static void prob_diff_update ( const vp9_tree_index * tree ,   vp9_prob probs [ ] ,  const unsigned int counts [ ] ,  int n , vp9_writer * w ) {int i ;","static void prob_diff_update ( const vpx_tree_index * tree , vp9_prob probs [ ] , const unsigned int counts [ ] , int n , vpx_writer * w ) {int i ;",810
2340,if ( -- timer -> running )  list_del ( & ti -> active_list ) ;},if ( -- timer -> running ) list_del_init ( & ti -> active_list ) ;},811
2341,char * message = NULL ;char * language = NULL ;size_t message_len = 0 ;,unsigned char * message = NULL ;unsigned char * language = NULL ;size_t message_len = 0 ;,812
2342,size_t reason = _libssh2_ntohu32 ( data + 1 ) ;if ( datalen >= 9 ) {message_len = _libssh2_ntohu32 ( data + 5 ) ;if ( message_len < datalen - 13 ) {message = ( char * ) data + 9 ;language_len = _libssh2_ntohu32 ( data + 9 + message_len ) ;language = ( char * ) data + 9 + message_len + 4 ;if ( language_len > ( datalen - 13 - message_len ) ) {,uint32_t reason = 0 ;struct string_buf buf ;buf . data = ( unsigned char * ) data + 9 ;language_len = _libssh2_ntohu32 ( data + 9 + message_len ) ;language = ( char * ) data + 9 + message_len + 4 ;if ( language_len > ( datalen - 13 - message_len ) ) {,812
2343,"LIBSSH2_IGNORE ( session , ( char * ) data + 1 , datalen - 1 ) ;}}else if ( session -> ssh_msg_ignore ) {LIBSSH2_IGNORE ( session , """" , 0 ) ;}LIBSSH2_FREE ( session , data ) ;session -> packAdd_state = libssh2_NB_state_idle ;return 0 ;case SSH_MSG_DEBUG : if ( datalen >= 2 ) {int always_display = data [ 1 ] ;if ( datalen >= 6 ) {message_len = _libssh2_ntohu32 ( data + 2 ) ;if ( message_len <= ( datalen - 10 ) ) {message = ( char * ) data + 6 ;language_len = _libssh2_ntohu32 ( data + 6 + message_len ) ;if ( language_len <= ( datalen - 10 - message_len ) )  language = ( char * ) data + 10 + message_len ;}}if ( session -> ssh_msg_debug ) {LIBSSH2_DEBUG ( session , always_display , message , message_len , language , language_len ) ;","LIBSSH2_IGNORE ( session , ( char * ) data ;buf . dataptr = buf . data ;buf . len = datalen ;buf . dataptr ++ ;_libssh2_get_u32 ( & buf , & reason ) ;_libssh2_get_string ( & buf , & message , & message_len ) ;_libssh2_get_string ( & buf , & language , & language_len ) ;if ( session -> ssh_msg_disconnect ) {LIBSSH2_DISCONNECT ( session , reason , ( const char * ) data + 6 ;language_len = _libssh2_ntohu32 ( data + 6 + message_len ) ;if ( language_len <= ( datalen - 10 - message_len ) ) language = ( char * ) message , message_len , ( const char * ) language , language_len ) ;",812
2344,if ( datalen >= ( 6 + len ) ) {want_reply = data [ 5 + len ] ;,if ( ( len <= ( UINT_MAX - 6 ) ) && ( datalen >= ( 6 + len ) ) ) {want_reply = data [ 5 + len ] ;,812
2345,SvcInternal * const si = ( SvcInternal * ) svc_ctx -> internal ;si -> message_buffer [ 0 ] = '\\\\0' ;,SvcInternal_t * const si = ( SvcInternal * ) svc_ctx -> internal ;si -> message_buffer [ 0 ] = '\\\\0' ;,813
2346,"bestsad = fn_ptr -> sdf ( what , what_stride , best_address ,  in_what_stride , UINT_MAX )  + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , best_address , in_what_stride ) + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ;",814
2347,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ;if ( thissad < bestsad ) {",814
2348,"static struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root ,  struct btrfs_path * path , const char * name , int name_len ) {","struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , struct btrfs_path * path , const char * name , int name_len ) {",815
2349,return ms ;free : free ( ms ) ;,ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;return ms ;free : free ( ms ) ;,816
2350,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;buf [ 0 ] = CP2112_GPIO_SET ;spin_unlock_irqrestore ( & dev -> lock , flags ) ;}","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;buf [ 0 ] = CP2112_GPIO_SET ;mutex_unlock ( & dev -> lock , flags ) ;}",817
2351,"
",ND_TCHECK ( rhp -> rh_short . sh_flags ) ;,818
2352,mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ;},mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ;},818
2353,"png_structp p = ( png_structp ) png_ptr ;png_uint_32 save_flags = p -> flags ;png_uint_32 num_bytes ;p -> flags |= PNG_FLAG_MALLOC_NULL_MEM_OK ;ptr = ( png_voidp ) png_malloc ( ( png_structp ) png_ptr , num_bytes ) ;p -> flags = save_flags ;# if defined ( PNG_1_0_X ) && ! defined ( PNG_NO_ZALLOC_ZERO ) if ( ptr == NULL ) return ( ( voidpf ) ptr ) ;",png_structp p ;png_uint_32 save_flags ;png_uint_32 num_bytes ;if ( png_ptr == NULL ) return ( NULL ) ;p = ( png_structp ) png_ptr ;save_flags = p -> flags ;png_uint_32 num_bytes ;p -> flags ;,819
2354,pkt . kind = VPX_CODEC_STATS_PKT ;pkt . data . twopass_stats . buf = stats ;,( void ) cpi ;pkt . kind = VPX_CODEC_STATS_PKT ;pkt . data . twopass_stats . buf = stats ;,820
2355,"if ( buf )   grub_memcpy ( buf , data + pos + real_offset , len ) ;grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ;","if ( buf ) {if ( pos + real_offset + len >= size ) {grub_errno = GRUB_ERR_BAD_FS ;return grub_errno ;}grub_memcpy ( buf , data + pos + real_offset , len ) ;}grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ;",821
2356,}msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ;x25_check_rbuf ( sk ) ;,msg -> msg_namelen = sizeof ( struct sockaddr_x25 ) ;x25_check_rbuf ( sk ) ;,822
2357,get_page ( page ) ;spin_unlock ( ptl ) ;,if ( unlikely ( ! try_get_page ( page ) ) ) {spin_unlock ( ptl ) ;return ERR_PTR ( - ENOMEM ) ;}spin_unlock ( ptl ) ;,823
2358,"if ( WARN ( irq >= nr_irqs , ""Invalid<S2SV_blank>irq<S2SV_blank>%d!\\\return info_for_irq ( irq ) -> evtchn ;}",const struct irq_info * info = NULL ;if ( likely ( irq < nr_irqs ) ) info = info_for_irq ( irq ) ;if ( ! info ) return 0 ;return info -> evtchn ;},824
2359,bufp += bytes_read ;},bufp += stripsize ;},825
2360,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",826
2361,args -> rmtblkcnt2 = args -> rmtblkcnt ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;},args -> rmtvaluelen2 = args -> rmtvaluelen ;args -> rmtblkcnt2 = args -> rmtblkcnt = 0 ;args -> rmtvaluelen ;args -> rmtblkno = 0 ;args -> rmtblkcnt = 0 ;},827
2362,args -> rmtblkcnt = args -> rmtblkcnt2 ;if ( args -> rmtblkno ) {,args -> rmtblkcnt = args -> rmtblkcnt2 ;args -> rmtvaluelen = args -> rmtvaluelen2 ;if ( args -> rmtblkno ) {,827
2363,union sctp_addr_param * addr_param ;__u32 serial ;int length ;,__u32 serial ;,828
2364,"addr_param = ( union sctp_addr_param * ) hdr -> params ;length = ntohs ( addr_param -> p . length ) ;if ( length < sizeof ( sctp_paramhdr_t ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) addr_param , commands ) ;if ( ! sctp_verify_asconf ( asoc ,  ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) ,  ( void * ) chunk -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;","if ( ! sctp_verify_asconf ( asoc , ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) , ( void * ) chunk -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;",828
2365,"static void write_modes ( VP9_COMP * cpi , const TileInfo * const tile ,  vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ) {int mi_row , mi_col ;for ( mi_row = tile -> mi_row_start ;vp9_zero ( cpi -> mb . e_mbd . left_seg_context ) ;for ( mi_col = tile -> mi_col_start ;","static void write_modes ( VP9_COMP * cpi , const TileInfo * const tile , vpx_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const tok_end ) {const VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ;int mi_row , mi_col ;set_partition_probs ( cm , xd ) ;for ( mi_row = tile -> mi_row_start ;vp9_zero ( xd -> left_seg_context ) ;for ( mi_col = tile -> mi_col_start ;",829
2366,"bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ;APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ;","apr_brigade_cleanup ( brigade ) ;bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ;APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ;",830
2367,"checkstackGC ( L , p -> maxstacksize + 1 ) ;setobjs2s ( L , L -> top ++ , ci -> func ) ;","luaD_checkstack ( L , p -> maxstacksize + 1 ) ;setobjs2s ( L , L -> top ++ , ci -> func ) ;",831
2368,"const char * sender ;sd_bus_message_handler_t callback ;void * userdata ;# endif int r ;assert ( registry ) ;r = check_good_user ( call , good_user ) ;","# endif const char * sender ;int r ;assert ( registry ) ;r = check_good_user ( call , good_user ) ;",832
2369,"
",""" ) ;if ( r >= 0 ) r = sd_bus_message_read ( q -> reply , ""bb"" , & authorized , & challenge ) ;if ( r < 0 ) return r ;if ( authorized ) return 1 ;if ( challenge ) return sd_bus_error_set ( ret_error , SD_BUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED , ""Interactive<S2SV_blank>authentication<S2SV_blank>required."" ) ;return - EACCES ;}# endif r = sd_bus_query_sender_privilege ( call , capability ) ;if ( r < 0 ) return r ;else if ( r > 0 ) return 1 ;sender = sd_bus_message_get_sender ( call ) ;if ( ! sender ) return - EBADMSG ;# if ENABLE_POLKIT c = sd_bus_message_get_allow_interactive_authorization ( call ) ;if ( c < 0 ) return c ;if ( c > 0 ) interactive = true ;r = hashmap_ensure_allocated ( registry , NULL ) ;if ( r < 0 ) return r ;r = sd_bus_message_new_method_call ( call -> bus , & pk , ""org.freedesktop.PolicyKit1"" , ""/org/freedesktop/PolicyKit1/Authority"" , ""org.freedesktop.PolicyKit1.Authority"" , ""CheckAuthorization"" ) ;if ( r < 0 ) return r ;r = sd_bus_message_append ( pk , ""(sa{sv})s"" , ""system-bus-name"" , 1 , ""name"" , ""s"" , sender , action ) ;if ( r < 0 ) return r ;r = bus_message_append_strv_key_value ( pk , details ) ;if ( r < 0 ) return r ;r = sd_bus_message_append ( pk , ""us"" , interactive , NULL ) ;if ( r < 0 ) return r ;q = new ( AsyncPolkitQuery , 1 ) ;if ( ! q ) return - ENOMEM ;* q = ( AsyncPolkitQuery ) {. request = sd_bus_message_ref ( call ) , };q -> action = strdup ( action ) ;if ( ! q -> action ) {async_polkit_query_free ( q ) ;return - ENOMEM ;}q -> details = strv_copy ( ( char * * ) details ) ;if ( ! q -> details ) {async_polkit_query_free ( q ) ;return - ENOMEM ;}r = hashmap_put ( * registry , call , q ) ;if ( r < 0 ) {async_polkit_query_free ( q ) ;return r ;}q -> registry = * registry ;r = sd_bus_call_async ( call -> bus , & q -> slot , pk , async_polkit_callback , q , 0 ) ;if ( r < 0 ) {async_polkit_query_free ( q ) ;return r ;}return 0 ;# endif return - EACCES ;sd_bus_error_copy ( ret_error , e ) ;return - sd_bus_error_get_errno ( e ) ;}r = sd_bus_message_enter_container ( q -> reply , \'r\' , ""bba{ss}",832
2370,dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;dev -> tx_queue_len = 0 ;,dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;dev -> tx_queue_len = 0 ;,833
2371,if ( ( ptr == NULL ) || ( * ptr == \'\\\\0\' ) ) continue ;,if ( ( strlen ( ptr ) > 2 ) && ( ptr == NULL ) || ( * ptr == \'\\\\0\' ) ) continue ;,834
2372,"if ( ( * ++ ptr == \\\'""\\\' ) && ( strchr ( & ptr [ 1 ] , \\\'""\\\' ) != NULL ) ) {char * ret = cli_strdup ( ++ ptr ) ;","if ( ( * ++ ptr == \\\'""\\\' ) && ( strchr ( & ptr [ 1 ] , \\\'""\\\' ) != NULL ) ) {char * ret = cli_strdup ( ++ ptr ) ;",834
2373,"
",nfp_repr_free ( repr ) ;,835
2374,goto err_reprs_clean ;}nfp_repr_free ( repr ) ;goto err_reprs_clean ;if ( err ) {nfp_port_free ( port ) ;,goto err_reprs_clean ;}kfree ( repr_priv ) ;nfp_repr_free ( repr ) ;goto err_reprs_clean ;if ( err ) {kfree ( repr_priv ) ;nfp_port_free ( port ) ;,835
2375,nfp_port_free ( port ) ;nfp_repr_free ( repr ) ;,kfree ( repr_priv ) ;nfp_port_free ( port ) ;nfp_repr_free ( repr ) ;,835
2376,proc = rqstp -> rq_procinfo ;rqstp -> rq_cachetype = proc -> pc_cachetype ;,"proc = rqstp -> rq_procinfo ;if ( nfs_request_too_big ( rqstp , proc ) ) {dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\\* statp = rpc_garbage_args ;return 1 ;}rqstp -> rq_cachetype = proc -> pc_cachetype ;",836
2377,"maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL ,  NULL , NULL ) ;if ( out . length && write_packet ( fd , & out ) ) {GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ;if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ;","maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL , NULL ) ;gss_release_buffer ( & min , & in , NULL ) ;if ( out . length && write_packet ( fd , & out ) ) {gss_release_buffer ( & min , & out ) ;GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ;if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ;",837
2378,"( * respond ) ( arg , 0 , NULL , NULL , NULL ) ;return ;","( * respond ) ( arg , EINVAL , NULL , NULL , NULL ) ;return ;",838
2379,"( * respond ) ( arg , 0 , NULL , NULL , NULL ) ;return ;","( * respond ) ( arg , 0 , NULL , NULL , NULL ) ;return ;",838
2380,struct twopass_rc * const twopass = & svc -> layer_context [ i ] . twopass ;svc -> spatial_layer_id = i ;,TWO_PASS * const twopass = & svc -> layer_context [ i ] . twopass ;svc -> spatial_layer_id = i ;,839
2381,skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == \'\\\,skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) && ! eof ( s ) ) ) if ( next ( s ) == \'\\\,840
2382,"while ( peek ( s ) != \'>\' && ! eol ( s ) )  buf_append ( s , next ( s ) ) ;","while ( peek ( s ) != \'>\' && ! eol ( s ) ) buf_append ( s , next ( s ) ) ;",840
2383,"avio_skip ( pb , 4 ) ;avio_skip ( pb , 4 ) ;","int ret ;avio_skip ( pb , 4 ) ;avio_skip ( pb , 4 ) ;",841
2384,"strncpy ( codec_name , val , sizeof ( codec_name ) - 1 ) ;","ret = strncpy ( codec_name , val , sizeof ( codec_name ) - 1 ) ;",841
2385,"sscanf ( val , ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ,  & header_key_part [ 0 ] , & header_key_part [ 1 ] , & header_key_part [ 2 ] , & header_key_part [ 3 ] ) ;for ( idx = 0 ;AV_WB32 ( & header_key [ idx * 4 ] , header_key_part [ idx ] ) ;","sscanf ( val , ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 ""%"" SCNu32 , & header_key_part [ 0 ] , & header_key_part [ 1 ] , & header_key_part [ 2 ] , & header_key_part [ 3 ] ) ;if ( ret != 4 ) return AVERROR_INVALIDDATA ;for ( idx = 0 ;AV_WB32 ( & header_key [ idx * 4 ] , header_key_part [ idx ] ) ;",841
2386,"
","if ( daemon_mode == TRUE && sigrestart == FALSE ) {result = daemon_init ( ) ;if ( result == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ;cleanup ( ) ;exit ( EXIT_FAILURE ) ;}nagios_pid = ( int ) getpid ( ) ;}",842
2387,"if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ;","if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) {logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ;",842
2388,exit ( EXIT_FAILURE ) ;},exit ( EXIT_FAILURE ) ;},842
2389,# define REMAIN ( buf -> length - ( ptr - bufstart ) )  if ( REMAIN > INT_MAX )  return GSS_S_DEFECTIVE_TOKEN ;,# define REMAIN ( buf -> length - ( ptr - bufstart ) ) if ( REMAIN == 0 || REMAIN > INT_MAX ) return GSS_S_DEFECTIVE_TOKEN ;,843
2390,"static void findoprnd ( ITEM * ptr , int32 * pos )  {# ifdef BS_DEBUG elog ( DEBUG3 , ( ptr [ * pos ] . type == OPR ) ? ""%d<S2SV_blank><S2SV_blank>%c"" : ""%d<S2SV_blank><S2SV_blank>%d"" , * pos , ptr [ * pos ] . val ) ;","static void findoprnd ( ITEM * ptr , int32 * pos ) {check_stack_depth ( ) ;# ifdef BS_DEBUG elog ( DEBUG3 , ( ptr [ * pos ] . type == OPR ) ? ""%d<S2SV_blank><S2SV_blank>%c"" : ""%d<S2SV_blank><S2SV_blank>%d"" , * pos , ptr [ * pos ] . val ) ;",844
2391,"vma = find_vma_prev ( mm , start , & prev ) ;if ( ! vma ) goto out_unlock ;","if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;vma = find_vma_prev ( mm , start , & prev ) ;if ( ! vma ) goto out_unlock ;",845
2392,"vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ;vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ;","memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ;memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ;",846
2393,"vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ;vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ;","memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ;memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ;",846
2394,"vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ;vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ;","memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ;memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ;",846
2395,struct dentry * dir = nd -> path . dentry ;int open_flag = op -> open_flag ;,struct dentry * dir = nd -> path . dentry ;kuid_t dir_uid = dir -> d_inode -> i_uid ;umode_t dir_mode = dir -> d_inode -> i_mode ;int open_flag = op -> open_flag ;,847
2396,"error = may_create_in_sticky ( dir ,  d_backing_inode ( nd -> path . dentry ) ) ;","error = may_create_in_sticky ( dir_mode , dir_uid , d_backing_inode ( nd -> path . dentry ) ) ;",847
2397,"static vpx_codec_err_t vp8e_set_previewpp ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {# if CONFIG_POSTPROC  vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ;( void ) ctr_id ;# else ( void ) ctx ;( void ) ctr_id ;( void ) args ;","static vpx_codec_err_t vp8e_set_previewpp ( vpx_codec_alg_priv_t * ctx , va_list args ) {# if CONFIG_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ;# else ( void ) args ;",848
2398,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,849
2399,args -> skippable [ 0 ] &= ( ! args -> x -> plane [ plane ] . eobs [ block ] ) ;},( void ) plane ;( void ) plane_bsize ;( void ) tx_size ;args -> skippable [ 0 ] &= ( ! args -> eobs [ block ] ) ;},850
2400,"int nAlloc = ( pIn ? pIn [ 0 ] * 2 : 10 ) + nInt ;VList * pOut = sqlite3DbRealloc ( db , pIn , nAlloc * sizeof ( int ) ) ;","sqlite3_int64 nAlloc = ( pIn ? pIn [ 0 ] * 2 : 10 ) + nInt ;VList * pOut = sqlite3DbRealloc ( db , pIn , nAlloc * sizeof ( int ) ) ;",851
2401,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,852
2402,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",852
2403,"
",LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;,852
2404,l_row -- ;l_column -- ;,l_row -- ;l_column -- ;,852
2405,"if ( ( * t ++ = * s ++ ) != '&' ) continue ;if ( * s == '#' ) {UV num = 0 ;if ( * s == 'x' || * s == 'X' ) {s ++ ;while ( * s ) {char * tmp = strchr ( PL_hexdigit , * s ) ;","if ( s < end && ( * t ++ = * s ++ ) != '&' ) continue ;if ( * s == '#' ) {UV num = 0 ;if ( s < end && ( * s == 'x' || * s == 'X' ) ) {s ++ ;while ( s < end ) {char * tmp = strchr ( PL_hexdigit , * s ) ;",853
2406,while ( isDIGIT ( * s ) ) {num = num * 10 + ( * s - '0' ) ;,while ( s < end && isDIGIT ( * s ) ) {num = num * 10 + ( * s - '0' ) ;,853
2407,while ( isALNUM ( * s ) )  s ++ ;if ( ent_name != s && entity2char ) {,while ( s < end && isALNUM ( * s ) ) s ++ ;if ( s < end && ent_name != s && entity2char ) {,853
2408,if ( * s == ';' )  s ++ ;,if ( * s == ';' ) s ++ ;,853
2409,"node * n = Ta3Parser_ParseStringObject ( s , filename ,  & _Ta3Parser_Grammar , start , & err , & iflags ) ;","node * n ;if ( feature_version >= 7 ) iflags |= PyPARSE_ASYNC_ALWAYS ;n = Ta3Parser_ParseStringObject ( s , filename , & _Ta3Parser_Grammar , start , & err , & iflags ) ;",854
2410,"int openasuser ;int should_free_origin = 0 ;int should_free_authpending_file = 0 ;parse_cfg ( flags , argc , argv , cfg ) ;","int openasuser = 0 ;int should_free_origin = 0 ;int should_free_authpending_file = 0 ;PAM_MODUTIL_DEF_PRIVS ( privs ) ;parse_cfg ( flags , argc , argv , cfg ) ;openasuser = geteuid ( ) == 0 ? 1 : 0 ;",855
2411,"snprintf ( buf , authfile_dir_len ,  ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ;else {DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ;authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ;buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ;if ( ! buf ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ;retval = PAM_IGNORE ;goto done ;snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ;}DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ;cfg -> auth_file = buf ;should_free_auth_file = 1 ;openasuser = geteuid ( ) == 0 && cfg -> openasuser ;if ( openasuser ) {if ( seteuid ( pw_s . pw_uid ) ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ;retval = PAM_IGNORE ;DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ;}if ( seteuid ( 0 ) ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ;DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ;}if ( cfg -> nouserok ) {DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ;","snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ;if ( ! openasuser ) {DBG ( ""WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>"" ""consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration"" , buf ) ;DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ;cfg -> auth_file = buf ;should_free_auth_file = 1 ;openasuser = geteuid ( ) == 0 && cfg -> openasuser ;if ( openasuser ) {if ( seteuid ( pw_s . pw_uid ) ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ;retval = PAM_IGNORE ;DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ;}DBG ( ""Dropping<S2SV_blank>privileges"" ) ;if ( pam_modutil_drop_priv ( pamh , & privs , pw ) ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ;DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ;}if ( pam_modutil_regain_priv ( pamh , & privs ) ) {DBG ( ""could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges"" ) ;",855
