,source,target,group
0,if ( np -> opt != NULL )   icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen +   np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,if ( np -> opt != NULL ) icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,2482
1,cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ;cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 1 ;cm -> refresh_entropy_probs = 1 ;,"
",2483
2,"cpi -> temporal_pattern_counter = 0 ;reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ;cm -> Width = cpi -> oxcf . Width ;cm -> Height = cpi -> oxcf . Height ;if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ;","if ( cpi -> temporal_layer_id > 0 ) {cpi -> temporal_layer_id = 0 ;cpi -> temporal_pattern_counter = 0 ;reset_temporal_layer_change ( cpi , oxcf , prev_number_of_layers ) ;}if ( ! cpi -> initial_width ) {cpi -> initial_width = cpi -> oxcf . Width ;cpi -> initial_height = cpi -> oxcf . Height ;assert ( cm -> Width <= cpi -> initial_width ) ;assert ( cm -> Height <= cpi -> initial_height ) ;}cm -> Width = cpi -> oxcf . Width ;cm -> Height = cpi -> oxcf . Height ;if ( cpi -> oxcf . Sharpness > 7 ) cpi -> oxcf . Sharpness = 7 ;",2483
3,"vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ;}","vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ;}",2483
4,if ( tcp -> csty & J2K_CP_CSTY_SOP ) {c [ 0 ] = 255 ;,"if ( tcp -> csty & J2K_CP_CSTY_SOP ) {if ( length < 6 ) {if ( p_t2_mode == FINAL_PASS ) {opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\\}return OPJ_FALSE ;}c [ 0 ] = 255 ;",2484
5,if ( tcp -> csty & J2K_CP_CSTY_EPH ) {c [ 0 ] = 255 ;,"if ( tcp -> csty & J2K_CP_CSTY_EPH ) {if ( length < 2 ) {if ( p_t2_mode == FINAL_PASS ) {opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\\}return OPJ_FALSE ;}c [ 0 ] = 255 ;",2484
6,"
",if ( lha -> compsize < 0 ) goto invalid ;,2485
7,"if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;","if ( sum_calculated != headersum ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error"" ) ;",2485
8,"
","if ( ! allocate_field ( stream , field -> pField , field -> data_size , ( size_t ) ( * size + 1 ) ) ) return false ;field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ;",2486
9,"}if ( ! pb_close_string_substream ( stream , & substream ) ) return false ;return status ;}else {pb_size_t * size = ( pb_size_t * ) field -> pSize ;if ( * size == PB_SIZE_MAX ) PB_RETURN_ERROR ( stream , ""too<S2SV_blank>many<S2SV_blank>array<S2SV_blank>entries"" ) ;if ( ! check_wire_type ( wire_type , field ) ) PB_RETURN_ERROR ( stream , ""wrong<S2SV_blank>wire<S2SV_blank>type"" ) ;( * size ) ++ ;if ( ! allocate_field ( stream , field -> pField , field -> data_size , * size ) ) return false ;field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size - 1 ) ;","
",2486
10,rfcomm_dlc_accept ( d ) ;return 0 ;,rfcomm_dlc_accept ( d ) ;msg -> msg_namelen = 0 ;return 0 ;,2487
11,"static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2488
12,"memcpy ( & bss_cfg -> wmm_info , wmm_ie +   sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;","if ( * ( wmm_ie + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ;memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ;priv -> wmm_enabled = 1 ;",2489
13,"FILE * file = fopen ( dump_file , ""w"" ) ;if ( ! file ) {","FILE * file = fopen_safe ( dump_file , ""w"" ) ;if ( ! file ) {",2490
14,if ( d_mountpoint ( dentry ) )  return 1 ;if ( nfsd4_is_junction ( dentry ) ) return 1 ;if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) )  return 0 ;return d_inode ( dentry ) != NULL ;},if ( ! d_inode ( dentry ) ) return 0 ;if ( d_mountpoint ( dentry ) ) return 2 ;return 0 ;},2491
15,StringValue ( data ) ;in = ( unsigned char * ) RSTRING_PTR ( data ) ;,"if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ;StringValue ( data ) ;in = ( unsigned char * ) RSTRING_PTR ( data ) ;",2492
16,"p = strchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;","p = osStrchr ( context -> buffer , \'<S2SV_blank>\' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;",2493
17,"int pkt_len , pktnum , hr , min , sec , csec ;char channel [ 10 ] , direction [ 10 ] ;","guint pkt_len ;int pktnum , hr , min , sec , csec ;char channel [ 10 ] , direction [ 10 ] ;",2494
18,"num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {phdr -> rec_type = REC_TYPE_PACKET ;phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ;","num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {if ( pkt_len > WTAP_MAX_PACKET_SIZE ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ;return FALSE ;}phdr -> rec_type = REC_TYPE_PACKET ;phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ;",2494
19,"ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ;pd = ws_buffer_start_ptr ( buf ) ;","ws_buffer_assure_space ( buf , pkt_len ) ;pd = ws_buffer_start_ptr ( buf ) ;",2494
20,long timeo ;msg -> msg_namelen = 0 ;,long timeo ;,2495
21,"int nNew = MAX ( 128 , p -> nAlloc * 2 ) ;while ( nByte > nNew ) nNew = nNew * 2 ;","sqlite3_int64 nNew = MAX ( 128 , 2 * ( sqlite3_int64 ) p -> nAlloc ) ;while ( nByte > nNew ) nNew = nNew * 2 ;",2496
22,"void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest ,  int stride , int eob ) {","void vp9_iht16x16_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) {",2497
23,"xfs_daddr_t blkno = map [ 0 ] . bm_bn ;int numblks = 0 ;pag = xfs_perag_get ( btp -> bt_mount ,  xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;","xfs_daddr_t blkno = map [ 0 ] . bm_bn ;xfs_daddr_t eofs ;int numblks = 0 ;eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ;if ( blkno >= eofs ) {xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ;return NULL ;}pag = xfs_perag_get ( btp -> bt_mount , xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ;",2498
24,"fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;fptr_orig = io_get_open_fptr ( mrb , orig ) ;","fptr_orig = io_get_open_fptr ( mrb , orig ) ;fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ;if ( fptr_copy != NULL ) {fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ;",2499
25,"ret = poll ( pfds , 1 , 50 ) ;if ( ret < 0 ) {","ret = TEMP_FAILURE_RETRY ( poll ( pfds , 1 , 50 ) ) ;if ( ret < 0 ) {",2500
26,struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;,struct flowi6 * fl6 ;int err = 0 ;int is_udplite = IS_UDPLITE ( sk ) ;if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ;fl6 = & inet -> cork . fl . u . ip6 ;,2501
27,"while ( c && cJSON_strcasecmp ( c -> string , string ) ) {++ i ;c = c -> next ;}if ( c ) {","+ i ;while ( c && cJSON_strcasecmp ( c -> string , string ) ) i ++ , c = c -> next ;}if ( c ) {",2502
28,"# if ENABLE_BGP_VNC  case BGP_ATTR_VNC : attrname = ""VNC"" ;","# if ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC : attrname = ""VNC"" ;",2503
29,"if ( err ) goto out ;upperdentry = ovl_dentry_upper ( dentry ) ;if ( upperdentry ) {mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;","mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ;}err = ovl_copy_up_last ( dentry , attr , false ) ;",2504
30,"if ( copy_from_user ( & info , u_info , sizeof ( info ) ) )  return - EFAULT ;if ( idx == - 1 ) idx = info . entry_number ;","if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) return - EFAULT ;if ( ! tls_desc_okay ( & info ) ) return - EINVAL ;if ( idx == - 1 ) idx = info . entry_number ;",2505
31,"
",mutt_socket_empty ( adata -> conn ) ;,2506
32,if ( rc == - 1 )  goto err_conn ;,if ( rc == - 1 ) goto err_conn ;,2506
33,"char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}return - EIO ;}return snprintf ( buf , PAGE_SIZE , ""%d\\\","char * data ;data = kmalloc ( 8 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}ret = - EIO ;goto out ;}ret = snprintf ( buf , PAGE_SIZE , ""%d\\\out : kfree ( data ) ;return ret ;",2507
34,"static void set_fdc ( int drive )  {if ( drive >= 0 && drive < N_DRIVE ) {fdc = FDC ( drive ) ;current_drive = drive ;if ( fdc != 1 && fdc != 0 ) {pr_info ( ""bad<S2SV_blank>fdc<S2SV_blank>value\\\}set_dor ( fdc , ~ 0 , 8 ) ;","static void set_fdc ( int drive ) {unsigned int new_fdc = fdc ;if ( drive >= 0 && drive < N_DRIVE ) {new_fdc = FDC ( drive ) ;current_drive = drive ;if ( new_fdc >= N_FDC ) {pr_info ( ""bad<S2SV_blank>fdc<S2SV_blank>value\\\}fdc = new_fdc ;set_dor ( fdc , ~ 0 , 8 ) ;",2508
35,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2509
36,# if ! ( CONFIG_FAST_UNALIGNED )  dst [ 0 ] = src [ 0 ] ;dst [ 1 ] = src [ 1 ] ;dst [ 2 ] = src [ 2 ] ;dst [ 3 ] = src [ 3 ] ;dst [ 4 ] = src [ 4 ] ;dst [ 5 ] = src [ 5 ] ;dst [ 6 ] = src [ 6 ] ;dst [ 7 ] = src [ 7 ] ;dst [ 8 ] = src [ 8 ] ;dst [ 9 ] = src [ 9 ] ;dst [ 10 ] = src [ 10 ] ;dst [ 11 ] = src [ 11 ] ;dst [ 12 ] = src [ 12 ] ;dst [ 13 ] = src [ 13 ] ;dst [ 14 ] = src [ 14 ] ;dst [ 15 ] = src [ 15 ] ;# else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ;( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ;( ( uint32_t * ) dst ) [ 2 ] = ( ( uint32_t * ) src ) [ 2 ] ;( ( uint32_t * ) dst ) [ 3 ] = ( ( uint32_t * ) src ) [ 3 ] ;# endif src += src_stride ;,"memcpy ( dst , src , 16 ) ;src += src_stride ;",2510
37,"spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;","int length = urb -> actual_length ;spin_lock ( & desc -> iuspin ) ;clear_bit ( WDM_RESPONDING , & desc -> flags ) ;",2511
38,"desc -> reslength = urb -> actual_length ;memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ;desc -> length += desc -> reslength ;","if ( length + desc -> length > desc -> wMaxCommand ) {set_bit ( WDM_OVERFLOW , & desc -> flags ) ;}else {if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) {memmove ( desc -> ubuf + desc -> length , desc -> inbuf , length ) ;desc -> length += length ;desc -> reslength = length ;}}",2511
39,"if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) )  timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ;remaining = kc -> timer_remaining ( timr , now ) ;","if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ;remaining = kc -> timer_remaining ( timr , now ) ;",2512
40,"
","if ( s -> diff_start + s -> diff_height > cur_blk_height ) {av_log ( avctx , AV_LOG_ERROR , ""Block<S2SV_blank>parameters<S2SV_blank>invalid\\\return AVERROR_INVALIDDATA ;}",2513
41,"av_log ( avctx , AV_LOG_DEBUG ,  ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\","av_log ( avctx , AV_LOG_DEBUG , ""%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\\",2513
42,"struct sshcomp * comp ;int r , mode ;for ( mode = 0 ;mode < MODE_MAX ;mode ++ ) {if ( ssh -> state -> newkeys [ mode ] == NULL ) continue ;comp = & ssh -> state -> newkeys [ mode ] -> comp ;if ( comp && comp -> enabled &&  ( r = ssh_packet_init_compression ( ssh ) ) != 0 )  return r ;}return 0 ;",int r ;if ( ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) return r ;}return 0 ;,2514
43,"logger ( Protocol , Debug , ""rdpdr_process()"" ) ;in_uint16 ( s , component ) ;","struct stream packet = * s ;logger ( Protocol , Debug , ""rdpdr_process()"" ) ;in_uint16 ( s , component ) ;",2515
44,"in_uint32_le ( s , g_client_id ) ;if ( vmin < 0x000c ) g_client_id = 0x815ed39d ;","in_uint32_le ( s , g_client_id ) ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""rdpdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>g_client_id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>did<S2SV_blank>overrun"" , & packet ) ;}if ( vmin < 0x000c ) g_client_id = 0x815ed39d ;",2515
45,"static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type ,  uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l , unsigned int mask_4x4_l , unsigned int mask_4x4_int_l , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) {const int mask_shift = plane_type ? 4 : 8 ;const int mask_cutoff = plane_type ? 0xf : 0xff ;const int lfl_forward = plane_type ? 4 : 8 ;unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ;","static void filter_selectively_vert_row2 ( int subsampling_factor , uint8_t * s , int pitch , unsigned int mask_16x16_l , unsigned int mask_8x8_l , unsigned int mask_4x4_l , unsigned int mask_4x4_int_l , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) {const int mask_shift = subsampling_factor ? 4 : 8 ;const int mask_cutoff = subsampling_factor ? 0xf : 0xff ;const int lfl_forward = subsampling_factor ? 4 : 8 ;unsigned int mask_16x16_0 = mask_16x16_l & mask_cutoff ;",2516
46,"const loop_filter_thresh * lfi0 = lfi_n -> lfthr + * lfl ;const loop_filter_thresh * lfi1 = lfi_n -> lfthr + * ( lfl + lfl_forward ) ;if ( mask & 1 ) {if ( ( mask_16x16_0 | mask_16x16_1 ) & 1 ) {if ( ( mask_16x16_0 & mask_16x16_1 ) & 1 ) {vp9_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim ,  lfi1 -> lim , lfi1 -> hev_thr ) ;if ( ( mask_8x8_0 & mask_8x8_1 ) & 1 ) {vp9_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ;vp9_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;if ( ( mask_4x4_0 & mask_4x4_1 ) & 1 ) {vp9_lpf_vertical_4_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ,  1 ) ;vp9_lpf_vertical_4 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim ,  lfi0 -> hev_thr , 1 ) ;vp9_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim ,  lfi1 -> hev_thr , 1 ) ;","vpx_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr ) ;vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vpx_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;vpx_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vpx_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr ) ;vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , 1 ) ;vpx_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim , lfi1 -> hev_thr , 1 ) ;",2516
47,"struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;struct netdev_desc * desc ;case SIOCDEVPRIVATE :  break ;case SIOCDEVPRIVATE + 1 :   miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;break ;case SIOCDEVPRIVATE + 2 :   mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ;break ;","struct mii_ioctl_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;struct netdev_desc * desc ;case SIOCGMIIPHY : miidata -> phy_id = phy_addr ;break ;case SIOCGMIIREG : miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;break ;case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;mii_write ( dev , phy_addr , miidata -> val_in ) ;break ;",2517
48,"if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) {log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\\log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s\\\if ( fgetc ( reader -> fhd ) != 0 ) {","if ( reader -> recursive_counter >= 10 ) return MYSOFA_INVALID_FORMAT ;else reader -> recursive_counter ++ ;if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) {log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>fractal<S2SV_blank>heap<S2SV_blank>indirect<S2SV_blank>block\\\log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s<S2SV_blank>stack<S2SV_blank>%d\\\if ( fgetc ( reader -> fhd ) != 0 ) {",2518
49,return MYSOFA_OK ;},reader -> recursive_counter -- ;return MYSOFA_OK ;},2518
50,"rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;","if ( desc == NULL ) desc = """" ;rhost_old [ 0 ] = \'\\\\0\' ;r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ;",2519
51,"static int  _PyMemoTable_ResizeTable ( PyMemoTable * self , Py_ssize_t min_size )  {Py_ssize_t new_size = MT_MINSIZE ;Py_ssize_t to_process ;assert ( min_size > 0 ) ;while ( new_size < min_size && new_size > 0 )  new_size <<= 1 ;if ( new_size <= 0 ) {","static int _PyMemoTable_ResizeTable ( PyMemoTable * self , size_t min_size ) {size_t new_size = MT_MINSIZE ;Py_ssize_t to_process ;assert ( min_size > 0 ) ;if ( min_size > PY_SSIZE_T_MAX ) {while ( new_size < min_size ) {new_size <<= 1 ;}",2520
52,struct stat st ;size_t pathlen ;,size_t pathlen ;,2521
53,"pr_fs_clear_cache ( ) ;res = pr_fsio_lstat ( path , & st ) ;xerrno = errno ;pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path ,  strerror ( xerrno ) ) ;errno = xerrno ;return - 1 ;if ( S_ISLNK ( st . st_mode ) ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>"" ""config)"" , path ) ;","res = is_symlink_path ( p , path , pathlen ) ;if ( errno == EPERM ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ;",2521
54,"static void prefetch_dec ( void )  {prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;","static void prefetch_dec ( void ) {dec_tables . counter_head ++ ;dec_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;",2522
55,"gdImageWBMPCtx ( im , fg , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;","if ( ! _gdImageWBMPCtx ( im , fg , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",2523
56,parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;parameters -> prch_init [ i ] = 256 ;},if ( parameters -> numresolution == 1 ) {parameters -> res_spec = 1 ;parameters -> prcw_init [ 0 ] = 128 ;parameters -> prch_init [ 0 ] = 128 ;}else {parameters -> res_spec = parameters -> numresolution - 1 ;for ( i = 0 ;}parameters -> prch_init [ i ] = 256 ;},2524
57,"int copied , error = - EINVAL ;if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ;","int copied , error = - EINVAL ;msg -> msg_namelen = 0 ;if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ;",2525
58,"goto try_again ;req -> status = 0 ;req -> zero = 0 ;req -> length = count ;req -> complete = f_hidg_req_complete ;req -> context = hidg ;status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ;if ( status < 0 ) {ERROR ( hidg -> func . config -> cdev , ""usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\\goto release_write_pending_unlocked ;}spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked :  hidg -> write_pending = 0 ;","goto release_write_pending ;spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ;return status ;release_write_pending_unlocked : hidg -> write_pending = 0 ;",2526
59,"struct usmStateReference * old_ref = ( struct usmStateReference * ) old ;if ( old_ref ) {if ( old_ref -> usr_name_length ) SNMP_FREE ( old_ref -> usr_name ) ;if ( old_ref -> usr_engine_id_length )  SNMP_FREE ( old_ref -> usr_engine_id ) ;if ( old_ref -> usr_auth_protocol_length )  SNMP_FREE ( old_ref -> usr_auth_protocol ) ;if ( old_ref -> usr_priv_protocol_length )  SNMP_FREE ( old_ref -> usr_priv_protocol ) ;if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) {SNMP_ZERO ( old_ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ;SNMP_FREE ( old_ref -> usr_auth_key ) ;}if ( old_ref -> usr_priv_key_length && old_ref -> usr_priv_key ) {SNMP_ZERO ( old_ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ;SNMP_FREE ( old_ref -> usr_priv_key ) ;}SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ;SNMP_FREE ( old_ref ) ;}","struct usmStateReference * ref = old ;if ( old_ref ) {if ( old_ref -> usr_name_length ) SNMP_FREE ( old_ref -> usr_name ) ;SNMP_FREE ( ref -> usr_engine_id ) ;if ( old_ref -> usr_auth_protocol_length ) SNMP_FREE ( old_ref -> usr_auth_protocol ) ;SNMP_FREE ( ref -> usr_priv_protocol ) ;if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) {SNMP_ZERO ( ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ;SNMP_FREE ( ref -> usr_auth_key ) ;}if ( ref -> usr_priv_key_length && old_ref -> usr_priv_key ) {SNMP_ZERO ( ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ;SNMP_FREE ( ref -> usr_priv_key ) ;}SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ;SNMP_FREE ( old_ref ) ;}",2527
60,"if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\","if ( ! urb -> actual_length ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\\return ;}if ( status ) {dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\\",2528
61,"else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) {memcpy ( command_info -> result_buffer , & data [ 1 ] ,  urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;","else if ( ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) {}else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) && ( urb -> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) {memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 ) ;command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ;",2528
62,"void ptrace_triggered ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","void ptrace_triggered ( struct perf_event * bp , struct perf_sample_data * data , struct pt_regs * regs ) {",2529
63,"if ( plen > 1024 * 1024 - 1 ) goto error ;ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ;if ( ret < 0 ) goto error ;description = NULL ;if ( _description ) {description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ;if ( IS_ERR ( description ) ) {",if ( plen ) {,2530
64,if ( _payload ) {ret = - ENOMEM ;,if ( _payload ) {ret = - ENOMEM ;,2530
65,"static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {const MACROBLOCK * const x = & cpi -> mb ;const MACROBLOCKD * const xd = & x -> e_mbd ;","static void save_context ( MACROBLOCK * const x , int mi_row , int mi_col , ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {const MACROBLOCKD * const xd = & x -> e_mbd ;",2531
66,"vpx_memcpy (  a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;vpx_memcpy (  l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;vpx_memcpy ( sa , xd -> above_seg_context + mi_col ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;","memcpy ( a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;memcpy ( l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;memcpy ( sa , xd -> above_seg_context + mi_col , sizeof ( * xd -> above_seg_context ) * mi_width ) ;memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) , sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;",2531
67,int blockstodecode ;av_assert0 ( s -> samples >= 0 ) ;,int blockstodecode ;uint64_t decoded_buffer_size ;av_assert0 ( s -> samples >= 0 ) ;,2532
68,"if ( ! nblocks || nblocks > INT_MAX ) {av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\\","if ( ! nblocks || nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 ) {av_log ( avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%"" PRIu32 "".\\\",2532
69,"av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size ,   2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ;if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ;","decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ;av_assert0 ( decoded_buffer_size <= INT_MAX ) ;av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , decoded_buffer_size ) ;if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ;",2532
70,"int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;unsigned v = get_symbol ( c , state , 0 ) ;","int chroma_planes , chroma_h_shift , chroma_v_shift , transparency , colorspace , bits_per_raw_sample ;unsigned v = get_symbol ( c , state , 0 ) ;",2533
71,"f -> colorspace = get_symbol ( c , state , 0 ) ;if ( f -> version > 0 )   f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;chroma_planes = get_rac ( c , state ) ;chroma_h_shift = get_symbol ( c , state , 0 ) ;chroma_v_shift = get_symbol ( c , state , 0 ) ;if ( chroma_planes != f -> chroma_planes  || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) {}f -> chroma_planes = chroma_planes ;","colorspace = get_symbol ( c , state , 0 ) ;bits_per_raw_sample = f -> version > 0 ) f -> avctx -> bits_per_raw_sample ;chroma_planes = get_rac ( c , state ) ;chroma_h_shift = get_symbol ( c , state , 0 ) ;chroma_v_shift = get_symbol ( c , state , 0 ) ;if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) {}f -> colorspace = colorspace ;f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;f -> chroma_planes = chroma_planes ;",2533
72,frame_end :  ff_er_frame_end ( & s -> er ) ;,frame_end : if ( ! s -> studio_profile ) ff_er_frame_end ( & s -> er ) ;,2534
73,sas_port_delete ( port -> port ) ;port -> port = NULL ;,sas_destruct_devices ( port ) ;sas_port_delete ( port -> port ) ;port -> port = NULL ;,2535
74,case OBJECT_TYPE_INTEGER :  ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ;break ;case OBJECT_TYPE_STRING :  ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;break ;,case OBJECT_TYPE_INTEGER : ( ( YR_OBJECT_INTEGER * ) copy ) -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value ;break ;case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) object ) -> value != NULL ) {( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ;}else {( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ;}break ;case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value ;break ;,2536
75,if ( ! vct_iscrlf ( * r ) ) {r ++ ;,if ( ! vct_iscrlf ( r ) ) {r ++ ;,2537
76,unsigned int random_variable = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {random_variable = get_random_int ( ) & STACK_RND_MASK ;random_variable <<= PAGE_SHIFT ;,unsigned long random_variable = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {random_variable = ( unsigned long ) get_random_int ( ) ;random_variable &= STACK_RND_MASK ;random_variable <<= PAGE_SHIFT ;,2538
77,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;buf [ 1 ] |= 1 << offset ;buf [ 2 ] = gpio_push_pull ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ;if ( ret < 0 ) {hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\\goto fail ;}spin_unlock_irqrestore ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;mutex_unlock ( & dev -> lock , flags ) ;cp2112_gpio_set ( chip , offset , value ) ;fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret < 0 ? ret : - EIO ;",2539
78,"spin_lock ( & inode -> i_lock ) ;inode -> i_blocks -= ( blocks_per_huge_page ( h ) * freed ) ;spin_unlock ( & inode -> i_lock ) ;hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ;hugetlb_acct_memory ( h , - ( chg - freed ) ) ;","struct hugepage_subpool * spool = subpool_inode ( inode ) ;spin_lock ( & inode -> i_lock ) ;hugepage_subpool_put_pages ( spool , ( chg - freed ) ) ;hugetlb_acct_memory ( h , - ( chg - freed ) ) ;",2540
79,"if ( keyring_key -> type != & key_type_logon ) {printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\\down_read ( & keyring_key -> sem ) ;ukp = user_key_payload ( keyring_key ) ;if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) {up_read ( & keyring_key -> sem ) ;","down_read ( & keyring_key -> sem ) ;if ( keyring_key -> type != & key_type_logon ) {printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\\ukp = user_key_payload ( keyring_key ) ;if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) {",2541
80,up_read ( & keyring_key -> sem ) ;up_read ( & keyring_key -> sem ) ;if ( res ) goto out ;crypt_info -> ci_keyring_key = keyring_key ;return 0 ;out : key_put ( keyring_key ) ;,out : up_read ( & keyring_key -> sem ) ;key_put ( keyring_key ) ;,2541
81,"memcpy ( res , dbg_data , nb10sz ) ;res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ;","
",2542
82,"int need_error_free = 0 ;int local_rcache = 0 , local_authcon = 0 ;if ( strcmp ( inbuf . data , sendauth_version ) ) {problem = KRB5_SENDAUTH_BADAUTHVERS ;","krb5_data d ;int need_error_free = 0 ;int local_rcache = 0 , local_authcon = 0 ;d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ;if ( ! data_eq ( inbuf , d ) ) {problem = KRB5_SENDAUTH_BADAUTHVERS ;",2543
83,"if ( appl_version && strcmp ( inbuf . data , appl_version ) ) {if ( ! problem ) {","if ( appl_version != NULL && ! problem ) {d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ;if ( ! data_eq ( inbuf , d ) ) {",2543
84,list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;,"if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ;ptr = buf ;",2544
85,hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ;},hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED ) ;},2545
86,"unsigned long flags ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;","unsigned long flags ;if ( qid > NVMET_NR_QUEUES ) return NULL ;spin_lock_irqsave ( & tgtport -> lock , flags ) ;",2546
87,if ( msg -> maxsize - msg -> cursize < 4 ) {msg -> overflowed = qtrue ;,if ( msg -> overflowed ) {,2547
88,if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) {msg -> overflowed = qtrue ;return ;}if ( bits == 8 ) {msg -> data [ msg -> cursize ] = value ;,2547
89,nbits = bits & 7 ;for ( i = 0 ;,"nbits = bits & 7 ;if ( msg -> bit , msg -> maxsize << 3 + nbits > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}for ( i = 0 ;",2547
90,"Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;}}","Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ;value = ( value >> 8 ) ;if ( msg -> bit > msg -> maxsize << 3 ) {msg -> overflowed = qtrue ;return ;}}}",2547
91,( NULL != ptr ) # if KEEP_NIS_AT_END  && ( NULL != ptr -> line )   && ( ( '+' != ptr -> line [ 0 ] )   && ( '-' != ptr -> line [ 0 ] ) )  # endif ;# if KEEP_NIS_AT_END  if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) {nis = ptr ;,( NULL != ptr ) # if KEEP_NIS_AT_END && ( ( NULL == ptr -> line ) && ( ( '+' != ptr -> line [ 0 ] ) ) ) # endif ;# if KEEP_NIS_AT_END if ( NULL != ptr ) {nis = ptr ;,2548
92,"if ( interpolation ) {if ( source < source_base ) source = source_base ;horiz_line_scale ( source , source_width , temp_area , dest_width ) ;}for ( k = 0 ;k < ( int ) ( dest_height + dest_band_height - 1 ) / dest_band_height ;k ++ ) {for ( i = 0 ;i < source_band_height ;i ++ ) {line_src = ( unsigned char * ) source + i * source_pitch ;if ( line_src < source_base ) line_src = source_base ;horiz_line_scale ( line_src , source_width , temp_area + ( i + 1 ) * dest_pitch , dest_width ) ;}vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ;if ( interpolation )  vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ;source += ( unsigned long ) source_band_height * source_pitch ;","if ( interpolation ) memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ;source += ( unsigned long ) source_band_height * source_pitch ;",2549
93,"source_band_height = temp_area_height - 1 ;dest_band_height = source_band_height * vratio / vscale ;Scale1Dh ( source , 1 , hscale , source_width + 1 , temp_area , 1 , hratio , dest_width ) ;bands = ( dest_height + dest_band_height - 1 ) / dest_band_height ;for ( k = 0 ;k < bands ;k ++ ) {for ( i = 1 ;i < source_band_height + 1 ;i ++ ) {if ( k * source_band_height + i < ( int ) source_height ) {Scale1Dh ( source + i * source_pitch , 1 , hscale , source_width + 1 , temp_area + i * dest_pitch , 1 , hratio , dest_width ) ;}else {vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ;}vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ;source += source_band_height * source_pitch ;","memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ;vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ;source += source_band_height * source_pitch ;",2549
94,if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,if ( sctp_chunk_pending ( ack ) ) continue ;if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,2550
95,if ( IS_ERR ( blkg ) ) {blkg_free ( new_blkg ) ;return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,if ( IS_ERR ( blkg ) ) return PTR_ERR ( blkg ) ;}q -> root_blkg = blkg ;,2551
96,"static int  mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen )  {MPT_FRAME_HDR * mf ;MPT_ADAPTER * iocp ;","static int mptctl_do_fw_download ( MPT_ADAPTER * iocp , char __user * ufwbuf , size_t fwlen ) {MPT_FRAME_HDR * mf ;",2552
97,"if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) {printk ( KERN_DEBUG MYNAM ""ioctl_fwdl<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;}else {}dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\\","}dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\\dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\\",2552
98,"skb -> sk = sk ;llc_sap_state_process ( sap , skb ) ;","skb_orphan ( skb ) ;sock_hold ( sk ) ;skb -> sk = sk ;skb -> destructor = sock_efree ;llc_sap_state_process ( sap , skb ) ;",2553
99,# if HAVE_NEON  int64_t store_reg [ 8 ] ;# endif VP8_COMMON * cm ;,VP8_COMMON * cm ;,2554
100,return VPX_CODEC_CORRUPT_FRAME ;}cpi -> common . error . setjmp = 1 ;# if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_push_neon ( store_reg ) ;# endif vpx_usec_timer_start ( & cmptimer ) ;,vp8_clear_system_state ( ) ;return VPX_CODEC_CORRUPT_FRAME ;cpi -> common . error . setjmp = 1 ;vpx_usec_timer_start ( & cmptimer ) ;,2554
101,"# endif if ( ! cpi -> source ) {if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) {if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ;",# endif return - 1 ;,2554
102,# endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {,# endif # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {,2554
103,if ( cpi -> oxcf . number_of_layers > 1 )  {unsigned int i ;assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;for ( i = 0 ;i < cpi -> oxcf . number_of_layers ;i ++ )  {,# if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 ) {LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ;if ( cpi -> oxcf . mr_encoder_id ) {cpi -> ref_framerate = low_res_frame_info -> low_res_framerate ;}else {low_res_frame_info -> low_res_framerate = cpi -> ref_framerate ;}}# endif if ( cpi -> oxcf . number_of_layers && i < VPX_TS_MAX_LAYERS ;++ i ) {,2554
104,"layer = cpi -> oxcf . layer_id [   cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;restore_layer_context ( cpi , layer ) ;vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ;}if ( cpi -> compressor_speed == 2 ) {vpx_usec_timer_start ( & tsctimer ) ;vpx_usec_timer_start ( & ticktimer ) ;}cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ;# if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING {int i ;const int num_part = ( 1 << cm -> multi_token_partition ) ;const unsigned long dest_size = dest_end - dest ;const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ;unsigned char * dp = dest ;cpi -> partition_d [ 0 ] = dp ;dp += dest_size / 10 ;cpi -> partition_d_end [ 0 ] = dp ;for ( i = 0 ;i < num_part ;i ++ ) {cpi -> partition_d [ i + 1 ] = dp ;dp += tok_part_buff_size ;cpi -> partition_d_end [ i + 1 ] = dp ;}}# endif * size = 0 ;vp8_clear_system_state ( ) ;cm -> frame_type = INTER_FRAME ;cm -> frame_flags = * frame_flags ;# if 0 if ( cm -> refresh_alt_ref_frame ) {cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 0 ;}else {cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 1 ;}# endif {int i = 0 ;for ( ;i < NUM_YV12_BUFFERS ;i ++ ) {if ( ! cm -> yv12_fb [ i ] . flags ) {cm -> new_fb_idx = i ;break ;}}assert ( i < NUM_YV12_BUFFERS ) ;# if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) {Pass1Encode ( cpi , size , dest , frame_flags ) ;}else if ( cpi -> pass == 2 ) {Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ;}else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ;if ( cpi -> compressor_speed == 2 ) {unsigned int duration , duration2 ;vpx_usec_timer_mark ( & tsctimer ) ;vpx_usec_timer_mark ( & ticktimer ) ;duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ;duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ;if ( cm -> frame_type != KEY_FRAME ) {if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ;else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ;}if ( duration2 ) {{if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ;else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ;}}}if ( cm -> refresh_entropy_probs == 0 ) {vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;}if ( cm -> refresh_alt_ref_frame )  vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_golden_frame )  vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_last_frame )  vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( * size > 0 ) {","if ( cpi -> temporal_layer_id >= 0 ) {memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_alt_ref_frame ) vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_golden_frame ) vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( cm -> refresh_last_frame ) vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;if ( * size > 0 ) {",2554
105,"int y_samples = orig -> y_height * orig -> y_width ;int uv_samples = orig -> uv_height * orig -> uv_width ;int t_samples = y_samples + 2 * uv_samples ;double sq_error , sq_error2 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;","unsigned int y_width = cpi -> common . Width ;unsigned int y_height = cpi -> common . Height ;unsigned int uv_width = ( y_width + 1 ) / 2 ;unsigned int uv_height = ( y_height + 1 ) / 2 ;int y_samples = orig -> y_height * orig -> y_width ;int uv_samples = orig -> uv_height * orig -> uv_width ;int t_samples = y_samples + 2 * uv_samples ;double sq_error , sq_error2 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;",2554
106,"double frame_psnr2 , frame_ssim2 = 0 ;double weight = 0 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride ,  pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride ,   pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;","double frame_psnr2 , frame_ssim2 = 0 ;double weight = 0 ;ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , y_width , y_height ) ;ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , uv_width , uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> u_buffer , pp -> uv_stride , uv_width , uv_height ) ;ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;",2554
107,"frame_ssim2 = vp8_calc_ssim ( cpi -> Source ,   & cm -> post_proc_buffer , 1 , & weight ) ;cpi -> summed_quality += frame_ssim2 * weight ;","frame_ssim2 = vpx_calc_ssim ( cpi -> Source , & cm -> post_proc_buffer , & weight ) ;cpi -> summed_quality += frame_ssim2 * weight ;",2554
108,"frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show ,  & y , & u , & v ) ;","frame_all = vpx_calc_ssimg ( cpi -> Source , cm -> frame_to_show , & y , & u , & v ) ;",2554
109,# endif # endif  # if HAVE_NEON  # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif {vp8_pop_neon ( store_reg ) ;}# endif cpi -> common . error . setjmp = 0 ;,# endif # endif cpi -> common . error . setjmp = 0 ;,2554
110,"( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;page_geometry = DestroyString ( page_geometry ) ;image = DestroyImage ( image ) ;",2555
111,"if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) )  return cid ;cid ++ )  if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) )  return cid ;","if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) return cid ;cid ++ ) if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) return cid ;",2556
112,exit ( - 1 ) ;}exit ( - 1 ) ;}exit ( - 1 ) ;}exit ( - 1 ) ;},exit ( 1 ) ;}exit ( 1 ) ;}exit ( 1 ) ;}exit ( 1 ) ;},2557
113,"struct efx_nic * efx = netdev_priv ( net_dev ) ;if ( ring -> rx_mini_pending || ring -> rx_jumbo_pending || ring -> rx_pending > EFX_MAX_DMAQ_SIZE || ring -> tx_pending > EFX_MAX_DMAQ_SIZE ) return - EINVAL ;if ( ring -> rx_pending < EFX_MIN_RING_SIZE ||  ring -> tx_pending < EFX_MIN_RING_SIZE ) {netif_err ( efx , drv , efx -> net_dev ,  ""TX<S2SV_blank>and<S2SV_blank>RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%ld\\\return efx_realloc_channels ( efx , ring -> rx_pending , ring -> tx_pending ) ;}","struct efx_nic * efx = netdev_priv ( net_dev ) ;u32 txq_entries ;if ( ring -> rx_mini_pending || ring -> rx_jumbo_pending || ring -> rx_pending > EFX_MAX_DMAQ_SIZE || ring -> tx_pending > EFX_MAX_DMAQ_SIZE ) return - EINVAL ;if ( ring -> rx_pending < EFX_RXQ_MIN_ENT ) {netif_err ( efx , drv , efx -> net_dev , ""RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%u\\\txq_entries = max ( ring -> tx_pending , EFX_TXQ_MIN_ENT ( efx ) ) ;if ( txq_entries != ring -> tx_pending ) netif_warn ( efx , drv , efx -> net_dev , ""increasing<S2SV_blank>TX<S2SV_blank>queue<S2SV_blank>size<S2SV_blank>to<S2SV_blank>minimum<S2SV_blank>of<S2SV_blank>%u\\\return efx_realloc_channels ( efx , ring -> rx_pending , txq_entries ) ;}",2558
114,"bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ;}","bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPU_ID ) ;}",2559
115,if ( shdr -> sh_size < 1 ) {return NULL ;,if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return NULL ;,2560
116,if ( header_len > LEVEL_3_MAX_HEADER_LEN ) {return 0 ;,if ( header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header ) ) {return 0 ;,2561
117,image -> columns = image -> rows = 0 ;image -> colors = 0 ;,image -> columns = image -> rows = 0 ;image -> colors = 0 ;,2562
118,if ( BImgBuff )  BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ;;break ;,if ( BImgBuff ) ;break ;,2562
119,"void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi )  {__issue_discard_cmd ( sbi , false ) ;__drop_discard_cmd ( sbi ) ;__wait_discard_cmd ( sbi , false ) ;}","void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi , bool umount ) {__issue_discard_cmd ( sbi , ! umount ) ;}",2563
120,"dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\bsg_set_block ( bd , file ) ;","dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\\if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;bsg_set_block ( bd , file ) ;",2564
121,"if ( check_stack_guard_page ( vma , address ) < 0 )  return VM_FAULT_SIGSEGV ;","if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ;if ( check_stack_guard_page ( vma , address ) < 0 ) return VM_FAULT_SIGSEGV ;",2565
122,if ( ! mm )  return 0 ;,if ( ! mm || ! mm -> env_end ) return 0 ;,2566
123,"static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe ,  struct pipe_buffer * buf ) {ref -> ref ++ ;}","static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {if ( ref -> ref > INT_MAX / 2 ) return false ;ref -> ref ++ ;return true ;}",2567
124,"cork -> length += length ;if ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;if ( proto == IPPROTO_UDP &&  ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {}if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ;","if ( ( length > mtu ) {int proto = sk -> sk_protocol ;if ( dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || proto == IPPROTO_RAW ) ) {ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ;skb = skb_peek_tail ( & sk -> sk_write_queue ) ;cork -> length += length ;if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) {if ( ! skb ) goto alloc_new_skb ;",2568
125,INST_HANDLER ( sts ) {int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,INST_HANDLER ( sts ) {if ( len < 4 ) {return ;}int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,2569
126,if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) )  if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;,"if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;",2570
127,"return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}","switch ( msr -> index ) {case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ;break ;case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ;}return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}",2571
128,"char file [ PATH_MAX ] ;strlcat ( info -> path , ""maps"" , sizeof ( info -> path ) ) ;while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%s<S2SV_blank>%ld<S2SV_blank>%s\\\","char file [ 1024 ] ;strlcat ( info -> path , ""maps"" , sizeof ( info -> path ) ) ;while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%5s<S2SV_blank>%ld<S2SV_blank>%1023s\\\",2572
129,"int is_pdf ;char * header ;header = get_header ( fp ) ;if ( header && strstr ( header , ""%PDF-"" ) )  is_pdf = 1 ;else is_pdf = 0 ;","char * header ;if ( ! ( header = get_header ( fp ) ) ) return 0 ;const char * c = strstr ( header , ""%PDF-"" ) ;const int is_pdf = c && ( ( c - header + strlen ( ""%PDF-M.m"" ) ) < 1024 ) ;",2573
130,"uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ;nblks += dblocks ;","uint dblocks = xfs_attr3_rmt_blocks ( mp , valuelen ) ;nblks += dblocks ;",2574
131,"archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC ,   ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;archive_clear_error ( & a -> archive ) ;","const size_t max_write = INT_MAX ;archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;if ( s > max_write ) s = max_write ;archive_clear_error ( & a -> archive ) ;",2575
132,case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE :  case RAPTOR_OPTION_RELATIVE_URIS :  case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case RAPTOR_OPTION_RELATIVE_URIS : case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ;,2576
133,"
",if ( ! str ) return NULL ;,2577
134,"if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) {Py_DECREF ( str ) ;","if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) {Py_DECREF ( str ) ;",2577
135,if ( ( error_code >> 16 ) != 0x8009 )  return WindowsErrorString ( ) ;,if ( ( ( error_code >> 16 ) != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) return WindowsErrorString ( ) ;,2578
136,"case CRYPT_E_NO_TRUSTED_SIGNER :  return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ;","case CRYPT_E_NO_TRUSTED_SIGNER : return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ;case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ;case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ;case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."" ;default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ;",2578
137,"if ( perf_event_overflow ( event , 1 , & data , regs ) )  x86_pmu_stop ( event , 0 ) ;","if ( perf_event_overflow ( event , & data , regs ) ) x86_pmu_stop ( event , 0 ) ;",2579
138,"
","memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;",2580
139,int_fb_list -> int_fb [ i ] . size = min_size ;},int_fb_list -> int_fb [ i ] . size = min_size ;},2580
140,"box -> info = boxinfo ;box -> ops = & boxinfo -> ops ;if ( extlen > 0xffffffffUL ) {jas_eprintf ( ""warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\\extlen = 0xffffffffUL ;}box -> len = extlen ;box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ;}else {box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ;}if ( box -> len != 0 && box -> len < 8 ) {goto error ;}dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ;if ( dataflag ) {if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) {goto error ;}if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) {box -> ops = & jp2_boxinfo_unk . ops ;jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\goto error ;}jas_stream_rewind ( tmpstream ) ;if ( box -> ops -> getdata ) {","box -> info = boxinfo ;box -> ops = & boxinfo -> ops ;jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\\jas_stream_rewind ( tmpstream ) ;box -> ops = & boxinfo -> ops ;if ( box -> ops -> getdata ) {",2581
141,"__evtchn_fifo_handle_events ( cpu , true ) ;return 0 ;","__evtchn_fifo_handle_events ( cpu , NULL ) ;return 0 ;",2582
142,"ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ;if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;return - 1 ;}","ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;",2583
143,"l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;if  ( ! l_current_pi -> include ) {","l_current_pi -> include = 00 ;if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}if ( ! l_current_pi -> include ) {",2584
144,"if ( c == EOF ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}file = ( FILE * ) NULL ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;}length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ;( void ) length ;filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ;for ( i = 0 ;i < ( ssize_t ) filesize ;i ++ ) {c = ReadBlobByte ( pwp_image ) ;if ( c == EOF ) break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",2585
145,"if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {ret = key -> type -> instantiate ( key , prep ) ;set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;","if ( key -> state == KEY_IS_UNINSTANTIATED ) {ret = key -> type -> instantiate ( key , prep ) ;mark_key_instantiated ( key , 0 ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;",2586
146,"const int sb_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;int min_log2 = 0 , max_log2 = 0 ;while ( ( sb_cols >> max_log2 ) >= MIN_TILE_WIDTH_B64 ) ++ max_log2 ;-- max_log2 ;if ( max_log2 < 0 ) max_log2 = 0 ;while ( ( MAX_TILE_WIDTH_B64 << min_log2 ) < sb_cols ) ++ min_log2 ;assert ( min_log2 <= max_log2 ) ;* min_log2_tile_cols = min_log2 ;* max_log2_tile_cols = max_log2 ;}",const int sb64_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;* min_log2_tile_cols = min_log2 ;* max_log2_tile_cols = get_max_log2_tile_cols ( sb64_cols ) ;assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) ;},2587
147,"if ( lf -> last_sharpness_level != lf -> sharpness_level ) {update_sharpness ( lfi , lf -> sharpness_level ) ;lf -> last_sharpness_level = lf -> sharpness_level ;}for ( seg_id = 0 ;seg_id < MAX_SEGMENTS ;seg_id ++ ) {int lvl_seg = default_filt_lvl ;if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) {const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ;lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ;vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ;}","if ( segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) {const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ;lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ;vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ;}",2588
148,"dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;","err = dev_get_valid_name ( net , dev , name ) ;if ( err ) goto err_free_dev ;dev_net_set ( dev , net ) ;dev -> rtnl_link_ops = & tun_link_ops ;",2589
149,"ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;","unsigned long eip ;rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;rc = assign_eip_near ( ctxt , eip ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;",2590
150,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,2591
151,"if ( size > INT_MAX )  size = INT_MAX ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;","if ( size > INT_MAX ) size = INT_MAX ;if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;",2592
152,"if ( attr >= 0 ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;","if ( attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;",2593
153,"n = r -> iov . iov_len / 512 ;if ( n ) {qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ;","n = r -> qiov . size / 512 ;if ( n ) {bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ;",2594
154,"case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices ,  src_devid , NULL , NULL ) ;dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID ,  NULL , NULL ) ;if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) {","case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED : case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED : dev_replace -> srcdev = btrfs_find_device ( fs_info -> fs_devices , src_devid , NULL , NULL , true ) ;dev_replace -> tgtdev = btrfs_find_device ( fs_info -> fs_devices , BTRFS_DEV_REPLACE_DEVID , NULL , NULL , true ) ;if ( ! dev_replace -> srcdev && ! btrfs_test_opt ( fs_info , DEGRADED ) ) {",2595
155,"
","if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) {al = SSL_AD_UNEXPECTED_MESSAGE ;SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ;goto f_err ;}",2596
156,if ( ( rsa = RSA_new ( ) ) == NULL )  {,if ( ( rsa = RSA_new ( ) ) == NULL ) {,2596
157,if ( header_len > LEVEL_3_MAX_HEADER_LEN ) {return 0 ;,if ( header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header ) ) {return 0 ;,2597
158,crypto_free_skcipher ( private ) ;},struct skcipher_tfm * tfm = private ;crypto_free_skcipher ( tfm -> skcipher ) ;kfree ( tfm ) ;},2598
159,"static void restore_context ( VP9_COMP * cpi , int mi_row , int mi_col ,  ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;","static void restore_context ( MACROBLOCK * const x , int mi_row , int mi_col , ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) {MACROBLOCKD * const xd = & x -> e_mbd ;",2599
160,"vpx_memcpy (  xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;vpx_memcpy (  xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;vpx_memcpy ( xd -> above_seg_context + mi_col , sa ,  sizeof ( * xd -> above_seg_context ) * mi_width ) ;vpx_memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl ,  sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;","memcpy ( xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ;memcpy ( xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ;memcpy ( xd -> above_seg_context + mi_col , sa , sizeof ( * xd -> above_seg_context ) * mi_width ) ;memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl , sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ;",2599
161,ND_TCHECK ( dp [ 0 ] ) ;,ND_TCHECK ( dp [ 4 ] ) ;,2600
162,"ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;dp += 3 ;ND_TCHECK ( dp [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( dp ) ) ) ) ;","ND_TCHECK ( dp [ 2 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>(%u)<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%"" PRIu64 , EXTRACT_32BITS ( & dp [ 4 ] ) , EXTRACT_32BITS ( & dp [ 2 ] ) , EXTRACT_64BITS ( & dp [ 0 ] ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] ) ) ) ) ;",2600
163,"case BSD_AFNUM_ISO :  isoclns_print ( ndo , p , length , caplen ) ;break ;","case BSD_AFNUM_ISO : isoclns_print ( ndo , p , length , caplen ) ;break ;",2601
164,# endif  if ( name == NULL ) {spacePop ( ctxt ) ;,# endif if ( ctxt -> instate == XML_PARSER_EOF ) return ;if ( name == NULL ) {spacePop ( ctxt ) ;,2602
165,"
",hdr -> sadb_msg_reserved = 0 ;,2603
166,"pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;","pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;",2603
167,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\\",2604
168,"if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}","if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}",2605
169,assert ( dev -> lintr . pin > 0 ) ;pthread_mutex_lock ( & dev -> lintr . lock ) ;,"if ( dev -> lintr . pin <= 0 ) {pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\\return ;}pthread_mutex_lock ( & dev -> lintr . lock ) ;",2606
170,"( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;geometry = DestroyString ( geometry ) ;image = DestroyImage ( image ) ;",2607
171,"ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , "")"" ) ) ;}ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK :  ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;","ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;atmarp_tpaddr_print ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ;if ( ATMTHRD_LEN ( ap ) != 0 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;break ;case ARPOP_REPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ""at<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""for<S2SV_blank>"" ) ) ;atmarp_spaddr_print ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;case ARPOP_NAK : ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ;break ;",2608
172,if ( ! ext_dp -> icmp_length ) {vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . len = hlen ;hlen -= 4 ;obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;,"if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) {vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) {}vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ;vec [ 0 ] . len = hlen ;hlen -= 4 ;obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ;",2609
173,"void show_object_with_name ( FILE * out , struct object * obj ,  struct strbuf * path , const char * component )  {fputc ( \'\\\free ( name ) ;}","void show_object_with_name ( FILE * out , struct object * obj , const char * component ) {}",2610
174,usleep ( us_delay ) ;pthread_mutex_unlock ( & out -> common . lock ) ;,TEMP_FAILURE_RETRY ( usleep ( us_delay ) ) ;pthread_mutex_unlock ( & out -> common . lock ) ;,2611
175,"int err ;if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {struct frag_hdr fhdr ;skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;skb -> ip_summed = CHECKSUM_PARTIAL ;skb -> csum = 0 ;__skb_queue_tail ( & sk -> sk_write_queue , skb ) ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;","struct frag_hdr fhdr ;int err ;if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) {skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ;skb -> csum = 0 ;__skb_queue_tail ( & sk -> sk_write_queue , skb ) ;}else if ( skb_is_gso ( skb ) ) {goto append ;}skb -> ip_summed = CHECKSUM_PARTIAL ;append : return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",2612
176,"else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ;}}ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ;if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;","ND_TCHECK ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ;",2613
177,"if ( dp -> icmp6_data16 [ 1 ] & 0xc0 )  ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 )  ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x40 )  ND_PRINT ( ( ndo , ""O"" ) ) ;","if ( dp -> icmp6_data16 [ 1 ] ) ;if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ;if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;",2613
178,PureFileInfo * r ;int d ;,PureFileInfo * r ;char * alloca_subdir ;size_t sizeof_subdir ;int d ;,2614
179,"
",sizeof_subdir = PATH_MAX + 1U ;if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) {goto toomany ;},2614
180,"listfile ( s , NULL ) ;}else {d = listfile ( s , NULL ) ;}}if ( ! d ) {s -> name_offset = ( size_t ) - 1 ;}s ++ ;}outputfiles ( f , tls_fd ) ;r = dir ;while ( opt_R && r != s ) {if ( r -> name_offset != ( size_t ) - 1 && ! chdir ( FI_NAME ( r ) ) ) {char * alloca_subdir ;const size_t sizeof_subdir = PATH_MAX + 1U ;if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) {goto toomany ;}","
",2614
181,nolist :  ALLOCA_FREE ( alloca_subdir ) ;if ( matches >= max_ls_files ) {,nolist : ALLOCA_FREE ( alloca_subdir ) ;if ( matches >= max_ls_files ) {,2614
182,toomany :  free ( names ) ;free ( dir ) ;,toomany : ALLOCA_FREE ( alloca_subdir ) ;free ( names ) ;free ( dir ) ;,2614
183,"
","if ( getenv ( ""HASHSEED"" ) ) json_object_seed ( getenv_int ( ""HASHSEED"" ) ) ;",2615
184,"if ( getenv_int ( ""STRIP"" ) ) {size_t size = 0 , used = 0 ;","if ( getenv_int ( ""STRIP"" ) ) {size_t size = 0 , used = 0 ;",2615
185,"oe_errno = 0 ;if ( ! sock )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen )  addrlen_in = * addrlen ;if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd ,  ( struct oe_sockaddr * ) addr ,  addrlen_in ,  addrlen ) != OE_OK )  {done :  return ret ;","oe_socklen_t addrlen_out = 0 ;oe_errno = 0 ;if ( oe_syscall_getsockname_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , addrlen ) != OE_OK ) {if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ;done : return ret ;",2616
186,err = - EFAULT ;goto out ;}if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) {u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR :  case PSR_AA32_MODE_FIQ :  case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND :  case PSR_MODE_EL0t :  case PSR_MODE_EL1t :  case PSR_MODE_EL1h :  break ;,u64 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ;break ;case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;,2617
187,return ret ;},goto out_controller_put ;},2618
188,for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ;for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,2619
189,if ( unix_sock_count ) {for ( i = scm -> fp -> count - 1 ;}return max_level ;,for ( i = scm -> fp -> count - 1 ;return max_level ;,2619
190,register const u_char * ep ;register u_char type ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;,register u_char type ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;,2620
191,"
",if ( len < 8 ) goto trunc ;{,2620
192,"case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK :  if ( ndo -> ndo_vflag )  pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;break ;}","case PIMV1_TYPE_JOIN_PRUNE : case PIMV1_TYPE_GRAFT : case PIMV1_TYPE_GRAFT_ACK : if ( ndo -> ndo_vflag ) pimv1_join_prune_print ( ndo , & bp [ 8 ] , len - 8 ) ;}break ;}",2620
193,"if ( offset != 0 )  csum = csum_sub ( csum ,  csum_partial ( skb_transport_header ( skb ) + tlen ,   offset , 0 ) ) ;put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;","if ( offset != 0 ) {int tend_off = skb_transport_offset ( skb ) + tlen ;csum = csum_sub ( csum , skb_checksum ( skb , tend_off , offset , 0 ) ) ;}put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ;",2621
194,"int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {","int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",2622
195,int max_bytes_matched = input_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,int max_bytes_matched ;max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size ;input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ;,2622
196,"set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;","set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ;set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ;set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ;",2623
197,"file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ;if ( ! file ) return - ENOMEM ;","file = kzalloc ( sizeof ( * file ) , GFP_NOIO ) ;if ( ! file ) return - ENOMEM ;",2624
198,# endif  if ( ( user = getpwnam ( username ) ) == NULL ) {,# endif char * crypt_password ;if ( ( user = getpwnam ( username ) ) == NULL ) {,2625
199,"# endif  if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 )  {","# endif crypt_password = crypt ( password , user_password ) ;if ( crypt_password == NULL ) {pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ;return - 1 ;}if ( strcmp ( user_password , crypt_password ) != 0 ) {",2625
200,"if ( atomic_dec_and_test ( & ucounts -> count ) ) {spin_lock_irqsave ( & ucounts_lock , flags ) ;hlist_del_init ( & ucounts -> node ) ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;}","spin_lock_irqsave ( & ucounts_lock , flags ) ;ucounts -> count -= 1 ;if ( ! ucounts -> count ) hlist_del_init ( & ucounts -> node ) ;else ucounts = NULL ;spin_unlock_irqrestore ( & ucounts_lock , flags ) ;",2626
201,"
",if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;,2627
202,length += len ;},length += len ;},2627
203,if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) )  {,"( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) {",2628
204,}read_lock ( & tasklist_lock ) ;,}if ( pid == INT_MIN ) return - ESRCH ;read_lock ( & tasklist_lock ) ;,2629
205,free ( mem ) ;},if ( mem ) {free ( mem ) ;mem = NULL ;}return ;},2630
206,"size_t ld ;const char * data = luaL_checklstring ( L , 2 , & ld ) ;size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ;int n = 0 ;size_t size = optsize ( L , opt , & fmt ) ;pos += gettoalign ( pos , & h , opt , size ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;","luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ;pos -- ;int n = 0 ;size_t size = optsize ( L , size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;",2631
207,"if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 )  {","if ( TEMP_FAILURE_RETRY ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) ) == - 1 ) {",2632
208,"bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ;if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\\free ( bin -> dyld_info ) ;return false ;","bin -> dyld_info = calloc ( 1 , sizeof ( struct dyld_info_command ) ) ;if ( bin -> dyld_info ) {if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) {bprintf ( ""Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\\R_FREE ( bin -> dyld_info ) ;return false ;",2633
209,"break ;case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ;","}break ;case LC_CODE_SIGNATURE : parse_signature ( bin , off ) ;",2633
210,"COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;f = FS_FOpenFileWrite ( filename ) ;","COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ;if ( ! COM_CompareExtension ( filename , "".txt"" ) ) {Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".txt\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;}f = FS_FOpenFileWrite ( filename ) ;",2634
211,"else {vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",2635
212,"unix_state_double_unlock ( sk , other ) ;if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ;","unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;unix_state_double_unlock ( sk , other ) ;if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ;",2636
213,"void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( get_bit ( fin ) ) {","void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset , int maxoffset ) {bloc = * offset ;while ( node && node -> symbol == INTERNAL_NODE ) {if ( bloc >= maxoffset ) {* ch = 0 ;* offset = maxoffset + 1 ;return ;}if ( get_bit ( fin ) ) {",2637
214,if ( ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,if ( ctx -> terminated || ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;,2638
215,if ( enable_apicv ) {for ( msr = 0x800 ;,for ( msr = 0x800 ;,2639
216,}if ( enable_ept ) {,if ( enable_ept ) {,2639
217,"state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;if ( ! state -> frame [ 0 ] ) {init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ;for ( ;;) {struct bpf_insn * insn ;u8 class ;int err ;if ( env -> insn_idx >= insn_cnt ) {verbose ( env , ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\\verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\\return - E2BIG ;}err = is_state_visited ( env , env -> insn_idx ) ;if ( do_print_state )  verbose ( env , ""\\\else verbose ( env , ""%d:<S2SV_blank>safe\\\","state -> speculative = false ;state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ;if ( ! state -> frame [ 0 ] ) {init_func_state ( env , ""\\\verbose ( env , ""\\\if ( do_print_state ) verbose ( env , ""\\\else verbose ( env , ""%d:<S2SV_blank>safe\\\",2640
218,"else  verbose ( env , ""\\\print_verifier_state ( env , state -> frame [ state -> curframe ] ) ;","else verbose ( env , ""\\\print_verifier_state ( env , state -> frame [ state -> curframe ] ) ;",2640
219,"if ( in ) {dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;dev -> out_pipe = usb_sndbulkpipe ( udev ,  out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;}if ( iso_in ) {","if ( in ) dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ;if ( iso_in ) {",2641
220,if ( flags & MSG_OOB )  goto out ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,if ( flags & MSG_OOB ) goto out ;,2642
221,"}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",2642
222,case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ;case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE |  VM_SHARED | VM_MAYSHARE |  VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ;,case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE | VM_NO_THP ) ) return - EINVAL ;case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE | VM_NO_THP ) ) return - EINVAL ;,2643
223,"
",mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;,2644
224,ops -> destroy ( dev ) ;mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;,ops -> destroy ( dev ) ;,2644
225,"if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) )  return FALSE ;","flatpak_bwrap_envp_to_args ( bwrap ) ;if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) ) return FALSE ;",2645
226,"if ( ! g_spawn_async ( NULL ,  ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ;","g_assert ( bwrap -> envp != NULL ) ;g_assert ( bwrap -> envp [ 0 ] == NULL ) ;if ( ! g_spawn_async ( NULL , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp , spawn_flags , flatpak_bwrap_child_setup_cb , bwrap -> fds , & child_pid , error ) ) return FALSE ;",2645
227,"if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 )  {","g_assert ( bwrap -> envp != NULL ) ;g_assert ( bwrap -> envp [ 0 ] == NULL ) ;if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) {",2645
228,"record_and_restart ( event , val , regs , nmi ) ;}","record_and_restart ( event , val , regs ) ;}",2646
229,"static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {","static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2647
230,if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;,if ( ! new_buffer ) {pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,2648
231,if ( ! new_buffer )   return AVERROR ( ENOMEM ) ;pc -> buffer = new_buffer ;,if ( ! new_buffer ) {pc -> overread_index = pc -> index = 0 ;return AVERROR ( ENOMEM ) ;}pc -> buffer = new_buffer ;,2648
232,"struct fsnotify_group * group ;struct user_struct * user ;user = get_current_user ( ) ;if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) {ret = - EMFILE ;}group = inotify_new_group ( user , inotify_max_queued_events ) ;if ( IS_ERR ( group ) ) {ret = PTR_ERR ( group ) ;goto out_free_uid ;if ( ret >= 0 )  return ret ;fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;","struct fsnotify_group * group ;group = inotify_new_group ( user , inotify_max_queued_events ) ;if ( IS_ERR ( group ) ) {ret = PTR_ERR ( group ) ;if ( ret < 0 ) fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;",2649
233,"static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile ,  vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ,  int mi_row , int mi_col ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;MODE_INFO * m ;set_mi_row_col ( xd , tile ,  mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ;write_mb_modes_kf ( cpi , xd -> mi , w ) ;}pack_mb_tokens ( w , tok , tok_end ) ;}","static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile , vpx_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const tok_end , int mi_row , int mi_col ) {const VP9_COMMON * const cm = & cpi -> td . common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;MODE_INFO * m ;cpi -> td . mb . mbmi_ext = cpi -> td . mb . mbmi_ext_base + ( mi_row * cm -> mi_cols + mi_col ) ;set_mi_row_col ( xd , tile , mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ;write_mb_modes_kf ( cm , xd , xd -> mi , w ) ;}pack_mb_tokens ( w , tok , tok_end , cm -> bit_depth ) ;}",2650
234,"mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\\if ( table -> total == table -> max ) {","if ( free < 0 ) {err = - ENOMEM ;goto out ;}mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\\if ( table -> total == table -> max ) {",2651
235,aof_fsync ( server . appendfd ) ;if ( server . vm_enabled ) unlink ( server . vm_swap_file ) ;,aof_fsync ( server . appendfd ) ;,2652
236,ACCESS_MASK access = FILE_READ_ATTRIBUTES ;,"size_t devicePathLen = 0 ;if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\\\\\Device\\\\\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) {byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ;if ( ! readBuffer ) {Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ;Irp -> IoStatus . Information = 0 ;}else {Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;break ;}",2653
237,"
",if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) {,2653
238,"
",Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ;Irp -> IoStatus . Information = 0 ;}TCfree ( readBuffer ) ;}}else {,2653
239,"byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) )  break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer ,  sizeof ( readBuffer ) ,  & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) )  {","byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ;if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) break ;EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ;offset . QuadPart = 0 ;ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , sizeof ( readBuffer ) , & offset , NULL ) ;if ( NT_SUCCESS ( ntStatus ) ) {",2653
240,Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},Irp -> IoStatus . Status = ntStatus ;Irp -> IoStatus . Information = 0 ;},2653
241,fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,fh16 [ 3 ] = 0 ;fh32 [ 2 ] = inode -> i_generation ;if ( parent ) {,2654
242,int err ;if ( rt ) return 0 ;daddr = inet -> inet_daddr ;if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;,struct ip_options_rcu * inet_opt ;int err ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;rcu_read_unlock ( ) ;,2655
243,"static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type ,  u32 * mask ) {if ( IS_ERR ( algt ) )  return ;if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) )  * type |= CRYPTO_ALG_INTERNAL ;if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) )  * mask |= CRYPTO_ALG_INTERNAL ;","static inline bool mcryptd_check_internal ( struct rtattr * * tb , u32 * type , u32 * mask ) {if ( IS_ERR ( algt ) ) return false ;* type |= algt -> type & CRYPTO_ALG_INTERNAL ;* mask |= algt -> mask & CRYPTO_ALG_INTERNAL ;if ( * type & * mask & CRYPTO_ALG_INTERNAL ) return true ;else return false ;",2656
244,"priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;","if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) {dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\\return - ENODEV ;}priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ;if ( ! priv ) return - ENOMEM ;",2657
245,"int yy , mm , dd , hr , min , sec , csec ;guint pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line ,  ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;","int yy , mm , dd , hr , min , sec , csec , pkt_len ;if ( sscanf ( line , ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) {num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;",2658
246,"num_items_scanned = sscanf ( line ,  ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" ,  direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}","num_items_scanned = sscanf ( line , ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ;yy = mm = dd = hr = min = sec = csec = 0 ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;}",2658
247,ND_TCHECK ( dp -> ip6f_offlg ) ;if ( ndo -> ndo_vflag ) {,ND_TCHECK ( * dp ) ;if ( ndo -> ndo_vflag ) {,2659
248,"ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" ,  ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ;","if ( length < 2 ) {ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ;return ;}if ( ! ND_TTEST_16BITS ( p ) ) {ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ;return ;}ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , ""none"" , * p & 0xc0 ) , length ) ) ;",2660
249,"return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ;}","return vpx_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ;}",2661
250,"if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ;__TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ;if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ;th = ( const struct tcphdr * ) skb -> data ;if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ;if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ;if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ;th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ;if ( ! sk ) goto no_tcp_socket ;process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ;if ( sk -> sk_state == TCP_NEW_SYN_RECV ) {struct request_sock * req = inet_reqsk ( sk ) ;struct sock * nsk ;sk = req -> rsk_listener ;tcp_v6_fill_cb ( skb , hdr , th ) ;if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) {","if ( tcp_filter ( sk , skb ) ) {",2662
251,"if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;skb -> dev = NULL ;","th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;if ( sk_filter ( sk , skb ) ) goto discard_and_relse ;skb -> dev = NULL ;",2662
252,if ( keyring ) {,if ( keyring && link_ret == 0 ) {,2663
253,"if ( keyring )  __key_link_end ( keyring , & key -> index_key , edit ) ;","if ( keyring ) __key_link_end ( keyring , & key -> index_key , edit ) ;",2663
254,"av_cold void ff_mpv_idct_init ( MpegEncContext * s )  {ff_idctdsp_init ( & s -> idsp , s -> avctx ) ;","av_cold void ff_mpv_idct_init ( MpegEncContext * s ) {if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;ff_idctdsp_init ( & s -> idsp , s -> avctx ) ;",2664
255,numSamples = pWTIntFrame -> numSamples ;pOutputBuffer = pWTIntFrame -> pAudioBuffer ;,"numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pOutputBuffer = pWTIntFrame -> pAudioBuffer ;",2665
256,"split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ;err = ext4_split_extent_at ( handle , inode , path ,  map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ;split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?  EXT4_EXT_MAY_ZEROOUT : 0 ;","split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ;if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ;err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ;split_flag1 = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) ;",2666
257,user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) return ERR_PTR ( - ENOMEM ) ;,if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;user = key_user_lookup ( current_fsuid ( ) ) ;if ( ! user ) return ERR_PTR ( - ENOMEM ) ;,2667
258,"BIO * cmsbio = NULL , * tmpin = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;","BIO * cmsbio = NULL , * tmpin = NULL , * tmpout = NULL ;if ( ! dcont && ! check_content ( cms ) ) return 0 ;",2668
259,"cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) )  goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {","if ( ! ( flags & SMIME_BINARY ) && dcont ) {tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ;goto err ;}cmsbio = CMS_dataInit ( cms , tmpout ) ;if ( ! cmsbio ) goto err ;}SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ;if ( flags & CMS_TEXT ) {if ( ! SMIME_text ( tmpout , out ) ) {CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ;goto err ;}}}else {cmsbio = CMS_dataInit ( cms , tmpin ) ;if ( ! cmsbio ) goto err ;if ( ! cms_copy_content ( out , cmsbio , flags ) ) goto err ;if ( ! ( flags & CMS_NO_CONTENT_VERIFY ) ) {",2668
260,"err :  if ( dcont && ( tmpin == dcont ) )  do_free_upto ( cmsbio , dcont ) ;if ( cms_certs )  sk_X509_pop_free ( cms_certs , X509_free ) ;","err : if ( ! ( flags & SMIME_BINARY ) && dcont ) {do_free_upto ( cmsbio , tmpout ) ;if ( tmpin != dcont ) BIO_free ( tmpin ) ;}else {if ( dcont && ( tmpin == dcont ) ) do_free_upto ( cmsbio , dcont ) ;}if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;if ( cms_certs ) sk_X509_pop_free ( cms_certs , X509_free ) ;",2668
261,"__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;","memset ( & t , 0 , sizeof ( t ) ) ;__ip_vs_get_timeouts ( net , & t ) ;if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ;",2669
262,"if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h )   ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;}return res ;","int force_key = 0 ;if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) {if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ;if ( ! valid_ref_frame_size ( ctx -> cfg . g_w , ctx -> cfg . g_h , cfg -> g_w , cfg -> g_h ) || ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) force_key = 1 ;}if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( ""Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames"" ) ;force_key |= ctx -> cpi -> common . profile != ctx -> oxcf . profile ;vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;}if ( force_key ) ctx -> next_frame_flags |= VPX_EFLAG_FORCE_KF ;return res ;",2670
263,"fp -> protocol = altsd -> bInterfaceProtocol ;if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ;","if ( altsd -> bNumEndpoints < 1 ) {kfree ( fp ) ;kfree ( rate_table ) ;return - EINVAL ;}fp -> protocol = altsd -> bInterfaceProtocol ;if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ;",2671
264,if ( pkt == NULL )  continue ;,"
",2672
265,int err = - EINVAL ;if ( ! kcontrol ) return err ;,unsigned int count ;int err = - EINVAL ;if ( ! kcontrol ) return err ;,2673
266,"up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",2673
267,while ( c ) {++ i ;c = c -> next ;}return i ;,"+ i ;while ( c ) i ++ , c = c -> next ;}return i ;",2674
268,time_t then ;then = 0 ;,time_t then ;if ( strlen ( stamp ) != 2 ) return SRS_ETIMESTAMPOUTOFDATE ;then = 0 ;,2675
269,"xmlNode *   crm_recv_remote_msg ( void * session , gboolean encrypted )  {char * reply = NULL ;xmlNode * xml = NULL ;if ( encrypted ) {# ifdef HAVE_GNUTLS_GNUTLS_H reply = cib_recv_tls ( session ) ;# else CRM_ASSERT ( encrypted == FALSE ) ;# endif }reply = cib_recv_plaintext ( GPOINTER_TO_INT ( session ) ) ;if ( reply == NULL || strlen ( reply ) == 0 ) {crm_trace ( ""Empty<S2SV_blank>reply"" ) ;xml = string2xml ( reply ) ;if ( xml == NULL ) {crm_err ( ""Couldn\\\'t<S2SV_blank>parse:<S2SV_blank>\\\'%.120s\\\'"" , reply ) ;free ( reply ) ;return xml ;","gboolean crm_recv_remote_msg ( void * session , char * * recv_buf , gboolean encrypted , int total_timeout , int * disconnected ) {int ret ;size_t request_len = 0 ;time_t start = time ( NULL ) ;char * raw_request = NULL ;int remaining_timeout = 0 ;if ( ret == 0 ) {crm_err ( ""poll<S2SV_blank>timed<S2SV_blank>out<S2SV_blank>(%d<S2SV_blank>ms)<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>msg"" , remaining_timeout ) ;return FALSE ;}else if ( ret < 0 ) {if ( errno != EINTR ) {crm_debug ( ""poll<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>msg,<S2SV_blank>rc:<S2SV_blank>%d,<S2SV_blank>errno:<S2SV_blank>%d"" , ret , errno ) ;* disconnected = 1 ;return FALSE ;}crm_debug ( ""poll<S2SV_blank>EINTR<S2SV_blank>encountered<S2SV_blank>during<S2SV_blank>poll,<S2SV_blank>retrying"" ) ;}raw_request = crm_recv_remote_raw ( session , encrypted , 0 , & request_len , disconnected ) ;remaining_timeout = remaining_timeout - ( ( time ( NULL ) - start ) * 1000 ) ;if ( ! raw_request ) {crm_debug ( ""Empty<S2SV_blank>msg<S2SV_blank>received<S2SV_blank>after<S2SV_blank>poll"" ) ;continue ;}if ( * recv_buf ) {int old_len = strlen ( * recv_buf ) ;crm_trace ( ""Expanding<S2SV_blank>recv<S2SV_blank>buffer<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d"" , old_len , old_len + request_len ) ;* recv_buf = realloc ( * recv_buf , old_len + request_len + 1 ) ;memcpy ( * recv_buf + old_len , raw_request , request_len ) ;* ( * recv_buf + old_len + request_len ) = \'\\\\0\' ;free ( raw_request ) ;* recv_buf = raw_request ;}if ( strstr ( * recv_buf , REMOTE_MSG_TERMINATOR ) ) {return TRUE ;return FALSE ;",2676
270,"int r , len , group = 0 ;Node * qn ;Node * * tp ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term )  goto end_of_token ;switch ( tok -> type ) {","int r , len , group ;Node * qn ;Node * * tp ;unsigned int parse_depth ;group = 0 ;* np = NULL ;if ( tok -> type == ( enum TokenSyms ) term ) goto end_of_token ;parse_depth = env -> parse_depth ;switch ( tok -> type ) {",2677
271,"qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper ,  r == TK_INTERVAL ) ;","parse_depth ++ ;if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , r == TK_INTERVAL ) ;",2677
272,"if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || PROTO_LEN ( ap ) != 4 || HRD_LEN ( ap ) == 0 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s<S2SV_blank>(len<S2SV_blank>%u),<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , HRD_LEN ( ap ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , PROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" ,  ipaddr_string ( ndo , SPA ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_INVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;","if ( ! ND_TTEST2 ( * TPA ( ap ) , PROTO_LEN ( ap ) ) ) {ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;tpaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;spaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;tpaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_INVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;spaddr_print_ip ( ndo , ap , pro ) ;",2678
273,"
","if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;",2679
274,break ;},break ;},2679
275,if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal )  return 0 ;,if ( ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS ) ) return 0 ;,2680
276,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;",2681
277,"if ( ! proc_parse_options ( options , ns ) ) {deactivate_locked_super ( sb ) ;","sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;if ( ! proc_parse_options ( options , ns ) ) {deactivate_locked_super ( sb ) ;",2682
278,"if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp ,  SSL_USE_ETM ( s ) ) ) {SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ;","if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp , s -> tlsext_use_etm ) ) {SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ;",2683
279,"ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ;",2684
280,"skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {msg -> msg_namelen = 0 ;copied = skb -> len ;","msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {copied = skb -> len ;",2685
281,"static bool tailmatch ( const char * little , const char * bigone )  {size_t littlelen = strlen ( little ) ;size_t biglen = strlen ( bigone ) ;if ( littlelen > biglen )  return FALSE ;return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;}","static bool tailmatch ( const char * cooke_domain , const char * bigone ) {size_t cookie_domain_len = strlen ( little ) ;size_t hostname_len = strlen ( bigone ) ;if ( hostname_len < cookie_domain_len ) return FALSE ;return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ;}",2686
282,},seg -> update_map = 0 ;seg -> update_data = 0 ;},2687
283,for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ;for ( i = scm -> fp -> count - 1 ;struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ;,2688
284,if ( unix_sock_count ) {for ( i = scm -> fp -> count - 1 ;}return max_level ;,for ( i = scm -> fp -> count - 1 ;return max_level ;,2688
285,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},2689
286,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,2689
287,}return TRUE ;,source -> id = 0 ;}return TRUE ;,2690
288,"if ( user -> uid_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;","if ( user -> uid_keyring && user -> session_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;",2691
289,"for ( i = 0 ;mechbuf [ i ] ;host = xhash_get ( c2s -> hosts , s -> req_to ) ;","for ( i = 0 ;mechbuf [ i ] ) ;log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf ;host = xhash_get ( c2s -> hosts , s -> req_to ) ;",2692
290,"static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop )  {","static void __evtchn_fifo_handle_events ( unsigned cpu , struct evtchn_loop_ctrl * ctrl ) {",2693
291,"consume_one_event ( cpu , control_block , q , & ready , drop ) ;ready |= xchg ( & control_block -> ready , 0 ) ;","consume_one_event ( cpu , ctrl , control_block , q , & ready ) ;ready |= xchg ( & control_block -> ready , 0 ) ;",2693
292,"# endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX )  if ( spwd && spwd -> sp_expire > 0 &&   ( request -> timestamp / 86400 ) > spwd -> sp_expire ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;","# endif # endif # if defined ( HAVE_GETSPNAM ) && ! defined ( M_UNIX ) if ( spwd && spwd -> sp_lstchg > 0 && spwd -> sp_max >= 0 && ( request -> timestamp / 86400 ) > ( spwd -> sp_lstchg + spwd -> sp_max ) ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;}if ( spwd && spwd -> sp_expire > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire ) {radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ;return RLM_MODULE_REJECT ;",2694
293,dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & ieee80211_dataif_ops ;dev -> destructor = free_netdev ;,2695
294,"case \'l\' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;case \'L\' : {","case \'l\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;}case \'L\' : {",2696
295,"case \'i\' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;","case \'i\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;}case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;",2696
296,"uint8_t i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\switch ( subtype ) {case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\break ;case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\if ( tlv_len < 7 ) {return hexdump ;}sublen = * ( tptr + 6 ) ;if ( tlv_len < 7 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 7 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) {return hexdump ;}sublen = * ( tptr + 4 ) ;if ( tlv_len < 5 + sublen ) {return hexdump ;}ND_PRINT ( ( ndo , ""\\\safeputs ( ndo , tptr + 5 , sublen ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;tval = * ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\for ( i = 0 ;i < NO_OF_BITS ;i ++ ) ND_PRINT ( ( ndo , ""%-2d<S2SV_blank>"" , ( tval >> i ) & 0x01 ) ) ;break ;case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) {return hexdump ;}tval = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\","u_int i ;if ( tlv_len < 4 ) {ND_PRINT ( ( ndo , ""\\\",2697
297,"ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;","ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""Protocol<S2SV_blank>ID:<S2SV_blank>%d"" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ;",2697
298,"futex_wait_queue_me ( hb , & q , to ) ;spin_lock ( & hb -> lock ) ;","if ( match_futex ( & q . key , & key2 ) ) {ret = - EINVAL ;goto out_put_keys ;}futex_wait_queue_me ( hb , & q , to ) ;spin_lock ( & hb -> lock ) ;",2698
299,"if ( ( e -> target_offset == sizeof ( struct ipt_entry ) &&  ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) &&  t -> verdict < 0 && unconditional ( & e -> ip ) ) ||  visited ) {","if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) {",2699
300,"struct {struct ip_options opt ;char data [ 40 ] ;}replyopts ;if ( ip_options_echo ( & replyopts . opt , skb ) )  return ;daddr = ipc . addr = rt -> rt_src ;ipc . opt = NULL ;ipc . tx_flags = 0 ;if ( replyopts . opt . optlen ) {ipc . opt = & replyopts . opt ;if ( ipc . opt -> srr )   daddr = replyopts . opt . faddr ;}",struct ip_options_data replyopts ;if ( replyopts . opt . opt . srr ) daddr = replyopts . opt . opt . faddr ;},2700
301,struct svc_rqst * rqstp = vrqstp ;set_freezable ( ) ;,"struct svc_rqst * rqstp = vrqstp ;struct net * net = & init_net ;struct lockd_net * ln = net_generic ( net , lockd_net_id ) ;set_freezable ( ) ;cancel_delayed_work_sync ( & ln -> grace_period_end ) ;locks_end_grace ( & ln -> lockd_manager ) ;",2701
302,return 0 ;},return 0 ;},2701
303,"cp = ikev1_attrmap_print ( ndo , cp ,  ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;}","cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;if ( cp == NULL ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}",2702
304,"case 16 :  # line 94 ""hex_grammar.y""  {# line 1023 ""hex_grammar.c"" break ;case 17 :  # line 95 ""hex_grammar.y""  {# line 1029 ""hex_grammar.c"" break ;case 18 :  # line 96 ""hex_grammar.y""  {# line 1035 ""hex_grammar.c"" break ;case 19 :  # line 97 ""hex_grammar.y""  {# line 1041 ""hex_grammar.c"" break ;case 21 :  # line 100 ""hex_grammar.y""  {# line 1047 ""hex_grammar.c"" break ;case 22 :  # line 99 ""hex_grammar.y""  {# line 1053 ""hex_grammar.c"" break ;case 23 :  # line 98 ""hex_grammar.y""  {# line 1059 ""hex_grammar.c"" break ;","case 16 : # line 101 ""hex_grammar.y"" {# line 1030 ""hex_grammar.c"" break ;case 17 : # line 102 ""hex_grammar.y"" {# line 1036 ""hex_grammar.c"" break ;case 18 : # line 103 ""hex_grammar.y"" {# line 1042 ""hex_grammar.c"" break ;case 19 : # line 104 ""hex_grammar.y"" {# line 1048 ""hex_grammar.c"" break ;case 21 : # line 107 ""hex_grammar.y"" {# line 1054 ""hex_grammar.c"" break ;case 22 : # line 106 ""hex_grammar.y"" {# line 1060 ""hex_grammar.c"" break ;case 23 : # line 105 ""hex_grammar.y"" {# line 1066 ""hex_grammar.c"" break ;",2703
305,pch -> chan_net = net ;chan -> ppp = pch ;,pch -> chan_net = get_net ( net ) ;chan -> ppp = pch ;,2704
306,image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;image -> rows = ( size_t ) floor floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,2705
307,width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,width = ( size_t ) floor floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;height = ( size_t ) floor floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;,2705
308,width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;,width = ( size_t ) floor floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;,2705
309,"if ( image -> columns == 0 )  image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;if ( image -> columns == 0 )  image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 )  image -> rows = ( size_t ) ( metrics . ascent - metrics . descent +  draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 )  image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;","if ( image -> columns == 0 ) image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ;if ( image -> columns == 0 ) image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 ) image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + draw_info -> stroke_width + 0.5 ) ;if ( image -> rows == 0 ) image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;",2705
310,"
",if ( saio -> offsets && saio -> entry_count ) {,2706
311,"
",saio = NULL ;},2706
312,"
",saiz = NULL ;,2706
313,"offset = saio -> offsets [ 0 ] + moof_offset ;nb_saio = saio -> entry_count ;for ( i = 0 ;saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ;}}","offset = saio -> offsets [ 0 ] + moof_offset ;nb_saio = saio -> entry_count ;for ( i = 0 ;saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ;}}",2706
314,int target = rc -> av_per_frame_bandwidth ;if ( ( cm -> current_video_frame == 0 ) ||  ( cm -> frame_flags & FRAMEFLAGS_KEY ) ||  ( cpi -> oxcf . auto_key && ( rc -> frames_since_key %  cpi -> key_frame_frequency == 0 ) ) ) {cm -> frame_type = KEY_FRAME ;if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {target = calc_iframe_target_size_one_pass_cbr ( cpi ) ;if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) {,"int target = rc -> avg_frame_bandwidth ;const int layer = LAYER_IDS_TO_IDX ( cpi -> svc . spatial_layer_id , cpi -> svc . temporal_layer_id , cpi -> svc . number_temporal_layers ) ;if ( ( cm -> current_video_frame == 0 ) || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) || ( cpi -> oxcf . auto_key && ( rc -> frames_since_key % cpi -> oxcf . key_freq == 0 ) ) ) {cm -> frame_type = KEY_FRAME ;if ( is_two_pass_svc ( cpi ) ) {cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ;cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ;}else if ( is_one_pass_cbr_svc ( cpi ) ) {cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ;reset_temporal_layer_to_zero ( cpi ) ;cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ;target = calc_iframe_target_size_one_pass_cbr ( cpi ) ;if ( is_two_pass_svc ( cpi ) ) {LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ;if ( cpi -> svc . spatial_layer_id == 0 ) {lc -> is_key_frame = 0 ;}else {lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ;if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ;}cpi -> ref_frame_flags &= ( ~ VP9_ALT_FLAG ) ;}else if ( is_one_pass_cbr_svc ( cpi ) ) {LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ;if ( cpi -> svc . spatial_layer_id == 0 ) {lc -> is_key_frame = 0 ;}else {lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ;",2707
315,"if ( used_address && used_address -> name_len == msg_sys -> msg_namelen &&   ! memcmp ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ) {memcpy ( & used_address -> name , msg -> msg_name ,  used_address -> name_len ) ;","if ( used_address && msg_sys -> msg_name && used_address -> name_len == msg_sys -> msg_namelen && ! memcmp ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ) {if ( msg_sys -> msg_name ) memcpy ( & used_address -> name , msg_sys -> msg_name , used_address -> name_len ) ;",2708
316,"static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) {int i , j ;","static void read_mv_probs ( nmv_context * ctx , int allow_hp , vpx_reader * r ) {int i , j ;",2709
317,"commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;query = ( ltxtquery * ) palloc ( commonlen ) ;","if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;commonlen = COMPUTESIZE ( state . num , state . sumlen ) ;query = ( ltxtquery * ) palloc ( commonlen ) ;",2710
318,"send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;}","TEMP_FAILURE_RETRY ( send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ;}",2711
319,case 'n' : * ( buf + insertpos ) = '\\\editpos ++ ;break ;case 't' : * ( buf + insertpos ) = '\\\\t' ;editpos ++ ;break ;case 'r' : * ( buf + insertpos ) = '\\\\r' ;editpos ++ ;break ;case '<S2SV_blank>' : * ( buf + insertpos ) = '<S2SV_blank>' ;editpos ++ ;break ;case '0' : if ( * ( buf + editpos + 2 ) == 'x' ) {if ( ( * ( buf + editpos + 3 ) == '0' && * ( buf + editpos + 4 ) == '0' ) ) {* ( buf + insertpos ) = * ( buf + editpos ) ;}else {* ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,case 'n' : * ( buf + insertpos ) = _x2c ( & buf [ editpos + 3 ] ) ;editpos += 4 ;,2712
320,switch ( sun_info . maptype )  {case RMT_EQUAL_RGB : {,switch ( sun_info . maptype ) {case RMT_NONE : break ;case RMT_EQUAL_RGB : {,2713
321,"static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,   int64_t * dist , int do_recon , int64_t best_rd ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;int i ;BLOCK_SIZE subsize ;int this_rate , sum_rate = 0 , best_rate = INT_MAX ;","static void nonrd_pick_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , RD_COST * rd_cost , int do_recon , int64_t best_rd ) {VP9_COMMON * const cm = & cpi -> common ;TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;int i ;BLOCK_SIZE subsize ;int this_rate , sum_rate = 0 , best_rate = INT_MAX ;",2714
322,"if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index != 0 ) {* rate = 0 ;* dist = 0 ;return ;}}x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;if ( cpi -> sf . auto_min_max_partition_size ) {partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&   bsize >= cpi -> sf . min_partition_size ) ;partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_horz_split ) ;partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&   bsize > cpi -> sf . min_partition_size ) ||  force_vert_split ) ;do_split &= bsize > cpi -> sf . min_partition_size ;}if ( cpi -> sf . use_square_partition_only ) {if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) )  do_split = 0 ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col ,   & this_rate , & this_dist , bsize ) ;ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate != INT_MAX ) {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;if ( sum_rd < best_rd ) {int64_t stop_thresh = 4096 ;int64_t stop_thresh_rd ;best_rate = this_rate ;best_dist = this_dist ;best_rd = sum_rd ;if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ;stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {do_split = 0 ;}if ( ! x -> in_active_map ) {do_split = 0 ;do_rect = 0 ;sum_rd = 0 ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * ms ;* get_sb_index ( x , subsize ) = i ;load_pred_mv ( x , ctx ) ;nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx ,   subsize , & this_rate , & this_dist , 0 ,  best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;","x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;if ( cpi -> sf . auto_min_max_partition_size ) {partition_none_allowed &= ( bsize <= x -> max_partition_size && bsize >= cpi -> sf . min_partition_size ) ;partition_horz_allowed &= ( ( bsize <= x -> max_partition_size && bsize > cpi -> sf . min_partition_size ) || force_horz_split ) ;partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && bsize > x -> min_partition_size ) || force_vert_split ) ;do_split &= bsize > x -> min_partition_size ;}if ( sf -> use_square_partition_only ) {ctx -> pred_pixel_ready = ! ( partition_vert_allowed || partition_horz_allowed || do_split ) ;nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx ) ;ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;ctx -> mbmi_ext = * x -> mbmi_ext ;ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;ctx -> skip = x -> skip ;if ( this_rdc . rate != INT_MAX ) {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ;this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ;if ( this_rdc . rdcost < best_rdc . rdcost ) {int64_t dist_breakout_thr = sf -> partition_search_breakout_dist_thr ;int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ;dist_breakout_thr >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;if ( ! x -> e_mbd . lossless && this_rdc . rate < rate_breakout_thr && this_rdc . dist < dist_breakout_thr ) {do_split = 0 ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * ms ;* get_sb_index ( x , subsize ) = i ;load_pred_mv ( x , ctx ) ;nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , & this_rate , & this_dist , 0 , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;",2714
323,"if ( cpi -> sf . less_rectangular_check )  do_rect &= ! partition_none_allowed ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col ,   & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}","if ( cpi -> sf . less_rectangular_check ) do_rect &= ! partition_none_allowed ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col , & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}",2714
324,"* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms ,   & this_rate , & this_dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}else {int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}}if ( sum_rd < best_rd ) {best_rate = sum_rate ;best_dist = sum_dist ;best_rd = sum_rd ;* ( get_sb_partitioning ( x , bsize ) ) = subsize ;* rate = best_rate ;* dist = best_dist ;if ( best_rate == INT_MAX )  return ;fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize ,  * ( get_sb_partitioning ( x , bsize ) ) ) ;if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {int output_enabled = ( bsize == BLOCK_64X64 ) ;if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ;encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ;}if ( bsize == BLOCK_64X64 ) {assert ( tp_orig < * tp ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;}","* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;nonrd_pick_sb_modes ( cpi , td , tile_data , tp , mi_row , mi_col , output_enabled , bsize ) ;if ( bsize == BLOCK_64X64 && do_recon ) {assert ( tp_orig < * tp ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;",2714
325,"static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , const char * ident , uint16_t afi ) {char ident_buffer [ 20 ] ;uint8_t prefix [ sizeof ( struct in6_addr ) ] ;u_int metric , status_byte , bit_length , byte_length , sublen , processed , subtlvtype , subtlvlen ;if ( ! ND_TTEST2 ( * tptr , 4 ) ) return ( 0 ) ;","static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , 2 ) ) return ( 0 ) ;",2715
326,"if ( ! ND_TTEST2 ( * tptr , 1 ) )  return ( 0 ) ;","if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ;",2715
327,"static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf )  {","static int scsi_disk_emulate_command ( SCSIDiskReq * r ) {uint8_t * outbuf ;if ( ! r -> iov . iov_base ) {if ( req -> cmd . xfer > 65536 ) {goto illegal_request ;}r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ;r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ;}outbuf = r -> iov . iov_base ;",2716
328,while ( FLASH -> SR & ( 1 << 16 ) ) ;flash_unlock ( ) ;if ( FLASH -> CR & ( 1 << 30 ) ) {FLASH -> OPTKEYR = 0x08192A3B ;FLASH -> OPTKEYR = 0x4C5D6E7F ;FLASH -> OPTR = val ;FLASH -> CR |= ( 1 << 17 ) ;while ( FLASH -> SR & ( 1 << 16 ) ) ;flash_lock ( ) ;__enable_irq ( ) ;},FLASH -> CR |= FLASH_CR_OBL_LAUNCH ;while ( true ) ;,2717
329,"size_t val_len ;size_t len , cert_len ;","size_t val_len = 0 ;size_t len , cert_len ;",2718
330,"pipe_buf_get ( ipipe , ibuf ) ;obuf = opipe -> bufs + nbuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}obuf = opipe -> bufs + nbuf ;",2719
331,addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;,"memset ( addr , 0 , sizeof ( * addr ) ) ;addr -> sap_family = AF_ATMPVC ;addr -> sap_addr . itf = vcc -> dev -> number ;",2720
332,"else  rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\","else if ( strcmp ( filetype [ i ] . ext , "".SVG"" ) == 0 ) {rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\if ( strrchr ( file_name , \'/\' ) ) strlcpy ( str , strrchr ( file_name , \'/\' ) + 1 , sizeof ( str ) ) ;else strlcpy ( str , file_name , sizeof ( str ) ) ;if ( str [ 6 ] == \'_\' && str [ 13 ] == \'_\' ) rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\\\""%s\\\\""\\\\r\\\else rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\\\""%s\\\\""\\\\r\\\}else rsprintf ( ""Content-Type:<S2SV_blank>%s\\\\r\\\",2721
333,return ret ;},"if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;return ret ;}",2722
334,"long elements ;elements = parse_iv2 ( ( * p ) + 2 , p ) ;( * p ) += 2 ;if ( ce -> serialize == NULL ) {object_init_ex ( * rval , ce ) ;else {zend_error ( E_WARNING , ""Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\\\'%s\\\'"" , ce -> name ) ;return 0 ;}","long elements ;if ( * p >= max - 2 ) {zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ;return - 1 ;",2723
335,token ++ ;},"token ++ ;}if ( operand >= MAX_OPERANDS ) {eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\\return false ;}",2724
336,void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec )  {,WORD32 impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) {,2725
337,ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ;ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ;},2725
338,},return 0 ;},2725
339,"int row8x8_remaining = tile -> mi_row_end - mi_row ;int col8x8_remaining = tile -> mi_col_end - mi_col ;int block_row , block_col ;","const int row8x8_remaining = tile -> mi_row_end - mi_row ;const int col8x8_remaining = tile -> mi_col_end - mi_col ;int block_row , block_col ;",2726
340,"for ( block_row = 0 ;block_row < MI_BLOCK_SIZE ;block_row += bh ) {for ( block_col = 0 ;block_col < MI_BLOCK_SIZE ;block_col += bw ) {int index = block_row * mis + block_col ;bsize = find_partition_size ( bsize , ( row8x8_remaining - block_row ) , ( col8x8_remaining - block_col ) , & bh , & bw ) ;mi_8x8 [ index ] = mi_upper_left + index ;mi_8x8 [ index ] -> mbmi . sb_type = bsize ;}}","set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , bsize , mi_8x8 ) ;",2726
341,if ( info . si_code >= 0 )   return - EPERM ;info . si_signo = sig ;,if ( info . si_code != SI_QUEUE ) {WARN_ON_ONCE ( info . si_code < 0 ) ;return - EPERM ;}info . si_signo = sig ;,2727
342,"if ( error == NULL ) {issuer_known = TRUE ;if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ;else if ( verify & GNUTLS_CERT_INVALID )  inf_gnutls_certificate_verification_set_error ( & error , verify ) ;}}",}if ( error == NULL ) if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {},2728
343,"return ! inode_capable ( inode , CAP_FOWNER ) ;}","return ! capable_wrt_inode_uidgid ( inode , CAP_FOWNER ) ;}",2729
344,"if ( ( opt_len != mp_dss_len ( mdss , 1 ) &&  opt_len != mp_dss_len ( mdss , 0 ) ) || flags & TH_SYN ) return 0 ;if ( mdss -> flags & MP_DSS_A ) {ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;if ( mdss -> flags & MP_DSS_a ) {ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}}if ( mdss -> flags & MP_DSS_m ) {ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;opt += 2 ;if ( opt_len == mp_dss_len ( mdss , 1 ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ;","if ( opt_len < 4 ) return 0 ;if ( flags & TH_SYN ) return 0 ;opt_len -= 4 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;if ( mdss -> flags & MP_DSS_a ) {if ( opt_len < 8 ) return 0 ;ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;opt_len -= 8 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;opt_len -= 4 ;if ( opt_len < 2 ) return 0 ;opt_len -= 4 ;}}if ( mdss -> flags & MP_DSS_m ) {if ( opt_len < 8 ) return 0 ;ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;opt_len -= 8 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;opt += 2 ;opt_len -= 2 ;if ( opt_len >= 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ;opt_len -= 2 ;}if ( opt_len != 0 ) return 0 ;",2730
345,"fprintf ( fpfile , ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f""  ""%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f"" ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f\\\","fprintf ( fpfile , ""%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf\\\",2731
346,int_fb -> in_use = 0 ;return 0 ;,if ( int_fb ) int_fb -> in_use = 0 ;return 0 ;,2732
347,inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;,"uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",2733
348,if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;},"
",2734
349,"chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;}skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ;chunk -> subh . v = NULL ;if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) {chunk -> singleton = 0 ;}else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;return NULL ;",chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;chunk -> pdiscard = 1 ;chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;,2734
350,err = - EINVAL ;ds = salg -> digestsize ;ss = salg -> statesize ;alg = & salg -> base ;,alg = & salg -> base ;err = - EINVAL ;if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ;ds = salg -> digestsize ;ss = salg -> statesize ;,2735
351,"static void  swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc32 ( tif , cp0 , cc ) ;}","static int swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc32 ( tif , cp0 , cc ) ;}",2736
352,if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) {r = - EINVAL ;,if ( ! kvm_vcpu_compatible ( vcpu ) ) {r = - EINVAL ;goto unlock_vcpu_destroy ;}if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) {r = - EINVAL ;,2737
353,struct cred * cred ;if ( ! ( unshare_flags & CLONE_NEWUSER ) ) return 0 ;cred = prepare_creds ( ) ;if ( ! cred )  return - ENOMEM ;* new_cred = cred ;return create_user_ns ( cred ) ;},struct cred * cred ;int err = - ENOMEM ;if ( cred ) {err = create_user_ns ( cred ) ;if ( err ) put_cred ( cred ) ;else * new_cred = cred ;}return err ;},2738
354,if ( peer ) {if ( ! lsk -> peer_conn_id ) return - ENOTCONN ;,lsa -> l2tp_unused = 0 ;if ( peer ) {if ( ! lsk -> peer_conn_id ) return - ENOTCONN ;,2739
355,if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 &&  rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,if ( * rsize >= 62 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) {,2740
356,int err ;if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ;if ( inet -> opt && inet -> opt -> srr ) {if ( ! daddr ) return - EINVAL ;nexthop = inet -> opt -> faddr ;},"int err ;struct ip_options_rcu * inet_opt ;if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) {if ( ! daddr ) return - EINVAL ;nexthop = inet_opt -> opt . faddr ;}",2741
357,if ( ! inet -> opt || ! inet -> opt -> srr )  daddr = rt -> rt_dst ;if ( ! inet -> inet_saddr ) inet -> inet_saddr = rt -> rt_src ;inet -> inet_rcv_saddr = inet -> inet_saddr ;if ( tp -> rx_opt . ts_recent_stamp && inet -> inet_daddr != daddr ) {tp -> rx_opt . ts_recent = 0 ;tp -> rx_opt . ts_recent_stamp = 0 ;tp -> write_seq = 0 ;}if ( tcp_death_row . sysctl_tw_recycle && ! tp -> rx_opt . ts_recent_stamp && rt -> rt_dst == daddr ) {struct inet_peer * peer = rt_get_peer ( rt ) ;if ( peer ) {inet_peer_refcheck ( peer ) ;if ( ( u32 ) get_seconds ( ) - peer -> tcp_ts_stamp <= TCP_PAWS_MSL ) {tp -> rx_opt . ts_recent_stamp = peer -> tcp_ts_stamp ;tp -> rx_opt . ts_recent = peer -> tcp_ts ;}}}inet -> inet_dport = usin -> sin_port ;inet -> inet_daddr = daddr ;inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;if ( inet -> opt )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ;,if ( ! inet_opt || ! inet_opt -> opt . srr ) daddr = rt -> rt_dst ;if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ;,2741
358,drop_futex_key_refs ( & q -> key ) ;},},2742
359,if ( test_tsk_need_resched ( rq -> curr ) )  rq -> skip_clock_update = 1 ;,if ( rq -> curr -> se . on_rq && test_tsk_need_resched ( rq -> curr ) ) rq -> skip_clock_update = 1 ;,2743
360,"dh_clnt = EVP_PKEY_get0_DH ( ckey ) ;if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) {","if ( ckey == NULL ) {SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ;return 0 ;}dh_clnt = EVP_PKEY_get0_DH ( ckey ) ;if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) {",2744
361,"static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;","static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;",2745
362,"if ( ! in_group_p ( inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  mode &= ~ S_ISGID ;","if ( ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) mode &= ~ S_ISGID ;",2746
363,"int midi_synth_load_patch ( int dev , int format , const char __user * addr ,  int offs , int count , int pmgr_flag )  {","int midi_synth_load_patch ( int dev , int format , const char __user * addr , int count , int pmgr_flag ) {",2747
364,"if ( format != SYSEX_PATCH )  {return - EINVAL ;}if ( count < hdr_size )  {return - EINVAL ;}count -= hdr_size ;if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) )  return - EFAULT ;if ( count < sysex . len )   {sysex . len = count ;}left = sysex . len ;",if ( format != SYSEX_PATCH ) return - EINVAL ;}if ( count < hdr_size ) {return - EINVAL ;if ( count < sysex . len ) {sysex . len = count ;}left = sysex . len ;,2747
365,mk_vhost_close ( sr ) ;},if ( sr -> fd_is_fdt == MK_TRUE ) {mk_vhost_close ( sr ) ;}else {close ( sr -> fd_file ) ;}},2748
366,}pin -> request_count -- ;,rdev -> ena_pin = NULL ;return ;}pin -> request_count -- ;,2749
367,"int chars_processed ;int elt ;int data_size = ndo -> ndo_snapend - bp ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed = 1 ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {","int elt ;u_int offset , max_offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;max_offset = ( u_int ) ( cp - bp ) ;if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) {",2750
368,"cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {","offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ;if ( offset >= max_offset ) {ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ;return ( NULL ) ;}max_offset = offset ;cp = bp + offset ;if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ;chars_processed ++ ;if ( chars_processed >= data_size ) {",2750
369,"chars_processed += l ;ND_PRINT ( ( ndo , ""."" ) ) ;chars_processed ++ ;if ( ! compress ) rp += l + 1 ;","ND_PRINT ( ( ndo , ""."" ) ) ;if ( ! compress ) rp += l + 1 ;",2750
370,if ( ! valid_localpart ( maddr -> user ) ||   ! valid_domainpart ( maddr -> domain ) ) {if ( mailfrom && maddr -> user [ 0 ] == '\\\\0' && maddr -> domain [ 0 ] == '\\\\0' ) return ( 1 ) ;,"if ( mailfrom && maddr -> user [ 0 ] == '\\\\0' && maddr -> domain [ 0 ] == '\\\\0' ) return ( 1 ) ;if ( maddr -> user [ 0 ] == '\\\\0' || ! valid_localpart ( maddr -> user ) ) return ( 0 ) ;if ( maddr -> domain [ 0 ] == '\\\\0' ) {( void ) strlcpy ( maddr -> domain , domain , sizeof ( maddr -> domain ) ) return ( 0 ) ;return ( 1 ) ;",2751
371,"return send ( socket -> fd , buf , count , MSG_DONTWAIT ) ;}","return TEMP_FAILURE_RETRY ( send ( socket -> fd , buf , count , MSG_DONTWAIT ) ) ;}",2752
372,"static int input_stats ( struct twopass_rc * p , FIRSTPASS_STATS * fps ) {if ( p -> stats_in >= p -> stats_in_end ) return EOF ;","static int input_stats ( TWO_PASS * p , FIRSTPASS_STATS * fps ) {if ( p -> stats_in >= p -> stats_in_end ) return EOF ;",2753
373,"# ifdef CONFIG_SWAP  if ( ! file ) {* prev = vma ;force_swapin_readahead ( vma , start , end ) ;* prev = vma ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;# else if ( ! file ) return - EBADF ;# endif if ( IS_DAX ( file_inode ( file ) ) ) {return 0 ;}* prev = vma ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;","* prev = vma ;# ifdef CONFIG_SWAP if ( ! file ) {force_swapin_readahead ( vma , start , end ) ;force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ;start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ;",2754
374,"
","if ( EOFBlob ( image ) != MagickFalse ) {layer_info = DestroyLayerInfo ( layer_info , number_layers ) ;ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ;}",2755
375,"if ( image -> debug != MagickFalse )  ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ;","if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ;",2755
376,"bool __net_get_random_once ( void * buf , int nbytes , bool * done ,  struct static_key * done_key )  {","bool __net_get_random_once ( void * buf , int nbytes , bool * done , struct static_key * once_key ) {",2756
377,__net_random_once_disable_jump ( done_key ) ;return true ;,__net_random_once_disable_jump ( once_key ) ;return true ;,2756
378,"unsigned int var = block_variance ( cpi , x , bs ) ;vp9_clear_system_state ( ) ;energy = 0.9 * ( log ( var + 1.0 ) - 10.0 ) ;","double energy_midpoint ;vpx_clear_system_state ( ) ;energy_midpoint = ( cpi -> oxcf . pass == 2 ) ? cpi -> twopass . mb_av_energy : DEFAULT_E_MIDPOINT ;energy = vp9_log_block_var ( cpi , x , bs ) - energy_midpoint ;",2757
379,"static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2758
380,srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;,"memset ( srose , 0 , msg -> msg_namelen ) ;srose -> srose_family = AF_ROSE ;srose -> srose_addr = rose -> dest_addr ;",2759
381,"static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  {","static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options , uid_t * check_ruid ) {",2760
382,if ( ! options ) {rc = - EINVAL ;,* check_ruid = 0 ;if ( ! options ) {rc = - EINVAL ;,2760
383,"
",case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ;break ;,2760
384,"case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\\","case ecryptfs_opt_err : default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\\",2760
385,"cJSON_AddFloatToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ;cJSON_AddFloatToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ;cJSON_AddFloatToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ;if ( ! test -> sender ) sender_has_retransmits = - 1 ;cJSON_AddIntToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ;if ( test -> role == \'s\' && test -> get_server_output ) {","cJSON_AddNumberToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ;cJSON_AddNumberToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ;cJSON_AddNumberToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ;if ( ! test -> sender ) sender_has_retransmits = - 1 ;cJSON_AddNumberToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ;if ( test -> role == \'s\' && test -> get_server_output ) {",2761
386,"else {cJSON_AddItemToObject ( j , ""streams"" , j_streams ) ;SLIST_FOREACH ( sp , & test -> streams , streams ) {j_stream = cJSON_CreateObject ( ) ;if ( j_stream == NULL ) {i_errno = IEPACKAGERESULTS ;r = - 1 ;}else {cJSON_AddItemToArray ( j_streams , j_stream ) ;bytes_transferred = test -> sender ? sp -> result -> bytes_sent : sp -> result -> bytes_received ;retransmits = ( test -> sender && test -> sender_has_retransmits ) ? sp -> result -> stream_retrans : - 1 ;cJSON_AddIntToObject ( j_stream , ""id"" , sp -> id ) ;cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ;cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ;cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ;cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ;cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ;}","cJSON_AddNumberToObject ( j_stream , ""id"" , sp -> id ) ;cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ;cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ;cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ;cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ;cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ;",2761
387,"memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;","rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ;rinfo [ val ] . req_state = srp -> done + 1 ;",2762
388,err = - EFAULT ;goto out ;}if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) {u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR :  case PSR_AA32_MODE_FIQ :  case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND :  case PSR_MODE_EL0t :  case PSR_MODE_EL1t :  case PSR_MODE_EL1h :  break ;,u64 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ;switch ( mode ) {case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ;break ;case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;break ;,2763
389,"static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ,  int64_t tx_cache [ TX_MODES ] ,  int64_t best_rd ) {MB_PREDICTION_MODE mode ;MB_PREDICTION_MODE mode_selected = DC_PRED ;int i ;int * bmode_costs = x -> mbmode_cost ;if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ;i < TX_MODES ;i ++ ) tx_cache [ i ] = INT64_MAX ;int64_t local_tx_cache [ TX_MODES ] ;MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ;MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;if ( ! ( cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] & ( 1 << mode ) ) ) continue ;if ( cpi -> common . frame_type == KEY_FRAME ) {const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ;const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ;bmode_costs = x -> y_mode_costs [ A ] [ L ] ;}mic -> mbmi . mode = mode ;intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion ,   & s , NULL , bsize , local_tx_cache , best_rd ) ;if ( this_rate_tokenonly == INT_MAX ) continue ;","static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , int64_t best_rd ) {MB_PREDICTION_MODE mode ;MB_PREDICTION_MODE mode_selected = DC_PRED ;int * bmode_costs ;const MODE_INFO * above_mi = xd -> above_mi ;const MODE_INFO * left_mi = xd -> left_mi ;const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ;const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ;bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ;memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ;if ( cpi -> sf . use_nonrd_pick_mode ) {if ( conditional_skipintra ( mode , mode_selected ) ) continue ;if ( * skippable ) break ;}mic -> mbmi . mode = mode ;intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , NULL , bsize , local_tx_cache , best_rd ) ;if ( this_rate_tokenonly == INT_MAX ) continue ;",2764
390,}if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) {for ( i = 0 ;i < TX_MODES && local_tx_cache [ i ] < INT64_MAX ;i ++ ) {const int64_t adj_rd = this_rd + local_tx_cache [ i ] - local_tx_cache [ cpi -> common . tx_mode ] ;if ( adj_rd < tx_cache [ i ] ) {tx_cache [ i ] = adj_rd ;}},"
",2764
391,CurrentColorSpace = ColorSpaceOut ;}Error :  cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,Lut = NULL ;CurrentColorSpace = ColorSpaceOut ;}Error : if ( Lut != NULL ) cmsPipelineFree ( Lut ) ;if ( Result != NULL ) cmsPipelineFree ( Result ) ;,2765
392,"
",if ( width >= ( long ) sizeof ( work ) ) width = sizeof ( work ) - 1 ;,2766
393,"
",size_t maxprec = sizeof ( work ) - 2 ;double val = p -> data . dnum ;while ( val >= 10.0 ) {val /= 10 ;maxprec -- ;}if ( prec > ( long ) maxprec ) prec = maxprec - 1 ;,2766
394,"len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;fptr += len ;len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;fptr += len ;","len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ;fptr += len ;len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ;fptr += len ;",2766
395,for ( fptr = work ;fptr ++ )  OUTCHAR ( * fptr ) ;,# ifdef CURLDEBUG assert ( strlen ( work ) <= sizeof ( work ) ) ;# endif for ( fptr = work ;fptr ++ ) OUTCHAR ( * fptr ) ;,2766
396,int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ;for ( y = 0 ;,int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ;av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ;av_assert0 ( height <= JPEG2000_MAX_CBLKH ) ;for ( y = 0 ;,2767
397,if ( sk -> sk_shutdown & RCV_SHUTDOWN ) {msg -> msg_namelen = 0 ;return 0 ;},if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ;,2768
398,else  msg -> msg_namelen = 0 ;,"
",2768
399,CollSeq * p4 ;if ( isCommuted ) {,CollSeq * p4 ;if ( pParse -> nErr ) return 0 ;if ( isCommuted ) {,2769
400,"mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ;mutex_unlock ( & mut ) ;","mc -> id = idr_alloc ( & multicast_idr , NULL , 0 , 0 , GFP_KERNEL ) ;mutex_unlock ( & mut ) ;",2770
401,"static void copy_to_user_policy ( struct xfrm_policy * xp , struct xfrm_userpolicy_info * p , int dir )  {memcpy ( & p -> sel , & xp -> selector , sizeof ( p -> sel ) ) ;","static void copy_to_user_policy ( struct xfrm_policy * xp , struct xfrm_userpolicy_info * p , int dir ) {memset ( p , 0 , sizeof ( * p ) ) ;memcpy ( & p -> sel , & xp -> selector , sizeof ( p -> sel ) ) ;",2771
402,continue ;},"if ( len >= FPM_LOG_BUFFER ) {zlog ( ZLOG_NOTICE , ""the<S2SV_blank>log<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>full<S2SV_blank>(%d).<S2SV_blank>The<S2SV_blank>access<S2SV_blank>log<S2SV_blank>request<S2SV_blank>has<S2SV_blank>been<S2SV_blank>truncated."" , FPM_LOG_BUFFER ) ;len = FPM_LOG_BUFFER ;break ;}continue ;}",2772
403,"
","if ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) {ret = - ENOENT ;goto out ;}",2773
404,"if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) {ret = - EACCES ;","if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) {ret = - EACCES ;",2773
405,"CYCLIC_REFRESH * vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) {CYCLIC_REFRESH * const cr = vpx_calloc ( 1 , sizeof ( * cr ) ) ;return cr ;}","CYCLIC_REFRESH * vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) {size_t last_coded_q_map_size ;CYCLIC_REFRESH * const cr = vpx_calloc ( 1 , sizeof ( * cr ) ) ;last_coded_q_map_size = mi_rows * mi_cols * sizeof ( * cr -> last_coded_q_map ) ;cr -> last_coded_q_map = vpx_malloc ( last_coded_q_map_size ) ;if ( cr -> last_coded_q_map == NULL ) {vpx_free ( cr ) ;return NULL ;}assert ( MAXQ <= 255 ) ;memset ( cr -> last_coded_q_map , MAXQ , last_coded_q_map_size ) ;return cr ;}",2774
406,"dm9000WriteReg ( DM9000_REG_MWCMDX , 0 ) ;DM9000_INDEX_REG = DM9000_REG_MWCMD ;p = ( uint16_t * ) context -> txBuffer ;","dm9000WriteReg ( DM9000_MWCMDX , 0 ) ;DM9000_INDEX_REG = DM9000_MWCMD ;p = ( uint16_t * ) context -> txBuffer ;",2775
407,"dm9000WriteReg ( DM9000_REG_TXPLL , LSB ( length ) ) ;dm9000WriteReg ( DM9000_REG_TXPLH , MSB ( length ) ) ;dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ;dm9000WriteReg ( DM9000_REG_TCR , TCR_TXREQ ) ;","dm9000WriteReg ( DM9000_TXPLL , LSB ( length ) ) ;dm9000WriteReg ( DM9000_TXPLH , MSB ( length ) ) ;dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PT ) ;dm9000WriteReg ( DM9000_TCR , DM9000_TCR_TXREQ ) ;",2775
408,inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;,"uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",2776
409,"if ( ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( ds ) ) & EVP_CIPH_FLAG_PIPELINE ) ) {SSLerr ( SSL_F_TLS1_ENC , SSL_R_PIPELINE_FAILURE ) ;return - 1 ;}}for ( ctr = 0 ;ctr < n_recs ;ctr ++ ) {reclen [ ctr ] = recs [ ctr ] . length ;if ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( ds ) ) & EVP_CIPH_FLAG_AEAD_CIPHER ) {unsigned char * seq ;seq = send ? RECORD_LAYER_get_write_sequence ( & s -> rlayer ) : RECORD_LAYER_get_read_sequence ( & s -> rlayer ) ;if ( SSL_IS_DTLS ( s ) ) {",if ( ! SSL_READ_ETM ( s ) ) {,2777
410,if ( ! SSL_USE_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL )  mac_size = EVP_MD_CTX_size ( s -> read_hash ) ;,if ( ! SSL_USE_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL ) mac_size = EVP_MD_CTX_size ( s -> read_hash ) ;,2777
411,static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu )  {if ( ! to_vmx ( vcpu ) -> nested . vmxon ) {,"static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) {if ( vmx_get_cpl ( vcpu ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;return 0 ;}if ( ! to_vmx ( vcpu ) -> nested . vmxon ) {",2778
412,"
",rcu_read_lock ( ) ;,2779
413,"final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;if ( IS_ERR ( dst ) ) {err = PTR_ERR ( dst ) ;dst = NULL ;goto done ;}skb = dccp_make_response ( sk , dst , req ) ;if ( skb != NULL ) {struct dccp_hdr * dh = dccp_hdr ( skb ) ;dh -> dccph_checksum = dccp_v6_csum_finish ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ;fl6 . daddr = ireq -> ir_v6_rmt_addr ;err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;err = net_xmit_eval ( err ) ;","final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ;rcu_read_unlock ( ) ;err = net_xmit_eval ( err ) ;",2779
414,"switch ( opt ) {case LCPOPT_VEXT : if ( len < 6 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>6)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 2 ) , 3 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;","ND_TCHECK_24BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ;",2780
415,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK_32BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ;",2780
416,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ;ND_TCHECK2 ( * ( p + 2 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ;ND_TCHECK_32BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ;",2780
417,"ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ;ND_TCHECK ( p [ 2 ] ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>Callback<S2SV_blank>Operation<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( ppp_callback_values , ""Unknown"" , p [ 2 ] ) , p [ 2 ] ) ) ;break ;case LCPOPT_MLMRRU : if ( len != 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;","ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ;ND_TCHECK_16BITS ( p + 2 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ;",2780
418,"expr_ty str = parsestrplus ( c , n ) ;","expr_ty str = parsestrplus ( c , STR ( ch ) ) ;",2781
419,"pynum = parsenumber ( c , s ) ;if ( ! pynum ) return NULL ;","pynum = parsenumber ( c , s ) ;if ( ! pynum ) return NULL ;",2781
420,"udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ;brelse ( bh ) ;up_read ( & iinfo -> i_data_sem ) ;","err = udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p , PAGE_SIZE ) ;brelse ( bh ) ;if ( err ) goto out_unlock_inode ;up_read ( & iinfo -> i_data_sem ) ;",2782
421,const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ;const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ;const BLOCK_SIZE bsize = mi -> mbmi . sb_type ;,const PREDICTION_MODE y_mode = mi -> mbmi . mode ;const PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ;const BLOCK_SIZE bsize = mi -> mbmi . sb_type ;,2783
422,"static void  horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % stride ) == 0 ) ;if ( cc > stride ) {","static int horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ;return 0 ;}if ( cc > stride ) {",2784
423,"
",return 1 ;,2784
424,},},2784
425,"env = g_environ_setenv ( env , var , val , TRUE ) ;}","if ( var [ 0 ] == \'\\\\0\' ) {g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>empty<S2SV_blank>name"" ) ;return G_DBUS_METHOD_INVOCATION_HANDLED ;}if ( strchr ( var , \'=\' ) != NULL ) {g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>name<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\\'=\\\'"" ) ;return G_DBUS_METHOD_INVOCATION_HANDLED ;}g_string_append ( env_string , var ) ;g_string_append_c ( env_string , \'=\' ) ;g_string_append ( env_string , val ) ;g_string_append_c ( env_string , \'\\\\0\' ) ;}",2785
426,goto errout_locked ;},goto errout_free ;},2786
427,kfree ( family -> attrbuf ) ;errout_locked : genl_unlock_all ( ) ;,errout_free : kfree ( family -> attrbuf ) ;errout_locked : genl_unlock_all ( ) ;,2786
428,"static void  horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 2 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 2 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%(2*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",2787
429,},return 1 ;},2787
430,"up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & kctl -> id ) ;return 0 ;","struct snd_ctl_elem_id id = kctl -> id ;up_read ( & card -> controls_rwsem ) ;snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & id ) ;return 0 ;",2788
431,"( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError ,  ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;image = DestroyImage ( image ) ;","( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , ""InvalidGeometry"" , ""`%s\\\'"" , option ) ;geometry = DestroyString ( geometry ) ;image = DestroyImage ( image ) ;",2789
432,"static inline bool unconditional ( const struct arpt_arp * arp )  {return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ;}","static inline bool unconditional ( const struct arpt_entry * e ) {return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> arp , & uncond , sizeof ( uncond ) ) == 0 ;}",2790
433,if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) )  goto out ;,"if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size ) ) ) goto out ;",2791
434,"size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;","size_t tail = ( i << 1 ) + 1 ;if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ;size_t ofs = CDF_GETUINT32 ( p , tail ) ;q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ;",2792
435,err = - EMSGSIZE ;if ( len > 0xFFFF ) goto out ;,struct ip_options_data opt_copy ;err = - EMSGSIZE ;if ( len > 0xFFFF ) goto out ;,2793
436,if ( ipc . opt ) free = 1 ;saddr = ipc . addr ;ipc . addr = daddr ;if ( ! ipc . opt )  ipc . opt = inet -> opt ;if ( ipc . opt ) {if ( ipc . opt -> srr ) {if ( ! daddr ) goto done ;daddr = ipc . opt -> faddr ;},"if ( ipc . opt ) {struct ip_options_rcu * inet_opt ;rcu_read_lock ( ) ;inet_opt = rcu_dereference ( inet -> inet_opt ) ;if ( inet_opt ) {memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ;ipc . opt = & opt_copy . opt ;rcu_read_unlock ( ) ;}if ( ipc . opt ) {if ( ipc . opt -> opt . srr ) {if ( ! daddr ) goto done ;daddr = ipc . opt -> opt . faddr ;}",2793
437,else  img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ;},else img = ctx -> iface -> enc . get_preview ( get_alg_priv ( ctx ) ) ;},2794
438,static void follow_dotdot ( struct nameidata * nd )  {,static int follow_dotdot ( struct nameidata * nd ) {,2795
439,break ;}},if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;break ;}return 0 ;},2795
440,"else if ( rc == - ENODATA )  rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ;return rc ;}","else if ( rc == - ENODATA && inode -> i_op -> removexattr ) {rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ;}return rc ;}",2796
441,MP4_READBOX_ENTER ( MP4_Box_data_string_t ) ;p_box -> data . p_string -> psz_text = malloc ( p_box -> i_size + 1 - 8 ) ;,MP4_READBOX_ENTER ( MP4_Box_data_string_t ) ;if ( p_box -> i_size < 8 || p_box -> i_size > SIZE_MAX ) MP4_READBOX_EXIT ( 0 ) ;p_box -> data . p_string -> psz_text = malloc ( p_box -> i_size + 1 - 8 ) ;,2797
442,"u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ;if ( ! d ) return - ENODEV ;if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 )  return - EAGAIN ;switch ( num ) {case 1 : switch ( msg [ 0 ] . addr ) {case SU3000_STREAM_CTRL :  obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ;obuf [ 1 ] = 3 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case DW2102_RC_QUERY :  obuf [ 0 ] = 0x10 ;if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ;msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ;break ;default :  obuf [ 0 ] = 0x08 ;obuf [ 1 ] = msg [ 0 ] . addr ;obuf [ 2 ] = msg [ 0 ] . len ;memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 ,   ibuf , 1 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case 2 :  obuf [ 0 ] = 0x09 ;obuf [ 1 ] = msg [ 0 ] . len ;obuf [ 2 ] = msg [ 1 ] . len ;obuf [ 3 ] = msg [ 0 ] . addr ;memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 ,   ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ;break ;mutex_unlock ( & d -> i2c_mutex ) ;return num ;","struct dw2102_state * state ;if ( ! d ) return - ENODEV ;state = d -> priv ;if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) return - EAGAIN ;if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) {mutex_unlock ( & d -> i2c_mutex ) ;return - EAGAIN ;}switch ( num ) {case 1 : switch ( msg [ 0 ] . addr ) {case SU3000_STREAM_CTRL : state -> data [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ;state -> data [ 1 ] = 3 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 0 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;break ;case DW2102_RC_QUERY : state -> data [ 0 ] = 0x10 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 2 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msg [ 0 ] . buf [ 1 ] = state -> data [ 0 ] ;msg [ 0 ] . buf [ 0 ] = state -> data [ 1 ] ;default : state -> data [ 0 ] = 0x08 ;state -> data [ 1 ] = msg [ 0 ] . addr ;state -> data [ 2 ] = msg [ 0 ] . len ;memcpy ( & state -> data [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 3 , state -> data , 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case 2 : state -> data [ 0 ] = 0x09 ;state -> data [ 1 ] = msg [ 0 ] . len ;state -> data [ 2 ] = msg [ 1 ] . len ;state -> data [ 3 ] = msg [ 0 ] . addr ;memcpy ( & state -> data [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 4 , state -> data , msg [ 1 ] . len + 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;memcpy ( msg [ 1 ] . buf , & state -> data [ 1 ] , msg [ 1 ] . len ) ;break ;mutex_unlock ( & d -> data_mutex ) ;mutex_unlock ( & d -> i2c_mutex ) ;return num ;",2798
443,"if ( yych == \':\' ) goto yy95 ;yy3 : # line 884 ""ext/standard/var_unserializer.re"" {return 0 ;}# line 580 ""ext/standard/var_unserializer.c"" yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy89 ;goto yy3 ;yy5 : yych = * ++ YYCURSOR ;if ( yych == \';\' ) goto yy87 ;goto yy3 ;yy6 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy83 ;goto yy3 ;yy7 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy77 ;goto yy3 ;yy8 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy53 ;goto yy3 ;yy9 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy46 ;goto yy3 ;yy10 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy39 ;goto yy3 ;yy11 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy32 ;goto yy3 ;yy12 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy25 ;goto yy3 ;yy13 : yych = * ( YYMARKER = ++ YYCURSOR ) ;if ( yych == \':\' ) goto yy17 ;goto yy3 ;yy14 : ++ YYCURSOR ;# line 878 ""ext/standard/var_unserializer.re"" {php_error_docref ( NULL , E_NOTICE , ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data"" ) ;return 0 ;}# line 629 ""ext/standard/var_unserializer.c"" yy16 : yych = * ++ YYCURSOR ;goto yy3 ;yy17 : yych = * ++ YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}if ( yych == \'+\' ) goto yy19 ;yy18 : YYCURSOR = YYMARKER ;goto yy3 ;yy19 : yych = * ++ YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}goto yy18 ;yy20 : ++ YYCURSOR ;if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ;yych = * YYCURSOR ;if ( yybm [ 0 + yych ] & 128 ) {goto yy20 ;}if ( yych != \':\' ) goto yy18 ;yych = * ++ YYCURSOR ;",if ( yych <= \'/\' ) goto yy18 ;if ( yych >= \';\' ) goto yy18 ;yych = * ++ YYCURSOR ;,2799
444,"# line 804 ""ext/standard/var_unserializer.c""  yy25 : yych = * ++ YYCURSOR ;","# line 805 ""ext/standard/var_unserializer.c"" yy25 : yych = * ++ YYCURSOR ;",2799
445,"# line 836 ""ext/standard/var_unserializer.c""  yy32 : yych = * ++ YYCURSOR ;","# line 837 ""ext/standard/var_unserializer.c"" yy32 : yych = * ++ YYCURSOR ;",2799
446,"# line 881 ""ext/standard/var_unserializer.c""  yy39 : yych = * ++ YYCURSOR ;","# line 882 ""ext/standard/var_unserializer.c"" yy39 : yych = * ++ YYCURSOR ;",2799
447,"# line 936 ""ext/standard/var_unserializer.c""  yy46 : yych = * ++ YYCURSOR ;","# line 937 ""ext/standard/var_unserializer.c"" yy46 : yych = * ++ YYCURSOR ;",2799
448,"# line 989 ""ext/standard/var_unserializer.c""  yy53 : yych = * ++ YYCURSOR ;","# line 990 ""ext/standard/var_unserializer.c"" yy53 : yych = * ++ YYCURSOR ;",2799
449,"# line 1086 ""ext/standard/var_unserializer.c""  yy65 : yych = * ++ YYCURSOR ;","# line 1087 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ;",2799
450,"# line 1161 ""ext/standard/var_unserializer.c""  yy76 : yych = * ++ YYCURSOR ;","# line 1162 ""ext/standard/var_unserializer.c"" yy76 : yych = * ++ YYCURSOR ;",2799
451,"# line 1214 ""ext/standard/var_unserializer.c""  yy83 : yych = * ++ YYCURSOR ;","# line 1215 ""ext/standard/var_unserializer.c"" yy83 : yych = * ++ YYCURSOR ;",2799
452,"# line 1228 ""ext/standard/var_unserializer.c""  yy87 : ++ YYCURSOR ;# line 1237 ""ext/standard/var_unserializer.c""  yy89 : yych = * ++ YYCURSOR ;","# line 1229 ""ext/standard/var_unserializer.c"" yy87 : ++ YYCURSOR ;# line 1238 ""ext/standard/var_unserializer.c"" yy89 : yych = * ++ YYCURSOR ;",2799
453,"# line 1285 ""ext/standard/var_unserializer.c""  yy95 : yych = * ++ YYCURSOR ;","# line 1286 ""ext/standard/var_unserializer.c"" yy95 : yych = * ++ YYCURSOR ;",2799
454,"# line 1334 ""ext/standard/var_unserializer.c""  }","# line 1335 ""ext/standard/var_unserializer.c"" }",2799
455,"if ( timeri -> master )  list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ;spin_unlock_irqrestore ( & slave_active_lock , flags ) ;return 1 ;","if ( timeri -> master && timeri -> timer ) {spin_lock ( & timeri -> timer -> lock ) ;list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ;spin_unlock ( & timeri -> timer -> lock ) ;}spin_unlock_irqrestore ( & slave_active_lock , flags ) ;return 1 ;",2800
456,"int n = * pnEntry ;if ( ( n & ( n - 1 ) ) == 0 ) {int sz = ( n == 0 ) ? 1 : 2 * n ;void * pNew = sqlite3DbRealloc ( db , pArray , sz * szEntry ) ;","sqlite3_int64 n = * pnEntry ;if ( ( n & ( n - 1 ) ) == 0 ) {sqlite3_int64 sz = ( n == 0 ) ? 1 : 2 * n ;void * pNew = sqlite3DbRealloc ( db , pArray , sz * szEntry ) ;",2801
457,if ( payload_len > IPV6_MAXPLEN ) {,if ( fp && payload_len > IPV6_MAXPLEN ) {,2802
458,if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL )  fp = fp -> next ;,if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) fp = fp -> next ;,2802
459,sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ;if ( ! sbi -> s_mb_cache ) {,sbi -> s_mb_cache = ext4_xattr_create_cache ( ) ;if ( ! sbi -> s_mb_cache ) {,2803
460,failed_mount_wq :  if ( sbi -> s_journal ) {,failed_mount_wq : if ( sbi -> s_mb_cache ) {ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ;sbi -> s_mb_cache = NULL ;}if ( sbi -> s_journal ) {,2803
461,const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ;int ref ;,const InterpKernel * kernel = vp9_filter_kernels [ mi -> mbmi . interp_filter ) ;int ref ;,2804
462,"const MV mv = mi -> mbmi . sb_type < BLOCK_8X8  ? ( plane == 0 ? mi -> bmi [ block ] . as_mv [ ref ] . as_mv  : mi_mv_pred_q4 ( mi , ref ) ) : mi -> mbmi . mv [ ref ] . as_mv ;if ( vp9_is_scaled ( sf ) ) {pre = pre_buf -> buf + scaled_buffer_offset ( x , y , pre_buf -> stride , sf ) ;","const MV mv = mi -> mbmi . sb_type < BLOCK_8X8 ? average_split_mvs ( pd , mi , ref , block ) : mi -> mbmi . mv [ ref ] . as_mv ;const int is_scaled = vp9_is_scaled ( sf ) ;if ( is_scaled ) {pre = pre_buf -> buf + scaled_buffer_offset ( x , y , pre_buf -> stride , sf ) ;",2804
463,"inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride ,   subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ;}","# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {high_inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys , xd -> bd ) ;}else {inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ;}# else inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ;# endif }",2804
464,"
","i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ;i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ;",2805
465,{UWORD8 u1_err_code = pu1_intra_err_codes [ i1_intra_pred ] ;,{UWORD8 u1_err_code = pu1_intra_err_codes [ i1_intra_pred ] ;,2805
466,}{,}{,2805
467,"assert ( caplen > 0 ) ;reallen = roundup2 ( caplen , 4 ) ;","reallen = roundup2 ( caplen , 4 ) ;",2806
468,"}return ( PTR_DIFF ( s , s0 ) + 1 ) ;","ND_TCHECK2 ( * s , 1 ) ;}return ( PTR_DIFF ( s , s0 ) + 1 ) ;",2807
469,"
",if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;,2808
470,"if ( tga_info . colormap_type != 0 )  {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","if ( tga_info . colormap_type != 0 ) {if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",2808
471,"_copy_from_pages ( buf , pages , res . acl_data_offset ,  res . acl_len ) ;}","_copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;}",2809
472,mutex_unlock ( & file -> mut ) ;ucma_put_ctx ( ctx ) ;,"mutex_lock ( & mut ) ;idr_replace ( & multicast_idr , mc , mc -> id ) ;mutex_unlock ( & mut ) ;mutex_unlock ( & file -> mut ) ;ucma_put_ctx ( ctx ) ;",2810
473,"timeri = list_entry ( timer -> open_list_head . next ,  struct snd_timer_instance , open_list ) ;if ( timeri -> flags & SNDRV_TIMER_IFLG_EXCLUSIVE ) {err = - EBUSY ;timeri = NULL ;","struct snd_timer_instance * t = list_entry ( timer -> open_list_head . next , struct snd_timer_instance , open_list ) ;if ( t -> flags & SNDRV_TIMER_IFLG_EXCLUSIVE ) {err = - EBUSY ;",2811
474,"d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ;d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ;q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ;","d0u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 0 ] ) ;d1u8 = vdup_n_u8 ( bifilter4_coeff [ xoffset ] [ 1 ] ) ;q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ;",2812
475,"static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe ,  struct pipe_buffer * buf ) {ref -> ref ++ ;}","static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {if ( ref -> ref > INT_MAX / 2 ) return false ;ref -> ref ++ ;return true ;}",2813
476,"int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ;int64_t total_samples = 0 , infilesize ;","int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 , format_chunk = 0 ;int64_t total_samples = 0 , infilesize ;",2814
477,"int supported = TRUE , format ;if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) {","int supported = TRUE , format ;if ( format_chunk ++ ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) {",2814
478,"
",ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;,2815
479,l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ;break ;,2815
480,"if ( JAS_CAST ( uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) {goto error ;","if ( JAS_CAST ( jas_uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) {goto error ;",2816
481,"# endif const bool bcached =  ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ;ctx -> hdrs [ i ] -> old = false ;","# endif const bool bcached = ( mutt_bcache_exists ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) == 0 ) ;ctx -> hdrs [ i ] -> old = false ;",2817
482,# ifdef SQLITE_TEST_REALLOC_STRESS  int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ;# else  int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ;UNUSED_PARAMETER ( nOp ) ;,# ifdef SQLITE_TEST_REALLOC_STRESS sqlite3_int64 nNew = ( v -> nOpAlloc >= 512 ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ;# else sqlite3_int64 nNew = ( v -> nOpAlloc ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) 1024 / sizeof ( Op ) ) ;UNUSED_PARAMETER ( nOp ) ;,2818
483,if ( key -> type -> destroy )  key -> type -> destroy ( key ) ;,"if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ;",2819
484,"int mi_row ;int mi_col ;int mi_index = 0 ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ;int rows = cm -> mi_rows ;log_frame_info ( cm , descriptor , file ) ;mi_index = 0 ;","int mi_row , mi_col ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ;int rows = cm -> mi_rows ;log_frame_info ( cm , descriptor , file ) ;",2820
485,"fprintf ( file , ""%2d<S2SV_blank>"" ,  * ( ( int * ) ( ( char * ) ( & mi_8x8 [ mi_index ] -> mbmi ) +  member_offset ) ) ) ;mi_index ++ ;}mi_index += 8 ;}","fprintf ( file , ""%2d<S2SV_blank>"" , * ( ( int * ) ( ( char * ) ( & mi [ 0 ] -> mbmi ) + member_offset ) ) ) ;mi ++ ;}mi += 8 ;}",2820
486,FIRSTPASS_STATS this_frame ;struct twopass_rc * const twopass = & cpi -> twopass ;,TWO_PASS * const twopass = & cpi -> twopass ;,2821
487,"if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF )  break ;accumulate_frame_motion_stats ( & this_frame ,  & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ;decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;boost_score += ( decay_accumulator *   calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ;}","const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ;if ( this_frame == NULL ) break ;accumulate_frame_motion_stats ( this_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;decay_accumulator *= get_prediction_decay_rate ( cpi , this_frame ) ;decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;}boost_score += decay_accumulator * calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ;",2821
488,"if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF )  break ;accumulate_frame_motion_stats ( & this_frame ,  & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ;decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;boost_score += ( decay_accumulator *   calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ;}if ( arf_boost < ( ( b_frames + f_frames ) * 20 ) )  arf_boost = ( ( b_frames + f_frames ) * 20 ) ;return arf_boost ;","if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF ) break ;accumulate_frame_motion_stats ( & this_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ;decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;}boost_score += ( decay_accumulator * calc_frame_boost ( cpi , this_frame , this_frame_mv_in_out , GF_MAX_BOOST ) ;if ( arf_boost < ( ( b_frames + f_frames ) * 20 ) ;arf_boost = MAX ( arf_boost , MIN_ARF_GF_BOOST ) ) arf_boost = ( ( b_frames + f_frames ) * 20 ) ;return arf_boost ;",2821
489,"emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ;return TRUE ;","emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>and<S2SV_blank>some<S2SV_blank>functionality<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ;return TRUE ;",2822
490,if ( m -> msg_flags & MSG_OOB )  goto read_error ;m -> msg_namelen = 0 ;,if ( m -> msg_flags & MSG_OOB ) goto read_error ;,2823
491,"lvl ++ )  vpx_memset ( lfi -> lfthr [ lvl ] . hev_thr , ( lvl >> 4 ) , SIMD_WIDTH ) ;}","lvl ++ ) memset ( lfi -> lfthr [ lvl ] . hev_thr , ( lvl >> 4 ) , SIMD_WIDTH ) ;}",2824
492,static void print_bpf_insn ( struct bpf_insn * insn )  {,"static void print_bpf_insn ( const struct bpf_verifier_env * env , const struct bpf_insn * insn ) {",2825
493,"}else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) {verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%x\\\}","}else if ( BPF_MODE ( insn -> code ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) {u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ;bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ;if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ;verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\\}",2825
494,"static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref ,  const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) {const MV_JOINT_TYPE joint_type =  ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ;const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ;","static INLINE void read_mv ( vpx_reader * r , MV * mv , const MV * ref , const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) {const MV_JOINT_TYPE joint_type = ( MV_JOINT_TYPE ) vpx_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ;const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ;",2826
495,"virCheckDomainReturn ( dom , - 1 ) ;if ( dom -> conn -> driver -> domainGetTime ) {","virCheckDomainReturn ( dom , - 1 ) ;virCheckReadOnlyGoto ( dom -> conn -> flags , error ) ;if ( dom -> conn -> driver -> domainGetTime ) {",2827
496,"if ( ! data )   return 0 ;memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ;","if ( ! data || len < 2 ) {return 0 ;}memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ;",2828
497,"const char * value = NULL ;xmlNode * command = NULL ;cib_client_t * client = data ;crm_trace ( ""%s<S2SV_blank>callback"" , client -> encrypted ? ""secure"" : ""clear-text"" ) ;command = crm_recv_remote_msg ( client -> session , client -> encrypted ) ;if ( command == NULL ) {value = crm_element_name ( command ) ;if ( safe_str_neq ( value , ""cib_command"" ) ) {crm_log_xml_trace ( command , ""Bad<S2SV_blank>command:<S2SV_blank>"" ) ;goto bail ;if ( client -> name == NULL ) {value = crm_element_value ( command , F_CLIENTNAME ) ;if ( value == NULL ) {client -> name = strdup ( client -> id ) ;else {client -> name = strdup ( value ) ;}}if ( client -> callback_id == NULL ) {value = crm_element_value ( command , F_CIB_CALLBACK_TOKEN ) ;if ( value != NULL ) {client -> callback_id = strdup ( value ) ;crm_trace ( ""Callback<S2SV_blank>channel<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , client -> id , client -> callback_id ) ;}else {client -> callback_id = strdup ( client -> id ) ;xml_remove_prop ( command , F_ORIG ) ;xml_remove_prop ( command , F_CIB_HOST ) ;xml_remove_prop ( command , F_CIB_GLOBAL_UPDATE ) ;crm_xml_add ( command , F_TYPE , T_CIB ) ;crm_xml_add ( command , F_CIB_CLIENTID , client -> id ) ;crm_xml_add ( command , F_CIB_CLIENTNAME , client -> name ) ;# if ENABLE_ACL  crm_xml_add ( command , F_CIB_USER , client -> user ) ;# endif if ( crm_element_value ( command , F_CIB_CALLID ) == NULL ) {crm_xml_add ( command , F_CIB_CALLID , call_uuid ) ;free ( call_uuid ) ;","xmlNode * command = NULL ;cib_client_t * client = data ;int disconnected = 0 ;int timeout = client -> remote_auth ? - 1 : 1000 ;crm_trace ( ""%s<S2SV_blank>callback"" , client -> encrypted ? ""secure"" : ""clear-text"" ) ;# ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> encrypted && ( client -> handshake_complete == FALSE ) ) {int rc = 0 ;do {rc = gnutls_handshake ( * client -> session ) ;if ( rc < 0 && rc != GNUTLS_E_AGAIN ) {crm_err ( ""Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>failed"" ) ;while ( rc == GNUTLS_E_INTERRUPTED ) ;if ( rc == 0 ) {crm_debug ( ""Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>completed"" ) ;client -> handshake_complete = TRUE ;if ( client -> remote_auth_timeout ) {g_source_remove ( client -> remote_auth_timeout ) ;client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , client ) ;return 0 ;# endif crm_recv_remote_msg ( client -> session , & client -> recv_buf , client -> encrypted , timeout , & disconnected ) ;if ( client -> remote_auth == FALSE ) {xmlNode * reg ;# if ENABLE_ACL crm_xml_add ( command , F_CIB_USER , client -> user ) ;# endif if ( crm_element_value ( command , F_CIB_CALLID ) == NULL ) {crm_xml_add ( command , F_CIB_CALLID , call_uuid ) ;free ( call_uuid ) ;",2829
498,"if ( entry -> me_key != NULL ) {entry -> me_value = value ;return 0 ;Py_INCREF ( key ) ;entry -> me_key = key ;entry -> me_value = value ;self -> mt_used ++ ;if ( ! ( self -> mt_used * 3 >= ( self -> mt_mask + 1 ) * 2 ) )  return 0 ;return _PyMemoTable_ResizeTable ( self ,   ( self -> mt_used > 50000 ? 2 : 4 ) * self -> mt_used ) ;}","if ( SIZE_MAX / 3 >= self -> mt_used ;return _PyMemoTable_ResizeTable ( self , desired_size && self -> mt_used ++ ;if ( ! ( self -> mt_used * 3 >= ( self -> mt_mask + 1 ) * 2 ) ) return 0 ;return _PyMemoTable_ResizeTable ( self , ( self -> mt_used > 50000 ? 2 : 4 ) * self -> mt_used ) ;",2830
499,params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;",2831
500,"# endif  vpx_memset ( segment_counts , 0 , sizeof ( segment_counts ) ) ;totalrate = 0 ;","# endif memset ( segment_counts , 0 , sizeof ( segment_counts ) ) ;totalrate = 0 ;",2832
501,"for ( i = 0 ;i < num_part ;i ++ ) {vp8_start_encode ( & bc [ i ] , cpi -> partition_d [ i + 1 ] , cpi -> partition_d_end [ i + 1 ] ) ;bc [ i ] . error = & cm -> error ;}}# endif {struct vpx_usec_timer emr_timer ;vpx_usec_timer_start ( & emr_timer ) ;# if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) {int i ;vp8cx_init_mbrthread_data ( cpi , x , cpi -> mb_row_ei , cpi -> encoding_thread_count ) ;for ( i = 0 ;i < cm -> mb_rows ;i ++ ) cpi -> mt_current_mb_col [ i ] = - 1 ;for ( i = 0 ;i < cpi -> encoding_thread_count ;i ++ ) {sem_post ( & cpi -> h_event_start_encoding [ i ] ) ;}for ( mb_row = 0 ;mb_row < cm -> mb_rows ;mb_row += ( cpi -> encoding_thread_count + 1 ) ) {vp8_zero ( cm -> left_context ) # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING tp = cpi -> tok ;# else tp = cpi -> tok + mb_row * ( cm -> mb_cols * 16 * 24 ) ;# endif encode_mb_row ( cpi , cm , mb_row , x , xd , & tp , segment_counts , & totalrate ) ;x -> src . y_buffer += 16 * x -> src . y_stride * ( cpi -> encoding_thread_count + 1 ) - 16 * cm -> mb_cols ;x -> src . u_buffer += 8 * x -> src . uv_stride * ( cpi -> encoding_thread_count + 1 ) - 8 * cm -> mb_cols ;x -> src . v_buffer += 8 * x -> src . uv_stride * ( cpi -> encoding_thread_count + 1 ) - 8 * cm -> mb_cols ;xd -> mode_info_context += xd -> mode_info_stride * cpi -> encoding_thread_count ;x -> partition_info += xd -> mode_info_stride * cpi -> encoding_thread_count ;x -> gf_active_ptr += cm -> mb_cols * cpi -> encoding_thread_count ;if ( mb_row == cm -> mb_rows - 1 ) {sem_post ( & cpi -> h_event_end_encoding ) ;}}sem_wait ( & cpi -> h_event_end_encoding ) ;for ( mb_row = 0 ;mb_row < cm -> mb_rows ;mb_row ++ ) {cpi -> tok_count += ( unsigned int ) ( cpi -> tplist [ mb_row ] . stop - cpi -> tplist [ mb_row ] . start ) ;}if ( xd -> segmentation_enabled ) {",memset ( xd -> segmentation_enabled ) {,2832
502,"vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ;tot_count = segment_counts [ 0 ] + segment_counts [ 1 ] + segment_counts [ 2 ] + segment_counts [ 3 ] ;","vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ;tot_count = segment_counts [ 0 ] + segment_counts [ 1 ] + segment_counts [ 2 ] + segment_counts [ 3 ] ;",2832
503,const char command5 [ ] = {int s ;,"const char command5 [ ] = {const char bad_command4 [ ] = {0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f };int s ;",2833
504,"
",if ( n == 0 ) {,2833
505,"
","n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ;n = read ( s , buf , sizeof ( buf ) ) ;printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\\printresponse ( buf , n ) ;close ( s ) ;s = connect_unix_socket ( sockpath ) ;}",2833
506,close ( s ) ;return 0 ;},close ( s ) ;return 0 ;},2833
507,"
","if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;",2834
508,return self ;},return self ;},2834
509,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] ;int hsub = s -> draw . hsub [ plane ] ;,for ( plane = 0 ;plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ;int hsub = s -> draw . hsub [ plane ] ;,2835
510,"struct flowi4 fl4 ;struct rtable * rt ;if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) )  return ;if ( ! IS_ERR ( rt ) )   __sk_dst_set ( sk , & rt -> dst ) ;rcu_read_unlock ( ) ;","struct dst_entry * dst ;struct flowi4 fl4 ;struct rtable * rt ;dst = __sk_dst_get ( sk ) ;if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst , 0 ) ) {rcu_read_unlock ( ) ;return ;}dst = ! IS_ERR ( rt ) ) __sk_dst_set ( sk , & rt -> dst : NULL ;sk_dst_set ( sk , dst ) ;rcu_read_unlock ( ) ;",2836
511,"if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) {c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ;aligned_height = FFALIGN ( c -> height , 16 ) ;av_free ( c -> framebuf ) ;","if ( ! c -> framebuf || c -> old_width < c -> width + 15 , 16 ) ;aligned_height = FFALIGN ( c -> height , 16 ) ;av_free ( c -> framebuf ) ;",2837
512,"bool tsonly ;if ( ! sk ) return ;# ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP &&  sk -> sk_type == SOCK_STREAM )  skb = tcp_get_timestamping_opt_stats ( sk ) ;else  # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ;","bool tsonly , opt_stats = false ;if ( ! sk ) return ;# ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) {skb = tcp_get_timestamping_opt_stats ( sk ) ;opt_stats = true ;}else # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ;",2838
513,"__skb_complete_tx_timestamp ( skb , sk , tstype ) ;}","__skb_complete_tx_timestamp ( skb , sk , tstype , opt_stats ) ;}",2838
514,if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 &&  rdesc [ 106 ] == 0x03 ) {,if ( * rsize >= 112 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && rdesc [ 106 ] == 0x03 ) {,2839
515,"static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",2840
516,if ( c < 0 )  break ;* p ++ = ( unsigned char ) c ;if ( c < 0 )  break ;* p ++ = ( unsigned char ) c ;,"if ( c < 0 ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}* p ++ = ( unsigned char ) c ;if ( c < 0 ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}* p ++ = ( unsigned char ) c ;",2841
517,"size_t ss = CDF_SEC_SIZE ( h ) , i , j ;scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) , i , j ;scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ;",2842
518,"return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ;}","return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ;}",2843
519,"a = 1.0f / MaxF ( w . x , MaxF ( w . y , w . z ) ) ;v . x = w . x * a ;","a = 1.0f / MagickMax ( w . x , MagickMax ( w . x , MaxF ( w . y , w . z ) ) ;v . x = w . x * a ;",2844
520,"static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val )  {ulonglong v ;v = 0 ;","static int jas_iccgetuint ( jas_stream_t * in , int n , jas_ulonglong * val ) {jas_ulonglong v ;v = 0 ;",2845
521,int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 )  / body -> unit_size ;,int n ;if ( ! body -> unit_size ) break ;n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ;,2846
522,uint32 nstrips ;if ( td -> td_nstrips ) return td -> td_nstrips ;,uint32 nstrips ;,2847
523,"memccpy ( result , ptr , 0 , len ) ;return result ;","memcpy ( result , ptr , 0 , len ) ;return result ;",2848
524,"imap_quote_string ( dest , dlen , buf ) ;FREE ( & buf ) ;","imap_quote_string ( dest , dlen , buf , false ) ;FREE ( & buf ) ;",2849
525,ifd ++ ;break ;,ifd ++ ;# ifdef LIBRAW_LIBRARY_BUILD if ( ifd >= sizeof tiff_ifd / sizeof tiff_ifd [ 0 ] ) throw LIBRAW_EXCEPTION_IO_CORRUPT ;# endif break ;,2850
526,# endif if ( len > 1000 ) len = 1000 ;,# endif if ( len < 1 || len > 1000 ) len = 1000 ;,2850
527,case 50454 : case 50455 :  if ( len > 2560000 || ! ( cbuf = ( char * ) malloc ( len ) ) )  break ;,case 50454 : case 50455 : if ( len > 2560000 || ! ( cbuf = ( char * ) malloc ( len ) ) ) break ;,2850
528,"static int handle_emulation_failure ( struct kvm_vcpu * vcpu )  {++ vcpu -> stat . insn_emulation_fail ;trace_kvm_emulate_insn_failed ( vcpu ) ;vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;kvm_queue_exception ( vcpu , UD_VECTOR ) ;return EMULATE_FAIL ;}","+ vcpu -> stat . insn_emulation_fail ;static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) {int r = EMULATE_DONE ;++ vcpu -> stat . insn_emulation_fail ;trace_kvm_emulate_insn_failed ( vcpu ) ;if ( ! is_guest_mode ( vcpu ) ) {vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ;r = EMULATE_FAIL ;}kvm_queue_exception ( vcpu , UD_VECTOR ) ;return r ;}",2851
529,"# define COPY_PORT ( dest , src ) do {","if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) {dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\\return - ENODEV ;}# define COPY_PORT ( dest , src ) do {",2852
530,"swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ;","swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ;",2852
531,"err = 0 ;skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ;payload_len = dg -> payload_size ;if ( payload_len != skb -> len - sizeof ( * dg ) ) {err = - EINVAL ;goto out ;}if ( payload_len > len ) {payload_len = len ;msg -> msg_flags |= MSG_TRUNC ;}err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ;if ( err ) goto out ;msg -> msg_namelen = 0 ;if ( msg -> msg_name ) {","msg -> msg_namelen = 0 ;err = 0 ;skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ;if ( msg -> msg_name ) {",2853
532,"pixs = pixRead ( ""cat.035.jpg"" ) ;pixn = pixBackgroundNormSimple ( pixs , NULL , NULL ) ;","lept_rmdir ( ""lept/dewmod"" ) ;lept_mkdir ( ""lept/dewmod"" ) ;pixs = pixRead ( ""cat.035.jpg"" ) ;pixn = pixBackgroundNormSimple ( pixs , NULL , NULL ) ;",2854
533,"lept_stderr ( ""pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\\lept_rmdir ( ""lept/dewmod"" ) ;lept_rmdir ( ""lept/dewtest"" ) ;","lept_stderr ( ""pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\\",2854
534,"endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ;","if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) {dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\\err = - EINVAL ;goto fail3 ;}endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ;usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ;",2855
535,goto fail3 ;},err = - EINVAL ;goto fail3 ;},2855
536,"long newpos ;JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\","size_t newpos ;JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\",2856
537,"set_header ( res , ""Content-Type"" , mime ) ;}","set_header ( res , ""Content-Type"" , ""%s"" , mime ) ;}",2857
538,"FD_SET ( sock , & mset ) ;max = sock > max ? sock : max ;}}for ( i = 0 ;i < modernsocks -> len ;i ++ ) {int sock = g_array_index ( modernsocks , int , i ) ;FD_SET ( sock , & mset ) ;max = sock > max ? sock : max ;}for ( ;;) {if ( is_sighup_caught ) {int n ;GError * gerror = NULL ;msg ( LOG_INFO , ""reconfiguration<S2SV_blank>request<S2SV_blank>received"" ) ;is_sighup_caught = 0 ;n = append_new_servers ( servers , & gerror ) ;if ( n == - 1 ) msg ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>new<S2SV_blank>servers:<S2SV_blank>%s"" , gerror -> message ) ;for ( i = servers -> len - n ;i < servers -> len ;++ i ) {const SERVER server = g_array_index ( servers , SERVER , i ) ;if ( server . socket >= 0 ) {FD_SET ( server . socket , & mset ) ;max = server . socket > max ? server . socket : max ;}msg ( LOG_INFO , ""reconfigured<S2SV_blank>new<S2SV_blank>server:<S2SV_blank>%s"" , server . servename ) ;}}memcpy ( & rset , & mset , sizeof ( fd_set ) ) ;if ( select ( max + 1 , & rset , NULL , NULL , NULL ) > 0 ) {int net ;DEBUG ( ""accept,<S2SV_blank>"" ) ;","+ i ) {DEBUG ( ""accept,<S2SV_blank>"" ) ;",2858
539,"CLIENT * client ;if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) {err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ;client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ;if ( ! client ) {","CLIENT * client ;if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) {err_nonfatal ( ""accept:<S2SV_blank>%m"" ) ;client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ;if ( ! client ) {",2858
540,sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ;if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ;,sc -> drefs_count = 0 ;sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ;if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ;,2859
541,"if ( ND_TTEST2 ( bp [ 0 ] , 30 ) && bp [ 11 ] == 1 && ( ( njoin = EXTRACT_16BITS ( & bp [ 20 ] ) ) + EXTRACT_16BITS ( & bp [ 22 ] ) ) == 1 ) {int hold ;ND_PRINT ( ( ndo , ""<S2SV_blank>RPF<S2SV_blank>%s<S2SV_blank>"" , ipaddr_string ( ndo , bp ) ) ) ;hold = EXTRACT_16BITS ( & bp [ 6 ] ) ;if ( hold != 180 ) {ND_PRINT ( ( ndo , ""Hold<S2SV_blank>"" ) ) ;unsigned_relts_print ( ndo , hold ) ;}ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%s/%d,<S2SV_blank>%s"" , njoin ? ""Join"" : ""Prune"" , ipaddr_string ( ndo , & bp [ 26 ] ) , bp [ 25 ] & 0x3f , ipaddr_string ( ndo , & bp [ 12 ] ) ) ) ;if ( EXTRACT_32BITS ( & bp [ 16 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 16 ] ) ) ) ;ND_PRINT ( ( ndo , "")<S2SV_blank>%s%s<S2SV_blank>%s"" , ( bp [ 24 ] & 0x01 ) ? ""Sparse"" : ""Dense"" , ( bp [ 25 ] & 0x80 ) ? ""<S2SV_blank>WC"" : """" , ( bp [ 25 ] & 0x40 ) ? ""RP"" : ""SPT"" ) ) ;return ;}ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""<S2SV_blank>Upstream<S2SV_blank>Nbr:<S2SV_blank>%s"" , ipaddr_string ( ndo , bp ) ) ) ;ND_TCHECK2 ( bp [ 6 ] , 2 ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 6 ] ) ) ;if ( ndo -> ndo_vflag < 2 ) return ;bp += 8 ;len -= 8 ;ND_TCHECK2 ( bp [ 0 ] , 4 ) ;ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( bp [ 4 ] , sizeof ( struct in_addr ) ) ;if ( EXTRACT_32BITS ( & bp [ 4 ] ) != 0xffffffff )   ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 4 ] ) ) ) ;ND_TCHECK2 ( bp [ 8 ] , 4 ) ;njoin = EXTRACT_16BITS ( & bp [ 8 ] ) ;nprune = EXTRACT_16BITS ( & bp [ 10 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>joined:<S2SV_blank>%d<S2SV_blank>pruned:<S2SV_blank>%d"" , njoin , nprune ) ) ;bp += 12 ;len -= 12 ;for ( njp = 0 ;ND_TCHECK2 ( bp [ 0 ] , 6 ) ;ND_PRINT ( ( ndo , ""\\\bp += 6 ;","if ( ND_TTEST2 ( bp [ 2 ] , 2 ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 6 ] ) ) ;if ( ndo -> ndo_vflag < 2 ) return ;bp += 8 ;len -= 8 ;ND_TCHECK2 ( bp [ 0 ] , 4 ) ;ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""\\\ND_TCHECK2 ( bp [ 4 ] , sizeof ( struct in_addr ) ) ;if ( EXTRACT_32BITS ( & bp [ 4 ] ) != 0xffffffff ) ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 4 ] ) ) ) ;ND_TCHECK2 ( bp [ 8 ] , 4 ) ;njoin = EXTRACT_16BITS ( & bp [ 8 ] ) ;nprune = EXTRACT_16BITS ( & bp [ 10 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>joined:<S2SV_blank>%d<S2SV_blank>pruned:<S2SV_blank>%d"" , njoin , nprune ) ) ;bp += 12 ;len -= 12 ;for ( njp = 0 ;ND_TCHECK2 ( bp [ 0 ] , 6 ) ;ND_PRINT ( ( ndo , ""\\\bp += 4 ;bp += 4 ;len -= 4 ;if ( len < 4 ) goto trunc ;",2860
542,"static void sas_destruct_devices ( struct work_struct * work )  {struct domain_device * dev , * n ;struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ;struct asd_sas_port * port = ev -> port ;clear_bit ( DISCE_DESTRUCT , & port -> disc . pending ) ;","void sas_destruct_devices ( struct work_struct * work ) {struct domain_device * dev , * n ;",2861
543,"int number_bidders , i , bid , best_bid ;struct archive_read_filter_bidder * bidder , * best_bidder ;for ( ;;) {number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ;","int number_bidders , i , bid , best_bid , n ;struct archive_read_filter_bidder * bidder , * best_bidder ;for ( n = 0 ;n < 25 ;++ n ) {number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ;",2862
544,"
","archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding"" ) ;return ( ARCHIVE_FATAL ) ;",2862
545,},},2862
546,flush_dcache_page ( page ) ;if ( ! tmp ) {,"iov_iter_advance ( ii , tmp ) ;flush_dcache_page ( page ) ;if ( ! tmp ) {",2863
547,"iov_iter_advance ( ii , tmp ) ;count += tmp ;",count += tmp ;,2863
548,numSamples = pWTIntFrame -> numSamples ;pOutputBuffer = pWTIntFrame -> pAudioBuffer ;,"numSamples = pWTIntFrame -> numSamples ;if ( numSamples <= 0 ) {ALOGE ( ""b/26366256"" ) ;return ;}pOutputBuffer = pWTIntFrame -> pAudioBuffer ;",2864
549,"RING_IDX cons = vif -> tx . req_cons ;int frags = 0 ;if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ;do {if ( frags >= work_to_do ) {netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\\return - frags ;netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\\return - frags ;","netdev_err ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\\netbk_fatal_tx_err ( vif ) ;return - frags ;netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\\return - frags ;netdev_err ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\\netbk_fatal_tx_err ( vif ) ;return - frags ;",2865
550,qemu_vfree ( r -> iov . iov_base ) ;},if ( r -> iov . iov_base ) {qemu_vfree ( r -> iov . iov_base ) ;}},2866
551,"if ( ! ( dev -> flags & IFF_UP ) )  return NET_RX_DROP ;if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) )   return NET_RX_DROP ;skb_set_dev ( skb , dev ) ;","if ( ! ( dev -> flags & IFF_UP ) || ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) ) {kfree_skb ( skb ) ;return NET_RX_DROP ;}skb_set_dev ( skb , dev ) ;",2867
552,"int ret , n ;quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ;","int ret , n ;int num_descriptors ;size_t offset = offsetof ( struct hid_descriptor , desc ) ;quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ;",2868
553,hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ;hid -> country = hdesc -> bCountryCode ;for ( n = 0 ;n < hdesc -> bNumDescriptors ;n ++ )  if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;,"if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) {dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\\return - EINVAL ;}hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ;hid -> country = hdesc -> bCountryCode ;num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) ;for ( n = 0 ;n < num_descriptors ;n ++ ) if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ;",2868
554,"void vp9_iht16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride ,  int tx_type ) {int16_t out [ 16 * 16 ] ;int16_t * outptr = out ;int16_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = IHT_16 [ tx_type ] ;","void vp9_iht16x16_256_add_c ( const tran_low_t * input , uint8_t * dest , int stride , int tx_type ) {tran_low_t out [ 16 * 16 ] ;tran_low_t * outptr = out ;int16_t temp_in [ 16 ] , temp_out [ 16 ] ;const transform_2d ht = IHT_16 [ tx_type ] ;",2869
555,"++ j ) temp_in [ j ] = out [ j * 16 + i ] ;for ( j = 0 ;++ j )   dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 )   + dest [ j * stride + i ] ) ;}","+ j ) temp_in [ j ] = out [ j * 16 + i ] ;++ j ) {temp_in [ j ] = out [ j * 16 + i ] ;for ( j = 0 ;+ j )   dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 )   + dest [ j * stride + i ] ) ;++ j ) dest [ j * stride + i ] = clip_pixel_add ( dest [ j * stride + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) ) ;}}",2869
556,"memset ( sax , 0 , sizeof ( sax ) ) ;sax -> sax25_family = AF_NETROM ;","memset ( sax , 0 , sizeof ( * sax ) ) ;sax -> sax25_family = AF_NETROM ;",2870
557,for ( j = 0 ;j < book -> dim ;j ++ )  a [ i ++ ] = v [ j ] ;,for ( j = 0 ;j < book -> dim && i < n ;j ++ ) a [ i ++ ] = v [ j ] ;,2871
558,for ( j = 0 ;j < book -> dim ;j ++ )  a [ i ++ ] = 0 ;,for ( j = 0 ;j < book -> dim && i < n ;j ++ ) a [ i ++ ] = 0 ;,2871
559,zip_object_handlers . get_properties = php_zip_get_properties ;zip_object_handlers . read_property = php_zip_read_property ;,zip_object_handlers . get_gc = php_zip_get_gc ;zip_object_handlers . get_properties = php_zip_get_properties ;zip_object_handlers . read_property = php_zip_read_property ;,2872
560,"case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;","case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN + 4 ) ;",2873
561,pptr += BGP_VPN_RD_LEN ;,pptr += BGP_VPN_RD_LEN + 4 ;,2873
562,"case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN :  ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;offset = strlen ( buf ) ;pptr += BGP_VPN_RD_LEN ;bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ;","case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ;offset = strlen ( buf ) ;pptr += BGP_VPN_RD_LEN ;bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ;",2873
563,"}commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ;","}if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ;",2874
564,"if ( ent != NULL ) {if ( ( st = populate_policy ( context , ld , ent , pol_name , * policy ) ) != 0 ) goto cleanup ;cleanup :  ldap_msgfree ( result ) ;","if ( ent == NULL ) {st = KRB5_KDB_NOENTRY ;goto cleanup ;st = populate_policy ( context , ld , ent , pol_name , * policy ) ;cleanup : ldap_msgfree ( result ) ;",2875
565,"static void sas_probe_devices ( struct work_struct * work )  {struct domain_device * dev , * n ;struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ;struct asd_sas_port * port = ev -> port ;clear_bit ( DISCE_PROBE , & port -> disc . pending ) ;","static void sas_probe_devices ( struct asd_sas_port * port ) {struct domain_device * dev , * n ;",2876
566,if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls >  JAS_UINTFAST32_NUMBITS - 2 ||  pirlvl -> prcheightexpn + pi -> picomp -> numrlvls >  JAS_UINTFAST32_NUMBITS - 2 ) {,if ( pirlvl -> prcwidthexpn + picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {,2877
567,"char * ext_name = NULL ;struct sshbuf * b = NULL ;goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}goto err ;}break ;case SSH_AGENT_CONSTRAIN_EXTENSION :  if ( ( r = sshbuf_get_cstring ( m , & ext_name , NULL ) ) != 0 ) {error_fr ( r , ""parse<S2SV_blank>constraint<S2SV_blank>extension"" ) ;goto err ;}debug_f ( ""constraint<S2SV_blank>ext<S2SV_blank>%s"" , ext_name ) ;if ( strcmp ( ext_name , ""sk-provider@openssh.com"" ) == 0 ) {if ( sk_providerp == NULL ) {error_f ( ""%s<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here"" , ext_name ) ;goto err ;}if ( * sk_providerp != NULL ) {error_f ( ""%s<S2SV_blank>already<S2SV_blank>set"" , ext_name ) ;goto err ;}if ( ( r = sshbuf_get_cstring ( m , sk_providerp , NULL ) ) != 0 ) {error_fr ( r , ""parse<S2SV_blank>%s"" , ext_name ) ;goto err ;}else {error_f ( ""unsupported<S2SV_blank>constraint<S2SV_blank>\\\\""%s\\\\"""" , ext_name ) ;goto err ;}free ( ext_name ) ;err :  free ( ext_name ) ;sshbuf_free ( b ) ;return - 1 ;return 0 ;","goto out ;}r = SSH_ERR_INVALID_FORMAT ;goto out ;}goto out ;}r = SSH_ERR_INVALID_FORMAT ;goto out ;}r = SSH_ERR_INVALID_FORMAT ;goto out ;}r = SSH_ERR_INVALID_FORMAT ;goto out ;}goto out ;}goto out ;break ;case SSH_AGENT_CONSTRAIN_EXTENSION : if ( ( r = parse_key_constraint_extension ( m , sk_providerp ) ) != 0 ) goto out ;r = SSH_ERR_FEATURE_UNSUPPORTED ;goto out ;r = 0 ;out : return r ;",2878
568,"sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ;if ( port_len ) snprintf ( port , 6 , ""%.*s"" , port_len , port_start ) ;","if ( url_len >= sizeof ( url_address ) ) {applog ( LOG_WARNING , ""%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\\\'%.*s\\\'"" , __func__ , url_len , url_begin ) ;url_len = sizeof ( url_address ) - 1 ;}sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ;if ( port_len ) snprintf ( port , 6 , ""%.*s"" , port_len , port_start ) ;",2879
569,"static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si ,  vp8_decrypt_cb * decrypt_cb ,  void * decrypt_state ) {","static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) {",2880
570,"int n = data_sz > 10 ? 10 : data_sz ;decrypt_cb ( decrypt_state , data , clear_buffer , n ) ;if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a )  res = VPX_CODEC_UNSUP_BITSTREAM ;si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ;","int n = MIN ( sizeof ( clear_buffer ) , data_sz ) ;decrypt_cb ( decrypt_state , data , clear_buffer , n ) ;if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) return VPX_CODEC_UNSUP_BITSTREAM ;si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ;",2880
571,"addr . sun_family = AF_UNIX ;strcpy ( addr . sun_path , sockFile ) ;","addr . sun_family = AF_UNIX ;if ( strlen ( sockFile ) + 1 > sizeof ( addr . sun_path ) ) {rfbClientErr ( ""ConnectToUnixSock:<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long\\\return - 1 ;}strcpy ( addr . sun_path , sockFile ) ;",2881
572,prev = NULL ;for ( vma = mm -> mmap ;,if ( ! mmget_still_valid ( mm ) ) goto skip_mm ;prev = NULL ;for ( vma = mm -> mmap ;,2882
573,up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,skip_mm : up_write ( & mm -> mmap_sem ) ;mmput ( mm ) ;,2882
574,"if ( ret )  return IMPEG2D_MB_TEX_DECODE_ERR ;IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ;","if ( ret ) return IMPEG2D_MB_TEX_DECODE_ERR ;if ( 0 >= ps_dec -> u2_num_mbs_left ) {break ;}IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ;",2883
575,"vpx_memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ;}","memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ;}",2884
576,"vpx_memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ;}","memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ;}",2884
577,"else if ( eobs [ 0 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ;vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}else if ( eobs [ 1 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dst + 4 , stride , dst + 4 , stride ) ;vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}else if ( eobs [ 2 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 32 ] * dq [ 0 ] , dst + 8 , stride , dst + 8 , stride ) ;vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}else if ( eobs [ 3 ] == 1 ) {vp8_dc_only_idct_add_mmx ( q [ 48 ] * dq [ 0 ] , dst + 12 , stride , dst + 12 , stride ) ;vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}","memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ;}",2885
578,"REMOVE_BITS ( 16 ) ;}if ( ! lzx -> header_read ) {j = 0 ;READ_BITS ( i , 1 ) ;if ( i ) {READ_BITS ( i , 16 ) ;READ_BITS ( j , 16 ) ;}lzx -> intel_filesize = ( i << 16 ) | j ;lzx -> header_read = 1 ;}frame_size = LZX_FRAME_SIZE ;if ( lzx -> length && ( lzx -> length - lzx -> offset ) < ( off_t ) frame_size ) {frame_size = lzx -> length - lzx -> offset ;}bytes_todo = lzx -> frame_posn + frame_size - window_posn ;while ( bytes_todo > 0 ) {if ( lzx -> block_remaining == 0 ) {if ( ( lzx -> block_type == LZX_BLOCKTYPE_UNCOMPRESSED ) && ( lzx -> block_length & 1 ) ) {READ_IF_NEEDED ;i_ptr ++ ;}READ_BITS ( lzx -> block_type , 3 ) ;READ_BITS ( i , 16 ) ;READ_BITS ( j , 8 ) ;lzx -> block_remaining = lzx -> block_length = ( i << 8 ) | j ;switch ( lzx -> block_type ) {case LZX_BLOCKTYPE_ALIGNED : for ( i = 0 ;i < 8 ;i ++ ) {READ_BITS ( j , 3 ) ;lzx -> ALIGNED_len [ i ] = j ;}BUILD_TABLE ( ALIGNED ) ;case LZX_BLOCKTYPE_VERBATIM : READ_LENGTHS ( MAINTREE , 0 , 256 ) ;READ_LENGTHS ( MAINTREE , 256 , LZX_NUM_CHARS + lzx -> num_offsets ) ;BUILD_TABLE ( MAINTREE ) ;if ( lzx -> MAINTREE_len [ 0xE8 ] != 0 ) lzx -> intel_started = 1 ;READ_LENGTHS ( LENGTH , 0 , LZX_NUM_SECONDARY_LENGTHS ) ;BUILD_TABLE_MAYBE_EMPTY ( LENGTH ) ;break ;case LZX_BLOCKTYPE_UNCOMPRESSED : lzx -> intel_started = 1 ;ENSURE_BITS ( 16 ) ;if ( bits_left > 16 ) i_ptr -= 2 ;","
",2886
579,"static void nsc_rle_decompress_data ( NSC_CONTEXT * context )  {rle = context -> Planes ;for ( i = 0 ;if ( planeSize == 0 )  FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ;else if ( planeSize < originalSize )   nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ;else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ;rle += planeSize ;}}","static BOOL nsc_rle_decompress_data ( NSC_CONTEXT * context ) {if ( ! context ) return FALSE ;rle = context -> Planes ;for ( i = 0 ;if ( planeSize == 0 ) {if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ;FillMemory ( context -> priv -> PlaneBuffers [ i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ;}else {if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ;CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ;}rle += planeSize ;}return TRUE ;}",2887
580,"struct sctp_endpoint * ep ;struct sctp_association * asoc ;struct list_head * pos , * temp ;unsigned int data_was_unread ;pr_debug ( ""%s:<S2SV_blank>sk:%p,<S2SV_blank>timeout:%ld\\\lock_sock ( sk ) ;sk -> sk_shutdown = SHUTDOWN_MASK ;sk -> sk_state = SCTP_SS_CLOSING ;ep = sctp_sk ( sk ) -> ep ;data_was_unread = sctp_queue_purge_ulpevents ( & sk -> sk_receive_queue ) ;data_was_unread += sctp_queue_purge_ulpevents ( & sctp_sk ( sk ) -> pd_lobby ) ;list_for_each_safe ( pos , temp , & ep -> asocs ) {asoc = list_entry ( pos , struct sctp_association , asocs ) ;if ( sctp_style ( sk , TCP ) ) {if ( sctp_state ( asoc , CLOSED ) ) {sctp_unhash_established ( asoc ) ;sctp_association_free ( asoc ) ;continue ;}}if ( data_was_unread || ! skb_queue_empty ( & asoc -> ulpq . lobby ) || ! skb_queue_empty ( & asoc -> ulpq . reasm ) || ( sock_flag ( sk , SOCK_LINGER ) && ! sk -> sk_lingertime ) ) {struct sctp_chunk * chunk ;chunk = sctp_make_abort_user ( asoc , NULL , 0 ) ;if ( chunk ) sctp_primitive_ABORT ( net , asoc , chunk ) ;}else sctp_primitive_SHUTDOWN ( net , asoc , NULL ) ;}if ( sctp_style ( sk , TCP ) && timeout ) sctp_wait_for_close ( sk , timeout ) ;release_sock ( sk ) ;local_bh_disable ( ) ;bh_lock_sock ( sk ) ;local_bh_enable ( ) ;sock_put ( sk ) ;",spin_lock_bh ( & net -> sctp . addr_wq_lock ) ;bh_lock_sock ( sk ) ;local_bh_enable ( ) ;sock_put ( sk ) ;,2888
581,"x < ( ( ssize_t ) image -> columns - 7 ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;}",x < ( ( ssize_t ) image -> columns - 3 ) ;,2889
582,for ( x = 0 ;x += 4 )  {,for ( x = 0 ;x += 4 ) {,2889
583,"p ++ ;q += GetPixelChannels ( image ) ;}if ( ( image -> columns % 4 ) != 0 ) {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;if ( ( image -> columns % 4 ) >= 1 )  {if ( ( image -> columns % 4 ) >= 2 )  {",p ++ ;}if ( ( image -> columns % 4 ) > 1 ) {if ( ( image -> columns % 4 ) >= 2 ) {,2889
584,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct tcp6_sock * newtcp6sk ;,const struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct ipv6_txoptions * opt ;struct tcp6_sock * newtcp6sk ;,2890
585,newnp -> saddr = newsk -> sk_v6_rcv_saddr ;inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ;newsk -> sk_backlog_rcv = tcp_v4_do_rcv ;# ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ;# endif newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;newnp -> pktoptions = NULL ;newnp -> opt = NULL ;newnp -> mcast_oif = tcp_v6_iif ( skb ) ;newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ;newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ;if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ;,opt = rcu_dereference ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ;,2890
586,"if ( np -> opt )   newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ;inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( newnp -> opt )   inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen +   newnp -> opt -> opt_flen ) ;tcp_ca_openreq_child ( newsk , dst ) ;","if ( np -> opt ) ;if ( opt ) {opt = ipv6_dup_options ( newsk , opt ) ;RCU_INIT_POINTER ( newnp -> opt , opt ) ;}inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ;if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + newnp -> opt -> opt_flen ;tcp_ca_openreq_child ( newsk , dst ) ;",2890
587,"static int cost_mv_ref ( const VP9_COMP * cpi , MB_PREDICTION_MODE mode ,   int mode_context ) {const MACROBLOCK * const x = & cpi -> mb ;return x -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ;}else {return 0 ;}","static int cost_mv_ref ( const VP9_COMP * cpi , PREDICTION_MODE mode , int mode_context ) {const MACROBLOCK * const x = & cpi -> mb ;return cpi -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ;",2891
588,"register u_int amt ;register u_int i ;int j ;int trunc ;if ( ndo -> ndo_snapend < dat ) return ;amt = ndo -> ndo_snapend - dat ;i = min ( length , amt ) ;if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ;i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ;case RIP6_REQUEST :  j = length / sizeof ( * ni ) ;if ( j == 1  && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6  && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ;else  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE :  j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 )  ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;i >= sizeof ( * ni ) ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( trunc )  ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;}if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;}","unsigned int length_left ;u_int j ;ND_TCHECK ( rp -> rip6_cmd ) ;case RIP6_REQUEST : j = length / sizeof ( * ni ) ;if ( j == 1 && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) {}if ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length ) ) ;else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) ) ;for ( ni = rp -> rip6_nets ;i -= sizeof ( * ni ) , ++ ni ) {if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\break ;case RIP6_RESPONSE : j = length / sizeof ( * ni ) ;if ( j * sizeof ( * ni ) != length - 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ;trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ;for ( ni = rp -> rip6_nets ;length_left >= sizeof ( * ni ) ;length_left -= sizeof ( * ni ) , ++ ni ) {ND_TCHECK ( * ni ) ;if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\\if ( length_left != 0 ) goto trunc ;}ND_TCHECK ( rp -> rip6_vers ) ;if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ;return ;trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ;return ;}",2892
589,if ( ! alt )  return - ENODEV ;,if ( ! alt ) return - ENODEV ;if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;,2893
590,"if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\","if ( q < p || q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\",2894
591,if ( ( ldblk > 9999 ) || ( ldblk < 0 ) )  break ;,if ( EOFBlob ( image ) ) break ;if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) break ;,2895
592,"}ui_seamless_seticon ( id , tok5 , width , height , chunk , icon_buf , len ) ;","if ( ( size_t ) len >= sizeof ( icon_buf ) ) {logger ( Protocol , Warning , ""seamless_process_line(),<S2SV_blank>icon<S2SV_blank>data<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>icon_buf"" ) ;break ;}}ui_seamless_seticon ( id , tok5 , width , height , chunk , icon_buf , len ) ;",2896
593,uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( cc % ( bps * stride ) != 0 ) {if ( ! tmp )  return 0 ;,uint8 * tmp ;if ( cc % ( bps * stride ) != 0 ) {tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ! tmp ) return 0 ;,2897
594,"if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  if ( copy_from_user ( & ifr , argp , ifreq_len ) )  return - EFAULT ;if ( cmd == TUNGETFEATURES ) {","if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) {if ( copy_from_user ( & ifr , argp , ifreq_len ) ) return - EFAULT ;}else memset ( & ifr , 0 , sizeof ( ifr ) ) ;if ( cmd == TUNGETFEATURES ) {",2898
595,"char src [ PATH_MAX + 1 ] ;memcpy ( src , dir , dir_len ) ;src [ dir_len ] = 0 ;return NULL ;}return dst ;","if ( dir_len > PATH_MAX ) {uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\\return NULL ;}char * src = uwsgi_concat2n ( dir , dir_len , """" , 0 ) ;free ( src ) ;return NULL ;}free ( src ) ;return dst ;",2899
596,"const int w = vpx_img_plane_width ( img , plane ) ;const int h = vpx_img_plane_height ( img , plane ) ;","const int w = vpx_img_plane_width ( img , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ;const int h = vpx_img_plane_height ( img , plane ) ;",2900
597,"err = device_register ( & bus -> dev ) ;if ( err ) {pr_err ( ""mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\\put_device ( & bus -> dev ) ;return - EINVAL ;",return - EINVAL ;,2901
598,"vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ;}","memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ;}",2902
599,default :  OVS_NOT_REACHED ( ) ;}default :  OVS_NOT_REACHED ( ) ;},default : return OFPERR_OFPGMFC_BAD_TYPE ;}default : return OFPERR_OFPGMFC_BAD_COMMAND ;},2903
600,if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,if ( sctp_chunk_pending ( ack ) ) continue ;if ( ack -> subh . addip_hdr -> serial == serial ) {sctp_chunk_hold ( ack ) ;,2904
601,"struct mb_cache_entry * ce ;if ( ! header -> h_hash ) return NULL ;again :  ce = mb_cache_entry_find_first ( ext2_xattr_cache , inode -> i_sb -> s_bdev ,  hash ) ;if ( IS_ERR ( ce ) ) {if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ;break ;}ext2_error ( inode -> i_sb , ""ext2_xattr_cache_find"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank>read<S2SV_blank>error"" ,  inode -> i_ino , ( unsigned long ) ce -> e_block ) ;}","struct mb2_cache_entry * ce ;struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache ;if ( ! header -> h_hash ) return NULL ;again : ce = mb2_cache_entry_find_first ( ext2_mb_cache , hash ) ;ext2_error ( inode -> i_sb , ""ext2_xattr_cache_find"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank>read<S2SV_blank>error"" , inode -> i_ino , ( unsigned long ) ce -> e_block ) ;}else {lock_buffer ( bh ) ;if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) {mb2_cache_entry_put ( ext2_mb_cache , ce ) ;unlock_buffer ( bh ) ;brelse ( bh ) ;goto again ;}else if ( le32_to_cpu ( HDR ( bh ) -> h_refcount ) > EXT2_XATTR_REFCOUNT_MAX ) {ea_idebug ( inode , ""block<S2SV_blank>%ld<S2SV_blank>refcount<S2SV_blank>%d>%d"" , ( unsigned long ) ce -> e_block ) ;}",2905
602,"mb_cache_entry_release ( ce ) ;return bh ;ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ;}","mb2_cache_entry_touch ( ext2_mb_cache , ce ) ;mb2_cache_entry_put ( ext2_mb_cache , ce ) ;return bh ;ce = mb2_cache_entry_find_next ( ext2_mb_cache , ce ) ;}",2905
603,"if ( skb -> protocol == htons ( ETH_P_IP ) ) return tcp_v4_do_rcv ( sk , skb ) ;if ( sk_filter ( sk , skb ) )  goto discard ;","if ( tcp_filter ( sk , skb ) ;if ( sk_filter ( sk , skb ) ) goto discard ;",2906
604,"for ( plane = 0 ;if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ;const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) : mbmi -> tx_size ;vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ;","mbmi -> skip = 1 ;if ( x -> skip ) return ;for ( plane = 0 ;if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ;const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , pd ) : mbmi -> tx_size ;vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ;",2907
605,"memmove ( s + j , s + qs , blen - qs ) ;j += blen - qs ;}","const int qslen = blen - qs ;memmove ( s + j , s + qs , ( size_t ) qslen ) ;qs = j ;j += qslen ;}",2908
606,if ( sec_attr == NULL ) {if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ;,if ( sec_attr == NULL || sec_attr_len ) {if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ;,2909
607,"U2FHID_INIT_RESP initresp ;if ( resplen > sizeof ( initresp ) )  {return U2FH_MEMORY_ERROR ;memcpy ( & initresp , resp , resplen ) ;dev -> cid = initresp . cid ;dev -> versionInterface = initresp . versionInterface ;dev -> versionMajor = initresp . versionMajor ;dev -> versionMinor = initresp . versionMinor ;dev -> capFlags = initresp . capFlags ;}","int offs = sizeof ( nonce ) ;if ( resplen < 17 ) {return U2FH_SIZE_ERROR ;}if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) {return U2FH_TRANSPORT_ERROR ;}dev -> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ;offs += 4 ;dev -> versionInterface = resp [ offs ++ ] ;dev -> versionMajor = resp [ offs ++ ] ;dev -> versionMinor = resp [ offs ++ ] ;dev -> versionBuild = resp [ offs ++ ] ;dev -> capFlags = resp [ offs ++ ] ;",2910
608,while ( f != upto ) ;},while ( f && f != upto ) ;},2911
609,"hash_param . data = 0 ;hash_param . len = 0 ;hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ;","hash_param . data = instance -> private_key ;hash_param . len = instance -> private_key_len ;hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ;",2912
610,ctxt -> dst . type = OP_REG ;ctxt -> dst . addr . reg = & ctxt -> _eip ;ctxt -> dst . bytes = ctxt -> op_bytes ;return em_pop ( ctxt ) ;,"int rc ;unsigned long eip ;rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ;return em_pop ( ctxt ) ;",2913
611,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,2914
612,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",2914
613,"spin_lock ( & key -> user -> lock ) ;key -> user -> qnkeys -- ;key -> user -> qnbytes -= key -> quotalen ;spin_unlock ( & key -> user -> lock ) ;}atomic_dec ( & key -> user -> nkeys ) ;if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ;key_user_put ( key -> user ) ;if ( key -> type -> destroy ) key -> type -> destroy ( key ) ;",spin_lock ( & key -> user ) ;,2915
614,"static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int nodigest , int nocontent )  {wfd = Fopen ( dest , ""w.ufdio"" ) ;umask ( old_umask ) ;}","static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int exclusive , int nodigest , int nocontent ) {wfd = Fopen ( dest , exclusive ? ""wx.ufdio"" : ""a.ufdio"" ) ;umask ( old_umask ) ;if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) {rc = RPMERR_OPEN_FAILED ;goto exit ;}}",2916
615,"int rose_parse_facilities ( unsigned char * p ,  struct rose_facilities_struct * facilities ) {if ( facilities_len == 0 )  return 0 ;while ( facilities_len > 0 ) {if ( * p == 0x00 ) {if ( len < 0 )  return 0 ;facilities_len -= len + 1 ;p += len + 1 ;if ( len < 0 )  return 0 ;facilities_len -= len + 1 ;p += len + 1 ;break ;default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\\facilities_len -- ;p ++ ;else break ;}return 1 ;","int rose_parse_facilities ( unsigned char * p , unsigned packet_len , struct rose_facilities_struct * facilities ) {if ( facilities_len == 0 || ( unsigned ) facilities_len > packet_len ) return 0 ;while ( facilities_len >= 3 && * p == 0x00 ) {break ;default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\\len = 1 ;if ( len < 0 ) return 0 ;if ( WARN_ON ( len >= facilities_len ) ) return 0 ;facilities_len -= len + 1 ;return facilities_len == 0 ;",2917
616,"if ( ! ( segment -> flags & TCP_FLAG_RST ) )  tcpSendSegment ( socket , TCP_FLAG_ACK , socket -> sndNxt , socket -> rcvNxt , 0 , FALSE ) ;return ERROR_FAILURE ;","if ( ! ( segment -> flags & TCP_FLAG_RST ) ) {tcpSendSegment ( socket , TCP_FLAG_ACK , socket -> sndNxt , socket -> rcvNxt , 0 , FALSE ) ;}return ERROR_FAILURE ;",2918
617,"int y4m_write_file_header ( char * buf , size_t len , int width , int height , const struct VpxRational * framerate ,  vpx_img_fmt_t fmt ) {const char * const color = fmt == VPX_IMG_FMT_444A ? ""C444alpha\\\return snprintf ( buf , len , ""YUV4MPEG2<S2SV_blank>W%u<S2SV_blank>H%u<S2SV_blank>F%u:%u<S2SV_blank>I%c<S2SV_blank>%s"" , width , height , framerate -> numerator , framerate -> denominator , \'p\' , color ) ;","int y4m_write_file_header ( char * buf , size_t len , int width , int height , const struct VpxRational * framerate , vpx_img_fmt_t fmt , unsigned int bit_depth ) {const char * color ;switch ( bit_depth ) {case 8 : color = fmt == VPX_IMG_FMT_444A ? ""C444alpha\\\break ;case 9 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p9<S2SV_blank>XYSCSS=444P9\\\break ;case 10 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p10<S2SV_blank>XYSCSS=444P10\\\break ;case 12 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p12<S2SV_blank>XYSCSS=444P12\\\break ;case 14 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p14<S2SV_blank>XYSCSS=444P14\\\break ;case 16 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p16<S2SV_blank>XYSCSS=444P16\\\break ;default : color = NULL ;assert ( 0 ) ;}return snprintf ( buf , len , ""YUV4MPEG2<S2SV_blank>W%u<S2SV_blank>H%u<S2SV_blank>F%u:%u<S2SV_blank>I%c<S2SV_blank>%s"" , width , height , framerate -> numerator , framerate -> denominator , \'p\' , color ) ;",2919
618,const VP9_CONFIG * oxcf = & cpi -> oxcf ;if ( oxcf -> rc_max_intra_bitrate_pct ) {const int max_rate = rc -> av_per_frame_bandwidth *  oxcf -> rc_max_intra_bitrate_pct / 100 ;,const VP9EncoderConfig * oxcf = & cpi -> oxcf ;if ( oxcf -> rc_max_intra_bitrate_pct ) {const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_intra_bitrate_pct / 100 ;,2920
619,"if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) {log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ;","if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS ) {log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ;",2921
620,"if ( flags & __GFP_ZERO )  memset ( addr , 0 , size ) ;","memset ( addr , 0 , size ) ;",2922
621,static SvcInternal * get_svc_internal ( SvcContext * svc_ctx ) {if ( svc_ctx == NULL ) return NULL ;SvcInternal * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ;if ( si != NULL ) {return ( SvcInternal * ) svc_ctx -> internal ;},static SvcInternal_t * get_svc_internal ( SvcContext * svc_ctx ) {if ( svc_ctx == NULL ) return NULL ;SvcInternal_t * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ;if ( si != NULL ) {return ( SvcInternal_t * ) svc_ctx -> internal ;},2923
622,"baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ;baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ;","if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ;baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ;",2924
623,"else  jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\\}","else {jsExceptionHere ( JSET_ERROR , ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\\return 0 ;}if ( gfx . data . height & 7 ) {jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\\return 0 ;}}",2925
624,"int vp9_prob_diff_update_savings_search ( const unsigned int * ct ,  vp9_prob oldp , vp9_prob * bestp ,   vp9_prob upd ) {const int old_b = cost_branch256 ( ct , oldp ) ;vp9_prob newp , bestnewp = oldp ;const int step = * bestp > oldp ? - 1 : 1 ;","int vp9_prob_diff_update_savings_search ( const unsigned int * ct , vpx_prob oldp , vpx_prob * bestp , vp9_prob upd ) {const int old_b = cost_branch256 ( ct , oldp ) ;vpx_prob newp , bestnewp = oldp ;const int step = * bestp > oldp ? - 1 : 1 ;",2926
625,if ( x & ( 1 << i ) ) return i ;},if ( x & ( 1U << ( unsigned int ) i ) ) return i ;},2927
626,"if ( secure_decrypt ( data , sizeof ( * header ) , 0 ) )   return - 1 ;header = ( const at91_secure_header_t * ) data ;if ( header -> magic != AT91_SECURE_MAGIC )  return - 1 ;file = ( unsigned char * ) data + sizeof ( * header ) ;return secure_decrypt ( file , header -> file_size , 1 ) ;}","int ret = - 1 ;if ( secure_decrypt ( data , sizeof ( * header ) , 0 ) ) goto secure_wipe_keys ;header = ( const at91_secure_header_t * ) data ;if ( header -> magic != AT91_SECURE_MAGIC ) goto secure_wipe_keys ;file = ( unsigned char * ) data + sizeof ( * header ) ;ret = secure_decrypt ( file , header -> file_size , 1 ) ;secure_wipe_keys : wipe_keys ( ) ;return ret ;}",2928
627,"if ( ! unqueue_me ( & q ) )  goto out_put_key ;ret = - ETIMEDOUT ;if ( to && ! to -> task )  goto out_put_key ;if ( ! signal_pending ( current ) ) {put_futex_key ( fshared , & q . key ) ;goto retry ;}ret = - ERESTARTSYS ;if ( ! abs_time )  goto out_put_key ;restart = & current_thread_info ( ) -> restart_block ;",if ( ! unqueue_me ( & q ) ) goto out ;ret = - ETIMEDOUT ;if ( to && ! to -> task ) goto out ;if ( ! signal_pending ( current ) ) goto retry ;}ret = - ERESTARTSYS ;if ( ! abs_time ) goto out_put_key ;restart = & current_thread_info ( ) -> restart_block ;,2929
628,"out_put_key :  put_futex_key ( fshared , & q . key ) ;","
",2929
629,u16 offset = sizeof ( struct ipv6hdr ) ;struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ;while ( offset + 1 <= packet_len ) {switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,u16 offset = sizeof ( struct ipv6hdr ) ;while ( offset <= packet_len ) {struct ipv6_opt_hdr * exthdr ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,2930
630,offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) +  offset ) ;return offset ;,if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ;exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ;offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;return - EINVAL ;,2930
631,"mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;","unsigned int status = 0 ;mm_segment_t old_fs ;if ( ! ur ) return sys_wait4 ( pid , ( unsigned int __user * ) & status , options , NULL ) ;ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ;set_fs ( old_fs ) ;err |= put_user ( status , ustatus ) ;err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ;err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ;",2931
632,"int get_vp9_frame_buffer ( void * cb_priv , size_t min_size ,  vpx_codec_frame_buffer_t * fb ) {","static int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {",2932
633,ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ;if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;,"ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) ) ;if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;",2932
634,"SkipRGBMipmaps ( image , dds_info , 4 ) ;return MagickTrue ;","return ( SkipRGBMipmaps ( image , dds_info , 4 , exception ) ) ;",2933
635,void * _TIFFmalloc ( tmsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,void * _TIFFmalloc ( tmsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,2934
636,"# ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds ,  & dec_tables ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds ,  & dec_tables ) ;# else return do_decrypt_fn ( ctx , bx , ax ) ;","# ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , dec_tables . T ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , dec_tables . T ) ;# else return do_decrypt_fn ( ctx , bx , ax ) ;",2935
637,if ( ret < 0 )  btrfs_release_path ( p ) ;,if ( ret < 0 && ! p -> skip_release_on_error ) btrfs_release_path ( p ) ;,2936
638,"Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\\return ;}if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) {Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\\\"".cfg\\\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\\return ;",2937
639,case CIPSO_V4_TAG_RBITMAP : if ( tag_len < CIPSO_V4_TAG_RBM_BLEN ) {,case CIPSO_V4_TAG_RBITMAP : if ( skb == NULL || tag_len < CIPSO_V4_TAG_RBM_BLEN ) {,2938
640,case CIPSO_V4_TAG_LOCAL :  if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) {err_offset = opt_iter ;,case CIPSO_V4_TAG_LOCAL : if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) {err_offset = opt_iter ;,2938
641,"size_t bytes_per_line , extent ,  height ,  length ;","size_t bytes_per_line , extent , height ;",2939
642,"if ( bytes_per_line == 0 )   bytes_per_line = image -> columns ;length = image -> rows * ( image -> columns + image -> columns % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;","
",2939
643,"SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 )  p ++ ;","SetPixelIndex ( image , * p ++ , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 ) p ++ ;",2939
644,"length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ;if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ssize_t ) image -> columns ;x ++ ) {","
",2939
645,"case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ;if ( L_ICANON ( tty ) )  retval = inq_canon ( ldata ) ;","case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) && ! L_EXTPROC ( tty ) , ( int __user * ) arg ) ;if ( L_ICANON ( tty ) ) retval = inq_canon ( ldata ) ;",2940
646,"slapi_pblock_get ( pb , SLAPI_SEARCH_SCOPE , & scope ) ;if ( scope == LDAP_SCOPE_BASE ) {char * * attrs = NULL ;slapi_pblock_get ( pb , SLAPI_SEARCH_ATTRS , & attrs ) ;if ( attrs ) {for ( size_t i = 0 ;attrs [ i ] ;i ++ ) {if ( ldbm_config_moved_attr ( attrs [ i ] ) ) {slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>required<S2SV_blank>attribute<S2SV_blank>has<S2SV_blank>been<S2SV_blank>moved<S2SV_blank>to<S2SV_blank>the<S2SV_blank>BDB<S2SV_blank>scecific<S2SV_blank>configuration<S2SV_blank>entry"" ) ;break ;","slapi_pblock_get ( pb , SLAPI_RESULT_TEXT , ""at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>required<S2SV_blank>attribute<S2SV_blank>has<S2SV_blank>been<S2SV_blank>moved<S2SV_blank>to<S2SV_blank>the<S2SV_blank>BDB<S2SV_blank>scecific<S2SV_blank>configuration<S2SV_blank>entry"" ) ;break ;",2941
647,ipc_lock_object ( & shp -> shm_perm ) ;path = shp -> shm_file -> f_path ;,ipc_lock_object ( & shp -> shm_perm ) ;if ( shp -> shm_file == NULL ) {ipc_unlock_object ( & shp -> shm_perm ) ;err = - EIDRM ;goto out_unlock ;}path = shp -> shm_file -> f_path ;,2942
648,"
",if ( af == NULL ) break ;,2943
649,"af -> from_addr_param ( & addr , addr_param ,  htons ( asoc -> peer . port ) , 0 ) ;","af -> from_addr_param ( & addr , addr_param , htons ( asoc -> peer . port ) , 0 ) ;",2943
650,"ih264d_create_op_t * ps_create_op ;WORD32 ret ;ps_create_op = ( ih264d_create_op_t * ) pv_api_op ;ret = ih264d_allocate_static_bufs ( & dec_hdl , pv_api_ip , pv_api_op ) ;if ( ( IV_FAIL == ret ) && ( NULL != dec_hdl ) )  {ih264d_free_static_bufs ( dec_hdl ) ;ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ;","ih264d_create_ip_t * ps_create_ip ;ih264d_create_op_t * ps_create_op ;WORD32 ret ;ps_create_ip = ( ih264d_create_ip_t * ) pv_api_ip ;ps_create_op = ( ih264d_create_op_t * ) pv_api_op ;dec_hdl = NULL ;ret = ih264d_allocate_static_bufs ( & dec_hdl , pv_api_ip , pv_api_op ) ;if ( IV_FAIL == ret ) && ( NULL != dec_hdl ) ) {ih264d_free_static_bufs ( dec_hdl ) ;}else {void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ;void * pv_mem_ctxt ;pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ;pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ;pf_aligned_free ( pv_mem_ctxt , dec_hdl ) ;}}ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ;",2944
651,suppress_route :  ip6_rt_put ( rt ) ;return true ;,suppress_route : if ( ! ( arg -> flags & FIB_LOOKUP_NOREF ) ) ip6_rt_put ( rt ) ;return true ;,2945
652,"if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;}return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;}","struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ;int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ;if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) {rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ;ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ;goto out ;}out : return ret ;}",2946
653,arg_allow_debuggers = 1 ;break ;,"struct utsname u ;int rv = uname ( & u ) ;if ( rv != 0 ) errExit ( ""uname"" ) ;int major ;int minor ;if ( 2 != sscanf ( u . release , ""%d.%d"" , & major , & minor ) ) {fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>extract<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version:<S2SV_blank>%s\\\exit ( 1 ) ;}if ( major < 4 || ( major == 4 && minor < 8 ) ) {fprintf ( stderr , ""Error:<S2SV_blank>--allow-debuggers<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>Linux<S2SV_blank>kernels<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>4.8.<S2SV_blank>"" ""A<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>ptrace<S2SV_blank>call<S2SV_blank>allows<S2SV_blank>a<S2SV_blank>full<S2SV_blank>bypass<S2SV_blank>of<S2SV_blank>the<S2SV_blank>seccomp<S2SV_blank>filter.<S2SV_blank>"" ""Your<S2SV_blank>current<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d.\\\exit ( 1 ) ;}arg_allow_debuggers = 1 ;break ;",2947
654,}else  inode -> i_gid = current_fsgid ( ) ;,"else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;}else inode -> i_gid = current_fsgid ( ) ;",2948
655,if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) )  return - ENXIO ;,"if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ;",2949
656,"long newpos ;JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\","size_t newpos ;JAS_DBGLOG ( 100 , ( ""mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\\",2950
657,uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,uint32_t data_siz ;uint16_t hmi_bpm = 0 ;uint16_t hmi_division = 0 ;,2951
658,}UNUSED ( hmi_size ) ;,"}if ( hmi_track_offset [ i ] >= hmi_size ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz = hmi_size - hmi_track_offset [ i ] ;",2951
659,"if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_track_offset [ i ] += hmi_tmp ;}else if ( hmi_data [ 1 ] == 0x15 ) {hmi_data += 4 ;}hmi_data += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;","if ( hmi_data [ 0 ] == 0xfe ) {if ( hmi_data [ 1 ] == 0x10 ) {hmi_tmp += 4 ;hmi_tmp = 8 ;}else {hmi_tmp = 4 ;}hmi_data += 4 ;if ( hmi_tmp > data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -= hmi_tmp ;}hmi_data += 4 ;hmi_track_offset [ i ] += 4 ;}if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , data_siz , hmi_running_event [ i ] ) ) == 0 ) {goto _hmi_end ;",2951
660,hmi_track_offset [ i ] += setup_ret ;note [ hmi_tmp ] . length = 0 ;if ( * hmi_data > 0x7f ) {do {note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;hmi_track_offset [ i ] ++ ;}}hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {,"data_siz -= setup_ret ;}}if ( data_siz && * hmi_data > 0x7f ) {do {if ( ! data_siz ) break ;if ( ! data_siz ) break ;note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ;data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;}}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}if ( ! data_siz ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmi_end ;}data_siz -- ;data_siz -- ;hmi_track_offset [ i ] ++ ;if ( note [ hmi_tmp ] . length ) {",2951
661,}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,}}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;}hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ;hmi_data ++ ;hmi_track_offset [ i ] ++ ;,2951
662,"char buf [ L_BUF_SIZE ] ;char * cmdstr , * plottitle , * dataname ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\\\'%s\\\'"" , gplot -> title ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\\\'%s\\\'"" , gplot -> xlabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\\\'%s\\\'"" , gplot -> ylabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE ,  ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" ,  gplot -> outname ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;","char buf [ L_BUFSIZE ] ;char * cmdstr , * plottitle , * dataname ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>title<S2SV_blank>\\\'%s\\\'"" , gplot -> title ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\\\'%s\\\'"" , gplot -> xlabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\\\'%s\\\'"" , gplot -> ylabel ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\\\'%s\\\'"" , gplot -> outname ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;snprintf ( buf , L_BUFSIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ;sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ;",2952
663,"snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;if ( i == 0 )  snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else if ( i < nplots - 1 )  snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else  snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" ,  dataname , plottitle , gplotstylenames [ plotstyle ] ) ;","snprintf ( buf , L_BUFSIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;if ( i == 0 ) snprintf ( buf , L_BUFSIZE , ""plot<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else if ( i < nplots - 1 ) snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s,<S2SV_blank>\\\\\\\\"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;else snprintf ( buf , L_BUFSIZE , ""<S2SV_blank>\\\'%s\\\'<S2SV_blank>title<S2SV_blank>\\\'%s\\\'<S2SV_blank>%s"" , dataname , plottitle , gplotstylenames [ plotstyle ] ) ;",2952
664,"struct rt6_info * rt = ( struct rt6_info * ) dst ;if ( ! dst )  goto out ;if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) {","struct rt6_info * rt ;if ( ! dst ) goto out ;if ( dst -> ops -> family != AF_INET6 ) {dst_release ( dst ) ;return NULL ;}rt = ( struct rt6_info * ) dst ;if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) {",2953
665,"struct mb_cache_entry * ce ;ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ;ea_bdebug ( bh , ""modifying<S2SV_blank>in-place"" ) ;if ( ce )  mb_cache_entry_free ( ce ) ;int offset ;if ( ce ) mb_cache_entry_release ( ce ) ;","__u32 hash = le32_to_cpu ( header -> h_hash ) ;ea_bdebug ( bh , ""modifying<S2SV_blank>in-place"" ) ;mb2_cache_entry_delete_block ( EXT2_SB ( sb ) -> s_mb_cache , hash , bh -> b_blocknr ) ;int offset ;",2954
666,u8 ip_proto = 0 ;if ( ! data ) {,u8 ip_proto = 0 ;bool ret = false ;if ( ! data ) {,2955
667,if ( ! iph || iph -> ihl < 5 )  return false ;nhoff += iph -> ihl * 4 ;,if ( ! iph || iph -> ihl < 5 ) goto out_bad ;nhoff += iph -> ihl * 4 ;,2955
668,if ( ! iph )  return false ;ip_proto = iph -> nexthdr ;,if ( ! iph ) goto out_bad ;ip_proto = iph -> nexthdr ;,2955
669,"if ( ! vlan )  return false ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) {","if ( ! vlan ) goto out_bad ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) {",2955
670,if ( ! hdr )  return false ;proto = hdr -> proto ;default :  return false ;},if ( ! hdr ) goto out_bad ;proto = hdr -> proto ;default : goto out_bad ;},2955
671,if ( ! hdr )  return false ;key_basic -> n_proto = proto ;key_control -> thoff = ( u16 ) nhoff ;return true ;}if ( ! hdr )  return false ;if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;return true ;return true ;default :  return false ;},if ( ! hdr ) goto out_bad ;goto out_good ;}if ( ! hdr ) goto out_bad ;if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {goto out_good ;goto out_good ;default : return false ;},2955
672,if ( ! hdr )  return false ;if ( hdr -> flags & ( GRE_VERSION | GRE_ROUTING ) ) break ;,if ( ! hdr ) goto out_bad ;if ( hdr -> flags & ( GRE_VERSION | GRE_ROUTING ) ) break ;,2955
673,"if ( ! keyid )  return false ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {","if ( ! keyid ) goto out_bad ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {",2955
674,if ( ! eth )  return false ;proto = eth -> h_proto ;,if ( ! eth ) goto out_bad ;proto = eth -> h_proto ;,2955
675,if ( ! opthdr )  return false ;ip_proto = opthdr [ 0 ] ;,if ( ! opthdr ) goto out_bad ;ip_proto = opthdr [ 0 ] ;,2955
676,"key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;if ( skb_flow_dissector_uses_key ( flow_dissector ,  FLOW_DISSECTOR_KEY_PORTS ) ) {return true ;","if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) {out_good : ret = true ;out_bad : key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;return ret ;",2955
677,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,2956
678,"VP8Frame * av_uninit ( curframe ) , * prev_frame ;if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ;","VP8Frame * av_uninit ( curframe ) , * prev_frame ;av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P ) ;if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ;",2957
679,"show ( obj , base , name , cb_data ) ;strbuf_addstr ( base , name ) ;","strbuf_addstr ( base , name ) ;show ( obj , base -> buf , cb_data ) ;",2958
680,int64_t off = s -> off ;int len = 0 ;,uint64_t off = s -> off ;int len = 0 ;,2959
681,"len += av_strlcatf ( headers + len , sizeof ( headers ) - len ,  ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ;if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ;","len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""Range:<S2SV_blank>bytes=%"" PRIu64 ""-"" , s -> off ) ;if ( s -> end_off ) len += av_strlcatf ( headers + len , sizeof ( headers ) - len , ""%"" PRId64 , s -> end_off - 1 ) ;",2959
682,s -> filesize = - 1 ;s -> willclose = 0 ;,s -> filesize = UINT64_MAX ;s -> willclose = 0 ;,2959
683,"size_t bits_per_pixel , map_length , number_colormaps ,  number_planes ,  one , offset , pixel_info_length ;","size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ;",2960
684,"if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ;pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ;","number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ;if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * number_planes_filled ;pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ;",2960
685,"static void cpStripToTile ( uint8 * out , uint8 * in ,  uint32 rows , uint32 cols , int outskew , int inskew )  {","static void cpStripToTile ( uint8 * out , uint8 * in , uint32 rows , uint32 cols , int outskew , int64 inskew ) {",2961
686,"if ( pos + 8 > len ) {return op -> size ;int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ,  max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ;","if ( pos + 8 + 8 > len ) {return op -> size ;const int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) ;const int max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ;",2962
687,"if ( ndo -> ndo_vflag )  ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ;p += 8 ;","if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ;p += 8 ;",2963
688,interface = intf -> cur_altsetting ;endpoint = & interface -> endpoint [ 0 ] . desc ;,interface = intf -> cur_altsetting ;if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL ;endpoint = & interface -> endpoint [ 0 ] . desc ;,2964
689,const char * bufptr ;bufptr = buf ;,"const char * bufptr ;if ( cnt < 0 ) {jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write"" ) ;}bufptr = buf ;",2965
690,"static void update_read_synchronize ( rdpUpdate * update , wStream * s )  {Stream_Seek_UINT16 ( s ) ;}","static BOOL update_read_synchronize ( rdpUpdate * update , wStream * s ) {return Stream_SafeSeek ( s , 2 ) ;}",2966
691,"case ICMP6_ROUTER_RENUMBERING_COMMAND : ND_PRINT ( ( ndo , ""router<S2SV_blank>renum:<S2SV_blank>command"" ) ) ;","case ICMP6_ROUTER_RENUMBERING_COMMAND : ND_PRINT ( ( ndo , ""%s"" , icmp6_tstr ) ) ;",2967
692,"trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}","trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}",2967
693,if ( ! new )  return - ENOMEM ;BUG_ON ( new -> thread_keyring ) ;,if ( ! new ) return - ENOMEM ;,2968
694,uchar buf [ JPG_MAGICLEN ] ;int i ;,jas_uchar buf [ JPG_MAGICLEN ] ;int i ;,2969
695,"
",ps_dec -> u2_forw_f_code = 7 ;ps_dec -> u2_back_f_code = 7 ;,2970
696,ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ;},ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ;},2970
697,"memcpy ( vs_param_set -> ie , priv -> vs_ie [ id ] . ie ,  le16_to_cpu ( vs_param_set -> header . len ) ) ;","if ( le16_to_cpu ( vs_param_set -> header . len ) > MWIFIEX_MAX_VSIE_LEN ) {mwifiex_dbg ( priv -> adapter , ERROR , ""Invalid<S2SV_blank>param<S2SV_blank>length!\\\break ;}memcpy ( vs_param_set -> ie , priv -> vs_ie [ id ] . ie , le16_to_cpu ( vs_param_set -> header . len ) ) ;",2971
698,"static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out )  {int i ;Rune c ;for ( ;switch ( pc -> opcode ) {case I_END :  return 1 ;case I_JUMP : pc = pc -> x ;if ( match ( pc -> x , sp , bol , flags , & scratch ) ) {* out = scratch ;return 1 ;}case I_PLA :  if ( ! match ( pc -> x , sp , bol , flags , out ) )  return 0 ;if ( match ( pc -> x , sp , bol , flags , & scratch ) )  return 0 ;if ( c == 0 )  return 0 ;pc = pc + 1 ;break ;case I_ANY : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( isnewline ( c ) )  return 0 ;pc = pc + 1 ;break ;case I_CHAR : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) c = canon ( c ) ;if ( c != pc -> c )  return 0 ;pc = pc + 1 ;break ;case I_CCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) {if ( ! incclasscanon ( pc -> cc , canon ( c ) ) )  return 0 ;}else {if ( ! incclass ( pc -> cc , c ) )  return 0 ;}case I_NCCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 )  return 0 ;if ( flags & REG_ICASE ) {if ( incclasscanon ( pc -> cc , canon ( c ) ) )  return 0 ;}else {if ( incclass ( pc -> cc , c ) )  return 0 ;}case I_REF : i = out -> sub [ pc -> n ] . ep - out -> sub [ pc -> n ] . sp ;if ( strncmpcanon ( sp , out -> sub [ pc -> n ] . sp , i ) )  return 0 ;}else {if ( strncmp ( sp , out -> sub [ pc -> n ] . sp , i ) )  return 0 ;}if ( i > 0 ) sp += i ;","static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out , int depth ) {int result ;int i ;Rune c ;if ( depth > MAXREC ) return - 1 ;for ( ;switch ( pc -> opcode ) {case I_END : return 0 ;case I_JUMP : pc = pc -> x ;result = match ( pc -> x , sp , bol , flags , & scratch , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 0 ) {* out = scratch ;return 0 ;}case I_PLA : result = match ( pc -> x , sp , bol , flags , out , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 1 ) return 1 ;result = match ( pc -> x , sp , bol , flags , & scratch , depth + 1 ) ;if ( result == - 1 ) return - 1 ;if ( result == 0 ) return 1 ;if ( c == 0 ) return 1 ;if ( c == 0 ) return 0 ;if ( isnewline ( c ) ) return 0 ;case I_CHAR : sp += chartorune ( & c , sp ) ;if ( c == 0 ) return 0 ;if ( flags & REG_ICASE ) c = canon ( c ) ;if ( c != pc -> c ) return 0 ;case I_CCLASS : sp += chartorune ( & c , sp ) ;if ( c == 0 ) return 0 ;if ( ! incclasscanon ( pc -> cc , canon ( c ) ) ) return 1 ;",2972
699,return 0 ;case I_EOL : if ( * sp == 0 ) {,return 0 ;case I_EOL : if ( * sp == 0 ) {,2972
700,return 0 ;case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ;if ( ! i )  return 0 ;pc = pc + 1 ;if ( i )  return 0 ;pc = pc + 1 ;,return 0 ;case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ;if ( ! i ) return 0 ;pc = pc + 1 ;if ( i ) return 0 ;pc = pc + 1 ;,2972
701,default :  return 0 ;},default : return 1 ;},2972
702,"m -> msg_namelen = 0 ;target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;","target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;",2973
703,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,2974
704,"else {ret . code = kadm5_get_policies ( ( void * ) handle , arg -> exp , & ret . pols , & ret . count ) ;if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ;log_done ( ""kadm5_get_policies"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ;if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ;}gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",2974
705,"gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) ,  _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;","gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ;if ( nautilus_file_can_set_permissions ( file ) ) {gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK ) ;}gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ;",2975
706,size_t size = ( alignment - MALLOC_ALIGNMENT ) + bytes ;void * base = leak_malloc ( size ) ;,size_t size = ( alignment - MALLOC_ALIGNMENT ) + bytes ;if ( size < bytes ) {return NULL ;}void * base = leak_malloc ( size ) ;,2976
707,},"hook_del_nick_can_register ( check_registration_keywords ) ;hook_del_user_can_register ( check_registration_keywords ) ;del_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table ) ;}",2977
708,"skb -> ip_summed = CHECKSUM_PARTIAL ;skb -> csum = 0 ;__skb_queue_tail ( queue , skb ) ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;","skb -> csum = 0 ;__skb_queue_tail ( queue , skb ) ;}else if ( skb_is_gso ( skb ) ) {goto append ;}skb -> ip_summed = CHECKSUM_PARTIAL ;append : return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",2978
709,"r = - ENOMEM ;if ( ! u . lapic ) goto out ;r = kvm_vcpu_ioctl_get_lapic ( vcpu , u . lapic ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( argp , u . lapic , sizeof ( struct kvm_lapic_state ) ) ) goto out ;r = 0 ;break ;}case KVM_SET_LAPIC : {r = - EINVAL ;if ( ! vcpu -> arch . apic ) goto out ;u . lapic = memdup_user ( argp , sizeof ( * u . lapic ) ) ;if ( IS_ERR ( u . lapic ) ) return PTR_ERR ( u . lapic ) ;r = kvm_vcpu_ioctl_set_lapic ( vcpu , u . lapic ) ;break ;}case KVM_INTERRUPT : {struct kvm_interrupt irq ;r = - EFAULT ;if ( copy_from_user ( & irq , argp , sizeof irq ) ) goto out ;r = kvm_vcpu_ioctl_interrupt ( vcpu , & irq ) ;break ;}case KVM_NMI : {r = kvm_vcpu_ioctl_nmi ( vcpu ) ;break ;}case KVM_SET_CPUID : {struct kvm_cpuid __user * cpuid_arg = argp ;struct kvm_cpuid cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_set_cpuid ( vcpu , & cpuid , cpuid_arg -> entries ) ;break ;}case KVM_SET_CPUID2 : {struct kvm_cpuid2 __user * cpuid_arg = argp ;struct kvm_cpuid2 cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_set_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ;break ;}case KVM_GET_CPUID2 : {struct kvm_cpuid2 __user * cpuid_arg = argp ;struct kvm_cpuid2 cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_get_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( cpuid_arg , & cpuid , sizeof cpuid ) ) goto out ;r = 0 ;break ;}case KVM_GET_MSRS : r = msr_io ( vcpu , argp , kvm_get_msr , 1 ) ;break ;case KVM_SET_MSRS : r = msr_io ( vcpu , argp , do_set_msr , 0 ) ;break ;case KVM_TPR_ACCESS_REPORTING : {struct kvm_tpr_access_ctl tac ;r = - EFAULT ;if ( copy_from_user ( & tac , argp , sizeof tac ) ) goto out ;r = vcpu_ioctl_tpr_access_reporting ( vcpu , & tac ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( argp , & tac , sizeof tac ) ) goto out ;r = 0 ;break ;};case KVM_SET_VAPIC_ADDR : {struct kvm_vapic_addr va ;r = - EINVAL ;if ( ! irqchip_in_kernel ( vcpu -> kvm ) ) goto out ;r = - EFAULT ;if ( copy_from_user ( & va , argp , sizeof va ) ) goto out ;r = 0 ;kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ;","r = kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ;",2979
710,"FIRSTPASS_STATS this_frame ;const FIRSTPASS_STATS * start_pos ;struct twopass_rc * twopass = & cpi -> twopass ;const VP9_CONFIG * const oxcf = & cpi -> oxcf ;const int is_spatial_svc = ( svc -> number_spatial_layers > 1 ) &&   ( svc -> number_temporal_layers == 1 ) ;double frame_rate ;if ( is_spatial_svc ) {twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ;}twopass -> total_stats = * twopass -> stats_in_end ;twopass -> total_left_stats = twopass -> total_stats ;frame_rate = 10000000.0 * twopass -> total_stats . count /  twopass -> total_stats . duration ;if ( is_spatial_svc ) {vp9_update_spatial_layer_framerate ( cpi , frame_rate ) ;twopass -> bits_left =  ( int64_t ) ( twopass -> total_stats . duration *  svc -> layer_context [ svc -> spatial_layer_id ] . target_bandwidth / 10000000.0 ) ;twopass -> bits_left = ( int64_t ) ( twopass -> total_stats . duration *  oxcf -> target_bandwidth / 10000000.0 ) ;}cpi -> output_framerate = oxcf -> framerate ;if ( ! is_spatial_svc ) {twopass -> kf_intra_err_min = KF_MB_INTRA_MIN * cpi -> common . MBs ;twopass -> gf_intra_err_min = GF_MB_INTRA_MIN * cpi -> common . MBs ;double sum_iiratio = 0.0 ;start_pos = twopass -> stats_in ;while ( input_stats ( twopass , & this_frame ) != EOF ) {const double iiratio = this_frame . intra_error / DOUBLE_DIVIDE_CHECK ( this_frame . coded_error ) ;","const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;const int is_spatial_svc = ( svc -> number_spatial_layers > 1 ) && ( svc -> number_temporal_layers > 1 ) ;double frame_rate ;if ( is_spatial_svc ) {twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass : & cpi -> twopass ;double frame_rate ;FIRSTPASS_STATS * stats ;stats = & twopass -> total_stats ;* stats = * twopass -> stats_in_end ;twopass -> total_left_stats = * stats ;frame_rate = 10000000.0 * twopass -> total_stats . count / twopass -> total_stats . duration ;if ( is_two_pass_svc ) {vp9_update_spatial_layer_framerate ( cpi , frame_rate ) ;twopass -> bits_left = ( int64_t ) ( stats -> duration * svc -> layer_context [ svc -> spatial_layer_id ] . target_bandwidth / 10000000.0 ) ;twopass -> bits_left = ( int64_t ) ( stats -> duration * oxcf -> target_bandwidth / 10000000.0 ) ;double sum_iiratio = 0.0 ;start_pos = twopass -> stats_in ;while ( input_stats ( twopass , & this_frame ) != EOF ) {const double iiratio = this_frame . intra_error / DOUBLE_DIVIDE_CHECK ( this_frame . coded_error ) ;",2980
711,"twopass -> modified_error_min = ( av_error * oxcf -> two_pass_vbrmin_section ) / 100 ;twopass -> modified_error_max = ( av_error * oxcf -> two_pass_vbrmax_section ) / 100 ;twopass -> modified_error_total +=  calculate_modified_err ( cpi , & this_frame ) ;}twopass -> modified_error_left = twopass -> modified_error_total ;reset_fpf_position ( twopass , start_pos ) ;","twopass -> modified_error_min = ( avg_error * oxcf -> two_pass_vbrmin_section ) / 100 ;twopass -> modified_error_max = ( avg_error * oxcf -> two_pass_vbrmax_section ) / 100 ;twopass -> modified_error_total += calculate_modified_err ( cpi , twopass , oxcf , s ) ;++ s ;}twopass -> modified_error_left = modified_error_total ;}cpi -> rc . vbr_bits_off_target = 0 ;cpi -> rc . vbr_bits_off_target_fast = 0 ;cpi -> rc . rate_error_estimate = 0 ;twopass -> kf_zeromotion_pct = 100 ;twopass -> last_kfgroup_zeromotion_pct = 100 ;if ( oxcf -> resize_mode != RESIZE_NONE ) {vp9_init_subsampling ( cpi ) ;",2980
712,int overflow_error = 0 ;res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ;if ( ! res ) {,"size_t weights_size ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {return NULL ;}else {weights_size = windows_size * sizeof ( double ) ;}res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ;if ( ! res ) {",2981
713,"for ( u = 0 ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ;}u -- ;for ( i = 0 ;gdFree ( res -> ContribRow [ i ] . Weights ) ;","for ( u = 0 ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ;}u -- ;for ( i = 0 ;gdFree ( res -> ContribRow [ i ] . Weights ) ;",2981
714,"Stream_Read_UINT16 ( s ,  bitmapData -> cbCompFirstRowSize ) ;","if ( Stream_GetRemainingLength ( s ) < 8 ) return FALSE ;Stream_Read_UINT16 ( s , bitmapData -> cbCompFirstRowSize ) ;",2982
715,struct siginfo info ;info . si_signo = sig ;,struct siginfo info = {};info . si_signo = sig ;,2983
716,"DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\\return - EINVAL ;","DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\\return - EINVAL ;}if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) {DRM_DEBUG ( ""execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\\return - EINVAL ;",2984
717,"if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & lineno , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) {","if ( lookup_attr_id ( obj , & PyId_lineno ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_lineno , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {else {",2985
718,"if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_boolop ( tmp , & op , arena ) ;else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""op\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_values ) ) {int res ;Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_values ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""BoolOp<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;}len = PyList_GET_SIZE ( tmp ) ;values = _Ta3_asdl_seq_new ( len , arena ) ;if ( values == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""BoolOp<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( values , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ;* out = BoolOp ( op , values , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;","if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) {int res ;res = obj2ast_int ( tmp , & lineno , arena ) ;if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""col_offset\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>expr"" ) ;else {int res ;res = obj2ast_boolop ( tmp , & col_offset , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;",2985
719,"if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & left , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & left , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
720,"if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""right\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ;return 1 ;}* out = BinOp ( left , op , right , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) UnaryOp_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}tmp = _PyObject_GetAttrId ( obj , & PyId_operand ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & operand , arena ) ;else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""operand\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp"" ) ;* out = UnaryOp ( op , operand , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Lambda_type ) ;if ( isinstance == - 1 ) {if ( isinstance ) {arguments_ty args ;expr_ty body ;if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( lookup_attr_id ( obj , ( PyObject * ) UnaryOp_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}res = obj2ast_boolop ( tmp , & op , arena ) ;if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ;else {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
721,"if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & test , arena ) ;if ( res != 0 ) goto failed ;","if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & test , arena ) ;if ( res != 0 ) goto failed ;",2985
722,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_keys ) ;",Py_ssize_t i ;,2985
723,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( keys , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""keys\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ;return 1 ;}if ( _PyObject_HasAttrId ( obj , & PyId_values ) ) {int res ;Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_values ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""Dict<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;}len = PyList_GET_SIZE ( tmp ) ;values = _Ta3_asdl_seq_new ( len , arena ) ;if ( values == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Dict<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;asdl_seq_SET ( values , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ;return 1 ;","expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( keys , i , val ) ;",2985
724,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_elts ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_elts ) ;",2985
725,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , value ) ;}Py_CLEAR ( tmp ) ;}if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ListComp_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , value ) ;}Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , ( PyObject * ) ListComp_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;",2985
726,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;",2985
727,"comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}","comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
728,"if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;","if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;",2985
729,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;",2985
730,"comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}","comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
731,"if ( _PyObject_HasAttrId ( obj , & PyId_key ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_key ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & key , arena ) ;if ( res != 0 ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""key\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ;","if ( _PyObject_HasAttrId ( obj , & PyId_key ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_key ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & key , arena ) ;if ( res != 0 ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""key\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ;",2985
732,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;",2985
733,"comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}","comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
734,"if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;","if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ;if ( tmp == NULL ) goto failed ;",2985
735,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_generators ) ;",2985
736,"comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}","comprehension_ty value ;res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( generators , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
737,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
738,"if ( exists_not_none ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( exists_not_none ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
739,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
740,"if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & left , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""left\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_ops ) ) {Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_ops ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""Compare<S2SV_blank>field<S2SV_blank>\\\\""ops\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;}len = PyList_GET_SIZE ( tmp ) ;ops = _Ta3_asdl_int_seq_new ( len , arena ) ;if ( ops == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {cmpop_ty value ;res = obj2ast_cmpop ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Compare<S2SV_blank>field<S2SV_blank>\\\\""ops\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( ops , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""ops\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ;return 1 ;if ( _PyObject_HasAttrId ( obj , & PyId_comparators ) ) {int res ;Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_comparators ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""Compare<S2SV_blank>field<S2SV_blank>\\\\""comparators\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;len = PyList_GET_SIZE ( tmp ) ;comparators = _Ta3_asdl_seq_new ( len , arena ) ;if ( comparators == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Compare<S2SV_blank>field<S2SV_blank>\\\\""comparators\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;asdl_seq_SET ( comparators , i , value ) ;}Py_CLEAR ( tmp ) ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""comparators\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ;return 1 ;","if ( _PyObject_HasAttrId ( obj , & PyId_left , & tmp ) < 0 ) {return 1 ;if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""left\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ;else {res = obj2ast_expr ( tmp , & left , arena ) ;if ( res != 0 ) goto failed ;if ( lookup_attr_id ( obj , & PyId_op , & tmp ) < 0 ) {return 1 ;if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""op\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ;return 1 ;int res ;res = obj2ast_operator ( tmp , & right , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;",2985
741,"if ( _PyObject_HasAttrId ( obj , & PyId_func ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_func ) ;if ( tmp == NULL ) goto failed ;","if ( _PyObject_HasAttrId ( obj , & PyId_func ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_func ) ;if ( tmp == NULL ) goto failed ;",2985
742,"Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;","Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ;",2985
743,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( args , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""args\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_keywords ) ;","expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( args , i , value ) ;}}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""args\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_keywords ) ;",2985
744,"keyword_ty value ;res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;if ( len != PyList_GET_SIZE ( tmp ) ) {PyErr_SetString ( PyExc_RuntimeError , ""Call<S2SV_blank>field<S2SV_blank>\\\\""keywords\\\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ;goto failed ;}asdl_seq_SET ( keywords , i , value ) ;}Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""keywords\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ;return 1 ;}* out = Call ( func , args , keywords , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Num_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_n ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_n ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","keyword_ty value ;res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( lookup_attr_id ( obj , ( PyObject * ) Num_type ) ;if ( _PyObject_HasAttrId ( obj , & PyId_n ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_n ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
745,"if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_string ( tmp , & s , arena ) ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""s\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Str"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_kind ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_kind ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_string ( tmp , & kind , arena ) ;else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""kind\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Str"" ) ;return 1 ;}","if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) {int res ;res = obj2ast_unaryop ( tmp , & op , arena ) ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_operand , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""operand\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp"" ) ;return 1 ;}else {res = obj2ast_expr ( tmp , & operand , arena ) ;",2985
746,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & value , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FormattedValue"" ) ;return 1 ;}if ( exists_not_none ( obj , & PyId_conversion ) ) {","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( lookup_attr_id ( obj , & PyId_conversion ) ) {",2985
747,"tmp = _PyObject_GetAttrId ( obj , & PyId_format_spec ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & format_spec , arena ) ;format_spec = NULL ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) JoinedStr_type ) ;","res = obj2ast_arguments ( tmp , & args , arena ) ;if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Lambda"" ) ;return 1 ;}int res ;res = obj2ast_expr ( tmp , & body , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , ( PyObject * ) JoinedStr_type ) ;",2985
748,"Py_ssize_t len ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_values ) ;if ( tmp == NULL ) goto failed ;if ( ! PyList_Check ( tmp ) ) {PyErr_Format ( PyExc_TypeError , ""JoinedStr<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ;goto failed ;len = PyList_GET_SIZE ( tmp ) ;values = _Ta3_asdl_seq_new ( len , arena ) ;if ( values == NULL ) goto failed ;for ( i = 0 ;i < len ;i ++ ) {expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( values , i , value ) ;}Py_CLEAR ( tmp ) ;}","res = obj2ast_expr ( tmp , & test , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""body\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ;return 1 ;}else {int res ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( values , i , value ) ;}Py_CLEAR ( tmp ) ;}",2985
749,"if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_bytes ( tmp , & s , arena ) ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""s\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Bytes"" ) ;* out = Bytes ( s , lineno , col_offset , arena ) ;isinstance = PyObject_IsInstance ( obj , ( PyObject * ) NameConstant_type ) ;singleton value ;if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_bytes ( tmp , & body , arena ) ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""orelse\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ;return 1 ;}else {int res ;res = obj2ast_expr ( tmp , & orelse , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}* out = IfExp ( test , body , orelse , lineno , col_offset , arena ) ;isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Dict_type ) ;asdl_seq * keys ;asdl_seq * values ;if ( lookup_attr_id ( obj , & PyId_keys , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""keys\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ;return 1 ;}else {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
750,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
751,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ;tmp = _PyObject_GetAttrId ( obj , & PyId_attr ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ;tmp = _PyObject_GetAttrId ( obj , & PyId_attr ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
752,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ;tmp = _PyObject_GetAttrId ( obj , & PyId_slice ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;}PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""value\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ;tmp = _PyObject_GetAttrId ( obj , & PyId_slice ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
753,"if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
754,"if ( _PyObject_HasAttrId ( obj , & PyId_id ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_id ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","if ( _PyObject_HasAttrId ( obj , & PyId_id ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_id ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
755,"if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_elts ) ;","if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) {int res ;Py_ssize_t i ;",2985
756,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""elts\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>List"" ) ;if ( _PyObject_HasAttrId ( obj , & PyId_ctx ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_ctx ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}","expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , val ) ;}}if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) {if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""values\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ;return 1 ;}else {tmp = _PyObject_GetAttrId ( obj , & PyId_ctx ) ;if ( tmp == NULL ) goto failed ;Py_CLEAR ( tmp ) ;}",2985
757,"if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) {int res ;Py_ssize_t i ;tmp = _PyObject_GetAttrId ( obj , & PyId_elts ) ;","if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) {int res ;Py_ssize_t i ;",2985
758,"expr_ty value ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , value ) ;}}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""elts\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ;return 1 ;if ( _PyObject_HasAttrId ( obj , & PyId_ctx ) ) {","expr_ty val ;res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ;if ( res != 0 ) goto failed ;asdl_seq_SET ( elts , i , val ) ;}* out = Dict ( keys , values , lineno , col_offset , arena ) ;if ( * out == NULL ) goto failed ;return 0 ;}isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Set_type ) ;if ( isinstance == - 1 ) {return 1 ;}if ( isinstance ) {asdl_seq * elts ;if ( lookup_attr_id ( obj , & PyId_elts , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""elts\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Set"" ) ;return 1 ;}else {",2985
759,"else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""ctx\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ;return 1 ;}","
",2985
760,"static const char *  parse_field ( netdissect_options * ndo , const char * * pptr , int * len )  {if ( * len <= 0 || ! pptr || ! * pptr )  return NULL ;if ( * pptr > ( const char * ) ndo -> ndo_snapend ) return NULL ;while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) {( * pptr ) ++ ;( * len ) -- ;}if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend )  return NULL ;","static const char * parse_field ( netdissect_options * ndo , const char * * pptr , int * len , int * truncated ) {while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) {",2986
761,if ( ! ( assigned_dev -> flags & KVM_DEV_ASSIGN_ENABLE_IOMMU ) )  return - EINVAL ;,u8 header_type ;if ( ! ( assigned_dev -> flags & KVM_DEV_ASSIGN_ENABLE_IOMMU ) ) return - EINVAL ;,2987
762,"if ( pci_enable_device ( dev ) ) {printk ( KERN_INFO ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>enable<S2SV_blank>PCI<S2SV_blank>device\\\","pci_read_config_byte ( dev , PCI_HEADER_TYPE , & header_type ) ;if ( ( header_type & PCI_HEADER_TYPE ) != PCI_HEADER_TYPE_NORMAL ) {r = - EPERM ;goto out_put ;}r = probe_sysfs_permissions ( dev ) ;if ( r ) goto out_put ;if ( pci_enable_device ( dev ) ) {printk ( KERN_INFO ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>enable<S2SV_blank>PCI<S2SV_blank>device\\\",2987
763,flush_rq -> mq_ctx = first_rq -> mq_ctx ;flush_rq -> tag = first_rq -> tag ;},"struct blk_mq_hw_ctx * hctx ;flush_rq -> mq_ctx = first_rq -> mq_ctx ;flush_rq -> tag = first_rq -> tag ;fq -> orig_rq = first_rq ;hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ;blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq ) ;}",2988
764,struct kvm_lapic * apic = vcpu -> arch . apic ;void * vapic ;,struct kvm_lapic * apic = vcpu -> arch . apic ;,2989
765,vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;* ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ;kunmap_atomic ( vapic ) ;,"kvm_write_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ;",2989
766,dtls1_process_buffered_records ( s ) ;if ( dtls1_get_processed_record ( s ) ) return 1 ;,if ( dtls1_process_buffered_records ( s ) < 0 ) return - 1 ;if ( dtls1_get_processed_record ( s ) ) return 1 ;,2990
767,"dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ;}return ( 1 ) ;}","if ( dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) < 0 ) return - 1 ;dtls1_record_bitmap_update ( s , bitmap ) ;}dtls1_record_bitmap_update ( s , bitmap ) ;return ( 1 ) ;}",2990
768,if ( ctx -> img_avail ) {if ( ! ( * iter ) ) {img = & ctx -> img ;* iter = img ;ctx -> img_avail = 0 ;,"if ( ctx -> frame_parallel_decode && ctx -> available_threads > 0 && ! ctx -> flushed ) {return NULL ;if ( ctx -> num_cache_frames > 0 ) {release_last_output_frame ( ctx ) ;ctx -> last_show_frame = ctx -> frame_cache [ ctx -> frame_cache_read ] . fb_idx ;if ( ctx -> need_resync ) return NULL ;img = & ctx -> frame_cache [ ctx -> frame_cache_read ] . img ;ctx -> frame_cache_read = ( ctx -> frame_cache_read + 1 ) % FRAME_CACHE_SIZE ;-- ctx -> num_cache_frames ;return img ;}if ( * iter == NULL && ctx -> frame_workers != NULL ) {do {YV12_BUFFER_CONFIG sd ;vp9_ppflags_t flags = {0 , 0 , 0 };const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ;VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_output_worker_id ] ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;ctx -> next_output_worker_id = ( ctx -> next_output_worker_id + 1 ) % ctx -> num_frame_workers ;if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) set_ppflags ( ctx , & flags ) ;if ( winterface -> sync ( worker ) ) {if ( frame_worker_data -> received_frame == 1 ) {++ ctx -> available_threads ;frame_worker_data -> received_frame = 0 ;check_resync ( ctx , frame_worker_data -> pbi ) ;if ( vp9_get_raw_frame ( frame_worker_data -> pbi , & sd , & flags ) == 0 ) {VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ;RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ;release_last_output_frame ( ctx ) ;ctx -> last_show_frame = frame_worker_data -> pbi -> common . new_fb_idx ;if ( ctx -> need_resync ) return NULL ;yuvconfig2image ( & ctx -> img , & sd , frame_worker_data -> user_priv ) ;ctx -> img . fb_priv = frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ;img = & ctx -> img ;}else {frame_worker_data -> received_frame = 0 ;++ ctx -> available_threads ;ctx -> need_resync = 1 ;if ( ctx -> flushed != 1 ) return NULL ;}}while ( ctx -> next_output_worker_id != ctx -> next_submit_worker_id ) ;}return NULL ;}",2991
769,". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = type -> match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , }int ret ;if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ;",". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , }int ret ;if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ;",2992
770,pairs = palloc ( count * sizeof ( Pairs ) ) ;for ( i = 0 ;,"if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;pairs = palloc ( count * sizeof ( Pairs ) ) ;for ( i = 0 ;",2993
771,"ptr = realloc ( priv -> EF_C_DevAut , len ) ;if ( ptr ) {priv -> EF_C_DevAut_len = len ;}","if ( len > 0 ) {ptr = realloc ( priv -> EF_C_DevAut , len ) ;if ( ptr ) {priv -> EF_C_DevAut_len = len ;}}",2994
772,"DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ;if ( ! fields ) {","const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ;DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ;if ( ! fields ) {",2995
773,unsigned long len = php_mysqlnd_net_field_length ( & p ) ;if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) {,"const unsigned long len = php_mysqlnd_net_field_length ( & p ) ;if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) {php_error_docref ( NULL , E_WARNING , ""Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>"" MYSQLND_SZ_T_SPEC ""<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet"" , ( p + len ) - packet_end - 1 ) ;DBG_RETURN ( FAIL ) ;}if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) {",2995
774,return ;},return 0 ;},2996
775,kfree ( rm -> atomic . op_notifier ) ;return ret ;,rm -> atomic . op_active = 0 ;kfree ( rm -> atomic . op_notifier ) ;return ret ;,2997
776,idata -> status = IMAP_FATAL ;return ;,"idata -> status = IMAP_FATAL ;return ;}if ( strlen ( idata -> buf ) < litlen ) {mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\\return ;",2998
777,l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;l_mco_size = 5 + l_tcp -> m_nb_mcc_records ;,l_mco_size = 5 + l_tcp -> m_nb_mcc_records ;,2999
778,"opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ;l_current_data += 2 ;","l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ;l_current_data += 2 ;",2999
779,return true ;},"if ( IS ( req -> method , METHOD_POST ) ) {const char * cookie = get_header ( req , ""Cookie"" ) ;const char * token = get_parameter ( req , ""securitytoken"" ) ;if ( ! cookie ) {LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>cookie\\\send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ;return false ;}if ( ! token ) {LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>parameter\\\send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ;return false ;}if ( ! Str_startsWith ( cookie , ""securitytoken="" ) ) {LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>no<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>cookie\\\send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ;return false ;}if ( Str_compareConstantTime ( cookie + 14 , token ) ) {LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>mismatch\\\send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ;return false ;}}return true ;}",3000
780,"int n = 0 , size = 0 , ret = - EFAULT ;struct perf_event_context * ctx = leader -> ctx ;u64 values [ 5 ] ;mutex_lock ( & ctx -> mutex ) ;","struct perf_event_context * ctx = leader -> ctx ;int n = 0 , size = 0 , ret ;u64 values [ 5 ] ;lockdep_assert_held ( & ctx -> mutex ) ;",3001
781,"if ( copy_to_user ( buf , values , size ) ) goto unlock ;","if ( copy_to_user ( buf , values , size ) ) return - EFAULT ;",3001
782,ret = - EFAULT ;goto unlock ;}unlock :  mutex_unlock ( & ctx -> mutex ) ;,ret = - EFAULT ;goto unlock ;}unlock : mutex_unlock ( & ctx -> mutex ) ;,3001
783,"int setpwnam ( struct passwd * pwd )  {int save_errno ;int found ;int namelen ;int buflen = 256 ;int contlen , rc ;char * linebuf = NULL ;char * tmpname = NULL ;char * atomic_dir = ""/etc"" ;pw_init ( ) ;if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL )  return - 1 ;","int setpwnam ( struct passwd * pwd , const char * prefix ) {pw_init ( ) ;if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) return - 1 ;",3002
784,"if ( mwifiex_map_pci_memory ( adapter , skb , MAX_EVENT_SIZE ,  PCI_DMA_FROMDEVICE ) )  return - 1 ;buf_pa = MWIFIEX_SKB_DMA_ADDR ( skb ) ;mwifiex_dbg ( adapter , EVENT , ""info:<S2SV_blank>EVT<S2SV_blank>ring:<S2SV_blank>skb=%p<S2SV_blank>len=%d<S2SV_blank>data=%p<S2SV_blank>buf_pa=%#x:%x\\\","if ( mwifiex_map_pci_memory ( adapter , skb , MAX_EVENT_SIZE , PCI_DMA_FROMDEVICE ) ) {kfree_skb ( skb ) ;kfree ( card -> evtbd_ring_vbase ) ;return - 1 ;}buf_pa = MWIFIEX_SKB_DMA_ADDR ( skb ) ;mwifiex_dbg ( adapter , EVENT , ""info:<S2SV_blank>EVT<S2SV_blank>ring:<S2SV_blank>skb=%p<S2SV_blank>len=%d<S2SV_blank>data=%p<S2SV_blank>buf_pa=%#x:%x\\\",3003
785,if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ;if ( count < sizeof ( cmd . type ) ) {ret = - EINVAL ;,3004
786,done = EAS_TRUE ;},"if ( pWTIntFrame -> numSamples < 0 ) {ALOGE ( ""b/26366256"" ) ;pWTIntFrame -> numSamples = 0 ;}done = EAS_TRUE ;}",3005
787,"if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;status = AcquireImageColormap ( image , image -> colors , exception ) ;if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;}break ;}case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {unsigned char * viff_colormap ;switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;break ;case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}image -> colors = viff_info . map_columns ;if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;lsb_first = 1 ;if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : {MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;break ;}default : break ;}for ( i = 0 ;i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;i ++ ) {switch ( ( int ) viff_info . map_storage_type ) {case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;break ;case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;break ;default : value = 1.0 * viff_colormap [ i ] ;break ;}if ( i < ( ssize_t ) image -> colors ) {image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;}viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;break ;}default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ;}image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ;image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;image -> columns = viff_info . rows ;image -> rows = viff_info . columns ;if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;switch ( ( int ) viff_info . data_storage_type ) {case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;break ;case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;break ;case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;break ;case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;break ;default : bytes_per_pixel = 1 ;break ;}if ( viff_info . data_storage_type == VFF_TYP_BIT )  max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;else  max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ;","if ( viff_info . data_storage_type == VFF_TYP_BIT ) {if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ;",3006
788,"static void show_object ( struct object * obj ,  struct strbuf * path , const char * last ,  void * data ) {char * name = path_name ( path , last ) ;add_preferred_base_object ( name ) ;free ( ( char * ) name ) ;}","static void show_object ( struct object * obj , const char * last , void * data ) {char * name = path_name ( path , last ) ;add_preferred_base_object ( name ) ;}",3007
789,"cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ;DPRINTF ( ( ""Chain:"" ) ) ;","cdf_secid_t maxsector = ( cdf_secid_t ) ( ( sat -> sat_len * size ) / sizeof ( maxsector ) ) ;DPRINTF ( ( ""Chain:"" ) ) ;",3008
790,"if ( sid > maxsector ) {DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\\","if ( sid >= maxsector ) {DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\\",3008
791,if ( keepinvariant ( g ) ) {,if ( g -> gckind == KGC_INC ) if ( keepinvariant ( g ) ) {,3009
792,"makewhite ( g , o ) ;}","makewhite ( g , o ) ;}",3009
793,"if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) {error ( ""Cannot<S2SV_blank>normalize<S2SV_blank>URL:<S2SV_blank>%s"" , url ) ;","if ( ( wp -> path = websValidateUriPath ( path ) ) == 0 ) {error ( ""Cannot<S2SV_blank>normalize<S2SV_blank>URL:<S2SV_blank>%s"" , url ) ;",3010
794,while ( ibuf [ ind ] == 0x01 ) {if ( ibuf [ ind + 1 ] == 0xFE ) {,while ( ibuf [ ind ] == 0x01 && i < gemsafe_cert_max ) {if ( ibuf [ ind + 1 ] == 0xFE ) {,3011
795,if ( src_end - src < zsize )  return AVERROR_INVALIDDATA ;,if ( src_end - src < zsize + ( sub_type != 2 ) ) return AVERROR_INVALIDDATA ;,3012
796,bitbuf = * src ++ ;bits = 8 ;,if ( src >= src_end ) return AVERROR_INVALIDDATA ;bitbuf = * src ++ ;bits = 8 ;,3012
797,"
","if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) {av_log ( NULL , AV_LOG_ERROR , ""RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\\ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ;prev_pkt [ channel_id ] . read = 0 ;}",3013
798,"if ( ! prev_pkt [ channel_id ] . read ) {if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ;","if ( ! prev_pkt [ channel_id ] . read ) {if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ;",3013
799,int nAlloc = pSrc -> nSrc * 2 + nExtra ;sqlite3 * db = pParse -> db ;,sqlite3_int64 nAlloc = 2 * ( sqlite3_int64 ) pSrc -> nSrc + nExtra ;sqlite3 * db = pParse -> db ;,3014
800,get_page ( * page ) ;out : ret = 0 ;,if ( unlikely ( ! try_get_page ( * page ) ) ) {ret = - ENOMEM ;goto unmap ;}out : ret = 0 ;,3015
801,for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ;,for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ;,3016
802,len = dp -> ip6r_len ;ep = ndo -> ndo_snapend ;,ep = ndo -> ndo_snapend ;len = dp -> ip6r_len ;,3017
803,"if ( js_regexec ( re -> prog , source , & m , 0 ) ) {js_copy ( J , 0 ) ;","if ( js_doregexec ( J , re -> prog , source , & m , 0 ) ) {js_copy ( J , 0 ) ;",3018
804,"if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) )  goto loop ;","if ( ! js_doregexec ( J , re -> prog , source , & m , REG_NOTBOL ) ) goto loop ;",3018
805,"struct oabi_flock64 user ;struct flock64 kernel ;mm_segment_t fs = USER_DS ;unsigned long local_arg = arg ;int ret ;case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 :  if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg ,  sizeof ( user ) ) ) return - EFAULT ;","case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 : if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , sizeof ( user ) ) ) return - EFAULT ;",3019
806,"ret = sys_fcntl64 ( fd , cmd , local_arg ) ;switch ( cmd ) {case F_GETLK64 : if ( ! ret ) {user . l_type = kernel . l_type ;user . l_whence = kernel . l_whence ;user . l_start = kernel . l_start ;user . l_len = kernel . l_len ;user . l_pid = kernel . l_pid ;if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - EFAULT ;case F_SETLK64 : case F_SETLKW64 : set_fs ( fs ) ;return ret ;}","ret = sys_fcntl64 ( fd , cmd , arg ) ;",3019
807,if ( err < 0 ) return err ;,if ( err < 0 < 0 ) return err ;,3020
808,if ( err )  goto err_free_dev ;,if ( err ) goto err_free_dev ;,3020
809,chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ;chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ;,chm -> index_root >= chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ;,3021
810,"if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) {D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ;","if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) {D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ;",3021
811,name = p ;READ_ENCINT ( section ) ;,if ( name_len == 0 ) goto chunk_end ;name = p ;READ_ENCINT ( section ) ;,3021
812,if ( ! file )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,3022
813,"memcpy ( res , dbg_data , nb10sz ) ;res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ;","
",3023
814,"if ( istreq ( str , ""all"" ) ) {* val_rtrn = MOD_REAL_MASK_ALL ;","if ( ! str ) return false ;if ( istreq ( str , ""all"" ) ) {* val_rtrn = MOD_REAL_MASK_ALL ;",3024
815,"conn -> c_trans = trans ;ret = trans -> conn_alloc ( conn , gfp ) ;","if ( trans == NULL ) {kmem_cache_free ( rds_conn_slab , conn ) ;conn = ERR_PTR ( - ENODEV ) ;goto out ;}conn -> c_trans = trans ;ret = trans -> conn_alloc ( conn , gfp ) ;",3025
816,release_sock ( sk ) ;return 0 ;,msg -> msg_namelen = 0 ;release_sock ( sk ) ;return 0 ;,3026
817,"case suite :  if ( NCH ( n ) == 1 )  return num_stmts ( CHILD ( n , 0 ) ) ;l = 0 ;for ( i = 2 ;i ++ )  l += num_stmts ( CHILD ( n , i ) ) ;","case suite : case func_body_suite : if ( NCH ( n ) == 1 ) return num_stmts ( CHILD ( n , 0 ) ) ;i = 2 ;l = 0 ;if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 ;for ( ;i ++ ) l += num_stmts ( CHILD ( n , i ) ) ;",3027
818,"amount = n_got * sizeof ( ut32 ) ;if ( amount < n_got || amount > UT32_MAX ) {goto out_error ;}struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ;if ( got_table ) {",amount = n_got * sizeof ( struct reloc_struct_t ) ) ;if ( got_table ) {,3028
819,"void vp9_loop_filter_rows ( const YV12_BUFFER_CONFIG * frame_buffer ,   VP9_COMMON * cm , MACROBLOCKD * xd ,  int start , int stop , int y_only ) {int mi_row , mi_col ;LOOP_FILTER_MASK lfm ;int use_420 = y_only || ( xd -> plane [ 1 ] . subsampling_y == 1 &&   xd -> plane [ 1 ] . subsampling_x == 1 ) ;for ( mi_row = start ;MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + mi_row * cm -> mi_stride ;for ( mi_col = 0 ;vp9_setup_dst_planes ( xd , frame_buffer , mi_row , mi_col ) ;if ( use_420 )   vp9_setup_mask ( cm , mi_row , mi_col , mi_8x8 + mi_col , cm -> mi_stride ,  & lfm ) ;for ( plane = 0 ;if ( use_420 )  vp9_filter_block_plane ( cm , & xd -> plane [ plane ] , mi_row , & lfm ) ;else filter_block_plane_non420 ( cm , & xd -> plane [ plane ] , mi_8x8 + mi_col , mi_row , mi_col ) ;}}","void vp9_loop_filter_rows ( YV12_BUFFER_CONFIG * frame_buffer , VP9_COMMON * cm , struct macroblockd_plane planes [ MAX_MB_PLANE ] , int start , int stop , int y_only ) {enum lf_path path ;LOOP_FILTER_MASK lfm ;int use_420 = y_only || ( xd -> plane [ 1 ] . subsampling_y == 1 && planes [ 1 ] . subsampling_x == 1 ) path = LF_PATH_420 ;else if ( planes [ 1 ] . subsampling_y == 0 && planes [ 1 ] . subsampling_x == 0 ) path = LF_PATH_444 ;else path = LF_PATH_SLOW ;for ( mi_row = start ;MODE_INFO * * mi = cm -> mi_grid_visible + mi_row * cm -> mi_stride ;for ( mi_col = 0 ;vp9_setup_dst_planes ( planes , frame_buffer , mi_row , mi_col ) ;vp9_setup_mask ( cm , mi_row , mi_col , mi_8x8 + mi_col , cm -> mi_stride , & lfm ) ;vp9_filter_block_plane_ss00 ( cm , & planes [ 0 ] , mi_row , & lfm ) ;for ( plane = 1 ;switch ( path ) {case LF_PATH_420 : vp9_filter_block_plane_ss11 ( cm , & planes [ plane ] , mi_row , & lfm ) ;break ;case LF_PATH_444 : vp9_filter_block_plane_ss00 ( cm , & planes [ plane ] , mi_row , & lfm ) ;break ;case LF_PATH_SLOW : vp9_filter_block_plane_non420 ( cm , & planes [ plane ] , mi + mi_col , mi_row , mi_col ) ;break ;}}}",3029
820,if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) )  return rdesc ;,if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ;if ( * rsize < 4 ) return rdesc ;,3030
821,if ( config -> listener_count == 0 # ifdef WITH_TLS || config -> default_listener . cafile || config -> default_listener . capath || config -> default_listener . certfile || config -> default_listener . keyfile || config -> default_listener . ciphers || config -> default_listener . psk_hint || config -> default_listener . require_certificate || config -> default_listener . crlfile || config -> default_listener . use_identity_as_username || config -> default_listener . use_subject_as_username # endif || config -> default_listener . use_username_as_clientid || config -> default_listener . host || config -> default_listener . port || config -> default_listener . max_connections != - 1 || config -> default_listener . mount_point || config -> default_listener . protocol != mp_mqtt || config -> default_listener . socket_domain || config -> default_listener . security_options . password_file || config -> default_listener . security_options . psk_file || config -> default_listener . security_options . auth_plugin_config_count || config -> default_listener . security_options . allow_anonymous != - 1 ) {,if ( config -> listener_count == 0 # ifdef WITH_TLS || config -> default_listener . cafile || config -> default_listener . capath || config -> default_listener . certfile || config -> default_listener . keyfile || config -> default_listener . ciphers || config -> default_listener . psk_hint || config -> default_listener . require_certificate || config -> default_listener . crlfile || config -> default_listener . use_identity_as_username || config -> default_listener . use_subject_as_username # endif || config -> default_listener . use_username_as_clientid || config -> default_listener . host || config -> default_listener . port || config -> default_listener . max_connections != - 1 || config -> default_listener . mount_point || config -> default_listener . protocol != mp_mqtt || config -> default_listener . socket_domain || config -> default_listener . security_options . acl_file = config -> default_listener . security_options . acl_file ;config -> listeners [ config -> listener_count - 1 ] . security_options . password_file || config -> default_listener . security_options . psk_file || config -> default_listener . security_options . auth_plugin_config_count || config -> default_listener . security_options . allow_anonymous != - 1 ) {,3031
822,# endif  config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ;config -> listeners [ config -> listener_count - 1 ] . security_options . psk_file = config -> default_listener . security_options . psk_file ;,# endif config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ;config -> listeners [ config -> listener_count - 1 ] . security_options . psk_file = config -> default_listener . security_options . psk_file ;,3031
823,"
","if ( ext4_has_feature_meta_bg ( sb ) ) {if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) {ext4_msg ( sb , KERN_WARNING , ""first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)"" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ;goto failed_mount ;}}",3032
824,"db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) /  EXT4_DESC_PER_BLOCK ( sb ) ;sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ;","db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / EXT4_DESC_PER_BLOCK ( sb ) ;sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ;",3032
825,"int j , len = apdu . resp [ i + 1 ] ;unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ;","size_t j , len = apdu . resp [ i + 1 ] ;unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ;",3033
826,"case 0x84 :  memcpy ( file -> name , d , len ) ;file -> namelen = len ;break ;","case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ;memcpy ( file -> name , d , file -> namelen = len ;break ;",3033
827,"dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) ,   s -> s3 -> rrec . seq_num ) ;}","if ( dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , s -> s3 -> rrec . seq_num ) < 0 ) return - 1 ;}",3034
828,"if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) &&   ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) ||   ! same_thread_group ( rtn , current ) ||  ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_SIGNAL ) ) return NULL ;if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) &&   ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) )   return NULL ;return task_pid ( rtn ) ;}","switch ( event -> sigev_notify & SIGEV_THREAD_ID ) && ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ;if ( ! rtn || ! same_thread_group ( rtn , current ) ) return NULL ;if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && ( ( event -> sigev_signo <= 0 || event -> sigev_signo > SIGRTMAX ) ) ) return NULL ;case SIGEV_NONE : return task_pid ( rtn ) ;default : return NULL ;}}",3035
829,"frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ;len = min ( 8u , frag -> len ) ;if ( ! vcpu -> mmio_is_write ) memcpy ( frag -> data , run -> mmio . data , len ) ;if ( frag -> len <= 8 ) {frag ++ ;vcpu -> mmio_cur_fragment ++ ;}else {frag -> data += len ;frag -> gpa += len ;frag -> len -= len ;}if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) {vcpu -> mmio_needed = 0 ;",frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment >= vcpu -> mmio_nr_fragments ) {vcpu -> mmio_needed = 0 ;,3036
830,"r = parse_gid ( e + 1 , & gid ) ;if ( r < 0 ) goto not_found ;","if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;r = parse_gid ( e + 1 , & gid ) ;if ( r < 0 ) goto not_found ;",3037
831,pch -> file . dead = 1 ;wake_up_interruptible ( & pch -> file . rwait ) ;,put_net ( pch -> chan_net ) ;pch -> chan_net = NULL ;pch -> file . dead = 1 ;wake_up_interruptible ( & pch -> file . rwait ) ;,3038
832,"dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ;dm9000WriteReg ( DM9000_REG_EPDRL , LSB ( data ) ) ;dm9000WriteReg ( DM9000_REG_EPDRH , MSB ( data ) ) ;dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRW ) ;while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 )  {dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ;}","dm9000WriteReg ( DM9000_EPAR , 0x40 | address ) ;dm9000WriteReg ( DM9000_EPDRL , LSB ( data ) ) ;dm9000WriteReg ( DM9000_EPDRH , MSB ( data ) ) ;dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW ) ;while ( ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE ) != 0 ) {dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS ) ;}",3039
833,"if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ;__TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ;if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ;th = ( const struct tcphdr * ) skb -> data ;if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ;if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ;if ( skb_checksum_init ( skb , IPPROTO_TCP , inet_compute_pseudo ) ) goto csum_error ;th = ( const struct tcphdr * ) skb -> data ;iph = ip_hdr ( skb ) ;memmove ( & TCP_SKB_CB ( skb ) -> header . h4 , IPCB ( skb ) , sizeof ( struct inet_skb_parm ) ) ;barrier ( ) ;TCP_SKB_CB ( skb ) -> seq = ntohl ( th -> seq ) ;TCP_SKB_CB ( skb ) -> end_seq = ( TCP_SKB_CB ( skb ) -> seq + th -> syn + th -> fin + skb -> len - th -> doff * 4 ) ;TCP_SKB_CB ( skb ) -> ack_seq = ntohl ( th -> ack_seq ) ;TCP_SKB_CB ( skb ) -> tcp_flags = tcp_flag_byte ( th ) ;TCP_SKB_CB ( skb ) -> tcp_tw_isn = 0 ;TCP_SKB_CB ( skb ) -> ip_dsfield = ipv4_get_dsfield ( iph ) ;TCP_SKB_CB ( skb ) -> sacked = 0 ;lookup : sk = __inet_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , & refcounted ) ;if ( ! sk ) goto no_tcp_socket ;process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ;if ( sk -> sk_state == TCP_NEW_SYN_RECV ) {struct request_sock * req = inet_reqsk ( sk ) ;struct sock * nsk ;sk = req -> rsk_listener ;if ( unlikely ( tcp_v4_inbound_md5_hash ( sk , skb ) ) ) {","if ( tcp_filter ( sk , skb ) ) ) {",3040
834,"if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;skb -> dev = NULL ;","th = ( const struct tcphdr * ) skb -> data ;iph = ip_hdr ( skb ) ;if ( sk_filter ( sk , skb ) ) goto discard_and_relse ;skb -> dev = NULL ;",3040
835,goto retry ;},"err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ;if ( err ) goto out ;err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ;if ( err ) goto out ;goto retry ;}",3041
836,"
",if ( retval == 0 && server_ptr == NULL ) retval = KRB5_KDB_NOENTRY ;,3042
837,"cleanup :  if ( retval != 0 )  * status = ""UNKNOWN_SERVER"" ;","cleanup : if ( retval != 0 ) * status = ""UNKNOWN_SERVER"" ;",3042
838,"else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) )  continue ;}if ( pmd_none_or_clear_bad ( pmd ) )   continue ;next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ;cond_resched ( ) ;","else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) ) goto next ;}if ( pmd_none_or_clear_bad ( pmd ) ) goto next ;next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ;next : cond_resched ( ) ;",3043
839,"REQ ( CHILD ( n , 0 ) , ASYNC ) ;switch ( TYPE ( CHILD ( n , 1 ) ) ) {case funcdef :  return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , NULL ,   1 ) ;case with_stmt :  return ast_for_with_stmt ( c , CHILD ( n , 1 ) ,  1 ) ;case for_stmt :  return ast_for_for_stmt ( c , CHILD ( n , 1 ) ,  1 ) ;","REQ ( CHILD ( n , 0 ) , NAME ) ;assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ;switch ( TYPE ( CHILD ( n , 1 ) ) ) {case funcdef : return ast_for_funcdef_impl ( c , n , NULL , 1 ) ;case with_stmt : return ast_for_with_stmt ( c , n , true ) ;case for_stmt : return ast_for_for_stmt ( c , CHILD ( n , 1 ) , 1 ) ;",3044
840,"
",ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;,3045
841,"bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ;ND_PRINT ( ( ndo , ""\\\","bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ;ND_PRINT ( ( ndo , ""\\\",3045
842,},trunc : return - 1 ;},3045
843,metadatalength = GetDuration ( mp4 ) ;if ( metadatalength > 0.0 ) {,"if ( mp4 == 0 ) {printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\\return - 1 ;}metadatalength = GetDuration ( mp4 ) ;if ( metadatalength > 0.0 ) {",3046
844,"float in = 0.0 , out = 0.0 ;payload = GetPayload ( mp4 , payload , index ) ;","double in = 0.0 , out = 0.0 ;payload = GetPayload ( mp4 , payload , index ) ;",3046
845,"
","double in = 0.0 , out = 0.0 ;",3046
846,"uint32_t fourcc = GPMF_Key ( ms ) ;double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ;printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\\}","uint32_t fourcc = GPMF_Key ( ms ) ;double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ;printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\\}",3046
847,"stmt_ty  For ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int  lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {","stmt_ty For ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {",3047
848,p -> v . For . orelse = orelse ;p -> lineno = lineno ;,p -> v . For . orelse = orelse ;p -> v . For . type_comment = type_comment ;p -> lineno = lineno ;,3047
849,"hide_shell ( shell_visible ? 1 : 0 ) ;if ( shell_visible ) gui_mode = 2 ;}break ;default : break ;}}return 0 ;}switch ( evt -> type ) {case GF_EVENT_DURATION : Duration = ( u64 ) ( 1000 * ( s64 ) evt -> duration . duration ) ;CanSeek = evt -> duration . can_seek ;break ;case GF_EVENT_MESSAGE : {const char * servName ;if ( ! evt -> message . service || ! strcmp ( evt -> message . service , the_url ) ) {servName = """" ;}else if ( ! strnicmp ( evt -> message . service , ""data:"" , 5 ) ) {servName = ""(embedded<S2SV_blank>data)"" ;}else {servName = evt -> message . service ;}if ( ! evt -> message . message ) return 0 ;if ( evt -> message . error ) {if ( ! is_connected ) last_error = evt -> message . error ;if ( evt -> message . error == GF_SCRIPT_INFO ) {GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s\\\}else {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s:<S2SV_blank>%s\\\}}else if ( ! be_quiet ) GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( ""%s<S2SV_blank>%s\\\}break ;case GF_EVENT_PROGRESS : {char * szTitle = """" ;if ( evt -> progress . progress_type == 0 ) {szTitle = ""Buffer<S2SV_blank>"" ;if ( bench_mode && ( bench_mode != 3 ) ) {if ( evt -> progress . done >= evt -> progress . total ) bench_buffer = 0 ;else bench_buffer = 1 + 100 * evt -> progress . done / evt -> progress . total ;break ;}}else if ( evt -> progress . progress_type == 1 ) {if ( bench_mode ) break ;szTitle = ""Download<S2SV_blank>"" ;}else if ( evt -> progress . progress_type == 2 ) szTitle = ""Import<S2SV_blank>"" ;gf_set_progress ( szTitle , evt -> progress . done , evt -> progress . total ) ;}break ;case GF_EVENT_DBLCLICK : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ;return 0 ;case GF_EVENT_MOUSEDOWN : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) {right_down = 1 ;last_x = evt -> mouse . x ;last_y = evt -> mouse . y ;}return 0 ;case GF_EVENT_MOUSEUP : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) {right_down = 0 ;last_x = evt -> mouse . x ;last_y = evt -> mouse . y ;}return 0 ;case GF_EVENT_MOUSEMOVE : if ( right_down && ( user . init_flags & GF_TERM_WINDOWLESS ) ) {GF_Event move ;move . move . x = evt -> mouse . x - last_x ;move . move . y = last_y - evt -> mouse . y ;move . type = GF_EVENT_MOVE ;move . move . relative = 1 ;gf_term_user_event ( term , & move ) ;}return 0 ;case GF_EVENT_KEYUP : switch ( evt -> key . key_code ) {case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) switch_bench ( ! bench_mode ) ;break ;}break ;case GF_EVENT_KEYDOWN : gf_term_process_shortcut ( term , evt ) ;switch ( evt -> key . key_code ) {case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) {if ( ! bench_mode ) switch_bench ( ! bench_mode ) ;}break ;case GF_KEY_PAGEDOWN : case GF_KEY_MEDIANEXTTRACK : request_next_playlist_item = 1 ;break ;case GF_KEY_MEDIAPREVIOUSTRACK : break ;case GF_KEY_ESCAPE : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ;break ;case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) {hide_shell ( shell_visible ? 1 : 0 ) ;if ( ! shell_visible ) gui_mode = 1 ;}break ;case GF_KEY_F : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Rendering<S2SV_blank>rate:<S2SV_blank>%f<S2SV_blank>FPS\\\break ;case GF_KEY_T : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , ""Scene<S2SV_blank>Time:<S2SV_blank>%f<S2SV_blank>\\\break ;case GF_KEY_D : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_DRAW_MODE , ( gf_term_get_option ( term , GF_OPT_DRAW_MODE ) == GF_DRAW_MODE_DEFER ) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER ) ;break ;case GF_KEY_4 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ;break ;case GF_KEY_5 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ;break ;case GF_KEY_6 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ;break ;case GF_KEY_7 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ;break ;case GF_KEY_O : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {if ( gf_term_get_option ( term , GF_OPT_MAIN_ADDON ) ) {fprintf ( stderr , ""Resuming<S2SV_blank>to<S2SV_blank>main<S2SV_blank>content\\\gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ;}else {fprintf ( stderr , ""Main<S2SV_blank>addon<S2SV_blank>not<S2SV_blank>enabled\\\}}break ;case GF_KEY_P : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {u32 pause_state = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ;fprintf ( stderr , ""[Status:<S2SV_blank>%s]\\\if ( ( pause_state == GF_STATE_PAUSED ) && ( evt -> key . flags & GF_KEY_MOD_SHIFT ) ) {gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ;}else {gf_term_set_option ( term , GF_OPT_PLAY_STATE , ( pause_state == GF_STATE_PAUSED ) ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ;}}break ;case GF_KEY_S : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ;fprintf ( stderr , ""Step<S2SV_blank>time:<S2SV_blank>"" ) ;PrintTime ( gf_term_get_time_in_ms ( term ) ) ;fprintf ( stderr , ""\\\}break ;case GF_KEY_B : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 1 ) ;break ;case GF_KEY_M : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 0 ) ;break ;case GF_KEY_H : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_switch_quality ( term , 1 ) ;}break ;case GF_KEY_L : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) {gf_term_switch_quality ( term , 0 ) ;}break ;case GF_KEY_F5 : if ( is_connected ) reload = 1 ;break ;case GF_KEY_A : addon_visible = ! addon_visible ;gf_term_toggle_addons ( term , addon_visible ) ;break ;case GF_KEY_UP : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( playback_speed * 2 ) ;}break ;case GF_KEY_DOWN : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( playback_speed / 2 ) ;}break ;case GF_KEY_LEFT : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) {do_set_speed ( - 1 * playback_speed ) ;}break ;}break ;case GF_EVENT_CONNECT : if ( evt -> connect . is_connected ) {is_connected = 1 ;fprintf ( stderr , ""Service<S2SV_blank>Connected\\\eos_seen = GF_FALSE ;if ( playback_speed != FIX_ONE ) gf_term_set_speed ( term , playback_speed ) ;}else if ( is_connected ) {fprintf ( stderr , ""Service<S2SV_blank>%s\\\is_connected = 0 ;Duration = 0 ;}if ( init_w && init_h ) {gf_term_set_size ( term , init_w , init_h ) ;}ResetCaption ( ) ;break ;case GF_EVENT_EOS : eos_seen = GF_TRUE ;if ( playlist ) {if ( Duration > 1500 ) request_next_playlist_item = GF_TRUE ;}else if ( loop_at_end ) {restart = 1 ;}break ;case GF_EVENT_SIZE : if ( user . init_flags & GF_TERM_WINDOWLESS ) {GF_Event move ;move . type = GF_EVENT_MOVE ;move . move . align_x = align_mode & 0xFF ;move . move . align_y = ( align_mode >> 8 ) & 0xFF ;move . move . relative = 2 ;gf_term_user_event ( term , & move ) ;}break ;case GF_EVENT_SCENE_SIZE : if ( forced_width && forced_height ) {GF_Event size ;size . type = GF_EVENT_SIZE ;size . size . width = forced_width ;size . size . height = forced_height ;gf_term_user_event ( term , & size ) ;}break ;case GF_EVENT_METADATA : ResetCaption ( ) ;break ;case GF_EVENT_RELOAD : if ( is_connected ) reload = 1 ;break ;case GF_EVENT_DROPFILE : {u32 i , pos ;if ( readonly_playlist ) {gf_fclose ( playlist ) ;playlist = NULL ;}readonly_playlist = 0 ;if ( ! playlist ) {readonly_playlist = 0 ;playlist = gf_temp_file_new ( NULL ) ;}pos = ftell ( playlist ) ;i = 0 ;while ( i < evt -> open_file . nb_files ) {if ( evt -> open_file . files [ i ] != NULL ) {fprintf ( playlist , ""%s\\\}i ++ ;}fseek ( playlist , pos , SEEK_SET ) ;request_next_playlist_item = 1 ;}return 1 ;case GF_EVENT_QUIT : if ( evt -> message . error ) {fprintf ( stderr , ""A<S2SV_blank>fatal<S2SV_blank>error<S2SV_blank>was<S2SV_blank>encoutered:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>exiting<S2SV_blank>...\\\}Run = 0 ;break ;case GF_EVENT_DISCONNECT : gf_term_disconnect ( term ) ;break ;case GF_EVENT_MIGRATE : {}break ;case GF_EVENT_NAVIGATE_INFO : if ( evt -> navigate . to_url ) fprintf ( stderr , ""Go<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>\\\\""%s\\\\""\\\\r"" , evt -> navigate . to_url ) ;break ;case GF_EVENT_NAVIGATE : if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) {strcpy ( the_url , evt -> navigate . to_url ) ;fprintf ( stderr , ""Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\\","strncpy ( the_url , evt -> navigate . to_url ) ;fprintf ( stderr , ""Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\\",3048
850,"int i , attr_id = 0 , nattr ;q = ( * s ) + 1 ;","int i , attr_id = 0 , nattr ;tagname [ 0 ] = '\\\\0' ;q = ( * s ) + 1 ;",3049
851,"DWORD nbWritten = 0 ;if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ;Stream_Seek ( irp -> input , 20 ) ;WLog_Print ( serial -> log , WLOG_DEBUG , ""writing<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>%s"" , Length , serial -> device . name ) ;if ( CommWriteFile ( serial -> hComm , Stream_Pointer ( irp -> input ) , Length , & nbWritten , NULL ) )  {","void * ptr ;DWORD nbWritten = 0 ;if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ;if ( ! Stream_SafeSeek ( irp -> input , 20 ) ) return ERROR_INVALID_DATA ;WLog_Print ( serial -> log , WLOG_DEBUG , ""writing<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>%s"" , Length , serial -> device . name ) ;ptr = Stream_Pointer ( irp -> input ) ;if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ;if ( CommWriteFile ( serial -> hComm , ptr , Length , & nbWritten , NULL ) ) {",3050
852,char * buf ;pkglen = s -> end - s -> p ;,"char * buf ;struct stream packet = * s ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""seamless_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ;}pkglen = s -> end - s -> p ;",3051
853,"memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;fl6 . saddr = ireq -> ir_v6_loc_addr ;","memset ( & fl6 , rcu_dereference ( 0 , sizeof ( fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt ) , & final ) ;fl6 . saddr = ireq -> ir_v6_loc_addr ;",3052
854,"ret = hermes_enable_port ( hw , 0 ) ;}","ret = hermes_disable_port ( hw , 0 ) ;}else {priv -> tkip_cm_active = 0 ;ret = hermes_enable_port ( hw , 0 ) ;}",3053
855,bool slow ;if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ;,bool slow ;if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ;,3054
856,"
",* addr_len = sizeof ( * sin6 ) ;,3054
857,}if ( is_udp4 ) {,}if ( is_udp4 ) {,3054
858,"if ( buf_len == 0 ) {return ;}s = p = ( const unsigned char * ) buf ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;if ( * p != \'x\' || * ++ p != \':\' ) {goto outexcept ;}++ p ;pcount = var_tmp_var ( & var_hash ) ;if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) {goto outexcept ;}-- p ;count = Z_LVAL_P ( pcount ) ;while ( count -- > 0 ) {spl_SplObjectStorageElement * pelement ;zend_string * hash ;if ( * p != \';\' ) {goto outexcept ;}++ p ;if ( * p != \'O\' && * p != \'C\' && * p != \'r\' ) {goto outexcept ;}if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) {goto outexcept ;}if ( Z_TYPE ( entry ) != IS_OBJECT ) {zval_ptr_dtor ( & entry ) ;goto outexcept ;}}ZVAL_UNDEF ( & inf ) ;",+ p ;+ p ;}ZVAL_UNDEF ( & inf ) ;,3055
859,if ( uri != NULL )  uri -> port = port & INT_MAX ;* str = cur ;,if ( uri != NULL ) uri -> port = port & USHRT_MAX ;* str = cur ;,3056
860,pch -> chan_net = net ;chan -> ppp = pch ;,pch -> chan_net = get_net ( net ) ;chan -> ppp = pch ;,3057
861,"RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}","if ( new_len > INT_MAX ) {efree ( replaced ) ;RETURN_FALSE ;}RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ;}",3058
862,"ret = hermes_enable_port ( hw , 0 ) ;}","ret = hermes_disable_port ( hw , 0 ) ;}else {priv -> tkip_cm_active = 0 ;ret = hermes_enable_port ( hw , 0 ) ;}",3059
863,"switch ( atype ) {case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ;else {ND_TCHECK ( * tptr ) ;","
",3060
864,"tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;","ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;tunnel_type = * ( tptr + 1 ) ;flags = * tptr ;tlen = len ;ND_TCHECK2 ( tptr [ 0 ] , 5 ) ;",3060
865,"maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL ,  NULL , NULL ) ;if ( out . length && write_packet ( fd , & out ) ) {GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ;if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ;","maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL , NULL ) ;gss_release_buffer ( & min , & in , NULL ) ;if ( out . length && write_packet ( fd , & out ) ) {gss_release_buffer ( & min , & out ) ;GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ;if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ;",3061
866,"xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ;obj_id = 0 ;",xref -> entries = safe_calloc ( xref -> n_entries * sizeof ( struct _xref_entry ) ) ;obj_id = 0 ;,3062
867,pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ;if ( rec ) {,Assert ( ncolumns <= MaxTupleAttributeNumber ) ;pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ;if ( rec ) {,3063
868,assert ( ( cc0 % rowsize ) == 0 ) ;while ( cc > 0 ) {,"if ( ( cc0 % rowsize ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ;return 0 ;}while ( cc > 0 ) {",3064
869,int procfd ;signed long personality ;,signed long personality ;,3065
870,"pid_t to_cleanup_pid = pid ;close ( ipc_sockets [ 1 ] ) ;status = 0 ;ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ;if ( ret <= 0 ) {ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ;ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 )  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ;if ( options -> stdin_fd == 0 ) {signal ( SIGINT , SIG_IGN ) ;signal ( SIGQUIT , SIG_IGN ) ;}ret = wait_for_pid ( pid ) ;if ( ret < 0 ) goto cleanup_error ;to_cleanup_pid = attached_pid ;","int procfd = - 1 ;pid_t to_cleanup_pid = pid ;close ( ipc_sockets [ 1 ] ) ;procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc."" ) ;ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ;",3065
871,"if ( ret != 0 )  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ;goto cleanup_error ;shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;close ( ipc_sockets [ 0 ] ) ;cleanup_error :  shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;","if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ;goto cleanup_error ;}ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>"" ""from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;close ( ipc_sockets [ 0 ] ) ;cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;",3065
872,"procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ;shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ;rexit ( - 1 ) ;}","
",3065
873,". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload ,  . procfd = procfd  }",". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload , }",3065
874,"static int try_filter_frame ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * const cpi ,  int filt_level , int partial_frame ) {int filt_err ;vp9_loop_filter_frame ( cm , & cpi -> mb . e_mbd , filt_level , 1 , partial_frame ) ;filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ;vpx_yv12_copy_y ( & cpi -> last_frame_uf , cm -> frame_to_show ) ;","static int64_t try_filter_frame ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * const cpi , int filt_level , int partial_frame ) {int64_t filt_err ;if ( cpi -> num_workers > 1 ) vp9_loop_filter_frame_mt ( cm -> frame_to_show , cm , cpi -> td . mb . e_mbd . plane , filt_level , 1 , partial_frame , cpi -> workers , cpi -> num_workers , & cpi -> td . lf_row_sync ) ;else vp9_loop_filter_frame ( cm -> frame_to_show , cm , & cpi -> mb . e_mbd , filt_level , 1 , partial_frame ) ;# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) {filt_err = vp9_highbd_get_y_sse ( sd , cm -> frame_to_show ) ;}# else filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ;# endif }else {filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ;vpx_yv12_copy_y ( & cpi -> last_frame_uf , cm -> frame_to_show ) ;",3066
875,"if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) &&  ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) )  goto invalid_key ;",if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED ) goto invalid_key ;,3067
876,"static int rd_inter4x4_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel )  {vp8_build_inter4x4_predictors_mbuv ( & x -> e_mbd ) ;","static int rd_inter4x4_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel ) {( void ) cpi ;( void ) fullpixel ;vp8_build_inter4x4_predictors_mbuv ( & x -> e_mbd ) ;",3068
877,"void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) {const MODE_INFO * mi = xd -> mi [ 0 ] ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;if ( mbmi -> sb_type < BLOCK_8X8 ) {",void vp9_update_mv_count ( ThreadData * td ) {const MACROBLOCKD * xd ) {const MODE_INFO * mi = xd -> mi [ 0 ] ;const MB_MODE_INFO * const mbmi = & mi -> mbmi ;const MB_MODE_INFO_EXT * mbmi_ext = td -> mb . mbmi_ext ;if ( mbmi -> sb_type < BLOCK_8X8 ) {,3069
878,"if ( mi -> bmi [ i ] . as_mode == NEWMV )  inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ;}if ( mbmi -> mode == NEWMV )  inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ;}","if ( mi -> bmi [ i ] . as_mode == NEWMV ) inc_mvs ( mbmi , mbmi_ext , mi -> bmi [ i ] . as_mv , & td -> counts -> mv ) ;}if ( mbmi -> mode == NEWMV ) inc_mvs ( mbmi , mbmi_ext , mbmi -> mv , & td -> counts -> mv ) ;}",3069
879,"static bool  ChunkedDecode ( Request * reqPtr , bool update ) {bool success = NS_TRUE ;NS_NONNULL_ASSERT ( reqPtr != NULL ) ;size_t chunk_length ;if ( p == NULL ) {success = NS_FALSE ;break ;chunk_length = ( size_t ) strtol ( chunkStart , NULL , 16 ) ;* p = \'\\\\r\' ;if ( p + 2 + chunk_length > end ) {Ns_Log ( DriverDebug , ""ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;success = NS_FALSE ;break ;memmove ( writeBuffer , p + 2 , chunk_length ) ;reqPtr -> chunkWriteOff += chunk_length ;* ( writeBuffer + chunk_length ) = \'\\\\0\' ;}reqPtr -> chunkStartOff += ( size_t ) ( p - chunkStart ) + 4u + chunk_length ;chunkStart = bufPtr -> string + reqPtr -> chunkStartOff ;return success ;}","static SockState ChunkedDecode ( Request * reqPtr , bool update ) {SockState result = SOCK_READY ;NS_NONNULL_ASSERT ( reqPtr != NULL ) ;long chunkLength ;if ( p == NULL ) {result = SOCK_MORE ;break ;chunkLength = strtol ( chunkStart , NULL , 16 ) ;* p = \'\\\\r\' ;if ( chunkLength < 0 ) {Ns_Log ( Warning , ""ChunkedDecode:<S2SV_blank>negative<S2SV_blank>chunk<S2SV_blank>length"" ) ;result = SOCK_BADREQUEST ;break ;}* p = \'\\\\r\' ;if ( p + 2 + chunkLength > end ) {Ns_Log ( DriverDebug , ""ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;result = SOCK_MORE ;break ;memmove ( writeBuffer , p + 2 , ( size_t ) chunkLength ) ;reqPtr -> chunkWriteOff += ( size_t ) chunkLength ;* ( writeBuffer + chunkLength ) = \'\\\\0\' ;}reqPtr -> chunkStartOff += ( size_t ) ( p - chunkStart ) + 4u + ( size_t ) chunkLength ;chunkStart = bufPtr -> string + reqPtr -> chunkStartOff ;}return result ;",3070
880,"static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val )  {ulonglong v ;v = 0 ;","static int jas_iccgetuint ( jas_stream_t * in , int n , jas_ulonglong * val ) {jas_ulonglong v ;v = 0 ;",3071
881,char * buf ;pkglen = s -> end - s -> p ;,"char * buf ;struct stream packet = * s ;if ( ! s_check ( s ) ) {rdp_protocol_error ( ""lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ;}pkglen = s -> end - s -> p ;",3072
882,"PyObject * bufobj = PyObject_CallObject ( readline , NULL ) ;if ( bufobj == NULL ) return 0 ;",PyObject * bufobj = _PyObject_CallNoArg ( readline ) ;if ( bufobj == NULL ) return 0 ;,3073
883,"static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt ,  u16 selector , int seg , u8 cpl , bool in_task_switch )  {","static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg , u8 cpl , bool in_task_switch , struct desc_struct * desc ) {",3074
884,"
",if ( desc ) * desc = seg_desc ;,3074
885,"return X86EMUL_CONTINUE ;exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ;","return X86EMUL_CONTINUE ;exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ;",3074
886,if ( op -> operands [ 1 ] . immediate == - 1 ) {return - 1 ;}immediate = op -> operands [ 1 ] . immediate * op -> operands [ 1 ] . sign ;if ( op -> operands [ 0 ] . type & OT_GPREG && ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) {if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) ) {if ( ! ( op -> operands [ 1 ] . type & OT_CONSTANT ) && op -> operands [ 1 ] . extended ) {,if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED ) {,3075
887,data [ l ++ ] = 0xc7 ;data [ l ++ ] = 0xc0 | op -> operands [ 0 ] . reg ;data [ l ++ ] = 0xb8 | op -> operands [ 0 ] . reg ;,data [ l ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ;return l ;}if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) {mod = 0x2 ;if ( op -> operands [ 1 ] . offset > 127 ) {mod = 0x4 ;}}if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) {if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) {data [ l ++ ] = 0x5 ;if ( op -> operands [ 1 ] . offset > 127 ) {data [ l ++ ] = 0x80 | op -> operands [ 0 ] . reg ;,3075
888,data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 4 ;data [ l ++ ] = getsib ( op -> operands [ 0 ] . scale [ 0 ] ) << 6 | op -> operands [ 0 ] . regs [ 0 ] << 3 | 5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;return l ;}if ( ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) {if ( op -> operands [ 0 ] . reg == X86R_UNDEFINED || op -> operands [ 1 ] . reg == X86R_UNDEFINED ) {return - 1 ;}mod = 0x3 ;data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . reg ;,data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ;,3075
889,data [ l ++ ] = 0xa1 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;if ( a -> bits == 64 ) {data [ l ++ ] = offset >> 32 ;data [ l ++ ] = offset >> 40 ;data [ l ++ ] = offset >> 48 ;data [ l ++ ] = offset >> 54 ;return l ;if ( op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | ( op -> operands [ 1 ] . regs [ 0 ] - 8 ) ;,data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ;if ( op -> operands [ 1 ] . offset > 127 ) {mod = 0x1 ;}else {if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) {data [ l ++ ] = 0x0d ;}else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) {data [ l ++ ] = 0x05 ;}else {data [ l ++ ] = mod << 5 | op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] - 8 ) ;,3075
890,data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ;data [ l ++ ] = 0x8b ;data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {,data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ;data [ l ++ ] = 0x8b ;data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ;}data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;}else {if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {base = 5 ;}if ( base ) {data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ;}else {data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ;}if ( offset || base ) {data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;}return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {,3075
891,data [ l ++ ] = 0x25 ;}data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;}if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {,data [ l ++ ] = 0x25 ;}data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;data [ l ++ ] = offset ;data [ l ++ ] = offset >> 8 ;data [ l ++ ] = offset >> 16 ;data [ l ++ ] = offset >> 24 ;return l ;}if ( a -> bits == 64 ) {if ( op -> operands [ 0 ] . type & OT_QWORD ) {if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) {if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) {data [ l ++ ] = 0x67 ;}data [ l ++ ] = 0x48 ;}}else if ( op -> operands [ 1 ] . type & OT_DWORD ) {data [ l ++ ] = 0x44 ;}else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) {data [ l ++ ] = 0x67 ;}if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) {data [ l ++ ] = 0x48 ;}}if ( op -> operands [ 0 ] . type & OT_WORD ) {data [ l ++ ] = 0x66 ;data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ;}else {data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ;}if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) {if ( a -> bits == 64 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ;data [ l ++ ] = 0x25 ;}else {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ;}if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) {data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ;if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) {,3075
892,"static pfn_t kvm_pin_pages ( struct kvm_memory_slot * slot , gfn_t gfn ,  unsigned long size )  {end_gfn = gfn + ( size >> PAGE_SHIFT ) ;gfn += 1 ;","static pfn_t kvm_pin_pages ( struct kvm_memory_slot * slot , gfn_t gfn , unsigned long npages ) {end_gfn = gfn + npages ;gfn += 1 ;",3076
893,"int lpc = 0 ;int csock = 0 ;unsigned laddr ;time_t now = 0 ;# ifdef HAVE_GNUTLS_GNUTLS_H  gnutls_session * session = NULL ;# endif cib_client_t * new_client = NULL ;xmlNode * login = NULL ;const char * user = NULL ;const char * pass = NULL ;const char * tmp = NULL ;# ifdef HAVE_DECL_NANOSLEEP const struct timespec sleepfast = {0 , 10000000 };# endif static struct mainloop_fd_callbacks remote_client_fd_callbacks = {",int csock = 0 ;unsigned laddr ;time_t now = 0 ;int flag ;# ifdef HAVE_GNUTLS_GNUTLS_H gnutls_session * session = NULL ;static struct mainloop_fd_callbacks remote_client_fd_callbacks = {,3077
894,"if ( ssock == remote_tls_fd ) {# ifdef HAVE_GNUTLS_GNUTLS_H  session = create_tls_session ( csock , GNUTLS_SERVER ) ;if ( session == NULL ) {do {crm_trace ( ""Iter:<S2SV_blank>%d"" , lpc ++ ) ;# ifdef HAVE_GNUTLS_GNUTLS_H  login = crm_recv_remote_msg ( session , TRUE ) ;# endif }login = crm_recv_remote_msg ( GINT_TO_POINTER ( csock ) , FALSE ) ;}","if ( ( flag = fcntl ( csock , F_GETFL ) ) >= 0 ) {if ( fcntl ( csock , F_SETFL , flag | O_NONBLOCK ) < 0 ) {crm_err ( ""fcntl()<S2SV_blank>write<S2SV_blank>failed"" ) ;close ( csock ) ;return TRUE ;}}else {crm_err ( ""fcntl()<S2SV_blank>read<S2SV_blank>failed"" ) ;close ( csock ) ;return TRUE ;}if ( ssock == remote_tls_fd ) {# ifdef HAVE_GNUTLS_GNUTLS_H session = crm_create_anon_tls_session ( csock , GNUTLS_SERVER , anon_cred_s ) ;if ( session == NULL ) {num_clients ++ ;new_client = calloc ( 1 , sizeof ( cib_client_t ) ) ;new_client -> id = crm_generate_uuid ( ) ;new_client -> callback_id = NULL ;new_client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , new_client ) ;# ifdef HAVE_GNUTLS_GNUTLS_H new_client -> encrypted = TRUE ;new_client -> session = session ;# endif }new_client -> session = GINT_TO_POINTER ( csock ) , FALSE ) ;}",3077
895,"free_xml ( login ) ;login = create_xml_node ( NULL , ""cib_result"" ) ;crm_xml_add ( login , F_CIB_OPERATION , CRM_OP_REGISTER ) ;crm_xml_add ( login , F_CIB_CLIENTID , new_client -> id ) ;crm_send_remote_msg ( new_client -> session , login , new_client -> encrypted ) ;free_xml ( login ) ;return TRUE ;bail :  if ( ssock == remote_tls_fd ) {# ifdef HAVE_GNUTLS_GNUTLS_H gnutls_bye ( * session , GNUTLS_SHUT_RDWR ) ;gnutls_deinit ( * session ) ;gnutls_free ( session ) ;# endif }close ( csock ) ;free_xml ( login ) ;","
",3077
896,if ( serial -> num_ports < 2 )  return - 1 ;,if ( serial -> num_bulk_out < 2 ) return - 1 ;,3078
897,int n ;if ( ! body -> unit_size )  break ;n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 )  / body -> unit_size ;,unsigned int n ;if ( ! body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 ) ) / body -> unit_size ;,3079
898,"StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\\\'buttons\\\'><tr>"" ) ;if ( s -> start ) StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'start\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Start<S2SV_blank>service\\\'></form></td>"" , s -> name ) ;if ( s -> stop ) StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'stop\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Stop<S2SV_blank>service\\\'></form></td>"" , s -> name ) ;if ( ( s -> start && s -> stop ) || s -> restart ) StringBuffer_append ( res -> outputbuffer ,  ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>""  ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'restart\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Restart<S2SV_blank>service\\\'></form></td>"" , s -> name ) ;}","StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'start\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Start<S2SV_blank>service\\\'>"" ""</form>"" ""</td>"" , s -> name , res -> token ) ;if ( s -> start ) StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'stop\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Stop<S2SV_blank>service\\\'>"" ""</form>"" ""</td>"" , s -> name , res -> token ) ;if ( s -> stop ) StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'restart\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Restart<S2SV_blank>service\\\'>"" ""</form>"" ""</td>"" , s -> name , res -> token ) ;StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\\\'securitytoken\\\'<S2SV_blank>value=\\\'%s\\\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'%s\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'%s\\\'>"" ""</form>"" ""</td>"" , s -> name , res -> token , s -> name ) ;if ( ( s -> start && s -> stop ) || s -> restart ) StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\\\'restart\\\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\\\'Restart<S2SV_blank>service\\\'></form></td>"" , s -> name ) ;StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ;}",3080
899,"if ( ! in_group_p ( inode -> i_gid ) &&  ! inode_capable ( inode , CAP_FSETID ) )  mode &= ~ S_ISGID ;","if ( ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) mode &= ~ S_ISGID ;",3081
900,"static int ceph_x_decrypt ( struct ceph_crypto_key * secret ,  void * * p , void * end , void * obuf , size_t olen )  {ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen ,  * p , len ) ;","static int ceph_x_decrypt ( struct ceph_crypto_key * secret , void * * p , void * end , void * * obuf , size_t olen ) {if ( * obuf == NULL ) {* obuf = kmalloc ( len , GFP_NOFS ) ;if ( ! * obuf ) return - ENOMEM ;olen = len ;}ret = ceph_decrypt2 ( secret , & head , & head_len , * obuf , & olen , * p , len ) ;",3082
901,"static void ptrace_triggered ( struct perf_event * bp , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {","static void ptrace_triggered ( struct perf_event * bp , struct perf_sample_data * data , struct pt_regs * regs ) {",3083
902,"
",int nb_bits = req [ offset + 5 ] ;,3084
903,"int mapping_address = address - mb_mapping -> start_bits ;if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\\","int mapping_address = address - mb_mapping -> start_bits ;if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\\",3084
904,"int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;int mapping_address = address - mb_mapping -> start_registers ;if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\\","int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ;int nb_bytes = req [ offset + 5 ] ;int mapping_address = address - mb_mapping -> start_registers ;if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb ) {rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , ""Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\\",3084
905,if ( net != c_net || ! tc -> t_sock )  continue ;,if ( net != c_net ) continue ;,3085
906,struct resv_map * reservations = vma_resv_map ( vma ) ;unsigned long reserve ;,struct resv_map * reservations = vma_resv_map ( vma ) ;struct hugepage_subpool * spool = subpool_vma ( vma ) ;unsigned long reserve ;,3086
907,"hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ;}","hugepage_subpool_put_pages ( spool , reserve ) ;}",3086
908,sc = create_spnego_ctx ( ) ;if ( sc == NULL ) {,sc = create_spnego_ctx ( 0 ) ;if ( sc == NULL ) {,3087
909,"
",}else if ( request_size < 0 ) {rc = - EINVAL ;goto out_free_buffer ;,3088
910,}},}},3088
911,rfcomm_dlc_accept ( d ) ;msg -> msg_namelen = 0 ;,rfcomm_dlc_accept ( d ) ;,3089
912,case \'<S2SV_blank>\' : case \'=\' :  case \'\\\\r\' :  case \'\\\,"case \'<S2SV_blank>\' : case \'=\' : case \\\'""\\\' : case \'\\\\\\\\\' : case \'\\\\r\' : case \'\\\",3090
913,return in ;},return NULL ;},3091
914,"int perf_event_overflow ( struct perf_event * event , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {return __perf_event_overflow ( event , nmi , 1 , data , regs ) ;}","int perf_event_overflow ( struct perf_event * event , struct perf_sample_data * data , struct pt_regs * regs ) {return __perf_event_overflow ( event , 1 , data , regs ) ;}",3092
915,"size_t i ;generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ;",size_t i ;,3093
916,"int err ;err = crypto_ahash_export ( req , state ) ;if ( err ) return err ;ctx2 -> more = 1 ;err = crypto_ahash_import ( & ctx2 -> req , state ) ;","bool more ;int err ;lock_sock ( sk ) ;more = ctx -> more ;err = more ? crypto_ahash_export ( req , state ) : 0 ;release_sock ( sk ) ;if ( err ) return err ;ctx2 -> more = more ;if ( ! more ) return err ;err = crypto_ahash_import ( & ctx2 -> req , state ) ;",3094
917,"flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;","if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;flags |= EXT4_GET_BLOCKS_PRE_IO ;return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ;",3095
918,"void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType )  {","static void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {",3096
919,"BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp )  {if ( rdp -> decrypt_use_count >= 4096 ) {","BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp ) {if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;if ( rdp -> decrypt_use_count >= 4096 ) {",3097
920,"const char * errstr ;if ( ( gr = getgrnam ( s ) ) != NULL ) {# else  sscanf ( s , ""%d"" , gid ) ;# endif  if ( errstr ) return - 1 ;return 0 ;}","# if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) const char * errstr = NULL ;# else int status ;# endif if ( ( gr = getgrnam ( s ) ) != NULL ) {if ( errstr ) return - 1 ;# else status = sscanf ( s , ""%d"" , gid ) ;if ( status != 1 ) return - 1 ;# endif return 0 ;}",3098
921,"void recovery_cipher_finalize ( void )  {static char CONFIDENTIAL new_mnemonic [ MNEMONIC_BUF ] = """" ;","void recovery_cipher_finalize ( void ) {if ( ! recovery_started ) {recovery_abort ( ) ;fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ;layoutHome ( ) ;return ;}static char CONFIDENTIAL new_mnemonic [ MNEMONIC_BUF ] = """" ;",3099
922,new_mnemonic [ strlen ( new_mnemonic ) - 1 ] = \'\\\\0\' ;if ( ! dry_run && ( ! enforce_wordlist || mnemonic_check ( new_mnemonic ) ) ) {,"new_mnemonic [ MAX ( 0u , strnlen ( new_mnemonic , sizeof ( new_mnemonic ) ) - 1 ) ] = \'\\\\0\' ;if ( ! dry_run && ( ! enforce_wordlist || mnemonic_check ( new_mnemonic ) ) ) {",3099
923,"Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL )  return HTTP_UNAUTHORIZED ;}","# ifdef UPNP_ENABLE_POST_WRITE Fp = fopen ( filename , ""wb"" ) ;if ( Fp == NULL ) return HTTP_UNAUTHORIZED ;# else return HTTP_NOT_FOUND ;# endif }",3100
924,inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;,"uint16 bps = 0 ;( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ;if ( bps != 8 ) {TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ;return 0 ;}inbuf = _TIFFmalloc ( scanlinesizein ) ;outbuf = _TIFFmalloc ( scanlinesizeout ) ;",3101
925,}if ( addr_len ) * addr_len = sizeof ( * saddr ) ;,* addr_len = sizeof ( * saddr ) ;},3102
926,if ( iterator -> next ) rfbDecrClientRef ( iterator -> next ) ;free ( iterator ) ;,if ( iterator && iterator -> next ) rfbDecrClientRef ( iterator -> next ) ;free ( iterator ) ;,3103
927,if ( key -> type -> destroy )  key -> type -> destroy ( key ) ;,"if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ;",3104
928,ptrdiff_t ext_first_part_size = token_part_sizes - pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) ;,ptrdiff_t ext_first_part_size = token_part_sizes - pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) {;,3105
929,# if CONFIG_MULTITHREAD  if ( pbi -> decoding_thread_count > num_token_partitions - 1 )   pbi -> decoding_thread_count = num_token_partitions - 1 ;# endif },# if CONFIG_MULTITHREAD if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) pbi -> decoding_thread_count = num_token_partitions - 1 ;}if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) {pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ;}# endif },3105
930,if ( fileblock < INDIRECT_BLOCKS )  blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ;else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 )  {,if ( fileblock < INDIRECT_BLOCKS ) {blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ;}else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) {,3106
931,"static int blosc_c ( struct thread_context * thread_context , int32_t bsize ,  int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes ,  const uint8_t * src , const int32_t offset , uint8_t * dest , uint8_t * tmp , uint8_t * tmp2 ) {","static int blosc_c ( struct thread_context * thread_context , int32_t bsize , int32_t leftoverblock , int32_t ntbytes , int32_t destsize , const uint8_t * src , const int32_t offset , uint8_t * dest , uint8_t * tmp , uint8_t * tmp2 ) {",3107
932,"_sw32 ( dest - 4 , - value ) ;continue ;# endif  if ( ntbytes + maxout > maxbytes ) {maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ;if ( maxout <= 0 ) {","if ( ntbytes > destsize ) {return - 1 ;}_sw32 ( dest - 4 , - value ) ;continue ;# endif if ( ntbytes + maxout > destsize ) {maxout = ( int64_t ) destsize - ( int64_t ) ntbytes ;if ( maxout <= 0 ) {",3107
933,if ( ( ntbytes + neblock ) > maxbytes ) {return 0 ;,if ( ( ntbytes + neblock ) > destsize ) {return 0 ;,3107
934,"zval_ptr_dtor ( value ) ;zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ;","zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ;",3108
935,"BIO * tmpout = NULL ;if ( out == NULL ) tmpout = BIO_new ( BIO_s_null ( ) ) ;else if ( flags & CMS_TEXT ) {tmpout = BIO_new ( BIO_s_mem ( ) ) ;BIO_set_mem_eof_return ( tmpout , 0 ) ;else tmpout = out ;","BIO * tmpout ;tmpout = cms_get_text_bio ( out , flags ) ;if ( ! tmpout ) {CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ;goto err ;for ( ;;) {i = BIO_read ( in , buf , sizeof ( buf ) ) ;if ( i <= 0 ) {if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) {if ( ! BIO_get_cipher_status ( in ) ) goto err ;}if ( i < 0 ) goto err ;break ;}if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ;}if ( flags & CMS_TEXT ) {",3109
936,continue ;},buffer_size -= ( size_t ) pkg_length ;continue ;},3110
937,continue ;},buffer_size -= ( size_t ) pkg_length ;continue ;},3110
938,}},buffer_size -= ( size_t ) pkg_length ;}},3110
939,"if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 )  isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;else  isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ;break ;","if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 ) ;else isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ;break ;",3111
940,int copylen ;bool zerocopy = false ;,int copylen = 0 ;bool zerocopy = false ;err = - EMSGSIZE ;if ( unlikely ( count > UIO_MAXIOV ) ) goto err ;,3112
941,"if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) )  zerocopy = true ;copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;","if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) zerocopy = true ;if ( count > MAX_SKB_FRAGS ) {copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ;if ( copylen < vnet_hdr_len ) copylen = 0 ;else copylen -= vnet_hdr_len ;}if ( copylen < vnet_hdr . hdr_len ) copylen = vnet_hdr . hdr_len ;if ( ! copylen ) copylen = GOODCOPY_LEN ;",3112
942,problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;,"
",3113
943,"return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}","switch ( msr -> index ) {case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ;break ;case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ;}return kvm_x86_ops -> set_msr ( vcpu , msr ) ;}",3114
944,struct perf_event_context * ctx ;struct file * event_file = NULL ;,"struct perf_event_context * ctx , * uninitialized_var ( gctx ) ;struct file * event_file = NULL ;",3115
945,"if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ;if ( group_leader -> cpu != event -> cpu ) goto err_context ;else {if ( group_leader -> ctx != ctx ) goto err_context ;if ( attr . exclusive || attr . pinned ) goto err_context ;if ( output_event ) {err = perf_event_set_output ( event , output_event ) ;if ( err ) goto err_context ;event_file = anon_inode_getfile ( ""[perf_event]"" , & perf_fops , event , f_flags ) ;if ( IS_ERR ( event_file ) ) {err = PTR_ERR ( event_file ) ;goto err_context ;struct perf_event_context * gctx = group_leader -> ctx ;mutex_lock ( & gctx -> mutex ) ;perf_remove_from_context ( group_leader , false ) ;perf_event__state_init ( group_leader ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_remove_from_context ( sibling , false ) ;perf_event__state_init ( sibling ) ;mutex_unlock ( & gctx -> mutex ) ;put_ctx ( gctx ) ;","gctx = group_leader -> ctx ;mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ;perf_remove_from_context ( group_leader , false ) ;perf_event__state_init ( group_leader ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_remove_from_context ( sibling , false ) ;perf_event__state_init ( sibling ) ;put_ctx ( gctx ) ;else {mutex_lock ( & ctx -> mutex ) ;WARN_ON_ONCE ( ctx -> parent_ctx ) ;if ( move_group ) {synchronize_rcu ( ) ;perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ;get_ctx ( ctx ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_install_in_context ( ctx , sibling , sibling -> cpu ) ;get_ctx ( ctx ) ;perf_install_in_context ( ctx , event , event -> cpu ) ;perf_unpin_context ( ctx ) ;mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & gctx -> mutex ) ;put_ctx ( gctx ) ;",3115
946,"}perf_install_in_context ( ctx , event , event -> cpu ) ;perf_unpin_context ( ctx ) ;","
",3115
947,"return crypto_alloc_skcipher ( name , type , mask ) ;}","struct skcipher_tfm * tfm ;struct crypto_skcipher * skcipher ;tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ;if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ;skcipher = crypto_alloc_skcipher ( name , type , mask ) ;if ( IS_ERR ( skcipher ) ) {kfree ( tfm ) ;return ERR_CAST ( skcipher ) ;}tfm -> skcipher = skcipher ;return tfm ;}",3116
948,if ( x & ( 1 << i ) ) return i ;},if ( x & ( 1U << ( unsigned int ) i ) ) return i ;},3117
949,"if ( attr >= 0 ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;","if ( attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS ) {xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ;",3118
950,int req_len ;struct qeth_arp_query_info qinfo = {,unsigned int req_len ;struct qeth_arp_query_info qinfo = {,3119
951,"if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) )  return - EFAULT ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;","if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) return - EFAULT ;if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL ;ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ;",3119
952,"separator = strchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;","separator = osStrchr ( connection -> buffer , '=' ) ;if ( ! separator ) return ERROR_INVALID_TAG ;",3120
953,"const int min_frame_target = MAX ( rc -> min_frame_bandwidth ,   rc -> av_per_frame_bandwidth >> 5 ) ;if ( target < min_frame_target ) target = min_frame_target ;return target ;}","const VP9EncoderConfig * oxcf = & cpi -> oxcf ;const int min_frame_target = MAX ( rc -> min_frame_bandwidth , rc -> avg_frame_bandwidth >> 5 ) ;if ( target < min_frame_target ) target = min_frame_target ;if ( oxcf -> rc_max_inter_bitrate_pct ) {const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ;target = MIN ( target , max_rate ) ;}return target ;}",3121
954,"
",if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) {continue ;},3122
955,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) &&  ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) {,3122
956,"deconstruct_array ( key_array , TEXTOID , - 1 , false , \'i\' ,  & key_datums , & key_nulls , & key_count ) ;if ( PG_ARGISNULL ( 1 ) ) {","deconstruct_array ( key_array , TEXTOID , - 1 , false , \'i\' , & key_datums , & key_nulls , & key_count ) ;if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;if ( PG_ARGISNULL ( 1 ) ) {",3123
957,"if ( ! unqueue_me ( & q ) )  goto out_put_key ;ret = - ETIMEDOUT ;if ( to && ! to -> task )  goto out_put_key ;if ( ! signal_pending ( current ) ) {put_futex_key ( fshared , & q . key ) ;goto retry ;}ret = - ERESTARTSYS ;if ( ! abs_time )  goto out_put_key ;restart = & current_thread_info ( ) -> restart_block ;",if ( ! unqueue_me ( & q ) ) goto out ;ret = - ETIMEDOUT ;if ( to && ! to -> task ) goto out ;if ( ! signal_pending ( current ) ) goto retry ;}ret = - ERESTARTSYS ;if ( ! abs_time ) goto out_put_key ;restart = & current_thread_info ( ) -> restart_block ;,3124
958,"out_put_key :  put_futex_key ( fshared , & q . key ) ;","
",3124
959,xstep = picomp -> hsamp * ( 1 <<  ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 <<  ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;,"if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",3125
960,if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",3125
961,"static char * print_value ( cJSON * item , int depth , int fmt )  {if ( ! item )  return 0 ;switch ( ( item -> type ) & 255 ) {case cJSON_NULL : out = cJSON_strdup ( ""null"" ) ;case cJSON_False : out = cJSON_strdup ( ""false"" ) ;break ;case cJSON_True : out = cJSON_strdup ( ""true"" ) ;case cJSON_Number : out = print_number ( item ) ;case cJSON_String : out = print_string ( item ) ;case cJSON_Array : out = print_array ( item , depth , fmt ) ;case cJSON_Object : out = print_object ( item , depth , fmt ) ;}","static char * print_value ( cJSON * item , int depth , int fmt , printbuffer * p ) {if ( ! item ) return 0 ;if ( p ) {switch ( ( item -> type ) & 255 ) {case cJSON_NULL : {out = ensure ( p , 5 ) ;if ( out ) strcpy ( out , ""null"" ) ;}case cJSON_False : {out = ensure ( p , 6 ) ;if ( out ) strcpy ( out , ""false"" ) ;}case cJSON_True : {out = ensure ( p , 5 ) ;if ( out ) strcpy ( out , ""true"" ) ;}case cJSON_Number : out = print_number ( item , 0 , p ) ;case cJSON_String : out = print_string ( item , 0 , p ) ;case cJSON_Array : out = print_array ( item , depth , fmt , 0 ) ;}}",3126
962,"static int rd_inter16x16_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel )  {vp8_build_inter16x16_predictors_mbuv ( & x -> e_mbd ) ;","static int rd_inter16x16_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel ) {( void ) cpi ;( void ) fullpixel ;vp8_build_inter16x16_predictors_mbuv ( & x -> e_mbd ) ;",3127
963,"static void update_coef_probs ( VP9_COMP * cpi , vp9_writer * w ) {const TX_MODE tx_mode = cpi -> common . tx_mode ;vp9_coeff_stats frame_branch_ct [ TX_SIZES ] [ PLANE_TYPES ] ;vp9_clear_system_state ( ) ;++ tx_size ) build_tree_distribution ( cpi , tx_size , frame_branch_ct [ tx_size ] ) ;for ( tx_size = TX_4X4 ;tx_size <= max_tx_size ;++ tx_size )   update_coef_probs_common ( w , cpi , tx_size , frame_branch_ct [ tx_size ] ) ;}","static void update_coef_probs ( VP9_COMP * cpi , vpx_writer * w ) {const TX_MODE tx_mode = cpi -> common . tx_mode ;+ tx_size ) build_tree_distribution ( cpi , tx_size , frame_branch_ct [ tx_size ] ) ;+ tx_size )   update_coef_probs_common ( w , cpi , tx_size , frame_branch_ct [ tx_size ] ) ;++ tx_size ) {vp9_coeff_stats frame_branch_ct [ PLANE_TYPES ] ;vp9_coeff_probs_model frame_coef_probs [ PLANE_TYPES ] ;if ( cpi -> td . counts -> tx . tx_totals [ tx_size ] <= 20 || ( tx_size >= TX_16X16 && cpi -> sf . tx_size_search_method == USE_TX_8X8 ) ) {vpx_write_bit ( w , 0 ) ;}else {build_tree_distribution ( cpi , tx_size , frame_branch_ct , frame_coef_probs ) ;}}}",3128
964,"ptr = strchr ( ptr + 1 , '/' ) + 1 ;rw_exit ( & sdvp -> sdev_contents ) ;","ptr = strchr ( ptr + 1 , '/' ) ;if ( ptr == NULL ) return ( ENOENT ) ;ptr ++ ;rw_exit ( & sdvp -> sdev_contents ) ;",3129
965,"if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",3130
966,},"assert_regexp_syntax_error ( ""\\\\\\\\x0"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\xxy"" ) ;}",3131
967,"
",L -> oldpc = 0 ;,3132
968,},},3132
969,"static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len ,  const u_char * ep , uint32_t phase , uint32_t doi0 _U_ ,   uint32_t proto0 _U_ , int depth )  {","static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) {",3133
970,"ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ;switch ( ntohs ( n . type ) ) {size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ;while ( cp < ep && cp < ep2 ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ;break ;}case IPSECDOI_NTYPE_REPLAY_STATUS :  ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;break ;case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ;default :  isakmp_print ( ndo , cp ,  item_len - sizeof ( * p ) - n . spi_size , NULL ) ;ND_PRINT ( ( ndo , "")"" ) ) ;}","switch ( ntohs ( n . type ) ) {size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) ) ;ND_PRINT ( ( ndo , "")"" ) ) ;break ;}case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ;ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;break ;case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ;break ;default : if ( ndo -> ndo_vflag > 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ;}else {if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ;ND_PRINT ( ( ndo , "")"" ) ) ;}",3133
971,cond_branch : f_offset = addrs [ i + filter [ i ] . jf ] - addrs [ i ] ;,cond_branch : f_offset = addrs [ i + filter [ i ] . jf && f_offset ] - addrs [ i ] ;,3134
972,"if ( filter [ i ] . jf )   t_offset += is_near ( f_offset ) ? 2 : 6 ;EMIT_COND_JMP ( t_op , t_offset ) ;","if ( filter [ i ] . jf ) t_offset += is_near ( f_offset ) ? 2 : 5 ;EMIT_COND_JMP ( t_op , t_offset ) ;",3134
973,"if ( test_bit ( DMF_FREEING , & md -> flags ) ||   dm_deleting_md ( md ) )  return NULL ;dm_get ( md ) ;return md ;","spin_lock ( & _minor_lock ) ;if ( test_bit ( DMF_FREEING , & md -> flags ) || dm_deleting_md ( md ) ) {md = NULL ;goto out ;}dm_get ( md ) ;out : spin_unlock ( & _minor_lock ) ;return md ;",3135
974,if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) )  {,if ( ! ps_dec -> u1_first_slice_in_stream && ps_dec -> u4_first_slice_in_pic == 2 ) ) {,3136
975,if ( ps_dec -> u4_first_slice_in_pic != 2 )  {,if ( ps_dec -> u4_first_slice_in_pic == 0 ) {,3136
976,prev_slice_err = 1 ;}else {prev_slice_err = 2 ;}if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ;else ps_cur_slice -> u1_bottom_field_flag = 0 ;num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & ps_dec -> s_cur_pic_poc ;u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ;}else if ( ps_dec -> u4_first_slice_in_pic == 2 )  {,"
",3136
977,else {if ( ps_dec -> u4_first_slice_in_pic )  {prev_slice_err = 1 ;num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ;}num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs )  - ps_dec -> u2_total_mbs_coded ;}if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded )  {num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff )  - ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & s_tmp_poc ;else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) {,num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ;if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) {prev_slice_err = 2 ;num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) {num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & s_tmp_poc ;else if ( ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ) {,3136
978,"if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) {ps_dec -> u1_first_slice_in_stream = 0 ;return ERROR_IN_LAST_SLICE_OF_PIC ;}if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) {ih264d_err_pic_dispbuf_mgr ( ps_dec ) ;return ERROR_NEW_FRAME_EXPECTED ;}if ( ret != OK ) return ret ;i1_is_end_of_poc = 0 ;}if ( ps_dec -> u4_first_slice_in_pic == 0 ) {ps_dec -> ps_parse_cur_slice ++ ;ps_dec -> u2_cur_slice_num ++ ;}if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) {ps_dec -> ps_decode_cur_slice ++ ;}ps_dec -> u1_slice_header_done = 0 ;if ( u1_field_pic_flag ) {ps_dec -> u2_prv_frame_num = u2_frame_num ;}if ( ps_cur_slice -> u1_mmco_equalto5 ) {WORD32 i4_temp_poc ;WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ;if ( ! ps_cur_slice -> u1_field_pic_flag ) {i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ;}else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ;ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ;}if ( ps_dec -> u4_first_slice_in_pic == 2 )  {ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ;if ( ret != OK ) return ret ;if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ;if ( i4_poc == 0 ) {ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ;ps_dec -> i4_max_poc = 0 ;}}ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ;ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ;ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ;ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ;ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ;ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ;ps_cur_slice -> u1_slice_type = u1_slice_type ;ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ;ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ;ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ;ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ;ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ;if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ;else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ;if ( u1_slice_type == B_SLICE ) {ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ;COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ;if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ;else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ;if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ;}else {if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ;}if ( ps_dec -> u4_first_slice_in_pic == 2 )  {if ( u2_first_mb_in_slice == 0 ) {ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ;if ( ret != OK ) return ret ;}ps_dec -> u4_output_present = 0 ;{ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ;if ( 0 != ps_dec -> s_disp_op . u4_error_code ) {ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ;}else ps_dec -> u4_output_present = 1 ;}if ( ps_dec -> u1_separate_parse == 1 ) {if ( ps_dec -> u4_dec_thread_created == 0 ) {ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ;ps_dec -> u4_dec_thread_created = 1 ;}if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) {ps_dec -> u4_start_recon_deblk = 0 ;ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ;ps_dec -> u4_bs_deblk_thread_created = 1 ;}}}{UWORD8 uc_nofield_nombaff ;uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ;if ( uc_nofield_nombaff ) {ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ;ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ;}else {ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ;ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ;}}{dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ;if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) {ps_err -> u1_err_flag = ACCEPT_ALL_PICS ;ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ;}ps_err -> u4_cur_frm = u2_frame_num ;}{WORD32 i4_skip_b_pic , i4_skip_p_pic ;i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ;i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ;if ( i4_skip_b_pic ) {ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ;ps_dec -> u1_last_pic_not_decoded = 1 ;return OK ;}if ( i4_skip_p_pic ) {ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ;ps_dec -> u1_last_pic_not_decoded = 1 ;return OK ;}{UWORD16 u2_mb_x , u2_mb_y ;ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ;",if ( ps_dec -> u2_total_mbs_coded ;ps_cur_poc = & s_tmp_poc ;else if ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ;,3136
979,ps_dec -> u4_first_slice_in_pic = 0 ;ps_dec -> u1_first_slice_in_stream = 0 ;,ps_dec -> u4_first_slice_in_pic = 0 ;ps_dec -> u1_first_slice_in_stream = 0 ;,3136
980,break ;case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) {if ( s -> codec_id == AV_CODEC_ID_JV ) {w_align = 8 ;,if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) {w_align = 8 ;h_align = 8 ;}break ;case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) {if ( s -> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) {w_align = 8 ;,3137
981,"case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ;if ( L_ICANON ( tty ) )  retval = inq_canon ( ldata ) ;","case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) && ! L_EXTPROC ( tty ) , ( int __user * ) arg ) ;if ( L_ICANON ( tty ) ) retval = inq_canon ( ldata ) ;",3138
982,sun_info . height = ReadBlobMSBLong ( image ) ;sun_info . depth = ReadBlobMSBLong ( image ) ;sun_info . length = ReadBlobMSBLong ( image ) ;sun_info . type = ReadBlobMSBLong ( image ) ;sun_info . maptype = ReadBlobMSBLong ( image ) ;sun_info . maplength = ReadBlobMSBLong ( image ) ;extent = sun_info . height * sun_info . width ;,bytes_per_line = sun_info . width * sun_info . depth ;sun_info . height ;,3139
983,"sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length ,   sizeof ( * sun_data ) ) ;if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;height = sun_info . height ;bytes_per_line = sun_info . width * sun_info . depth ;","sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ;if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;height = sun_info . height ;bytes_per_line = sun_info . width * sun_info . depth ;",3139
984,"int release_vp9_frame_buffer ( void * cb_priv ,  vpx_codec_frame_buffer_t * fb ) {","static int release_vp9_frame_buffer ( void * cb_priv , vpx_codec_frame_buffer_t * fb ) {",3140
985,"void vp9_cost_tokens ( int * costs , const vp9_prob * probs , vp9_tree tree ) {cost ( costs , tree , probs , 0 , 0 ) ;","void vp9_cost_tokens ( int * costs , const vpx_prob * probs , vp9_tree tree ) {cost ( costs , tree , probs , 0 , 0 ) ;",3141
986,"vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ;vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ;vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ;","unsigned long cr4 ;vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ;cr4 = read_cr4 ( ) ;vmcs_writel ( HOST_CR4 , cr4 ) ;vmx -> host_state . vmcs_host_cr4 = cr4 ;",3142
987,value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |   ( ( unsigned char * ) buffer ) [ 1 ] ) ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,value = ( unsigned short ) buffer [ 1 ] << 8 ) | buffer [ 0 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | ( ( unsigned char * ) buffer ) [ 1 ] ) ;quantum . unsigned_value = value & 0xffff ) ;return ( quantum . signed_value ) ;,3143
988,"code = validate_as_request ( kdc_active_realm , request , * princ ,  no_server , kdc_time , status , & e_data ) ;","princ -> pw_expiration = 0 ;clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;code = validate_as_request ( kdc_active_realm , request , * princ , no_server , kdc_time , status , & e_data ) ;",3144
989,"dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\\","dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\\",3145
990,"u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ;if ( ! d ) return - ENODEV ;if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 )  return - EAGAIN ;switch ( num ) {case 1 : switch ( msg [ 0 ] . addr ) {case SU3000_STREAM_CTRL :  obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ;obuf [ 1 ] = 3 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case DW2102_RC_QUERY :  obuf [ 0 ] = 0x10 ;if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ;msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ;break ;default :  obuf [ 0 ] = 0x08 ;obuf [ 1 ] = msg [ 0 ] . addr ;obuf [ 2 ] = msg [ 0 ] . len ;memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 ,   ibuf , 1 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case 2 :  obuf [ 0 ] = 0x09 ;obuf [ 1 ] = msg [ 0 ] . len ;obuf [ 2 ] = msg [ 1 ] . len ;obuf [ 3 ] = msg [ 0 ] . addr ;memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 ,   ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 )  err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ;break ;mutex_unlock ( & d -> i2c_mutex ) ;return num ;","struct dw2102_state * state ;if ( ! d ) return - ENODEV ;state = d -> priv ;if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) return - EAGAIN ;if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) {mutex_unlock ( & d -> i2c_mutex ) ;return - EAGAIN ;}switch ( num ) {case 1 : switch ( msg [ 0 ] . addr ) {case SU3000_STREAM_CTRL : state -> data [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ;state -> data [ 1 ] = 3 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 0 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;break ;case DW2102_RC_QUERY : state -> data [ 0 ] = 0x10 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 2 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msg [ 0 ] . buf [ 1 ] = state -> data [ 0 ] ;msg [ 0 ] . buf [ 0 ] = state -> data [ 1 ] ;default : state -> data [ 0 ] = 0x08 ;state -> data [ 1 ] = msg [ 0 ] . addr ;state -> data [ 2 ] = msg [ 0 ] . len ;memcpy ( & state -> data [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 3 , state -> data , 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;case 2 : state -> data [ 0 ] = 0x09 ;state -> data [ 1 ] = msg [ 0 ] . len ;state -> data [ 2 ] = msg [ 1 ] . len ;state -> data [ 3 ] = msg [ 0 ] . addr ;memcpy ( & state -> data [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ;if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 4 , state -> data , msg [ 1 ] . len + 1 , 0 ) < 0 ) err ( ""i2c<S2SV_blank>transfer<S2SV_blank>failed."" ) ;memcpy ( msg [ 1 ] . buf , & state -> data [ 1 ] , msg [ 1 ] . len ) ;break ;mutex_unlock ( & d -> data_mutex ) ;mutex_unlock ( & d -> i2c_mutex ) ;return num ;",3146
991,blockcnt = ( ( len + pos ) + blocksize - 1 ) >>  ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ;,if ( len < 1 || len == 0xffffffff ) {return - 1 ;}blockcnt = ( ( len + pos ) + blocksize - 1 ) >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ;,3147
992,struct cred * cred ;if ( ! ( unshare_flags & CLONE_NEWUSER ) ) return 0 ;cred = prepare_creds ( ) ;if ( ! cred )  return - ENOMEM ;* new_cred = cred ;return create_user_ns ( cred ) ;},struct cred * cred ;int err = - ENOMEM ;if ( cred ) {err = create_user_ns ( cred ) ;if ( err ) put_cred ( cred ) ;else * new_cred = cred ;}return err ;},3148
993,"
",status = register_pernet_subsys ( & sctp_ctrlsock_ops ) ;if ( status ) goto err_register_ctrlsock ;,3149
994,status = sctp_v4_protosw_init ( ) ;if ( status ) goto err_protosw_init ;status = register_pernet_subsys ( & sctp_net_ops ) ;if ( status ) goto err_register_pernet_subsys ;err_add_protocol :  unregister_pernet_subsys ( & sctp_net_ops ) ;err_register_pernet_subsys : sctp_v6_protosw_exit ( ) ;err_protosw_init :  sctp_v4_pf_exit ( ) ;,status = sctp_v4_protosw_init ( ) ;if ( status ) goto err_protosw_init ;status = register_pernet_subsys ( & sctp_net_ops ) ;if ( status ) goto err_register_pernet_subsys ;err_add_protocol : unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ;err_register_ctrlsock : sctp_v6_protosw_exit ( ) ;err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ;err_register_defaults : sctp_v4_pf_exit ( ) ;,3149
995,"
",atomic_dec ( & chip -> active ) ;,3150
996,"if ( err < 0 ) goto __error ;usb_chip [ chip -> index ] = chip ;chip -> num_interfaces ++ ;usb_set_intfdata ( intf , chip ) ;atomic_dec ( & chip -> active ) ;mutex_unlock ( & register_mutex ) ;return 0 ;__error : if ( chip ) {if ( ! chip -> num_interfaces )  snd_card_free ( chip -> card ) ;atomic_dec ( & chip -> active ) ;}",},3150
997,"cntsize ( in , & sumlen , & nnode ) ;len = COMPUTESIZE ( nnode , sumlen ) ;","cntsize ( in , & sumlen , & nnode ) ;if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;len = COMPUTESIZE ( nnode , sumlen ) ;",3151
998,"s -> decode_mb = mpeg4_decode_studio_mb ;decode_smpte_tc ( ctx , gb ) ;","s -> interlaced_dct = 0 ;s -> decode_mb = mpeg4_decode_studio_mb ;decode_smpte_tc ( ctx , gb ) ;",3152
999,"ret = read ( p_dev -> fd , & ev , sizeof ( ev ) ) ;if ( ret == 0 ) {","ret = TEMP_FAILURE_RETRY ( read ( p_dev -> fd , & ev , sizeof ( ev ) ) ) ;if ( ret == 0 ) {",3153
1000,"int status = 0 ;cred = rpc_lookup_cred ( ) ;state = nfs4_do_open ( dir , & path , flags , sattr , cred ) ;d_drop ( dentry ) ;","fmode_t fmode = flags & ( FMODE_READ | FMODE_WRITE ) ;int status = 0 ;cred = rpc_lookup_cred ( ) ;state = nfs4_do_open ( dir , & path , fmode , flags , sattr , cred ) ;d_drop ( dentry ) ;",3154
1001,"if ( status == 0 && ( nd -> flags & LOOKUP_OPEN ) != 0 )  status = nfs4_intent_set_file ( nd , & path , state ) ;else  nfs4_close_sync ( & path , state , flags ) ;out_putcred : put_rpccred ( cred ) ;","if ( status == 0 && ( nd -> flags & LOOKUP_OPEN ) != 0 ) status = nfs4_intent_set_file ( nd , & path , state , fmode ) ;out_putcred : put_rpccred ( cred ) ;",3154
1002,"struct key * keyring ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;","struct key * keyring ;if ( new -> thread_keyring ) return 0 ;keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ;",3155
1003,if ( index > glyphCache -> glyphCache [ id ] . number )  {,if ( index >= glyphCache -> glyphCache [ id ] . number ) {,3156
1004,"end = strchr ( * value + 1 , \\\'""\\\' ) ;if ( ! end ) {end ++ ;}","char * p = end = * value + 1 ;while ( * p ) {if ( * p == \'\\\\\\\\\' ) {p ++ ;* end = * p ;}else {* end = * p ;if ( * p == \\\'""\\\' ) break ;}p ++ ;end ++ ;}if ( * end != \\\'""\\\' ) {end = ++ p ;}",3157
1005,"timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer ,  timer -> base -> get_time ( ) , timr -> it_interval ) ;","timr -> it_overrun += hrtimer_forward ( timer , timer -> base -> get_time ( ) , timr -> it_interval ) ;",3158
1006,if ( ! file )  OE_RAISE_ERRNO ( OE_EINVAL ) ;done :  return ret ;,if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( ret > ( ssize_t ) count ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : return ret ;,3159
1007,"cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) :  jas_stream_tmpfile ( ) ;","cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ;",3160
1008,"checkstackp ( L , 1 , ra ) ;}","checkstackGCp ( L , 1 , ra ) ;}",3161
1009,vpx_active_map_t map = {0 }map . rows = ( cfg -> g_h + 15 ) / 16 ;,"vpx_active_map_t map = {0 , 0 , 0 }map . rows = ( cfg -> g_h + 15 ) / 16 ;",3162
1010,"
","if ( zPath == 0 ) zPath = """" ;",3163
1011,nPath = ( int ) strlen ( zPath ) ;mTime = zipfileGetTime ( apVal [ 4 ] ) ;,nPath = ( int ) strlen ( zPath ) ;mTime = zipfileGetTime ( apVal [ 4 ] ) ;,3163
1012,union sctp_addr_param * addr_param ;__u32 serial ;int length ;,__u32 serial ;,3164
1013,"addr_param = ( union sctp_addr_param * ) hdr -> params ;length = ntohs ( addr_param -> p . length ) ;if ( length < sizeof ( sctp_paramhdr_t ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) addr_param , commands ) ;if ( ! sctp_verify_asconf ( asoc ,  ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) ,  ( void * ) chunk -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;","if ( ! sctp_verify_asconf ( asoc , ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) , ( void * ) chunk -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;",3164
1014,"sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) {if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) {goto beach ;}i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ;if ( i < 0 ) goto beach ;",st32 vnaux = entry -> vn_aux ;if ( vnaux < 1 ) {vstart += vnaux ;,3165
1015,"vstart += entry -> vn_aux ;for ( j = 0 , isum = i + entry -> vn_aux ;","vstart += entry -> vn_aux ;for ( j = 0 , isum = i + entry -> vn_aux ;",3165
1016,"for ( plane = 0 ;plane < 4 && src -> data [ plane ] ;plane ++ )  av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ;","for ( plane = 0 ;plane < 4 && src -> data [ plane ] && src -> linesize [ plane ] ;plane ++ ) av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ;",3166
1017,"DPRINTF ( ""Read<S2SV_blank>sector_count=%d\\\if ( r -> sector_count == 0 ) {scsi_req_complete ( & r -> req , GOOD ) ;return ;}assert ( r -> req . aiocb == NULL ) ;if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) {DPRINTF ( ""Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\\scsi_read_complete ( r , - EINVAL ) ;return ;}n = r -> sector_count ;if ( n > SCSI_DMA_BUF_SIZE / 512 ) n = SCSI_DMA_BUF_SIZE / 512 ;r -> iov . iov_len = n * 512 ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ;r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n ,  scsi_read_complete , r ) ;","r -> iov . iov_len = n * 512 ;qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ;bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ;r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , scsi_read_complete , r ) ;",3167
1018,"vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ;vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;}","memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ;memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ;}",3168
1019,char added ;},},3169
1020,pair -> added = 0 ;for ( it = tmp_subnodes -> first ;,for ( it = tmp_subnodes -> first ;,3169
1021,int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,struct address_space * mapping ;pgoff_t idx ;unsigned long size ;int vm_shared = dst_vma -> vm_flags & VM_SHARED ;struct hstate * h = hstate_vma ( dst_vma ) ;,3170
1022,"if ( vm_shared ) {struct address_space * mapping = dst_vma -> vm_file -> f_mapping ;pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;spin_lock ( ptl ) ;ret = - EEXIST ;","mapping = dst_vma -> vm_file -> f_mapping ;idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ;if ( vm_shared ) {size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_nounlock ;spin_lock ( ptl ) ;size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ;ret = - EFAULT ;if ( idx >= size ) goto out_release_unlock ;ret = - EEXIST ;",3170
1023,"if ( error == - EIO ) goto out ;xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ;memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ;goto out ;}ASSERT ( blkno == 0 ) ;error = xfs_attr3_leaf_create ( args , blkno , & bp ) ;if ( error ) {error = xfs_da_shrink_inode ( args , 0 , bp ) ;bp = NULL ;","if ( bp && ( xfs_da_shrink_inode ( args , 0 , bp ) ;bp = NULL ;",3171
1024,"if ( ! stream -> config . cfg . g_w || ! stream -> config . cfg . g_h )  fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>"" ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" , stream -> index ) ;if ( stream -> config . cfg . g_profile != 0 && ! global -> experimental_bitstream ) {fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>profile<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>experimental<S2SV_blank>and<S2SV_blank>requires<S2SV_blank>the<S2SV_blank>--%s<S2SV_blank>flag"" , stream -> index , stream -> config . cfg . g_profile , experimental_bitstream . long_name ) ;if ( ! streami -> config . out_fn )  fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>Output<S2SV_blank>file<S2SV_blank>is<S2SV_blank>required<S2SV_blank>(specify<S2SV_blank>with<S2SV_blank>-o)"" , streami -> index ) ;if ( streami != stream ) {const char * a = stream -> config . out_fn ;const char * b = streami -> config . out_fn ;const char * a = stream -> config . stats_fn ;const char * b = streami -> config . stats_fn ;if ( a && b && ! strcmp ( a , b ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ;}","( void ) global ;if ( ! stream -> config . cfg . g_input_bit_depth > ( unsigned int ) stream -> config . cfg . g_bit_depth ) {fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>codec<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)<S2SV_blank>less<S2SV_blank>than<S2SV_blank>input<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)"" , stream -> index , ( int ) stream -> config . cfg . g_bit_depth , stream -> config . cfg . g_input_bit_depth ) ;if ( ! streami -> config . out_fn ;const char * b = streami -> config . out_fn ;const char * a = stream -> config . stats_fn ;const char * b = streami -> config . fpmb_stats_fn ;const char * b = streami -> config . fpmb_stats_fn ;if ( a && b && ! strcmp ( a , b ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>mb<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ;# endif }",3172
1025,"case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR :  ip_printroute ( ndo , cp , option_len ) ;break ;","case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ;break ;",3173
1026,"if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;","if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;return 1 ;}if ( vmx_get_cpl ( vcpu ) ) {kvm_queue_exception ( vcpu , UD_VECTOR ) ;",3174
1027,"if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) {cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\\return - EINVAL ;}new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ;if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) {const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ;const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ;struct bpf_insn * patch = & insn_buf [ 0 ] ;bool issrc , isneg ;u32 off_reg ;aux = & env -> insn_aux_data [ i + delta ] ;if ( ! aux -> alu_state || aux -> alu_state == BPF_ALU_NON_POINTER ) continue ;isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ;issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ;off_reg = issrc ? insn -> src_reg : insn -> dst_reg ;if ( isneg )   * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ;* patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ;* patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ;* patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ;* patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ;* patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ;* patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ;if ( ! issrc ) * patch ++ = BPF_MOV64_REG ( insn -> dst_reg , insn -> src_reg ) ;if ( issrc && isneg )  * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ;","if ( isimm ) {* patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ;* patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ;* patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ;* patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ;}* patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ;* patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ;* patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ;* patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ;if ( ! issrc ) * patch ++ = BPF_MOV64_REG ( insn -> dst_reg , insn -> src_reg ) ;if ( issrc && isneg && ! isimm ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ;",3175
1028,"err = 0 ;skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ;payload_len = dg -> payload_size ;if ( payload_len != skb -> len - sizeof ( * dg ) ) {err = - EINVAL ;goto out ;}if ( payload_len > len ) {payload_len = len ;msg -> msg_flags |= MSG_TRUNC ;}err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ;if ( err ) goto out ;msg -> msg_namelen = 0 ;if ( msg -> msg_name ) {","msg -> msg_namelen = 0 ;err = 0 ;skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ;if ( msg -> msg_name ) {",3176
1029,"size_t i , maxcount ;const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ;","size_t maxcount ;const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ;",3177
1030,"ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ;* count = 0 ;for ( i = 0 ;i < CDF_TOLE4 ( si -> si_count ) ;i ++ ) {if ( i >= CDF_LOOP_LIMIT ) {DPRINTF ( ( ""Unpack<S2SV_blank>summary<S2SV_blank>info<S2SV_blank>loop<S2SV_blank>limit"" ) ) ;errno = EFTYPE ;if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) ,  info , count , & maxcount ) == - 1 ) {return - 1 ;}}","ssi -> si_count = CDF_TOLE4 ( si -> si_count ) ;* count = 0 ;if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) , info , count , & maxcount ) == - 1 ) {}",3177
1031,j < size ;,j < minsz ;,3178
1032,"for ( j = 0 ;r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ;}if ( op . val != UT64_MAX )  printline ( ""val"" , ""0x%08"" PFMT64x ""\\\if ( op . ptr != UT64_MAX )   printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\\if ( op . refptr != - 1 )   printline ( ""refptr"" , ""%d\\\printline ( ""size"" , ""%d\\\","int minsz = R_MIN ( len , size ) ;minsz = R_MAX ( minsz , 0 ) ;for ( j = 0 ;ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : buf [ j + idx ] ;r_cons_printf ( ""%02x"" , ch ) ;}if ( op . val != UT64_MAX ) {printline ( ""val"" , ""0x%08"" PFMT64x ""\\\}if ( op . ptr != UT64_MAX ) {printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\\}if ( op . refptr != - 1 ) {printline ( ""refptr"" , ""%d\\\}printline ( ""size"" , ""%d\\\",3178
1033,"int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ;","int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ;",3179
1034,if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,if ( ret < 0 ) {if ( ret != - EEXIST ) goto error ;,3180
1035,"REQ ( CHILD ( n , 0 ) , ASYNC ) ;REQ ( CHILD ( n , 1 ) , funcdef ) ;return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , decorator_seq ,   1 ) ;}","REQ ( CHILD ( n , 0 ) , NAME ) ;assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 ) ;REQ ( CHILD ( n , 1 ) , funcdef ) ;return ast_for_funcdef_impl ( c , n , decorator_seq , 1 ) ;}",3181
1036,"sprintf ( buf , ""%s.conf"" , set ) ;if ( ( f = fopen ( buf , ""r"" ) ) == NULL ) {printf ( ""\\\\\","snprintf ( buf , sizeof ( buf ) , ""%s.conf"" , set ) ;if ( ( f = fopen ( buf , ""r"" ) ) == NULL ) {printf ( ""\\\\\",3182
1037,hdr = ( void * ) p - head -> iov_base ;dlen = head -> iov_len + rqstp -> rq_arg . page_len - hdr ;,hdr = ( void * ) p - head -> iov_base ;if ( hdr > head -> iov_len ) return 0 ;dlen = head -> iov_len + rqstp -> rq_arg . page_len - hdr ;,3183
1038,"char * p , * q , * r ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;","char * p , * q ;Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ;",3184
1039,"printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;","printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\\<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\\exit ( 0 ) ;",3184
1040,"if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( * p ) ;p ++ )  ;lenIV = atoi ( line + 6 ) ;}else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) )  && strstr ( line , ""readstring"" ) ) {* p = \'\\\\0\' ;q = strrchr ( line , \'/\' ) ;if ( q ) {r = cs_start ;++ q ;while ( ! isspace ( * q ) && * q != \'{\' ) * r ++ = * q ++ ;* r = \'\\\\0\' ;* p = \'s\' ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) )  ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) )  ever_active = active = 1 ;for ( q = p ;isspace ( * q ) && * q != \'\\\q ++ )  ;","if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( ( unsigned char ) line [ 17 ] ) ) {for ( p = line + 18 ;isspace ( ( unsigned char ) * p ) ;p ++ ) ;+ q ;set_lenIV ( line ) ;else if ( ( p = strstr ( line , ""string<S2SV_blank>currentfile"" ) ) ) {set_cs_start ( line ) ;if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( ( unsigned char ) p [ 7 ] ) ) ever_active = active = 1 ;else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( ( unsigned char ) p [ 13 ] ) ) ever_active = active = 1 ;for ( q = p ;isspace ( ( unsigned char ) * q ) && * q != \'\\\q ++ ) ;",3184
1041,if ( * p ) {if ( p [ 0 ] == \'@\' ) {,char op0 = 0 ;if ( * p ) {if ( p [ 0 ] == \'@\' ) {,3185
1042,* q = 0 ;},op0 = * q ;* q = 0 ;},3185
1043,"cmd = p + 1 ;cmd = p + 1 ;}* p = \\\'""\\\' ;cmd = p ;",cmd = p ;cmd = p + 1 ;}* p = op0 ;cmd = p ;,3185
1044,"# if defined ( HAVE_OPENSSL ) && ! defined ( EMBEDDED_LIBRARY ) if ( mysql -> options . ssl_key || mysql -> options . ssl_cert || mysql -> options . ssl_ca || mysql -> options . ssl_capath || mysql -> options . ssl_cipher || ( mysql -> options . extension && mysql -> options . extension -> ssl_crl ) ||  ( mysql -> options . extension && mysql -> options . extension -> ssl_crlpath ) )   mysql -> options . use_ssl = 1 ;if ( mysql -> options . use_ssl ) mysql -> client_flag |= CLIENT_SSL ;# endif if ( mysql -> client_flag & CLIENT_PROTOCOL_41 ) {int4store ( buff , mysql -> client_flag ) ;int4store ( buff + 4 , net -> max_packet_size ) ;buff [ 8 ] = ( char ) mysql -> charset -> number ;memset ( buff + 9 , 0 , 32 - 9 ) ;end = buff + 32 ;else {int2store ( buff , mysql -> client_flag ) ;int3store ( buff + 2 , net -> max_packet_size ) ;end = buff + 5 ;# ifdef HAVE_OPENSSL  if ( mysql -> client_flag & CLIENT_SSL )  {unsigned long ssl_error ;MYSQL_TRACE ( SEND_SSL_REQUEST , mysql , ( end - buff , ( const unsigned char * ) buff ) ) ;","# if defined ( HAVE_OPENSSL ) && ! defined ( EMBEDDED_LIBRARY ) if ( mysql -> options . ssl_key || mysql -> options . ssl_cert || mysql -> options . ssl_ca || mysql -> options . ssl_capath || mysql -> options . ssl_cipher || ( mysql -> options . extension && mysql -> options . extension -> ssl_crl ) || ( mysql -> options . extension && mysql -> options . extension -> ssl_crlpath ) || ( mysql -> options . extension && mysql -> options . extension -> ssl_enforce ) ) mysql -> options . use_ssl = TRUE ;if ( mysql -> options . use_ssl ) mysql -> client_flag |= CLIENT_SSL ;# endif if ( mysql -> options . extension && mysql -> options . extension -> ssl_enforce ) {DBUG_ASSERT ( mysql -> options . use_ssl ) ;if ( ! ( mysql -> server_capabilities & CLIENT_SSL ) ) {set_mysql_extended_error ( mysql , CR_SSL_CONNECTION_ERROR , unknown_sqlstate , ER ( CR_SSL_CONNECTION_ERROR ) , ""SSL<S2SV_blank>is<S2SV_blank>required<S2SV_blank>but<S2SV_blank>the<S2SV_blank>server<S2SV_blank>doesn\\\'t<S2SV_blank>"" ""support<S2SV_blank>it"" ) ;goto error ;if ( ( mysql -> server_capabilities & CLIENT_SSL ) && mysql -> options . use_ssl ) {unsigned long ssl_error ;if ( ! mysql -> options . ssl_cipher ) {SET_OPTION ( ssl_cipher , default_ssl_cipher ) ;}MYSQL_TRACE ( SEND_SSL_REQUEST , mysql , ( end - buff , ( const unsigned char * ) buff ) ) ;",3186
1045,switch ( header -> biSize ) {,"switch ( header -> biBitCount == 0 ) {fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\\return OPJ_FALSE ;}if ( header -> biSize ) {",3187
1046,if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,if ( header -> biSize >= 40U ) {header -> biCompression = ( OPJ_UINT32 ) getc ( IN ) ;,3187
1047,"int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;","unlink ( path ) ;int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_EXCL , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;",3188
1048,return - ETIMEDOUT ;},kfree_skb ( skb ) ;return - ETIMEDOUT ;},3189
1049,"
",ctx -> si . w = 0 ;ctx -> si . h = 0 ;,3190
1050,vp8_clear_system_state ( ) ;return - 1 ;,vp8_clear_system_state ( ) ;return - 1 ;,3190
1051,"if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {ret = key -> type -> instantiate ( key , prep ) ;set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;","if ( key -> state == KEY_IS_UNINSTANTIATED ) {ret = key -> type -> instantiate ( key , prep ) ;mark_key_instantiated ( key , 0 ) ;if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;",3191
1052,"BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t )  ldblk , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;","BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ;if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ;",3192
1053,"if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 )  if ( copy_from_user ( & ifr , argp , ifreq_len ) )  return - EFAULT ;if ( cmd == TUNGETFEATURES ) {","if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) {if ( copy_from_user ( & ifr , argp , ifreq_len ) ) return - EFAULT ;}else memset ( & ifr , 0 , sizeof ( ifr ) ) ;if ( cmd == TUNGETFEATURES ) {",3193
1054,"
",last_name = 0 ;,3194
1055,if ( gfs )  gfs -> errors = gfc . errors [ 1 ] ;,if ( gfs ) gfs -> errors = gfc . errors [ 1 ] ;,3194
1056,"void bpf_map_inc ( struct bpf_map * map , bool uref )  {atomic_inc ( & map -> refcnt ) ;if ( uref ) atomic_inc ( & map -> usercnt ) ;}","struct bpf_map * bpf_map_inc ( struct bpf_map * map , bool uref ) {if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) {atomic_dec ( & map -> refcnt ) ;return ERR_PTR ( - EBUSY ) ;}if ( uref ) atomic_inc ( & map -> usercnt ) ;return map ;}",3195
1057,usb_conv_info -> class_data = u3v_conv_info ;},usb_conv_info -> class_data = u3v_conv_info ;usb_conv_info -> class_data_type = USB_CONV_U3V ;}else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) {return 0 ;},3196
1058,if ( plen == 0 ) {break ;,if ( plen < sizeof ( struct sctp_paramhdr ) ) {break ;,3197
1059,"
",if ( plen < sizeof ( struct sctp_asconf_addrv4_param ) ) {return ( - 101 ) ;},3197
1060,"phdr = sctp_get_next_param ( m , offset ,  ( struct sctp_paramhdr * ) & lstore , plen ) ;","phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) & lstore , plen ) ;",3197
1061,"if ( error == NULL ) {issuer_known = TRUE ;if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ;else if ( verify & GNUTLS_CERT_INVALID )  inf_gnutls_certificate_verification_set_error ( & error , verify ) ;}}",}if ( error == NULL ) if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) {},3198
1062,"str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ;if ( str == ( unsigned char * ) NULL ) {","str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count + 1 , sizeof ( * str ) ) ;if ( str == ( unsigned char * ) NULL ) {",3199
1063,"PyObject * logical = NULL ;FriBidiParType base = FRIBIDI_TYPE_RTL ;const char * encoding = ""utf-8"" ;static char * kwargs [ ] =  {""logical"" , ""base_direction"" , ""encoding"" , ""clean"" , ""reordernsm"" , NULL }if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""O|isii"" , kwargs ,   & logical , & base , & encoding , & clean , & reordernsm ) )   return NULL ;if ( ! ( base == FRIBIDI_TYPE_RTL ||  base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) )  return PyErr_Format ( PyExc_ValueError , ""invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON"" , base ) ;if ( PyUnicode_Check ( logical ) )  return log2vis_unicode ( logical , base , clean , reordernsm ) ;else if ( PyString_Check ( logical ) )  return log2vis_encoded_string ( logical , encoding , base , clean , reordernsm ) ;else return PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>unicode<S2SV_blank>or<S2SV_blank>str,<S2SV_blank>not<S2SV_blank>%s"" , logical -> ob_type -> tp_name ) ;","PyUnicodeObject * logical = NULL ;FriBidiParType base = FRIBIDI_TYPE_RTL ;static char * kwargs [ ] = {""logical"" , ""base_direction"" , ""clean"" , ""reordernsm"" , NULL }if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""U|iii"" , kwargs , & logical , & base , & clean , & reordernsm ) ) {return NULL ;}if ( ! ( base == FRIBIDI_TYPE_RTL || base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) {return PyErr_Format ( PyExc_ValueError , ""invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON"" , base ) ;}return unicode_log2vis ( logical , base , clean , reordernsm ) ;",3200
1064,"nfca_poll -> nfcid1_len = * data ++ ;pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\\","nfca_poll -> nfcid1_len = min_t ( __u8 , * data ++ , NFC_NFCID1_MAXSIZE ) ;pr_debug ( ""sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\\",3201
1065,"int zero_bits = * in & 0x07 ;size_t octets_left = inlen - 1 ;int i , count = 0 ;memset ( outbuf , 0 , outlen ) ;","int i , count = 0 ;int zero_bits ;size_t octets_left ;if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ;if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ;zero_bits = * in & 0x07 ;octets_left = inlen - 1 ;int i , count = 0 ;memset ( outbuf , 0 , outlen ) ;",3202
1066,if ( uid >= AID_APP ) {return 0 ;,if ( multiuser_get_app_id ( uid ) >= AID_APP ) {return 0 ;,3203
1067,"ret = get_tag ( asn1 , len , & inner_tag , & asn1 , & len , & rem , & rlen ) ;if ( ret ) return ret ;","ret = get_tag ( asn1 , len , & inner_tag , & asn1 , & len , & rem , & rlen , 0 ) ;if ( ret ) return ret ;",3204
1068,"}return ( PTR_DIFF ( s , s0 ) + 1 ) ;","ND_TCHECK2 ( * s , 1 ) ;}return ( PTR_DIFF ( s , s0 ) + 1 ) ;",3205
1069,"if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) {s -> width = s -> height = 0 ;","if ( ( ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ) < 0 ) {s -> width = s -> height = 0 ;",3206
1070,"static ssize_t  pipe_write ( struct kiocb * iocb , const struct iovec * _iov ,  unsigned long nr_segs , loff_t ppos ) {ssize_t ret ;int do_wakeup ;struct iovec * iov = ( struct iovec * ) _iov ;size_t total_len ;ssize_t chars ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) )  return 0 ;do_wakeup = 0 ;ret = 0 ;","static ssize_t pipe_write ( struct kiocb * iocb , struct iov_iter * from ) {ssize_t ret = 0 ;int do_wakeup = 0 ;size_t total_len = iov_iter_count ( from ) ;ssize_t chars ;total_len = iov_length ( iov , nr_segs ) ;if ( unlikely ( total_len == 0 ) ) return 0 ;",3207
1071,"int error , atomic = 1 ;void * addr ;error = ops -> confirm ( pipe , buf ) ;iov_fault_in_pages_read ( iov , chars ) ;redo1 : if ( atomic ) addr = kmap_atomic ( buf -> page ) ;else addr = kmap ( buf -> page ) ;error = pipe_iov_copy_from_user ( offset + addr , iov , chars , atomic ) ;if ( atomic ) kunmap_atomic ( addr ) ;else kunmap ( buf -> page ) ;ret = error ;do_wakeup = 1 ;if ( error ) {if ( atomic ) {atomic = 0 ;goto redo1 ;}}buf -> len += chars ;total_len -= chars ;ret = chars ;","int error = ops -> confirm ( pipe , buf ) ;ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ;if ( unlikely ( ret < chars ) ) {error = - EFAULT ;}do_wakeup = 1 ;buf -> len += chars ;total_len -= chars ;ret = chars ;",3207
1072,"char * src ;int error , atomic = 1 ;",int copied ;,3207
1073,"chars = PAGE_SIZE ;if ( chars > total_len ) chars = total_len ;iov_fault_in_pages_read ( iov , chars ) ;redo2 : if ( atomic ) src = kmap_atomic ( page ) ;else src = kmap ( page ) ;error = pipe_iov_copy_from_user ( src , iov , chars , atomic ) ;if ( unlikely ( error ) ) {if ( atomic ) {ret += chars ;buf -> page = page ;buf -> len = chars ;buf -> flags = 0 ;total_len -= chars ;if ( ! total_len ) break ;","copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from ) ;if ( unlikely ( error ) ) {if ( atomic ) {ret += copied ;buf -> page = page ;buf -> len = copied ;buf -> flags = 0 ;if ( ! iov_iter_count ( from ) ) break ;",3207
1074,u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;if ( insn_bitness == 32 ) {,u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;u32 dst = insn -> dst_reg ;int ret ;if ( insn_bitness == 32 ) {,3208
1075,"case BPF_ADD :  if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) ||  signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {","case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\return ret ;}if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) {",3208
1076,"case BPF_SUB :  if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) ||  signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {","case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\\return ret ;}if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) {",3208
1077,tlv = cp + i ;type = ( uint8_t ) tlv [ 0 ] ;,if ( i + 2 > length ) return - 1 ;tlv = cp + i ;type = ( uint8_t ) tlv [ 0 ] ;,3209
1078,"ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ;switch ( type ) {","ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ;if ( i + 2 + optlen > length ) return - 1 ;switch ( type ) {",3209
1079,"error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp1 ) ;if ( error ) return error ;if ( args -> blkno2 != args -> blkno ) {error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno2 , - 1 , & bp2 ) ;if ( error ) return error ;}else {bp2 = bp1 ;}leaf1 = bp1 -> b_addr ;entry1 = & xfs_attr3_leaf_entryp ( leaf1 ) [ args -> index ] ;leaf2 = bp2 -> b_addr ;entry2 = & xfs_attr3_leaf_entryp ( leaf2 ) [ args -> index2 ] ;# ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr1 , leaf1 ) ;ASSERT ( args -> index < ichdr1 . count ) ;ASSERT ( args -> index >= 0 ) ;xfs_attr3_leaf_hdr_from_disk ( & ichdr2 , leaf2 ) ;ASSERT ( args -> index2 < ichdr2 . count ) ;ASSERT ( args -> index2 >= 0 ) ;if ( entry1 -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf1 , args -> index ) ;namelen1 = name_loc -> namelen ;name1 = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ;namelen1 = name_rmt -> namelen ;name1 = ( char * ) name_rmt -> name ;}if ( entry2 -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf2 , args -> index2 ) ;namelen2 = name_loc -> namelen ;name2 = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf2 , args -> index2 ) ;namelen2 = name_rmt -> namelen ;name2 = ( char * ) name_rmt -> name ;}ASSERT ( be32_to_cpu ( entry1 -> hashval ) == be32_to_cpu ( entry2 -> hashval ) ) ;ASSERT ( namelen1 == namelen2 ) ;ASSERT ( memcmp ( name1 , name2 , namelen1 ) == 0 ) ;# endif ASSERT ( entry1 -> flags & XFS_ATTR_INCOMPLETE ) ;ASSERT ( ( entry2 -> flags & XFS_ATTR_INCOMPLETE ) == 0 ) ;entry1 -> flags &= ~ XFS_ATTR_INCOMPLETE ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , entry1 , sizeof ( * entry1 ) ) ) ;if ( args -> rmtblkno ) {ASSERT ( ( entry1 -> flags & XFS_ATTR_LOCAL ) == 0 ) ;name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ;name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ;name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ;","error = xfs_attr3_leaf_read ( args -> rmtvaluelen ) ;xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ;",3210
1080,if ( shdr -> sh_size < 1 ) {return false ;,if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) {return false ;,3211
1081,"
","Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ;const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ;Jid * msg_jid = jid_create ( stanza_from ) ;if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) {log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ;return TRUE ;}",3212
1082,const gchar * to = xmpp_stanza_get_to ( message ) ;const gchar * from = xmpp_stanza_get_from ( message ) ;Jid * jid_to = jid_create ( to ) ;Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ;,const gchar * to = xmpp_stanza_get_to ( message ) ;const gchar * from = xmpp_stanza_get_from ( message ) ;Jid * jid_to = jid_create ( to ) ;,3212
1083,"buff [ r ] = \'\\\\0\' ;set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ;","buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) ] = \'\\\\0\' ;set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ;",3213
1084,return error ;},return error < 0 ? error : 0 ;},3214
1085,if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,if ( num < 0 || num >= 256 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ;,3215
1086,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ;if ( p == prev ) {,3215
1087,"static int cfm_network_addr_print ( netdissect_options * ndo ,  register const u_char * tptr )  {u_int hexdump = FALSE ;network_addr_type = * tptr ;case AFNUM_INET :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 :  ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;","static int cfm_network_addr_print ( netdissect_options * ndo , register const u_char * tptr , const u_int length ) {u_int hexdump = FALSE ;if ( length < 1 ) {ND_PRINT ( ( ndo , ""\\\return hexdump ;}network_addr_type = * tptr ;case AFNUM_INET : if ( length != 1 + 4 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ;break ;case AFNUM_INET6 : if ( length != 1 + 16 ) {ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ;hexdump = TRUE ;break ;}ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ;break ;",3216
1088,"vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",3217
1089,"decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ;decoder_info -> pb_split = get_flc ( 1 , stream ) ;","decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ;decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE ) ) ;decoder_info -> pb_split = get_flc ( 1 , stream ) ;",3218
1090,"vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;","memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;ta = ( ENTROPY_CONTEXT * ) & t_above ;",3219
1091,"void vp9_write_nmv_probs ( VP9_COMMON * cm , int usehp , vp9_writer * w ) {int i , j ;nmv_context * const mvc = & cm -> fc . nmvc ;nmv_context_counts * const counts = & cm -> counts . mv ;","void vp9_write_nmv_probs ( VP9_COMMON * cm , int usehp , vpx_writer * w , nmv_context_counts * const counts ) {int i , j ;nmv_context * const mvc = & cm -> fc -> nmvc ;",3220
1092,"size_t columns ,  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads ,  sizeof ( * pixels ) ) ;( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ )  {","size_t columns , rows ;rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) ;pixels = ( PixelChannels * * ) AcquireQuantumMemory ( rows , sizeof ( * pixels ) ) ;columns = MaxPixelChannels ;for ( i = 0 ;i ++ ) {",3221
1093,"static void temporal_filter_iterate_c ( VP9_COMP * cpi ,  int frame_count ,  int alt_ref_index , int strength , struct scale_factors * scale ) {int mb_cols = cpi -> common . mb_cols ;int mb_rows = cpi -> common . mb_rows ;int mb_y_offset = 0 ;int mb_uv_offset = 0 ;DECLARE_ALIGNED_ARRAY ( 16 , unsigned int , accumulator , 16 * 16 * 3 ) ;DECLARE_ALIGNED_ARRAY ( 16 , uint16_t , count , 16 * 16 * 3 ) ;MACROBLOCKD * mbd = & cpi -> mb . e_mbd ;YV12_BUFFER_CONFIG * f = cpi -> frames [ alt_ref_index ] ;uint8_t * dst1 , * dst2 ;DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , predictor , 16 * 16 * 3 ) ;const int mb_uv_height = 16 >> mbd -> plane [ 1 ] . subsampling_y ;uint8_t * input_buffer [ MAX_MB_PLANE ] ;int i ;assert ( mbd -> plane [ 1 ] . subsampling_x == mbd -> plane [ 1 ] . subsampling_y ) ;for ( i = 0 ;# if ALT_REF_MC_ENABLED  cpi -> mb . mv_row_min = - ( ( mb_row * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;cpi -> mb . mv_row_max = ( ( cpi -> common . mb_rows - 1 - mb_row ) * 16 )  + ( 17 - 2 * VP9_INTERP_EXTEND ) ;# endif  for ( mb_col = 0 ;vpx_memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ;vpx_memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ;# if ALT_REF_MC_ENABLED  cpi -> mb . mv_col_min = - ( ( mb_col * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;cpi -> mb . mv_col_max = ( ( cpi -> common . mb_cols - 1 - mb_col ) * 16 )  + ( 17 - 2 * VP9_INTERP_EXTEND ) ;# endif  for ( frame = 0 ;if ( cpi -> frames [ frame ] == NULL )  continue ;int err = 0 ;# if ALT_REF_MC_ENABLED # define THRESH_LOW 10000 # define THRESH_HIGH 20000 err = temporal_filter_find_matching_mb_c ( cpi ,  cpi -> frames [ alt_ref_index ] -> y_buffer + mb_y_offset ,   cpi -> frames [ frame ] -> y_buffer + mb_y_offset ,   cpi -> frames [ frame ] -> y_stride ) ;# endif   filter_weight = err < THRESH_LOW   ? 2 : err < THRESH_HIGH ? 1 : 0 ;}temporal_filter_predictors_mb_c ( mbd ,  cpi -> frames [ frame ] -> y_buffer + mb_y_offset ,  cpi -> frames [ frame ] -> u_buffer + mb_uv_offset , cpi -> frames [ frame ] -> v_buffer + mb_uv_offset , cpi -> frames [ frame ] -> y_stride , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ;","static void temporal_filter_iterate_c ( VP9_COMP * cpi , YV12_BUFFER_CONFIG * * frames , int frame_count , int alt_ref_index , int strength , struct scale_factors * scale ) {int mb_cols = ( frames [ alt_ref_index ] -> y_crop_width + 15 ) >> 4 ;int mb_rows = ( frames [ alt_ref_index ] -> y_crop_height + 15 ) >> 4 ;int mb_y_offset = 0 ;DECLARE_ALIGNED ( 16 , unsigned int , accumulator , 16 * 16 * 3 ] ) ;DECLARE_ALIGNED ( 16 , uint16_t , count [ 16 * 16 * 3 ] ) ;MACROBLOCKD * mbd = & cpi -> td . mb . e_mbd ;YV12_BUFFER_CONFIG * f = frames [ alt_ref_index ] ;uint8_t * dst1 , * dst2 ;# if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , predictor16 [ 16 * 16 * 3 ] ) ;DECLARE_ALIGNED ( 16 , uint8_t , predictor8 [ 16 * 16 * 3 ] ) ;uint8_t * predictor ;# else DECLARE_ALIGNED ( 16 , uint8_t , predictor [ 16 * 16 * 3 ] ) ;# endif const int mb_uv_height = 16 >> mbd -> plane [ 1 ] . subsampling_y ;const int mb_uv_width = 16 >> mbd -> plane [ 1 ] . subsampling_x ;uint8_t * input_buffer [ MAX_MB_PLANE ] ;int i ;# if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {predictor = CONVERT_TO_BYTEPTR ( predictor16 ) ;}else {predictor = predictor8 ;}# endif for ( i = 0 ;cpi -> td . mb . mv_row_min = - ( ( mb_row * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;cpi -> td . mb . mv_row_max = ( ( mb_rows - 1 - mb_row ) * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ;for ( mb_col = 0 ;memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ;memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ;cpi -> td . mb . mv_col_min = - ( ( mb_col * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ) ;cpi -> td . mb . mv_col_max = ( ( mb_cols - 1 - mb_col ) * 16 ) + ( 17 - 2 * VP9_INTERP_EXTEND ) ;for ( frame = 0 ;const int thresh_low = 10000 ;const int thresh_high = 20000 ;if ( frames [ frame ] == NULL ) continue ;int err = temporal_filter_find_matching_mb_c ( cpi , cpi -> frames [ alt_ref_index ] -> y_buffer + mb_y_offset , cpi -> frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> y_stride ) ;# endif filter_weight = err < THRESH_LOW ? 2 : err < THRESH_HIGH ? 1 : 0 ;}temporal_filter_predictors_mb_c ( mbd , cpi -> frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> u_buffer + mb_uv_offset , cpi -> frames [ frame ] -> v_buffer + mb_uv_offset , cpi -> frames [ frame ] -> y_stride , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ;",3222
1094,pval *= cpi -> fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;byte ++ ;stride = cpi -> alt_ref_buffer . uv_stride ;byte = mb_uv_offset ;for ( j = 0 ;j < mb_uv_height ;int m = k + 256 ;pval *= cpi -> fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;pval *= cpi -> fixed_divide [ count [ m ] ] ;pval >>= 19 ;dst2 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - mb_uv_height ;}mb_y_offset += 16 ;mb_uv_offset += mb_uv_height ;}mb_uv_offset += mb_uv_height * ( f -> uv_stride - mb_cols ) ;},"pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1_16 [ byte ] = ( uint16_t ) pval ;byte ++ ;dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) ;dst2_16 = CONVERT_TO_SHORTPTR ( dst2 ) ;stride = cpi -> alt_ref_buffer . uv_stride ;byte = mb_uv_offset ;for ( j = 0 ;j < mb_uv_width ;int m = k + 256 ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1_16 [ byte ] = ( uint16_t ) pval ;pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;pval *= fixed_divide [ count [ m ] ] ;pval >>= 19 ;dst2_16 [ byte ] = ( uint16_t ) pval ;byte ++ ;}byte += stride - mb_uv_width ;}}else {dst1 = cpi -> alt_ref_buffer . y_buffer ;stride = cpi -> alt_ref_buffer . y_stride ;byte = mb_y_offset ;for ( i = 0 , k = 0 ;i < 16 ;i ++ ) {for ( j = 0 ;j < 16 ;j ++ , k ++ ) {unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - 16 ;}dst1 = cpi -> alt_ref_buffer . u_buffer ;dst2 = cpi -> alt_ref_buffer . v_buffer ;stride = cpi -> alt_ref_buffer . uv_stride ;byte = mb_uv_offset ;for ( i = 0 , k = 256 ;i < mb_uv_height ;i ++ ) {for ( j = 0 ;j < mb_uv_width ;j ++ , k ++ ) {int m = k + 256 ;unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;pval *= fixed_divide [ count [ m ] ] ;pval >>= 19 ;dst2 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - mb_uv_width ;}}# else dst1 = cpi -> alt_ref_buffer . y_buffer ;stride = cpi -> alt_ref_buffer . y_stride ;byte = mb_y_offset ;for ( i = 0 , k = 0 ;i < 16 ;i ++ ) {for ( j = 0 ;j < 16 ;j ++ , k ++ ) {unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - 16 ;}dst1 = cpi -> alt_ref_buffer . u_buffer ;dst2 = cpi -> alt_ref_buffer . v_buffer ;stride = cpi -> alt_ref_buffer . uv_stride ;byte = mb_uv_offset ;for ( i = 0 , k = 256 ;i < mb_uv_height ;i ++ ) {for ( j = 0 ;j < mb_uv_width ;j ++ , k ++ ) {int m = k + 256 ;unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ;pval *= fixed_divide [ count [ k ] ] ;pval >>= 19 ;dst1 [ byte ] = ( uint8_t ) pval ;pval = accumulator [ m ] + ( count [ m ] >> 1 ) ;pval *= fixed_divide [ count [ m ] ] ;pval >>= 19 ;dst2 [ byte ] = ( uint8_t ) pval ;byte ++ ;}byte += stride - mb_uv_width ;}# endif mb_y_offset += 16 ;mb_uv_offset += mb_uv_width ;}mb_uv_offset += mb_uv_height * f -> uv_stride - mb_cols ) ;}",3222
1095,if ( l >= ( len - o ) ) {iter -> err_off = o ;,if ( l >= ( len - o - 4 ) ) {iter -> err_off = o ;,3223
1096,"if ( ! rtlpriv -> usb_data )  return - ENOMEM ;spin_lock_init ( & rtlpriv -> locks . usb_lock ) ;INIT_WORK ( & rtlpriv -> works . fill_h2c_cmd , rtl_fill_h2c_cmd_work_callback ) ;","if ( ! rtlpriv -> usb_data ) {ieee80211_free_hw ( hw ) ;return - ENOMEM ;}spin_lock_init ( & rtlpriv -> locks . usb_lock ) ;INIT_WORK ( & rtlpriv -> works . fill_h2c_cmd , rtl_fill_h2c_cmd_work_callback ) ;kfree ( rtlpriv -> usb_data ) ;",3224
1097,complete ( & rtlpriv -> firmware_loading_complete ) ;return - ENODEV ;,complete ( & rtlpriv -> firmware_loading_complete ) ;return - ENODEV ;,3224
1098,ps_codec -> i4_slice_error = 0 ;,ret = ps_codec -> i4_slice_error = 0 ;,3225
1099,"
",if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) {return ret ;},3225
1100,"ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ;}","ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ;}",3225
1101,while ( collen > 0 )  {while ( replen > 0 )  {,while ( indexw < width && collen > 0 ) {while ( indexw < width && replen > 0 ) {,3226
1102,while ( collen > 0 )  {,while ( indexw < width && collen > 0 ) {,3226
1103,while ( replen > 0 )  {,while ( indexw < width && replen > 0 ) {,3226
1104,if ( g -> sect <= 0 ||   g -> head <= 0 ||  ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,if ( ( int ) g -> sect <= 0 || ( int ) g -> head <= 0 || ( int ) ( g -> sect * g -> head ) <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,3227
1105,"int retval = 0 ;int bytes_read = 0 ;retval = - ENODEV ;goto exit ;bytes_read = snprintf ( in_buffer , 20 , ""%lld\\\spin_unlock_irqrestore ( & dev -> lock , flags ) ;if ( * ppos < bytes_read ) {if ( copy_to_user ( buffer , in_buffer + * ppos , bytes_read - * ppos ) ) retval = - EFAULT ;else {retval = bytes_read - * ppos ;* ppos += bytes_read ;}exit : mutex_unlock ( & dev -> io_mutex ) ;return retval ;}","int len = 0 ;int bytes_read = 0 ;mutex_unlock ( & dev -> io_mutex ) ;return - ENODEV ;len = snprintf ( in_buffer , 20 , ""%lld\\\spin_unlock_irqrestore ( & dev -> lock , flags ) ;mutex_unlock ( & dev -> io_mutex ) ;return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) ;",3228
1106,"draw_info -> geometry = AcquireString ( geometry ) ;status = AnnotateImage ( image , draw_info ) ;","( void ) CloneString ( & draw_info -> geometry = AcquireString ( geometry ) ;status = AnnotateImage ( image , draw_info ) ;",3229
1107,"isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;","isoclns_print ( ndo , p , length , caplen ) ;return ( hdrlen ) ;",3230
1108,const VP9_CONFIG * const oxcf = & cpi -> oxcf ;int layer ;int layer_end ;if ( svc -> number_temporal_layers > 1 ) {layer_end = svc -> number_temporal_layers ;else {layer_end = svc -> number_spatial_layers ;}for ( layer = 0 ;layer < layer_end ;++ layer ) {LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ;RATE_CONTROL * const lrc = & lc -> rc ;lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ;,"const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;int sl , tl ;int alt_ref_idx = svc -> number_spatial_layers ;if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . pass == 2 ) {if ( vpx_realloc_frame_buffer ( & cpi -> svc . empty_frame . img , SMALL_FRAME_WIDTH , SMALL_FRAME_HEIGHT , cpi -> common . subsampling_x , cpi -> common . subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cpi -> common . use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , cpi -> common . byte_alignment , NULL , NULL , NULL ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>empty<S2SV_blank>frame<S2SV_blank>for<S2SV_blank>multiple<S2SV_blank>frame<S2SV_blank>"" ""contexts"" ) ;memset ( cpi -> svc . empty_frame . img . buffer_alloc , 0x80 , cpi -> svc . empty_frame . img . buffer_alloc_sz ) ;+ layer ) {for ( sl = 0 ;sl < oxcf -> ss_number_layers ;++ sl ) {for ( tl = 0 ;tl < oxcf -> ts_number_layers ;++ tl ) {int layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ;LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ;RATE_CONTROL * const lrc = & lc -> rc ;int i ;lc -> layer_size = 0 ;lc -> frames_from_key_frame = 0 ;lc -> last_frame_type = FRAME_TYPES ;",3231
1109,"lrc -> rate_correction_factor = 1.0 ;lrc -> key_frame_rate_correction_factor = 1.0 ;if ( svc -> number_temporal_layers > 1 ) {lc -> target_bandwidth = oxcf -> ts_target_bitrate [ layer ] * 1000 ;lc -> target_bandwidth = oxcf -> ss_target_bitrate [ layer ] * 1000 ;lrc -> last_q [ 0 ] = oxcf -> best_allowed_q ;lrc -> last_q [ 1 ] = oxcf -> best_allowed_q ;lrc -> last_q [ 2 ] = oxcf -> best_allowed_q ;lrc -> buffer_level = vp9_rescale ( ( int ) ( oxcf -> starting_buffer_level ) , lc -> target_bandwidth , 1000 ) ;",for ( i = 0 ;i < RATE_FACTOR_LEVELS ;++ i ) {lrc -> rate_correction_factors [ i ] = 1.0 ;}if ( cpi -> oxcf . rc_mode == VPX_CBR ) {lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ;lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ;lrc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ;lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ;lrc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ;lrc -> last_q [ INTER_FRAME ] = oxcf -> best_allowed_q ;lrc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;lrc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ;if ( oxcf -> ss_enable_auto_arf [ sl ] ) lc -> alt_ref_idx = alt_ref_idx ++ ;else lc -> alt_ref_idx = INVALID_IDX ;lc -> gold_ref_idx = INVALID_IDX ;lrc -> buffer_level = oxcf -> starting_buffer_level_ms * lc -> target_bandwidth / 1000 ;if ( ! ( svc -> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) && alt_ref_idx < REF_FRAMES ) svc -> layer_context [ 0 ] . gold_ref_idx = alt_ref_idx ;},3231
1110,"struct inode * inode = page -> mapping -> host ;int ret = - EAGAIN ;if ( ret == - EAGAIN )  ret = f2fs_mpage_readpages ( page -> mapping , NULL , page , 1 , false ) ;return ret ;","struct inode * inode = page_file_mapping ( page ) -> host ;int ret = - EAGAIN ;if ( ret == - EAGAIN ) ret = f2fs_mpage_readpages ( page_file_mapping ( page ) , NULL , page , 1 , false ) ;return ret ;",3232
1111,},"hook_del_nick_can_register ( check_registration_keywords ) ;hook_del_user_can_register ( check_registration_keywords ) ;del_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table ) ;}",3233
1112,"ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;","memset ( & ddi , 0 , sizeof ( ddi ) ) ;ddi . dinfo_nboards = dgnc_NumBoards ;sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ;",3234
1113,if ( po -> fanout )   return - EINVAL ;lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;,lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;rcu_read_lock ( ) ;if ( po -> fanout ) {ret = - EINVAL ;lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;,3235
1114,ps_dec -> u2_total_mbs_coded ++ ;u1_num_mbsNby2 ++ ;,u1_num_mbsNby2 ++ ;,3236
1115,if ( u1_tfr_n_mb )  u1_num_mbs = 0 ;,ps_dec -> u2_total_mbs_coded += u1_num_mbs ;if ( u1_tfr_n_mb ) u1_num_mbs = 0 ;,3236
1116,"if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) {ext4_debug ( ""inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\\ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\\list_for_each_entry ( io , & EXT4_I ( inode ) -> i_completed_io_list , list ) {","unsigned long flags ;if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) {ext4_debug ( ""inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\\spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\\list_for_each_entry ( io , & EXT4_I ( inode ) -> i_completed_io_list , list ) {",3237
1117,# endif  },"spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;# endif }",3237
1118,"static int __perf_event_overflow ( struct perf_event * event , int nmi ,  int throttle , struct perf_sample_data * data , struct pt_regs * regs ) {","static int __perf_event_overflow ( struct perf_event * event , int throttle , struct perf_sample_data * data , struct pt_regs * regs ) {",3238
1119,"if ( nmi ) {event -> pending_disable = 1 ;}else  perf_event_disable ( event ) ;if ( event -> overflow_handler ) event -> overflow_handler ( event , nmi , data , regs ) ;else  perf_event_output ( event , nmi , data , regs ) ;if ( event -> fasync && event -> pending_kill ) {if ( nmi ) {event -> pending_wakeup = 1 ;irq_work_queue ( & event -> pending ) ;}","event -> pending_disable = 1 ;irq_work_queue ( & event -> pending ) ;}if ( event -> overflow_handler ) event -> overflow_handler ( event , data , regs ) ;else perf_event_output ( event , nmi , data , regs ) ;if ( event -> fasync && event -> pending_kill ) {event -> pending_wakeup = 1 ;",3238
1120,"<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>6<S2SV_blank>}"" , ""a\\\\0x\\\\0b\\\\0"" ) ;assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>8<S2SV_blank>}"" , ""a\\\\0x\\\\0x\\\\0b\\\\0"" ) ;assert_regexp_syntax_error ( "")"" ) ;assert_true_regexp ( ""abc"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""abc"" , ""xbc"" ) ;assert_false_regexp ( ""abc"" , ""axc"" ) ;assert_false_regexp ( ""abc"" , ""abx"" ) ;assert_true_regexp ( ""abc"" , ""xabcx"" , ""abc"" ) ;assert_true_regexp ( ""abc"" , ""ababc"" , ""abc"" ) ;assert_true_regexp ( ""a.c"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""a.b"" , ""a\\\assert_false_regexp ( ""a.*b"" , ""acc\\\assert_false_regexp ( ""a.{4,5}b"" , ""acc\\\assert_true_regexp ( ""a.b"" , ""a\\\\rb"" , ""a\\\\rb"" ) ;assert_true_regexp ( ""ab*c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab*bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*bc"" , ""abbc"" , ""abbc"" ) ;assert_true_regexp ( ""a.*bb"" , ""abbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""a.*?bbb"" , ""abbbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""a.*c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a.*c"" , ""axyzc"" , ""axyzc"" ) ;assert_true_regexp ( ""ab+c"" , ""abbc"" , ""abbc"" ) ;assert_false_regexp ( ""ab+c"" , ""ac"" ) ;assert_true_regexp ( ""ab+"" , ""abbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""ab+?"" , ""abbbb"" , ""ab"" ) ;assert_false_regexp ( ""ab+bc"" , ""abc"" ) ;assert_false_regexp ( ""ab+bc"" , ""abq"" ) ;assert_true_regexp ( ""a+b+c"" , ""aabbabc"" , ""abc"" ) ;assert_false_regexp ( ""ab?bc"" , ""abbbbc"" ) ;assert_true_regexp ( ""ab?c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab*?"" , ""abbb"" , ""a"" ) ;assert_true_regexp ( ""ab?c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab??"" , ""ab"" , ""a"" ) ;assert_true_regexp ( ""a(b|x)c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a(b|x)c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a(b|.)c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a(b|x|y)c"" , ""ayc"" , ""ayc"" ) ;assert_true_regexp ( ""(a+|b)*"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a|b|c|d|e"" , ""e"" , ""e"" ) ;assert_true_regexp ( ""(a|b|c|d|e)f"" , ""ef"" , ""ef"" ) ;assert_true_regexp ( "".b{2}"" , ""abb"" , ""abb"" ) ;assert_true_regexp ( "".b{2,3}"" , ""abbb"" , ""abbb"" ) ;assert_true_regexp ( "".b{2,3}?"" , ""abbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{2,3}?c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( "".b{2,3}cccc"" , ""abbbcccc"" , ""abbbcccc"" ) ;assert_true_regexp ( "".b{2,3}?cccc"" , ""abbbcccc"" , ""bbbcccc"" ) ;assert_true_regexp ( ""a.b{2,3}cccc"" , ""aabbbcccc"" , ""aabbbcccc"" ) ;assert_true_regexp ( ""ab{2,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{2,3}?c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{0,1}?c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a{0,1}bc"" , ""bbc"" , ""bc"" ) ;assert_true_regexp ( ""a{0,1}?bc"" , ""abc"" , ""bc"" ) ;assert_true_regexp ( ""aa{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""aa{0,1}?bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""aa{0,1}bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{1}c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{1,2}c"" , ""abbc"" , ""abbc"" ) ;assert_true_regexp ( ""ab{1,}c"" , ""abbbc"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{1,}b"" , ""ab"" ) ;assert_false_regexp ( ""ab{1}c"" , ""abbc"" ) ;assert_true_regexp ( ""ab{0,}c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""ab{1,1}c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""ab{0,}c"" , ""abbbc"" , ""abbbc"" ) ;assert_true_regexp ( ""ab{,3}c"" , ""abbbc"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{,2}c"" , ""abbbc"" ) ;assert_false_regexp ( ""ab{4,5}bc"" , ""abbbbc"" ) ;assert_true_regexp ( ""ab{0,1}"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{0,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{0,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{0,4}"" , ""abbbbb"" , ""abbbb"" ) ;assert_true_regexp ( ""ab{1,1}"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{1,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{2,2}"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}"" , ""abbbbb"" , ""abbb"" ) ;assert_true_regexp ( ""ab{1,3}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{0,1}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,2}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,3}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{0,4}?"" , ""abbbbb"" , ""a"" ) ;assert_true_regexp ( ""ab{1,1}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,2}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{1,3}?"" , ""abbbbb"" , ""ab"" ) ;assert_true_regexp ( ""ab{2,2}?"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( ""ab{2,3}?"" , ""abbbbb"" , ""abb"" ) ;assert_true_regexp ( "".(abc){0,1}"" , ""xabcabcabcabc"" , ""xabc"" ) ;assert_true_regexp ( "".(abc){0,2}"" , ""xabcabcabcabc"" , ""xabcabc"" ) ;assert_true_regexp ( ""x{1,2}abcd"" , ""xxxxabcd"" , ""xxabcd"" ) ;assert_true_regexp ( ""x{1,2}abcd"" , ""xxxxabcd"" , ""xxabcd"" ) ;assert_true_regexp ( ""ab{.*}"" , ""ab{c}"" , ""ab{c}"" ) ;assert_true_regexp ( "".(aa){1,2}"" , ""aaaaaaaaaa"" , ""aaaaa"" ) ;assert_true_regexp ( ""a.(bc.){2}"" , ""aabcabca"" , ""aabcabca"" ) ;assert_true_regexp ( ""(ab{1,2}c){1,3}"" , ""abbcabc"" , ""abbcabc"" ) ;assert_true_regexp ( ""ab(c|cc){1,3}d"" , ""abccccccd"" , ""abccccccd"" ) ;assert_true_regexp ( ""a[bx]c"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a[bx]c"" , ""axc"" , ""axc"" ) ;assert_true_regexp ( ""a[0-9]*b"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a[0-9]*b"" , ""a0123456789b"" , ""a0123456789b"" ) ;assert_true_regexp ( ""[0-9a-f]+"" , ""0123456789abcdef"" , ""0123456789abcdef"" ) ;assert_true_regexp ( ""[0-9a-f]+"" , ""xyz0123456789xyz"" , ""0123456789"" ) ;assert_true_regexp ( ""a[\\\\\\\\s\\\\\\\\S]b"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ;assert_true_regexp ( ""a[\\\\\\\\d\\\\\\\\D]b"" , ""a1b"" , ""a1b"" ) ;assert_false_regexp ( ""[x-z]+"" , ""abc"" ) ;assert_true_regexp ( ""a[-]?c"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a[-b]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[-b]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a[b-]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[b-]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""[a-c-e]"" , ""b"" , ""b"" ) ;assert_true_regexp ( ""[a-c-e]"" , ""-"" , ""-"" ) ;assert_false_regexp ( ""[a-c-e]"" , ""d"" ) ;assert_regexp_syntax_error ( ""[b-a]"" ) ;assert_regexp_syntax_error ( ""(abc"" ) ;assert_regexp_syntax_error ( ""abc)"" ) ;assert_regexp_syntax_error ( ""a[]b"" ) ;assert_true_regexp ( ""a[\\\\\\\\-b]"" , ""a-"" , ""a-"" ) ;assert_true_regexp ( ""a[\\\\\\\\-b]"" , ""ab"" , ""ab"" ) ;assert_true_regexp ( ""a]"" , ""a]"" , ""a]"" ) ;assert_true_regexp ( ""a[]]b"" , ""a]b"" , ""a]b"" ) ;assert_true_regexp ( ""a[\\\\\\\\]]b"" , ""a]b"" , ""a]b"" ) ;assert_true_regexp ( ""a[^bc]d"" , ""aed"" , ""aed"" ) ;assert_false_regexp ( ""a[^bc]d"" , ""abd"" ) ;assert_true_regexp ( ""a[^-b]c"" , ""adc"" , ""adc"" ) ;assert_false_regexp ( ""a[^-b]c"" , ""a-c"" ) ;assert_false_regexp ( ""a[^]b]c"" , ""a]c"" ) ;assert_true_regexp ( ""a[^]b]c"" , ""adc"" , ""adc"" ) ;assert_true_regexp ( ""[^ab]*"" , ""cde"" , ""cde"" ) ;assert_regexp_syntax_error ( "")("" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\tb"" , ""a\\\\tb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\rb"" , ""a\\\\rb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\vb"" , ""a\\\\vb"" ) ;assert_true_regexp ( ""a\\\\\\\\sb"" , ""a\\\\fb"" , ""a\\\\fb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a<S2SV_blank>b"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\tb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\rb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\vb"" ) ;assert_false_regexp ( ""a\\\\\\\\Sb"" , ""a\\\\fb"" ) ;assert_true_regexp ( ""\\\\\\\assert_true_regexp ( ""[\\\\\\\assert_true_regexp ( ""\\\\\\\\x01\\\\\\\\x02\\\\\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" ) ;assert_true_regexp ( ""[\\\\\\\\x01-\\\\\\\\x03]+"" , ""\\\\x01\\\\x02\\\\x03"" , ""\\\\x01\\\\x02\\\\x03"" ) ;assert_false_regexp ( ""[\\\\\\\\x00-\\\\\\\\x02]+"" , ""\\\\x03\\\\x04\\\\x05"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D]"" , ""]"" , ""]"" ) ;assert_true_regexp ( ""[\\\\\\\\0x5A-\\\\\\\\x5D]"" , ""\\\\x5B"" , ""\\\\x5B"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""[\\\\\\\\x5C-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""[\\\\\\\\x5D-\\\\\\\\x5F]"" , ""\\\\x5E"" , ""\\\\x5E"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""a_c"" , ""a_c"" ) ;assert_true_regexp ( ""a\\\\\\\\wc"" , ""a0c"" , ""a0c"" ) ;assert_false_regexp ( ""a\\\\\\\\wc"" , ""a*c"" ) ;assert_true_regexp ( ""\\\\\\\\w+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ;assert_true_regexp ( ""[\\\\\\\\w]+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ;assert_true_regexp ( ""\\\\\\\\D+"" , ""1234abc5678"" , ""abc"" ) ;assert_true_regexp ( ""[\\\\\\\\d]+"" , ""0123456789"" , ""0123456789"" ) ;assert_true_regexp ( ""[\\\\\\\\D]+"" , ""1234abc5678"" , ""abc"" ) ;assert_true_regexp ( ""[\\\\\\\\da-fA-F]+"" , ""123abc"" , ""123abc"" ) ;assert_false_regexp ( ""^(ab|cd)e"" , ""abcde"" ) ;assert_true_regexp ( ""(abc|)ef"" , ""abcdef"" , ""ef"" ) ;assert_true_regexp ( ""(abc|)ef"" , ""abcef"" , ""abcef"" ) ;assert_true_regexp ( ""\\\\\\\\babc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""abc\\\\\\\\b"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""\\\\\\\\babc"" , ""1abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\b"" , ""abc1"" ) ;assert_true_regexp ( ""abc\\\\\\\\s\\\\\\\\b"" , ""abc<S2SV_blank>x"" , ""abc<S2SV_blank>"" ) ;assert_false_regexp ( ""abc\\\\\\\\s\\\\\\\\b"" , ""abc<S2SV_blank><S2SV_blank>"" ) ;assert_true_regexp ( ""\\\\\\\\babc\\\\\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""abcd"" , ""bcd"" ) ;assert_true_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w"" , ""abcd"" , ""abc"" ) ;assert_false_regexp ( ""\\\\\\\\b\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\b"" , ""abcd"" ) ;assert_false_regexp ( ""\\\\\\\\Babc"" , ""abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\B"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\Babc"" , ""1abc"" , ""abc"" ) ;assert_true_regexp ( ""abc\\\\\\\\B"" , ""abc1"" , ""abc"" ) ;assert_false_regexp ( ""abc\\\\\\\\s\\\\\\\\B"" , ""abc<S2SV_blank>x"" ) ;assert_true_regexp ( ""abc\\\\\\\\s\\\\\\\\B"" , ""abc<S2SV_blank><S2SV_blank>"" , ""abc<S2SV_blank>"" ) ;assert_true_regexp ( ""\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\B"" , ""abcd"" , ""abc"" ) ;assert_true_regexp ( ""\\\\\\\\B\\\\\\\\w\\\\\\\\w\\\\\\\\w"" , ""abcd"" , ""bcd"" ) ;assert_false_regexp ( ""\\\\\\\\B\\\\\\\\w\\\\\\\\w\\\\\\\\w\\\\\\\\B"" , ""abcd"" ) ;assert_regexp_syntax_error ( ""(|abc)ef"" ) ;assert_true_regexp ( ""((a)(b)c)(d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""(a|b)c*d"" , ""abcd"" , ""bcd"" ) ;assert_true_regexp ( ""(ab|ab*)bc"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""abc"" , ""abc"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""ac"" , ""ac"" ) ;assert_true_regexp ( ""a([bc]*)c*"" , ""a"" , ""a"" ) ;assert_true_regexp ( ""a([bc]*)(c*d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a([bc]+)(c*d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a([bc]*)(c+d)"" , ""abcd"" , ""abcd"" ) ;assert_true_regexp ( ""a[bcd]*dcdcde"" , ""adcdcde"" , ""adcdcde"" ) ;assert_false_regexp ( ""a[bcd]+dcdcde"" , ""adcdcde"" ) ;assert_true_regexp ( ""\\\\\\\\((.*),<S2SV_blank>(.*)\\\\\\\\)"" , ""(a,<S2SV_blank>b)"" , ""(a,<S2SV_blank>b)"" ) ;assert_true_regexp ( ""abc|123$"" , ""abcx"" , ""abc"" ) ;assert_false_regexp ( ""abc|123$"" , ""123x"" ) ;assert_true_regexp ( ""abc|^123"" , ""123"" , ""123"" ) ;assert_false_regexp ( ""abc|^123"" , ""x123"" ) ;assert_true_regexp ( ""^abc$"" , ""abc"" , ""abc"" ) ;assert_false_regexp ( ""^abc$"" , ""abcc"" ) ;assert_true_regexp ( ""^abc"" , ""abcc"" , ""abc"" ) ;assert_false_regexp ( ""^abc$"" , ""aabc"" ) ;assert_false_regexp ( ""abc^"" , ""abc"" ) ;assert_false_regexp ( ""ab^c"" , ""abc"" ) ;assert_false_regexp ( ""a^bcdef"" , ""abcdef"" ) assert_true_regexp ( ""abc$"" , ""aabc"" , ""abc"" ) ;assert_false_regexp ( ""$abc"" , ""abc"" ) ;assert_true_regexp ( ""(a|a$)bcd"" , ""abcd"" , ""abcd"" ) ;assert_false_regexp ( ""(a$|a$)bcd"" , ""abcd"" ) ;assert_false_regexp ( ""(abc$|ab$)"" , ""abcd"" ) ;assert_true_regexp ( ""^a(bc+|b[eh])g|.h$"" , ""abhg"" , ""abhg"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effgz"" , ""effgz"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""ij"" , ""ij"" ) ;assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effg"" ) ;assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""bcdd"" ) ;assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""reffgz"" , ""effgz"" ) ;assert_true_regexp ( ""whatever|<S2SV_blank><S2SV_blank><S2SV_blank>x.<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x0"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\x"" ) ;assert_regexp_syntax_error ( ""x{0,0}"" ) ;assert_regexp_syntax_error ( ""x{0}"" ) ;assert_regexp_syntax_error ( ""\\\\\\\\xxy"" ) ;assert_error ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a\\\\\\\\/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ERROR_SYNTAX_ERROR ) ;assert_error ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/[a\\\\\\\\/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ERROR_SYNTAX_ERROR ) ;assert_true_rule_blob (  ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\\\t/<S2SV_blank>\\\\\"" ,  PE32_FILE ) ;assert_true_rule_blob (  ""rule<S2SV_blank>test<S2SV_blank>{"" ,  PE32_FILE ) ;","<S2SV_blank>\\\\\t/<S2SV_blank>\\\\\"" , PE32_FILE ) ;assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{"" , PE32_FILE ) ;",3239
1121,"static int jas_iccputsint ( jas_stream_t * out , int n , longlong val )  {ulonglong tmp ;tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ;","static int jas_iccputsint ( jas_stream_t * out , int n , jas_longlong val ) {ulonglong tmp ;tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ;",3240
1122,"rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( rc < 0 )  return rc ;inode -> i_ctime = CURRENT_TIME ;if ( rc == 0 ) acl = NULL ;","rc = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ;if ( rc ) return rc ;inode -> i_ctime = CURRENT_TIME ;",3241
1123,"pirlvl = pi -> picomp -> pirlvls ;pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;","pirlvl = pi -> picomp -> pirlvls ;if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ;",3242
1124,if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) ||  ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) &&  ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) ||  ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) {",3242
1125,"static int changedline ( const Proto * p , int oldpc , int newpc ) {while ( oldpc ++ < newpc ) {","static int changedline ( const Proto * p , int oldpc , int newpc ) {if ( p -> lineinfo == NULL ) return 0 ;while ( oldpc ++ < newpc ) {",3243
1126,"
",bool disconnect ;,3244
1127,"p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;list_del_init ( & p -> mnt_expire ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ;if ( mnt_has_parent ( p ) ) {umount_mnt ( p ) ;}change_mnt_propagation ( p , MS_PRIVATE ) ;}","p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;list_del_init ( & p -> mnt_expire ) ;disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;if ( mnt_has_parent ( p ) ) {if ( ! disconnect ) {list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ;}}else {umount_mnt ( p ) ;}change_mnt_propagation ( p , MS_PRIVATE ) ;}",3244
1128,"static void encode_frame ( vpx_codec_ctx_t * codec ,  vpx_image_t * img , int frame_index , int flags ,  VpxVideoWriter * writer ) {vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {","static int encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img , int frame_index , int flags , VpxVideoWriter * writer ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {",3245
1129,},return got_pkts ;},3245
1130,for ( x = 0 ;x += 2 )  {,for ( x = 0 ;x += 4 ) {,3246
1131,"static VALUE from_document ( VALUE klass , VALUE document )  {","static VALUE from_document ( int argc , VALUE * argv , VALUE klass ) {VALUE document ;VALUE parse_options ;int scanned_args = 0 ;scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ;if ( scanned_args == 1 ) {parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ;}rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;",3247
1132,return rb_schema ;},return rb_schema ;},3247
1133,"ops -> get_msr ( ctxt , MSR_EFER , & efer ) ;setup_syscalls_segments ( ctxt , & cs , & ss ) ;ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ;","if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ;ops -> get_msr ( ctxt , MSR_EFER , & efer ) ;setup_syscalls_segments ( ctxt , & cs , & ss ) ;if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt ) ;ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ;",3248
1134,"static void send ( node_t * node , node_t * child , byte * fout ) {if ( node -> parent ) {send ( node -> parent , node , fout ) ;}if ( child ) {if ( node -> right == child ) {","static void send ( node_t * node , node_t * child , byte * fout , int maxoffset ) {if ( node -> parent ) {send ( node -> parent , node , fout , maxoffset ) ;}if ( child ) {if ( bloc >= maxoffset ) {bloc = maxoffset + 1 ;return ;}if ( node -> right == child ) {",3249
1135,"int bytes_read = read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ;if ( bytes_read > 0 ) {","int bytes_read = TEMP_FAILURE_RETRY ( read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ) ;if ( bytes_read > 0 ) {",3250
1136,"if ( ! revs -> blob_objects )  return ;show ( obj , path , name , cb_data ) ;}","size_t pathlen ;if ( ! revs -> blob_objects ) return ;pathlen = path -> len ;strbuf_addstr ( path , name ) ;show ( obj , path -> buf , cb_data ) ;strbuf_setlen ( path , pathlen ) ;}",3251
1137,"yyerror ( yyscanner , lex_env , ""repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large"" ) ;yyerror ( yyscanner , lex_env , ""bad<S2SV_blank>repeat<S2SV_blank>interval"" ) ;","yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;",3252
1138,"yyerror ( yyscanner , lex_env , ""repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large"" ) ;","yyerror ( yyscanner , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" ) ;",3252
1139,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",3252
1140,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",3252
1141,"yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;","yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ;yyterminate ( ) ;",3252
1142,"static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid ,  struct uid_gid_map * new_map ) {","static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) {",3253
1143,"if ( ns_capable ( ns -> parent , cap_setid ) )  return true ;","if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ;",3253
1144,"unsigned long cs ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE )  return rc ;if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ;if ( ctxt -> mode >= X86EMUL_MODE_PROT16 && ( cs & 3 ) > cpl ) return X86EMUL_UNHANDLEABLE ;rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ;return rc ;","unsigned long eip , cs ;u16 old_cs ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & eip , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ;rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ;return rc ;",3254
1145,"j ++ )  {body [ j ] = XMALLOC ( VarLenData , 1 ) ;return body ;}","j ++ ) {if ( a -> type == szMAPI_BINARY ) {body [ j ] = XMALLOC ( VarLenData , 1 ) ;}return body ;}",3255
1146,"sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL ,  ""FILE:<S2SV_blank>%02X%02X%02X%02X\\\}}","if ( bufLen < 2 ) break ;sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , ""FILE:<S2SV_blank>%02X%02X%02X%02X\\\bufLen -= 2 ;}}",3256
1147,"rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) ,  & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;","rval = tpm_kdfa ( session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ;",3257
1148,"# endif const bool bcached =  ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ;ctx -> hdrs [ i ] -> old = false ;","# endif const bool bcached = ( mutt_bcache_exists ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) == 0 ) ;ctx -> hdrs [ i ] -> old = false ;",3258
1149,"struct iovec iov ;iov_for_each ( iov , i , * iter ) {if ( end < start ) return ERR_PTR ( - EINVAL ) ;","struct iovec iov ;struct bio_vec * bvec ;iov_for_each ( iov , i , * iter ) {if ( unlikely ( end < start ) return ERR_PTR ( - EINVAL ) ;",3259
1150,if ( ret < local_nr_pages ) {ret = - EFAULT ;,if ( ret < local_nr_pages ) ) {for ( j = cur_page ;j < page_limit ;j ++ ) {if ( ! pages [ j ] ) break ;put_page ( pages [ j ] ) ;}ret = - EFAULT ;,3259
1151,out_unmap :  for ( j = 0 ;j < nr_pages ;j ++ ) {if ( ! pages [ j ] ) break ;put_page ( pages [ j ] ) ;,"out_unmap : bio_for_each_segment_all ( bvec , bio , j ) {put_page ( bvec -> bv_page ) ;",3259
1152,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ;if ( current -> pid != previous_pid ) {","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , regs -> ARM_pc ) ;if ( current -> pid != previous_pid ) {",3260
1153,"ut8 * buf = calloc ( to - from , 1 ) ;if ( ! buf || ! min ) {r_buf_read_at ( bf -> buf , from , buf , to - from ) ;while ( needle < to ) {","int len = to - from ;ut8 * buf = calloc ( len , 1 ) ;if ( ! buf || ! min ) {r_buf_read_at ( bf -> buf , from , buf , len ) ;while ( needle < to ) {",3261
1154,if ( ( to - needle ) > 5 ) {bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ;if ( is_wide32 ) {,if ( ( to - needle ) > 5 + rc ) {bool is_wide32 = ( needle + rc + 2 < to ) && ( ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ) ;if ( is_wide32 ) {,3261
1155,"rd_create_ui ( ) ;in_uint32_le ( s , g_rdp_shareid ) ;in_uint16_le ( s , len_combined_caps ) ;in_uint8s ( s , len_src_descriptor ) ;","struct stream packet = * s ;rd_create_ui ( ) ;in_uint32_le ( s , g_rdp_shareid ) ;in_uint16_le ( s , len_combined_caps ) ;if ( ! s_check_rem ( s , len_src_descriptor ) ) {rdp_protocol_error ( ""rdp_demand_active(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>source<S2SV_blank>descriptor<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , len_src_descriptor ) ;",3262
1156,block_length = data [ i ] * 256 + data [ i + 1 ] ;},if ( i + 1 < data_size ) block_length = data [ i ] * 256 + data [ i + 1 ] ;},3263
1157,"switch ( type )  {case - 1 : {SetPixelAlpha ( image , pixel , q ) ;break ;case - 2 : case 0 : {SetPixelRed ( image , pixel , q ) ;if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ;if ( image -> storage_class == PseudoClass ) {if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ;else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;if ( image -> depth == 1 ) {SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) &   ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;x -- ;continue ;}}break ;}case 1 : {if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ;else SetPixelGreen ( image , pixel , q ) ;break ;case 2 : {if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ;else SetPixelBlue ( image , pixel , q ) ;break ;}case 3 : {if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ;else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ;break ;}case 4 : {if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ;if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ;break ;}default : break ;}q += GetPixelChannels ( image ) ;","if ( image -> depth > 1 ) {SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ;q += GetPixelChannels ( image ) ;else {SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;if ( x != image -> columns ) x -- ;continue ;",3264
1158,"if ( sock -> type == SOCK_RAW )  sock -> ops = & rawsock_raw_ops ;else   sock -> ops = & rawsock_ops ;sk = sk_alloc ( net , PF_NFC , GFP_ATOMIC , nfc_proto -> proto , kern ) ;","if ( sock -> type == SOCK_RAW ) {if ( ! capable ( CAP_NET_RAW ) ) return - EPERM ;sock -> ops = & rawsock_raw_ops ;}else {sock -> ops = & rawsock_ops ;}sk = sk_alloc ( net , PF_NFC , GFP_ATOMIC , nfc_proto -> proto , kern ) ;",3265
1159,"if ( arg_debug ) printf ( ""Initializing<S2SV_blank>child<S2SV_blank>process\\\close ( parent_to_child_fds [ 1 ] ) ;close ( child_to_parent_fds [ 0 ] ) ;wait_for_other ( parent_to_child_fds [ 0 ] ) ;if ( arg_debug && child_pid == 1 ) printf ( ""PID<S2SV_blank>namespace<S2SV_blank>installed\\\if ( cfg . hostname ) {if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( ""sethostname"" ) ;}if ( mount ( NULL , ""/"" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) {chk_chroot ( ) ;}preproc_mount_mnt_dir ( ) ;if ( mount ( LIBDIR ""/firejail"" , RUN_FIREJAIL_LIB_DIR , ""none"" , MS_BIND , NULL ) < 0 ) errExit ( ""mounting<S2SV_blank>"" RUN_FIREJAIL_LIB_DIR ) ;if ( cfg . name ) fs_logger2 ( ""sandbox<S2SV_blank>name:"" , cfg . name ) ;fs_logger2int ( ""sandbox<S2SV_blank>pid:"" , ( int ) sandbox_pid ) ;if ( cfg . chrootdir ) fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>chroot"" ) ;else if ( arg_overlay ) fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>overlay"" ) ;else fs_logger ( ""sandbox<S2SV_blank>filesystem:<S2SV_blank>local"" ) ;fs_logger ( ""install<S2SV_blank>mount<S2SV_blank>namespace"" ) ;if ( arg_netfilter && any_bridge_configured ( ) ) {netfilter ( arg_netfilter_file ) ;}if ( arg_netfilter6 && any_bridge_configured ( ) ) {netfilter6 ( arg_netfilter6_file ) ;}int gw_cfg_failed = 0 ;if ( arg_nonetwork ) {net_if_up ( ""lo"" ) ;if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>enabled,<S2SV_blank>only<S2SV_blank>loopback<S2SV_blank>interface<S2SV_blank>available\\\}else if ( arg_netns ) {netns ( arg_netns ) ;if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>\\\'%s\\\'<S2SV_blank>activated\\\}else if ( any_bridge_configured ( ) || any_interface_configured ( ) ) {net_if_up ( ""lo"" ) ;if ( mac_not_zero ( cfg . bridge0 . macsandbox ) ) net_config_mac ( cfg . bridge0 . devsandbox , cfg . bridge0 . macsandbox ) ;sandbox_if_up ( & cfg . bridge0 ) ;if ( mac_not_zero ( cfg . bridge1 . macsandbox ) ) net_config_mac ( cfg . bridge1 . devsandbox , cfg . bridge1 . macsandbox ) ;sandbox_if_up ( & cfg . bridge1 ) ;if ( mac_not_zero ( cfg . bridge2 . macsandbox ) ) net_config_mac ( cfg . bridge2 . devsandbox , cfg . bridge2 . macsandbox ) ;sandbox_if_up ( & cfg . bridge2 ) ;if ( mac_not_zero ( cfg . bridge3 . macsandbox ) ) net_config_mac ( cfg . bridge3 . devsandbox , cfg . bridge3 . macsandbox ) ;sandbox_if_up ( & cfg . bridge3 ) ;if ( cfg . interface0 . configured && cfg . interface0 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface0 . dev , cfg . interface0 . ip , cfg . interface0 . mask , cfg . interface0 . mtu ) ;}if ( cfg . interface1 . configured && cfg . interface1 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface1 . dev , cfg . interface1 . ip , cfg . interface1 . mask , cfg . interface1 . mtu ) ;}if ( cfg . interface2 . configured && cfg . interface2 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface2 . dev , cfg . interface2 . ip , cfg . interface2 . mask , cfg . interface2 . mtu ) ;}if ( cfg . interface3 . configured && cfg . interface3 . ip ) {if ( arg_debug ) printf ( ""Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\\net_config_interface ( cfg . interface3 . dev , cfg . interface3 . ip , cfg . interface3 . mask , cfg . interface3 . mtu ) ;}if ( cfg . defaultgw ) {if ( net_add_route ( 0 , 0 , cfg . defaultgw ) ) {fwarning ( ""cannot<S2SV_blank>configure<S2SV_blank>default<S2SV_blank>route\\\gw_cfg_failed = 1 ;}}if ( arg_debug ) printf ( ""Network<S2SV_blank>namespace<S2SV_blank>enabled\\\}if ( ! arg_quiet ) {if ( any_bridge_configured ( ) || any_interface_configured ( ) || cfg . defaultgw || cfg . dns1 ) {fmessage ( ""\\\if ( any_bridge_configured ( ) || any_interface_configured ( ) ) {if ( arg_scan ) sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 3 , PATH_FNET , ""printif"" , ""scan"" ) ;else sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 2 , PATH_FNET , ""printif"" ) ;}if ( cfg . defaultgw != 0 ) {if ( gw_cfg_failed ) fmessage ( ""Default<S2SV_blank>gateway<S2SV_blank>configuration<S2SV_blank>failed\\\else fmessage ( ""Default<S2SV_blank>gateway<S2SV_blank>%d.%d.%d.%d\\\}if ( cfg . dns1 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns2 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns3 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\if ( cfg . dns4 != NULL ) fmessage ( ""DNS<S2SV_blank>server<S2SV_blank>%s\\\fmessage ( ""\\\}}if ( arg_nonetwork || any_bridge_configured ( ) || any_interface_configured ( ) ) {}else {EUID_USER ( ) ;env_ibus_load ( ) ;EUID_ROOT ( ) ;}# ifdef HAVE_SECCOMP if ( cfg . protocol ) {if ( arg_debug ) printf ( ""Build<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\\int rv = sbox_run ( SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP , 5 , PATH_FSECCOMP , ""protocol"" , ""build"" , cfg . protocol , RUN_SECCOMP_PROTOCOL ) ;if ( rv ) exit ( rv ) ;}if ( arg_seccomp && ( cfg . seccomp_list || cfg . seccomp_list_drop || cfg . seccomp_list_keep ) ) arg_seccomp_postexec = 1 ;# endif bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec ;if ( getuid ( ) != 0 && ( arg_appimage || cfg . chrootdir || arg_overlay ) ) {enforce_filters ( ) ;need_preload = arg_trace || arg_tracelog ;}if ( need_preload ) fs_trace_preload ( ) ;if ( cfg . hosts_file ) fs_store_hosts_file ( ) ;# ifdef HAVE_CHROOT if ( cfg . chrootdir ) {fs_chroot ( cfg . chrootdir ) ;if ( need_preload ) fs_trace_preload ( ) ;}else # endif # ifdef HAVE_OVERLAYFS if ( arg_overlay ) fs_overlayfs ( ) ;else # endif fs_basic_fs ( ) ;if ( arg_private ) {if ( cfg . home_private ) {if ( cfg . chrootdir ) fwarning ( ""private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_homedir ( ) ;}else if ( cfg . home_private_keep ) {if ( cfg . chrootdir ) fwarning ( ""private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_home_list ( ) ;}else fs_private ( ) ;}if ( arg_private_dev ) fs_private_dev ( ) ;if ( arg_private_etc ) {if ( cfg . chrootdir ) fwarning ( ""private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/etc"" , RUN_ETC_DIR , cfg . etc_private_keep ) ;if ( need_preload ) fs_trace_preload ( ) ;}}if ( arg_private_opt ) {if ( cfg . chrootdir ) fwarning ( ""private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/opt"" , RUN_OPT_DIR , cfg . opt_private_keep ) ;}}if ( arg_private_srv ) {if ( cfg . chrootdir ) fwarning ( ""private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_dir_list ( ""/srv"" , RUN_SRV_DIR , cfg . srv_private_keep ) ;}}if ( arg_private_bin && ! arg_appimage ) {if ( cfg . chrootdir ) fwarning ( ""private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {if ( arg_x11_xorg ) {EUID_USER ( ) ;char * tmp ;if ( asprintf ( & tmp , ""%s,xauth"" , cfg . bin_private_keep ) == - 1 ) errExit ( ""asprintf"" ) ;cfg . bin_private_keep = tmp ;EUID_ROOT ( ) ;}fs_private_bin_list ( ) ;}}if ( arg_private_lib && ! arg_appimage ) {if ( cfg . chrootdir ) fwarning ( ""private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else {fs_private_lib ( ) ;}}if ( arg_private_cache ) {if ( cfg . chrootdir ) fwarning ( ""private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\\else if ( arg_overlay ) fwarning ( ""private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\\else fs_private_cache ( ) ;}if ( arg_private_tmp ) {EUID_USER ( ) ;fs_private_tmp ( ) ;EUID_ROOT ( ) ;}if ( arg_nodbus ) dbus_session_disable ( ) ;if ( cfg . hostname ) fs_hostname ( cfg . hostname ) ;if ( cfg . hosts_file ) fs_mount_hosts_file ( ) ;if ( arg_netns ) netns_mounts ( arg_netns ) ;fs_proc_sys_dev_boot ( ) ;if ( checkcfg ( CFG_DISABLE_MNT ) ) fs_mnt ( 1 ) ;else if ( arg_disable_mnt ) fs_mnt ( 0 ) ;fs_whitelist ( ) ;fs_blacklist ( ) ;if ( arg_nosound ) {pulseaudio_disable ( ) ;fs_dev_disable_sound ( ) ;}else if ( ! arg_noautopulse ) pulseaudio_init ( ) ;if ( arg_no3d ) fs_dev_disable_3d ( ) ;if ( arg_notv ) fs_dev_disable_tv ( ) ;if ( arg_nodvd ) fs_dev_disable_dvd ( ) ;if ( arg_nou2f ) fs_dev_disable_u2f ( ) ;if ( arg_novideo ) fs_dev_disable_video ( ) ;if ( need_preload ) fs_trace ( ) ;fs_resolvconf ( ) ;fs_logger_print ( ) ;fs_logger_change_owner ( ) ;EUID_USER ( ) ;int cwd = 0 ;if ( cfg . cwd ) {if ( chdir ( cfg . cwd ) == 0 ) cwd = 1 ;}if ( ! cwd ) {if ( chdir ( ""/"" ) < 0 ) errExit ( ""chdir"" ) ;if ( cfg . homedir ) {struct stat s ;if ( stat ( cfg . homedir , & s ) == 0 ) {if ( chdir ( cfg . homedir ) < 0 ) errExit ( ""chdir"" ) ;}}}if ( arg_debug ) {char * cpath = get_current_dir_name ( ) ;if ( cpath ) {printf ( ""Current<S2SV_blank>directory:<S2SV_blank>%s\\\free ( cpath ) ;}}EUID_ROOT ( ) ;fs_x11 ( ) ;if ( arg_x11_xorg ) x11_xorg ( ) ;save_umask ( ) ;save_nonewprivs ( ) ;set_caps ( ) ;save_cpu ( ) ;",save_cpu ( ) ;,3266
1160,# endif  FILE * rj = create_ready_for_join_file ( ) ;,# endif FILE * rj = create_ready_for_join_file ( ) ;,3266
1161,"
","if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) {jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\\jas_free ( siz -> comps ) ;return - 1 ;}if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) {jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\\jas_free ( siz -> comps ) ;return - 1 ;}",3267
1162,siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ;siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ;,siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ;siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ;,3267
1163,if ( ( temp_buffer & 0xffffff00 ) != 0x100 )  continue ;else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ;else if ( temp_buffer < 0x120 )  VO ++ ;else if ( temp_buffer < 0x130 )  VOL ++ ;,if ( temp_buffer & 0xfffffe00 ) continue ;if ( temp_buffer >= 0x100 && temp_buffer < 2 ) continue ;else if ( temp_buffer >= 0x120 && temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ;else if ( temp_buffer < 0x120 ) VO ++ ;else if ( temp_buffer < 0x130 ) VOL ++ ;,3268
1164,"# endif if ( quitmore # ifdef FEAT_EVAL && ! getline_equal ( fgetline , cookie , get_func_line ) # endif && ! getline_equal ( fgetline , cookie , getnextac ) ) -- quitmore ;","# endif if ( restricted != 0 && ( ea . argt & RESTRICT ) ) {errormsg = _ ( ""E981:<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ;goto doend ;}if ( quitmore # ifdef FEAT_EVAL && ! getline_equal ( fgetline , cookie , get_func_line ) # endif && ! getline_equal ( fgetline , cookie , getnextac ) ) -- quitmore ;",3269
1165,# endif  if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) )  {,# endif if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) ) {,3269
1166,"chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ;if ( chip -> data_buffer == NULL ) {","chip -> data_buffer = kzalloc ( TPM_BUFSIZE , GFP_KERNEL ) ;if ( chip -> data_buffer == NULL ) {",3270
1167,"unsigned int channo ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {","unsigned int channo ;cdef -> ents = 0 ;if ( jp2_getuint16 ( in , & cdef -> numchans ) ) {",3271
1168,"
",}else if ( request_size < 0 ) {rc = - EINVAL ;goto out_free_buffer ;,3272
1169,}},}},3272
1170,"guchar * match ;int i ;if ( client -> auth_end_offset > 0 ) {gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ;gsize to_match = MIN ( left , buffer -> pos ) ;if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 )  {","goffset offset = 0 ;gsize original_size = client -> auth_buffer -> len ;g_byte_array_append ( client -> auth_buffer , buffer -> data , buffer -> pos ) ;if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) {",3273
1171,"if ( match != NULL )  return match - buffer -> data + strlen ( AUTH_END_STRING ) ;for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ;i > 0 ;i -- ) {if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) {client -> auth_end_offset = i ;break ;return - 1 ;","if ( match != NULL ) return match - buffer -> data + strlen ( AUTH_END_STRING ) ;for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ;while ( TRUE ) {guint8 * line_start = client -> auth_buffer -> data + offset ;gsize remaining_data = client -> auth_buffer -> len - offset ;guint8 * line_end ;line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ;if ( line_end ) {offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ;if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ;* line_end = 0 ;if ( auth_line_is_begin ( line_start ) ) return offset - original_size ;}else {g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ;if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ;return FIND_AUTH_END_CONTINUE ;",3273
1172,break ;default : break ;,strict = true ;break ;default : break ;,3274
1173,# if ! ( CONFIG_FAST_UNALIGNED )  dst [ 0 ] = src [ 0 ] ;dst [ 1 ] = src [ 1 ] ;dst [ 2 ] = src [ 2 ] ;dst [ 3 ] = src [ 3 ] ;dst [ 4 ] = src [ 4 ] ;dst [ 5 ] = src [ 5 ] ;dst [ 6 ] = src [ 6 ] ;dst [ 7 ] = src [ 7 ] ;# else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ;( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ;# endif src += src_stride ;,"memcpy ( dst , src , 8 ) ;src += src_stride ;",3275
1174,"size_t i ;generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ;",size_t i ;,3276
1175,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read )  ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ;else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;,if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) {i_temp = ih264d_read_mmco_commands ( ps_dec ) ;if ( i_temp < 0 ) {return ERROR_DBP_MANAGER_T ;}ps_dec -> u4_bitoffset = i_temp ;}else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ;,3277
1176,"if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) >  ( Rec2 . RecordLength - 2 - 2 ) / 3 )  ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;","if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;",3278
1177,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank>"" ""<keyframe-interval><S2SV_blank>[<error-resilient>]\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank>"" ""<keyframe-interval><S2SV_blank>[<error-resilient>]\\\",3279
1178,# elif defined ( USE_PAM )  # define PAM_END ( msg ) do {}while ( 0 )  pam_handle_t * pamh = NULL ;,# elif defined ( USE_PAM ) # define PAM_END ( msg ) do {\\\\\while ( 0 ) pam_handle_t * pamh = NULL ;,3280
1179,"# ifndef linux if ( dup2 ( temp_stdin , STDIN_FILENO ) == - 1 ) err ( 1 , ""dup2"" ) ;","# else # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresgid ( target_pw -> pw_gid , target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setresgid"" ) ;# else if ( setregid ( target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setregid"" ) ;# endif if ( initgroups ( target_pw -> pw_name , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""initgroups"" ) ;# if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresuid ( target , target , target ) == - 1 ) err ( 1 , ""setresuid"" ) ;# else if ( setreuid ( target , target ) == - 1 ) err ( 1 , ""setreuid"" ) ;# endif # ifndef linux if ( dup2 ( temp_stdin , STDIN_FILENO ) == - 1 ) err ( 1 , ""dup2"" ) ;",3280
1180,"# endif  if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = ""(failed)"" ;# ifndef HAVE_LOGIN_CAP_H  if ( target != 0 ) setuid ( target ) ;if ( geteuid ( ) == ROOT_UID ) setuid ( ROOT_UID ) ;# endif syslog ( LOG_AUTHPRIV | LOG_INFO , ""%s<S2SV_blank>ran<S2SV_blank>command<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , myname , cmdline , target_pw -> pw_name , cwd ) ;","# endif if ( getcwd ( cwdpath , sizeof ( cwdpath ) ) == NULL ) cwd = ""(failed)"" ;syslog ( LOG_AUTHPRIV | LOG_INFO , ""%s<S2SV_blank>ran<S2SV_blank>command<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , myname , cmdline , target_pw -> pw_name , cwd ) ;",3280
1181,if ( ! ( XFS_AGF_GOOD_VERSION ( be32_to_cpu ( agf -> agf_versionnum ) ) && be32_to_cpu ( agf -> agf_freeblks ) <= be32_to_cpu ( agf -> agf_length ) && be32_to_cpu ( agf -> agf_flfirst ) < xfs_agfl_size ( mp ) && be32_to_cpu ( agf -> agf_fllast ) < xfs_agfl_size ( mp ) &&  be32_to_cpu ( agf -> agf_flcount ) <= xfs_agfl_size ( mp ) ) )  return __this_address ;if ( bp -> b_pag && be32_to_cpu ( agf -> agf_seqno ) != bp -> b_pag -> pag_agno )  return __this_address ;if ( xfs_sb_version_haslazysbcount ( & mp -> m_sb ) &&  be32_to_cpu ( agf -> agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) )  return __this_address ;,if ( ! ( XFS_AGF_GOOD_VERSION ( be32_to_cpu ( agf -> agf_versionnum ) ) && be32_to_cpu ( agf -> agf_freeblks ) <= be32_to_cpu ( agf -> agf_length ) && be32_to_cpu ( agf -> agf_flfirst ) < xfs_agfl_size ( mp ) ) ) return __this_address ;if ( xfs_sb_version_hasrmapbt ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_rmap_blocks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ;if ( be32_to_cpu ( agf -> agf_length ) > mp -> m_sb . sb_dblocks ) return __this_address ;if ( be32_to_cpu ( agf -> agf_freeblks ) < be32_to_cpu ( agf -> agf_longest ) || be32_to_cpu ( agf -> agf_freeblks ) > be32_to_cpu ( agf -> agf_length && be32_to_cpu ( agf -> agf_fllast ) < xfs_agfl_size ( mp ) && be32_to_cpu ( agf -> agf_flcount ) <= xfs_agfl_size ( mp ) ) ) return __this_address ;if ( bp -> b_pag && be32_to_cpu ( agf -> agf_seqno ) != bp -> b_pag -> pag_agno ) return __this_address ;if ( xfs_sb_version_haslazysbcount ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ;if ( xfs_sb_version_hasreflink ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_refcount_blocks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ;,3281
1182,"skb -> ip_summed = CHECKSUM_PARTIAL ;skb -> csum = 0 ;__skb_queue_tail ( queue , skb ) ;}return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;","skb -> csum = 0 ;__skb_queue_tail ( queue , skb ) ;}else if ( skb_is_gso ( skb ) ) {goto append ;}skb -> ip_summed = CHECKSUM_PARTIAL ;append : return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ;",3282
1183,"int byte_count = 0 , count ;if ( ! format ) return psf_ftell ( psf ) ;while ( ( c = * format ++ ) )  {switch ( c )  {ucptr = ( unsigned char * ) intptr ;byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ;case \'h\' :  intptr = va_arg ( argptr , unsigned int * ) ;ucptr = ( unsigned char * ) intptr ;","int byte_count = 0 , count = 0 ;if ( ! format ) return psf_ftell ( psf ) ;while ( ( c = * format ++ ) ) {if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ;switch ( c ) {* intptr = 0 ;ucptr = ( unsigned char * ) intptr ;byte_count += header_read ( psf , ucptr , sizeof ( int ) ) ;case \'h\' : intptr = va_arg ( argptr , unsigned int * ) ;* intptr = 0 ;ucptr = ( unsigned char * ) intptr ;",3283
1184,"if ( count > 0 )  byte_count += header_read ( psf , charptr , count ) ;break ;case \'G\' :  charptr = va_arg ( argptr , char * ) ;count = va_arg ( argptr , size_t ) ;if ( count > 0 )  byte_count += header_gets ( psf , charptr , count ) ;header_seek ( psf , count , SEEK_SET ) ;byte_count = count ;byte_count += count ;}","memset ( charptr , 0 , count ) ;byte_count += header_read ( psf , charptr , count ) ;header_seek ( psf , count , SEEK_SET ) ;byte_count = count ;break ;case \'j\' : count = va_arg ( argptr , size_t ) ;header_seek ( psf , count , SEEK_SET ) ;byte_count = count ;byte_count += count ;}",3283
1185,"if ( ! ( info = bmp_getinfo ( in ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\\}if ( ! bmp_issupported ( & hdr , info ) ) {","JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\\if ( ! ( info = bmp_getinfo ( in ) ) ) {jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>info\\\}JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\\if ( ! bmp_issupported ( & hdr , info ) ) {",3284
1186,"if ( ACTION ( HOME ) ) {}handle_run ( req , res ) ;}is_monit_running ( res ) ;}else if ( ACTION ( ABOUT ) ) {do_about ( res ) ;}else if ( ACTION ( FAVICON ) ) {printFavicon ( res ) ;}else if ( ACTION ( PING ) ) {do_ping ( res ) ;}else if ( ACTION ( GETID ) ) {do_getid ( res ) ;}else if ( ACTION ( STATUS ) ) {print_status ( req , res , 1 ) ;","if ( ACTION ( RUNTIME ) ) {}handle_runtime ( req , res ) ;}is_monit_running ( res ) ;}else {handle_service ( req , res , 1 ) ;",3285
1187,"extent_type = btrfs_file_extent_type ( leaf , fi ) ;if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) {item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ;else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) {item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ;item_end -- ;if ( found_type > min_type ) {del_item = 1 ;else {if ( item_end < new_size ) break ;if ( found_key . offset >= new_size ) del_item = 1 ;else del_item = 0 ;}found_extent = 0 ;if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ;if ( del_item ) last_size = found_key . offset ;else last_size = new_size ;if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) {u64 num_dec ;extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ;if ( ! del_item ) {u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ;extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ;btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ;num_dec = ( orig_num_bytes - extent_num_bytes ) ;if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ;","extent_type = btrfs_file_extent_type ( leaf , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) {err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ;if ( err ) {btrfs_abort_transaction ( trans , root , err ) ;goto error ;pending_del_nr = 0 ;err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ;if ( err ) {btrfs_abort_transaction ( trans , root , err ) ;goto error ;else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ;",3286
1188,"if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ;if ( ! del_item &&  btrfs_file_extent_compression ( leaf , fi ) == 0 &&  btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) )  inode_sub_bytes ( inode , item_end + 1 -  new_size ) ;btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ;size = btrfs_file_extent_calc_inline_size ( size ) ;btrfs_truncate_item ( root , path , size , 1 ) ;","if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) {inode_sub_bytes ( inode , num_dec ) ;if ( ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( btrfs_file_extent_compression ( leaf , fi ) == 0 && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) {if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , item_end + 1 - new_size ) ;",3286
1189,},vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ;vpx_free ( denoiser -> denoise_state ) ;},3287
1190,struct stat st ;size_t pathlen ;,size_t pathlen ;,3288
1191,"pr_fs_clear_cache ( ) ;res = pr_fsio_lstat ( path , & st ) ;xerrno = errno ;pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path ,  strerror ( xerrno ) ) ;errno = xerrno ;return - 1 ;if ( S_ISLNK ( st . st_mode ) ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>"" ""config)"" , path ) ;","res = is_symlink_path ( p , path , pathlen ) ;if ( errno == EPERM ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ;",3288
1192,"if ( length == 1 && bp [ 0 ] == 0xff ) {ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ;}if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) {","ND_TCHECK ( bp [ 0 ] ) ;if ( length == 1 && bp [ 0 ] == 0xff ) {ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ;}ND_TCHECK ( bp [ 3 ] ) ;if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) {",3289
1193,"int col_min = ref_col - distance ;int col_max = ref_col + distance ;DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , sad_array8 , 8 ) ;unsigned int sad_array [ 3 ] ;","DECLARE_ALIGNED ( 16 , unsigned short , sad_array8 , 8 ) ;unsigned int sad_array [ 3 ] ;",3290
1194,"bestsad = fn_ptr -> sdf ( what , what_stride ,  bestaddress , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",3290
1195,"fn_ptr -> sdx8f ( what , what_stride , check_here , in_what_stride , sad_array8 ) ;for ( i = 0 ;i < 8 ;i ++ ) {thissad = sad_array8 [ i ] ;if ( thissad < bestsad ) {this_mv . as_mv . col = c ;thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","fn_ptr -> sdx8f ( what , what_stride , check_here , in_what_stride ) ;",3290
1196,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {",3290
1197,hlist_del ( & pin -> m_list ) ;hlist_del ( & pin -> s_list ) ;spin_unlock ( & pin_lock ) ;,hlist_del_init ( & pin -> m_list ) ;hlist_del_init ( & pin -> s_list ) ;spin_unlock ( & pin_lock ) ;,3291
1198,"static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf )  {","static bool do_write_pids ( pid_t tpid , uid_t tuid , const char * contrl , const char * cg , const char * file , const char * buf ) {",3292
1199,"if ( v == \'0\' ) {if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 )  fail = true ;","if ( ! may_move_pid ( tpid , tuid , cred . pid ) ) {fail = true ;break ;}if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) fail = true ;",3292
1200,"u_char * b , * s , * t , c ;int i , proto ;b = ( uint8_t * ) malloc ( length ) ;if ( b == NULL ) return ;for ( s = ( u_char * ) p , t = b , i = length ;i > 0 ;c = * s ++ ;if ( i > 1 ) {i -- ;c = * s ++ ^ 0x20 ;}else continue ;","u_char * b , * t , c ;const u_char * s ;int i , proto ;b = ( u_char * ) malloc ( length ) ;if ( b == NULL ) return ;for ( s = p , t = b , i = length ;i > 0 && ND_TTEST ( * s ) ;c = * s ++ ;if ( i <= 1 || ! ND_TTEST ( * s ) ) break ;i -- ;c = * s ++ ^ 0x20 ;",3293
1201,assert ( dev -> lintr . pin > 0 ) ;pthread_mutex_lock ( & dev -> lintr . lock ) ;,"if ( dev -> lintr . pin <= 0 ) {pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\\return ;}pthread_mutex_lock ( & dev -> lintr . lock ) ;",3294
1202,BUG_ON ( ret == - EEXIST ) ;if ( ret ) {,BUG_ON ( ret == - EEXIST || ret == - EOVERFLOW ) ;if ( ret ) {,3295
1203,int opts ;Resub m ;,int result ;int opts ;Resub m ;,3296
1204,"if ( ! js_regexec ( re -> prog , text , & m , opts ) ) {if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ;","result = js_regexec ( re -> prog , text , & m , opts ) ;if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ;if ( result == 0 ) {if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ;",3296
1205,"static void findoprnd ( ITEM * ptr , int32 * pos )  {if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) {","static void findoprnd ( ITEM * ptr , int32 * pos ) {check_stack_depth ( ) ;if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) {",3297
1206,"int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {","static int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {",3298
1207,"if ( ! ctx -> priv ) {vpx_codec_alg_priv_t * alg_priv = vpx_memalign ( 32 , sizeof ( * alg_priv ) ) ;if ( alg_priv == NULL )   return VPX_CODEC_MEM_ERROR ;vp9_zero ( * alg_priv ) ;ctx -> priv = ( vpx_codec_priv_t * ) alg_priv ;ctx -> priv -> sz = sizeof ( * ctx -> priv ) ;if ( ctx -> config . dec ) {ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ;ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ;}","( void ) data ;if ( ! ctx -> priv ) {vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * alg_priv ) ) ;if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ;vp9_zero ( * alg_priv ) ;ctx -> priv = ( vpx_codec_priv_t * ) priv ;ctx -> priv -> sz = sizeof ( * ctx -> priv ) ;priv -> si . sz = sizeof ( priv -> si ) ;priv -> flushed = 0 ;priv -> frame_parallel_decode = ( ctx -> config . dec && ( ctx -> config . dec -> threads > 1 ) && ( ctx -> init_flags & VPX_CODEC_USE_FRAME_THREADING ) ) ? 1 : 0 ;if ( ctx -> config . dec ) {priv -> cfg = * ctx -> config . dec ;ctx -> config . dec = & priv -> cfg ;}",3299
1208,valuelen = be16_to_cpu ( name_loc -> valuelen ) ;,"args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , valuelen ) ;",3300
1209,"memcpy ( args -> value , & name_loc -> nameval [ args -> namelen ] , valuelen ) ;else {name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ;ASSERT ( name_rmt -> namelen == args -> namelen ) ;ASSERT ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) == 0 ) ;valuelen = be32_to_cpu ( name_rmt -> valuelen ) ;args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount ,  valuelen ) ;if ( args -> flags & ATTR_KERNOVAL ) {args -> valuelen = valuelen ;return 0 ;}if ( args -> valuelen < valuelen ) {args -> valuelen = valuelen ;return XFS_ERROR ( ERANGE ) ;}args -> valuelen = valuelen ;}","
",3300
1210,"char * sockaddr_url , * stratum_port , * tmp ;char * url , * port , address [ 256 ] ;if ( opt_disable_client_reconnect ) {applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>forbidden,<S2SV_blank>aborting."" ) ;memset ( address , 0 , 255 ) ;url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ;if ( ! url ) url = pool -> sockaddr_url ;sprintf ( address , ""%s:%s"" , url , port ) ;if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ;","if ( opt_disable_client_reconnect ) {applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting."" ) ;char * url , * port , address [ 256 ] ;char * sockaddr_url , * stratum_port , * tmp ;url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ;if ( ! url ) url = pool -> sockaddr_url ;sprintf ( address , ""%s:%s"" , url , port ) ;if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ;",3301
1211,"if ( input [ 0 ] == \'<S2SV_blank>\' )  input ++ ;ptr = strchr ( input , \'<S2SV_blank>\' ) ;","if ( input [ 0 ] == \'<S2SV_blank>\' ) {input ++ ;}ptr = strchr ( input , \'<S2SV_blank>\' ) ;",3302
1212,"if ( ! r_fs_mount ( core -> fs , ptr , input , off ) )  eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) )  eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\\else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) )   eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\free ( ptr ) ;","if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) {eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}}if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) {eprintf ( ""Unknown<S2SV_blank>filesystem<S2SV_blank>type\\\}else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) {eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\\}free ( ptr ) ;",3302
1213,"while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) {const struct id_off * io , * ie ;for ( ie = io + ps -> nid ;io < ie && ! ND_TTEST ( * io ) ;ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ;","while ( -- n >= 0 && ND_TTEST ( * ps ) ) {const struct id_off * io , * ie ;for ( ie = io + ps -> nid ;io < ie && ND_TTEST ( * io ) ;ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ;",3303
1214,if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&  sbi -> s_want_extra_isize == 0 ) {sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ;if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize >  sbi -> s_inode_size ) {sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ;,unsigned def_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ;if ( sbi -> s_inode_size == EXT4_GOOD_OLD_INODE_SIZE ) {sbi -> s_want_extra_isize = 0 ;return ;}if ( sbi -> s_want_extra_isize < 4 ) {sbi -> s_want_extra_isize = def_extra_isize ;if ( ( sbi -> s_want_extra_isize > sbi -> s_inode_size ) ) {sbi -> s_want_extra_isize = def_extra_isize ;,3304
1215,"struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;struct netdev_desc * desc ;case SIOCDEVPRIVATE :  break ;case SIOCDEVPRIVATE + 1 :   miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;break ;case SIOCDEVPRIVATE + 2 :   mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ;break ;","struct mii_ioctl_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ;struct netdev_desc * desc ;case SIOCGMIIPHY : miidata -> phy_id = phy_addr ;break ;case SIOCGMIIREG : miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ;break ;case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;mii_write ( dev , phy_addr , miidata -> val_in ) ;break ;",3305
1216,"int hns_nic_net_xmit_hw ( struct net_device * ndev ,  struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) {","netdev_tx_t hns_nic_net_xmit_hw ( struct net_device * ndev , struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) {",3306
1217,wmb ( ) ;assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ;,netif_trans_update ( ndev ) ;ndev -> stats . tx_bytes += skb -> len ;ndev -> stats . tx_packets ++ ;wmb ( ) ;assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ;,3306
1218,if ( sk_hashed ( sk ) ) {write_lock_bh ( & ping_table . lock ) ;hlist_nulls_del ( & sk -> sk_nulls_node ) ;write_unlock_bh ( & ping_table . lock ) ;}},write_lock_bh ( & ping_table . lock ) ;if ( sk_hashed ( sk ) ) {hlist_nulls_del ( & sk -> sk_nulls_node ) ;}write_unlock_bh ( & ping_table . lock ) ;},3307
1219,"char query [ 1024 ] , * end ;MYSQL_RES * result ;",char query [ NAME_LEN + 100 ] ;int len ;MYSQL_RES * result ;,3308
1220,"sprintf ( query , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ;if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) {","my_snprintf ( query , sizeof ( query ) , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ;if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) {",3308
1221,"end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ;if ( wild && wild [ 0 ] )  strxmov ( end , ""<S2SV_blank>like<S2SV_blank>\\\'"" , wild , ""\\\'"" , NullS ) ;","len = sizeof ( query ) ;len -= my_snprintf ( query , len , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ;if ( wild && wild [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len , ""<S2SV_blank>like<S2SV_blank>\\\'"" , wild , ""\\\'"" , NullS ) ;",3308
1222,"end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ;if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) {","my_snprintf ( query , sizeof ( query ) , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ;if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) {",3308
1223,"VP8Frame * av_uninit ( curframe ) , * prev_frame ;if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ;","VP8Frame * av_uninit ( curframe ) , * prev_frame ;av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P ) ;if ( is_vp7 ) ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ;",3309
1224,ssize_t result ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,ssize_t result ;if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,3310
1225,if ( img -> img_data && img -> img_data_owner )  img_buf_free ( img -> img_data ) ;if ( img -> self_allocd ) free ( img ) ;,if ( img -> img_data && img -> img_data_owner ) vpx_free ( img -> img_data ) ;if ( img -> self_allocd ) free ( img ) ;,3311
1226,"if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) {l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}","if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) * l_step_l , sizeof ( OPJ_INT16 ) ) ;}",3312
1227,struct stat st ;size_t pathlen ;,size_t pathlen ;,3313
1228,"pr_fs_clear_cache2 ( path ) ;res = pr_fsio_lstat ( path , & st ) ;xerrno = errno ;pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path ,  strerror ( xerrno ) ) ;errno = xerrno ;return - 1 ;if ( S_ISLNK ( st . st_mode ) ) {pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>"" ""config)"" , path ) ;","res = is_symlink_path ( p , path , pathlen ) ;xerrno = errno ;pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ;",3313
1229,"
",if ( af == NULL ) break ;,3314
1230,"af -> from_addr_param ( & addr , addr_param ,  htons ( asoc -> peer . port ) , 0 ) ;","af -> from_addr_param ( & addr , addr_param , htons ( asoc -> peer . port ) , 0 ) ;",3314
1231,"imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ;if ( imbuf == NULL ) {","imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx , imsy ) ;if ( imbuf == NULL ) {",3315
1232,"( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ;while ( * p != '\\\\0' ) {","( void ) ResetMagickMemory ( imbuf , background_color_index , ( size_t ) imsx * imsy ) ;while ( * p != '\\\\0' ) {",3315
1233,"dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ;if ( dmbuf == ( unsigned char * ) NULL ) {( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ;for ( y = 0 ;","dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy ) ;if ( dmbuf == ( unsigned char * ) NULL ) {( void ) ResetMagickMemory ( dmbuf , background_color_index , ( size_t ) dmsx * dmsy ) ;for ( y = 0 ;",3315
1234,"dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ;if ( dmbuf == ( unsigned char * ) NULL ) {( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ;for ( y = 0 ;","dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy ) ;if ( dmbuf == ( unsigned char * ) NULL ) {( void ) ResetMagickMemory ( dmbuf , background_color_index , ( size_t ) dmsx * dmsy ) ;for ( y = 0 ;",3315
1235,"( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ;}","( void ) ResetMagickMemory ( imbuf + ( size_t ) imsx * y + posision_x , color_index , repeat_count ) ;}",3315
1236,"if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) {imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ;","if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx , dmsy ) ) == NULL ) {imbuf = ( unsigned char * ) RelinquishMagickMemory ( imbuf ) ;",3315
1237,"
",ND_TCHECK_32BITS ( cp ) ;,3316
1238,"ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" ,  EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;","ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ;",3316
1239,"ALOGE ( ""b/26366256"" ) ;return ;","ALOGE ( ""b/26366256"" ) ;android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;return ;",3317
1240,"u64 base_addr , size ;if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ;","u64 base_addr , size ;if ( get_securelevel ( ) > 0 ) return - EPERM ;if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ;",3318
1241,if ( client -> rcSource )  free ( client -> rcSource ) ;,if ( width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE ) return FALSE ;if ( client -> rcSource ) free ( client -> rcSource ) ;,3319
1242,"if ( bee -> ui -> ft_in_start ) {return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ;","if ( bee -> ui -> ft_in_start && bu ) {return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ;",3320
1243,if ( vui_flag_pos ) * vui_flag_pos = 0 ;if ( vps_id >= 16 ) {return - 1 ;,if ( ( vps_id < 0 ) || ( vui_flag_pos ) * vui_flag_pos = 0 ;if ( vps_id >= 16 ) ) {return - 1 ;,3321
1244,ether_setup ( dev ) ;dev -> netdev_ops = & veth_netdev_ops ;,ether_setup ( dev ) ;dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;dev -> netdev_ops = & veth_netdev_ops ;,3322
1245,"struct key * find_keyring_by_name ( const char * name , bool skip_perm_check )  {if ( ! name ) return ERR_PTR ( - EINVAL ) ;bucket = keyring_hash ( name ) ;read_lock ( & keyring_name_lock ) ;if ( keyring_name_hash [ bucket ] . next ) {list_for_each_entry ( keyring , & keyring_name_hash [ bucket ] , name_link ) {if ( ! kuid_has_mapping ( current_user_ns ( ) , keyring -> user -> uid ) ) continue ;if ( test_bit ( KEY_FLAG_REVOKED , & keyring -> flags ) ) continue ;if ( strcmp ( keyring -> description , name ) != 0 ) continue ;if ( ! skip_perm_check &&  key_permission ( make_key_ref ( keyring , 0 ) , KEY_NEED_SEARCH ) < 0 )  continue ;if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ;","struct key * find_keyring_by_name ( const char * name , bool uid_keyring ) {if ( uid_keyring ) {if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ;}}else {if ( key_permission ( make_key_ref ( keyring , 0 ) , KEY_NEED_SEARCH ) < 0 ) continue ;if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ;",3323
1246,"while ( ! kthread_should_stop ( ) ) {err = svc_recv ( rqstp , MAX_SCHEDULE_TIMEOUT ) ;return 0 ;}","while ( ! kthread_freezable_should_stop ( NULL ) ) {if ( signal_pending ( current ) ) flush_signals ( current ) ;err = svc_recv ( rqstp , MAX_SCHEDULE_TIMEOUT ) ;svc_exit_thread ( rqstp ) ;module_put_and_exit ( 0 ) ;return 0 ;}",3324
1247,PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;p = val ;q = p ;while ( * q != PS_DELIMITER ) {,int skip = 0 ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;p = val ;q = p ;skip = 0 ;while ( * q != PS_DELIMITER ) {,3325
1248,"goto skip ;}php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}","skip = 1 ;}if ( ! skip ) {php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}}",3325
1249,"PS_ADD_VARL ( name , namelen ) ;skip : efree ( name ) ;","if ( ! skip ) {PS_ADD_VARL ( name , namelen ) ;}skip : efree ( name ) ;",3325
1250,"if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) {spin_lock_irq ( & child -> sighand -> siglock ) ;WARN_ON_ONCE ( task_is_stopped ( child ) ) ;if ( ignore_state || ( task_is_traced ( child ) &&  ! ( child -> jobctl & JOBCTL_LISTENING ) ) )  ret = 0 ;spin_unlock_irq ( & child -> sighand -> siglock ) ;if ( ! ret && ! ignore_state )   ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ;return ret ;","if ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) {WARN_ON ( child -> state == __TASK_TRACED ) ;if ( ignore_state || ( task_is_traced ( child ) && ! ( child -> jobctl & JOBCTL_LISTENING ) ) ) ret = 0 ;if ( ! ret && ! ignore_state ) {if ( ! wait_task_inactive ( child , __TASK_TRACED ) ) {WARN_ON ( child -> state == __TASK_TRACED ) ;ret = - ESRCH ;}}return ret ;",3326
1251,"static vpx_codec_err_t ctrl_get_display_size ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {int * const display_size = va_arg ( args , int * ) ;if ( display_size ) {if ( ctx -> pbi ) {const VP9_COMMON * const cm = & ctx -> pbi -> common ;display_size [ 0 ] = cm -> display_width ;}else {return VPX_CODEC_ERROR ;return VPX_CODEC_OK ;}}","static vpx_codec_err_t ctrl_get_display_size ( vpx_codec_alg_priv_t * ctx , va_list args ) {int * const display_size = va_arg ( args , int * ) ;if ( ctx -> frame_workers ) {VPxWorker * const worker = ctx -> frame_workers ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;const VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ;display_size [ 0 ] = cm -> display_width ;return VPX_CODEC_OK ;return VPX_CODEC_ERROR ;}}",3327
1252,altcol = ( altcol / tok -> alttabsize + 1 )   * tok -> alttabsize ;},altcol = ( altcol / ALTTABSIZE + 1 ) * tok -> alttabsize ;},3328
1253,if ( altcol != tok -> altindstack [ tok -> indent ] ) {if ( indenterror ( tok ) ) {return ERRORTOKEN ;,return indenterror ( tok ) ) {return ERRORTOKEN ;,3328
1254,"if ( indenterror ( tok ) ) {return ERRORTOKEN ;}}tok -> pendin ++ ;tok -> indstack [ ++ tok -> indent ] = col ;tok -> altindstack [ tok -> indent ] = altcol ;}else {while ( tok -> indent > 0 && col < tok -> indstack [ tok -> indent ] ) {tok -> pendin -- ;tok -> indent -- ;}if ( col != tok -> indstack [ tok -> indent ] ) {tok -> done = E_DEDENT ;tok -> cur = tok -> inp ;return ERRORTOKEN ;}if ( altcol != tok -> altindstack [ tok -> indent ] ) {if ( indenterror ( tok ) ) {return ERRORTOKEN ;}}}}}tok -> start = tok -> cur ;if ( tok -> pendin != 0 ) {if ( tok -> pendin < 0 ) {tok -> pendin ++ ;return DEDENT ;}else {tok -> pendin -- ;return INDENT ;}}if ( tok -> async_def && ! blankline && tok -> level == 0 && tok -> async_def_nl && tok -> async_def_indent >= tok -> indent ) {tok -> async_def = 0 ;tok -> async_def_indent = 0 ;tok -> async_def_nl = 0 ;}again : tok -> start = NULL ;do {c = tok_nextc ( tok ) ;}while ( c == \'<S2SV_blank>\' || c == \'\\\\t\' || c == \'\\\\014\' ) ;tok -> start = tok -> cur - 1 ;if ( c == \'#\' ) {const char * prefix , * p , * type_start ;while ( c != EOF && c != \'\\\p = tok -> start ;prefix = type_comment_prefix ;while ( * prefix && p < tok -> cur ) {if ( * prefix == \'<S2SV_blank>\' ) {while ( * p == \'<S2SV_blank>\' || * p == \'\\\\t\' ) p ++ ;}else if ( * prefix == * p ) {p ++ ;}else {break ;}prefix ++ ;}if ( ! * prefix ) {int is_type_ignore = 1 ;tok_backup ( tok , c ) ;type_start = p ;is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ;p += 6 ;while ( is_type_ignore && p < tok -> cur ) {if ( * p == \'#\' ) break ;is_type_ignore = is_type_ignore && ( * p == \'<S2SV_blank>\' || * p == \'\\\\t\' ) ;p ++ ;}if ( is_type_ignore ) {if ( blankline ) {tok_nextc ( tok ) ;tok -> atbol = 1 ;}return TYPE_IGNORE ;}else {* p_start = ( char * ) type_start ;* p_end = tok -> cur ;return TYPE_COMMENT ;}}}if ( c == EOF ) {return tok -> done == E_EOF ? ENDMARKER : ERRORTOKEN ;}nonascii = 0 ;if ( is_potential_identifier_start ( c ) ) {int saw_b = 0 , saw_r = 0 , saw_u = 0 , saw_f = 0 ;while ( 1 ) {if ( ! ( saw_b || saw_u || saw_f ) && ( c == \'b\' || c == \'B\' ) ) saw_b = 1 ;else if ( ! ( saw_b || saw_u || saw_r || saw_f ) && ( c == \'u\' || c == \'U\' ) ) {saw_u = 1 ;}else if ( ! ( saw_r || saw_u ) && ( c == \'r\' || c == \'R\' ) ) {saw_r = 1 ;}else if ( ! ( saw_f || saw_b || saw_u ) && ( c == \'f\' || c == \'F\' ) ) {saw_f = 1 ;}else {break ;}c = tok_nextc ( tok ) ;if ( c == \\\'""\\\' || c == \'\\\\\'\' ) {goto letter_quote ;}}while ( is_potential_identifier_char ( c ) ) {if ( c >= 128 ) {nonascii = 1 ;}c = tok_nextc ( tok ) ;}tok_backup ( tok , c ) ;if ( nonascii && ! verify_identifier ( tok ) ) {return ERRORTOKEN ;}* p_start = tok -> start ;* p_end = tok -> cur ;if ( tok -> cur - tok -> start == 5 ) {if ( tok -> async_def ) {if ( memcmp ( tok -> start , ""async"" , 5 ) == 0 ) {return ASYNC ;}if ( memcmp ( tok -> start , ""await"" , 5 ) == 0 ) {return AWAIT ;",if ( indenterror ( tok ) ;,3328
1255,"if ( c == \'+\' || c == \'-\' ) {c = tok_nextc ( tok ) ;if ( ! isdigit ( c ) ) {tok -> done = E_TOKEN ;tok_backup ( tok , c ) ;return ERRORTOKEN ;}}else if ( ! isdigit ( c ) ) {tok_backup ( tok , c ) ;tok_backup ( tok , e ) ;* p_start = tok -> start ;* p_end = tok -> cur ;return NUMBER ;}c = tok_decimal_tail ( tok ) ;if ( c == 0 ) {return ERRORTOKEN ;}}if ( c == \'j\' || c == \'J\' ) {imaginary : c = tok_nextc ( tok ) ;}}}tok_backup ( tok , c ) ;* p_start = tok -> start ;* p_end = tok -> cur ;return NUMBER ;}letter_quote : if ( c == \'\\\\\'\' || c == \\\'""\\\' ) {int quote = c ;int quote_size = 1 ;int end_quote_size = 0 ;c = tok_nextc ( tok ) ;if ( c == quote ) {c = tok_nextc ( tok ) ;if ( c == quote ) {quote_size = 3 ;}else {end_quote_size = 1 ;}}if ( c != quote ) {tok_backup ( tok , c ) ;}while ( end_quote_size != quote_size ) {c = tok_nextc ( tok ) ;if ( c == EOF ) {if ( quote_size == 3 ) {tok -> done = E_EOFS ;}else {tok -> done = E_EOLS ;","
",3328
1256,"# ifndef _MSC_VER   char filename [ dirent . namelen + 1 ] ;# else char * filename = grub_malloc ( dirent . namelen + 1 ) ;# endif struct grub_fshelp_node * fdiro ;enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ;grub_ext2_read_file ( diro , 0 , 0 , 0 , fpos + sizeof ( struct ext2_dirent ) , dirent . namelen , filename ) ;if ( grub_errno )  return 0 ;fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) ) ;if ( ! fdiro )  return 0 ;fdiro -> data = diro -> data ;","char * filename = grub_malloc ( dirent . namelen + 1 ] ;# else char * filename = grub_malloc ( dirent . namelen + 1 ) ;struct grub_fshelp_node * fdiro ;enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ;if ( ! filename ) {break ;}grub_ext2_read_file ( diro , 0 , 0 , 0 , fpos + sizeof ( struct ext2_dirent ) , dirent . namelen , filename ) ;if ( grub_errno ) {free ( filename ) ;return 0 ;}fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) ) ;if ( ! fdiro ) {free ( filename ) ;return 0 ;}fdiro -> data = diro -> data ;",3329
1257,if ( grub_errno )  {grub_free ( fdiro ) ;,if ( grub_errno ) {free ( filename ) ;grub_free ( fdiro ) ;,3329
1258,"if ( hook ( filename , type , fdiro , closure ) )  return 1 ;","if ( hook ( filename , type , fdiro , closure ) ) {free ( filename ) ;return 1 ;}free ( filename ) ;",3329
1259,"if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {char saved_p ;for ( line += 18 ;isspace ( * line ) ;line ++ )  ;","if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( ( unsigned char ) line [ 17 ] ) ) {char saved_p ;for ( line += 18 ;isspace ( ( unsigned char ) * line ) ;line ++ ) ;",3330
1260,for ( ;line < last && isspace ( * line ) ;line ++ )  ;else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] )   && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) )  blocktyp = PFA_HEX ;,for ( ;line < last && isspace ( ( unsigned char ) * line ) ;line ++ ) ;else if ( last >= line + 4 && isxdigit ( ( unsigned char ) line [ 0 ] ) && isxdigit ( ( unsigned char ) line [ 1 ] ) && isxdigit ( ( unsigned char ) line [ 2 ] ) && isxdigit ( ( unsigned char ) line [ 3 ] ) ) blocktyp = PFA_HEX ;,3330
1261,"
",copy = datalen - transhdrlen - fraggap ;if ( copy < 0 ) {err = - EINVAL ;goto error ;},3331
1262,"if ( transhdrlen ) {skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ;}else {skb = NULL ;if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ;if ( unlikely ( ! skb ) ) err = - ENOBUFS ;}if ( ! skb ) goto error ;skb -> protocol = htons ( ETH_P_IPV6 ) ;skb -> ip_summed = csummode ;skb -> csum = 0 ;skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ;skb_shinfo ( skb ) -> tx_flags = tx_flags ;tx_flags = 0 ;skb_shinfo ( skb ) -> tskey = tskey ;tskey = 0 ;data = skb_put ( skb , fraglen ) ;skb_set_network_header ( skb , exthdrlen ) ;data += fragheaderlen ;skb -> transport_header = ( skb -> network_header + fragheaderlen ) ;if ( fraggap ) {skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ;skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ;data += fraggap ;pskb_trim_unique ( skb_prev , maxfraglen ) ;}copy = datalen - transhdrlen - fraggap ;if ( copy < 0 ) {err = - EINVAL ;kfree_skb ( skb ) ;goto error ;else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) {","if ( transhdrlen ) {skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ;if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) {",3331
1263,"zip_error_set ( error , ZIP_ER_INTERNAL , 0 ) ;if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;}","
",3332
1264,if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;,if ( ! from_buffer ) {_zip_buffer_free ( buffer ) ;,3332
1265,"if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K )  return 0 ;if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ;if ( aux -> alu_state &&  ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) )  return - EACCES ;aux -> alu_state = alu_state ;","if ( can_skip_alu_sanitation ( env , insn ) ) return 0 ;if ( update_alu_sanitation_state ( aux , alu_state , alu_limit ) ) return - EACCES ;aux -> alu_state = alu_state ;",3333
1266,"pr_debug ( ""%p<S2SV_blank>%zu\\\lock_sock ( sk ) ;","pr_debug ( ""%p<S2SV_blank>%zu\\\msg -> msg_namelen = 0 ;lock_sock ( sk ) ;",3334
1267,sockaddr -> sa_family = AF_NFC ;sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ;,"memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;sockaddr -> sa_family = AF_NFC ;sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ;",3334
1268,if ( s ) {struct unix_sock * u = unix_sk ( s ) ;spin_lock ( & unix_gc_lock ) ;spin_unlock ( & unix_gc_lock ) ;}},spin_lock ( & unix_gc_lock ) ;if ( s ) {struct unix_sock * u = unix_sk ( s ) ;}fp -> f_cred -> user -> unix_inflight -- ;spin_unlock ( & unix_gc_lock ) ;},3335
1269,"unsigned char * buf ;assert ( m -> buf_ ) ;if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) {return - 1 ;","unsigned char * buf ;assert ( m -> buf_ ) ;if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {return - 1 ;",3336
1270,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,3337
1271,"static void set_block_size ( VP9_COMP * const cpi ,  const TileInfo * const tile ,  int mi_row , int mi_col , BLOCK_SIZE bsize ) {MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ;xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ;}","static void set_block_size ( VP9_COMP * const cpi , MACROBLOCK * const x , MACROBLOCKD * const xd , int mi_row , int mi_col , BLOCK_SIZE bsize ) {set_mode_info_offsets ( & cpi -> common , x , xd , mi_row , mi_col ) ;xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;}",3338
1272,"sprintf ( address , ""%s:%s"" , url , port ) ;if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ;","snprintf ( address , 254 , ""%s:%s"" , url , port ) ;if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ;",3339
1273,"memset ( global , 0 , sizeof ( * global ) ) ;global -> codec = get_vpx_encoder_by_index ( 0 ) ;global -> passes = 0 ;","const int num_encoder = get_vpx_encoder_count ( ) ;if ( num_encoder < 1 ) die ( ""Error:<S2SV_blank>no<S2SV_blank>valid<S2SV_blank>encoder<S2SV_blank>available\\\memset ( global , 0 , sizeof ( * global ) ) ;global -> codec = get_vpx_encoder_by_index ( num_encoder - 1 ) ;global -> passes = 0 ;global -> color_type = I420 ;global -> passes = 0 ;",3340
1274,"else if ( arg_match ( & arg , & usage , argi ) ) global -> usage = arg_parse_uint ( & arg ) ;else if ( arg_match ( & arg , & use_yv12 , argi ) )  global -> use_i420 = 0 ;else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> use_i420 = 1 ;else if ( arg_match ( & arg , & quietarg , argi ) ) global -> quiet = 1 ;else if ( arg_match ( & arg , & verbosearg , argi ) ) global -> verbose = 1 ;else if ( arg_match ( & arg , & limit , argi ) ) global -> limit = arg_parse_uint ( & arg ) ;else if ( arg_match ( & arg , & skip , argi ) ) global -> skip_frames = arg_parse_uint ( & arg ) ;else if ( arg_match ( & arg , & psnrarg , argi ) ) global -> show_psnr = 1 ;else if ( arg_match ( & arg , & recontest , argi ) ) global -> test_decode = arg_parse_enum_or_int ( & arg ) ;else if ( arg_match ( & arg , & framerate , argi ) ) {global -> framerate = arg_parse_rational ( & arg ) ;validate_positive_rational ( arg . name , & global -> framerate ) ;global -> have_framerate = 1 ;}else if ( arg_match ( & arg , & out_part , argi ) ) global -> out_part = 1 ;else if ( arg_match ( & arg , & debugmode , argi ) ) global -> debug = 1 ;else if ( arg_match ( & arg , & q_hist_n , argi ) ) global -> show_q_hist_buckets = arg_parse_uint ( & arg ) ;else if ( arg_match ( & arg , & rate_hist_n , argi ) ) global -> show_rate_hist_buckets = arg_parse_uint ( & arg ) ;else if ( arg_match ( & arg , & disable_warnings , argi ) ) global -> disable_warnings = 1 ;else if ( arg_match ( & arg , & disable_warning_prompt , argi ) ) global -> disable_warning_prompt = 1 ;else if ( arg_match ( & arg , & experimental_bitstream , argi ) )  global -> experimental_bitstream = 1 ;","else if ( arg_match ( & arg , & usage , argi ) ) global -> color_type = YV12 ;else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> color_type = I420 ;else if ( arg_match ( & arg , & use_i422 , argi ) ) global -> color_type = I422 ;else if ( arg_match ( & arg , & use_i444 , argi ) ) global -> color_type = I444 ;else if ( arg_match ( & arg , & use_i440 , argi ) ) global -> color_type = I440 ;else if ( arg_match ( & arg , & use_yv12 , argi ) ) global -> use_i420 = 0 ;else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> use_i420 = 1 ;",3340
1275,"# if CONFIG_VP9_ENCODER  global -> passes = ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 && global -> deadline != VPX_DL_REALTIME ) ? 2 : 1 ;","# if CONFIG_VP9_ENCODER || CONFIG_VP10_ENCODER if ( global -> codec != NULL && global -> codec -> name != NULL ) global -> passes = ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 && global -> deadline != VPX_DL_REALTIME ) ? 2 : 1 ;",3340
1276,"}target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;","}m -> msg_namelen = 0 ;target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ;",3341
1277,"if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) {* pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ;if ( * pgmap ) page = pte_page ( pte ) ;else goto no_page ;else if ( unlikely ( ! page ) ) {",if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) {if ( unlikely ( ! try_get_page ( page ) ) ) {page = ERR_PTR ( - ENOMEM ) ;goto out ;},3342
1278,if ( flags & FOLL_GET )  get_page ( page ) ;if ( flags & FOLL_TOUCH ) {,if ( flags & FOLL_GET ) get_page ( page ) ;if ( flags & FOLL_TOUCH ) {,3342
1279,"sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;","sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ;sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;",3343
1280,hndl = sock_diag_lock_handler ( req -> sdiag_family ) ;if ( hndl == NULL ) err = - ENOENT ;,if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;hndl = sock_diag_lock_handler ( req -> sdiag_family ) ;if ( hndl == NULL ) err = - ENOENT ;,3344
1281,"static inline ulong encode_twos_comp ( long n , int prec )  {ulong result ;assert ( prec >= 2 ) ;","static inline jas_ulong encode_twos_comp ( long n , int prec ) {jas_ulong result ;assert ( prec >= 2 ) ;",3345
1282,"static int  mptctl_eventquery ( unsigned long arg )  {struct mpt_ioctl_eventquery karg ;MPT_ADAPTER * ioc ;int iocnum ;return - EFAULT ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_eventquery()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;","static int mptctl_eventquery ( MPT_ADAPTER * ioc , unsigned long arg ) {struct mpt_ioctl_eventquery karg ;return - EFAULT ;",3346
1283,if ( source == target )  return 0 ;,"if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) ) return 0 ;",3347
1284,"
",WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;,3348
1285,if ( ! vma -> vm_userfaultfd_ctx . ctx )  goto skip ;,if ( ! vma -> vm_userfaultfd_ctx . ctx ) goto skip ;,3348
1286,"static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options )  {","static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options , uid_t * check_ruid ) {",3349
1287,if ( ! options ) {rc = - EINVAL ;,* check_ruid = 0 ;if ( ! options ) {rc = - EINVAL ;,3349
1288,"
",case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ;break ;,3349
1289,"case ecryptfs_opt_err :  default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\\","case ecryptfs_opt_err : default : printk ( KERN_WARNING ""%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\\",3349
1290,"len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ;if ( len == - 1 ) {","len = mutt_b64_decode ( obuf , idata -> buf + 2 , sizeof ( obuf ) ) ;if ( len == - 1 ) {",3350
1291,"int Downmix_Reset ( downmix_object_t * pDownmixer , bool init ) {return 0 ;","int Downmix_Reset ( downmix_object_t * pDownmixer __unused , bool init __unused ) {return 0 ;",3351
1292,if ( cache_type ) {,if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) {,3352
1293,"
",if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;,3352
1294,if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {if ( io ) io -> flag = EXT4_IO_UNWRITTEN ;}},if ( flags == EXT4_GET_BLOCKS_PRE_IO ) {if ( io ) io -> flag = EXT4_IO_UNWRITTEN ;}},3352
1295,if ( retval ) {,if ( retval || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != \'\\\\0\' ) {,3353
1296,"if ( retval ) {com_err ( ""uu-server"" , retval , ""reading<S2SV_blank>pname"" ) ;","if ( retval ) {com_err ( ""uu-server"" , retval , ""reading<S2SV_blank>pname"" ) ;",3353
1297,block_length = data [ i ] * 256 + data [ i + 1 ] ;},if ( i + 1 < data_size ) block_length = data [ i ] * 256 + data [ i + 1 ] ;},3354
1298,"for ( plane = 0 ;in -> data [ plane ] && plane < 4 ;plane ++ )  hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;for ( plane = 0 ;in -> data [ plane ] && plane < 4 ;plane ++ )  vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;","for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;plane ++ ) hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;plane ++ ) vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ;",3355
1299,RATE_CONTROL * const rc = & cpi -> rc ;VP9_CONFIG * const oxcf = & cpi -> oxcf ;struct twopass_rc * const twopass = & cpi -> twopass ;FIRSTPASS_STATS next_frame = {0 };const FIRSTPASS_STATS * start_pos ;int i ;double gf_first_frame_err = 0.0 ;double mod_frame_err = 0.0 ;,VP9_COMMON * const cm = & cpi -> common ;RATE_CONTROL * const rc = & cpi -> rc ;VP9EncoderConfig * const oxcf = & cpi -> oxcf ;TWO_PASS * const twopass = & cpi -> twopass ;FIRSTPASS_STATS next_frame ;const FIRSTPASS_STATS * start_pos ;int i ;# if GROUP_ADAPTIVE_MAXQ double gf_group_raw_error = 0.0 ;# endif double gf_group_skip_pct = 0.0 ;double gf_group_inactive_zone_rows = 0.0 ;double gf_first_frame_err = 0.0 ;double mod_frame_err = 0.0 ;,3356
1300,"const int max_bits = frame_max_bits ( rc , oxcf ) ;unsigned int allow_alt_ref = oxcf -> play_alternate && oxcf -> lag_in_frames ;twopass -> gf_group_bits = 0 ;vp9_clear_system_state ( ) ;start_pos = twopass -> stats_in ;mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) gf_group_err -= gf_first_frame_err ;mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 10.0 ;active_max_gf_interval = 12 + ( ( int ) vp9_convert_qindex_to_q ( rc -> last_q [ INTER_FRAME ] ) >> 5 ) ;if ( active_max_gf_interval > rc -> max_gf_interval )  active_max_gf_interval = rc -> max_gf_interval ;i = 0 ;mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;gf_group_err += mod_frame_err ;if ( EOF == input_stats ( twopass , & next_frame ) )  break ;loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ;decay_accumulator = decay_accumulator * loop_decay_rate ;if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) <  zero_motion_accumulator ) {zero_motion_accumulator = next_frame . pcnt_inter - next_frame . pcnt_motion ;}if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate ,  last_loop_decay_rate ) ) {boost_score += ( decay_accumulator *   calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ) ;if (  ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) ||  (  ( i > MIN_GF_INTERVAL ) &&  ( ( boost_score > 125.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > mv_ratio_accumulator_thresh ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) ||  ( ( boost_score - old_boost_score ) < IIFACTOR ) ) ) ) {boost_score = old_boost_score ;if ( ( rc -> frames_to_key - i ) < MIN_GF_INTERVAL ) {while ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) {++ i ;if ( i < rc -> frames_to_key ) {mod_frame_err = calculate_modified_err ( cpi , this_frame ) ;gf_group_err += mod_frame_err ;}}}# if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) {cpi -> new_frame_coding_order_period = 0 ;cpi -> next_frame_in_order = 0 ;cpi -> arf_buffered = 0 ;vp9_zero ( cpi -> frame_coding_order ) ;vp9_zero ( cpi -> arf_buffer_idx ) ;vpx_memset ( cpi -> arf_weight , - 1 , sizeof ( cpi -> arf_weight ) ) ;}# endif if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active )  rc -> baseline_gf_interval = i - 1 ;else  rc -> baseline_gf_interval = i ;if ( allow_alt_ref &&  ( i < cpi -> oxcf . lag_in_frames ) &&  ( i >= MIN_GF_INTERVAL ) && ( rc -> next_key_frame_forced || ( i <= ( rc -> frames_to_key - MIN_GF_INTERVAL ) ) ) ) {# endif  }rc -> gfu_boost = ( int ) boost_score ;rc -> source_alt_ref_pending = 0 ;# if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled ) {# if CONFIG_MULTIPLE_ARF  if ( cpi -> multi_arf_enabled && ( cpi -> common . frame_type != KEY_FRAME ) ) {int max_level = INT_MIN ;for ( i = 0 ;i < cpi -> frame_coding_order_period ;++ i ) {if ( cpi -> arf_weight [ i ] > max_level ) {max_level = cpi -> arf_weight [ i ] ;","unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ;int active_min_gf_interval ;int64_t gf_group_bits ;double gf_group_error_left ;int gf_arf_bits ;const int is_key_frame = frame_is_intra_only ( cm ) ;const int arf_active_or_kf = is_key_frame || rc -> source_alt_ref_active ;if ( is_key_frame == 0 ) {vp9_zero ( twopass -> gf_group ) ;}vpx_clear_system_state ( ) ;vp9_zero ( next_frame ) ;mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ;if ( arf_active_or_kf ) {gf_group_err -= gf_first_frame_err ;# if GROUP_ADAPTIVE_MAXQ gf_group_raw_error -= this_frame -> coded_error ;# endif gf_group_skip_pct -= this_frame -> intra_skip_pct ;gf_group_inactive_zone_rows -= this_frame -> inactive_zone_rows ;}mv_ratio_accumulator_thresh = ( cpi -> initial_height + cpi -> initial_width ) / 4.0 ;{int int_max_q = ( int ) ( vp9_convert_qindex_to_q ( twopass -> active_worst_quality , cpi -> common . bit_depth ) ) ;int int_lbq = ( int ) ( vp9_convert_qindex_to_q ( rc -> last_boosted_qindex , cpi -> common . bit_depth ) ) ;active_min_gf_interval = rc -> min_gf_interval + MIN ( 2 , int_max_q / 200 ) ;if ( active_min_gf_interval > rc -> max_gf_interval ) active_min_gf_interval = rc -> max_gf_interval ;if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval ;}}if ( cpi -> multi_arf_allowed ) {active_max_gf_interval = rc -> max_gf_interval ;}else {active_max_gf_interval = 12 + MIN ( 4 , ( int_lbq / 6 ) ) ;if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval ;if ( active_max_gf_interval > rc -> max_gf_interval ) active_max_gf_interval = rc -> max_gf_interval ;i = 0 ;mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ;gf_group_err += mod_frame_err ;# if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ;# endif gf_group_skip_pct += this_frame -> intra_skip_pct ;gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ;if ( EOF == input_stats ( twopass , & next_frame ) ) break ;loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ;decay_accumulator = decay_accumulator * loop_decay_rate ;zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ;if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate , last_loop_decay_rate ) ) {boost_score += decay_accumulator * calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out , GF_MAX_BOOST ) ;if ( ( i >= ( active_max_gf_interval + arf_active_or_kf ) && zero_motion_accumulator < 0.995 ) || ( ( i > MIN_GF_INTERVAL ) && ( ( boost_score > 125.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > mv_ratio_accumulator_thresh ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < BOOST_BREAKOUT ) ) ) ) {boost_score = old_boost_score ;+ i ;rc -> constrained_gf_group = ( i >= rc -> frames_to_key ) ? 1 : 0 ;if ( allow_alt_ref && ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) {++ i ;gf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ;# if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ;# endif gf_group_skip_pct += this_frame -> intra_skip_pct ;gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ;}rc -> baseline_gf_interval = i - 1 ;else rc -> baseline_gf_interval = i ;if ( allow_alt_ref && ( i < cpi -> oxcf . lag_in_frames ) && ( i >= MIN_GF_INTERVAL ) && ( rc -> next_key_frame_forced || ( i <= ( rc -> frames_to_key - MIN_GF_INTERVAL ) ) ) ) {# endif gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , rc -> gfu_boost , gf_group_bits ) ;twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ;if ( rc -> source_alt_ref_pending ) {gf_group_error_left = gf_group_err - mod_frame_err ;}else if ( is_key_frame == 0 ) {gf_group_error_left = gf_group_err - gf_first_frame_err ;}gf_group_error_left = gf_group_err ;}allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ;reset_fpf_position ( twopass , start_pos ) ;if ( cpi -> multi_arf_enabled ) {+ i ) {# if CONFIG_MULTIPLE_ARF if ( cpi -> multi_arf_enabled && ( cpi -> common . frame_type != KEY_FRAME ) {twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ;}if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) {cpi -> rc . next_frame_size_selector = UNSCALED ;",3356
1301,"
",nfp_repr_free ( repr ) ;,3357
1302,goto err_reprs_clean ;},goto err_reprs_clean ;},3357
1303,nfp_repr_free ( repr ) ;goto err_reprs_clean ;,kfree ( repr_priv ) ;nfp_repr_free ( repr ) ;goto err_reprs_clean ;,3357
1304,if ( err ) {nfp_port_free ( port ) ;,if ( err ) {kfree ( repr_priv ) ;nfp_port_free ( port ) ;,3357
1305,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",3358
1306,if ( sp -> sa_protocol != PX_PROTO_PPTP )  return - EINVAL ;,if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;if ( sp -> sa_protocol != PX_PROTO_PPTP ) return - EINVAL ;,3359
1307,"RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;if ( ! work_to_do ) {","if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) {netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\\netbk_fatal_tx_err ( vif ) ;continue ;}RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ;if ( ! work_to_do ) {",3360
1308,"if ( unlikely ( work_to_do < 0 ) ) {netbk_tx_err ( vif , & txreq , idx ) ;continue ;}if ( unlikely ( ret < 0 ) ) {netbk_tx_err ( vif , & txreq , idx - ret ) ;continue ;}",if ( unlikely ( work_to_do < 0 ) ) continue ;if ( unlikely ( ret < 0 ) ) continue ;,3360
1309,"netdev_dbg ( vif -> dev ,  ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\\netbk_tx_err ( vif , & txreq , idx ) ;continue ;","netdev_err ( vif -> dev , ""txreq.offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u,<S2SV_blank>end:<S2SV_blank>%lu\\\netbk_fatal_tx_err ( vif ) ;continue ;",3360
1310,"netbk_tx_err ( vif , & txreq , idx ) ;continue ;",continue ;,3360
1311,"
",same -> dest_count = count ;,3361
1312,"ret = vfs_dedupe_file_range ( file , same ) ;if ( ret ) goto out ;","ret = vfs_dedupe_file_range ( file , same ) ;if ( ret ) goto out ;",3361
1313,}return OK ;,"if ( * i == \'\\\\\\\\\' ) {AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ;return HTTP_BAD_REQUEST ;}}return OK ;",3362
1314,"char * to , * repl ;to = g . inf ;if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) {to = g . hname ;len = strlen ( g . hname ) ;}repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ;g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ;if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ;memcpy ( g . outf , to , len ) ;strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ;g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ;","char * to = g . inf , * sufx = """" ;size_t pre = 0 ;if ( g . decode ) {if ( ( g . headis & 1 ) != 0 && g . hname != NULL ) {pre = justname ( g . inf ) - g . inf ;to = justname ( g . hname ) ;len = strlen ( to ) ;}else if ( strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ;g . outf = MALLOC ( pre + len + strlen ( sufx ) + 1 ) ;if ( g . outf == NULL ) bail ( ""not<S2SV_blank>enough<S2SV_blank>memory"" , """" ) ;memcpy ( g . outf , g . inf , pre ) ;memcpy ( g . outf + pre , to , len ) ;strcpy ( g . outf + pre + len , sufx ) ;g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | ( g . force ? 0 : O_EXCL ) , 0600 ) ;",3363
1315,"if ( mi < 0 )  return - EINVAL ;return remap_pfn_range ( vma , vma -> vm_start ,  idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;","struct uio_mem * mem ;if ( mi < 0 ) return - EINVAL ;mem = idev -> info -> mem + mi ;if ( vma -> vm_end - vma -> vm_start > mem -> size ) return - EINVAL ;return remap_pfn_range ( vma , vma -> vm_start , mem -> addr >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;",3364
1316,if ( src == NULL )  return 0 ;w = src -> width ;,"if ( src == NULL ) return 0 ;if ( ( UINT32_MAX - src -> width < ( x > 0 ? x : - x ) ) || ( UINT32_MAX - src -> height < ( y > 0 ? y : - y ) ) ) {# ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , ""overflow<S2SV_blank>in<S2SV_blank>compose_image"" ) ;# endif return 0 ;}w = src -> width ;",3365
1317,"static int  mptctl_do_mpt_command ( struct mpt_ioctl_command karg , void __user * mfPtr )  {MPT_ADAPTER * ioc ;MPT_FRAME_HDR * mf = NULL ;","static int mptctl_do_mpt_command ( MPT_ADAPTER * ioc , struct mpt_ioctl_command karg , void __user * mfPtr ) {MPT_FRAME_HDR * mf = NULL ;",3366
1318,"int iocnum , flagsLength ;int sz , rc = 0 ;int msgContext ;u16 req_idx ;ulong timeout ;unsigned long timeleft ;struct scsi_device * sdev ;unsigned long flags ;u8 function ;bufIn . kptr = bufOut . kptr = NULL ;bufIn . len = bufOut . len = 0 ;if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||  ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_do_mpt_command()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;}","int flagsLength ;int sz , rc = 0 ;",3366
1319,"strcpy ( algo -> alg_name , auth -> alg_name ) ;memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ) ;","strncpy ( algo -> alg_name , auth -> alg_name , sizeof ( algo -> alg_name ) ) ;memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ) ;",3367
1320,"u8 * output ;gf_bs_get_content_no_truncate ( ctx -> state . bs , & ctx -> state . frame_obus , & pck_size , & ctx -> state . frame_obus_alloc ) ;","u8 * output ;if ( ! ctx -> opid ) return GF_NON_COMPLIANT_BITSTREAM ;gf_bs_get_content_no_truncate ( ctx -> state . bs , & ctx -> state . frame_obus , & pck_size , & ctx -> state . frame_obus_alloc ) ;",3368
1321,if ( type == HUB_INIT2 )  goto init2 ;if ( type == HUB_INIT3 )  goto init3 ;,"if ( type == HUB_INIT2 || type == HUB_INIT3 ) {device_lock ( hub -> intfdev ) ;if ( hub -> disconnected ) {device_unlock ( hub -> intfdev ) ;kref_put ( & hub -> kref , hub_release ) ;return ;}if ( type == HUB_INIT2 ) goto init2 ;goto init3 ;}kref_get ( & hub -> kref ) ;",3369
1322,"
","device_unlock ( hub -> intfdev ) ;if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ;kref_put ( & hub -> kref , hub_release ) ;",3369
1323,return ;},return ;},3369
1324,},},3369
1325,while ( * param != '<S2SV_blank>' && * param != '\\\\0' )  param ++ ;while ( * param == '<S2SV_blank>' )   param ++ ;},while ( * param != '<S2SV_blank>' && * param != '\\\\0' ) {param ++ ;}while ( * param == '<S2SV_blank>' ) {param ++ ;}},3370
1326,if ( code == gcode )  return & wordlist [ key ] ;,if ( code == gcode && wordlist [ key ] . index >= 0 ) return & wordlist [ key ] ;,3371
1327,"char buffer [ 4096 ] ;char buffer2 [ 4096 ] ;char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;int l ;if ( name_len > sizeof ( buffer ) - 2 ) {buf = estrndup ( name , name_len ) ;}else {memcpy ( buf , name , name_len ) ;buf [ name_len ] = 0 ;decrypt_return_plain :  if ( buf != buffer ) {efree ( buf ) ;}","char * buf = buffer , * buf2 = buffer2 , * d , * d_url ;int l ;buf = estrndup ( name , name_len ) ;else {memcpy ( buf , name , name_len ) ;decrypt_return_plain : efree ( buf ) ;",3372
1328,"else if ( SUHOSIN_G ( cookie_cryptlist ) ) {if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) {goto decrypt_return_plain ;}}if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) {memcpy ( buf2 , value , value_len ) ;buf2 [ value_len ] = 0 ;}else {}","
",3372
1329,skip_cookie :  if ( buf != buffer ) {efree ( buf ) ;}if ( buf2 != buffer2 ) {},skip_cookie : efree ( buf ) ;,3372
1330,x < ( ssize_t ) image -> columns ;,"x < ( ssize_t ) ConstrainColormapIndex ( image , image -> columns ;",3373
1331,"SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ;","SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , exception ) , q ) ;",3373
1332,"SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t )  GetPixelIndex ( image , q ) , q ) ;q += GetPixelChannels ( image ) ;","SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) GetPixelIndex ( image , q ) , q ) ;q += GetPixelChannels ( image ) ;",3373
1333,case PKT_STARTUP : if ( client -> pool ) {,"case PKT_STARTUP : if ( ! client -> auth_user ) {disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ;return false ;}if ( client -> pool ) {",3374
1334,"case \'p\' :  if ( cf_auth_type <= AUTH_TRUST ) {disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ;","case \'p\' : if ( cf_auth_type <= AUTH_TRUST ) {disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ;",3374
1335,"BUFPUTSL ( ob , ""<q>"" ) ;bufput ( ob , text -> data , text -> size ) ;","struct html_renderopt * options = opaque ;BUFPUTSL ( ob , ""<q>"" ) ;if ( options -> flags & HTML_ESCAPE ) escape_html ( ob , text -> data , text -> size ) ;else bufput ( ob , text -> data , text -> size ) ;",3375
1336,"if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) {return - EACCES ;","if ( cgroup ) {if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ;if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) return - EACCES ;",3376
1337,"void validate_positive_rational ( const char * msg ,  struct vpx_rational * rat ) {","static void validate_positive_rational ( const char * msg , struct vpx_rational * rat ) {",3377
1338,"
",buflen ++ ;,3378
1339,continue ;},continue ;},3378
1340,"# if 1 fprintf ( out , ""\\\\t%u"" , id ) ;# else fprintf ( out , ""\\\\t%u(%u)"" , id , flow -> flow_id ) ;fprintf ( out , ""%s%s%s:%u<S2SV_blank>%s<S2SV_blank>%s%s%s:%u<S2SV_blank>"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> src_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> src_port ) , flow -> bidirectional ? ""<->"" : ""->"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> dst_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> dst_port ) ) ;if ( flow -> vlan_id > 0 ) fprintf ( out , ""[VLAN:<S2SV_blank>%u]"" , flow -> vlan_id ) ;","# if 1 fprintf ( out , ""[URL:<S2SV_blank>%s][StatusCode:<S2SV_blank>%u]"" , flow -> flow_id ) ;fprintf ( out , ""[Content-Type:<S2SV_blank>%s]"" , flow -> src_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> src_port ) , flow -> bidirectional ? ""<->"" : ""->"" , ( flow -> ip_version == 6 ) ? ""["" : """" , flow -> dst_name , ( flow -> ip_version == 6 ) ? ""]"" : """" , ntohs ( flow -> dst_port ) ) ;if ( flow -> vlan_id > 0 ) fprintf ( out , ""[User-Agent:<S2SV_blank>%s]"" , flow -> vlan_id ) ;",3379
1341,"fprintf ( out , ""[URL:<S2SV_blank>%s[StatusCode:<S2SV_blank>%u]"" ,  flow -> http . url , flow -> http . response_status_code ) ;if ( flow -> http . content_type [ 0 ] != \'\\\\0\' )  fprintf ( out , ""[ContentType:<S2SV_blank>%s]"" , flow -> http . content_type ) ;if ( flow -> http . user_agent [ 0 ] != \'\\\\0\' )  fprintf ( out , ""[UserAgent:<S2SV_blank>%s]"" , flow -> http . user_agent ) ;}","fprintf ( out , ""[URL:<S2SV_blank>%s[StatusCode:<S2SV_blank>%u]"" , flow -> http . url , flow -> http . response_status_code ) ;if ( flow -> http . content_type [ 0 ] != \'\\\\0\' ) fprintf ( out , ""[ContentType:<S2SV_blank>%s]"" , flow -> http . content_type ) ;if ( flow -> http . user_agent [ 0 ] != \'\\\\0\' ) fprintf ( out , ""[UserAgent:<S2SV_blank>%s]"" , flow -> http . user_agent ) ;}",3379
1342,"int ret ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data ,  indx , & data , 1 , 1000 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}","u8 * buf ;int ret ;buf = kmemdup ( & data , 1 , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data , indx , buf , 1 , 1000 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\kfree ( buf ) ;return ret ;}",3380
1343,"for ( plane = 0 ;plane < 4 && in -> data [ plane ] ;const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ;","for ( plane = 0 ;plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ;const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ;",3381
1344,if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt )   return - EINVAL ;if ( ! rt ) return 0 ;,struct xfrm_replay_state_esn * rs ;if ( p -> flags & XFRM_STATE_ESN ) {if ( ! rt ) return - EINVAL ;rs = nla_data ( rt ) ;if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ;if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ;}if ( ! rt ) return 0 ;,3382
1345,"static void mark_object ( struct object * obj , struct strbuf * path ,  const char * name , void * data ) {","static void mark_object ( struct object * obj , const char * name , void * data ) {",3383
1346,"guchar * match ;int i ;if ( client -> auth_end_offset > 0 ) {gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ;gsize to_match = MIN ( left , buffer -> pos ) ;if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 )  {","goffset offset = 0 ;gsize original_size = client -> auth_buffer -> len ;g_byte_array_append ( client -> auth_buffer , buffer -> data , buffer -> pos ) ;if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) {",3384
1347,"if ( match != NULL )  return match - buffer -> data + strlen ( AUTH_END_STRING ) ;for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ;i > 0 ;i -- ) {if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) {client -> auth_end_offset = i ;break ;return - 1 ;","if ( match != NULL ) return match - buffer -> data + strlen ( AUTH_END_STRING ) ;for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ;while ( TRUE ) {guint8 * line_start = client -> auth_buffer -> data + offset ;gsize remaining_data = client -> auth_buffer -> len - offset ;guint8 * line_end ;line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ;if ( line_end ) {offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ;if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ;* line_end = 0 ;if ( auth_line_is_begin ( line_start ) ) return offset - original_size ;}else {g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ;if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ;return FIND_AUTH_END_CONTINUE ;",3384
1348,"z . kind = 0 ;z . class = 0 ;# define PARSE_STRING s = parse_field ( ndo , & parse , & parselen ) ;# define PARSE_FIELD_INT ( field ) PARSE_STRING if ( ! lose ) field = strtol ( s , 0 , 16 ) ;if ( lose ) return ;if ( strncmp ( z . version , ""ZEPH"" , 4 ) ) return ;PARSE_FIELD_INT ( z . numfields ) ;PARSE_FIELD_INT ( z . kind ) ;PARSE_FIELD_STR ( z . uid ) ;PARSE_FIELD_INT ( z . port ) ;PARSE_FIELD_INT ( z . auth ) ;PARSE_FIELD_INT ( z . authlen ) ;PARSE_FIELD_STR ( z . authdata ) ;PARSE_FIELD_STR ( z . class ) ;PARSE_FIELD_STR ( z . inst ) ;PARSE_FIELD_STR ( z . opcode ) ;PARSE_FIELD_STR ( z . sender ) ;PARSE_FIELD_STR ( z . recipient ) ;PARSE_FIELD_STR ( z . format ) ;PARSE_FIELD_INT ( z . cksum ) ;PARSE_FIELD_INT ( z . multi ) ;PARSE_FIELD_STR ( z . multi_uid ) ;if ( lose ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;","int truncated = 0 ;z . kind = 0 ;z . class = 0 ;# define PARSE_STRING s = parse_field ( ndo , & parse , & parselen , & truncated ) ;if ( truncated ) goto trunc ;# define PARSE_FIELD_INT ( field ) PARSE_STRING if ( ! lose ) field = strtol ( s , 0 , 16 ) ;if ( lose ) goto trunc ;ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;return ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ;return ;",3385
1349,},},3385
1350,"if ( ! mp -> ports && ! mp -> mglist &&  netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;","if ( ! mp -> ports && ! mp -> mglist && mp -> timer_armed && netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;",3386
1351,"if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ;","memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ;if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ;",3387
1352,"st = decrease_reservation ( nr_pages , GFP_USER ) ;if ( st != BP_DONE ) return - ENOMEM ;","if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ;st = decrease_reservation ( nr_pages , GFP_USER ) ;if ( st != BP_DONE ) return - ENOMEM ;",3388
1353,case 0x00 :  p += 2 ;n += 2 ;case 0x40 :  p += 3 ;n += 3 ;case 0x80 :  p += 4 ;n += 4 ;case 0xC0 :  l = p [ 1 ] ;if ( l < 10 || l > 20 ) return - 1 ;,case 0x00 : if ( len < 2 ) return - 1 ;p += 2 ;n += 2 ;case 0x40 : if ( len < 3 ) return - 1 ;p += 3 ;n += 3 ;case 0x80 : if ( len < 4 ) return - 1 ;p += 4 ;n += 4 ;case 0xC0 : if ( len < 2 ) return - 1 ;l = p [ 1 ] ;if ( l < 10 || l > 20 ) return - 1 ;,3389
1354,"}msg -> msg_namelen = sizeof ( * sax ) ;skb_free_datagram ( sk , skb ) ;release_sock ( sk ) ;","msg -> msg_namelen = sizeof ( * sax ) ;}skb_free_datagram ( sk , skb ) ;release_sock ( sk ) ;",3390
1355,"p = strchr ( context -> buffer , '<S2SV_blank>' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;","p = osStrchr ( context -> buffer , '<S2SV_blank>' ) ;if ( p == NULL ) return ERROR_INVALID_SYNTAX ;",3391
1356,"for ( i = 1 ;i <= SYSTEM_ID_LEN ;snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""%02x"" , * cp ++ ) ;","int sysid_len ;sysid_len = SYSTEM_ID_LEN ;if ( sysid_len > id_len ) sysid_len = id_len ;for ( i = 1 ;i <= sysid_len ;snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""%02x"" , * cp ++ ) ;",3392
1357,"
",if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;,3393
1358,line += PKT_LEN_SIZE ;if ( len == PKT_LEN_SIZE ) {,line += PKT_LEN_SIZE ;if ( len == PKT_LEN_SIZE ) {,3393
1359,"DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ;if ( ! fields ) {","const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ;DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ;if ( ! fields ) {",3394
1360,unsigned long len = php_mysqlnd_net_field_length ( & p ) ;if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) {,"const unsigned long len = php_mysqlnd_net_field_length ( & p ) ;if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) {php_error_docref ( NULL , E_WARNING , ""Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>"" MYSQLND_SZ_T_SPEC ""<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet"" , ( p + len ) - packet_end - 1 ) ;DBG_RETURN ( FAIL ) ;}if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) {",3394
1361,u8 odata [ 16 ] ;u8 idata [ 16 ] ;,u8 * odata = pctx -> odata ;u8 * idata = pctx -> idata ;,3395
1362,"static int ceph_x_decrypt ( struct ceph_crypto_key * secret ,  void * * p , void * end , void * obuf , size_t olen )  {ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen ,  * p , len ) ;","static int ceph_x_decrypt ( struct ceph_crypto_key * secret , void * * p , void * end , void * * obuf , size_t olen ) {if ( * obuf == NULL ) {* obuf = kmalloc ( len , GFP_NOFS ) ;if ( ! * obuf ) return - ENOMEM ;olen = len ;}ret = ceph_decrypt2 ( secret , & head , & head_len , * obuf , & olen , * p , len ) ;",3396
1363,if ( name_len == 0 ) goto chunk_end ;name = p ;READ_ENCINT ( length ) ;if ( ( offset == 0 ) && ( length == 0 ) ) {,name = p ;READ_ENCINT ( length ) ;if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ;if ( ( offset == 0 ) && ( length == 0 ) ) {,3397
1364,"# if HAVE_XSHM shm -> shmid = shmget ( IPC_PRIVATE ,  xim -> bytes_per_line * xim -> height , IPC_CREAT | 0777 ) ;if ( shm -> shmid == - 1 ) {","# if HAVE_XSHM shm -> shmid = shmget ( IPC_PRIVATE , xim -> bytes_per_line * xim -> height , IPC_CREAT | 0600 ) ;if ( shm -> shmid == - 1 ) {",3398
1365,if ( event -> attr . inherit || ! is_sampling_event ( event ) )  return - EINVAL ;return 0 ;},"struct perf_event_context * ctx ;int ret ;ctx = perf_event_ctx_lock ( event ) ) return - EINVAL ;ret = _perf_event_refresh ( event , refresh ) ;perf_event_ctx_unlock ( event , ctx ) ;return ret ;}",3399
1366,"if ( level != SOL_PPPOL2TP )  return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ;if ( optlen < sizeof ( int ) ) return - EINVAL ;",if ( level != SOL_PPPOL2TP ) return - EINVAL ;if ( optlen < sizeof ( int ) ) return - EINVAL ;,3400
1367,section -> frame = 0.0 ;section -> intra_error = 0.0 ;section -> sr_coded_error = 0.0 ;section -> ssim_weighted_pred_err = 0.0 ;section -> pcnt_neutral = 0.0 ;section -> MVr = 0.0 ;,section -> frame = 0.0 ;section -> weight = 0.0 ;section -> intra_error = 0.0 ;section -> sr_coded_error = 0.0 ;section -> ssim_weighted_pred_err = 0.0 ;section -> pcnt_neutral = 0.0 ;section -> intra_skip_pct = 0.0 ;section -> inactive_zone_rows = 0.0 ;section -> inactive_zone_cols = 0.0 ;section -> MVr = 0.0 ;,3401
1368,bool off_is_neg = off_reg -> smin_value < 0 ;bool ptr_is_dst_reg = ptr_reg == dst_reg ;,bool off_is_imm = tnum_is_const ( off_reg -> var_off ) ;bool off_is_neg = off_reg -> smin_value < 0 ;bool ptr_is_dst_reg = ptr_reg == dst_reg ;,3402
1369,alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ;alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ;,alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ;alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0 ;alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ;,3402
1370,"while ( * end_ptr != \\\'\\\\""\\\' && * end_ptr && ++ len ) if ( * end_ptr ++ == \'\\\\\\\\\' ) end_ptr ++ ;out = ( char * ) cJSON_malloc ( len + 1 ) ;","while ( * end_ptr != \\\'\\\\""\\\' && * end_ptr && ++ len ) {if ( * end_ptr ++ == \'\\\\\\\\\' ) {if ( * end_ptr == \'\\\\0\' ) {return 0 ;}end_ptr ++ ;}}out = ( char * ) cJSON_malloc ( len + 1 ) ;",3403
1371,if ( status ) {if ( edge_port -> lsr_event ) {edge_port -> lsr_event = 0 ;,if ( urb -> actual_length > 0 && status ) {if ( edge_port -> lsr_event ) {edge_port -> lsr_event = 0 ;,3404
1372,"Rd_WP_DWORD ( image , & Rec . RecordLength ) ;if ( EOFBlob ( image ) ) break ;","Rd_WP_DWORD ( image , & Rec . RecordLength ) ;if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;if ( EOFBlob ( image ) ) break ;",3405
1373,"return reply_msg ( c , MSG_BAD_FORMAT ) ;type = which_cmd ( c ) ;dprintf ( ""got<S2SV_blank>%s<S2SV_blank>command:<S2SV_blank>\\\\""%s\\\\""\\\switch ( type ) {case OP_PUT : r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;r = read_delay ( & delay , delay_buf , & ttr_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;r = read_ttr ( & ttr , ttr_buf , & size_buf ) ;if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ;errno = 0 ;body_size = strtoul ( size_buf , & end_buf , 10 ) ;if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ;if ( body_size > job_data_size_limit ) {return reply_msg ( c , MSG_JOB_TOO_BIG ) ;}","return skip ( c , body_size + 2 , MSG_JOB_TOO_BIG ) ;",3406
1374,if ( likely ( s [ 1 ] && s [ 2 ] ) ) {* d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ;s += 2 ;,char t = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ;* d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>' ) ;s += 2 ;,3407
1375,if ( s -> pts == AV_NOPTS_VALUE ) {,if ( s -> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0 ) {,3408
1376,"if ( buf -> pts == AV_NOPTS_VALUE ) {return write_to_fifo ( s -> fifo , buf ) ;","if ( buf -> pts == AV_NOPTS_VALUE ) {return write_to_fifo ( s -> fifo , buf ) ;",3408
1377,"fseek ( f , 0 , SEEK_SET ) ;if ( fscanf ( f , ""PG%[<S2SV_blank>\\\\t]%c%c%[<S2SV_blank>\\\\t+-]%d%[<S2SV_blank>\\\\t]%d%[<S2SV_blank>\\\\t]%d"" , temp , & endian1 ,  & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) {","fseek ( f , ""PG%31[<S2SV_blank>\\\\t]%c%c%31[<S2SV_blank>\\\\t+-]%d%31[<S2SV_blank>\\\\t]%d%31[<S2SV_blank>\\\\t]%d"" , temp , & endian1 , & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) {",3409
1378,struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ;struct rng_alg * alg = crypto_rng_alg ( rng ) ;struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ;if ( oalg -> rng_make_random ) {rng -> generate = generate ;rng -> seed = rngapi_reset ;rng -> seedsize = oalg -> seedsize ;,"
",3410
1379,"if ( ! strcmp ( attr , ""packetization-mode"" ) ) {","if ( * value == 0 || ! strcmp ( attr , ""packetization-mode"" ) ) {",3411
1380,"if ( value [ strlen ( value ) - 1 ] == \',\' ) {av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\\","if ( value [ strlen ( value ) - 1 ] == \',\' ) {av_log ( s , AV_LOG_WARNING , ""Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\\",3411
1381,"if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) {res = M_fs_delete ( path_new , M_FALSE , NULL , M_FS_PROGRESS_NOEXTRA ) ;if ( res != M_FS_ERROR_SUCCESS ) {return res ;}}","
",3412
1382,"strcat ( t1_buf_array , t1_line_array ) ;strcpy ( t1_line_array , t1_buf_array ) ;","alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcat ( t1_buf_array , t1_line_array ) ;alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ;strcpy ( t1_line_array , t1_buf_array ) ;",3413
1383,"return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;}","int ret ;ret = scsi_verify_blk_ioctl ( bd , cmd ) ;if ( ret < 0 ) return ret ;return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ;}",3414
1384,"sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL ,  ""FILE:<S2SV_blank>%02X%02X%02X%02X\\\}}","if ( bufLen < 2 ) break ;sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , ""FILE:<S2SV_blank>%02X%02X%02X%02X\\\bufLen -= 2 ;}}",3415
1385,"ptr = realloc ( priv -> EF_C_DevAut , len ) ;if ( ptr ) {priv -> EF_C_DevAut_len = len ;}","if ( len > 0 ) {ptr = realloc ( priv -> EF_C_DevAut , len ) ;if ( ptr ) {priv -> EF_C_DevAut_len = len ;}}",3416
1386,"static void  swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {horAcc16 ( tif , cp0 , cc ) ;}","static int swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {return horAcc16 ( tif , cp0 , cc ) ;}",3417
1387,"struct twopass_rc * const twopass = & cpi -> twopass ;int frames_left ;FIRSTPASS_STATS this_frame_copy ;double this_frame_intra_error ;double this_frame_coded_error ;int target ;LAYER_CONTEXT * lc = NULL ;int is_spatial_svc = ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) ;if ( is_spatial_svc ) {lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] ;frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ;frames_left = ( int ) ( twopass -> total_stats . count -  cm -> current_video_frame ) ;}if ( cpi -> refresh_alt_ref_frame ) {vp9_rc_set_frame_target ( cpi , twopass -> gf_bits ) ;return ;vp9_clear_system_state ( ) ;if ( is_spatial_svc && twopass -> kf_intra_err_min == 0 ) {twopass -> kf_intra_err_min = KF_MB_INTRA_MIN * cpi -> common . MBs ;twopass -> gf_intra_err_min = GF_MB_INTRA_MIN * cpi -> common . MBs ;if ( cpi -> oxcf . end_usage == USAGE_CONSTANT_QUALITY ) {else if ( cm -> current_video_frame == 0 || ( is_spatial_svc && lc -> current_video_frame_in_layer == 0 ) ) {const int tmp_q = vp9_twopass_worst_quality ( cpi , & twopass -> total_left_stats , section_target_bandwidth ) ;rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q ) ;this_frame_intra_error = this_frame . intra_error ;this_frame_coded_error = this_frame . coded_error ;if ( rc -> frames_to_key == 0 || ( cm -> frame_flags & FRAMEFLAGS_KEY ) ) {find_next_key_frame ( cpi , & this_frame_copy ) ;if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 && cpi -> svc . spatial_layer_id > 0 ) {if ( rc -> frames_till_gf_update_due == 0 ) {this_frame_copy = this_frame ;","TWO_PASS * const twopass = & cpi -> twopass ;GF_GROUP * const gf_group = & twopass -> gf_group ;int frames_left ;int target_rate ;LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : 0 ;if ( lc != NULL ) {frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ;frames_left = ( int ) ( twopass -> total_stats . count - cm -> current_video_frame ) ;}if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) {int target_rate ;configure_buffer_updates ( cpi ) ;target_rate = gf_group -> bit_allocation [ gf_group -> index ] ;target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ;rc -> base_frame_target = target_rate ;if ( lc != NULL ) {if ( cpi -> svc . spatial_layer_id == 0 ) {lc -> is_key_frame = 0 ;}else {lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ;if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ;if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) {cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ;}return ;}vpx_clear_system_state ( ) ;if ( cpi -> oxcf . rc_mode == VPX_Q ) {else if ( cm -> current_video_frame == 0 || ( lc != NULL && lc -> current_video_frame_in_layer == 0 ) ) {const double section_length = twopass -> total_left_stats . count ;const double section_error = twopass -> total_left_stats . coded_error / section_length ;const double section_intra_skip = twopass -> total_left_stats . intra_skip_pct / section_length ;const double section_inactive_zone = ( twopass -> total_left_stats . inactive_zone_rows * 2 ) / ( ( double ) cm -> mb_rows * section_length ) ;const int tmp_q = get_twopass_worst_quality ( cpi , section_error , section_intra_skip + section_inactive_zone , section_target_bandwidth , DEFAULT_GRP_WEIGHT ) ;twopass -> baseline_active_worst_quality = tmp_q ;rc -> last_q [ INTER_FRAME ] = tmp_q ;rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q , cm -> bit_depth ) ;rc -> avg_frame_qindex [ INTER_FRAME ] = tmp_q ;rc -> last_q [ KEY_FRAME ] = ( tmp_q + cpi -> oxcf . best_allowed_q ) / 2 ;rc -> avg_frame_qindex [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ;if ( this_frame . intra_skip_pct >= FC_ANIMATION_THRESH ) twopass -> fr_content_type = FC_GRAPHICS_ANIMATION ;else twopass -> fr_content_type = FC_NORMAL ;if ( rc -> frames_to_key == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) ) {FIRSTPASS_STATS this_frame_copy ;find_next_key_frame ( cpi , & this_frame ) ;this_frame = this_frame_copy ;}else {if ( lc != NULL ) {if ( cpi -> svc . spatial_layer_id == 0 ) {lc -> is_key_frame = ( cm -> frame_type == KEY_FRAME ) ;if ( lc -> is_key_frame ) {cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ;lc -> frames_from_key_frame = 0 ;cpi -> svc . encode_intra_empty_frame = 1 ;}lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ;if ( lc -> is_key_frame ) {cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ;lc -> frames_from_key_frame = 0 ;}}if ( rc -> frames_till_gf_update_due == 0 ) {define_gf_group ( cpi , & this_frame ) ;rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ;if ( lc != NULL ) cpi -> refresh_golden_frame = 1 ;# if ARF_STATS_OUTPUT {FILE * fpfile ;fpfile = fopen ( ""arf.stt"" , ""a"" ) ;++ arf_count ;fprintf ( fpfile , ""%10d<S2SV_blank>%10ld<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10ld\\\this_frame_copy = this_frame ;",3418
1388,buf = g_malloc ( size ) ;if ( object ) {,buf = g_malloc0 ( size ) ;if ( object ) {,3419
1389,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) {,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) # define GIFOutputCode ( code ) \\\\\,3420
1390,}IndexPacket index ;,\\\\\IndexPacket index ;,3420
1391,"
",next_pixel = MagickFalse ;displacement = 1 ;,3420
1392,index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;p ++ ;next_pixel = MagickFalse ;displacement = 1 ;,index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ;p ++ ;if ( k < 0 ) continue ;,3420
1393,"if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ;if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA )  && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ;switch ( ctxt -> mode ) {case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ;break ;case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ;break ;default : break ;}cs_sel = ( u16 ) msr_data ;cs_sel &= ~ SELECTOR_RPL_MASK ;ss_sel &= ~ SELECTOR_RPL_MASK ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) {cs . d = 0 ;ctxt -> _eip = msr_data ;ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ;* reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ;return X86EMUL_CONTINUE ;","if ( ctxt -> mode != X86EMUL_MODE_PROT64 ) && ( efer & EFER_LMA ) && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ;if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ;cs_sel = ( u16 ) msr_data ;cs_sel &= ~ SELECTOR_RPL_MASK ;ss_sel &= ~ SELECTOR_RPL_MASK ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) {cs . d = 0 ;ctxt -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) msr_data ;ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ;* reg_write ( ctxt , VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 ) msr_data ;return X86EMUL_CONTINUE ;",3421
1394,chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ;chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ;,chm -> index_root >= chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ;,3422
1395,"if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) {D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ;","if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) {D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ;",3422
1396,name = p ;READ_ENCINT ( section ) ;,if ( name_len == 0 ) goto chunk_end ;name = p ;READ_ENCINT ( section ) ;,3422
1397,return error ;},return error < 0 ? error : 0 ;},3423
1398,"static void  l2tp_bearer_cap_print ( netdissect_options * ndo , const u_char * dat )  {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_CAP_ANALOG_MASK ) {","static void l2tp_bearer_cap_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {const uint32_t * ptr = ( const uint32_t * ) dat ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_CAP_ANALOG_MASK ) {",3424
1399,int delta_munlocked ;struct pagevec pvec_putback ;,int delta_munlocked = - nr ;struct pagevec pvec_putback ;,3425
1400,"}pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ;delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ;__mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ;","}else {delta_munlocked ++ ;}pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ;__mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ;",3425
1401,return 0 ;},"return count_mounts ( m -> mnt_ns , child ) ;}",3426
1402,for ( x = 0 ;x += 2 )  {,for ( x = 0 ;x += 4 ) {,3427
1403,update_db_bp_intercept ( & svm -> vcpu ) ;},},3428
1404,"if ( srp -> bio )   blk_end_request_all ( srp -> rq , - EIO ) ;sg_finish_rem_req ( srp ) ;","if ( srp -> bio ) {if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ;blk_end_request_all ( srp -> rq , - EIO ) ;srp -> rq = NULL ;}sg_finish_rem_req ( srp ) ;",3429
1405,"fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.asoundrc<S2SV_blank>file\\\exit ( 1 ) ;pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( child == 0 ) {drop_privs ( 0 ) ;int rv = copy_file ( src , dest ) ;if ( rv )  fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\else {fs_logger2 ( ""clone"" , dest ) ;}","char * rp = realpath ( src , NULL ) ;if ( ! rp ) {fprintf ( stderr , ""Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\\exit ( 1 ) ;}if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) {fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\else {fs_logger2 ( ""clone"" , dest ) ;",3430
1406,"if ( ! php_var_unserialize ( & key , p , max , NULL TSRMLS_CC ) ) {zval_dtor ( key ) ;FREE_ZVAL ( key ) ;return 0 ;}if ( Z_TYPE_P ( key ) != IS_LONG && Z_TYPE_P ( key ) != IS_STRING ) {zval_dtor ( key ) ;FREE_ZVAL ( key ) ;return 0 ;}ALLOC_INIT_ZVAL ( data ) ;if ( ! php_var_unserialize ( & data , p , max , var_hash TSRMLS_CC ) ) {zval_dtor ( key ) ;FREE_ZVAL ( key ) ;zval_dtor ( data ) ;FREE_ZVAL ( data ) ;return 0 ;}if ( ! objprops ) {switch ( Z_TYPE_P ( key ) ) {case IS_LONG : if ( zend_hash_index_find ( ht , Z_LVAL_P ( key ) , ( void * * ) & old_data ) == SUCCESS ) {","if ( zend_hash_find ( ht , Z_LVAL_P ( key ) , ( void * * ) & old_data ) == SUCCESS ) {",3431
1407,"if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) {var_push_dtor ( var_hash , old_data ) ;","if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) {var_push_dtor ( var_hash , old_data ) ;",3431
1408,"rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;}","if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ;}",3432
1409,"if ( PageHuge ( page ) || PageTransHuge ( page ) ) copy_huge_page ( newpage , page ) ;else copy_highpage ( newpage , page ) ;if ( PageError ( page ) ) SetPageError ( newpage ) ;if ( PageReferenced ( page ) ) SetPageReferenced ( newpage ) ;if ( PageUptodate ( page ) ) SetPageUptodate ( newpage ) ;if ( TestClearPageActive ( page ) ) {VM_BUG_ON_PAGE ( PageUnevictable ( page ) , page ) ;SetPageActive ( newpage ) ;}else if ( TestClearPageUnevictable ( page ) ) SetPageUnevictable ( newpage ) ;if ( PageChecked ( page ) ) SetPageChecked ( newpage ) ;if ( PageMappedToDisk ( page ) ) SetPageMappedToDisk ( newpage ) ;if ( PageDirty ( page ) ) {clear_page_dirty_for_io ( page ) ;if ( PageSwapBacked ( page ) ) SetPageDirty ( newpage ) ;else  __set_page_dirty_nobuffers ( newpage ) ;",if ( PageHuge ( page ) || PageTransHuge ( page ) ) SetPageDirty ( newpage ) ;else __set_page_dirty_nobuffers ( newpage ) ;,3433
1410,mask -> matte = MagickFalse ;channel_image = mask ;},if ( mask != ( Image * ) NULL ) {mask -> matte = MagickFalse ;channel_image = mask ;}},3434
1411,"addresses = state -> endpoints ;while ( ( address = stok ( addresses , ""<S2SV_blank>\\\\t,"" , & tok ) ) != 0 ) {addresses = 0 ;","for ( addresses = sclone ( state -> endpoints ) ;( address = stok ( addresses , ""<S2SV_blank>\\\\t,"" , & tok ) ) != 0 ;addresses = tok ) {",3435
1412,"hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;","hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ;hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;",3436
1413,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,3437
1414,"align_get_bits ( gb ) ;if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) {","align_get_bits ( gb ) ;if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ;if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) {",3438
1415,"list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) {ctx -> chain = chain ;err = nft_delchain ( ctx ) ;if ( err < 0 ) goto out ;list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) {if ( set -> flags & NFT_SET_ANONYMOUS &&  ! list_empty ( & set -> bindings ) ) continue ;","list_for_each_entry ( chain , & ctx -> table -> chains , list ) {ctx -> chain = chain ;list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) {if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ;err = nft_delset ( ctx , set ) ;if ( err < 0 ) goto out ;}list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) {if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ;",3439
1416,f2fs_wait_discard_bios ( sbi ) ;out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ;,"f2fs_wait_discard_bios ( sbi , false ) ;out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ;",3440
1417,free_uid ( group -> inotify_data . user ) ;},atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;free_uid ( group -> inotify_data . user ) ;},3441
1418,return ( ( Image * ) NULL ) ;},break ;},3442
1419,"size_t bytes_per_line , extent ,  length ;ssize_t count , y ;","size_t bytes_per_line , extent , height , length ;ssize_t count , y ;",3443
1420,"sun_pixels = sun_data ;bytes_per_line = 0 ;if ( sun_info . type == RT_ENCODED ) {size_t height ;bytes_per_line += 15 ;( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line *  height ) ;}p = sun_pixels ;","if ( sun_info . type == RT_ENCODED ) bytes_per_line += 15 ;( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ;p = sun_pixels ;",3443
1421,"case SCSI_REQ_STATUS_RETRY_FLUSH :  ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ;if ( ret == 0 ) {",case SCSI_REQ_STATUS_RETRY_FLUSH : ret = scsi_disk_emulate_command ( r ) ;if ( ret == 0 ) {,3444
1422,u16 offset = sizeof ( struct ipv6hdr ) ;unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,unsigned int offset = sizeof ( struct ipv6hdr ) ;unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ;unsigned int len ;switch ( * * nexthdr ) {case NEXTHDR_HOP : break ;,3445
1423,offset += ipv6_optlen ( exthdr ) ;* nexthdr = & exthdr -> nexthdr ;,len = ipv6_optlen ( exthdr ) ;if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ;offset += len ;* nexthdr = & exthdr -> nexthdr ;,3445
1424,"mpeg4_decode_gop_header ( s , gb ) ;}else if ( startcode == VOS_STARTCODE ) {mpeg4_decode_profile_level ( s , gb ) ;if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&  ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) {s -> studio_profile = 1 ;}}","mpeg4_decode_gop_header ( s , gb , & profile , & level ) ;if ( profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) {s -> studio_profile = 1 ;}else if ( s -> studio_profile ) {av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\\return AVERROR_PATCHWELCOME ;}s -> avctx -> profile = profile ;s -> avctx -> level = level ;}",3446
1425,"if ( ! s -> avctx -> bits_per_raw_sample ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>VOL<S2SV_blank>header\\\","if ( ! s -> avctx -> bits_per_raw_sample ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>VOL<S2SV_blank>header\\\",3446
1426,char err_msg [ 64 ] ;D_imp_xxh ( sth ) ;,char * err_msg ;D_imp_xxh ( sth ) ;,3447
1427,"do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , ""Illegal<S2SV_blank>parameter<S2SV_blank>number"" , NULL ) ;return FALSE ;}if ( SvOK ( value ) && ( sql_type == SQL_NUMERIC || sql_type == SQL_DECIMAL || sql_type == SQL_INTEGER || sql_type == SQL_SMALLINT || sql_type == SQL_FLOAT || sql_type == SQL_REAL || sql_type == SQL_DOUBLE ) ) {if ( ! looks_like_number ( value ) ) {sprintf ( err_msg ,  ""Binding<S2SV_blank>non-numeric<S2SV_blank>field<S2SV_blank>%d,<S2SV_blank>value<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>a<S2SV_blank>numeric!"" ,  param_num , neatsvpv ( value , 0 ) ) ;do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , err_msg , NULL ) ;","err_msg = SvPVX ( sv_2mortal ( newSVpvf ( ""Binding<S2SV_blank>non-numeric<S2SV_blank>field<S2SV_blank>%d,<S2SV_blank>value<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>a<S2SV_blank>numeric!"" , param_num , neatsvpv ( value , 0 ) ) ) ) ;do_error ( sth , JW_ERR_ILLEGAL_PARAM_NUM , err_msg , NULL ) ;",3447
1428,if ( frame_end - frame < width + 3 )  return AVERROR_INVALIDDATA ;,if ( frame_end - frame < width + 4 ) return AVERROR_INVALIDDATA ;,3448
1429,int check_fragments_for_errors ( VP8D_COMP * pbi )  {,static int check_fragments_for_errors ( VP8D_COMP * pbi ) {,3449
1430,"for ( mask = pbi -> refresh_frame_flags ;if ( mask & 1 ) {const int old_idx = cm -> ref_frame_map [ ref_index ] ;ref_cnt_fb ( cm -> frame_bufs , & cm -> ref_frame_map [ ref_index ] ,   cm -> new_fb_idx ) ;if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 )  cm -> release_fb_cb ( cm -> cb_priv , & cm -> frame_bufs [ old_idx ] . raw_frame_buffer ) ;","BufferPool * const pool = cm -> buffer_pool ;RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ;lock_buffer_pool ( pool ) ;for ( mask = pbi -> refresh_frame_flags ;const int old_idx = cm -> ref_frame_map [ ref_index ] ;decrease_ref_count ( old_idx , frame_bufs , pool ) ;cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ;}unlock_buffer_pool ( pool ) ;pbi -> hold_ref_buf = 0 ;cm -> frame_to_show = get_frame_new_buffer ( cm ) ;if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) {lock_buffer_pool ( pool ) ;-- frame_bufs [ cm -> new_fb_idx ) ;if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 ) cm -> release_fb_cb ( cm -> cb_priv , & cm -> frame_bufs [ old_idx ] . raw_frame_buffer ) ;",3450
1431,ref_index ++ )  cm -> frame_refs [ ref_index ] . idx = INT_MAX ;},ref_index ++ ) cm -> frame_refs [ ref_index ] . idx = - 1 ;},3450
1432,"for ( s = 0 ;s < ns ;tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ;","for ( s = 0 ;s < ns && row < imagelength ;tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ;",3451
1433,return in ;},return NULL ;},3452
1434,"mutt_error ( ""%s"" , s + 3 ) ;}","mutt_error ( ""%s"" , s + 2 ) ;}",3453
1435,switch ( quantum_info -> depth )  {,pixel = 0 ;switch ( quantum_info -> depth ) {,3454
1436,"static void write_modes_sb ( VP9_COMP * cpi , const TileInfo * const tile ,  vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ,  int mi_row , int mi_col , BLOCK_SIZE bsize ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;const int bsl = b_width_log2 ( bsize ) ;const int bs = ( 1 << bsl ) / 4 ;MODE_INFO * m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;","static void write_modes_sb ( VP9_COMP * cpi , const TileInfo * const tile , vpx_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , int mi_row , int mi_col , BLOCK_SIZE bsize ) {const VP9_COMMON * const cm = & cpi -> td . common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;const int bsl = b_width_log2_lookup [ bsize ] ;const int bs = ( 1 << bsl ) / 4 ;const MODE_INFO * m = NULL ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ;",3455
1437,"safe_print ( value , valsz , NULL ) ;fputs ( ""\\\safe_print ( value , valsz , ""\\\\"""" ) ;fputs ( ""\\\\"""" , stdout ) ;","safe_print ( value , valsz , ""<S2SV_blank>\\\\\\\\\\\\""\\\'$`<>"" ) ;fputs ( ""\\\safe_print ( value , valsz , ""\\\\""\\\\\\\\"" ) ;fputs ( ""\\\\"""" , stdout ) ;",3456
1438,"
",if ( idx > 63 ) return AVERROR_INVALIDDATA ;,3457
1439,"j = scantable [ idx ++ ] ;block [ j ] = sign ? 1 : - 1 ;j = scantable [ idx ++ ] ;block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ;}j = scantable [ idx ++ ] ;","j = scantable [ idx ++ ] ;block [ j ] = sign ? 1 : - 1 ;if ( idx > 63 ) return AVERROR_INVALIDDATA ;j = scantable [ idx ++ ] ;block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ;}if ( idx > 63 ) return AVERROR_INVALIDDATA ;j = scantable [ idx ++ ] ;",3457
1440,"int i , pktsz , ret ;if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) {","int pktsz , ret ;if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) {",3458
1441,"dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\\i = 0x12345678 ;catc_write_mem ( catc , 0x7a80 , & i , 4 ) ;i = 0x87654321 ;catc_write_mem ( catc , 0xfa80 , & i , 4 ) ;catc_read_mem ( catc , 0x7a80 , & i , 4 ) ;switch ( i ) {case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ;","u32 * buf ;int i ;dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\\buf = kmalloc ( 4 , GFP_KERNEL ) ;if ( ! buf ) {ret = - ENOMEM ;goto fail_free ;}* buf = 0x12345678 ;catc_write_mem ( catc , 0x7a80 , buf , 4 ) ;i = 0x87654321 ;catc_write_mem ( catc , 0xfa80 , buf , 4 ) ;catc_read_mem ( catc , 0x7a80 , buf , 4 ) ;switch ( i ) {case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ;",3458
1442,"}dev_dbg ( dev , ""Getting<S2SV_blank>MAC<S2SV_blank>from<S2SV_blank>SEEROM.\\\","}kfree ( buf ) ;dev_dbg ( dev , ""Getting<S2SV_blank>MAC<S2SV_blank>from<S2SV_blank>SEEROM.\\\",3458
1443,"const unsigned char * old_name ;struct inode * source = old_dentry -> d_inode ;if ( source == target )  return 0 ;if ( ! target ) {error = may_create ( new_dir , new_dentry ) ;}else {new_is_dir = d_is_dir ( new_dentry ) ;if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ;else error = may_delete ( new_dir , new_dentry , new_is_dir ) ;}if ( error ) return error ;if ( ! old_dir -> i_op -> rename ) return - EPERM ;if ( new_dir != old_dir ) {if ( is_dir ) {error = inode_permission ( source , MAY_WRITE ) ;if ( error ) return error ;}if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) {error = inode_permission ( target , MAY_WRITE ) ;if ( error ) return error ;}}error = security_inode_rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ;if ( error ) return error ;old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ;dget ( new_dentry ) ;","struct inode * source = old_dentry -> d_inode ;struct name_snapshot old_name ;if ( source == target ) return 0 ;take_dentry_name_snapshot ( & old_name , old_dentry ) ;dget ( new_dentry ) ;",3459
1444,"fsnotify_move ( old_dir , new_dir , old_name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ;fsnotify_oldname_free ( old_name ) ;","fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ;release_dentry_name_snapshot ( & old_name ) ;",3459
1445,"if ( PageHuge ( page ) || PageTransHuge ( page ) ) copy_huge_page ( newpage , page ) ;else copy_highpage ( newpage , page ) ;if ( PageError ( page ) ) SetPageError ( newpage ) ;if ( PageReferenced ( page ) ) SetPageReferenced ( newpage ) ;if ( PageUptodate ( page ) ) SetPageUptodate ( newpage ) ;if ( TestClearPageActive ( page ) ) {VM_BUG_ON_PAGE ( PageUnevictable ( page ) , page ) ;SetPageActive ( newpage ) ;}else if ( TestClearPageUnevictable ( page ) ) SetPageUnevictable ( newpage ) ;if ( PageChecked ( page ) ) SetPageChecked ( newpage ) ;if ( PageMappedToDisk ( page ) ) SetPageMappedToDisk ( newpage ) ;if ( PageDirty ( page ) ) {clear_page_dirty_for_io ( page ) ;if ( PageSwapBacked ( page ) ) SetPageDirty ( newpage ) ;else  __set_page_dirty_nobuffers ( newpage ) ;",if ( PageHuge ( page ) || PageTransHuge ( page ) ) SetPageDirty ( newpage ) ;else __set_page_dirty_nobuffers ( newpage ) ;,3460
1446,"unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ;out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ;","init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ;out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ;",3461
1447,"struct user_element * ue = kcontrol -> private_data ;change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ;return change ;}","struct user_element * ue = kcontrol -> private_data ;mutex_lock ( & ue -> card -> user_ctl_lock ) ;change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ;mutex_unlock ( & ue -> card -> user_ctl_lock ) ;return change ;}",3462
1448,char * name ;unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = {0 };,char * name ;,3463
1449,"if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 )  ossl_raise ( eCipherError , NULL ) ;","if ( EVP_CipherInit_ex ( ctx , cipher , NULL , NULL , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;",3463
1450,"NICK_REC * list ;list = g_hash_table_lookup ( channel -> nicks , nick -> nick ) ;if ( list == nick || list -> next == NULL ) {g_hash_table_remove ( channel -> nicks , nick -> nick ) ;if ( list -> next != NULL ) {g_hash_table_insert ( channel -> nicks , nick -> next -> nick ,  nick -> next ) ;}while ( list -> next != nick ) list = list -> next ;}","NICK_REC * list , * newlist ;list = g_hash_table_lookup ( channel -> nicks , nick -> nick ) ;if ( list == nick ) {newlist = nick -> next -> nick , nick -> next ) ;}while ( list -> next != nick ) list = list -> next ;}",3464
1451,"jas_matrix_t * jas_seq2d_create ( int xstart , int ystart , int xend , int yend )  {","jas_matrix_t * jas_seq2d_create ( jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t yend ) {",3465
1452,"imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ;imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ;if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , ""Sending<S2SV_blank>LOGIN<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s...\\\","imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user , false ) ;imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass , false ) ;if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , ""Sending<S2SV_blank>LOGIN<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s...\\\",3466
1453,default :  assert ( 0 ) ;},"default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\\return ;}",3467
1454,"ut8 * buf = calloc ( to - from , 1 ) ;if ( ! buf || ! min ) {r_buf_read_at ( bf -> buf , from , buf , to - from ) ;while ( needle < to ) {","int len = to - from ;ut8 * buf = calloc ( len , 1 ) ;if ( ! buf || ! min ) {r_buf_read_at ( bf -> buf , from , buf , len ) ;while ( needle < to ) {",3468
1455,if ( ( to - needle ) > 5 ) {bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ;if ( is_wide32 ) {,if ( ( to - needle ) > 5 + rc ) {bool is_wide32 = ( needle + rc + 2 < to ) && ( ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ) ;if ( is_wide32 ) {,3468
1456,"static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;","static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ;",3469
1457,if ( ( int ) arg >= cdi -> capacity )  return - EINVAL ;,if ( arg >= cdi -> capacity ) return - EINVAL ;,3470
1458,"int bytes_returned , name_len ;__u16 params , byte_count ;","int bytes_returned ;unsigned int name_len ;__u16 params , byte_count ;",3471
1459,"
","size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;",3472
1460,params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,3472
1461,"pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE ,  ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%"" PRIsize ""<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)"" ,  sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , total_length , BT_SHB_INSANE_MAX ) ;","pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%"" PRIsize ""<S2SV_blank><<S2SV_blank>_%u_<S2SV_blank><<S2SV_blank>%u<S2SV_blank>(BT_SHB_INSANE_MAX)"" , sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , total_length , BT_SHB_INSANE_MAX ) ;",3473
1462,"if ( bee -> ui -> ft_in_start ) {return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ;","if ( bee -> ui -> ft_in_start && bu ) {return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ;",3474
1463,"strcpy ( cat_enum . szPath , fileName ) ;sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ;strcpy ( cat_enum . szRad1 , fileName ) ;}strcpy ( cat_enum . szRad1 , sep + 1 ) ;sep [ 0 ] = 0 ;}sep = strchr ( cat_enum . szRad1 , \'*\' ) ;strcpy ( cat_enum . szRad2 , sep + 1 ) ;sep [ 0 ] = 0 ;sep = strchr ( cat_enum . szRad2 , \'%\' ) ;if ( ! sep ) sep = strchr ( cat_enum . szRad2 , \'#\' ) ;if ( sep ) {strcpy ( cat_enum . szOpt , sep ) ;","if ( strlen ( fileName ) >= sizeof ( cat_enum . szPath ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szPath , fileName ) ;sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ;if ( strlen ( fileName ) >= sizeof ( cat_enum . szRad1 ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szRad1 , fileName ) ;}if ( strlen ( sep + 1 ) ;sep [ 0 ] = 0 ;}sep = strchr ( cat_enum . szRad1 , \'*\' ) ;strcpy ( cat_enum . szRad2 , sep + 1 ) >= sizeof ( cat_enum . szRad2 , \'%\' ) ;if ( ! sep ) sep = strchr ( cat_enum . szRad2 , \'#\' ) ;if ( sep ) {if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\\return GF_NOT_SUPPORTED ;}strcpy ( cat_enum . szOpt , sep ) ;}",3475
1464,"case LDP_TLV_COMMON_HELLO : TLV_TCHECK ( 4 ) ;ND_PRINT ( ( ndo , ""\\\break ;case LDP_TLV_IPV4_TRANSPORT_ADDR : TLV_TCHECK ( 4 ) ;ND_PRINT ( ( ndo , ""\\\break ;case LDP_TLV_IPV6_TRANSPORT_ADDR : TLV_TCHECK ( 16 ) ;ND_PRINT ( ( ndo , ""\\\break ;case LDP_TLV_CONFIG_SEQ_NUMBER : TLV_TCHECK ( 4 ) ;ND_PRINT ( ( ndo , ""\\\break ;case LDP_TLV_ADDRESS_LIST : TLV_TCHECK ( LDP_TLV_ADDRESS_LIST_AFNUM_LEN ) ;af = EXTRACT_16BITS ( tptr ) ;tptr += LDP_TLV_ADDRESS_LIST_AFNUM_LEN ;tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN ;ND_PRINT ( ( ndo , ""\\\switch ( af ) {case AFNUM_INET : while ( tlv_tlen >= sizeof ( struct in_addr ) ) {ND_TCHECK2 ( * tptr , sizeof ( struct in_addr ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ;tlv_tlen -= sizeof ( struct in_addr ) ;tptr += sizeof ( struct in_addr ) ;}break ;case AFNUM_INET6 : while ( tlv_tlen >= sizeof ( struct in6_addr ) ) {ND_TCHECK2 ( * tptr , sizeof ( struct in6_addr ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr ) ) ) ;tlv_tlen -= sizeof ( struct in6_addr ) ;tptr += sizeof ( struct in6_addr ) ;}break ;default : break ;}break ;case LDP_TLV_COMMON_SESSION : TLV_TCHECK ( 8 ) ;ND_PRINT ( ( ndo , ""\\\break ;case LDP_TLV_FEC : TLV_TCHECK ( 1 ) ;fec_type = * tptr ;ND_PRINT ( ( ndo , ""\\\tptr += 1 ;tlv_tlen -= 1 ;switch ( fec_type ) {case LDP_FEC_WILDCARD : break ;case LDP_FEC_PREFIX : TLV_TCHECK ( 2 ) ;af = EXTRACT_16BITS ( tptr ) ;tptr += LDP_TLV_ADDRESS_LIST_AFNUM_LEN ;tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN ;if ( af == AFNUM_INET ) {i = decode_prefix4 ( ndo , tptr , tlv_tlen , buf , sizeof ( buf ) ) ;if ( i == - 2 ) goto trunc ;if ( i == - 3 ) ND_PRINT ( ( ndo , "":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>TLV)"" ) ) ;else if ( i == - 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(invalid<S2SV_blank>length)"" ) ) ;else ND_PRINT ( ( ndo , "":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>%s"" , buf ) ) ;}else if ( af == AFNUM_INET6 ) {i = decode_prefix6 ( ndo , tptr , tlv_tlen , buf , sizeof ( buf ) ) ;if ( i == - 2 ) goto trunc ;if ( i == - 3 ) ND_PRINT ( ( ndo , "":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>TLV)"" ) ) ;else if ( i == - 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>IPv6<S2SV_blank>prefix<S2SV_blank>(invalid<S2SV_blank>length)"" ) ) ;else ND_PRINT ( ( ndo , "":<S2SV_blank>IPv6<S2SV_blank>prefix<S2SV_blank>%s"" , buf ) ) ;}else ND_PRINT ( ( ndo , "":<S2SV_blank>Address<S2SV_blank>family<S2SV_blank>%u<S2SV_blank>prefix"" , af ) ) ;break ;case LDP_FEC_HOSTADDRESS : break ;case LDP_FEC_MARTINI_VC : TLV_TCHECK ( 7 ) ;vc_info_len = * ( tptr + 2 ) ;if ( vc_info_len == 0 ) {ND_PRINT ( ( ndo , "":<S2SV_blank>%s,<S2SV_blank>%scontrol<S2SV_blank>word,<S2SV_blank>group-ID<S2SV_blank>%u,<S2SV_blank>VC-info-length:<S2SV_blank>%u"" , tok2str ( mpls_pw_types_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) & 0x7fff ) , EXTRACT_16BITS ( tptr ) & 0x8000 ? """" : ""no<S2SV_blank>"" , EXTRACT_32BITS ( tptr + 3 ) , vc_info_len ) ) ;break ;}TLV_TCHECK ( 11 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>%s,<S2SV_blank>%scontrol<S2SV_blank>word,<S2SV_blank>group-ID<S2SV_blank>%u,<S2SV_blank>VC-ID<S2SV_blank>%u,<S2SV_blank>VC-info-length:<S2SV_blank>%u"" , tok2str ( mpls_pw_types_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) & 0x7fff ) , EXTRACT_16BITS ( tptr ) & 0x8000 ? """" : ""no<S2SV_blank>"" , EXTRACT_32BITS ( tptr + 3 ) , EXTRACT_32BITS ( tptr + 7 ) , vc_info_len ) ) ;if ( vc_info_len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid,<S2SV_blank><<S2SV_blank>4"" ) ) ;return ( tlv_len + 4 ) ;}vc_info_len -= 4 ;tptr += 11 ;tlv_tlen -= 11 ;TLV_TCHECK ( vc_info_len ) ;while ( vc_info_len > 2 ) {vc_info_tlv_type = * tptr ;vc_info_tlv_len = * ( tptr + 1 ) ;if ( vc_info_tlv_len < 2 ) break ;if ( vc_info_len < vc_info_tlv_len ) break ;ND_PRINT ( ( ndo , ""\\\switch ( vc_info_tlv_type ) {case LDP_FEC_MARTINI_IFPARM_MTU : ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ;break ;case LDP_FEC_MARTINI_IFPARM_DESC : ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ;for ( idx = 2 ;idx < vc_info_tlv_len ;idx ++ ) safeputchar ( ndo , * ( tptr + idx ) ) ;break ;case LDP_FEC_MARTINI_IFPARM_VCCV : ND_PRINT ( ( ndo , ""\\\ND_PRINT ( ( ndo , ""\\\break ;default : print_unknown_data ( ndo , tptr + 2 , ""\\\break ;}vc_info_len -= vc_info_tlv_len ;tptr += vc_info_tlv_len ;}break ;}break ;case LDP_TLV_GENERIC_LABEL : TLV_TCHECK ( 4 ) ;ND_PRINT ( ( ndo , ""\\\break ;case LDP_TLV_STATUS : TLV_TCHECK ( 8 ) ;ui = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;ND_PRINT ( ( ndo , ""\\\ui = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;if ( ui ) ND_PRINT ( ( ndo , "",<S2SV_blank>causing<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x"" , ui ) ) ;break ;case LDP_TLV_FT_SESSION :  TLV_TCHECK ( 8 ) ;ft_flags = EXTRACT_16BITS ( tptr ) ;",case LDP_TLV_COMMON_HELLO : TLV_TCHECK ( 12 ) ;ft_flags = EXTRACT_16BITS ( tptr ) ;,3476
1465,"trunc :  ND_PRINT ( ( ndo , ""\\\return 0 ;","trunc : ND_PRINT ( ( ndo , ""\\\return 0 ;",3476
1466,"hrtimer_cancel ( & stime -> hrt ) ;hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ;","hrtimer_try_to_cancel ( & stime -> hrt ) ;hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ;",3477
1467,"const unsigned char * old_name ;struct inode * source = old_dentry -> d_inode ;if ( source == target )  return 0 ;if ( ! target ) {error = may_create ( new_dir , new_dentry ) ;}else {new_is_dir = d_is_dir ( new_dentry ) ;if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ;else error = may_delete ( new_dir , new_dentry , new_is_dir ) ;}if ( error ) return error ;if ( ! old_dir -> i_op -> rename ) return - EPERM ;if ( new_dir != old_dir ) {if ( is_dir ) {error = inode_permission ( source , MAY_WRITE ) ;if ( error ) return error ;}if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) {error = inode_permission ( target , MAY_WRITE ) ;if ( error ) return error ;}}error = security_inode_rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ;if ( error ) return error ;old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ;dget ( new_dentry ) ;","struct inode * source = old_dentry -> d_inode ;struct name_snapshot old_name ;if ( source == target ) return 0 ;take_dentry_name_snapshot ( & old_name , old_dentry ) ;dget ( new_dentry ) ;",3478
1468,"fsnotify_move ( old_dir , new_dir , old_name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ;fsnotify_oldname_free ( old_name ) ;","fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ;release_dentry_name_snapshot ( & old_name ) ;",3478
1469,"return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ;}","struct dm_dev * dev = fc -> dev ;int r = 0 ;if ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ;}",3479
1470,"# endif _end :  snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ;}","# endif _end : kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ;snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;}",3480
1471,"void bpf_map_inc ( struct bpf_map * map , bool uref )  {atomic_inc ( & map -> refcnt ) ;if ( uref ) atomic_inc ( & map -> usercnt ) ;}","struct bpf_map * bpf_map_inc ( struct bpf_map * map , bool uref ) {if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) {atomic_dec ( & map -> refcnt ) ;return ERR_PTR ( - EBUSY ) ;}if ( uref ) atomic_inc ( & map -> usercnt ) ;return map ;}",3481
1472,"struct pstore * ps = get_info ( store ) ;uint32_t stride ;chunk_t next_free ;stride = ( ps -> exceptions_per_area + 1 ) ;next_free = ++ ps -> next_free ;if ( sector_div ( next_free , stride ) == 1 )  ps -> next_free ++ ;atomic_inc ( & ps -> pending_count ) ;","struct pstore * ps = get_info ( store ) ;ps -> next_free ;if ( sector_div ( next_free , stride ) == 1 ) ps -> next_free ++ ;skip_metadata ( ps ) ;atomic_inc ( & ps -> pending_count ) ;",3482
1473,"vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;dest_ptr1 += plane_stride ;","memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;dest_ptr1 += plane_stride ;",3483
1474,"vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;dest_ptr1 += plane_stride ;vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;dest_ptr1 += plane_stride ;","memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;dest_ptr1 += plane_stride ;memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ;dest_ptr1 += plane_stride ;",3483
1475,"return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) ,  RTL8150_REQ_GET_REGS , RTL8150_REQT_READ ,  indx , 0 , data , size , 500 ) ;}","void * buf ;int ret ;buf = kmalloc ( size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , RTL8150_REQ_GET_REGS , RTL8150_REQT_READ , indx , 0 , buf , size , 500 ) ;if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ;kfree ( buf ) ;return ret ;}",3484
1476,"static int decode_term_subexp ( vp9_reader * r ) {if ( ! vp9_read_bit ( r ) )   return vp9_read_literal ( r , 4 ) ;if ( ! vp9_read_bit ( r ) )   return vp9_read_literal ( r , 4 ) + 16 ;if ( ! vp9_read_bit ( r ) )   return vp9_read_literal ( r , 5 ) + 32 ;return decode_uniform ( r ) + 64 ;","static int decode_term_subexp ( vpx_reader * r ) {if ( ! vpx_read_bit ( r ) ) return vp9_read_literal ( r , 4 ) ;if ( ! vp9_read_bit ( r ) ) return vpx_read_literal ( r , 4 ) + 16 ;if ( ! vpx_read_bit ( r ) ) return vp9_read_literal ( r , 5 ) + 32 ;return decode_uniform ( r ) + 64 ;",3485
1477,int best_filt_val = cm -> filter_level ;YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ;,int best_filt_val ;YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ;,3486
1478,"vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;","yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;",3486
1479,"vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;","yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ;vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ;",3486
1480,goto out ;}if ( unlikely ( error ) ) goto out ;,goto out2 ;}out2 : if ( unlikely ( error ) ) goto out ;,3487
1481,if ( ! ( opened & FILE_OPENED ) ) {BUG_ON ( ! error ) ;,if ( ! ( opened & FILE_OPENED ) ) {BUG_ON ( ! error ) ;,3487
1482,value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ;return ( ( unsigned short ) ( value & 0xffff ) ) ;}value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) |  ( ( unsigned char * ) buffer ) [ 1 ] ) ;return ( ( unsigned short ) ( value & 0xffff ) ) ;},value = ( unsigned short ) buffer [ 1 ] << 8 ) | buffer [ 0 ] ;return ( ( unsigned short ) ( value & 0xffff ) ) ;}value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | ( ( unsigned char * ) buffer ) [ 1 ] ) ;return ( value & 0xffff ) ;},3488
1483,"if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) {res = M_fs_delete ( path_new , M_FALSE , NULL , M_FS_PROGRESS_NOEXTRA ) ;if ( res != M_FS_ERROR_SUCCESS ) {return res ;}}","
",3489
1484,static int stv06xx_isoc_init ( struct gspca_dev * gspca_dev )  {struct usb_host_interface * alt ;alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ;alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( sd -> sensor -> max_packet_size [ gspca_dev -> curr_mode ] ) ;,static int stv06xx_isoc_init ( struct gspca_dev * gspca_dev ) {struct usb_interface_cache * intfc ;struct usb_host_interface * alt ;intfc = gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] ;if ( intfc -> num_altsetting < 2 ) return - ENODEV ;alt = & intfc -> altsetting [ 1 ] ;if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( sd -> sensor -> max_packet_size [ gspca_dev -> curr_mode ] ) ;,3490
1485,if ( ! is_launcher )  {if ( nautilus_file_can_execute ( file ) )  {,"g_autofree gchar * trusted = NULL ;if ( ! is_launcher ) {trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ;if ( nautilus_file_can_execute ( file ) && trusted != NULL ) {",3491
1486,"# define ThrowDCMException ( exception , message ) {}char explicit_vr [ MaxTextExtent ] , implicit_vr [ MaxTextExtent ] , magick [ MaxTextExtent ] , photometric [ MaxTextExtent ] ;","# define ThrowDCMException ( exception , message ) \\\\\\\\\\char explicit_vr [ MaxTextExtent ] , implicit_vr [ MaxTextExtent ] , magick [ MaxTextExtent ] , photometric [ MaxTextExtent ] ;",3492
1487,"if ( length > GetBlobSize ( image ) )  ThrowReaderException ( CorruptImageError ,  ""InsufficientImageDataInFile"" ) ;","if ( length > GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",3492
1488,"if ( ! copy_from_iter_full ( kbuf , len , from ) )   return - EFAULT ;ret = qrtr_endpoint_post ( & tun -> ep , kbuf , len ) ;return ret < 0 ? ret : len ;}","if ( ! copy_from_iter_full ( kbuf , len , from ) ) {kfree ( kbuf ) ;return - EFAULT ;}ret = qrtr_endpoint_post ( & tun -> ep , kbuf , len ) ;kfree ( kbuf ) ;return ret < 0 ? ret : len ;}",3493
1489,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,3494
1490,"rfbBool ReadFromRFBServer ( rfbClient * client , char * out , unsigned int n )  {# undef DEBUG_READ_EXACT # ifdef DEBUG_READ_EXACT char * oout = out ;","rfbBool ReadFromRFBServer ( rfbClient * client , char * out , unsigned int n ) {const int USECS_WAIT_PER_RETRY = 100000 ;int retries = 0 ;# undef DEBUG_READ_EXACT # ifdef DEBUG_READ_EXACT char * oout = out ;",3495
1491,"if ( client -> tlsSession ) i = ReadFromTLS ( client , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ;else # ifdef LIBVNCSERVER_HAVE_SASL if ( client -> saslconn ) i = ReadFromSASL ( client , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ;else {# endif i = read ( client -> sock , client -> buf + client -> buffered , RFB_BUF_SIZE - client -> buffered ) ;# ifdef WIN32 if ( i < 0 ) errno = WSAGetLastError ( ) ;# endif # ifdef LIBVNCSERVER_HAVE_SASL }# endif if ( i <= 0 ) {if ( i < 0 ) {if ( errno == EWOULDBLOCK || errno == EAGAIN ) {WaitForMessage ( client , 100000 ) ;i = 0 ;","if ( client -> tlsSession ) i = ReadFromTLS ( client , USECS_WAIT_PER_RETRY ) ;i = 0 ;",3495
1492,"WaitForMessage ( client , 100000 ) ;i = 0 ;","if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) {rfbClientLog ( ""Connection<S2SV_blank>timed<S2SV_blank>out\\\return FALSE ;}WaitForMessage ( client , USECS_WAIT_PER_RETRY ) ;i = 0 ;",3495
1493,"
",if ( total_subobj_len < 4 ) goto invalid ;,3496
1494,subobj_len = EXTRACT_16BITS ( obj_tptr ) ;subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ;if ( subobj_len == 0 )  goto invalid ;,subobj_len = EXTRACT_16BITS ( obj_tptr ) ;subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ;if ( subobj_len < 4 || subobj_len > total_subobj_len ) goto invalid ;,3496
1495,"if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 )  isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;else  isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ;break ;","if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 ) ;else isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ;break ;",3497
1496,"xdr_free ( xdr_func , xdr_ptr ) ;XDR_DESTROY ( & temp_xdrs ) ;","xdr_free ( xdr_func , xdr_ptr ) ;XDR_DESTROY ( & temp_xdrs ) ;",3498
1497,"if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) {c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ;aligned_height = FFALIGN ( c -> height , 16 ) ;av_free ( c -> framebuf ) ;","if ( ! c -> framebuf || c -> old_width < c -> width + 15 , 16 ) ;aligned_height = FFALIGN ( c -> height , 16 ) ;av_free ( c -> framebuf ) ;",3499
1498,"while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX )  && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) )  {","while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) && ( ps_dec -> s_bit_stream . u4_offset < ps_dec -> s_bit_stream . u4_max_offset ) ) {",3500
1499,"error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error < 0 ) return error ;if ( mode != inode -> i_mode ) {inode -> i_mode = mode ;mark_inode_dirty ( inode ) ;}}","error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ;if ( error ) return error ;if ( error < 0 ) return error ;if ( mode != inode -> i_mode ) mark_inode_dirty ( inode ) ;}}",3501
1500,"SDev = cd -> device ;retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) {result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen ,  ( unsigned char * ) cgc -> sense , & sshdr ,  cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ;","unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ;SDev = cd -> device ;if ( cgc -> sense ) senseptr = sense_buffer ;retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) {result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ;if ( cgc -> sense ) ) ;",3502
1501,# endif  log_flush ( LOG_MODE_ERROR ) ;log_close ( SINK_SYSLOG | SINK_OUTFILE ) ;,# endif log_flush ( LOG_MODE_BUFFER ) ;log_close ( SINK_SYSLOG | SINK_OUTFILE ) ;,3503
1502,}else {,ps_dec -> u4_first_slice_in_pic = 0 ;}else {,3504
1503,"
",},3504
1504,ps_dec -> u2_cur_slice_num ++ ;if ( ps_dec -> u4_first_slice_in_pic != 0 )  ps_dec -> ps_parse_cur_slice ++ ;,if ( ps_dec -> u4_first_slice_in_pic != 0 ) {ps_dec -> ps_parse_cur_slice ++ ;ps_dec -> u2_cur_slice_num ++ ;if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ;,3504
1505,"if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) )  return 0 ;ext_block = ( struct grub_ext4_extent_header * ) buf ;","if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) ) {return 0 ;}ext_block = ( struct grub_ext4_extent_header * ) buf ;",3505
1506,if ( ! vct_iscrlf ( * p ) ) {for ( ;! vct_iscrlf ( * p ) ;p ++ )  if ( ! vct_issep ( * p ) && vct_isctl ( * p ) ) return ( 400 ) ;,if ( ! vct_iscrlf ( p ) ) {for ( ;! vct_iscrlf ( p ) ;p ++ ) if ( ! vct_issep ( * p ) && vct_isctl ( * p ) ) return ( 400 ) ;,3506
1507,"while ( ( c = ReadBlobByte ( image ) ) != EOF )  ( void ) fputc ( c , file ) ;( void ) fclose ( file ) ;","while ( ( c = ReadBlobByte ( image ) ) != EOF ) if ( fputc ( c , file ) != c ) break ;( void ) fclose ( file ) ;",3507
1508,lua_newtable ( L ) ;while ( len -- ) {,"lua_newtable ( L ) ;luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"" ) ;while ( len -- ) {",3508
1509,if ( tcp -> csty & J2K_CP_CSTY_SOP ) {c [ 0 ] = 255 ;,"if ( tcp -> csty & J2K_CP_CSTY_SOP ) {if ( length < 6 ) {if ( p_t2_mode == FINAL_PASS ) {opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\\}return OPJ_FALSE ;}c [ 0 ] = 255 ;",3509
1510,if ( tcp -> csty & J2K_CP_CSTY_EPH ) {c [ 0 ] = 255 ;,"if ( tcp -> csty & J2K_CP_CSTY_EPH ) {if ( length < 2 ) {if ( p_t2_mode == FINAL_PASS ) {opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\\}return OPJ_FALSE ;}c [ 0 ] = 255 ;",3509
1511,"( void ) data ;vp8_rtcd ( ) ;if ( ! ctx -> priv )  {vpx_codec_mmap_t mmap ;mmap . id = vp8_mem_req_segs [ 0 ] . id ;mmap . sz = sizeof ( vpx_codec_alg_priv_t ) ;mmap . align = vp8_mem_req_segs [ 0 ] . align ;mmap . flags = vp8_mem_req_segs [ 0 ] . flags ;res = vpx_mmap_alloc ( & mmap ) ;if ( res != VPX_CODEC_OK ) return res ;vp8_init_ctx ( ctx , & mmap ) ;ctx -> priv -> alg_priv -> fragments . count = 0 ;ctx -> priv -> alg_priv -> fragments . enabled =   ( ctx -> priv -> alg_priv -> base . init_flags &  VPX_CODEC_USE_INPUT_FRAGMENTS ) ;ctx -> priv -> alg_priv -> defer_alloc = 1 ;}ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads =  ( ctx -> priv -> alg_priv -> base . init_flags &  VPX_CODEC_USE_FRAME_THREADING ) ;ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads = 0 ;if ( ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads &&   ( ( ctx -> priv -> alg_priv -> base . init_flags &   VPX_CODEC_USE_ERROR_CONCEALMENT )   || ( ctx -> priv -> alg_priv -> base . init_flags &  VPX_CODEC_USE_INPUT_FRAGMENTS ) ) ) {","vpx_codec_alg_priv_t * priv = NULL ;( void ) data ;vp8_rtcd ( ) ;vpx_dsp_rtcd ( ) ;vpx_scale_rtcd ( ) ;if ( ! ctx -> priv ) {vp8_init_ctx ( ctx , & mmap ) ;ctx -> priv -> alg_priv -> fragments . count = 0 ;ctx -> priv -> alg_priv -> fragments . enabled = ( ctx -> priv -> alg_priv -> base . init_flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) ;ctx -> priv -> alg_priv -> defer_alloc = 1 ;}ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads = ( ctx -> priv ;}priv -> yv12_frame_buffers . use_frame_threads = 0 ;if ( ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads && ( ( ctx -> priv -> init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) || ( ctx -> priv -> init_flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) ) ) {",3510
1512,struct inode * inode = file_inode ( bprm -> file ) ;umode_t mode = inode -> i_mode ;bprm -> cred -> euid = current_euid ( ) ;bprm -> cred -> egid = current_egid ( ) ;,bprm -> cred -> euid = current_euid ( ) ;bprm -> cred -> egid = current_egid ( ) ;,3511
1513,if ( ! ok ) return ( ( int ) n ) ;if ( s -> session -> peer != NULL ) {,if ( peer != NULL ) {,3512
1514,if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) )  {,if ( ( peer != NULL ) {,3512
1515,"static vpx_codec_err_t set_encoder_config (  VP9_CONFIG * oxcf ,  const vpx_codec_enc_cfg_t * cfg , const struct vp9_extracfg * extra_cfg ) {oxcf -> profile = cfg -> g_profile ;oxcf -> width = cfg -> g_w ;oxcf -> height = cfg -> g_h ;oxcf -> bit_depth = extra_cfg -> bit_depth ;oxcf -> framerate = ( double ) cfg -> g_timebase . den / cfg -> g_timebase . num ;if ( oxcf -> framerate > 180 )   oxcf -> framerate = 30 ;switch ( cfg -> g_pass ) {case VPX_RC_ONE_PASS :  oxcf -> mode = MODE_GOODQUALITY ;break ;case VPX_RC_FIRST_PASS :  oxcf -> mode = MODE_FIRSTPASS ;break ;case VPX_RC_LAST_PASS :  oxcf -> mode = MODE_SECONDPASS_BEST ;break ;oxcf -> end_usage = USAGE_LOCAL_FILE_PLAYBACK ;if ( cfg -> rc_end_usage == VPX_CQ )  oxcf -> end_usage = USAGE_CONSTRAINED_QUALITY ;else if ( cfg -> rc_end_usage == VPX_Q ) oxcf -> end_usage = USAGE_CONSTANT_QUALITY ;else if ( cfg -> rc_end_usage == VPX_CBR ) oxcf -> end_usage = USAGE_STREAM_FROM_SERVER ;oxcf -> target_bandwidth = cfg -> rc_target_bitrate ;oxcf -> rc_max_intra_bitrate_pct = extra_cfg -> rc_max_intra_bitrate_pct ;oxcf -> best_allowed_q = q_trans [ cfg -> rc_min_quantizer ] ;oxcf -> worst_allowed_q = q_trans [ cfg -> rc_max_quantizer ] ;oxcf -> cq_level = q_trans [ extra_cfg -> cq_level ] ;oxcf -> fixed_q = - 1 ;oxcf -> under_shoot_pct = cfg -> rc_undershoot_pct ;oxcf -> over_shoot_pct = cfg -> rc_overshoot_pct ;oxcf -> maximum_buffer_size = cfg -> rc_buf_sz ;oxcf -> starting_buffer_level = cfg -> rc_buf_initial_sz ;oxcf -> optimal_buffer_level = cfg -> rc_buf_optimal_sz ;oxcf -> drop_frames_water_mark = cfg -> rc_dropframe_thresh ;oxcf -> two_pass_vbrbias = cfg -> rc_2pass_vbr_bias_pct ;oxcf -> two_pass_vbrmin_section = cfg -> rc_2pass_vbr_minsection_pct ;oxcf -> two_pass_vbrmax_section = cfg -> rc_2pass_vbr_maxsection_pct ;oxcf -> auto_key = cfg -> kf_mode == VPX_KF_AUTO && cfg -> kf_min_dist != cfg -> kf_max_dist ;oxcf -> key_freq = cfg -> kf_max_dist ;oxcf -> cpu_used = extra_cfg -> cpu_used ;oxcf -> encode_breakout = extra_cfg -> static_thresh ;oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ;oxcf -> noise_sensitivity = extra_cfg -> noise_sensitivity ;oxcf -> output_pkt_list = extra_cfg -> pkt_list ;oxcf -> arnr_max_frames = extra_cfg -> arnr_max_frames ;oxcf -> arnr_strength = extra_cfg -> arnr_strength ;oxcf -> arnr_type = extra_cfg -> arnr_type ;oxcf -> tuning = extra_cfg -> tuning ;oxcf -> tile_columns = extra_cfg -> tile_columns ;oxcf -> tile_rows = extra_cfg -> tile_rows ;oxcf -> lossless = extra_cfg -> lossless ;oxcf -> error_resilient_mode = cfg -> g_error_resilient ;oxcf -> ss_number_layers = cfg -> ss_number_layers ;if ( oxcf -> ss_number_layers > 1 ) {vp9_copy ( oxcf -> ss_target_bitrate , cfg -> ss_target_bitrate ) ;}else if ( oxcf -> ss_number_layers == 1 ) {oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ;oxcf -> ts_number_layers = cfg -> ts_number_layers ;if ( oxcf -> ts_number_layers > 1 ) {vp9_copy ( oxcf -> ts_target_bitrate , cfg -> ts_target_bitrate ) ;vp9_copy ( oxcf -> ts_rate_decimator , cfg -> ts_rate_decimator ) ;oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ;oxcf -> ts_rate_decimator [ 0 ] = 1 ;","static vpx_codec_err_t set_encoder_config ( VP9EncoderConfig * oxcf , const vpx_codec_enc_cfg_t * cfg , const struct vp9_extracfg * extra_cfg ) {const int is_vbr = cfg -> rc_end_usage == VPX_VBR ;int sl , tl ;oxcf -> max_threads = ( int ) cfg -> g_threads ;oxcf -> profile = cfg -> g_profile ;oxcf -> width = cfg -> g_w ;oxcf -> height = cfg -> g_h ;oxcf -> bit_depth = cfg -> g_bit_depth ;oxcf -> input_bit_depth = cfg -> g_input_bit_depth ;oxcf -> init_framerate = ( double ) cfg -> g_timebase . den / cfg -> g_timebase . num ;if ( oxcf -> init_framerate > 180 ) oxcf -> framerate = 30 ;switch ( cfg -> g_pass ) {case VPX_RC_ONE_PASS : oxcf -> pass = 0 ;break ;case VPX_RC_FIRST_PASS : oxcf -> pass = 1 ;break ;case VPX_RC_LAST_PASS : oxcf -> pass = 2 ;break ;oxcf -> rc_mode = cfg -> rc_end_usage == VPX_CQ ) oxcf -> end_usage = USAGE_CONSTRAINED_QUALITY ;else if ( cfg -> rc_end_usage ;oxcf -> target_bandwidth = 1000 * cfg -> rc_target_bitrate ;oxcf -> rc_max_intra_bitrate_pct = extra_cfg -> rc_max_intra_bitrate_pct ;oxcf -> best_allowed_q = q_trans [ cfg -> rc_min_quantizer ] ;oxcf -> worst_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( cfg -> rc_max_quantizer ) ;oxcf -> cq_level = q_trans [ extra_cfg -> cq_level ) ;oxcf -> fixed_q = - 1 ;oxcf -> scaled_frame_width = cfg -> rc_scaled_width ;oxcf -> scaled_frame_height = cfg -> rc_scaled_height ;if ( cfg -> rc_resize_allowed == 1 ) {oxcf -> resize_mode = ( oxcf -> scaled_frame_width == 0 || oxcf -> scaled_frame_height == 0 ) ? RESIZE_DYNAMIC : RESIZE_FIXED ;}else {oxcf -> resize_mode = RESIZE_NONE ;}oxcf -> maximum_buffer_size_ms = is_vbr ? 240000 : cfg -> rc_buf_sz ;oxcf -> starting_buffer_level_ms = is_vbr ? 60000 : cfg -> rc_buf_initial_sz ;oxcf -> optimal_buffer_level_ms = is_vbr ? 60000 : cfg -> rc_buf_optimal_sz ;oxcf -> speed = abs ( extra_cfg -> cpu_used ) ;oxcf -> enable_auto_arf = extra_cfg -> cpu_used ;oxcf -> encode_breakout = extra_cfg -> static_thresh ;oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ;oxcf -> noise_sensitivity = extra_cfg -> noise_sensitivity ;oxcf -> output_pkt_list = extra_cfg -> pkt_list ;oxcf -> arnr_max_frames = extra_cfg -> arnr_max_frames ;oxcf -> min_gf_interval = extra_cfg -> min_gf_interval ;oxcf -> content = extra_cfg -> content ;oxcf -> error_resilient_mode = cfg -> g_error_resilient ;oxcf -> ss_number_layers == 1 && oxcf -> pass != 0 ) {oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ;# if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ 0 ] = extra_cfg -> enable_auto_alt_ref ;# endif }if ( oxcf -> ts_number_layers = cfg -> ss_number_layers ;if ( oxcf -> ss_number_layers > 1 ) {for ( tl = 0 ;tl < VPX_TS_MAX_LAYERS ;++ tl ) {oxcf -> ts_rate_decimator [ tl ] = cfg -> ts_rate_decimator [ tl ] ? cfg -> ts_rate_decimator [ tl ] : 1 ;oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ;oxcf -> ts_rate_decimator [ 0 ] = 1 ;",3513
1516,"int ret ;ret = usb_control_msg ( pegasus -> usb , usb_rcvctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_GET_REGS , PEGASUS_REQT_READ , 0 ,  indx , data , size , 1000 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\return ret ;}","u8 * buf ;int ret ;buf = kmalloc ( size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( pegasus -> usb , usb_rcvctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_GET_REGS , PEGASUS_REQT_READ , 0 , indx , buf , size , 1000 ) ;if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\\else if ( ret <= size ) memcpy ( data , buf , ret ) ;kfree ( buf ) ;return ret ;}",3514
1517,if ( ! saw_digit )   goto invalid ;break ;,if ( ! saw_digit ) {bp ++ ;goto invalid ;}break ;,3515
1518,if ( * bp != '\\\\r' )   goto invalid ;bp ++ ;if ( * bp != '\\\bp ++ ;,if ( * bp != '\\\\r' ) {bp ++ ;goto invalid ;}bp ++ ;if ( * bp != '\\\bp ++ ;goto invalid ;}bp ++ ;,3515
1519,trunc :  return ( - 2 ) ;invalid :  return ( - 5 ) ;},trunc : * endp = bp ;return ( - 2 ) ;invalid : * endp = bp ;return ( - 5 ) ;},3515
1520,len = dp -> ip6r_len ;ep = ndo -> ndo_snapend ;,ep = ndo -> ndo_snapend ;len = dp -> ip6r_len ;,3516
1521,"size_t cnt = 0 ;do {if ( ( ( ( ! __libc_enable_secure   && strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 )  || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == \'\\\\0\' || name [ len ] == \'/\' || ( is_path && name [ len ] == \':\' ) ) ) || ( name [ 1 ] == \'{\' && ( ( ! __libc_enable_secure  && strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 )  || ( strncmp ( & name [ 2 ] , ""PLATFORM}","const char * const start = name ;size_t cnt = 0 ;do {if ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( ! __libc_enable_secure || ( ( name [ 7 ] == \'\\\\0\' || ( is_path && name [ 7 ] == \':\' ) ) && ( name == start || ( is_path && name [ - 1 ] == \':\' ) ) ) ) && ( len = 7 ) != 0 ) || ( strncmp ( & name [ 1 ] , ""PLATFORM}"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == \'\\\\0\' || name [ len ] == \'/\' || ( is_path && name [ len ] == \':\' ) ) ) || ( name [ 1 ] == \'{\' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( ! __libc_enable_secure && strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) || ( strncmp ( & name [ 2 ] , ""PLATFORM}",3517
1522,"retval = generic_gss_oid_decompose ( minor_status ,  GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ;","if ( ctx -> terminated || ! ctx -> established ) {* minor_status = KG_CTX_INCOMPLETE ;return GSS_S_NO_CONTEXT ;}retval = generic_gss_oid_decompose ( minor_status , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ;",3518
1523,eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) |  ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ;if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ;,eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) | ( 1u << AC_VECTOR ) ;if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ;,3519
1524,"file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ;if ( ! file ) return - ENOMEM ;","file = kzalloc ( sizeof ( * file ) , GFP_NOIO ) ;if ( ! file ) return - ENOMEM ;",3520
1525,"tags = stok ( sclone ( tags ) , ""<S2SV_blank>"" , NULL ) ;}","tags = ssplit ( sclone ( tags ) , ""<S2SV_blank>"" , NULL ) ;}",3521
1526,if ( include_level > 10 ) {,if ( ( len > 12 ) && include_level > 10 ) {,3522
1527,"if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) {do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ;# if ! defined ( NO_POPEN )  }else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) {do_ssi_exec ( conn , buf + 9 ) ;","if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) {do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ;# if ! defined ( NO_POPEN ) }else if ( ( len > 9 ) && ! memcmp ( buf + 5 , ""exec"" , 4 ) ) {do_ssi_exec ( conn , buf + 9 ) ;",3522
1528,}i = 0 ;,i = 0 ;,3523
1529,keymap -> num_key_aliases = num_key_aliases ;keymap -> key_aliases = key_aliases ;,}keymap -> num_key_aliases = num_key_aliases ;keymap -> key_aliases = key_aliases ;,3523
1530,"int nalloca ;struct globval * firstmalloc , * tmplink ;","int hasglob ;int nalloca ;struct globval * firstmalloc , * tmplink ;",3524
1531,patlen = ( pat && * pat ) ? strlen ( pat ) : 0 ;if ( skip == 0 && glob_pattern_p ( pat ) == 0 )  {,patlen = ( pat && * pat ) ? strlen ( pat ) ) == 0 || hasglob == 2 ) {,3524
1532,if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) )  return FALSE ;if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) )  return FALSE ;,if ( * dp != ( csum & 0xff ) || dp [ 1 ] != ( ( csum >> 8 ) & 0xff ) || dp [ 2 ] != ( ( csum >> 16 ) & 0xff ) || dp [ 3 ] != ( ( csum >> 24 ) & 0xff ) ) return FALSE ;if ( * dp != ( csum & 0xff ) || dp [ 1 ] != ( ( csum >> 8 ) & 0xff ) ) return FALSE ;,3525
1533,"# ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds ,  & dec_tables ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds ,  & dec_tables ) ;# else return do_decrypt_fn ( ctx , bx , ax ) ;","# ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , dec_tables . T ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , dec_tables . T ) ;# else return do_decrypt_fn ( ctx , bx , ax ) ;",3526
1534,"int32_t DownmixLib_Create ( const effect_uuid_t * uuid ,  int32_t sessionId ,   int32_t ioId ,  effect_handle_t * pHandle ) {","int32_t DownmixLib_Create ( const effect_uuid_t * uuid , int32_t sessionId __unused , int32_t ioId __unused , effect_handle_t * pHandle ) {",3527
1535,"skb = xchg ( & np -> pktoptions , NULL ) ;opt = xchg ( & np -> opt , NULL ) ;if ( opt )   sock_kfree_s ( sk , opt , opt -> tot_len ) ;}","skb = xchg ( ( __force struct ipv6_txoptions * * ) & np -> pktoptions , NULL ) ;opt = xchg ( & np -> opt , NULL ) ;if ( opt ) {atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ;txopt_put ( opt ) ;}}",3528
1536,dec -> xstart = siz -> xoff ;dec -> ystart = siz -> yoff ;,size_t size ;dec -> xstart = siz -> xoff ;dec -> ystart = siz -> yoff ;,3529
1537,"dec -> numtiles = dec -> numhtiles * dec -> numvtiles ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;for ( tileno = 0 , tile = dec -> tiles ;++ tileno ,  ++ tile ) {","if ( ! jas_safe_size_mul ( dec -> numhtiles * dec -> numvtiles ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;dec -> numtiles = size ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\\if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) {return - 1 ;}for ( tileno = 0 , tile = dec -> tiles ;+ tileno ,  ++ tile ) {++ tileno , ++ tile ) {",3529
1538,"# define ThrowDCMException ( exception , message ) {","# define ThrowDCMException ( exception , message ) \\\\\",3530
1539,"}char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;","\\\\\char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ;",3530
1540,"data = ( unsigned char * ) NULL ;if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ;else if ( ( length == 1 ) && ( quantum == 2 ) ) {if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ;else datum = ReadBlobSignedShort ( image ) ;}else if ( ( length == 1 ) && ( quantum == 4 ) ) {if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ;else datum = ReadBlobSignedLong ( image ) ;}else if ( ( quantum != 0 ) && ( length != 0 ) ) {if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ;if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;count = ReadBlob ( image , ( size_t ) quantum * length , data ) ;if ( count != ( ssize_t ) ( quantum * length ) ) {if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\\ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;}data [ length * quantum ] = \'\\\\0\' ;}if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) {if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;continue ;}switch ( group ) {case 0x0002 : {switch ( element ) {case 0x0010 : {char transfer_syntax [ MagickPathExtent ] ;if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) {explicit_retry = MagickTrue ;( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ;group = 0 ;element = 0 ;if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\\break ;}* transfer_syntax = \'\\\\0\' ;if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ;if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\\if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) {int subtype , type ;type = 1 ;subtype = 0 ;if ( strlen ( transfer_syntax ) > 17 ) {count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ;if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;}switch ( type ) {case 1 : {image -> endian = LSBEndian ;break ;}case 2 : {image -> endian = MSBEndian ;break ;}case 4 : {if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ;else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ;else image -> compression = JPEGCompression ;break ;}case 5 : {image -> compression = RLECompression ;break ;}}}break ;}default : break ;}break ;}case 0x0028 : {switch ( element ) {case 0x0002 : {info . samples_per_pixel = ( size_t ) datum ;if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;break ;}case 0x0004 : {if ( data == ( unsigned char * ) NULL ) break ;for ( i = 0 ;i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ;i ++ ) photometric [ i ] = ( char ) data [ i ] ;photometric [ i ] = \'\\\\0\' ;info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ;break ;}case 0x0006 : {if ( datum == 1 ) image -> interlace = PlaneInterlace ;break ;}case 0x0008 : {if ( data == ( unsigned char * ) NULL ) break ;number_scenes = StringToUnsignedLong ( ( char * ) data ) ;break ;}case 0x0010 : {height = ( size_t ) datum ;break ;}case 0x0011 : {width = ( size_t ) datum ;break ;}case 0x0100 : {info . bits_allocated = ( size_t ) datum ;info . bytes_per_pixel = 1 ;if ( datum > 8 ) info . bytes_per_pixel = 2 ;info . depth = info . bits_allocated ;if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;info . max_value = ( 1UL << info . bits_allocated ) - 1 ;image -> depth = info . depth ;break ;}case 0x0101 : {info . significant_bits = ( size_t ) datum ;info . bytes_per_pixel = 1 ;if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ;info . depth = info . significant_bits ;if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;info . max_value = ( 1UL << info . significant_bits ) - 1 ;info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ;image -> depth = info . depth ;break ;}case 0x0102 : {break ;}case 0x0103 : {info . signed_data = ( size_t ) datum ;break ;}case 0x1050 : {if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ;break ;}case 0x1051 : {if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ;break ;}case 0x1052 : {if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ;break ;}case 0x1053 : {if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ;break ;}case 0x1200 : case 0x3006 : {if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / info . bytes_per_pixel ) ;datum = ( int ) colors ;if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ;graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ;if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ;else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ;break ;}case 0x1201 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ;redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ;if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;redmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1202 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ;greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ;if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;greenmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1203 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ;bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ;if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;bluemap [ i ] = ( int ) index ;p += 2 ;}break ;}default : break ;}break ;}case 0x2050 : {switch ( element ) {case 0x0020 : {if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ;break ;}default : break ;}break ;}default : break ;}if ( data != ( unsigned char * ) NULL ) {char * attribute ;for ( i = 0 ;dicom_info [ i ] . description != ( char * ) NULL ;i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ;if ( dicom_info [ i ] . description != ( char * ) NULL ) {attribute = AcquireString ( ""dcm:"" ) ;( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ;for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) {( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ;( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ;}attribute = DestroyString ( attribute ) ;}}if ( image_info -> verbose != MagickFalse ) {if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\\else {for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) {ssize_t j ;datum = 0 ;for ( j = ( ssize_t ) length - 1 ;j >= 0 ;j -- ) datum = ( 256 * datum + data [ j ] ) ;( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ;}else for ( i = 0 ;i < ( ssize_t ) length ;i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ;else ( void ) FormatLocaleFile ( stdout , ""%c"" , \'.\' ) ;( void ) FormatLocaleFile ( stdout , ""\\\}}if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}}if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) {Image * last ;last = RemoveLastImageFromList ( & image ) ;if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ;break ;}if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ;if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) {Image * images ;ImageInfo * read_info ;int c ;for ( i = 0 ;i < ( ssize_t ) stream_info -> remaining ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ;length = ( size_t ) ReadBlobLSBLong ( image ) ;if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;stream_info -> offset_count = length >> 2 ;if ( stream_info -> offset_count != 0 ) {if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ;stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ;if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;offset = TellBlob ( image ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] += offset ;}read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;images = NewImageList ( ) ;for ( scene = 0 ;scene < ( ssize_t ) number_scenes ;scene ++ ) {char filename [ MagickPathExtent ] ;const char * property ;FILE * file ;Image * jpeg_image ;int unique_file ;unsigned int tag ;tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ;length = ( size_t ) ReadBlobLSBLong ( image ) ;if ( tag == 0xFFFEE0DD ) break ;if ( tag != 0xFFFEE000 ) {read_info = DestroyImageInfo ( read_info ) ;ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ;}file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( file == ( FILE * ) NULL ) {( void ) RelinquishUniqueFileResource ( filename ) ;ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ;break ;}for ( c = EOF ;length != 0 ;length -- ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",3530
1541,void ntlm_print_negotiate_flags ( UINT32 flags )  {,static void ntlm_print_negotiate_flags ( UINT32 flags ) {,3531
1542,"if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) {while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 )  {","if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) {while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) {",3532
1543,"struct is_skippable_args args = {x , & result }vp9_foreach_transformed_block_in_plane ( & x -> e_mbd , bsize , plane , is_skippable , & args ) ;","struct is_skippable_args args = {x -> plane [ plane ] . eobs , & result }vp9_foreach_transformed_block_in_plane ( & x -> e_mbd , bsize , plane , is_skippable , & args ) ;",3533
1544,dev_data = pci_get_drvdata ( dev ) ;if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) {,u16 val ;struct pci_cmd_info * cmd = data ;dev_data = pci_get_drvdata ( dev ) ;if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) {,3534
1545,"return pci_write_config_word ( dev , offset , value ) ;}","cmd -> val = value ;if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ;err = pci_read_config_word ( dev , offset , & val ) ;if ( err || val == value ) return err ;value &= PCI_COMMAND_GUEST ;value |= val & ~ PCI_COMMAND_GUEST ;return pci_write_config_word ( dev , offset , value ) ;}",3534
1546,case SIOCYAMGCFG :  yi . cfg . mask = 0xffffffff ;yi . cfg . iobase = yp -> iobase ;,"case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;yi . cfg . mask = 0xffffffff ;yi . cfg . iobase = yp -> iobase ;",3535
1547,if ( swapped == 1 ) {pcap_fh . version_major = SWAPSHORT ( pcap_fh . version_major ) ;pcap_fh . version_minor = SWAPSHORT ( pcap_fh . version_minor ) ;pcap_fh . thiszone = SWAPLONG ( pcap_fh . thiszone ) ;pcap_fh . sigfigs = SWAPLONG ( pcap_fh . sigfigs ) ;pcap_fh . snaplen = SWAPLONG ( pcap_fh . snaplen ) ;pcap_fh . linktype = SWAPLONG ( pcap_fh . linktype ) ;,"if ( caplentoobig ) {printf ( ""\\\close ( fd ) ;break ;",3536
1548,if ( last_sec > 0 && last_usec > 0 ) {if ( ( pcap_ph . ts . tv_sec == last_sec ) ? ( pcap_ph . ts . tv_usec < last_usec ) : ( pcap_ph . ts . tv_sec < last_sec ) ) {,if ( last_sec > 0 && last_usec > 0 ) {if ( ( pcap_ph . ts . tv_sec == last_sec ) ? ( pcap_ph . ts . tv_usec < last_usec ) : ( pcap_ph . ts . tv_sec < last_sec ) ) {,3536
1549,continue ;},continue ;},3536
1550,"if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ;tmp_strsize = ( u32 ) ptr -> size - 8 ;tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ;if ( ! tmp_str ) return GF_OUT_OF_MEM ;memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ;tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ;for ( i = 0 ;tmp_strsize = ( u32 ) ptr -> size - 8 ;while ( tmp_strsize ) {tmp_str [ j ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;","if ( ptr -> size ;ISOM_DECREASE_SIZE ( ptr , 1 ) ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ;for ( i = 0 ;tmp_strsize = ( u32 ) ptr -> size ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;",3537
1551,ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ;for ( i = 0 ;tmp_strsize = ( u32 ) ptr -> size - 8 ;while ( tmp_strsize ) {tmp_str [ j ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;,"ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ;for ( i = 0 ;tmp_strsize = ( u32 ) ptr -> size ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ j ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;",3537
1552,tmp_strsize = ( u32 ) ptr -> size - 8 ;while ( tmp_strsize ) {tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;i = 0 ;tmp_strsize = ( u32 ) ptr -> size - 8 ;while ( tmp_strsize ) {tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;}ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ;,"tmp_strsize = ( u32 ) ptr -> size ;while ( tmp_strsize ) {ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;ISOM_DECREASE_SIZE ( ptr , 1 ) i = 0 ;tmp_strsize = ( u32 ) ptr -> size - 8 ;while ( tmp_strsize ) {tmp_str [ i ] = gf_bs_read_u8 ( bs ) ;tmp_strsize -- ;}ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> segment_run_table_count = gf_bs_read_u8 ( bs ) ;",3537
1553,ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ;for ( i = 0 ;,ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ;for ( i = 0 ;,3537
1554,uint32_t sampleRate ;while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) {,uint32_t sampleRate = 0 ;while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) {,3538
1555,config -> num_channels = numChannels ;,config -> num_channels || ! config -> sample_rate = numChannels ;,3538
1556,"if ( ! config -> num_channels ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;","if ( ! config -> num_channels ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;",3538
1557,"void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {","static void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {",3539
1558,},pdo_row_ce -> unserialize = zend_class_unserialize_deny ;},3540
1559,if ( ( ldblk > 9999 ) || ( ldblk < 0 ) )  break ;,if ( EOFBlob ( image ) ) break ;if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) break ;,3541
1560,s32 smin_val = src_reg -> smin_value ;u32 umin_val = src_reg -> umin_value ;if ( src_known && dst_known ) return ;,s32 smin_val = src_reg -> s32_min_value ;u32 umin_val = src_reg -> u32_min_value ;if ( src_known && dst_known ) return ;,3542
1561,dst_reg -> s32_min_value = dst_reg -> umin_value ;dst_reg -> s32_max_value = dst_reg -> umax_value ;},dst_reg -> s32_min_value = dst_reg -> u32_min_value ;dst_reg -> s32_max_value = dst_reg -> u32_max_value ;},3542
1562,"# ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) {if ( setpwnam ( ctl -> pw ) < 0 ) {warn ( ""setpwnam<S2SV_blank>failed"" ) ;","# ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw , "".chfn"" -> pw_uid , LU_GECOS , gecos ) < 0 ) {if ( setpwnam ( ctl -> pw ) < 0 ) {warn ( ""setpwnam<S2SV_blank>failed"" ) ;",3543
1563,# ifdef LIBRAW_LIBRARY_BUILD int cstat [ 4 ] = {,# ifdef LIBRAW_LIBRARY_BUILD if ( width < TS || height < TS ) throw LIBRAW_EXCEPTION_IO_CORRUPT ;for ( int i = 0 ;i < 3 ;i ++ ) for ( int j = 0 ;j < 3 ;j ++ ) for ( int k = 0 ;k < 2 ;k ++ ) for ( int l = 0 ;l < 8 ;l ++ ) allhex [ i ] [ j ] [ k ] [ l ] = 32700 ;int cstat [ 4 ] = {,3544
1564,"# endif # ifdef LIBRAW_LIBRARY_BUILD  for ( row = 0 ;row ++ )  for ( col = 0 ;# endif  cielab ( 0 , 0 ) ;homo = ( char ( * ) [ TS ] [ TS ] ) ( buffer + TS * TS * ( ndir * 10 + 6 ) ) ;for ( row = 0 ;","# endif # ifdef LIBRAW_LIBRARY_BUILD for ( row = 0 ;row ++ ) for ( col = 0 ;# endif cielab ( 0 , 0 ) ;int minv = 0 , maxv = 0 , minh = 0 , maxh = 0 ;homo = ( char ( * ) [ TS ] [ TS ] ) ( buffer + TS * TS * ( ndir * 10 + 6 ) ) ;for ( row = 0 ;",3544
1565,allhex [ row ] [ col ] [ 0 ] [ c ^ ( g * 2 & d ) ] = h + v * width ;allhex [ row ] [ col ] [ 1 ] [ c ^ ( g * 2 & d ) ] = h + v * TS ;}for ( row = 2 ;,"minv = MIN ( v , minv ) ;maxv = MAX ( v , maxv ) ;minh = MIN ( v , minh ) ;maxh = MAX ( v , maxh ) ;allhex [ row ] [ col ] [ 0 ] [ c ^ ( g * 2 & d ) ] = h + v * width ;allhex [ row ] [ col ] [ 1 ] [ c ^ ( g * 2 & d ) ] = h + v * TS ;}# ifdef LIBRAW_LIBRARY_BUILD for ( int i = 0 ;i < 3 ;i ++ ) for ( int j = 0 ;j < 3 ;j ++ ) for ( int k = 0 ;k < 2 ;k ++ ) for ( int l = 0 ;l < 8 ;l ++ ) if ( allhex [ i ] [ j ] [ k ] [ l ] > maxh + maxv * width + 1 || allhex [ i ] [ j ] [ k ] [ l ] < minh + minv * width - 1 ) throw LIBRAW_EXCEPTION_IO_CORRUPT ;int retrycount = 0 ;# endif for ( row = 2 ;",3544
1566,case 2 : if ( ( min = ~ ( max = 0 ) ) && ( col += 2 ) < width - 3 && row > 2 )  row -- ;},case 2 : if ( ( min = ~ ( max = 0 ) ) && ( col += 2 ) < width - 3 && row > 2 ) {row -- ;# ifdef LIBRAW_LIBRARY_BUILD if ( retrycount ++ > width * height ) throw LIBRAW_EXCEPTION_IO_CORRUPT ;# endif }},3544
1567,dlen -= 2 ;for ( ;,dlen -= 3 ;for ( ;,3545
1568,"if ( key_is_instantiated ( key ) )  seq_printf ( m , ""<S2SV_blank>pid:%d<S2SV_blank>ci:%zu"" , rka -> pid , rka -> callout_len ) ;","if ( key_is_positive ( key ) ) seq_printf ( m , ""<S2SV_blank>pid:%d<S2SV_blank>ci:%zu"" , rka -> pid , rka -> callout_len ) ;",3546
1569,assert ( bi != NULL ) ;ii = & bi -> slotinfo [ dev -> slot ] . si_intpins [ dev -> lintr . pin - 1 ] ;assert ( ii -> ii_ioapic_irq > 0 ) ;if ( ii -> ii_pirq_pin == 0 )  ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ;assert ( ii -> ii_pirq_pin > 0 ) ;,"if ( bi == NULL ) {pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\\return ;}ii = & bi -> slotinfo [ dev -> slot ] . si_intpins [ dev -> lintr . pin - 1 ] ;if ( ii -> ii_pirq_pin == 0 ) ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ;",3547
1570,bufsize = file -> size ;sc_file_free ( file ) ;,"bufsize = MIN ( file -> size , sizeof buf ) ;sc_file_free ( file ) ;",3548
1571,"if ( logfile_fd != INVALID_FD )  write ( logfile_fd , data , length ) ;btsnoop_net_write ( data , length ) ;","if ( logfile_fd != INVALID_FD ) TEMP_FAILURE_RETRY ( write ( logfile_fd , data , length ) ) ;btsnoop_net_write ( data , length ) ;",3549
1572,"s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , GFP_KERNEL ) ;if ( ! s_cmd ) return - ENOMEM ;if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) {ret = - EFAULT ;goto exit ;}s_cmd -> command += ec -> cmd_offset ;ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ;if ( ret < 0 ) goto exit ;if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) )  ret = - EFAULT ;",s_cmd = kmalloc ( sizeof ( * s_cmd ) + s_cmd -> insize ) ) ret = - EFAULT ;,3550
1573,free ( ctx ) ;return VPX_CODEC_OK ;,vpx_free ( ctx ) ;return VPX_CODEC_OK ;,3551
1574,"if ( class == BPF_ALU || class == BPF_ALU64 ) {err = check_alu_op ( env , insn ) ;","env -> insn_aux_data [ insn_idx ] . seen = true ;if ( class == BPF_ALU || class == BPF_ALU64 ) {err = check_alu_op ( env , insn ) ;",3552
1575,"
",env -> insn_aux_data [ insn_idx ] . seen = true ;,3552
1576,"}verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\\","}verbose ( env , ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\\",3552
1577,u1_num_mbs ++ ;ps_dec -> u2_total_mbs_coded ++ ;,u1_num_mbs ++ ;,3553
1578,if ( u1_tfr_n_mb )  u1_num_mbs = 0 ;,ps_dec -> u2_total_mbs_coded += u1_num_mbs ;if ( u1_tfr_n_mb ) u1_num_mbs = 0 ;,3553
1579,"return ( * field_rtrn != NULL ) ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;* field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ;* index_rtrn = NULL ;return true ;case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ;return true ;default : break ;","return ( * elem_rtrn != NULL && * field_rtrn != NULL ) ;case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ;if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ;if ( * field_rtrn == NULL ) return false ;return true ;default : break ;",3554
1580,if ( ! replay_esn || ! rp )  return 0 ;if ( xfrm_replay_state_esn_len ( replay_esn ) !=   xfrm_replay_state_esn_len ( up ) )  return - EINVAL ;,int ulen ;if ( ! replay_esn || ! rp ) return 0 ;ulen = xfrm_replay_state_esn_len ( up ) ;if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) return - EINVAL ;,3555
1581,"static void rd_use_partition ( VP9_COMP * cpi ,  const TileInfo * const tile ,  MODE_INFO * * mi_8x8 , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int * rate , int64_t * dist ,  int do_recon ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2 ( bsize ) ;const int mi_step = num_4x4_blocks_wide_lookup [ bsize ] / 2 ;int last_part_rate = INT_MAX ;int64_t last_part_dist = INT64_MAX ;int64_t last_part_rd = INT64_MAX ;int none_rate = INT_MAX ;int64_t none_dist = INT64_MAX ;int64_t none_rd = INT64_MAX ;int chosen_rate = INT_MAX ;int64_t chosen_dist = INT64_MAX ;int64_t chosen_rd = INT64_MAX ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols )  return ;partition = partition_lookup [ bsl ] [ bs_type ] ;subsize = get_subsize ( bsize , partition ) ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index != 0 ) {* rate = 0 ;* dist = 0 ;return ;}}else {* ( get_sb_partitioning ( x , bsize ) ) = subsize ;}save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;if ( bsize == BLOCK_16X16 ) {set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ;}else {x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;","static void rd_use_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , MODE_INFO * * mi_8x8 , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int * rate , int64_t * dist , int do_recon , PC_TREE * pc_tree ) {VP9_COMMON * const cm = & cpi -> common ;TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2_lookup [ bsize ] ;const int mi_step = num_4x4_blocks_wide_lookup [ bsize ] / 2 ;RD_COST last_part_rdc , none_rdc , chosen_rdc ;PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;vp9_rd_cost_reset ( & last_part_rdc ) ;vp9_rd_cost_reset ( & none_rdc ) ;vp9_rd_cost_reset ( & chosen_rdc ) ;partition = partition_lookup [ bsl ] [ bs_type ] ;subsize = get_subsize ( bsize , partition ) ;pc_tree -> partitioning = partition ;save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ;if ( bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) {set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;x -> mb_energy = vp9_block_energy ( cpi , tile_info , x , mi_row , mi_col , bsize ) ;",3556
1582,"* ( get_sb_partitioning ( x , bsize ) ) = bsize ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & none_rate , & none_dist , bsize ,  get_block_context ( x , bsize ) , INT64_MAX ) ;if ( none_rate < INT_MAX ) {none_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;none_rd = RDCOST ( x -> rdmult , x -> rddiv , none_rate , none_dist ) ;}restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;mi_8x8 [ 0 ] -> mbmi . sb_type = bs_type ;* ( get_sb_partitioning ( x , bsize ) ) = subsize ;}}switch ( partition ) {case PARTITION_NONE :  rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate ,  & last_part_dist , bsize , get_block_context ( x , bsize ) , INT64_MAX ) ;break ;case PARTITION_HORZ :  * get_sb_index ( x , subsize ) = 0 ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , & last_part_dist , subsize , get_block_context ( x , subsize ) , INT64_MAX ) ;if ( last_part_rate != INT_MAX &&  bsize >= BLOCK_8X8 && mi_row + ( mi_step >> 1 ) < cm -> mi_rows ) {int rt = 0 ;int64_t dt = 0 ;update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col ,  subsize , 0 ) ;encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ;* get_sb_index ( x , subsize ) = 1 ;rd_pick_sb_modes ( cpi , tile , mi_row + ( mi_step >> 1 ) , mi_col , & rt , & dt ,   subsize , get_block_context ( x , subsize ) , INT64_MAX ) ;if ( rt == INT_MAX || dt == INT64_MAX ) {last_part_rate = INT_MAX ;last_part_dist = INT64_MAX ;break ;}last_part_rate += rt ;last_part_dist += dt ;}break ;case PARTITION_VERT :  * get_sb_index ( x , subsize ) = 0 ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , & last_part_dist , subsize , get_block_context ( x , subsize ) , INT64_MAX ) ;if ( last_part_rate != INT_MAX &&  bsize >= BLOCK_8X8 && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) {int rt = 0 ;int64_t dt = 0 ;update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col ,  subsize , 0 ) ;encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ;* get_sb_index ( x , subsize ) = 1 ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ( mi_step >> 1 ) , & rt , & dt ,   subsize , get_block_context ( x , subsize ) , INT64_MAX ) ;if ( rt == INT_MAX || dt == INT64_MAX ) {last_part_rate = INT_MAX ;last_part_dist = INT64_MAX ;break ;}last_part_rate += rt ;last_part_dist += dt ;}break ;case PARTITION_SPLIT :  last_part_rate = 0 ;last_part_dist = 0 ;for ( i = 0 ;i < 4 ;i ++ ) {int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ;int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ;int jj = i >> 1 , ii = i & 0x01 ;int rt ;int64_t dt ;if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) continue ;* get_sb_index ( x , subsize ) = i ;rd_use_partition ( cpi , tile , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx , subsize , & rt , & dt ,  i != 3 ) ;if ( rt == INT_MAX || dt == INT64_MAX ) {last_part_rate = INT_MAX ;last_part_dist = INT64_MAX ;break ;}last_part_rate += rt ;last_part_dist += dt ;break ;default : assert ( 0 ) ;}pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;if ( last_part_rate < INT_MAX ) {last_part_rate += x -> partition_cost [ pl ] [ partition ] ;last_part_rd = RDCOST ( x -> rdmult , x -> rddiv , last_part_rate , last_part_dist ) ;}chosen_rate = 0 ;chosen_dist = 0 ;restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;for ( i = 0 ;int rt = 0 ;int64_t dt = 0 ;* get_sb_index ( x , split_subsize ) = i ;* get_sb_partitioning ( x , bsize ) = split_subsize ;rd_pick_sb_modes ( cpi , tile , mi_row + y_idx , mi_col + x_idx , & rt , & dt ,  split_subsize , get_block_context ( x , split_subsize ) , INT64_MAX ) ;if ( rt == INT_MAX || dt == INT64_MAX ) {chosen_rate = INT_MAX ;chosen_dist = INT64_MAX ;chosen_rate += rt ;chosen_dist += dt ;if ( i != 3 )  encode_sb ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , 0 ,   split_subsize ) ;pl = partition_plane_context ( xd , mi_row + y_idx , mi_col + x_idx , split_subsize ) ;chosen_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;}if ( chosen_rate < INT_MAX ) {chosen_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;chosen_rd = RDCOST ( x -> rdmult , x -> rddiv , chosen_rate , chosen_dist ) ;}if ( bsize >= BLOCK_8X8 )  * ( get_sb_partitioning ( x , bsize ) ) = subsize ;chosen_rate = last_part_rate ;if ( bsize >= BLOCK_8X8 )  * ( get_sb_partitioning ( x , bsize ) ) = bsize ;chosen_rate = none_rate ;restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;if ( bsize == BLOCK_64X64 )  assert ( chosen_rate < INT_MAX && chosen_dist < INT64_MAX ) ;if ( do_recon ) {if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , chosen_rate ) ;* dist = chosen_dist ;}","* ( get_sb_partitioning ( x , bsize ) ) = bsize ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & none_rate , & none_dist , bsize , get_block_context ( x , bsize ) , INT64_MAX ) ;chosen_rate = 0 ;chosen_dist = 0 ;restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;pc_tree -> partitioning = PARTITION_SPLIT ;for ( i = 0 ;int rt = 0 ;int64_t dt = 0 ;* get_sb_index ( x , split_subsize ) = i ;* get_sb_partitioning ( x , bsize ) = split_subsize ;rd_pick_sb_modes ( cpi , tile , mi_row + y_idx , mi_col + x_idx , & rt , & dt , split_subsize , get_block_context ( x , split_subsize ) , INT64_MAX ) ;if ( rt == INT_MAX || dt == INT64_MAX ) {chosen_rate = INT_MAX ;chosen_dist = INT64_MAX ;chosen_rate += rt ;chosen_dist += dt ;if ( i != 3 ) encode_sb ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , 0 , split_subsize , pc_tree -> split [ i ] ) ;pl = partition_plane_context ( xd , mi_row + y_idx , mi_col + x_idx , split_subsize ) ;chosen_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;}if ( chosen_rate < INT_MAX ) {chosen_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;chosen_rd = RDCOST ( x -> rdmult , x -> rddiv , chosen_rate , chosen_dist ) ;}if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = subsize ;chosen_rate = last_part_rate ;if ( bsize >= BLOCK_8X8 ) * ( get_sb_partitioning ( x , bsize ) ) = bsize ;chosen_rate = none_rate ;restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;if ( bsize == BLOCK_64X64 ) assert ( chosen_rate < INT_MAX && chosen_dist < INT64_MAX ) ;if ( do_recon ) {if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , chosen_rate ) ;* dist = chosen_rdc . dist ;}",3556
1583,"ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ;len = ntohs ( a . h . len ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>method=%s"" , len - 4 ,  STR_OR_ID ( a . auth_method , v2_auth ) ) ) ;if ( 1 < ndo -> ndo_vflag && 4 < len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ;ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ;}else if ( ndo -> ndo_vflag && 4 < len ) {if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ;return ( const u_char * ) ext + len ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ;","ikev2_pay_print ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ;if ( 1 < ndo -> ndo_vflag && 4 < len ) {ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ;if ( len > 4 ) {if ( ndo -> ndo_vflag && 4 < len ) {if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ;}return ( const u_char * ) ext + len ;trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ;",3557
1584,"unsigned int maxw , maxh , max ;int offset , upb ;unsigned int i , j ;maxw = ( unsigned int ) img -> comps [ 0 ] . w ;maxh = ( unsigned int ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;for ( i = 0U ;i < ( maxh & ~ ( unsigned int ) 1U ) ;i += 2U )  {ny = y + maxw ;nr = r + maxw ;for ( j = 0 ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {","size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ;int offset , upb ;size_t i ;maxw = ( size_t ) img -> comps [ 0 ] . w ;maxh = ( size_t ) img -> comps [ 0 ] . h ;max = maxw * maxh ;d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ;d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ;d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ;offx = img -> x0 & 1U ;loopmaxw = maxw - offx ;offy = img -> y0 & 1U ;loopmaxh = maxh - offy ;if ( offy > 0U ) {size_t j ;for ( j = 0 ;j < maxw ;++ j ) {sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ;++ y ;++ r ;++ g ;++ b ;}}for ( i = 0U ;i < ( loopmaxh & ~ ( unsigned int ) 1U ) ;i += 2U ) {ny = y + maxw ;nr = r + maxw ;for ( j = 0 ;j < ( maxw & ~ ( size_t ) 1U ) ;j += 2U ) {size_t j ;",3558
1585,if ( j < maxw )  {,if ( j < maxw ) {,3558
1586,if ( i < maxh )  {for ( j = 0U ;j < ( maxw & ~ ( unsigned int ) 1U ) ;j += 2U )  {,if ( i < maxh ) {for ( j = 0U ;j < ( loopmaxw & ~ ( unsigned int ) 1U ) ;j += 2U ) {,3558
1587,if ( j < maxw ) {,if ( j < loopmaxw ) {,3558
1588,# if defined ( USE_JPWL ) || defined ( USE_MJ2 )   img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = maxw ;img -> comps [ 2 ] . h = maxh ;# else  img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ;# endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails :  if ( r ) free ( r ) ;if ( g ) free ( g ) ;if ( b ) free ( b ) ;},img -> comps [ 1 ] . w = maxw ;img -> comps [ 2 ] . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ;img -> comps [ 2 ] . h = img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ;img -> comps [ 2 ] . h = img -> comps [ 0 ] . h ;img -> comps [ 1 ] . dx = img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ;img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dx ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ;return ;fails : free ( r ) ;if ( g ) free ( g ) ;free ( b ) ;},3558
1589,"static void prefetch_table ( const volatile byte * tab , size_t len )  {for ( i = 0 ;i < len ;i += 8 * 32 )  {","static inline void prefetch_table ( const volatile byte * tab , size_t len ) {for ( i = 0 ;len - i >= 8 * 32 ;i += 8 * 32 ) {",3559
1590,( void ) tab [ len - 1 ] ;},for ( ;i < len ;i += 32 ) {( void ) tab [ i ] ;}( void ) tab [ len - 1 ] ;},3559
1591,"if ( chunk_header . ckSize < sizeof ( DS64Chunk ) ||  ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) ||   bcount != chunk_header . ckSize ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) &&  ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) {error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ;","if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) {error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ;",3560
1592,"void * ptr = malloc ( num * size ) ;if ( ptr ) {memset ( ptr , '\\\\0' , ( num * size ) ) ;}","size_t res ;if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;void * ptr ;ptr = malloc ( res ) ;if ( ptr ) {memset ( ptr , '\\\\0' , ( res ) ) ;}",3561
1593,}free ( buffer ) ;,"if ( ! strcmp ( line , ""HASHSEED"" ) ) {conf . have_hashseed = 1 ;conf . hashseed = atoi ( val ) ;}else {conf . have_hashseed = 0 ;}}free ( buffer ) ;",3562
1594,"}else if ( cpkt . cptype == MT_CPTYPE_PASSWORD ) {# if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( curconn -> trypassword , 17 ) ;","}else if ( cpkt . cptype == MT_CPTYPE_PASSWORD && cpkt . length == 17 ) {# if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( curconn -> trypassword , 17 ) ;",3563
1595,"syslog ( LOG_WARNING , _ ( ""(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d"" ) , curconn -> seskey , cpkt . cptype ) ;}","syslog ( LOG_WARNING , _ ( ""(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%d"" ) , curconn -> seskey , cpkt . cptype , cpkt . length ) ;}",3563
1596,"if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( dst_reg , 4 ) ;coerce_reg_to_size ( & src_reg , 4 ) ;}",u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ;,3564
1597,"if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) {__mark_reg_unbounded ( dst_reg ) ;__update_reg_bounds ( dst_reg ) ;break ;}dst_reg -> umin_value *= umin_val ;dst_reg -> umax_value *= umax_val ;if ( dst_reg -> umax_value > S64_MAX ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}break ;case BPF_AND : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ;break ;}dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = dst_reg -> var_off . value ;dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_OR : if ( src_known && dst_known ) {__mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ;dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ;dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ;dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ;if ( dst_reg -> smin_value < 0 || smin_val < 0 ) {dst_reg -> smin_value = S64_MIN ;dst_reg -> smax_value = S64_MAX ;}else {dst_reg -> smin_value = dst_reg -> umin_value ;dst_reg -> smax_value = dst_reg -> umax_value ;}__update_reg_bounds ( dst_reg ) ;break ;case BPF_LSH :  if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;break ;","if ( umax_val >= insn_bitness ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) {coerce_reg_to_size ( dst_reg , 4 ) ;coerce_reg_to_size ( & src_reg , 4 ) ;",3564
1598,"case BPF_RSH :  if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;","case BPF_RSH : if ( umax_val > 63 ) {mark_reg_unknown ( env , regs , insn -> dst_reg ) ;",3564
1599,__reg_deduce_bounds ( dst_reg ) ;__reg_bound_offset ( dst_reg ) ;,__reg_deduce_bounds ( dst_reg ) ;__reg_bound_offset ( dst_reg ) ;,3564
1600,"
","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}",3565
1601,"( void ) ReadBlobString ( image , text ) ;if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) {","( void ) ReadBlobString ( image , text ) ;if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) {",3565
1602,"if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse )  ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( image -> colors + 1 , sizeof ( * image -> colormap ) ) ;if ( image -> colormap == ( PixelInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",3566
1603,"status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse )  return ( DestroyImageList ( image ) ) ;status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ;if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ;do {c = ReadBlobByte ( image ) ;}while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ;if ( c != EOF ) {AcquireNextImage ( image_info , image , exception ) ;if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;}image = SyncNextImageInList ( image ) ;","if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) return ( DestroyImageList ( image ) ) ;status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ;if ( status == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ;",3566
1604,"ret = copy_to_user ( uattr , attr , usize ) ;if ( ret ) return - EFAULT ;","ret = copy_to_user ( uattr , attr , attr -> size ) ;if ( ret ) return - EFAULT ;",3567
1605,"if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;","if ( ! ( buf = jas_alloc3 ( bufsize , numcols , sizeof ( jpc_fix_t ) ) ) ) {abort ( ) ;",3568
1606,"sctp_sock_rfree ( skb ) ;__skb_unlink ( skb , & oldsk -> sk_receive_queue ) ;sctp_skb_set_owner_r ( skb , newsk ) ;}","sctp_sock_rfree_frag ( skb ) ;__skb_unlink ( skb , & oldsk -> sk_receive_queue ) ;sctp_skb_set_owner_r_frag ( skb , newsk ) ;}",3569
1607,"sctp_sock_rfree ( skb ) ;__skb_unlink ( skb , & oldsp -> pd_lobby ) ;sctp_skb_set_owner_r ( skb , newsk ) ;}if ( assoc -> ulpq . pd_mode )  sctp_clear_pd ( oldsk ) ;}","sctp_sock_rfree_frag ( skb ) ;__skb_unlink ( skb , & oldsp -> pd_lobby ) ;sctp_skb_set_owner_r_frag ( skb , newsk ) ;}}if ( assoc -> ulpq . pd_mode ) sctp_clear_pd ( oldsk ) ;}sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) {sctp_sock_rfree_frag ( skb ) ;sctp_skb_set_owner_r_frag ( skb , newsk ) ;}sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) {sctp_sock_rfree_frag ( skb ) ;sctp_skb_set_owner_r_frag ( skb , newsk ) ;",3569
1608,"static void nsc_decode ( NSC_CONTEXT * context )  {UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ;BYTE shift = context -> ColorLossLevel - 1 ;BYTE * bmpdata = context -> BitmapData ;for ( y = 0 ;","static BOOL nsc_decode ( NSC_CONTEXT * context ) {UINT16 rw ;BYTE shift ;BYTE * bmpdata ;size_t pos = 0 ;if ( ! context ) return FALSE ;rw = ROUND_UP_TO ( context -> width , 8 ) ;shift = context -> ColorLossLevel - 1 ;bmpdata = context -> BitmapData ;if ( ! bmpdata ) return FALSE ;for ( y = 0 ;",3570
1609,"* bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ;* bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ;","if ( pos + 4 > context -> BitmapDataLength ) return FALSE ;pos += 4 ;* bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ;* bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ;",3570
1610,},return TRUE ;},3570
1611,dst [ y * linesize + x ] = clr ;lx = x ;,if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;dst [ y * linesize + x ] = clr ;lx = x ;,3571
1612,return - 1 ;},fclose ( mapf ) ;return - 1 ;},3572
1613,"if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL )  {",if ( ( psf = psf_allocate ( ) ) == NULL ) {,3573
1614,"if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) )   task -> task_state_flags |= SAS_TASK_STATE_ABORTED ;spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ;}","if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) {task -> task_state_flags |= SAS_TASK_STATE_ABORTED ;}spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ;}",3574
1615,devc -> voc [ voice ] . panning = value ;},if ( voice < 0 || voice >= devc -> nr_voice ) return ;devc -> voc [ voice ] . panning = value ;},3575
1616,"cib_remote_opaque_t * private = cib -> variant_opaque ;shutdown ( private -> command . socket , SHUT_RDWR ) ;shutdown ( private -> callback . socket , SHUT_RDWR ) ;close ( private -> command . socket ) ;close ( private -> callback . socket ) ;gnutls_bye ( * ( private -> command . session ) , GNUTLS_SHUT_RDWR ) ;gnutls_deinit ( * ( private -> command . session ) ) ;gnutls_bye ( * ( private -> callback . session ) , GNUTLS_SHUT_RDWR ) ;gnutls_deinit ( * ( private -> callback . session ) ) ;gnutls_anon_free_client_credentials ( anon_cred_c ) ;gnutls_global_deinit ( ) ;}# endif  return 0 ;}","cib_remote_opaque_t * private = cib -> variant_opaque ;if ( private -> command . session ) {gnutls_bye ( * ( private -> command . session ) , GNUTLS_SHUT_RDWR ) ;gnutls_deinit ( * ( private -> command . session ) ) ;}if ( private -> callback . session ) {gnutls_bye ( * ( private -> callback . session ) , GNUTLS_SHUT_RDWR ) ;gnutls_deinit ( * ( private -> callback . session ) ) ;}private -> command . session = NULL ;private -> callback . session = NULL ;if ( remote_gnutls_credentials_init ) {gnutls_anon_free_client_credentials ( anon_cred_c ) ;gnutls_global_deinit ( ) ;remote_gnutls_credentials_init = FALSE ;}}# endif if ( private -> command . socket ) {shutdown ( private -> command . socket , SHUT_RDWR ) ;close ( private -> command . socket ) ;}if ( private -> callback . socket ) {shutdown ( private -> callback . socket , SHUT_RDWR ) ;close ( private -> callback . socket ) ;}private -> command . socket = 0 ;private -> callback . socket = 0 ;free ( private -> command . recv_buf ) ;free ( private -> callback . recv_buf ) ;private -> command . recv_buf = NULL ;private -> callback . recv_buf = NULL ;return 0 ;}",3576
1617,case EXIT_REASON_EXCEPTION_NMI :  if ( ! is_exception ( intr_info ) )  return false ;,case EXIT_REASON_EXCEPTION_NMI : if ( is_nmi ( intr_info ) ) return false ;,3577
1618,"static int update_mv ( vp9_writer * w , const unsigned int ct [ 2 ] , vp9_prob * cur_p ,   vp9_prob upd_p ) {const vp9_prob new_p = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) | 1 ;const int update = cost_branch256 ( ct , * cur_p ) + vp9_cost_zero ( upd_p ) > cost_branch256 ( ct , new_p ) + vp9_cost_one ( upd_p ) + 7 * 256 ;vp9_write ( w , update , upd_p ) ;if ( update ) {vp9_write_literal ( w , new_p >> 1 , 7 ) ;}","static int update_mv ( vpx_writer * w , const unsigned int ct [ 2 ] , vpx_prob * cur_p , vp9_prob upd_p ) {const vpx_prob new_p = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) | 1 ;const int update = cost_branch256 ( ct , * cur_p ) + vp9_cost_zero ( upd_p ) > cost_branch256 ( ct , new_p ) + vp9_cost_one ( upd_p ) + 7 * 256 ;vpx_write ( w , update , upd_p ) ;if ( update ) {vpx_write_literal ( w , new_p >> 1 , 7 ) ;}",3578
1619,"defaultoptions ( & h ) ;lua_settop ( L , 2 ) ;size_t size = optsize ( L , opt , & fmt ) ;pos += gettoalign ( pos , & h , opt , size ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;switch ( opt ) {lua_pushnumber ( L , res ) ;break ;case \'x\' : {case \'f\' : {float f ;memcpy ( & f , data + pos , size ) ;correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ;lua_pushnumber ( L , f ) ;break ;}case \'d\' : {double d ;memcpy ( & d , data + pos , size ) ;correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ;lua_pushnumber ( L , d ) ;break ;}case \'c\' : {if ( size == 0 ) {if ( ! lua_isnumber ( L , - 1 ) )   luaL_error ( L , ""format<S2SV_blank>`c0\\\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ;size = lua_tonumber ( L , - 1 ) ;lua_pop ( L , 1 ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;}lua_pushlstring ( L , data + pos , size ) ;break ;}lua_pushlstring ( L , data + pos , size - 1 ) ;break ;return lua_gettop ( L ) - 2 ;}","int n = 0 ;defaultoptions ( & h ) ;size_t size = optsize ( L , 2 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ;switch ( opt ) {lua_pushnumber ( L , ""format<S2SV_blank>\\\'c0\\\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ;size = lua_tonumber ( L , - 1 ) ;n -- ;lua_pop ( L , 1 ) ;luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ;lua_pushlstring ( L , data + pos , size ) ;n ++ ;lua_pushlstring ( L , data + pos , size - 1 ) ;n ++ ;break ;return n + 1 ;}",3579
1620,"for ( i = 0 ;i ++ )  if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ;","if ( strlen ( line ) == 0 ) return - 1 ;for ( i = 0 ;i ++ ) if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ;",3580
1621,int overflow_error = 0 ;res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ;if ( ! res ) {,"size_t weights_size ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {return NULL ;}else {weights_size = windows_size * sizeof ( double ) ;}res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ;if ( ! res ) {",3581
1622,"for ( u = 0 ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ;}u -- ;for ( i = 0 ;gdFree ( res -> ContribRow [ i ] . Weights ) ;","for ( u = 0 ;if ( overflow2 ( windows_size , sizeof ( double ) ) ) {res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ;}u -- ;for ( i = 0 ;gdFree ( res -> ContribRow [ i ] . Weights ) ;",3581
1623,timer -> it_overrun += 1 << i ;delta -= incr ;,timer -> it_overrun += 1LL << i ;delta -= incr ;,3582
1624,"map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ;if ( NULL == map ) return - ENOMEM ;","map = q -> bufs [ first ] -> map = kzalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ;if ( NULL == map ) return - ENOMEM ;",3583
1625,"handle = server -> connrec -> use_ssl ?  net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey ,  server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ;","handle = server -> connrec -> use_ssl ? net_connect_ip_ssl ( ip , port , server -> connrec -> address , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ;",3584
1626,"static void write_segment_id ( vp9_writer * w , const struct segmentation * seg ,  int segment_id ) {","static void write_segment_id ( vpx_writer * w , const struct segmentation * seg , int segment_id ) {",3585
1627,"FLACHeader hdr ;if ( ! ctx -> duration . num ) flac_dmx_check_dur ( filter , ctx ) ;","FLACHeader hdr ;if ( ctx -> in_error ) return GF_NON_COMPLIANT_BITSTREAM ;if ( ! ctx -> duration . num ) flac_dmx_check_dur ( filter , ctx ) ;GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>magic\\\ctx -> in_error = GF_TRUE ;ctx -> flac_buffer_size = 0 ;if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ;return GF_NON_COMPLIANT_BITSTREAM ;",3586
1628,}while ( gf_bs_available ( ctx -> bs ) ) {,}while ( gf_bs_available ( ctx -> bs ) ) {,3586
1629,if ( last ) break ;},"if ( last ) break ;}if ( ! dsi_end ) {GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>header\\\ctx -> in_error = GF_TRUE ;ctx -> flac_buffer_size = 0 ;if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ;return GF_NON_COMPLIANT_BITSTREAM ;}",3586
1630,if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) )  return ERR_PTR ( - EINVAL ) ;,if ( ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ;if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ;,3587
1631,struct dentry * dir ;struct fscrypt_info * ci ;,struct dentry * dir ;,3588
1632,ci = d_inode ( dir ) -> i_crypt_info ;if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ;dir_has_key = ( ci != NULL ) ;dput ( dir ) ;,dir_has_key = ( ci != NULL ) ;dput ( dir ) ;,3588
1633,"fp -> protocol = altsd -> bInterfaceProtocol ;if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ;","if ( altsd -> bNumEndpoints < 1 ) {kfree ( fp ) ;kfree ( rate_table ) ;return - EINVAL ;}fp -> protocol = altsd -> bInterfaceProtocol ;if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ;",3589
1634,}i2_cur_mb_addr ++ ;,if ( ! uc_more_data_flag && ! i2_mb_skip_run && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) {return ERROR_EOB_FLUSHBITS_T ;}}i2_cur_mb_addr ++ ;,3590
1635,"case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) {im -> legendposition = NORTH ;}else if ( strcmp ( optarg , ""west"" ) == 0 ) {im -> legendposition = WEST ;}else if ( strcmp ( optarg , ""south"" ) == 0 ) {im -> legendposition = SOUTH ;}else if ( strcmp ( optarg , ""east"" ) == 0 ) {im -> legendposition = EAST ;}else {rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\\\'%s\\\'"" , optarg ) ;",case 1005 : if ( bad_format_axis ( optarg ) ) {,3591
1636,"case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) {rrd_set_error ( ""--units<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>once!"" ) ;",case LONGOPT_UNITS_SI : if ( bad_format_axis ( optarg ) ) {,3591
1637,"case 1004 :  if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;","case 1004 : if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;",3591
1638,"case 1012 :  if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;","case 1012 : if ( bad_format ( optarg ) ) {rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ;",3591
1639,"kvmclock_reset ( vcpu ) ;vcpu -> arch . time = data ;vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ;if ( vcpu -> arch . time_offset &  ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ;vcpu -> arch . time_page =   gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ;if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ;if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ;vcpu -> arch . st . msr_val = data ;if ( ! ( data & KVM_MSR_ENABLED ) ) break ;vcpu -> arch . st . last_steal = current -> sched_info . run_delay ;preempt_disable ( ) ;accumulate_steal_time ( vcpu ) ;preempt_enable ( ) ;kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ;","u64 gpa_offset ;kvmclock_reset ( vcpu ) ;vcpu -> arch . time = data ;gpa_offset = data & ~ ( PAGE_MASK | 1 ) ;if ( gpa_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ;if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , data >> PAGE_SHIFT ) ;if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ;if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ;else vcpu -> arch . pv_time_enabled = true ;",3592
1640,"unsigned v = get_symbol ( c , state , 0 ) ;if ( v >= 2 ) {av_log ( f -> avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ver01<S2SV_blank>header\\\return AVERROR_INVALIDDATA ;}f -> version = v ;f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ) ;if ( f -> ac > 1 ) {for ( i = 1 ;i < 256 ;i ++ ) f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ] ;}f -> colorspace = get_symbol ( c , state , 0 ) ;if ( f -> version > 0 ) f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ;f -> chroma_planes = get_rac ( c , state ) ;f -> chroma_h_shift = get_symbol ( c , state , 0 ) ;f -> chroma_v_shift = get_symbol ( c , state , 0 ) ;f -> transparency = get_rac ( c , state ) ;f -> plane_count = 2 + f -> transparency ;","int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ;unsigned v = get_symbol ( c , state , 0 ) ;chroma_planes = get_rac ( c , state ) ;f -> chroma_h_shift = get_symbol ( c , state , 0 ) ;f -> chroma_v_shift = get_symbol ( c , state , 0 ) ;f -> transparency = get_rac ( c , state ) ;f -> plane_count = 2 + f -> transparency ;",3593
1641,"dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ;usb_set_intfdata ( interface , dev ) ;retval = usb_register_dev ( interface , & tower_class ) ;if ( retval ) {dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\\usb_set_intfdata ( interface , NULL ) ;goto error ;}dev -> minor = interface -> minor ;dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\\","
",3594
1642,exit :  return retval ;,"usb_set_intfdata ( interface , dev ) ;retval = usb_register_dev ( interface , & tower_class ) ;if ( retval ) {dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\\usb_set_intfdata ( interface , NULL ) ;goto error ;}dev -> minor = interface -> minor ;dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\\exit : return retval ;",3594
1643,"int i , length_modes , length_chars ;if ( ! server || ! prefix )  return ;if ( server -> prefix_modes ) {","int i , old_length_chars , length_modes , length_chars ;if ( ! server || ! prefix ) return ;old_length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 ;if ( server -> prefix_modes ) {",3595
1644,},"length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 ;if ( server -> prefix_chars && ( length_chars != old_length_chars ) ) irc_nick_realloc_prefixes ( server , old_length_chars , length_chars ) ;}",3595
1645,snd_seq_timer_stop ( q -> timer ) ;snd_seq_timer_close ( q ) ;snd_use_lock_sync ( & q -> use_lock ) ;,mutex_lock ( & q -> timer_mutex ) ;snd_seq_timer_stop ( q -> timer ) ;snd_seq_timer_close ( q ) ;mutex_unlock ( & q -> timer_mutex ) ;snd_use_lock_sync ( & q -> use_lock ) ;,3596
1646,"if ( plen > 1024 * 1024 - 1 ) goto error ;ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ;if ( ret < 0 ) goto error ;description = NULL ;if ( _description ) {description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ;if ( IS_ERR ( description ) ) {",if ( plen ) {,3597
1647,if ( _payload ) {ret = - ENOMEM ;,if ( _payload ) {ret = - ENOMEM ;,3597
1648,"struct address_space * mapping ;mapping = ( struct address_space * ) page_private ( page ) ;if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) {update_and_free_page ( h , page ) ;h -> surplus_huge_pages -- ;h -> surplus_huge_pages_node [ nid ] -- ;}else {enqueue_huge_page ( h , page ) ;}spin_unlock ( & hugetlb_lock ) ;if ( mapping )  hugetlb_put_quota ( mapping , 1 ) ;","struct hugepage_subpool * spool = ( struct hugepage_subpool * ) page_private ( page ) ;hugepage_subpool_put_pages ( spool , 1 ) ;",3598
1649,"struct sk_buff * skb ;skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ;if ( dump_one_state ( x , 0 , & info ) ) {kfree_skb ( skb ) ;return NULL ;}","struct sk_buff * skb ;int err ;skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ;err = dump_one_state ( x , 0 , & info ) ;if ( err ) {kfree_skb ( skb ) ;return ERR_PTR ( err ) ;}",3599
1650,"
",unsigned int actual_size = f -> blocksize_1 / 2 ;unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ;unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ;,3600
1651,int n_read = r -> end - r -> begin ;int part_read = n_read / r -> part_size ;,int n_read = limit_r_end - limit_r_begin ;int part_read = n_read / r -> part_size ;,3600
1652,if ( length > 4 )  Stream_Seek_UINT16 ( s ) ;if ( length > 6 )  Stream_Seek_UINT16 ( s ) ;,if ( length > 5 ) Stream_Seek_UINT16 ( s ) ;if ( length > 7 ) Stream_Seek_UINT16 ( s ) ;,3601
1653,uint32_t bcount ;infilesize = DoGetFileSize ( infile ) ;,uint32_t bcount ;CLEAR ( WaveHeader ) ;infilesize = DoGetFileSize ( infile ) ;,3602
1654,void unix_notinflight ( struct file * fp )  {,"void unix_notinflight ( struct user_struct * user , struct file * fp ) {",3603
1655,fp -> f_cred -> user -> unix_inflight -- ;spin_unlock ( & unix_gc_lock ) ;,user -> unix_inflight -- ;spin_unlock ( & unix_gc_lock ) ;,3603
1656,if ( argReg >= regsz ) {},if ( argReg > regsz ) {return ;},3604
1657,"size_t columns ,  number_threads ;number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ;pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads ,  sizeof ( * pixels ) ) ;( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ )  {","size_t columns , rows ;rows = MagickMax ( GetImageListLength ( images ) , ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) ;pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( rows , sizeof ( * pixels ) ) ;columns = images -> columns ;for ( i = 0 ;i ++ ) {",3605
1658,"EVP_MD_CTX_init ( & ctx ) ;if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) {","if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;return - 1 ;}EVP_MD_CTX_init ( & ctx ) ;if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) {",3606
1659,"static void  build_config ( char * prefix , struct server * server )  {int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;path = ss_malloc ( path_size ) ;snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ;FILE * f = fopen ( path , ""w+"" ) ;if ( f == NULL ) {if ( verbose ) {LOGE ( ""unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file"" ) ;}ss_free ( path ) ;return ;}fprintf ( f , ""{\\\fprintf ( f , ""\\\\""server_port\\\\"":%d,\\\fprintf ( f , ""\\\\""password\\\\"":\\\\""%s\\\\"""" , server -> password ) ;if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\\\if ( server -> mode ) fprintf ( f , "",\\\if ( server -> method ) fprintf ( f , "",\\\if ( server -> plugin ) fprintf ( f , "",\\\","static void build_config ( char * prefix , struct manager_ctx * manager , struct server * server ) {int path_size = strlen ( prefix ) + strlen ( server -> plugin ) fprintf ( f , "",\\\",3607
1660,mutex_lock ( & ses -> server -> srv_mutex ) ;if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) {rc = ses -> server -> ops -> generate_signingkey ( ses ) ;kfree ( ses -> auth_key . response ) ;goto keygen_exit ;},mutex_lock ( & ses -> server -> ops -> generate_signingkey ) {rc = ses -> server -> ops -> generate_signingkey ( ses ) ;kfree ( ses -> auth_key . response ) ;return rc ;},3608
1661,ses -> status = CifsGood ;ses -> need_reconnect = false ;spin_unlock ( & GlobalMid_Lock ) ;keygen_exit :  if ( ! ses -> server -> sign ) {kfree ( ses -> auth_key . response ) ;ses -> auth_key . response = NULL ;},"
",3608
1662,if ( type == HUB_INIT2 )  goto init2 ;if ( type == HUB_INIT3 )  goto init3 ;,"if ( type == HUB_INIT2 || type == HUB_INIT3 ) {device_lock ( hub -> intfdev ) ;if ( hub -> disconnected ) {device_unlock ( hub -> intfdev ) ;kref_put ( & hub -> kref , hub_release ) ;return ;}if ( type == HUB_INIT2 ) goto init2 ;goto init3 ;}kref_get ( & hub -> kref ) ;",3609
1663,"
","device_unlock ( hub -> intfdev ) ;if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ;kref_put ( & hub -> kref , hub_release ) ;",3609
1664,return ;},return ;},3609
1665,},},3609
1666,"
","else kvm_iommu_unmap_pages ( kvm , & old ) ;",3610
1667,}r = - ENOMEM ;,}r = - ENOMEM ;,3610
1668,unsigned char buffer [ 3 ] ;int ret ;,"unsigned char * buffer ;int ret ;buffer = kmalloc ( 3 , GFP_KERNEL ) ;if ( ! buffer ) return - ENOMEM ;",3611
1669,return ret ;},kfree ( buffer ) ;return ret ;},3611
1670,"const char * base ;if ( strchr ( part , \'/\' ) ) {base = part ;else {base = isarchive ? config_archivepartitiondir ( part ) : config_partitiondir ( part ) ;}assert ( base != NULL ) ;",const char * base = isarchive ? config_archivepartitiondir ( part ) : config_partitiondir ( part ) ;assert ( base != NULL ) ;,3612
1671,"fprintf ( file , ""<S2SV_blank>%s=\\\\""%s\\\\"""" , tag -> bit_name , tag -> bit_val ) ;}","fputc ( \'<S2SV_blank>\' , file ) ;fputs ( tag -> bit_name , file ) ;fputc ( \'=\' , file ) ;save_quoted ( tag -> bit_val , file ) ;}",3613
1672,"if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) )  break ;","if ( js_doregexec ( J , re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) break ;",3614
1673,"ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;","ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true , NULL ) ;if ( ret != X86EMUL_CONTINUE ) return ret ;",3615
1674,"int vp9_compute_qdelta_by_rate ( const RATE_CONTROL * rc , FRAME_TYPE frame_type ,  int qindex , double rate_target_ratio ) {int target_index = rc -> worst_quality ;const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 ) ;const int target_bits_per_mb = ( int ) ( rate_target_ratio * base_bits_per_mb ) ;target_index = i ;if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 ) <= target_bits_per_mb )  break ;","int vp9_compute_qdelta_by_rate ( const RATE_CONTROL * rc , FRAME_TYPE frame_type , int qindex , double rate_target_ratio , vpx_bit_depth_t bit_depth ) {int target_index = rc -> worst_quality ;const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 , bit_depth ) ;const int target_bits_per_mb = ( int ) ( rate_target_ratio * base_bits_per_mb ) ;if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 , bit_depth ) <= target_bits_per_mb ) {target_index = i ;break ;}",3616
1675,"strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ;","strncpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ;",3617
1676,"s = strchr ( token , \'?\' ) ;if ( s != NULL ) {","s = osStrchr ( token , \'?\' ) ;if ( s != NULL ) {",3618
1677,"if ( ! n || ! buf || ! buf_size ) {datao = 6 + n -> offset ;if ( ( datao + 8 < datao ) || ( datao + 8 < 8 ) || ( datao + 8 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ;return ;}","if ( CHECKOVERFLOW ( datao , buf_size , 8 ) ) {",3619
1678,"if ( ! n -> entries ) {EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataPentax"" , sizeof ( MnotePentaxEntry ) * c ) ;return ;}tcount = 0 ;for ( i = c , o = datao ;i ;-- i , o += 12 ) {size_t s ;if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA ,  ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) ||  ( dataofs + s > buf_size ) ) {","if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ;break ;n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ;n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ;if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components ) {exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components ) ;break ;}if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || ( dataofs + s > buf_size ) ) {exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>"" ""of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ;continue ;}n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ;if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) {",3619
1679,"memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ;return 0 ;}","mutex_lock ( & ue -> card -> user_ctl_lock ) ;memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ;mutex_unlock ( & ue -> card -> user_ctl_lock ) ;return 0 ;}",3620
1680,"err = ops -> cee_peer_getpg ( netdev , & pg ) ;if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PG , sizeof ( pg ) , & pg ) ) goto nla_put_failure ;struct cee_pfc pfc ;err = ops -> cee_peer_getpfc ( netdev , & pfc ) ;","memset ( & pg , 0 , sizeof ( pg ) ) ;err = ops -> cee_peer_getpg ( netdev , & pg ) ;if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PG , sizeof ( pg ) , & pg ) ) goto nla_put_failure ;struct cee_pfc pfc ;memset ( & pfc , 0 , sizeof ( pfc ) ) ;err = ops -> cee_peer_getpfc ( netdev , & pfc ) ;",3621
1681,unsigned facility ;struct option long_options [ ] = {,unsigned facility ;mode_t new_umask_val ;struct option long_options [ ] = {,3622
1682,",  # ifdef _WITH_VRRP_  {",", {""umask"" , required_argument , NULL , \'u\' }, # ifdef _WITH_VRRP_ {",3622
1683,"while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndDRS:f:p:i:mM::g::Gt::""  # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) {","while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndu:DRS:f:p:i:mM::g::Gt::"" # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) {",3622
1684,"
",case \'u\' : new_umask_val = set_umask ( optarg ) ;if ( umask_cmdline ) umask_val = new_umask_val ;break ;,3622
1685,"case \'t\' :  __set_bit ( CONFIG_TEST_BIT , & debug ) ;","case \'t\' : __set_bit ( CONFIG_TEST_BIT , & debug ) ;",3622
1686,return 0 ;},match_data -> cmp = asymmetric_key_cmp ;return 0 ;},3623
1687,"struct address_space * mapping = inode -> i_mapping ;unsigned int blkbits = inode -> i_blkbits ;}if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) {ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ;if ( ret ) return ret ;",unsigned int blkbits = inode -> i_blkbits ;,3624
1688,"truncate_pagecache_range ( inode , start , end - 1 ) ;inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ;ext4_inode_block_unlocked_dio ( inode ) ;inode_dio_wait ( inode ) ;ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size ,  flags , mode ) ;if ( ret ) goto out_dio ;","ext4_inode_block_unlocked_dio ( inode ) ;ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ;up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;if ( ret ) goto out_dio ;",3624
1689,"ap_assert ( stream ) ;if ( ! stream -> has_response ) {if ( name [ 0 ] == \':\' ) {return h2_stream_set_error ( stream ,  HTTP_REQUEST_URI_TOO_LARGE ) ;return h2_stream_set_error ( stream ,   HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ) ;}","int error = 0 ;ap_assert ( stream ) ;if ( stream -> has_response ) {return APR_EINVAL ;}++ stream -> request_headers_added ;if ( name [ 0 ] == \':\' ) {error = HTTP_REQUEST_URI_TOO_LARGE ;error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ;}if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 ) {if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 + 100 ) {return APR_ECONNRESET ;}ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream -> session -> c , ""h2_stream(%ld-%d):<S2SV_blank>too<S2SV_blank>many<S2SV_blank>header<S2SV_blank>lines"" , stream -> session -> id , stream -> id ) ;error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ;}if ( h2_stream_is_scheduled ( stream ) ) {return add_trailer ( stream , error ) ;}else if ( error ) {return h2_stream_set_error ( stream , HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ) ;}",3625
1690,"if ( type == ARPHRD_ETHER )  dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ;else  dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ;","if ( type == ARPHRD_ETHER ) {dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ;dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;}else dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ;",3626
1691,"pte_unmap ( page_table ) ;if ( ! ( flags & FAULT_FLAG_WRITE ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ;","pte_unmap ( page_table ) ;if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS ;if ( ! ( flags & FAULT_FLAG_WRITE ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ;",3627
1692,"if ( * p == FAC_CCITT_DEST_NSAP ) {memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ;","if ( l < 10 || l > 20 ) return - 1 ;if ( * p == FAC_CCITT_DEST_NSAP ) {memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ;",3628
1693,"if ( cluster != fs -> clusters - 1 )  get_fat ( & subseqEntry , fs -> fat , cluster + 1 , fs ) ;","if ( cluster != fs -> clusters + 1 ) get_fat ( & subseqEntry , fs -> fat , cluster + 1 , fs ) ;",3629
1694,"
","value = get_map_string_item_or_NULL ( settings , ""PrivateReports"" ) ;if ( value ) {g_settings_privatereports = string_to_bool ( value ) ;remove_map_string_item ( settings , ""PrivateReports"" ) ;}",3630
1695,GHashTableIter iter ;const char * name ;,GHashTableIter iter ;const char * name ;,3630
1696,if ( split_flag ) {int new_size = size / 2 ;,if ( split_flag && size >= MIN_BLOCK_SIZE ) {int new_size = size / 2 ;,3631
1697,int size ;int depth = 0 ;,int size ;int base_size ;int depth = 0 ;,3632
1698,"size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ;path = ( PATH * ) palloc ( size ) ;SET_VARSIZE ( path , size ) ;path -> npts = npts ;if ( ( ! path_decode ( TRUE , npts , s , & isopen , & s , & ( path -> p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == \'\\\\0\' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\\\""%s\\\\"""" , str ) ) ) ;","base_size = sizeof ( path -> p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ;size = offsetof ( PATH , p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == \'\\\\0\' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\\\""%s\\\\"""" , str ) ) ) ;",3632
1699,while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) &&  ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error )  {,while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) {,3633
1700,"if ( optstr ) {jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\\return 0 ;}","image = 0 ;info = 0 ;if ( optstr ) {jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\\goto error ;}",3634
1701,"return 0 ;}JAS_DBGLOG ( 1 ,  ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>""  ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>""  ""mincolors<S2SV_blank>%d\\\if ( ! bmp_issupported ( & hdr , info ) ) {bmp_info_destroy ( info ) ;return 0 ;return 0 ;}bmp_info_destroy ( info ) ;return 0 ;","goto error ;}JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\\if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) {jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\\goto error ;}if ( ! bmp_issupported ( & hdr , info ) ) {goto error ;goto error ;}goto error ;",3634
1702,bmp_info_destroy ( info ) ;return 0 ;,goto error ;,3634
1703,bmp_info_destroy ( info ) ;jas_image_destroy ( image ) ;return 0 ;}bmp_info_destroy ( info ) ;return image ;,goto error ;}bmp_info_destroy ( info ) ;return image ;error : if ( info ) {bmp_info_destroy ( info ) ;}if ( image ) {jas_image_destroy ( image ) ;}return 0 ;,3634
1704,"void * dllhandle ;if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\","void * dllhandle ;if ( COM_CompareExtension ( name , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , name ) ;return NULL ;}if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\",3635
1705,ssize_t ret ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,ssize_t ret ;if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( len < sizeof ( hdr ) ) return - EINVAL ;,3636
1706,if ( tag == 0 ) {if ( data [ dp ++ ] != 0 ) goto invalid_eoc ;,if ( tag == ASN1_EOC ) {if ( data [ dp ++ ] != 0 ) goto invalid_eoc ;,3637
1707,if ( len <= 0x7f ) {dp += len ;goto next_tag ;}if ( unlikely ( n > sizeof ( size_t ) - 1 ) )  goto length_too_long ;for ( len = 0 ;len <<= 8 ;dp += len ;goto next_tag ;,if ( len <= 0x7f ) goto check_length ;if ( unlikely ( n > sizeof ( len ) - 1 ) ) goto length_too_long ;len = 0 ;for ( ;len <<= 8 ;check_length : if ( len > datalen - dp ) goto data_overrun_error ;dp += len ;goto next_tag ;,3637
1708,"rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE ,  GFP_KERNEL ) ;","rinfo = kzalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , GFP_KERNEL ) ;",3638
1709,if ( ! is_launcher )  {if ( nautilus_file_can_execute ( file ) )  {,"g_autofree gchar * trusted = NULL ;if ( ! is_launcher ) {trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ;if ( nautilus_file_can_execute ( file ) && trusted != NULL ) {",3639
1710,commonlen = COMPUTESIZE ( state . num ) ;query = ( QUERYTYPE * ) palloc ( commonlen ) ;,"if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;commonlen = COMPUTESIZE ( state . num ) ;query = ( QUERYTYPE * ) palloc ( commonlen ) ;",3640
1711,"if ( strcmp ( f -> file , ""tasks"" ) == 0 || strcmp ( f -> file , ""/tasks"" ) == 0 || strcmp ( f -> file , ""/cgroup.procs"" ) == 0 || strcmp ( f -> file , ""cgroup.procs"" ) == 0 )  r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ;else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ;","if ( strcmp ( f -> file , ""tasks"" ) == 0 || strcmp ( f -> file , ""/tasks"" ) == 0 || strcmp ( f -> file , ""/cgroup.procs"" ) == 0 || strcmp ( f -> file , ""cgroup.procs"" ) == 0 ) r = do_write_pids ( fc -> pid , fc -> uid , f -> controller , f -> cgroup , f -> file , localbuf ) ;else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ;",3641
1712,"void vp9_idct16x16_add ( const int16_t * input , uint8_t * dest , int stride ,  int eob ) {if ( eob == 1 )  vp9_idct16x16_1_add ( input , dest , stride ) ;else if ( eob <= 10 )  vp9_idct16x16_10_add ( input , dest , stride ) ;else  vp9_idct16x16_256_add ( input , dest , stride ) ;}","void vp9_idct16x16_add ( const tran_low_t * input , uint8_t * dest , int stride , int eob ) {if ( eob == 1 ) vpx_idct16x16_1_add ( input , dest , stride ) ;else if ( eob <= 10 ) vpx_idct16x16_10_add ( input , dest , stride ) ;else vpx_idct16x16_256_add ( input , dest , stride ) ;}",3642
1713,uint16_t mus_freq = 0 ;uint8_t mus_event [ ] = {uint8_t mus_event_size = 0 ;,# define MUS_SZ 4 uint16_t mus_freq = 0 ;uint8_t mus_event [ MUS_SZ ] = {uint8_t mus_event_size = 0 ;,3643
1714,"setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ;if ( setup_ret == 0 ) {","setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , MUS_SZ , 0 ) ;if ( setup_ret == 0 ) {",3643
1715,"gdImagePtr im ;char * buffer ;size_t size ;size = read_test_file ( & buffer , ""heap_overflow.tga"" ) ;im = gdImageCreateFromTgaPtr ( size , ( void * ) buffer ) ;gdTestAssert ( im == NULL ) ;free ( buffer ) ;","check_file ( ""heap_overflow_1.tga"" ) ;check_file ( ""heap_overflow_2.tga"" ) ;",3644
1716,"if ( rc < 0 )   dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\\","if ( rc != KLSI_STATUSBUF_LEN ) {dev_err ( & port -> dev , ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\\if ( rc >= 0 ) rc = - EIO ;}",3645
1717,"static int  l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 )   {if ( tl1 > l2 ) return 0 ;","static int l_strnstart ( netdissect_options * ndo , const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) {if ( ! ND_TTEST2 ( * str2 , tl1 ) ) {return 0 ;}if ( tl1 > l2 ) return 0 ;",3646
1718,"queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ;queue_remove_all ( att -> ind_queue , NULL , NULL , disc_att_send_op ) ;queue_remove_all ( att -> write_queue , NULL , NULL , disc_att_send_op ) ;","
",3647
1719,"queue_foreach ( att -> disconn_list , disconn_handler , INT_TO_PTR ( err ) ) ;bt_att_unregister_all ( att ) ;","att -> in_disc = true ;queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ;queue_remove_all ( att -> ind_queue , NULL , NULL , disc_att_send_op ) ;queue_remove_all ( att -> write_queue , NULL , NULL , disc_att_send_op ) ;att -> in_disc = false ;queue_foreach ( att -> disconn_list , disconn_handler , INT_TO_PTR ( err ) ) ;bt_att_unregister_all ( att ) ;",3647
1720,"static int read_skip ( VP9_COMMON * cm , const MACROBLOCKD * xd ,  int segment_id , vp9_reader * r ) {if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) {return 1 ;const int skip = vp9_read ( r , cm -> fc . skip_probs [ ctx ] ) ;if ( ! cm -> frame_parallel_decoding_mode )  ++ cm -> counts . skip [ ctx ] [ skip ] ;","static int read_skip ( VP9_COMMON * cm , const MACROBLOCKD * xd , int segment_id , vpx_reader * r ) {if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) {return 1 ;const int skip = vpx_read ( r , cm -> fc -> skip_probs [ ctx ] ) ;FRAME_COUNTS * counts = xd -> counts ;if ( counts ) ++ counts -> skip [ ctx ] [ skip ] ;",3648
1721,"return xfrm6_rcv_spi ( skb , spi ) ;}","return xfrm6_rcv_spi ( skb , spi ) > 0 ? : 0 ;}",3649
1722,OPJ_UNUSED ( p_manager ) ;if ( p_total_data_size < 12 ) {,if ( p_total_data_size < 12 ) {,3650
1723,size_t mask = ( size_t ) self -> mt_mask ;PyMemoEntry * table = self -> mt_table ;,size_t mask = self -> mt_mask ;PyMemoEntry * table = self -> mt_table ;,3651
1724,"static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , const char * ident , uint16_t afi ) {char ident_buffer [ 20 ] ;uint8_t prefix [ sizeof ( struct in6_addr ) ] ;u_int metric , status_byte , bit_length , byte_length , sublen , processed , subtlvtype , subtlvlen ;if ( ! ND_TTEST2 ( * tptr , 4 ) ) return ( 0 ) ;","static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , 2 ) ) return ( 0 ) ;",3652
1725,"if ( ! ND_TTEST2 ( * tptr , 1 ) )  return ( 0 ) ;","if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ;",3652
1726,"
",mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;,3653
1727,ops -> destroy ( dev ) ;mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;,ops -> destroy ( dev ) ;,3653
1728,"char * pin , * pout ;if ( ! icv_utf16_to_local ) {","char * pin , * pout ;struct stream packet = * s ;if ( ( in_len < 0 ) || ( ( uint32 ) in_len >= ( RD_UINT32_MAX / 2 ) ) ) {logger ( Protocol , Error , ""rdp_in_unistr(),<S2SV_blank>length<S2SV_blank>of<S2SV_blank>unicode<S2SV_blank>data<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" ) ;abort ( ) ;}if ( ! s_check_rem ( s , in_len ) ) {rdp_protocol_error ( ""rdp_in_unistr(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>unicode<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}if ( ! icv_utf16_to_local ) {",3654
1729,if ( map_info -> channel_map != NULL )  {size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ;free ( psf -> channel_map ) ;,"if ( map_info -> channel_map != NULL ) {size_t chanmap_size = SF_MIN ( psf -> sf . channels , layout_tag & 0xffff ) * sizeof ( psf -> channel_map [ 0 ] ) ;free ( psf -> channel_map ) ;",3655
1730,"}else if ( ! strncmp ( network_line , ""GET_DN<S2SV_blank>"" , strlen ( ""GET_DN<S2SV_blank>"" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) {univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:<S2SV_blank>GET_DN"" ) ;","}else if ( ! strncmp ( network_line , ""GET_DN<S2SV_blank>"" , strlen ( ""GET_DN<S2SV_blank>"" ) ) && msg_id != UINT32_MAX && version > PROTOCOL_UNKNOWN && version < PROTOCOL_3 ) {univention_debug ( UV_DEBUG_TRANSFILE , UV_DEBUG_ALL , ""RECV:<S2SV_blank>GET_DN"" ) ;",3656
1731,vp9_ppflags_t flags = {0 };if ( ctx -> preview_ppcfg . post_proc_flag ) {,vp9_ppflags_t flags ;vp9_zero ( flags ) ;if ( ctx -> preview_ppcfg . post_proc_flag ) {,3657
1732,if ( ! addr || addr -> sa_family != AF_BLUETOOTH )  return - EINVAL ;,if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ;if ( addr_len < sizeof ( struct sockaddr_sco ) ) return - EINVAL ;,3658
1733,"if ( unlikely ( in_interrupt ( ) ) ) panic ( ""Aiee,<S2SV_blank>killing<S2SV_blank>interrupt<S2SV_blank>handler!"" ) ;if ( unlikely ( ! tsk -> pid ) ) panic ( ""Attempted<S2SV_blank>to<S2SV_blank>kill<S2SV_blank>the<S2SV_blank>idle<S2SV_blank>task!"" ) ;tracehook_report_exit ( & code ) ;if ( unlikely ( tsk -> flags & PF_EXITING ) ) {printk ( KERN_ALERT ""Fixing<S2SV_blank>recursive<S2SV_blank>fault<S2SV_blank>but<S2SV_blank>reboot<S2SV_blank>is<S2SV_blank>needed!\\\tsk -> flags |= PF_EXITPIDONE ;if ( tsk -> io_context ) exit_io_context ( ) ;set_current_state ( TASK_UNINTERRUPTIBLE ) ;schedule ( ) ;}exit_signals ( tsk ) ;smp_mb ( ) ;spin_unlock_wait ( & tsk -> pi_lock ) ;if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO ""note:<S2SV_blank>%s[%d]<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>preempt_count<S2SV_blank>%d\\\acct_update_integrals ( tsk ) ;if ( tsk -> mm ) {update_hiwater_rss ( tsk -> mm ) ;update_hiwater_vm ( tsk -> mm ) ;}group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ;if ( group_dead ) {hrtimer_cancel ( & tsk -> signal -> real_timer ) ;exit_itimers ( tsk -> signal ) ;}acct_collect ( code , group_dead ) ;# ifdef CONFIG_FUTEX   if ( unlikely ( tsk -> robust_list ) )  exit_robust_list ( tsk ) ;# ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ;# endif # endif if ( group_dead ) tty_audit_exit ( ) ;if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ;tsk -> exit_code = code ;taskstats_exit ( tsk , group_dead ) ;exit_mm ( tsk ) ;if ( group_dead ) acct_process ( ) ;trace_sched_process_exit ( tsk ) ;exit_sem ( tsk ) ;exit_files ( tsk ) ;exit_fs ( tsk ) ;check_stack_usage ( ) ;exit_thread ( ) ;cgroup_exit ( tsk , 1 ) ;exit_keys ( tsk ) ;if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ;module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ;if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ;proc_exit_connector ( tsk ) ;exit_notify ( tsk , group_dead ) ;# ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ;tsk -> mempolicy = NULL ;# endif # ifdef CONFIG_FUTEX if ( unlikely ( ! list_empty ( & tsk -> pi_state_list ) ) ) exit_pi_state_list ( tsk ) ;",if ( unlikely ( ! list_empty ( & tsk -> pi_state_list ) ) ) exit_pi_state_list ( tsk ) ;,3659
1734,"in_uint16_le ( s , type ) ;in_uint16_le ( s , status ) ;if ( status == CLIPRDR_ERROR )  {","struct stream packet = * s ;in_uint16_le ( s , type ) ;in_uint16_le ( s , status ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}if ( status == CLIPRDR_ERROR ) {",3660
1735,"if ( ! mp -> ports && ! mp -> mglist &&  netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;","if ( ! mp -> ports && ! mp -> mglist && mp -> timer_armed && netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;",3661
1736,"cleanup :  assert ( status != NULL ) ;if ( reply_key ) krb5_free_keyblock ( kdc_context , reply_key ) ;","cleanup : if ( status == NULL ) status = ""UNKNOWN_REASON"" ;if ( reply_key ) krb5_free_keyblock ( kdc_context , reply_key ) ;",3662
1737,"netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\\return - EINVAL ;netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\\return - EINVAL ;","netdev_err ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;netdev_err ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\\netbk_fatal_tx_err ( vif ) ;return - EINVAL ;",3663
1738,"struct mb_cache_entry * ce = NULL ;int error = 0 ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;if ( ce )  mb_cache_entry_free ( ce ) ;if ( ce )  mb_cache_entry_release ( ce ) ;","int error = 0 ;struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ;__u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ;ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr ) ;",3664
1739,"if ( ! sctp_verify_asconf ( asoc ,  ( sctp_paramhdr_t * ) addip_hdr -> params ,  ( void * ) asconf_ack -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;","if ( ! sctp_verify_asconf ( asoc , asconf_ack , false , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ;",3665
1740,for ( vma = mm -> mmap ;vma = vma -> vm_next )  if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) {,VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;for ( vma = mm -> mmap ;vma = vma -> vm_next ) if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) {,3666
1741,"case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR :  ip_printroute ( ndo , cp , option_len ) ;break ;","case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ;break ;",3667
1742,"request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;request_buf . value = buf2 ;","request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 , sizeof ( buf2 ) ) ;request_buf . value = buf2 ;",3668
1743,"request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;request_buf . value = buf2 ;","request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 , sizeof ( buf2 ) ) ;request_buf . value = buf2 ;",3668
1744,"
",if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) {return ( - 1 ) ;},3669
1745,unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ;},unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ;},3669
1746,char * tmpptr = key + strlen ( key ) ;* tmpptr = \'=\' ;,char * tmpptr = key + strlen ( key ) ;* tmpptr = \'=\' ;,3670
1747,atomic_inc ( & sb -> s_active ) ;mnt -> mnt . mnt_sb = sb ;,if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;atomic_inc ( & sb -> s_active ) ;mnt -> mnt . mnt_sb = sb ;,3671
1748,"sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ;","sigev_none = timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ;kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ;",3672
1749,"VP9_COMMON * const cm = & cpi -> common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;FRAME_CONTEXT * const fc = & cm -> fc ;vp9_writer header_bc ;vp9_start_encode ( & header_bc , data ) ;else  encode_txfm_probs ( cm , & header_bc ) ;update_coef_probs ( cpi , & header_bc ) ;update_skip_probs ( cm , & header_bc ) ;if ( ! frame_is_intra_only ( cm ) ) {++ i )  prob_diff_update ( vp9_inter_mode_tree , cm -> fc . inter_mode_probs [ i ] ,   cm -> counts . inter_mode [ i ] , INTER_MODES , & header_bc ) ;vp9_zero ( cm -> counts . inter_mode ) ;if ( cm -> interp_filter == SWITCHABLE )  update_switchable_interp_probs ( cm , & header_bc ) ;for ( i = 0 ;i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> intra_inter_prob [ i ] ,  cm -> counts . intra_inter [ i ] ) ;if ( cm -> allow_comp_inter_inter ) {const int use_compound_pred = cm -> reference_mode != SINGLE_REFERENCE ;vp9_write_bit ( & header_bc , use_compound_pred ) ;if ( use_compound_pred ) {vp9_write_bit ( & header_bc , use_hybrid_pred ) ;if ( use_hybrid_pred ) for ( i = 0 ;i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_inter_prob [ i ] ,  cm -> counts . comp_inter [ i ] ) ;}vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 0 ] ,  cm -> counts . single_ref [ i ] [ 0 ] ) ;vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 1 ] ,  cm -> counts . single_ref [ i ] [ 1 ] ) ;}i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_ref_prob [ i ] ,  cm -> counts . comp_ref [ i ] ) ;for ( i = 0 ;++ i )  prob_diff_update ( vp9_intra_mode_tree , cm -> fc . y_mode_prob [ i ] ,   cm -> counts . y_mode [ i ] , INTRA_MODES , & header_bc ) ;for ( i = 0 ;i < PARTITION_CONTEXTS ;++ i ) prob_diff_update ( vp9_partition_tree , fc -> partition_prob [ i ] ,  cm -> counts . partition [ i ] , PARTITION_TYPES , & header_bc ) ;vp9_write_nmv_probs ( cm , cm -> allow_high_precision_mv , & header_bc ) ;}vp9_stop_encode ( & header_bc ) ;assert ( header_bc . pos <= 0xffff ) ;","VP9_COMMON * const cm = & cpi -> td . common ;MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;FRAME_CONTEXT * const fc = cm -> fc ;FRAME_COUNTS * counts = cpi -> td . counts ;vpx_writer header_bc ;vpx_start_encode ( & header_bc , data ) ;else encode_txfm_probs ( cm , & header_bc , counts ) ;update_coef_probs ( cpi , & header_bc , counts ) ;update_skip_probs ( cm , & header_bc ) ;if ( ! frame_is_intra_only ( cm ) ) {+ i )  prob_diff_update ( vp9_inter_mode_tree , cm -> fc . inter_mode_probs [ i ] ,   cm -> counts . inter_mode [ i ] , INTER_MODES , & header_bc ) ;++ i ) prob_diff_update ( vp9_inter_mode_tree , cm -> fc -> inter_mode_probs [ i ] , cm -> counts . inter_mode [ i ] , INTER_MODES , & header_bc ) ;if ( cm -> interp_filter == SWITCHABLE ) update_switchable_interp_probs ( cm , & header_bc , counts ) ;for ( i = 0 ;i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> intra_inter_prob [ i ] , counts -> intra_inter [ i ] ) ;if ( cpi -> allow_comp_inter_inter ) {const int use_compound_pred = cm -> reference_mode != SINGLE_REFERENCE ;vpx_write_bit ( & header_bc , use_compound_pred ) ;if ( use_compound_pred ) {vpx_write_bit ( & header_bc , use_hybrid_pred ) ;if ( use_hybrid_pred ) for ( i = 0 ;i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_inter_prob [ i ] , counts -> comp_inter [ i ] ) ;}vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 0 ] , counts -> single_ref [ i ] [ 0 ] ) ;vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 1 ] , counts -> single_ref [ i ] [ 1 ] ) ;}i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_ref_prob [ i ] , counts -> comp_ref [ i ] ) ;for ( i = 0 ;+ i )  prob_diff_update ( vp9_intra_mode_tree , cm -> fc . y_mode_prob [ i ] ,   cm -> counts . y_mode [ i ] , INTRA_MODES , & header_bc ) ;+ i ) prob_diff_update ( vp9_partition_tree , fc -> partition_prob [ i ] ,  cm -> counts . partition [ i ] , PARTITION_TYPES , & header_bc ) ;++ i ) prob_diff_update ( vp9_intra_mode_tree , cm -> fc -> y_mode_prob [ i ] , cm -> counts . y_mode [ i ] , counts -> partition [ i ] , PARTITION_TYPES , & header_bc , & counts -> mv ) ;vp9_write_nmv_probs ( cm , cm -> allow_high_precision_mv , & header_bc ) ;}vp9_stop_encode ( & header_bc ) ;assert ( header_bc . pos <= 0xffff ) ;",3673
1750,"if ( packet -> payload_packet_len >= 40 ) {if ( packet -> tcp != NULL )  ovpn_payload += 2 ;opcode = ovpn_payload [ 0 ] & P_OPCODE_MASK ;# ifdef DEBUG printf ( ""[packet_id:<S2SV_blank>%u][opcode:<S2SV_blank>%u][Packet<S2SV_blank>ID:<S2SV_blank>%d][%u<S2SV_blank><-><S2SV_blank>%u][len:<S2SV_blank>%u]\\\# endif if ( ( flow -> num_processed_pkts == 1 ) && (  ( ( packet -> payload_packet_len == 112 )  && ( ( opcode == 168 ) || ( opcode == 192 ) ) )  || ( ( packet -> payload_packet_len == 80 )  && ( ( opcode == 184 ) || ( opcode == 88 ) || ( opcode == 160 ) || ( opcode == 168 ) || ( opcode == 200 ) ) ) ) ) {","int16_t ovpn_payload_len = packet -> payload_packet_len ;if ( ovpn_payload_len >= 40 ) {if ( packet -> tcp != NULL ) ovpn_payload += 2 , ovpn_payload_len -= 2 ;;opcode = ovpn_payload [ 0 ] & P_OPCODE_MASK ;# ifdef DEBUG printf ( ""[packet_id:<S2SV_blank>%u][opcode:<S2SV_blank>%u][Packet<S2SV_blank>ID:<S2SV_blank>%d][%u<S2SV_blank><-><S2SV_blank>%u][len:<S2SV_blank>%u]\\\# endif if ( ( flow -> num_processed_pkts == 1 ) && ( ( ( ovpn_payload_len == 112 ) && ( ( opcode == 168 ) || ( opcode == 192 ) ) ) || ( ( ovpn_payload_len == 80 ) && ( ( opcode == 184 ) || ( opcode == 88 ) || ( opcode == 160 ) || ( opcode == 168 ) || ( opcode == 200 ) ) ) ) ) {",3674
1751,"
",u_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ;,3674
1752,"alen = ovpn_payload [ P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ] ;if ( alen > 0 ) {session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) + 1 + alen * 4 ;if ( memcmp ( flow -> ovpn_session_id , session_remote , 8 ) == 0 ) {NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>openvpn\\\}}","alen = ovpn_payload [ offset ] ;if ( alen > 0 ) {offset += 1 + alen * 4 ;if ( ( offset + 8 ) <= ovpn_payload_len ) {session_remote = & ovpn_payload [ offset ] ;if ( memcmp ( flow -> ovpn_session_id , session_remote , 8 ) == 0 ) {NDPI_LOG_INFO ( ndpi_struct , ""found<S2SV_blank>openvpn\\\}}else failed = 1 ;}",3674
1753,case 0x2f8 :  return true ;,"
",3675
1754,return TRUE ;},if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;return TRUE ;},3676
1755,if ( ( data & ~ mask ) != PSW_USER_BITS )  return - EINVAL ;,if ( ( data ^ PSW_USER_BITS ) & ~ mask ) return - EINVAL ;if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME ) return - EINVAL ;,3677
1756,"vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;vp8_clear_system_state ( ) ;vpx_memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ;cpi -> twopass . kf_group_bits = 0 ;","memset ( & next_frame , 0 , sizeof ( next_frame ) ) ;vp8_clear_system_state ( ) ;memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ;cpi -> twopass . kf_group_bits = 0 ;",3678
1757,"vpx_memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ;input_stats ( cpi , this_frame ) ;","memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ;input_stats ( cpi , this_frame ) ;",3678
1758,"vpx_memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ;reset_fpf_position ( cpi , start_position ) ;","memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ;reset_fpf_position ( cpi , start_position ) ;",3678
1759,boost_score = 0.0 ;loop_decay_rate = 1.00 ;,boost_score = 0.0 ;,3678
1760,int projected_buffer_level = ( int ) cpi -> buffer_level ;int tmp_q ;,int projected_buffer_level ;int tmp_q ;,3678
1761,"const uint8_t * end , * ptr = avpkt -> data ;int ncolors , cpp , ret , i , j ;end = avpkt -> data + avpkt -> size ;while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 )  ptr ++ ;if ( ptr >= end ) {","const uint8_t * end , * ptr ;int ncolors , cpp , ret , i , j ;av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ;if ( ! x -> buf ) return AVERROR ( ENOMEM ) ;memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ;x -> buf [ avpkt -> size ] = 0 ;ptr = x -> buf ;end = x -> buf + avpkt -> size ;while ( end - ptr > 9 && memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) ) ptr ++ ;if ( end - ptr <= 9 ) {",3679
1762,"i ++ )  size *= 94 ;if ( ncolors <= 0 || ncolors > size ) {if ( ! x -> pixels ) return AVERROR ( ENOMEM ) ;ptr += mod_strcspn ( ptr , "","" ) + 1 ;for ( i = 0 ;const uint8_t * index ;if ( ptr + cpp > end )  return AVERROR_INVALIDDATA ;",i ++ ) size *= 95 ;if ( ncolors <= 0 || ncolors > size ) {if ( end - ptr < cpp ) return AVERROR_INVALIDDATA ;for ( i = 0 ;const uint8_t * index ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;if ( ptr + cpp > end ) return AVERROR_INVALIDDATA ;,3679
1763,"}for ( i = 0 ;ptr += mod_strcspn ( ptr , ""\\\\"""" ) + 1 ;for ( j = 0 ;if ( ptr + cpp > end )  return AVERROR_INVALIDDATA ;","}for ( i = 0 ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;ptr += mod_strcspn ( ptr , ""\\\\"""" ) + 1 ;if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ;for ( j = 0 ;if ( end - ptr < cpp ) return AVERROR_INVALIDDATA ;",3679
1764,"static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags ,  struct in6_addr * addr , uint32_t * ifindex )  {unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;struct iovec iovec ;","static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags , struct in6_addr * addr , uint32_t * ifindex , int * hoplimit ) {unsigned char cbuf [ 2 * CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ;struct iovec iovec ;",3680
1765,if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 &&   cmsghdr -> cmsg_type == IPV6_PKTINFO &&  cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) {}* addr = sin6 . sin6_addr ;,if ( cmsghdr -> cmsg_level != IPPROTO_IPV6 ) continue ;switch ( cmsghdr -> cmsg_type ) {case IPV6_PKTINFO : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) {break ;case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) {int * val ;val = ( int * ) CMSG_DATA ( cmsghdr ) ;* hoplimit = * val ;}break ;}}* addr = sin6 . sin6_addr ;,3680
1766,"if ( ep_loop_check ( ep , tfile ) != 0 )   goto error_tgt_fput ;}","if ( ep_loop_check ( ep , tfile ) != 0 ) {clear_tfile_check_list ( ) ;goto error_tgt_fput ;}}",3681
1767,"dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\\","dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\\",3682
1768,"mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\\if ( table -> total == table -> max ) {","if ( free < 0 ) {err = - ENOMEM ;goto out ;}mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\\if ( table -> total == table -> max ) {",3683
1769,unsigned facility ;struct option long_options [ ] = {,unsigned facility ;mode_t new_umask_val ;struct option long_options [ ] = {,3684
1770,",  # ifdef _WITH_VRRP_  {",", {""umask"" , required_argument , NULL , \'u\' }, # ifdef _WITH_VRRP_ {",3684
1771,"while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndDRS:f:p:i:mM::g::Gt::""  # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) {","while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndu:DRS:f:p:i:mM::g::Gt::"" # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) {",3684
1772,"
",case \'u\' : new_umask_val = set_umask ( optarg ) ;if ( umask_cmdline ) umask_val = new_umask_val ;break ;,3684
1773,"case \'t\' :  __set_bit ( CONFIG_TEST_BIT , & debug ) ;","case \'t\' : __set_bit ( CONFIG_TEST_BIT , & debug ) ;",3684
1774,"strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ;","strncpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ;if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ;",3685
1775,"int x , y , pos ;Wbmp * wbmp ;if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) {gd_error ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP"" ) ;return ;}pos = 0 ;for ( y = 0 ;y < gdImageSY ( image ) ;y ++ ) {for ( x = 0 ;x < gdImageSX ( image ) ;x ++ ) {if ( gdImageGetPixel ( image , x , y ) == fg ) {wbmp -> bitmap [ pos ] = WBMP_BLACK ;","_gdImageWBMPCtx ( image , x , y ) == fg ) {wbmp -> bitmap [ pos ] = WBMP_BLACK ;",3686
1776,"MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;int mb_y_offset = 0 , arf_y_offset = 0 , gld_y_offset = 0 ;int_mv arf_top_mv , gld_top_mv ;MODE_INFO mi_local = {arf_top_mv . as_int = 0 ;","MACROBLOCK * const x = & cpi -> td . mb ;MACROBLOCKD * const xd = & x -> e_mbd ;MV gld_top_mv = {0 , 0 };MODE_INFO mi_local = {arf_top_mv . as_int = 0 ;",3687
1777,"int_mv arf_left_mv , gld_left_mv ;int mb_y_in_offset = mb_y_offset ;int gld_y_in_offset = gld_y_offset ;arf_left_mv . as_int = arf_top_mv . as_int ;gld_left_mv . as_int = gld_top_mv . as_int ;",MV gld_left_mv = gld_top_mv ;int mb_y_in_offset = mb_y_offset ;int gld_y_in_offset = gld_y_offset ;,3687
1778,arf_left_mv . as_int = mb_stats -> ref [ ALTREF_FRAME ] . m . mv . as_int ;gld_left_mv . as_int = mb_stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int ;arf_top_mv . as_int = arf_left_mv . as_int ;gld_top_mv . as_int = gld_left_mv . as_int ;,gld_left_mv = mb_stats -> ref [ ALTREF_FRAME ] . m . mv . as_int ;gld_left_mv . as_int = mb_stats -> ref [ GOLDEN_FRAME ] . m . mv . as_mv ;gld_top_mv = gld_left_mv ;,3687
1779,"D ( printf ( ""Token<S2SV_blank>%s/\\\'%s\\\'<S2SV_blank>...<S2SV_blank>"" , _PyParser_TokenNames [ type ] , str ) ) ;","D ( printf ( ""<S2SV_blank>Push<S2SV_blank>\\\'%s\\\'\\\",3688
1780,"dfa * d1 = PyGrammar_FindDFA (  ps -> p_grammar , nt ) ;D ( printf ( ""<S2SV_blank>Push<S2SV_blank>...\\\continue ;","dfa * d1 ;if ( nt == func_body_suite && ! ( ps -> p_flags & PyCF_TYPE_COMMENTS ) ) {D ( printf ( ""<S2SV_blank>[switch<S2SV_blank>func_body_suite<S2SV_blank>to<S2SV_blank>suite]"" ) ) ;nt = suite ;}d1 = PyGrammar_FindDFA ( ps -> p_grammar , nt ) ;D ( printf ( ""<S2SV_blank>Push<S2SV_blank>...\\\continue ;",3688
1781,"char buffer [ 64 ] = {, rdnSeqBuf [ 1024 ] = {u_int rdn_len = 0 ;","char buffer [ 64 ] = {, rdnSeqBuf [ 2048 ] = {u_int rdn_len = 0 ;",3689
1782,"if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pflags ) != IS_LONG ) {","if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) {zval_ptr_dtor ( & intern -> array ) ;",3690
1783,"if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) {goto outexcept ;","if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) {goto outexcept ;",3690
1784,"if ( jp2_getuint16 ( in , & pclr -> numlutents ) ||  jp2_getuint8 ( in , & pclr -> numchans ) ) {","pclr -> bpc = 0 ;if ( jp2_getuint16 ( in , & pclr -> numlutents ) || jp2_getuint8 ( in , & pclr -> numchans ) ) {",3691
1785,"static void accumulate_frame_motion_stats (  FIRSTPASS_STATS * this_frame ,   double * this_frame_mv_in_out ,  double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) {double motion_pct ;motion_pct = this_frame -> pcnt_motion ;* this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ;* mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ;* abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ;if ( motion_pct > 0.05 ) {const double this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) /   DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ;const double this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) /   DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ;* mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs )   ? ( this_frame_mvr_ratio * motion_pct )  : this_frame -> mvr_abs * motion_pct ;* mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs )   ? ( this_frame_mvc_ratio * motion_pct )  : this_frame -> mvc_abs * motion_pct ;","static void accumulate_frame_motion_stats ( const FIRSTPASS_STATS * stats , double * this_frame_mv_in_out , double * mv_in_out , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) {const double pct = stats -> pcnt_motion ;* this_frame_mv_in_out = this_frame -> mv_in_out_count * pct ;* mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ;* abs_mv_in_out_accumulator += fabs ( * mv_in_out ) ;if ( motion_pct > 0.05 ) {const double mvr_ratio = fabs ( this_frame -> mvr_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ;const double this_frame_mvc_ratio = fabs ( stats -> mvr_abs ) ? ( this_frame_mvr_ratio * motion_pct ) : this_frame -> mvr_abs * motion_pct ;* mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) ? ( this_frame_mvc_ratio * motion_pct ) : this_frame -> mvc_abs * motion_pct ;",3692
1786,"if ( readonly &&  ( ( flags & O_ACCMODE ) == O_WRONLY ||   ( flags & O_ACCMODE ) == O_RDWR ) ) {verbose ( ""Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode"" ) ;","if ( readonly && ( ( flags & O_ACCMODE ) != O_RDONLY || ( flags & O_ACCMODE ) == O_RDWR ) ) {verbose ( ""Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode"" ) ;",3693
1787,"assert_true_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" ,  NULL ) ;","assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>\\\\\"" , NULL ) ;",3694
1788,"assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" ,  NULL ) ;assert_false_rule (  ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" ,  NULL ) ;","assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_false_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""foo\\\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\\\""bar\\\\"")<S2SV_blank>==<S2SV_blank>-1\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\\\""FOO\\\\\\\"" , NULL ) ;assert_true_rule ( ""import<S2SV_blank>\\\\""tests\\\\""<S2SV_blank>\\\\\<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\\\""FOO\\\\\\\"" , NULL ) ;",3694
1789,"char common_name [ FIELD_SIZE + 1 ] ;SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ;X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ;# ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , common_name , FIELD_SIZE , 0 , NULL ) == 1 ) cert_valid = 1 ;# else if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , FIELD_SIZE ) == 0 ) cert_valid = 1 ;","SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ;X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ;# ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ;# else char common_name [ FIELD_SIZE + 1 ] ;if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , FIELD_SIZE ) == 0 ) cert_valid = 1 ;",3695
1790,pipe -> curbuf = 0 ;kfree ( pipe -> bufs ) ;,"account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;pipe -> curbuf = 0 ;kfree ( pipe -> bufs ) ;",3696
1791,static char buf [ 256 ] ;int buflen = 0 ;,"static char buf [ 1024 + 1 ] ;char * bufp = buf ;size_t space_left = sizeof ( buf ) , string_size ;",3697
1792,"buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , ""%s%s"" ,   sepstr , lp -> s ) ;sepstr = sep ;if ( buflen == 0 )  ( void ) snprintf ( buf , sizeof ( buf ) , fmt == NULL ? ""#%08x"" : fmt , v ) ;","if ( space_left <= 1 ) return ( buf ) ;string_size = strlcpy ( bufp , sepstr , space_left ) ;if ( string_size >= space_left ) return ( buf ) ;bufp += string_size ;space_left -= string_size ;if ( space_left <= 1 ) return ( buf ) ;string_size = strlcpy ( bufp , lp -> s , space_left ) ;if ( string_size >= space_left ) return ( buf ) ;bufp += string_size ;space_left -= string_size ;sepstr = sep ;if ( bufp == buf ) ( void ) snprintf ( buf , sizeof ( buf ) , fmt == NULL ? ""#%08x"" : fmt , v ) ;",3697
1793,"cpi -> framerate = ( double ) ( oxcf -> timebase . den ) /   ( double ) ( oxcf -> timebase . num ) ;if ( cpi -> framerate > 180 ) cpi -> framerate = 30 ;vp8_change_config ( cpi , oxcf ) ;cpi -> active_worst_quality = cpi -> oxcf . worst_allowed_q ;","if ( oxcf -> timebase . num > 0 ) {cpi -> framerate = ( double ) ( oxcf -> timebase . den ) / ( double ) ( oxcf -> timebase . num ) ;}else {cpi -> framerate = 30 ;}if ( cpi -> framerate > 180 ) cpi -> framerate = 30 ;cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ;cm -> refresh_golden_frame = 0 ;cm -> refresh_last_frame = 1 ;cm -> refresh_entropy_probs = 1 ;vp8_change_config ( cpi , oxcf ) ;cpi -> active_worst_quality = cpi -> oxcf . worst_allowed_q ;",3698
1794,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",3699
1795,uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ( cc % ( bps * stride ) ) != 0 ) {if ( ! tmp )  return 0 ;,uint8 * tmp ;if ( ( cc % ( bps * stride ) ) != 0 ) {tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ! tmp ) return 0 ;,3700
1796,"static void rd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile ,  int mi_row , int mi_col ,  int * totalrate , int64_t * totaldist ,  BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;double rdmult_ratio ;vp9_clear_system_state ( ) ;rdmult_ratio = 1.0 ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index != 0 ) {set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;mbmi = & xd -> mi [ 0 ] -> mbmi ;","static void rd_pick_sb_modes ( VP9_COMP * cpi , TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) {TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCKD * const xd = & x -> e_mbd ;vpx_clear_system_state ( ) ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index != 0 ) {set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ;mbmi = & xd -> mi [ 0 ] -> mbmi ;ctx -> skippable = 0 ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {ctx -> pred_pixel_ready = 0 ;",3701
1797,"x -> skip_recode = 0 ;mbmi -> skip = 0 ;x -> source_variance = get_sby_perpixel_variance ( cpi , x , bsize ) ;if ( aq_mode == VARIANCE_AQ ) {mbmi -> segment_id = vp9_vaq_segment_id ( energy ) ;else {const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ;mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}rdmult_ratio = vp9_vaq_rdmult_ratio ( energy ) ;vp9_init_plane_quantizers ( cpi , x ) ;orig_rdmult = x -> rdmult ;if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) activity_masking ( cpi , x ) ;else if ( aq_mode == COMPLEXITY_AQ ) {const int mi_offset = mi_row * cm -> mi_cols + mi_col ;unsigned char complexity = cpi -> complexity_map [ mi_offset ] ;const int is_edge = ( mi_row <= 1 ) || ( mi_row >= ( cm -> mi_rows - 2 ) ) || ( mi_col <= 1 ) || ( mi_col >= ( cm -> mi_cols - 2 ) ) ;if ( ! is_edge && ( complexity > 128 ) )  x -> rdmult += ( ( x -> rdmult * ( complexity - 128 ) ) / 256 ) ;}if ( vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) )  x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ;vp9_rd_pick_intra_mode_sb ( cpi , x , totalrate , totaldist , bsize , ctx ,  best_rd ) ;if ( bsize >= BLOCK_8X8 )   vp9_rd_pick_inter_mode_sb ( cpi , x , tile , mi_row , mi_col ,   totalrate , totaldist , bsize , ctx , best_rd ) ;else   vp9_rd_pick_inter_mode_sub8x8 ( cpi , x , tile , mi_row , mi_col , totalrate ,  totaldist , bsize , ctx , best_rd ) ;if ( aq_mode == VARIANCE_AQ ) {x -> rdmult = orig_rdmult ;if ( * totalrate != INT_MAX ) {vp9_clear_system_state ( ) ;* totalrate = ( int ) round ( * totalrate * rdmult_ratio ) ;}else if ( aq_mode == COMPLEXITY_AQ || aq_mode == CYCLIC_REFRESH_AQ ) {x -> rdmult = orig_rdmult ;","x -> skip_recode = 0 ;mbmi -> skip = 0 ;x -> source_variance = vp9_high_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize , xd -> bd ) ;}else {x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ;}# else x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ;# endif orig_rdmult = x -> rdmult ;if ( aq_mode == VARIANCE_AQ ) {mbmi -> segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;rdmult_ratio = vp9_vaq_rdmult_ratio ( energy ) ;vp9_init_plane_quantizers ( cpi , x ) ;orig_rdmult = x -> rdmult ;if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) activity_masking ( cpi , x ) ;x -> rdmult += ( ( x -> rdmult * ( complexity - 128 ) ) / 256 ) ;}if ( vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ;vp9_rd_pick_intra_mode_sb ( cpi , x , totalrate , totaldist , bsize , ctx , best_rd ) ;if ( bsize >= BLOCK_8X8 ) vp9_rd_pick_inter_mode_sb ( cpi , x , tile , mi_row , mi_col , totalrate , totaldist , bsize , ctx , best_rd ) ;else vp9_rd_pick_inter_mode_sub8x8 ( cpi , x , tile , mi_row , mi_col , totalrate , totaldist , bsize , ctx , best_rd ) ;}if ( aq_mode == VARIANCE_AQ ) {x -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id ) ;else if ( aq_mode == COMPLEXITY_AQ ) && ( bsize >= BLOCK_16X16 ) && ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) ) {vp9_caq_select_segment ( cpi , x , bsize , mi_row , mi_col , rd_cost -> rate ) ;x -> rdmult = orig_rdmult ;if ( rd_cost -> rate == INT_MAX ) rd_cost -> rdcost = INT64_MAX ;ctx -> rate = rd_cost -> rate ;ctx -> dist = rd_cost -> dist ;",3701
1798,tdata_t _TIFFmalloc ( tsize_t s )  {return ( malloc ( ( size_t ) s ) ) ;,tdata_t _TIFFmalloc ( tsize_t s ) {if ( s == 0 ) return ( ( void * ) NULL ) ;return ( malloc ( ( size_t ) s ) ) ;,3702
1799,"char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}return - EIO ;}return brightness ;","char * data ;data = kmalloc ( 8 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}ret = - EIO ;goto out ;}ret = brightness ;out : kfree ( data ) ;return ret ;",3703
1800,"gboolean use_box_blur ;gint width , height ;","gint width , height ;",3704
1801,if ( sy < 0.0 )  sy = 0.0 ;if ( sx < 10.0 && sy < 10.0 ) use_box_blur = FALSE ;,if ( sy < 0.0 ) sy = 0.0 ;if ( sx < 10.0 && sy < 10.0 ) use_box_blur = FALSE ;,3704
1802,if ( use_box_blur ) {box_width = compute_box_blur_width ( sx ) ;,gboolean use_box_blur ;if ( sx < 10.0 ) use_box_blur = FALSE ;else use_box_blur = TRUE ;if ( use_box_blur ) {box_width = compute_box_blur_width ( sx ) ;,3704
1803,"col_buffer = g_new0 ( guchar , height * bpp * 2 ) ;col1 = col_buffer ;","gboolean use_box_blur ;if ( sy < 10.0 ) use_box_blur = FALSE ;else use_box_blur = TRUE ;col_buffer = g_new0 ( guchar , height * bpp * 2 ) ;col1 = col_buffer ;",3704
1804,data -> l_head = NULL ;data -> portListing = NULL ;data -> portListingLength = 0 ;,"memset ( data , 0 , sizeof ( struct NameValueParserData ) ) ;",3705
1805,"if ( ssl_derive ( s , ckey , skey ) == 0 ) {SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EVP_LIB ) ;","if ( ckey == NULL ) {SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ;goto err ;}if ( ssl_derive ( s , ckey , skey ) == 0 ) {SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EVP_LIB ) ;",3706
1806,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen ,  int transhdrlen , int mtu , unsigned int flags )  {","static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) {",3707
1807,ipv6_select_ident ( & fhdr ) ;skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;,"ipv6_select_ident ( & fhdr , rt ) ;skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ;",3707
1808,"static int ion_handle_put ( struct ion_handle * handle )  {ret = kref_put ( & handle -> ref , ion_handle_destroy ) ;mutex_unlock ( & client -> lock ) ;",int ion_handle_put ( struct ion_handle * handle ) {ret = ion_handle_put_nolock ( handle ) ;mutex_unlock ( & client -> lock ) ;,3708
1809,"WORD32 cur_poc , ref_list_poc , flag = 1 ;cur_poc = ps_slice_hdr -> i4_abs_pic_order_cnt ;for ( i = 0 ;i < ps_slice_hdr -> i1_num_ref_idx_l0_active ;i ++ ) {ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_mv_buf ) -> i4_abs_poc ;if ( ref_list_poc > cur_poc ) {flag = 0 ;break ;}}if ( flag && ( ps_slice_hdr -> i1_slice_type == BSLICE ) ) {for ( i = 0 ;i < ps_slice_hdr -> i1_num_ref_idx_l1_active ;i ++ ) {ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_mv_buf ) -> i4_abs_poc ;if ( ref_list_poc > cur_poc ) {flag = 0 ;break ;}}}ps_slice_hdr -> i1_low_delay_flag = flag ;}if ( ps_slice_hdr -> i1_slice_type == ISLICE ) {cabac_init_idc = 0 ;}else if ( ps_slice_hdr -> i1_slice_type == PSLICE ) {cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 2 : 1 ;}else {cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 1 : 2 ;}slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ;slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ;if ( ( 0 == ps_slice_hdr -> i1_dependent_slice_flag ) || ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) ) ) {",WORD32 tu_coeff_data_reset_size ;ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) ) ) {,3709
1810,"WORD32 pu_skip_wd , pu_skip_ht ;WORD32 rows_remaining , cols_remaining ;","WORD32 pu_skip_wd , pu_skip_ht ;WORD32 rows_remaining , cols_remaining ;",3709
1811,ps_codec -> s_parse . i4_pic_pu_idx = i4_pic_pu_idx ;ps_tu -> b1_cb_cbf = 0 ;ps_tu -> b1_cr_cbf = 0 ;ps_tu -> b1_y_cbf = 0 ;ps_tu -> b4_pos_x = 0 ;ps_tu -> b4_pos_y = 0 ;ps_tu -> b1_transquant_bypass = 0 ;ps_tu -> b3_size = ( ps_sps -> i1_log2_ctb_size - 2 ) ;ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ;ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ;ps_tu -> b6_luma_intra_mode = INTRA_PRED_NONE ;ps_tu -> b1_first_tu_in_cu = 1 ;ps_codec -> s_parse . ps_tu ++ ;ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ;,ps_codec -> s_parse . i4_pic_pu_idx = i4_pic_pu_idx ;ps_codec -> s_parse . ps_tu ++ ;ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ;,3709
1812,"tu_t * ps_tu = ps_codec -> s_parse . ps_tu ;pu_t * ps_pu = ps_codec -> s_parse . ps_pu ;WORD32 pu_skip_wd , pu_skip_ht ;WORD32 rows_remaining , cols_remaining ;rows_remaining = ps_sps -> i2_pic_height_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ;pu_skip_ht = MIN ( ctb_size , rows_remaining ) ;cols_remaining = ps_sps -> i2_pic_width_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) ;pu_skip_wd = MIN ( ctb_size , cols_remaining ) ;ps_tu -> b1_cb_cbf = 0 ;ps_tu -> b1_cr_cbf = 0 ;ps_tu -> b1_y_cbf = 0 ;ps_tu -> b4_pos_x = 0 ;ps_tu -> b4_pos_y = 0 ;ps_tu -> b1_transquant_bypass = 0 ;ps_tu -> b3_size = ( ps_sps -> i1_log2_ctb_size - 2 ) ;ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ;ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ;ps_tu -> b6_luma_intra_mode = INTRA_PRED_NONE ;ps_tu -> b1_first_tu_in_cu = 1 ;ps_codec -> s_parse . ps_tu ++ ;ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ;ps_codec -> s_parse . i4_pic_tu_idx ++ ;ps_codec -> s_parse . s_cu . i4_pred_mode = PRED_MODE_SKIP ;ps_codec -> s_parse . s_cu . i4_part_mode = PART_2Nx2N ;ps_pu -> b2_part_idx = 0 ;ps_pu -> b4_pos_x = 0 ;ps_pu -> b4_pos_y = 0 ;ps_pu -> b4_wd = ( pu_skip_wd >> 2 ) - 1 ;ps_pu -> b4_ht = ( pu_skip_ht >> 2 ) - 1 ;ps_pu -> b1_intra_flag = 0 ;ps_pu -> b3_part_mode = ps_codec -> s_parse . s_cu . i4_part_mode ;ps_pu -> b1_merge_flag = 1 ;ps_pu -> b3_merge_idx = 0 ;ps_codec -> s_parse . ps_pu ++ ;ps_codec -> s_parse . i4_pic_pu_idx ++ ;",ihevcd_set_ctb_skip ( ps_codec ) ;,3709
1813,usleep ( 250000 ) ;skt_disconnect ( common -> ctrl_fd ) ;usleep ( 250000 ) ;},TEMP_FAILURE_RETRY ( usleep ( 250000 ) ) ;skt_disconnect ( common -> ctrl_fd ) ;TEMP_FAILURE_RETRY ( usleep ( 250000 ) ) ;},3710
1814,"static void perf_swevent_event ( struct perf_event * event , u64 nr ,  int nmi , struct perf_sample_data * data ,  struct pt_regs * regs ) {if ( nr == 1 && hwc -> sample_period == 1 && ! event -> attr . freq )  return perf_swevent_overflow ( event , 1 , nmi , data , regs ) ;if ( local64_add_negative ( nr , & hwc -> period_left ) ) return ;perf_swevent_overflow ( event , 0 , nmi , data , regs ) ;}","static void perf_swevent_event ( struct perf_event * event , u64 nr , struct perf_sample_data * data , struct pt_regs * regs ) {if ( nr == 1 && hwc -> sample_period == 1 && ! event -> attr . freq ) return perf_swevent_overflow ( event , 1 , data , regs ) ;if ( local64_add_negative ( nr , & hwc -> period_left ) ) return ;perf_swevent_overflow ( event , 0 , data , regs ) ;}",3711
1815,"
",tty_driver_kref_put ( driver ) ;,3712
1816,return PTR_ERR ( tty ) ;},return PTR_ERR ( tty ) ;},3712
1817,case IS_STRING :  convert_to_double_ex ( tmp ) ;m1 [ i ] = Z_DVAL_PP ( tmp ) ;break ;,case IS_STRING : {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;m1 [ i ] = Z_DVAL ( dval ) ;}break ;,3713
1818,case IS_STRING :  convert_to_double_ex ( tmp ) ;m2 [ i ] = Z_DVAL_PP ( tmp ) ;break ;,case IS_STRING : {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;m2 [ i ] = Z_DVAL ( dval ) ;}break ;,3713
1819,"int len ;if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) {len = ( int ) ( cp - ( ip_as_string + 1 ) ) ;if ( len > ( int ) sizeof ( buf ) - 1 ) {return - 1 ;","size_t len ;if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) {len = ( cp - ( ip_as_string + 1 ) ) ;if ( len > sizeof ( buf ) - 1 ) {return - 1 ;",3714
1820,"strcat ( line , buf ) ;strcat ( line , ""<S2SV_blank>"" ) ;e = e -> next ;line [ strlen ( line ) - 1 ] = 0 ;return line ;","strncat ( line , buf , sizeof line ) ;strncat ( line , buf ) ;strcat ( line , ""<S2SV_blank>"" , sizeof line ) ;e = e -> next ;line [ ( sizeof line ) - 1 ] = \'\\\\0\' ;line [ strlen ( line ) - 1 ] = 0 ;return line ;",3715
1821,drop_futex_key_refs ( & q -> key ) ;},},3716
1822,tread . event = SNDRV_TIMER_EVENT_EARLY ;tread . tstamp . tv_sec = 0 ;,"memset ( & tread , 0 , sizeof ( tread ) ) ;tread . event = SNDRV_TIMER_EVENT_EARLY ;tread . tstamp . tv_sec = 0 ;",3717
1823,"case 'b' : j = cJSON_CreateBool ( va_arg ( argp , int ) ) ;case 'd' :  j = cJSON_CreateInt ( va_arg ( argp , int64_t ) ) ;break ;case 'f' :  j = cJSON_CreateFloat ( va_arg ( argp , double ) ) ;break ;","case 'b' : j = cJSON_CreateNumber ( va_arg ( argp , int ) ) ;break ;case 'd' : j = cJSON_CreateNumber ( va_arg ( argp , int64_t ) ) ;break ;case 'f' : j = cJSON_CreateFloat ( va_arg ( argp , double ) ) ;",3718
1824,"void options_free ( ) {parse_global_option ( CMD_FREE , NULL , NULL ) ;}","void options_free ( int current ) {GLOBAL_OPTIONS * global = current ? & global_options : & new_global_options ;SERVICE_OPTIONS * service = current ? & service_options : & new_service_options ;parse_global_option ( CMD_FREE , global , NULL , NULL ) ;CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ;while ( service ) {SERVICE_OPTIONS * tmp = service ;service = service -> next ;tmp -> next = NULL ;service_free ( tmp ) ;}CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;}",3719
1825,"static expr_ty  ast_for_call ( struct compiling * c , const node * n , expr_ty func )  {int i , nargs , nkeywords , ngens ;int ndoublestars ;nkeywords = 0 ;ngens = 0 ;for ( i = 0 ;else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for )  ngens ++ ;else if ( TYPE ( CHILD ( ch , 0 ) ) == STAR ) nargs ++ ;else nkeywords ++ ;}}if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) {ast_error ( c , n , ""Generator<S2SV_blank>expression<S2SV_blank>must<S2SV_blank>be<S2SV_blank>parenthesized<S2SV_blank>"" ""if<S2SV_blank>not<S2SV_blank>sole<S2SV_blank>argument"" ) ;if ( nargs + nkeywords + ngens > 255 ) {ast_error ( c , n , ""more<S2SV_blank>than<S2SV_blank>255<S2SV_blank>arguments"" ) ;args = _Ta3_asdl_seq_new ( nargs + ngens , c -> c_arena ) ;","static expr_ty ast_for_call ( struct compiling * c , const node * n , expr_ty func , bool allowgen ) {int i , nargs , nkeywords ;int ndoublestars ;for ( i = 0 ;else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) {nargs ++ ;if ( ! allowgen ) {ast_error ( c , ch , ""invalid<S2SV_blank>syntax"" ) ;if ( NCH ( n ) > 1 ) {ast_error ( c , ch , ""Generator<S2SV_blank>expression<S2SV_blank>must<S2SV_blank>be<S2SV_blank>parenthesized"" ) ;}args = _Ta3_asdl_seq_new ( nargs , c -> c_arena ) ;",3720
1826,for ( k = passIC + 2 ;k < passIC + 2 + passInstructions [ passIC + 1 ] ;k ++ )  if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ;,for ( k = passIC + 2 ;( ( k < passIC + 2 + passInstructions [ passIC + 1 ] ) && ( kk < input -> length ) ) ;k ++ ) if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ;,3721
1827,"char combname [ L_BUF_SIZE ] ;l_int32 i , nsels , sx , sy , found ;if ( direction == L_HORIZ )  snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ;else  snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ;found = FALSE ;","char combname [ L_BUFSIZE ] ;l_int32 i , nsels , sx , sy , found ;if ( direction == L_HORIZ ) snprintf ( combname , L_BUFSIZE , ""sel_comb_%dh"" , size ) ;else snprintf ( combname , L_BUFSIZE , ""sel_comb_%dv"" , size ) ;found = FALSE ;",3722
1828,"if ( ascii_strncasecmp ( ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" , idata -> buf , 16 ) && imap_check_capabilities ( idata ) ) goto bail ;","# if defined ( USE_SSL ) if ( ! idata -> conn -> ssf ) {if ( option ( OPTSSLFORCETLS ) || ( query_quadoption ( OPT_SSLSTARTTLS , _ ( ""Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?"" ) ) != MUTT_NO ) ) {mutt_error _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ;mutt_sleep ( 1 ) ;goto err_close_conn ;}}# endif if ( ascii_strncasecmp ( ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" , idata -> buf , 16 ) && imap_check_capabilities ( idata ) ) goto bail ;",3723
1829,idata -> state = IMAP_AUTHENTICATED ;if ( imap_check_capabilities ( idata ) != 0 ) goto bail ;,idata -> state = IMAP_AUTHENTICATED ;if ( imap_check_capabilities ( idata ) != 0 ) goto bail ;,3723
1830,"return sprintf ( buf , ""%s\\\}","ssize_t len ;device_lock ( dev ) ;len = sprintf ( buf , ""%s\\\device_unlock ( dev ) ;return len ;}",3724
1831,cJSON * ref ;if ( ! ( ref = cJSON_New_Item ( ) ) )  return 0 ;,cJSON * ref = cJSON_New_Item ( ) ) ) return 0 ;,3725
1832,"ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" ,  ( char * ) * data ) ;","ext3_msg ( sb , KERN_ERR , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , ( char * ) * data ) ;",3726
1833,"fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ;# ifdef USE_HCACHE fc . hc = hc ;","fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ;if ( fc . messages == NULL ) return - 1 ;# ifdef USE_HCACHE fc . hc = hc ;",3727
1834,block_in_file = ( sector_t ) page -> index ;last_block = block_in_file + nr_pages ;,block_in_file = ( sector_t ) page_index ( page ) ;last_block = block_in_file + nr_pages ;,3728
1835,if ( ! PageUptodate ( page ) && ! cleancache_get_page ( page ) ) {SetPageUptodate ( page ) ;,if ( ! PageUptodate ( page ) && ( ! PageSwapCache ( page ) && ! cleancache_get_page ( page ) ) ) {SetPageUptodate ( page ) ;,3728
1836,"vpx_memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ;}","memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ;}",3729
1837,"msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ;","skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ;",3730
1838,"if ( ( opt_len != mp_dss_len ( mdss , 1 ) &&  opt_len != mp_dss_len ( mdss , 0 ) ) || flags & TH_SYN ) return 0 ;if ( mdss -> flags & MP_DSS_A ) {ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;if ( mdss -> flags & MP_DSS_a ) {ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}}if ( mdss -> flags & MP_DSS_m ) {ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;opt += 2 ;if ( opt_len == mp_dss_len ( mdss , 1 ) )  ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ;","if ( opt_len < 4 ) return 0 ;if ( flags & TH_SYN ) return 0 ;opt_len -= 4 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""<S2SV_blank>ack<S2SV_blank>"" ) ) ;if ( mdss -> flags & MP_DSS_a ) {if ( opt_len < 8 ) return 0 ;ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;opt_len -= 8 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;opt_len -= 4 ;if ( opt_len < 2 ) return 0 ;opt_len -= 4 ;}}if ( mdss -> flags & MP_DSS_m ) {if ( opt_len < 8 ) return 0 ;ND_PRINT ( ( ndo , ""%"" PRIu64 , EXTRACT_64BITS ( opt ) ) ) ;opt_len -= 8 ;}if ( opt_len < 4 ) return 0 ;ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ;opt += 4 ;}ND_PRINT ( ( ndo , ""<S2SV_blank>subseq<S2SV_blank>%u"" , EXTRACT_32BITS ( opt ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ;opt += 2 ;opt_len -= 2 ;if ( opt_len >= 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ;opt_len -= 2 ;}if ( opt_len != 0 ) return 0 ;",3731
1839,"int hours , minutes , seconds ;int64_t time ;","int64_t hours , minutes , seconds ;int64_t time ;",3732
1840,"( void ) & line ;if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len )  return 0 ;DPRINTF ( ( ""%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%"" SIZE_T_FORMAT ""u"" ""<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>[%"" SIZE_T_FORMAT ""u<S2SV_blank>%"" SIZE_T_FORMAT ""u]\\\errno = EFTYPE ;","size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ;( void ) & line ;if ( e >= b && ( size_t ) ( e - b ) <= ss * sst -> sst_len ) return 0 ;DPRINTF ( ( ""%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%"" SIZE_T_FORMAT ""u"" ""<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>[%"" SIZE_T_FORMAT ""u<S2SV_blank>%"" SIZE_T_FORMAT ""u]\\\errno = EFTYPE ;",3733
1841,"void fdct4_sse2 ( __m128i * in ) {const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;","static void fdct4_sse2 ( __m128i * in ) {const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( ( int16_t ) cospi_16_64 ) ;const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;",3734
1842,sbinfo -> hstate = config . hstate ;spin_lock_init ( & sbinfo -> stat_lock ) ;sbinfo -> max_blocks = config . nr_blocks ;sbinfo -> free_blocks = config . nr_blocks ;sbinfo -> max_inodes = config . nr_inodes ;,sbinfo -> max_inodes = config . nr_inodes ;sbinfo -> spool = NULL ;if ( config . nr_blocks != - 1 ) {sbinfo -> spool = hugepage_new_subpool ( config . nr_blocks ) ;if ( ! inode ) goto out_free ;},3735
1843,if ( ! inode )  goto out_free ;root = d_alloc_root ( inode ) ;if ( ! root ) {out_free :  kfree ( sbinfo ) ;return - ENOMEM ;,if ( ! inode ) goto out_free ;root = d_alloc_root ( inode ) ;if ( ! root ) {out_free : if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ;kfree ( sbinfo ) ;return - ENOMEM ;,3735
1844,"status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ;if ( ( status & EIR_LINKIF ) != 0 ) {enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_LINKIF ) ;value = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) ;if ( ( value & ESTAT_PHYLNK ) != 0 ) {value = enc624j600ReadPhyReg ( interface , ENC624J600_PHY_REG_PHSTAT3 ) ;if ( ( value & PHSTAT3_SPDDPX1 ) != 0 ) {if ( ( value & PHSTAT3_SPDDPX2 ) != 0 )  {","status = enc624j600ReadReg ( interface , ENC624J600_EIR ) ;if ( ( status & ENC624J600_EIR_LINKIF ) != 0 ) {enc624j600ClearBit ( interface , ENC624J600_EIR , ENC624J600_EIR_LINKIF ) ;value = enc624j600ReadReg ( interface , ENC624J600_ESTAT ) ;if ( ( value & ENC624J600_ESTAT_PHYLNK ) != 0 ) {value = enc624j600ReadPhyReg ( interface , ENC624J600_PHSTAT3 ) ;if ( ( value & ENC624J600_PHSTAT3_SPDDPX1 ) != 0 ) {if ( ( value & ENC624J600_PHSTAT3_SPDDPX2 ) != 0 ) {",3736
1845,"if ( ( status & EIR_PKTIF ) != 0 )  {enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_PKTIF ) ;do {enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE | EIE_PKTIE ) ;}","if ( ( status & ENC624J600_EIR_PKTIF ) != 0 ) {enc624j600ClearBit ( interface , ENC624J600_EIR , ENC624J600_EIR_PKTIF ) ;do {enc624j600SetBit ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE ) ;}",3736
1846,"if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) return ;}r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ;r_anal_esil_set_pc ( esil , core -> offset ) ;r_anal_esil_parse ( esil , input + 1 ) ;r_anal_esil_dumpstack ( esil ) ;r_anal_esil_stack_free ( esil ) ;break ;case \'s\' : switch ( input [ 1 ] ) {case \'?\' : eprintf ( ""See:<S2SV_blank>ae?~aes\\\break ;case \'l\' : {ut64 pc = r_debug_reg_get ( core -> dbg , ""PC"" ) ;RAnalOp * op = r_core_anal_op ( core , pc ) ;if ( ! op ) {break ;}r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ;r_debug_reg_set ( core -> dbg , ""PC"" , pc + op -> size ) ;r_anal_esil_set_pc ( esil , pc + op -> size ) ;r_core_cmd0 ( core , "".ar*"" ) ;}break ;case \'b\' : if ( ! r_core_esil_step_back ( core ) ) {eprintf ( ""cannnot<S2SV_blank>step<S2SV_blank>back\\\}r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'u\' : if ( input [ 2 ] == \'e\' ) {until_expr = input + 3 ;}else {until_addr = r_num_math ( core -> num , input + 2 ) ;}r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'o\' : op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ;if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) {until_addr = op -> addr + op -> size ;}r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_anal_op_free ( op ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'p\' : n = strchr ( input , \'<S2SV_blank>\' ) ;n1 = n ? strchr ( n + 1 , \'<S2SV_blank>\' ) : NULL ;if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) {eprintf ( ""aesp<S2SV_blank>[offset]<S2SV_blank>[num]\\\break ;}adr = r_num_math ( core -> num , n + 1 ) ;off = r_num_math ( core -> num , n1 + 1 ) ;cmd_aespc ( core , adr , off ) ;break ;case \'<S2SV_blank>\' : n = strchr ( input , \'<S2SV_blank>\' ) ;if ( ! ( n + 1 ) ) {r_core_esil_step ( core , until_addr , until_expr , NULL ) ;break ;}off = r_num_math ( core -> num , n + 1 ) ;cmd_aespc ( core , - 1 , off ) ;break ;default : r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;}break ;case \'c\' : if ( input [ 1 ] == \'?\' ) {r_core_cmd_help ( core , help_msg_aec ) ;}else if ( input [ 1 ] == \'s\' ) {const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ;ut64 newaddr ;int ret ;for ( ;;) {op = r_core_anal_op ( core , addr ) ;if ( ! op ) {break ;}if ( op -> type == R_ANAL_OP_TYPE_SWI ) {eprintf ( ""syscall<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\break ;}if ( op -> type == R_ANAL_OP_TYPE_TRAP ) {eprintf ( ""trap<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\break ;}ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ;r_anal_op_free ( op ) ;op = NULL ;if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) {break ;}if ( ! ret ) break ;r_core_cmd0 ( core , "".ar*"" ) ;newaddr = r_num_get ( core -> num , pc ) ;if ( addr == newaddr ) {addr ++ ;break ;}else {addr = newaddr ;}}if ( op ) {r_anal_op_free ( op ) ;}}else {if ( input [ 1 ] == \'u\' && input [ 2 ] == \'e\' ) until_expr = input + 3 ;else if ( input [ 1 ] == \'u\' ) until_addr = r_num_math ( core -> num , input + 2 ) ;else until_expr = ""0"" ;r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;}break ;case \'i\' : switch ( input [ 1 ] ) {case \'s\' : case \'m\' : cmd_esil_mem ( core , input + 2 ) ;break ;case \'p\' : r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ;break ;case \'?\' : cmd_esil_mem ( core , ""?"" ) ;break ;case \'-\' : if ( esil ) {sdb_reset ( esil -> stats ) ;}r_anal_esil_free ( esil ) ;core -> anal -> esil = NULL ;break ;case 0 : r_anal_esil_free ( esil ) ;{const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ;if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) {r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ;}}if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) {r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ;esil -> verbose = ( int ) r_config_get_i ( core -> config , ""esil.verbose"" ) ;{const char * s = r_config_get ( core -> config , ""cmd.esil.intr"" ) ;if ( s ) {char * my = strdup ( s ) ;if ( my ) {r_config_set ( core -> config , ""cmd.esil.intr"" , my ) ;free ( my ) ;}}}break ;}break ;case \'k\' : switch ( input [ 1 ] ) {case \'\\\\0\' : input = ""123*"" ;case \'<S2SV_blank>\' : if ( esil && esil -> stats ) {char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ;if ( out ) {r_cons_println ( out ) ;free ( out ) ;}}else {eprintf ( ""esil.stats<S2SV_blank>is<S2SV_blank>empty.<S2SV_blank>Run<S2SV_blank>\\\'aei\\\'\\\}break ;case \'-\' : if ( esil ) {sdb_reset ( esil -> stats ) ;}break ;}break ;case \'f\' : {RListIter * iter ;RAnalBlock * bb ;RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ;if ( fcn ) {r_list_foreach ( fcn -> bbs , iter , bb ) {ut64 pc = bb -> addr ;ut64 end = bb -> addr + bb -> size ;RAnalOp op ;ut8 * buf ;int ret , bbs = end - pc ;if ( bbs < 1 || bbs > 0xfffff ) {eprintf ( ""Invalid<S2SV_blank>block<S2SV_blank>size\\\}buf = calloc ( 1 , bbs + 1 ) ;r_io_read_at ( core -> io , pc , buf , bbs ) ;int left ;while ( pc < end ) {left = R_MIN ( end - pc , 32 ) ;r_asm_set_pc ( core -> assembler , pc ) ;ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ;if ( ret ) {r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ;r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ;r_anal_esil_dumpstack ( esil ) ;r_anal_esil_stack_free ( esil ) ;pc += op . size ;}else {pc += 4 ;}}}}else {eprintf ( ""Cannot<S2SV_blank>find<S2SV_blank>function<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\}}break ;case \'t\' : switch ( input [ 1 ] ) {case \'r\' : {RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ;if ( ! esil )  return ;","
",3737
1847,"int a = getnum ( L , fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;","int a = getnum ( fmt , MAXALIGN ) ;if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2"" , a ) ;",3738
1848,"int len ;if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) {len = ( int ) ( cp - ( ip_as_string + 1 ) ) ;if ( len > ( int ) sizeof ( buf ) - 1 ) {return - 1 ;","size_t len ;if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) {len = ( cp - ( ip_as_string + 1 ) ) ;if ( len > sizeof ( buf ) - 1 ) {return - 1 ;",3739
1849,addr -> addrtype = TIPC_ADDR_ID ;addr -> addr . id . ref = msg_origport ( msg ) ;,"addr -> addrtype = TIPC_ADDR_ID ;memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) ) ;addr -> addr . id . ref = msg_origport ( msg ) ;",3740
1850,"
","break ;default : fastd_buffer_free ( buffer ) ;pr_debug ( ""received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>%P[%I]"" , peer , remote_addr ) ;",3741
1851,}},}},3741
1852,"assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ;files = va_arg ( ap , const char * ) ;","assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID ) == 0 ) ;files = va_arg ( ap , const char * ) ;",3742
1853,INST_HANDLER ( lds ) {int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,INST_HANDLER ( lds ) {if ( len < 4 ) {return ;}int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ;,3743
1854,struct inet_sock * inet = inet_sk ( sk ) ;struct ip_options * opt = inet -> opt ;,"
",3744
1855,if ( opt && opt -> srr )  daddr = opt -> faddr ;,"struct ip_options_rcu * inet_opt ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;",3744
1856,cifs_small_buf_release ( req ) ;rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ;,rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ;,3745
1857,* nbytes = le32_to_cpu ( rsp -> DataLength ) ;if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) {,cifs_small_buf_release ( req ) ;* nbytes = le32_to_cpu ( rsp -> DataLength ) ;if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) {,3745
1858,"sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ;}cu -> dies [ cu -> length ] . length ++ ;","if ( name > 1024 ) {sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ;}else {eprintf ( ""Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\\}}cu -> dies [ cu -> length ] . length ++ ;",3746
1859,"char lbase [ 256 ] ;char strbase [ 256 ] ;char ltest [ 256 ] ;char strtest [ 256 ] ;if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) {","char lbase [ 512 ] ;char strbase [ 256 ] ;char ltest [ 512 ] ;char strtest [ 256 ] ;if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) {",3747
1860,"while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) {int nbase = sscanf ( lbase , ""%255[^\\\\r\\\int ntest = sscanf ( ltest , ""%255[^\\\\r\\\assert ( nbase != 255 && ntest != 255 ) ;if ( nbase != 1 || ntest != 1 ) {","while ( fgets ( lbase , ""%511[^\\\\r\\\int ntest = sscanf ( ltest , ""%255[^\\\\r\\\assert ( nbase != 255 && ntest != 255 ) ;if ( nbase != 1 || ntest != 1 ) {",3747
1861,"skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT ,  flags & MSG_DONTWAIT , & err ) ;","msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ;",3748
1862,if ( ( data & ~ mask ) != PSW_USER_BITS )  return - EINVAL ;,if ( ( data ^ PSW_USER_BITS ) & ~ mask ) return - EINVAL ;if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME ) return - EINVAL ;,3749
1863,struct net_device * dev = vif -> dev ;if ( netif_carrier_ok ( dev ) ) {rtnl_lock ( ) ;if ( netif_running ( dev ) )  xenvif_down ( vif ) ;rtnl_unlock ( ) ;xenvif_put ( vif ) ;},if ( netif_carrier_ok ( dev ) ) {rtnl_lock ( ) ;if ( netif_running ( dev ) ) xenvif_carrier_off ( vif ) ;rtnl_unlock ( ) ;xenvif_put ( vif ) ;,3750
1864,int ret = 0 ;if ( evtchn_ops -> percpu_init ) ret = evtchn_ops -> percpu_init ( cpu ) ;,int ret = 0 ;xen_cpu_init_eoi ( cpu ) ;if ( evtchn_ops -> percpu_init ) ret = evtchn_ops -> percpu_init ( cpu ) ;,3751
1865,"default :  assert ( 0 ) ;return ""(unknown)"" ;",default : abort ( ) ;,3752
1866,"struct IGDdatas * datas = ( struct IGDdatas * ) d ;memcpy ( datas -> cureltname , name , l ) ;","struct IGDdatas * datas = ( struct IGDdatas * ) d ;if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1 ;memcpy ( datas -> cureltname , name , l ) ;",3753
1867,"static void  horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % ( 2 * stride ) ) == 0 ) ;if ( wc > stride ) {","static int horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % ( 2 * stride ) ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horAcc16"" , ""%s"" , ""cc%(2*stride))!=0"" ) ;return 0 ;}if ( wc > stride ) {",3754
1868,},return 1 ;},3754
1869,cond_branch : f_offset = addrs [ i + filter [ i ] . jf ] - addrs [ i ] ;,cond_branch : f_offset = addrs [ i + filter [ i ] . jf && f_offset ] - addrs [ i ] ;,3755
1870,"if ( filter [ i ] . jf )   t_offset += is_near ( f_offset ) ? 2 : 6 ;EMIT_COND_JMP ( t_op , t_offset ) ;","if ( filter [ i ] . jf ) t_offset += is_near ( f_offset ) ? 2 : 5 ;EMIT_COND_JMP ( t_op , t_offset ) ;",3755
1871,int err = - EIO ;unsigned char * p = kmap ( page ) ;uint32_t pos ;iinfo = UDF_I ( inode ) ;,int err ;unsigned char * p = kmap ( page ) ;uint32_t pos ;if ( inode -> i_size > inode -> i_sb -> s_blocksize ) {err = - ENAMETOOLONG ;goto out_unmap ;}iinfo = UDF_I ( inode ) ;,3756
1872,if ( ! bh )  goto out ;,if ( ! bh ) {err = - EIO ;goto out_unlock_inode ;},3756
1873,out :  up_read ( & iinfo -> i_data_sem ) ;kunmap ( page ) ;unlock_page ( page ) ;,out_unlock_inode : up_read ( & iinfo -> i_data_sem ) ;out_unmap : kunmap ( page ) ;unlock_page ( page ) ;,3756
1874,io -> io_cleanup = port_cleanup ;switch ( io -> regsize ) {,switch ( io -> regsize ) {,3757
1875,return 0 ;},io -> io_cleanup = port_cleanup ;return 0 ;},3757
1876,"assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ;( void ) memcpy ( ( ( char * ) buf ) + offs ,  ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ;return len ;","size_t ss = CDF_SHORT_SEC_SIZE ( h ) ;size_t pos = CDF_SHORT_SEC_POS ( h , id ) ;assert ( ss == len ) ;if ( sst -> sst_len < ( size_t ) id ) {DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\\return - 1 ;}( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ;return len ;",3758
1877,if ( ! io_end || ! size )  return ;,unsigned long flags ;struct ext4_inode_info * ei ;if ( ! io_end || ! size ) return ;,3759
1878,"wq = EXT4_SB ( io_end -> inode -> i_sb ) -> dio_unwritten_wq ;queue_work ( wq , & io_end -> work ) ;list_add_tail ( & io_end -> list ,   & EXT4_I ( io_end -> inode ) -> i_completed_io_list ) ;iocb -> private = NULL ;","io_end -> flag = EXT4_IO_UNWRITTEN ;wq = EXT4_SB ( io_end -> inode -> i_sb ) -> dio_unwritten_wq ;queue_work ( wq , & io_end -> work ) ;ei = EXT4_I ( io_end -> inode ) ;spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ;list_add_tail ( & io_end -> list , & ei -> i_completed_io_list ) ;spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;iocb -> private = NULL ;",3759
1879,"err = aead_register_instance ( tmpl , inst ) ;if ( err ) goto out_drop_aead ;","inst -> free = pcrypt_free ;err = aead_register_instance ( tmpl , inst ) ;if ( err ) goto out_drop_aead ;",3760
1880,"if ( srp -> bio )   blk_end_request_all ( srp -> rq , - EIO ) ;sg_finish_rem_req ( srp ) ;","if ( srp -> bio ) {if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ;blk_end_request_all ( srp -> rq , - EIO ) ;srp -> rq = NULL ;}sg_finish_rem_req ( srp ) ;",3761
1881,"remote_path_check :  if ( ! rc && cifs_sb -> prepathlen && tcon ) {full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ;","remote_path_check : if ( ! rc && tcon ) {full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ;",3762
1882,"if ( c == EOF ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) != 0 ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;}file = ( FILE * ) NULL ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) {( void ) RelinquishUniqueFileResource ( filename ) ;read_info = DestroyImageInfo ( read_info ) ;ThrowFileException ( exception , FileOpenError , ""UnableToWriteFile"" , image -> filename ) ;image = DestroyImageList ( image ) ;return ( ( Image * ) NULL ) ;}length = fwrite ( ""SFW94A"" , 1 , 6 , file ) ;( void ) length ;filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ;for ( i = 0 ;i < ( ssize_t ) filesize ;i ++ ) {c = ReadBlobByte ( pwp_image ) ;if ( c == EOF ) break ;( void ) fputc ( c , file ) ;}","if ( fputc ( c , file ) != c ) break ;",3763
1883,"authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ;if ( authpending_file_descriptor < 0 ) {","authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY , 0664 ) ;if ( authpending_file_descriptor < 0 ) {if ( cfg -> is_custom_debug_file ) {fclose ( cfg -> debug_file ) ;}",3764
1884,return retval ;},return retval ;},3764
1885,"static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize )  {","static BOOL nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 outSize , UINT32 originalSize ) {",3765
1886,* out ++ = value ;left -- ;,if ( outSize < 1 ) return FALSE ;outSize -- ;* out ++ = value ;left -- ;,3765
1887,"FillMemory ( out , len , value ) ;out += len ;* out ++ = value ;left -- ;* ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ;","if ( outSize < len ) return FALSE ;outSize -= len ;FillMemory ( out , len , value ) ;out += len ;if ( outSize < 1 ) return FALSE ;outSize -- ;* out ++ = value ;left -- ;if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ;memcpy ( out , in , 4 ) ;return TRUE ;",3765
1888,"static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y ,  ExceptionInfo * exception ) {size_t bit ;ssize_t x ;register Quantum * q ;Quantum index ;switch ( depth )  {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}for ( bit = 0 ;bit ++ )  {index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}( void ) SyncAuthenticPixels ( image , exception ) ;break ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL )  break ;index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;","static MagickBooleanType InsertRow ( Image * image , ssize_t bpp , unsigned char * p , ssize_t y , ExceptionInfo * exception ) {int bit ;Quantum index ;register Quantum * q ;Quantum index ;switch ( bpp ) {index = ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;}for ( bit = 0 ;bit ++ ) {index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;}break ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns - 3 ) ;x += 4 ) {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 4 ) > 2 ) {index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;}}p ++ ;}break ;}case 4 : {index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;",3766
1889,"index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ;index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ;q += GetPixelChannels ( image ) ;}}( void ) SyncAuthenticPixels ( image , exception ) ;break ;}case 4 : {q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;for ( x = 0 ;x < ( ( ssize_t ) image -> columns - 1 ) ;x += 2 ) {q += GetPixelChannels ( image ) ;index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ;SetPixelIndex ( image , index , q ) ;if ( ( image -> columns % 2 ) != 0 ) {index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ;SetPixelIndex ( image , index , q ) ;q += GetPixelChannels ( image ) ;p ++ ;}q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL )  break ;index = ConstrainColormapIndex ( image , * p , exception ) ;SetPixelIndex ( image , index , q ) ;( void ) SyncAuthenticPixels ( image , exception ) ;","index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ;if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;q += GetPixelChannels ( image ) ;if ( ( image -> columns % 2 ) != 0 ) {if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ;p ++ ;q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;if ( q == ( Quantum * ) NULL ) break ;index = ConstrainColormapIndex ( image , * p , exception ) ;SetPixelIndex ( image , index , q ) ;",3766
1890,"rc = - EFAULT ;if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ;sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ;rc = - EINVAL ;if ( sipx -> sipx_family != AF_IPX ) break ;f . ipx_network = sipx -> sipx_network ;memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ;memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ;f . ipx_dlink_type = sipx -> sipx_type ;f . ipx_special = sipx -> sipx_special ;if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ;else rc = ipxitf_create ( & f ) ;break ;}case SIOCGIFADDR : {struct sockaddr_ipx * sipx ;struct ipx_interface * ipxif ;struct net_device * dev ;rc = - EFAULT ;if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ;sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ;dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ;rc = - ENODEV ;if ( ! dev ) break ;ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type ) ) ;rc = - EADDRNOTAVAIL ;if ( ! ipxif ) break ;sipx -> sipx_family = AF_IPX ;sipx -> sipx_network = ipxif -> if_netnum ;memcpy ( sipx -> sipx_node , ipxif -> if_node , sizeof ( sipx -> sipx_node ) ) ;rc = - EFAULT ;if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) )  break ;ipxitf_put ( ipxif ) ;rc = 0 ;","rc = 0 ;if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = - EFAULT ;ipxitf_put ( ipxif ) ;rc = 0 ;",3767
1891,for ( i = 0 ;i <= SERDES_MAX ;struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ;,for ( i = 0 ;i < SERDES_MAX ;struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ;,3768
1892,struct dentry * upper = ovl_dentry_upper ( dentry ) ;int err ;err = - ESTALE ;if ( upper -> d_parent == upperdir ) {dget ( upper ) ;dput ( upper ) ;ovl_dentry_version_inc ( dentry -> d_parent ) ;}if ( ! err ) d_drop ( dentry ) ;inode_unlock ( dir ) ;return err ;,"struct dentry * upper ;int err ;upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ;err = PTR_ERR ( upper ) ;if ( IS_ERR ( upper ) ) goto out_unlock ;err = - ESTALE ;if ( upper == ovl_dentry_upper ( dentry ) ) {ovl_dentry_version_inc ( dentry -> d_parent ) ;}dput ( upper ) ;if ( ! err ) d_drop ( dentry ) ;out_unlock : inode_unlock ( dir ) ;return err ;",3769
1893,ctx = d -> log_ctx ;d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ;,d -> log_file = eventfp ;ctx = d -> log_ctx ;d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ;,3770
1894,"int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname ,   int flen )  {if ( udf_build_ustr_exact ( unifilename , sname , flen ) )  goto out2 ;","int udf_get_filename ( struct super_block * sb , uint8_t * sname , int slen , uint8_t * dname , int dlen ) {if ( udf_build_ustr_exact ( unifilename , sname , slen ) ) goto out2 ;",3771
1895,"len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len ,  unifilename -> u_name , unifilename -> u_len ) ;","len = udf_translate_to_linux ( dname , dlen , filename -> u_name , filename -> u_len , unifilename -> u_name , unifilename -> u_len ) ;",3771
1896,"
",copy = datalen - transhdrlen - fraggap ;if ( copy < 0 ) {err = - EINVAL ;goto error ;},3772
1897,"if ( transhdrlen ) {skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ;}else {skb = NULL ;if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ;if ( unlikely ( ! skb ) ) err = - ENOBUFS ;}if ( ! skb ) goto error ;skb -> protocol = htons ( ETH_P_IPV6 ) ;skb -> ip_summed = csummode ;skb -> csum = 0 ;skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ;skb_shinfo ( skb ) -> tx_flags = tx_flags ;tx_flags = 0 ;skb_shinfo ( skb ) -> tskey = tskey ;tskey = 0 ;data = skb_put ( skb , fraglen ) ;skb_set_network_header ( skb , exthdrlen ) ;data += fragheaderlen ;skb -> transport_header = ( skb -> network_header + fragheaderlen ) ;if ( fraggap ) {skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ;skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ;data += fraggap ;pskb_trim_unique ( skb_prev , maxfraglen ) ;}copy = datalen - transhdrlen - fraggap ;if ( copy < 0 ) {err = - EINVAL ;kfree_skb ( skb ) ;goto error ;else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) {","if ( transhdrlen ) {skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ;if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) {",3772
1898,struct sk_buff * list_skb = skb_shinfo ( head_skb ) -> frag_list ;unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ;unsigned int offset = doffset ;,struct sk_buff * list_skb = skb_shinfo ( head_skb ) ;struct sk_buff * frag_skb = head_skb -> frag_list ;frag_skb = list_skb ;unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ;unsigned int offset = doffset ;,3773
1899,pos += skb_headlen ( list_skb ) ;while ( pos < offset + len ) {,frag_skb = list_skb ;pos += skb_headlen ( list_skb ) ;while ( pos < offset + len ) {,3773
1900,"
","if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ;",3773
1901,BUG_ON ( ! nfrags ) ;list_skb = list_skb -> next ;* nskb_frag = * frag ;__skb_frag_ref ( nskb_frag ) ;,BUG_ON ( ! nfrags ) ;list_skb = list_skb -> next ;* nskb_frag = * frag ;__skb_frag_ref ( nskb_frag ) ;,3773
1902,return in ;},return NULL ;},3774
1903,if ( new_fs ) {if ( & p -> mnt == new_fs -> root . mnt ) {,new_ns -> mounts ++ ;if ( new_fs ) {if ( & p -> mnt == new_fs -> root . mnt ) {,3775
1904,gdFree ( tmp_im ) ;},gdImageDestroy ( tmp_im ) ;},3776
1905,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,3777
1906,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",3777
1907,if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) &&  ! ( opt_len == 24 && flags & TH_ACK ) )  return 0 ;,if ( ! ( opt_len == 12 && ( flags & TH_SYN ) ) && ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) && ! ( opt_len == 24 && ( flags & TH_ACK ) ) ) return 0 ;,3778
1908,"ngx_int_t rc ;ngx_http_core_main_conf_t * cmcf ;size_t size ;r = sr -> parent ;rc = ngx_http_lua_set_content_length_header ( sr ,  body -> buf ? ngx_buf_size ( body -> buf ) : 0 ) ;else if ( ! always_forward_body && method != NGX_HTTP_PUT && method != NGX_HTTP_POST && r -> headers_in . content_length_n > 0 ) {rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ;if ( rc != NGX_OK ) {# if 1  sr -> request_body = NULL ;# endif }else {if ( ngx_http_lua_copy_request_headers ( sr , r ) != NGX_OK ) {return NGX_ERROR ;}if ( sr -> request_body ) {}}}","ngx_http_core_main_conf_t * cmcf ;int pr_not_chunked = 0 ;size_t size ;r = sr -> parent ;}else if ( ! always_forward_body && method != NGX_HTTP_PUT && method != NGX_HTTP_POST && r -> headers_in . content_length_n > 0 ) {rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ;}if ( ngx_http_lua_copy_request_headers ( sr , r , pr_not_chunked ) != NGX_OK ) {if ( sr -> request_body ) {",3779
1909,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",3780
1910,"( void ) SetImageColorspace ( image , GRAYColorspace ) ;if ( ( fits_info . min_data == 0.0 ) && ( fits_info . max_data == 0.0 ) ) {","( void ) SetImageColorspace ( image , GRAYColorspace ) ;if ( ( fits_info . min_data == 0.0 ) && ( fits_info . max_data == 0.0 ) ) {",3780
1911,"
",icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;,3781
1912,"tcp_init_send_head ( sk ) ;memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ;","tcp_init_send_head ( sk ) ;memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ;",3781
1913,"
",char * txt = op -> txt ;int txtLen = strlen ( op -> txt ) ;int txtLeft = R_ASM_BUFSIZE - txtLen ;txt += txtLen ;,3782
1914,"for ( i = 0 ;i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;}snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ;free ( table ) ;","for ( i = 0 ;i < count && txtLen + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;txtLen = strlen ( txt ) ;txt += txtLen ;txtLeft -= txtLen ;}snprintf ( txt , txtLeft - 1 , ""%d"" , def ) ;free ( table ) ;",3782
1915,"isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ;return hdrlen ;","isoclns_print ( ndo , p + 1 , length - 1 ) ;return hdrlen ;",3783
1916,"int64_t i = 0 ;double f = 0 ;int isint = 1 ;int sign = 1 , scale = 0 , subscale = 0 , signsubscale = 1 ;if ( * num == '-' ) {sign = - 1 ;++ num ;}if ( * num == '0' ) ++ num ;if ( * num >= '1' && * num <= '9' ) {do {i = ( i * 10 ) + ( * num - '0' ) ;f = ( f * 10.0 ) + ( * num - '0' ) ;++ num ;if ( * num == '.' && num [ 1 ] >= '0' && num [ 1 ] <= '9' ) {do {f = ( f * 10.0 ) + ( * num ++ - '0' ) ;scale -- ;}while ( * num >= '0' && * num <= '9' ) ;}if ( * num == 'e' || * num == 'E' ) {isint = 0 ;++ num ;if ( * num == '+' )  ++ num ;else if ( * num == '-' ) {signsubscale = - 1 ;++ num ;i = sign * i ;item -> valueint = i ;item -> valuefloat = i ;}else {f = sign * f * ipow ( 10.0 , scale + subscale * signsubscale ) ;item -> valueint = f ;item -> valuefloat = f ;}","+ num ;+ num ;double n = 0 , sign = 1 , scale = 0 ;double f = 0 ;int subscale = 0 , signsubscale = 1 ;if ( * num == '-' ) sign = - 1 , num ++ ;if ( * num == '0' ) num ++ ;if ( * num >= '1' && * num <= '9' ) do n = ( n * 10.0 ) + ( * num ++ - '0' ) ;while ( * num >= '0' && * num <= '9' ) ;if ( * num == '.' && num [ 1 ] >= '0' && num [ 1 ] <= '9' ) {num ++ ;do n = ( n * 10.0 ) + ( * num ++ - '0' ) , scale -- ;if ( * num == 'e' || * num == 'E' ) {+ num ;+ num ;if ( * num == '+' ) ++ num ;else if ( * num == '-' ) {signsubscale = - 1 ;++ num ;i = sign * n * pow ( 10.0 , ( scale + subscale * signsubscale ) ) ;item -> valuedouble = n ;item -> valueint = ( int64_t ) n ;",3784
1917,spin_lock_init ( & tu -> qlock ) ;init_waitqueue_head ( & tu -> qchange_sleep ) ;mutex_init ( & tu -> tread_sem ) ;tu -> ticks = 1 ;,spin_lock_init ( & tu -> ioctl_lock ) ;tu -> ticks = 1 ;,3785
1918,"Data = - Data ;vp8_write_literal ( bc , Data , mb_feature_data_bits [ i ] ) ;vp8_write_bit ( bc , 1 ) ;}else {vp8_write_literal ( bc , Data , mb_feature_data_bits [ i ] ) ;vp8_write_bit ( bc , 0 ) ;}}else vp8_write_bit ( bc , 0 ) ;}}}if ( xd -> update_mb_segmentation_map ) {for ( i = 0 ;i < MB_FEATURE_TREE_PROBS ;i ++ ) {int Data = xd -> mb_segment_tree_probs [ i ] ;if ( Data != 255 ) {vp8_write_bit ( bc , 1 ) ;vp8_write_literal ( bc , Data , 8 ) ;}else vp8_write_bit ( bc , 0 ) ;}}}vp8_write_bit ( bc , pc -> filter_type ) ;vp8_write_literal ( bc , pc -> filter_level , 6 ) ;vp8_write_literal ( bc , pc -> sharpness_level , 3 ) ;vp8_write_bit ( bc , xd -> mode_ref_lf_delta_enabled ) ;if ( xd -> mode_ref_lf_delta_enabled ) {int send_update = xd -> mode_ref_lf_delta_update || cpi -> oxcf . error_resilient_mode ;vp8_write_bit ( bc , send_update ) ;if ( send_update ) {int Data ;for ( i = 0 ;i < MAX_REF_LF_DELTAS ;i ++ ) {Data = xd -> ref_lf_deltas [ i ] ;if ( xd -> ref_lf_deltas [ i ] != xd -> last_ref_lf_deltas [ i ] || cpi -> oxcf . error_resilient_mode ) {xd -> last_ref_lf_deltas [ i ] = xd -> ref_lf_deltas [ i ] ;vp8_write_bit ( bc , 1 ) ;if ( Data > 0 ) {vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ;vp8_write_bit ( bc , 0 ) ;}else {Data = - Data ;vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ;vp8_write_bit ( bc , 1 ) ;}}else vp8_write_bit ( bc , 0 ) ;}for ( i = 0 ;i < MAX_MODE_LF_DELTAS ;i ++ ) {Data = xd -> mode_lf_deltas [ i ] ;if ( xd -> mode_lf_deltas [ i ] != xd -> last_mode_lf_deltas [ i ] || cpi -> oxcf . error_resilient_mode ) {xd -> last_mode_lf_deltas [ i ] = xd -> mode_lf_deltas [ i ] ;vp8_write_bit ( bc , 1 ) ;if ( Data > 0 ) {vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ;vp8_write_bit ( bc , 0 ) ;}else {Data = - Data ;vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ;vp8_write_bit ( bc , 1 ) ;}}else vp8_write_bit ( bc , 0 ) ;}}}vp8_write_literal ( bc , pc -> multi_token_partition , 2 ) ;vp8_write_literal ( bc , pc -> base_qindex , 7 ) ;put_delta_q ( bc , pc -> y1dc_delta_q ) ;put_delta_q ( bc , pc -> y2dc_delta_q ) ;put_delta_q ( bc , pc -> y2ac_delta_q ) ;put_delta_q ( bc , pc -> uvdc_delta_q ) ;put_delta_q ( bc , pc -> uvac_delta_q ) ;if ( pc -> frame_type != KEY_FRAME ) {vp8_write_bit ( bc , pc -> refresh_golden_frame ) ;vp8_write_bit ( bc , pc -> refresh_alt_ref_frame ) ;if ( ! pc -> refresh_golden_frame ) vp8_write_literal ( bc , pc -> copy_buffer_to_gf , 2 ) ;if ( ! pc -> refresh_alt_ref_frame ) vp8_write_literal ( bc , pc -> copy_buffer_to_arf , 2 ) ;vp8_write_bit ( bc , pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) ;vp8_write_bit ( bc , pc -> ref_frame_sign_bias [ ALTREF_FRAME ] ) ;}# if ! ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cpi -> oxcf . error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS ) {if ( pc -> frame_type == KEY_FRAME ) pc -> refresh_entropy_probs = 1 ;else pc -> refresh_entropy_probs = 0 ;# endif vp8_write_bit ( bc , pc -> refresh_entropy_probs ) ;if ( pc -> frame_type != KEY_FRAME ) vp8_write_bit ( bc , pc -> refresh_last_frame ) ;# ifdef VP8_ENTROPY_STATS if ( pc -> frame_type == INTER_FRAME ) active_section = 0 ;else active_section = 7 ;# endif vp8_clear_system_state ( ) ;# if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING pack_coef_probs ( cpi ) ;# else if ( pc -> refresh_entropy_probs == 0 ) {vpx_memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;}","memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ;",3786
1919,"vpx_memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ;cpi -> partition_d [ i + 1 ] = dp ;","vpx_memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ;cpi -> partition_d [ i + 1 ] = dp ;",3786
1920,"else # endif  pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ;vp8_stop_encode ( & cpi -> bc [ 1 ] ) ;","else # endif pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ;vp8_stop_encode ( & cpi -> bc [ 1 ] ) ;",3786
1921,if ( likely ( s [ 1 ] && s [ 2 ] ) ) {* d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ;s += 2 ;,char t = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ;* d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>' ) ;s += 2 ;,3787
1922,value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) |   ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;}value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) |   ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;},value = ( unsigned int ) buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ;return ( ( unsigned int ) ( value & 0xffffffff ) ) ;}value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ;value |= ( unsigned int ) buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ;return ( value & 0xffffffff ) ;},3788
1923,i ++ ;if ( file -> f_flags & O_NONBLOCK ) {,"if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) {clear_bit ( WDM_OVERFLOW , & desc -> flags ) ;rv = - ENOBUFS ;goto err ;}i ++ ;if ( file -> f_flags & O_NONBLOCK ) {",3789
1924,"int n , length ;uint8_t * buf ;struct l2tp_dict_attr_t * da ;struct l2tp_attr_t * attr , * RV = NULL ;uint8_t * ptr ;socklen_t len = sizeof ( addr ) ;struct msghdr msg ;char msg_control [ 128 ] ;struct cmsghdr * cmsg ;uint16_t orig_avp_len ;msg . msg_controllen = 128 ;n = recvmsg ( fd , & msg , MSG_PEEK ) ;","struct l2tp_packet_t * pack ;struct l2tp_attr_t * RV = NULL ;uint8_t * ptr ;socklen_t addr_len ;uint16_t orig_avp_len ;uint8_t * buf , * ptr ;int n , length ;struct msghdr msg ;struct cmsghdr * cmsg ;char msg_control [ 128 ] ;msg . msg_controllen = 128 ;n = recvmsg ( fd , & msg , MSG_PEEK ) ;",3790
1925,"n = recvfrom ( fd , buf , L2TP_MAX_PACKET_SIZE , 0 , & addr , & len ) ;if ( n < 0 ) {mempool_free ( buf ) ;if ( errno == EAGAIN ) {return - 1 ;}else if ( errno == ECONNREFUSED ) {return - 2 ;}log_error ( ""l2tp:<S2SV_blank>recv:<S2SV_blank>%s\\\return 0 ;}if ( n < 6 ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%zu)\\\if ( hdr -> T == 0 )  goto out_err_hdr ;if ( n < ntohs ( hdr -> length ) ) {if ( conf_verbose )  log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%i)\\\goto out_err_hdr ;}if ( hdr -> ver == 2 ) {if ( hdr -> L == 0 ) {if ( conf_verbose )  log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\\if ( ! conf_avp_permissive ) goto out_err_hdr ;}if ( hdr -> S == 0 ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(S=0)\\\if ( ! conf_avp_permissive ) goto out_err_hdr ;}if ( hdr -> O == 1 ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(O=1)\\\if ( ! conf_avp_permissive ) goto out_err_hdr ;}else if ( hdr -> ver != 3 ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%i<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\\","addr_len = sizeof ( addr ) ;n = recvfrom ( fd , buf , L2TP_MAX_PACKET_SIZE , 0 , & addr , & addr_len ) ;if ( n < sizeof ( * hdr ) ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%zu)\\\if ( hdr -> T == 0 ) goto out_err_hdr ;if ( n < ntohs ( hdr -> length ) ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%i)\\\goto out_err_hdr ;hdr -> flags = ntohs ( hdr -> flags ) ;if ( ! ( hdr -> flags & L2TP_FLAG_T ) ) goto out_err_hdr ;if ( ! ( hdr -> flags & L2TP_FLAG_L ) ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\\",3790
1926,"length = ntohs ( hdr -> length ) - sizeof ( * hdr ) ;while ( length ) {* ( uint16_t * ) ptr = ntohs ( * ( uint16_t * ) ptr ) ;if ( avp -> length > length ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(exceeds<S2SV_blank>message<S2SV_blank>length)\\\if ( conf_verbose )   log_warn ( ""l2tp:<S2SV_blank>unknown<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%u)\\\if ( avp -> M && ! conf_avp_permissive ) goto out_err ;if ( da -> M != - 1 && da -> M != avp -> M ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\\if ( da -> H != - 1 && da -> H != avp -> H ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\\if ( avp -> H ) {if ( ! RV ) {","length -= sizeof ( * hdr ) ;while ( length > 0 ) {struct l2tp_dict_attr_t * da ;struct l2tp_attr_t * attr ;uint16_t avp_len ;if ( length < sizeof ( * avp ) ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\\goto out_err ;}if ( avp -> length > length ) {if ( conf_verbose ) {log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(exceeds<S2SV_blank>message<S2SV_blank>length)\\\if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>unknown<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%u)\\\if ( avp -> M && ! conf_avp_permissive ) goto out_err ;if ( da -> M != - 1 && da -> M != avp -> M ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\\if ( da -> H != - 1 && da -> H != avp -> H ) {if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\\if ( avp -> H ) {if ( ! RV ) {",3790
1927,}attr = mempool_alloc ( attr_pool ) ;if ( avp -> H ) {orig_avp_len = ntohs ( * ( uint16_t * ) avp -> val ) + sizeof ( * avp ) ;orig_avp_val = avp -> val + sizeof ( uint16_t ) ;else {orig_avp_len = avp -> length ;orig_avp_val = avp -> val ;}attr -> attr = da ;attr -> M = avp -> M ;attr -> H = 0 ;attr -> length = orig_avp_len - sizeof ( * avp ) ;if ( attr -> attr -> id == Random_Vector ) RV = attr ;switch ( da -> type ) {case ATTR_TYPE_INT16 : if ( orig_avp_len != sizeof ( * avp ) + 2 ) goto out_err_len ;attr -> val . uint16 = ntohs ( * ( uint16_t * ) orig_avp_val ) ;break ;case ATTR_TYPE_INT32 : if ( orig_avp_len != sizeof ( * avp ) + 4 ) goto out_err_len ;attr -> val . uint32 = ntohl ( * ( uint32_t * ) orig_avp_val ) ;break ;case ATTR_TYPE_INT64 : if ( orig_avp_len != sizeof ( * avp ) + 8 ) goto out_err_len ;attr -> val . uint64 = be64toh ( * ( uint64_t * ) orig_avp_val ) ;break ;case ATTR_TYPE_OCTETS : attr -> val . octets = _malloc ( attr -> length ) ;,}attr = mempool_alloc ( attr_pool ) ;if ( avp -> H ) ;,3790
1928,skip :  ptr += avp -> length ;length -= avp -> length ;},skip : ptr += avp -> length ;length -= avp -> length ;},3790
1929,port -> exists = false ;synchronize_irq ( I8042_AUX_IRQ ) ;port -> serio = NULL ;},spin_lock_irq ( & i8042_lock ) ;port -> exists = false ;port -> serio = NULL ;spin_unlock_irq ( & i8042_lock ) ;synchronize_irq ( I8042_AUX_IRQ ) ;},3791
1930,"ret = - EFAULT ;if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ;ret = security_file_permission ( file , MAY_READ ) ;if ( unlikely ( ret ) ) break ;ret = aio_setup_single_vector ( kiocb ) ;ret = - EFAULT ;if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ;ret = security_file_permission ( file , MAY_WRITE ) ;if ( unlikely ( ret ) ) break ;ret = aio_setup_single_vector ( kiocb ) ;ret = security_file_permission ( file , MAY_READ ) ;if ( unlikely ( ret ) ) break ;","ret = aio_setup_single_vector ( READ , file , kiocb ) ;ret = aio_setup_single_vector ( WRITE , file , kiocb ) ;",3792
1931,"ret = security_file_permission ( file , MAY_WRITE ) ;if ( unlikely ( ret ) ) break ;","
",3792
1932,register const u_char * ep ;register const struct pim * pim = ( const struct pim * ) bp ;ep = ( const u_char * ) ndo -> ndo_snapend ;if ( bp >= ep ) return ;# endif  switch ( PIM_VER ( pim -> pim_typever ) ) {case 2 : if ( ! ndo -> ndo_vflag ) {,register const struct pim * pim = ( const struct pim * ) bp ;# endif ND_TCHECK ( pim -> pim_typever ) ;switch ( PIM_VER ( pim -> pim_typever ) ) {case 2 : if ( ! ndo -> ndo_vflag ) {,3793
1933,},"trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ;return ;}",3793
1934,"static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key ,  unsigned int keylen ) {","int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , unsigned int keylen ) {",3794
1935,"# ifdef HAVE_IPV6  char * p ;if ( * ( str ) == \'[\' && str_len > 1 ) {p = memchr ( str + 1 , \']\' , str_len - 2 ) ;if ( ! p || * ( p + 1 ) != \':\' ) {* portno = atoi ( p + 2 ) ;return estrndup ( str + 1 , p - str - 1 ) ;","# ifdef HAVE_IPV6 if ( * ( str ) == \'[\' && str_len > 1 ) {char * p = memchr ( str + 1 , \']\' , str_len - 2 ) , * e = NULL ;if ( ! p || * ( p + 1 ) != \':\' ) {* portno = strtol ( p + 2 ) ;return estrndup ( str + 1 , p - str - 1 ) ;",3795
1936,"* portno = atoi ( colon + 1 ) ;host = estrndup ( str , colon - str ) ;}else {if ( get_err ) {return host ;}","char * e = NULL ;* portno = strtol ( colon + 1 , & e , 10 ) ;if ( ! e || ! * e ) {return estrndup ( str , colon - str ) ;}}if ( get_err ) {",3795
1937,"pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , ""error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file"" ) ;}else {if ( amt_read == 0 && ! fail_on_eof ) return ( 0 ) ;pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE ,  ""truncated<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%"" PRIsize ""<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%"" PRIsize ,  bytes_to_read , amt_read ) ;","pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , ""truncated<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%"" PRIsize ""<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%"" PRIsize , bytes_to_read , amt_read ) ;",3796
1938,if ( count < sizeof hdr )  return - EINVAL ;,if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ;if ( count < sizeof hdr ) return - EINVAL ;,3797
1939,"file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ;if ( ! file ) {","file = fopen_safe ( ""/tmp/keepalived.json"" , ""w"" ) ;if ( ! file ) {",3798
1940,"ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ;if ( ret ) return ;","ret = perf_output_begin ( & handle , event , read_event . header . size , 0 ) ;if ( ret ) return ;",3799
1941,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS ,  1 , 0 , regs , 0 ) ;__get_user ( insn . word , pc ) ;","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;__get_user ( insn . word , pc ) ;",3800
1942,iocb -> private = ext4_init_io_end ( inode ) ;if ( ! iocb -> private ) return - ENOMEM ;,"iocb -> private = ext4_init_io_end ( inode , GFP_NOFS ) ;if ( ! iocb -> private ) return - ENOMEM ;",3801
1943,"gdImagePtr pim = 0 , tim = im ;int interlace , BitsPerPixel ;interlace = im -> interlace ;if ( im -> trueColor ) {pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ;if ( ! pim ) {","_gdImageGifCtx ( im , 1 , 256 ) ;if ( ! pim ) {",3802
1944,},"
",3802
1945,if ( map_data )  copy = true ;,if ( ! iter_is_iovec ( iter ) ) goto fail ;if ( map_data ) copy = true ;,3803
1946,rq -> bio = NULL ;return - EINVAL ;,fail : rq -> bio = NULL ;return - EINVAL ;,3803
1947,# endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) &&  is_kvmppc_hv_enabled ( kvm ) ;break ;,# endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && hv_enabled ;break ;,3804
1948,"char group [ LONG_STRING ] ;char desc [ HUGE_STRING ] = """" ;if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\\nntp_data = nntp_data_find ( nserv , group ) ;","char group [ LONG_STRING ] = """" ;char desc [ HUGE_STRING ] = """" ;if ( sscanf ( line , ""%1023s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\\mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\\return 0 ;}nntp_data = nntp_data_find ( nserv , group ) ;",3805
1949,"AcquireNextImage ( image_info , image ) ;if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ;","if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;AcquireNextImage ( image_info , image ) ;if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ;",3806
1950,if ( index > MAX_SUPPORTED_TV_TIMING )  return false ;,if ( index >= MAX_SUPPORTED_TV_TIMING ) return false ;,3807
1951,if ( index == 1 ) {mode -> crtc_htotal -= 1 ;mode -> crtc_vtotal -= 1 ;}break ;case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ;if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 )  return false ;,if ( index >= MAX_SUPPORTED_TV_TIMING_V1_2 ) return false ;,3807
1952,"actd = ( vp8_variance16x16 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ;act = ( vp8_variance16x16 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ;# ifdef USE_SSD  sad = ( vp8_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ) ;sad = ( sse + 128 ) >> 8 ;usad = ( vp8_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ) ;usad = ( sse + 32 ) >> 6 ;vsad = ( vp8_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ) ;vsad = ( sse + 32 ) >> 6 ;# else sad = ( vp8_sad16x16 ( y , y_stride , yd , yd_stride , UINT_MAX ) + 128 ) >> 8 ;usad = ( vp8_sad8x8 ( u , uv_stride , ud , uvd_stride , UINT_MAX ) + 32 ) >> 6 ;vsad = ( vp8_sad8x8 ( v , uv_stride , vd , uvd_stride , UINT_MAX ) + 32 ) >> 6 ;# endif }else {actd = ( vp8_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ;act = ( vp8_variance8x8 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ;# ifdef USE_SSD  sad = ( vp8_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ) ;sad = ( sse + 32 ) >> 6 ;usad = ( vp8_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ) ;usad = ( sse + 8 ) >> 4 ;vsad = ( vp8_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ) ;vsad = ( sse + 8 ) >> 4 ;","actd = ( vpx_variance16x16 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ;act = ( vpx_variance16x16 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ;# ifdef USE_SSD vpx_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ;sad = ( sse + 128 ) >> 8 ;vpx_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) + 32 ) >> 6 ;vpx_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ;vsad = ( sse + 32 ) >> 6 ;act = ( vp8_variance8x8 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ;# ifdef USE_SSD vpx_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ;sad = ( vp8_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ) ;sad = ( sse + 32 ) >> 6 ;usad = ( vp8_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ) ;usad = ( sse + 8 ) >> 4 ;vsad = ( vp8_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ) ;vsad = ( sse + 8 ) >> 4 ;",3808
1953,"++ i , up += uv_stride , udp += uvd_stride )  vpx_memcpy ( udp , up , uvblksize ) ;for ( vp = v , vdp = vd , i = 0 ;++ i , vp += uv_stride , vdp += uvd_stride )  vpx_memcpy ( vdp , vp , uvblksize ) ;}","+ i , up += uv_stride , udp += uvd_stride )  vpx_memcpy ( udp , up , uvblksize ) ;++ i , up += uv_stride , udp += uvd_stride ) memcpy ( udp , up , uvblksize ) ;for ( vp = v , vdp = vd , i = 0 ;+ i , vp += uv_stride , vdp += uvd_stride )  vpx_memcpy ( vdp , vp , uvblksize ) ;++ i , vp += uv_stride , vdp += uvd_stride ) memcpy ( vdp , vp , uvblksize ) ;}",3808
1954,"update_write_field_flags ( s , orderInfo -> fieldFlags , orderInfo -> controlFlags ,  PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ) ;update_write_bounds ( s , orderInfo ) ;","update_write_field_flags ( s , orderInfo -> fieldFlags , orderInfo -> controlFlags , get_primary_drawing_order_field_bytes ( orderInfo -> orderType ] ) ;update_write_bounds ( s , orderInfo ) ;",3809
1955,"if ( err )  return err ;return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ;","if ( err ) {kfree_skb ( skb ) ;return err ;}return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ;",3810
1956,msg -> msg_namelen = 0 ;if ( ! siocb -> scm ) {,if ( ! siocb -> scm ) {,3811
1957,char temp [ 500 ] ;int i = 0 ;,int temp_size = 500 ;char * temp = malloc ( temp_size ) ;int i = 0 ;,3812
1958,temp [ i ] = fgetc ( fp ) ;if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == \'\\\\0\' || temp [ i ] == EOF ) ) {,"if ( i >= temp_size ) {temp_size *= 2 ;temp = realloc ( temp , temp_size ) ;}temp [ i ] = fgetc ( fp ) ;if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == \'\\\\0\' || temp [ i ] == EOF ) ) {",3812
1959,"encode_share_access ( xdr , arg -> open_flags ) ;return 0 ;","encode_share_access ( xdr , arg -> fmode ) ;return 0 ;",3813
1960,"
","memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;",3814
1961,av_freep ( & h -> DPB ) ;},av_freep ( & h -> DPB ) ;},3814
1962,"# endif  timr -> it_overrun += ( unsigned int )  hrtimer_forward ( timer , now , timr -> it_interval ) ;","# endif timr -> it_overrun += hrtimer_forward ( timer , now , timr -> it_interval ) ;",3815
1963,"if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;","if ( NULL == siocb -> scm , false ) siocb -> scm = & tmp_scm ;err = scm_send ( sock , msg , siocb -> scm ) ;if ( err < 0 ) return err ;",3816
1964,"}if ( ! asoc -> assoc_id ) {sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ;}}kfree ( asoc -> peer . peer_random ) ;asoc -> peer . peer_random = new -> peer . peer_random ;new -> peer . peer_random = NULL ;kfree ( asoc -> peer . peer_chunks ) ;asoc -> peer . peer_chunks = new -> peer . peer_chunks ;new -> peer . peer_chunks = NULL ;kfree ( asoc -> peer . peer_hmacs ) ;asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ;new -> peer . peer_hmacs = NULL ;sctp_auth_key_put ( asoc -> asoc_shared_key ) ;sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ;","sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ;",3817
1965,"
",dcfg -> xml_external_entity = NOT_SET ;,3818
1966,return dcfg ;},return dcfg ;},3818
1967,"pdf = calloc ( 1 , sizeof ( pdf_t ) ) ;if ( name ) {pdf -> name = malloc ( strlen ( n ) + 1 ) ;strcpy ( pdf -> name , n ) ;pdf -> name = malloc ( strlen ( ""Unknown"" ) + 1 ) ;strcpy ( pdf -> name , ""Unknown"" ) ;","pdf = safe_calloc ( sizeof ( pdf_t ) ) ;if ( name ) {pdf -> name = safe_calloc ( strlen ( n ) + 1 ) ;strcpy ( pdf -> name , n ) ;pdf -> name = safe_calloc ( strlen ( ""Unknown"" ) + 1 ) ;strcpy ( pdf -> name , ""Unknown"" ) ;",3819
1968,if ( * off >= skb -> len ) {* off -= skb -> len ;,if ( * off >= skb -> len && skb -> len ) {* off -= skb -> len ;,3820
1969,"ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data ,  size2 , mime ) ;if ( ret < 0 ) return ret ;","ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , size2 , NULL ) ;if ( ret < 0 ) return ret ;",3821
1970,"if ( rt -> rt_flags & RTCF_NOTIFY )  r -> rtm_flags |= RTM_F_NOTIFY ;if ( nla_put_be32 ( skb , RTA_DST , dst ) ) goto nla_put_failure ;","if ( rt -> rt_flags & RTCF_NOTIFY ) r -> rtm_flags |= RTM_F_NOTIFY ;if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT ;if ( nla_put_be32 ( skb , RTA_DST , dst ) ) goto nla_put_failure ;",3822
1971,return 0 ;},_TIFFfree ( working_copy ) ;return 0 ;},3823
1972,if ( indev != NULL ) {ifa = indev -> ifa_list ;,if ( indev && indev -> ifa_list ) {ifa = indev -> ifa_list ;,3824
1973,"
",down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;,3825
1974,"truncate_pagecache ( inode , inode -> i_size ) ;if ( shrink )  ext4_truncate ( inode ) ;}","truncate_pagecache ( inode , inode -> i_size ) ;if ( shrink ) ext4_truncate ( inode ) ;up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;}",3825
1975,int procfd ;signed long personality ;,signed long personality ;,3826
1976,"pid_t to_cleanup_pid = pid ;close ( ipc_sockets [ 1 ] ) ;status = 0 ;ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ;if ( ret <= 0 ) {ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ;ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 )  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ;if ( options -> stdin_fd == 0 ) {signal ( SIGINT , SIG_IGN ) ;signal ( SIGQUIT , SIG_IGN ) ;}ret = wait_for_pid ( pid ) ;if ( ret < 0 ) goto cleanup_error ;to_cleanup_pid = attached_pid ;","int procfd = - 1 ;pid_t to_cleanup_pid = pid ;close ( ipc_sockets [ 1 ] ) ;procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc."" ) ;ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ;",3826
1977,"if ( ret != 0 )  ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ;goto cleanup_error ;shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;close ( ipc_sockets [ 0 ] ) ;cleanup_error :  shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;","if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ;goto cleanup_error ;}ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ;if ( ret <= 0 ) {if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>"" ""from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ;goto cleanup_error ;shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;close ( ipc_sockets [ 0 ] ) ;cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ;",3826
1978,"procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ;if ( procfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ;shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ;rexit ( - 1 ) ;}","
",3826
1979,". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload ,  . procfd = procfd  }",". ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , . exec_payload = exec_payload , }",3826
1980,rp [ 0 ] = 1 ;res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ;res -> sign = 0 ;,"res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ;if ( res -> nlimbs ) {if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ;rp = res -> d ;rp [ 0 ] = 1 ;}res -> sign = 0 ;",3827
1981,if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC )  s -> mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM ;,if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ;else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ;if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) s -> mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM ;,3828
1982,}if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) s -> mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM ;,}if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) s -> mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM ;,3828
1983,"args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ;args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return xdr_argsize_check ( rqstp , p ) ;}","if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ;args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return 1 ;}",3829
1984,int valuelen = args -> valuelen ;int nmap ;ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ;while ( valuelen > 0 ) {,int valuelen ;int nmap ;ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ;ASSERT ( args -> rmtvaluelen == args -> valuelen ) ;valuelen = args -> rmtvaluelen ;while ( valuelen > 0 ) {,3830
1985,"int openasuser ;int should_free_origin = 0 ;int should_free_authpending_file = 0 ;parse_cfg ( flags , argc , argv , cfg ) ;","int openasuser = 0 ;int should_free_origin = 0 ;int should_free_authpending_file = 0 ;PAM_MODUTIL_DEF_PRIVS ( privs ) ;parse_cfg ( flags , argc , argv , cfg ) ;openasuser = geteuid ( ) == 0 ? 1 : 0 ;",3831
1986,"snprintf ( buf , authfile_dir_len ,  ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ;else {DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ;authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ;buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ;if ( ! buf ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ;retval = PAM_IGNORE ;goto done ;snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ;}DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ;cfg -> auth_file = buf ;should_free_auth_file = 1 ;openasuser = geteuid ( ) == 0 && cfg -> openasuser ;if ( openasuser ) {if ( seteuid ( pw_s . pw_uid ) ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ;retval = PAM_IGNORE ;DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ;}if ( seteuid ( 0 ) ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ;DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ;}if ( cfg -> nouserok ) {DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ;","snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ;if ( ! openasuser ) {DBG ( ""WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>"" ""consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration"" , buf ) ;DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ;cfg -> auth_file = buf ;should_free_auth_file = 1 ;openasuser = geteuid ( ) == 0 && cfg -> openasuser ;if ( openasuser ) {if ( seteuid ( pw_s . pw_uid ) ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ;retval = PAM_IGNORE ;DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ;}DBG ( ""Dropping<S2SV_blank>privileges"" ) ;if ( pam_modutil_drop_priv ( pamh , & privs , pw ) ) {DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ;DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ;}if ( pam_modutil_regain_priv ( pamh , & privs ) ) {DBG ( ""could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges"" ) ;",3831
1987,"DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ;if ( cfg -> is_custom_debug_file ) {fclose ( cfg -> debug_file ) ;","DBG ( ""Restored<S2SV_blank>privileges"" ) ;",3831
1988,"
",ret = - EPERM ;if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ;,3832
1989,if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end &&  end > cur -> vm_start ) {if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ;,if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) {if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) ;WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) goto out_unlock ;,3832
1990,BUG_ON ( vma -> vm_userfaultfd_ctx . ctx &&  vma -> vm_userfaultfd_ctx . ctx != ctx ) ;if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ;,BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ;if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ;,3832
1991,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",3833
1992,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",3834
1993,data -> l_head = NULL ;data -> portListing = NULL ;data -> portListingLength = 0 ;,"memset ( data , 0 , sizeof ( struct NameValueParserData ) ) ;",3835
1994,"
","if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}",3836
1995,"( void ) ReadBlobString ( image , text ) ;if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) {","( void ) ReadBlobString ( image , text ) ;if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) {",3836
1996,"struct user_struct * user = group -> inotify_data . user ;pr_debug ( ""%s:<S2SV_blank>group=%p\\\atomic_dec ( & user -> inotify_devs ) ;return 0 ;","pr_debug ( ""%s:<S2SV_blank>group=%p\\\return 0 ;",3837
1997,"unsigned char  * lastrow ,  * one_row , * ptr ;","unsigned char * last_row , * one_row , * ptr ;",3838
1998,"GetMagickPixelPacket ( image , & transpix ) ;if ( bits_per_pixel == 16 ) {redbits = ( size_t ) ReadBlobByte ( image ) ;( void ) redbits ;greenbits = ( size_t ) ReadBlobByte ( image ) ;( void ) greenbits ;bluebits = ( size_t ) ReadBlobByte ( image ) ;( void ) bluebits ;ReadBlobByte ( image ) ;ReadBlobByte ( image ) ;transpix . red = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ;transpix . green = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ;transpix . blue = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ;}if ( bits_per_pixel == 8 ) {IndexPacket index ;if ( flags & PALM_HAS_COLORMAP_FLAG ) {count = ( ssize_t ) ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) count ;i ++ ) {ReadBlobByte ( image ) ;index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ;image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;}}else for ( i = 0 ;i < ( ssize_t ) ( 1L << bits_per_pixel ) ;i ++ ) {index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ;image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ;image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ;image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ;}}if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ;( void ) size ;image -> storage_class = DirectClass ;if ( bits_per_pixel < 16 ) {image -> storage_class = PseudoClass ;image -> depth = 8 ;}if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( image ) ;}status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ;lastrow = ( unsigned char * ) NULL ;if ( compressionType == PALM_COMPRESSION_SCANLINE ) {lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row ,   2 * image -> columns ) , sizeof ( * lastrow ) ) ;if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","last_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ;lastrow = ( unsigned char * ) NULL ;if ( compressionType == PALM_COMPRESSION_SCANLINE ) {lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * lastrow ) ) ;if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",3838
1999,"else  one_row [ i + bit ] = lastrow [ i + bit ] ;}( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ;}","else one_row [ i + bit ] = lastrow [ i + bit ] ;}}( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ;",3838
2000,"if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;","if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;",3838
2001,"if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;","if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;",3838
2002,if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;if ( EOFBlob ( image ) != MagickFalse ) {,if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row ) ;if ( EOFBlob ( image ) != MagickFalse ) {,3838
2003,if ( retval ) {,if ( retval || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != \'\\\\0\' ) {,3839
2004,"if ( retval ) {com_err ( ""uu-server"" , retval , ""reading<S2SV_blank>pname"" ) ;","if ( retval ) {com_err ( ""uu-server"" , retval , ""reading<S2SV_blank>pname"" ) ;",3839
2005,"static void mark_object ( struct object * obj , struct strbuf * path ,  const char * name , void * data ) {","static void mark_object ( struct object * obj , const char * name , void * data ) {",3840
2006,"void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr )  {vcpu -> arch . apic -> vapic_addr = vapic_addr ;if ( vapic_addr ) __set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;else  __clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;}","int kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) {if ( vapic_addr ) {if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ;__set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;}else {__clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ;}vcpu -> arch . apic -> vapic_addr = vapic_addr ;return 0 ;}",3841
2007,"static vpx_codec_err_t ctrl_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {int * const update_info = va_arg ( args , int * ) ;if ( update_info ) {if ( ctx -> pbi )   * update_info = ctx -> pbi -> refresh_frame_flags ;else return VPX_CODEC_ERROR ;return VPX_CODEC_INVALID_PARAM ;}}","static vpx_codec_err_t ctrl_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , va_list args ) {int * const update_info = va_arg ( args , int * ) ;if ( ctx -> frame_workers ) {VPxWorker * const worker = ctx -> frame_workers ;FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ;* update_info = ctx -> pbi -> refresh_frame_flags ;return VPX_CODEC_INVALID_PARAM ;}}return VPX_CODEC_INVALID_PARAM ;}",3842
2008,if ( addr > ( vdev -> config_len - sizeof ( val ) ) )  return ;,if ( addr + sizeof ( val ) ) ) return ;,3843
2009,"* p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ;* p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ;* p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ;* p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ;* p_max_prec = 0 ;","* p_tx0 = ( OPJ_INT32 ) opj_uint_max ( p_cp -> tx0 + p * p_cp -> tdx , p_image -> x0 ) ;* p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx , p_image -> x1 ) ;* p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy , p_image -> y0 ) ;* p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy , p_image -> y1 ) ;* p_max_prec = 0 ;",3844
2010,mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ;if ( mmap_is_legacy ( ) ) {,mm -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor ;if ( mmap_is_legacy ( ) ) {,3845
2011,"static INLINE void fdct32x32 ( int rd_transform ,  const int16_t * src , int16_t * dst , int src_stride ) {if ( rd_transform )  vp9_fdct32x32_rd ( src , dst , src_stride ) ;else  vp9_fdct32x32 ( src , dst , src_stride ) ;}","static INLINE void fdct32x32 ( int rd_transform , const int16_t * src , tran_low_t * dst , int src_stride ) {if ( rd_transform ) vpx_fdct32x32_rd ( src , dst , src_stride ) ;else vpx_fdct32x32 ( src , dst , src_stride ) ;}",3846
2012,"if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) {char saved_p ;for ( line += 18 ;isspace ( * line ) ;line ++ )  ;","if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( ( unsigned char ) line [ 17 ] ) ) {char saved_p ;for ( line += 18 ;isspace ( ( unsigned char ) * line ) ;line ++ ) ;",3847
2013,for ( ;line < last && isspace ( * line ) ;line ++ )  ;else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] )   && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) )  blocktyp = PFA_HEX ;,for ( ;line < last && isspace ( ( unsigned char ) * line ) ;line ++ ) ;else if ( last >= line + 4 && isxdigit ( ( unsigned char ) line [ 0 ] ) && isxdigit ( ( unsigned char ) line [ 1 ] ) && isxdigit ( ( unsigned char ) line [ 2 ] ) && isxdigit ( ( unsigned char ) line [ 3 ] ) ) blocktyp = PFA_HEX ;,3847
2014,gfp_mask = sk -> sk_allocation ;if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ;,int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;err = - EMSGSIZE ;if ( npages > MAX_SKB_FRAGS ) goto failure ;gfp_mask = sk -> sk_allocation ;if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ;,3848
2015,int npages ;int i ;if ( ! data_len )  break ;npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;,int i ;if ( ! data_len ) break ;npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;,3848
2016,"if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ;return ;}if ( ! ndo -> ndo_eflag ) {ND_PRINT ( ( ndo , ""ARP,<S2SV_blank>"" ) ) ;}if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || PROTO_LEN ( ap ) != 4 || HRD_LEN ( ap ) == 0 || ndo -> ndo_vflag ) {ND_PRINT ( ( ndo , ""%s<S2SV_blank>(len<S2SV_blank>%u),<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u)"" , tok2str ( arphrd_values , ""Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)"" , hrd ) , HRD_LEN ( ap ) , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , pro ) , PROTO_LEN ( ap ) ) ) ;case ARPOP_REQUEST :  ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;break ;case ARPOP_REPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" ,  ipaddr_string ( ndo , SPA ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , ""who-is<S2SV_blank>%s<S2SV_blank>tell<S2SV_blank>%s"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_INVREPLY :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" ,   linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ,  ipaddr_string ( ndo , SPA ( ap ) ) ) ) ;","if ( ! ND_TTEST2 ( * TPA ( ap ) , PROTO_LEN ( ap ) ) ) {ND_PRINT ( ( ndo , ""who-has<S2SV_blank>"" ) ) ;tpaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REQUEST : ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ;if ( isnonzero ( ( const u_char * ) THA ( ap ) , HRD_LEN ( ap ) ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>"" ) ) ;spaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_REVREQUEST : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;tpaddr_print_ip ( ndo , ap , pro ) ;case ARPOP_REVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , ""%s<S2SV_blank>at<S2SV_blank>"" , linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;case ARPOP_INVREPLY : ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) ) ) ;spaddr_print_ip ( ndo , ap , pro ) ;",3849
2017,const VP9_CONFIG * const oxcf = & cpi -> oxcf ;const RATE_CONTROL * const rc = & cpi -> rc ;int layer ;int layer_end ;if ( svc -> number_temporal_layers > 1 ) {layer_end = svc -> number_temporal_layers ;else {layer_end = svc -> number_spatial_layers ;for ( layer = 0 ;layer < layer_end ;++ layer ) {LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ;RATE_CONTROL * const lrc = & lc -> rc ;if ( svc -> number_temporal_layers > 1 ) {lc -> target_bandwidth = oxcf -> ts_target_bitrate [ layer ] * 1000 ;,"const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;const RATE_CONTROL * const rc = & cpi -> rc ;int sl , tl , layer = 0 , spatial_layer_target ;if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) {for ( sl = 0 ;sl < oxcf -> ss_number_layers ;++ sl ) {spatial_layer_target = 0 ;for ( tl = 0 ;tl < oxcf -> ts_number_layers ;++ tl ) {layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ;svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ;}layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ;spatial_layer_target = svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ;for ( tl = 0 ;tl < oxcf -> ts_number_layers ;++ tl ) {LAYER_CONTEXT * const lc = & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ;RATE_CONTROL * const lrc = & lc -> rc ;lc -> spatial_layer_target_bandwidth = spatial_layer_target ;bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ;lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ;lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ;lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ;lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ;lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ;lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ;lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ;lrc -> worst_quality = rc -> worst_quality ;lrc -> best_quality = rc -> best_quality ;}+ layer ) {else {int layer_end ;if ( svc -> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) {lc -> target_bandwidth = oxcf -> ts_target_bitrate [ layer ] * 1000 ;",3850
2018,lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ;}lc -> framerate = oxcf -> framerate ;}lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ;},lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ;}lc -> framerate = oxcf -> framerate ;}lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ;}},3850
2019,"-------------------\\\psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;return 1 ;return 0 ;}","if ( psf -> fileoffset < psf -> filelength ) {psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ;return 1 ;};return 0 ;}",3851
2020,dst_reg -> id = ptr_reg -> id ;switch ( opcode ) {,"dst_reg -> id = ptr_reg -> id ;if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ;switch ( opcode ) {",3852
2021,"
","if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;",3852
2022,__update_reg_bounds ( dst_reg ) ;__reg_deduce_bounds ( dst_reg ) ;,__update_reg_bounds ( dst_reg ) ;__reg_deduce_bounds ( dst_reg ) ;,3852
2023,"else  return ast_for_call ( c , CHILD ( n , 1 ) , left_expr ) ;}","else return ast_for_call ( c , CHILD ( n , 1 ) , left_expr , true ) ;}",3853
2024,"if ( ep_loop_check ( ep , tfile ) != 0 )   goto error_tgt_fput ;}","if ( ep_loop_check ( ep , tfile ) != 0 ) {clear_tfile_check_list ( ) ;goto error_tgt_fput ;}}",3854
2025,else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) {if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode_x2apic ;,else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) ) {if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode_x2apic ;,3855
2026,print_bpf_insn ( insn ) ;},"print_bpf_insn ( env , insn ) ;}",3856
2027,},mono_reflection_shutdown ( ) ;},3857
2028,"stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;switch ( stlv_type ) {case ISIS_SUBTLV_SPB_INSTANCE :  ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\","ND_TCHECK2 ( * tptr , 2 ) ;stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;if ( len < stlv_len ) goto trunc ;ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;switch ( stlv_type ) {case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",3858
2029,"while ( tmp )  {ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ;ND_PRINT ( ( ndo , ""\\\len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;tmp -- ;case ISIS_SUBTLV_SPBM_SI :  ND_TCHECK2 ( * tptr , 8 ) ;ND_PRINT ( ( ndo , ""\\\","stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ;while ( tmp ) {if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ;tmp -- ;case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",3858
2030,}return 0 ;,tptr += stlv_len ;len -= stlv_len ;}return 0 ;,3858
2031,"
","if ( overflow2 ( sidx , nc ) ) {goto fail1 ;}",3859
2032,"sidx = sizeof ( t_chunk_info ) * nc ;if ( sidx <= 0 ) {cidx = gdCalloc ( sidx , 1 ) ;for ( i = 0 ;","sidx = sizeof ( t_chunk_info ) * nc ;if ( sidx <= 0 ) {cidx = gdCalloc ( sidx , 1 ) ;if ( cidx == NULL ) {goto fail1 ;}for ( i = 0 ;",3859
2033,"assert ( ( occ0 % rowsize ) == 0 ) ;assert ( sp -> decodepfunc != NULL ) ;( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ;occ0 -= rowsize ;","if ( ( occ0 % rowsize ) != 0 ) {if ( ! TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize<S2SV_blank>!=<S2SV_blank>0"" ) ;return 0 ;}assert ( sp -> decodepfunc != NULL ) ;( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ) return 0 ;occ0 -= rowsize ;",3860
2034,goto out ;},goto out2 ;},3861
2035,"return ( xdr_opaque ( xdrs , * objp , size ) ) ;case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ;","if ( ! xdr_opaque ( xdrs , * objp , size ) ) return FALSE ;if ( ( * objp ) [ size - 1 ] != '\\\\0' ) return FALSE ;if ( memchr ( * objp , '\\\\0' , size - 1 ) != NULL ) return FALSE ;return TRUE ;case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ;",3862
2036,"u_char showspi , showdata , showsomedata ;const char * notify_name ;showdata = 0 ;showsomedata = 0 ;","u_char showspi , showsomedata ;const char * notify_name ;showsomedata = 0 ;",3863
2037,showsomedata = 1 ;showdata = 0 ;,showsomedata = 1 ;,3863
2038,"if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ;cp = ( const u_char * ) ( p + 1 ) + n . spi_size ;if ( 3 < ndo -> ndo_vflag ) {showdata = 1 ;}if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) {ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ;}else if ( showsomedata && cp < ep ) {if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;}","if ( cp < ep ) {if ( ndo -> ndo_vflag ) {showdata = 1 ;if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) {ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ;}else if ( showsomedata ) {if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ;}}",3863
2039,"status = dm9000ReadReg ( DM9000_REG_ISR ) ;if ( ( status & ISR_LNKCHG ) != 0 ) {mask = dm9000ReadReg ( DM9000_REG_IMR ) ;dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_LNKCHGI ) ;interface -> nicEvent = TRUE ;if ( ( status & ISR_PT ) != 0 )  {dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ;}dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_PRI ) ;interface -> nicEvent = TRUE ;","status = dm9000ReadReg ( DM9000_ISR ) ;if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) {mask = dm9000ReadReg ( DM9000_IMR ) ;dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_LNKCHGI ) ;interface -> nicEvent = TRUE ;if ( ( status & ISR_PT ) != 0 ) {dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ;}dm9000WriteReg ( DM9000_IMR , mask & ~ IMR_PRI ) ;interface -> nicEvent = TRUE ;",3864
2040,break ;case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) {if ( s -> codec_id == AV_CODEC_ID_JV ) {w_align = 8 ;,if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) {w_align = 8 ;h_align = 8 ;}break ;case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) {if ( s -> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) {w_align = 8 ;,3865
2041,"ext4_show_quota_options ( seq , sb ) ;return 0 ;","if ( test_opt ( sb , DIOREAD_NOLOCK ) ) seq_puts ( seq , "",dioread_nolock"" ) ;ext4_show_quota_options ( seq , sb ) ;return 0 ;",3866
2042,"BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp )  {if ( rdp -> decrypt_use_count >= 4096 ) {","BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp ) {if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;if ( rdp -> decrypt_use_count >= 4096 ) {",3867
2043,"# if ENABLE_BGP_VNC  case BGP_ATTR_VNC : # endif case BGP_ATTR_ENCAP : ret = bgp_attr_encap ( type , peer , length , attr , flag , startp ) ;","# if ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC : # endif case BGP_ATTR_ENCAP : ret = bgp_attr_encap ( type , peer , length , attr , flag , startp ) ;",3868
2044,"comics_document -> selected_command = g_find_program_in_path ( ""unrar-free"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = GNAUNRAR ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}}","
",3869
2045,"comics_document -> selected_command = g_find_program_in_path ( ""7z"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = P7ZIP ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}","
",3869
2046,"comics_document -> selected_command = g_find_program_in_path ( ""7z"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = P7ZIP ;return TRUE ;}comics_document -> selected_command =  g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}}else if ( g_content_type_is_a ( mime_type , ""application/x-cbt"" ) || g_content_type_is_a ( mime_type , ""application/x-tar"" ) ) {comics_document -> selected_command = g_find_program_in_path ( ""tar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}comics_document -> selected_command = g_find_program_in_path ( ""bsdtar"" ) ;if ( comics_document -> selected_command ) {comics_document -> command_usage = TAR ;return TRUE ;}","
",3869
2047,"break ;case PT_RREQ : if ( wb_rreq ( ndo , ( const struct pkt_rreq * ) ( ph + 1 ) , len ) >= 0 ) return ;break ;case PT_RREP : if ( wb_rrep ( ndo , ( const struct pkt_rrep * ) ( ph + 1 ) , len ) >= 0 ) return ;break ;case PT_DRAWOP : if ( wb_drawop ( ndo , ( const struct pkt_dop * ) ( ph + 1 ) , len ) >= 0 ) return ;break ;case PT_PREQ : if ( wb_preq ( ndo , ( const struct pkt_preq * ) ( ph + 1 ) , len ) >= 0 ) return ;break ;case PT_PREP : if ( wb_prep ( ndo , ( const struct pkt_prep * ) ( ph + 1 ) , len ) >= 0 )  return ;break ;","ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_RREQ : if ( wb_rreq ( ndo , ( const struct pkt_rreq * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_RREP : if ( wb_rrep ( ndo , ( const struct pkt_rrep * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_DRAWOP : if ( wb_drawop ( ndo , ( const struct pkt_dop * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_PREQ : if ( wb_preq ( ndo , ( const struct pkt_preq * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;case PT_PREP : if ( wb_prep ( ndo , ( const struct pkt_prep * ) ( ph + 1 ) , len ) >= 0 ) return ;ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;break ;",3870
2048,"int i , pktsz , ret ;if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) {","int pktsz , ret ;if ( usb_set_interface ( usbdev , intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) {",3871
2049,"dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\\i = 0x12345678 ;catc_write_mem ( catc , 0x7a80 , & i , 4 ) ;i = 0x87654321 ;catc_write_mem ( catc , 0xfa80 , & i , 4 ) ;catc_read_mem ( catc , 0x7a80 , & i , 4 ) ;switch ( i ) {case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ;","u32 * buf ;int i ;dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\\buf = kmalloc ( 4 , GFP_KERNEL ) ;if ( ! buf ) {ret = - ENOMEM ;goto fail_free ;}* buf = 0x12345678 ;catc_write_mem ( catc , 0x7a80 , buf , 4 ) ;i = 0x87654321 ;catc_write_mem ( catc , 0xfa80 , buf , 4 ) ;catc_read_mem ( catc , 0x7a80 , buf , 4 ) ;switch ( i ) {case 0x12345678 : catc_set_reg ( catc , TxBufCount , 8 ) ;",3871
2050,"}dev_dbg ( dev , ""Getting<S2SV_blank>MAC<S2SV_blank>from<S2SV_blank>SEEROM.\\\","}kfree ( buf ) ;dev_dbg ( dev , ""Getting<S2SV_blank>MAC<S2SV_blank>from<S2SV_blank>SEEROM.\\\",3871
2051,"void * p = au -> reply_buf ;void * end = p + sizeof ( au -> reply_buf ) ;ret = ceph_x_decrypt ( & th -> session_key , & p , end , & reply , sizeof ( reply ) ) ;if ( ret < 0 ) return ret ;","void * preply = & reply ;void * p = au -> reply_buf ;void * end = p + sizeof ( au -> reply_buf ) ;ret = ceph_x_decrypt ( & th -> session_key , & p , end , & preply , sizeof ( reply ) ) ;if ( ret < 0 ) return ret ;",3872
2052,cp += advance ;len -= advance ;,if ( len < ( u_int ) advance ) goto trunc ;cp += advance ;len -= advance ;,3873
2053,"nh = * cp ;return ;case IPPROTO_ROUTING :  advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ;nh = * cp ;break ;","if ( advance < 0 ) return ;nh = * cp ;return ;case IPPROTO_ROUTING : ND_TCHECK ( * cp ) ;advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ;if ( advance < 0 ) return ;nh = * cp ;break ;",3873
2054,"case IPPROTO_AH :  advance = ah_print ( ndo , cp ) ;nh = * cp ;nh = enh & 0xff ;len -= padlen ;","case IPPROTO_AH : advance = ah_print ( ndo , cp ) ;if ( advance < 0 ) return ;nh = * cp ;if ( advance < 0 ) return ;nh = enh & 0xff ;len -= padlen ;",3873
2055,if ( p == q || size < 16 || size > 256 )  return ( ( Image * ) NULL ) ;,if ( ( p == q ) || ( size < 16 || size > 256 ) ) return ( ( Image * ) NULL ) ;,3874
2056,"
",ND_TCHECK ( tptr [ 1 ] ) ;,3875
2057,"ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values ,  ""?"" , tptr [ 0 ] ) ) ) ;for ( i = 0 ;","ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ;for ( i = 0 ;",3875
2058,jpc_tsfb_band_t bnds [ 64 ] ;jpc_pchg_t * pchg ;,jpc_tsfb_band_t bnds [ JPC_MAXBANDS ] ;jpc_pchg_t * pchg ;,3876
2059,if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) )  return - EINVAL ;,if ( validate_core_offset ( reg ) ) return - EINVAL ;if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ;,3877
2060,if ( -- timer -> running )  list_del ( & ti -> active_list ) ;},if ( -- timer -> running ) list_del_init ( & ti -> active_list ) ;},3878
2061,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,3879
2062,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",3879
2063,"g_return_if_fail ( RS_IS_FILTER ( filter ) ) ;GString * str = g_string_new ( ""digraph<S2SV_blank>G<S2SV_blank>{g_file_set_contents ( ""/tmp/rs-filter-graph"" , str -> str , str -> len , NULL ) ;if ( 0 != system ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>/tmp/rs-filter-graph.png<S2SV_blank></tmp/rs-filter-graph"" ) )  g_warning ( ""Calling<S2SV_blank>dot<S2SV_blank>failed"" ) ;if ( 0 != system ( ""gnome-open<S2SV_blank>/tmp/rs-filter-graph.png"" ) )   g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ;g_string_free ( str , TRUE ) ;","g_return_if_fail ( RS_IS_FILTER ( filter ) ) ;gchar * dot_filename ;gchar * png_filename ;gchar * command_line ;GString * str = g_string_new ( ""digraph<S2SV_blank>G<S2SV_blank>{dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ;png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ;g_file_set_contents ( dot_filename , str -> str , str -> len , NULL ) ;command_line = g_strdup_printf ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s"" , png_filename , dot_filename ) ;if ( 0 != system ( command_line ) ) g_warning ( ""Calling<S2SV_blank>dot<S2SV_blank>failed"" ) ;g_free ( command_line ) ;command_line = g_strdup_printf ( ""gnome-open<S2SV_blank>%s"" , png_filename ) ;if ( 0 != system ( command_line ) ) g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ;g_free ( command_line ) ;g_free ( dot_filename ) ;g_free ( png_filename ) ;g_string_free ( str , TRUE ) ;",3880
2064,return res ;cleanup : if ( hdl ) {,cleanup : return res ;cleanup : if ( hdl ) {,3881
2065,sb -> s_op = & ext2_sops ;sb -> s_export_op = & ext2_export_ops ;,"# ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ;if ( ! sbi -> s_mb_cache ) {ext2_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ;goto failed_mount3 ;}# endif sb -> s_op = & ext2_sops ;sb -> s_export_op = & ext2_export_ops ;",3882
2066,failed_mount3 :  percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ;,failed_mount3 : if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ;percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ;,3882
2067,"if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) &&  ( IN_DEV_SHARED_MEDIA ( out_dev ) ||   inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) {flags |= RTCF_DOREDIRECT ;do_cache = false ;}","if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) && skb -> protocol == htons ( ETH_P_IP ) && ( IN_DEV_SHARED_MEDIA ( out_dev ) || inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ;",3883
2068,"unsigned long kflags = key -> flags ;kenter ( ""{","unsigned long kflags = READ_ONCE ( key -> flags ) ;short state = READ_ONCE ( key -> state ) ;kenter ( ""{",3884
2069,if ( kflags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) ) ) {if ( ! ( ctx -> flags & KEYRING_SEARCH_SKIP_EXPIRED ) ) ctx -> result = ERR_PTR ( - EKEYEXPIRED ) ;,if ( state < 0 ) {if ( ! ( ctx -> flags & KEYRING_SEARCH_SKIP_EXPIRED ) ) ctx -> result = ERR_PTR ( state ) ;,3884
2070,"if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) {smp_rmb ( ) ;ctx -> result = ERR_PTR ( key -> reject_error ) ;kleave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]"" , ctx -> skipped_ret ) ;","if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) {smp_rmb ( ) ;ctx -> result = ERR_PTR ( key -> reject_error ) ;kleave ( ""<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]"" , ctx -> skipped_ret ) ;",3884
2071,if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) {if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO )  c -> idct_put = ff_simple_idct_put_int32_10bit ;,if ( c -> mpeg4_studio_profile ) c -> idct_put = ff_simple_idct_put_int32_10bit ;,3885
2072,subsampling_dx = parameters -> subsampling_dx ;subsampling_dy = parameters -> subsampling_dy ;,"if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) {char ch ;OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ;long curpos = ftell ( f ) ;if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) {expected_file_size = ( OPJ_UINT64 ) INT_MAX ;}fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ;if ( fread ( & ch , 1 , 1 , f ) != 1 ) {fclose ( f ) ;return NULL ;}fseek ( f , curpos , SEEK_SET ) ;}subsampling_dx = parameters -> subsampling_dx ;subsampling_dy = parameters -> subsampling_dy ;",3886
2073,dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ;for ( i = 0 ;,"dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ;if ( iface_desc -> desc . bNumEndpoints < 1 ) {dev_err ( & interface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\\retval = - EINVAL ;goto error ;}for ( i = 0 ;",3887
2074,"
",struct name_snapshot name ;,3888
2075,"mask |= FS_EVENT_ON_CHILD ;if ( path )  ret = fsnotify ( p_inode , mask , path , FSNOTIFY_EVENT_PATH ,  dentry -> d_name . name , 0 ) ;else ret = fsnotify ( p_inode , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE ,  dentry -> d_name . name , 0 ) ;}","mask |= FS_EVENT_ON_CHILD ;take_dentry_name_snapshot ( & name , dentry ) ;if ( path ) ret = fsnotify ( p_inode , mask , path , FSNOTIFY_EVENT_PATH , name . name , 0 ) ;else ret = fsnotify ( p_inode , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE , name . name , 0 ) ;release_dentry_name_snapshot ( & name ) ;}",3888
2076,"if ( level != SOL_PPPOL2TP )  return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ;if ( get_user ( len , optlen ) ) return - EFAULT ;","if ( level != SOL_PPPOL2TP ) return - EINVAL ;if ( get_user ( len , optlen ) ) return - EFAULT ;",3889
2077,"memcpy ( data -> strval , * bnode , size ) ;data -> strval [ size ] = \'\\\\0\' ;","if ( ! data -> strval ) {plist_free_data ( data ) ;PLIST_BIN_ERR ( ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%"" PRIu64 ""<S2SV_blank>bytes\\\return NULL ;}memcpy ( data -> strval , * bnode , size ) ;data -> strval [ size ] = \'\\\\0\' ;",3890
2078,static int  mptctl_hp_targetinfo ( unsigned long arg )  {MPT_ADAPTER * ioc ;MPT_SCSI_HOST * hd = NULL ;hp_target_info_t karg ;int iocnum ;,"static int mptctl_hp_targetinfo ( MPT_ADAPTER * ioc , unsigned long arg ) {MPT_SCSI_HOST * hd = NULL ;hp_target_info_t karg ;int iocnum ;",3891
2079,"if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) ||   ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_hp_targetinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;}if ( karg . hdr . id >= MPT_MAX_FC_DEVICES ) return - EINVAL ;",if ( karg . hdr . id >= MPT_MAX_FC_DEVICES ) return - EINVAL ;,3891
2080,"++ v ;v -> iov_base = ( char * ) ""\\\( void ) __writev ( STDERR_FILENO , iov , 2 ) ;}","+ v ;if ( buf [ bufsize - 1 ] != \'\\\++ v ;v -> iov_base = ( char * ) ""\\\}( void ) __writev ( STDERR_FILENO , iov , v - iov + 1 ) ;}",3892
2081,if ( xWantedSize > 0 )  {if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )  {}}if ( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )  {,if ( ( xWantedSize > 0 ) && ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize + heapSTRUCT_SIZE ) > xWantedSize ) ) {if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) {configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ;}else {xWantedSize = 0 ;}}else {xWantedSize = 0 ;}if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) {,3893
2082,if ( * t ++ != * q ++ ) return 0 ;lowlen -- ;,if ( t >= tend ) return 0 ;if ( * t ++ != * q ++ ) return 0 ;lowlen -- ;,3894
2083,"static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data ,  UINT32 scanline ) {}","static BOOL nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) {return TRUE ;}",3895
2084,"static char temp [ NFSX_V3FHMAX + 1 ] ;strncpy ( temp , sfsname , NFSX_V3FHMAX ) ;temp [ sizeof ( temp ) - 1 ] = \'\\\\0\' ;spacep = strchr ( temp , \'<S2SV_blank>\' ) ;","char temp [ NFSX_V3FHMAX + 1 ] ;u_int stringlen ;stringlen = len ;if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ;strncpy ( temp , sfsname , stringlen ) ;temp [ sizeof ( temp ) - 1 ] = \'\\\\0\' ;spacep = strchr ( temp , \'<S2SV_blank>\' ) ;",3896
2085,"if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) )  {","if ( TEMP_FAILURE_RETRY ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) ) != sizeof ( cmd ) ) {",3897
2086,"
",clear_buffer_delay ( bh ) ;clear_buffer_unwritten ( bh ) ;,3898
2087,bh -> b_bdev = NULL ;return may_free ;,bh -> b_bdev = NULL ;return may_free ;,3898
2088,"if ( JAS_CAST ( uint , jas_stream_write ( out , ( char * ) ppm -> data , ppm -> len ) ) != ppm -> len ) {return - 1 ;","if ( JAS_CAST ( jas_uint , jas_stream_write ( out , ( char * ) ppm -> data , ppm -> len ) ) != ppm -> len ) {return - 1 ;",3899
2089,"if ( strlen ( str ) >= sizeof ( lowstr ) )  {return NULL ;}return NULL ;}result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ;if ( ! result ) return NULL ;if ( dtype != DTK_DELTA ) {if ( tm2interval ( tm , fsec , result ) != 0 )  {","if ( strlen ( str ) > MAXDATELEN ) {return NULL ;}free ( result ) ;return NULL ;}if ( tm2interval ( tm , fsec , result ) != 0 ) {errno = PGTYPES_INTVL_BAD_INTERVAL ;return NULL ;}if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) {if ( tm2interval ( tm , fsec , result ) != 0 ) {",3900
2090,"stmt_ty  AsyncWith ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int  end_lineno , int end_col_offset , PyArena * arena ) {p -> lineno = lineno ;p -> col_offset = col_offset ;","stmt_ty AsyncWith ( asdl_seq * items , asdl_seq * body , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) {p -> v . AsyncWith . type_comment = type_comment ;p -> lineno = lineno ;p -> col_offset = col_offset ;",3901
2091,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ;struct xfrm_dump_info info ;BUILD_BUG_ON ( sizeof ( struct xfrm_policy_walk ) > sizeof ( cb -> args ) - sizeof ( cb -> args [ 0 ] ) ) ;if ( ! cb -> args [ 0 ] ) {cb -> args [ 0 ] = 1 ;,struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ;struct xfrm_dump_info info ;if ( ! cb -> args [ 0 ] ) {cb -> args [ 0 ] = 1 ;,3902
2092,case '#' : DBUG_PUSH ( argument ? argument : default_dbug_option ) ;,# include < sslopt - case . h > case '#' : DBUG_PUSH ( argument ? argument : default_dbug_option ) ;,3903
2093,"case 'h' :  case 'W' : case 'P' : case 'S' : case OPT_MYSQL_PROTOCOL : case OPT_SHARED_MEMORY_BASE_NAME : case OPT_PLUGIN_DIR : case OPT_DEFAULT_AUTH : add_one_option ( & conn_args , opt , argument ) ;","case 'h' : case 'W' : case 'P' : case 'S' : case OPT_MYSQL_PROTOCOL : case OPT_SHARED_MEMORY_BASE_NAME : case OPT_PLUGIN_DIR : case OPT_DEFAULT_AUTH : add_one_option ( & conn_args , opt , argument ) ;",3903
2094,"assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ;return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) ,  ( ( char * ) buf ) + offs , len ) ;","size_t ss = CDF_SEC_SIZE ( h ) ;size_t pos = CDF_SEC_POS ( h , id ) ;assert ( ss == len ) ;return cdf_read ( info , ( off_t ) pos , ( ( char * ) buf ) + offs , len ) ;",3904
2095,next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ;if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ;,loff_t max_chunk_size = UINT_MAX & bsize_mask ;next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ;if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ;,3905
2096,"if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ;while ( len > 0 ) {if ( len < bytes ) bytes = len ;al = gfs2_alloc_get ( ip ) ;if ( ! al ) {error = - ENOMEM ;goto out_unlock ;}error = gfs2_quota_lock_check ( ip ) ;if ( error ) goto out_alloc_put ;retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ;error = gfs2_inplace_reserve ( ip ) ;if ( error ) {if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) {bytes >>= 1 ;bytes &= bsize_mask ;if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ;goto retry ;}goto out_qunlock ;}max_bytes = bytes ;calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ;al -> al_requested = data_blocks + ind_blocks ;","if ( ! gfs2_write_alloc_required ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , & max_bytes , & data_blocks , & ind_blocks ) ;",3905
2097,"unsigned char challenge [ 30 ] ;unsigned char signature [ 256 ] ;unsigned int siglen = sizeof signature ;const EVP_MD * md = EVP_sha1 ( ) ;if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) {goto err ;","unsigned char * signature = NULL ;unsigned int siglen = sizeof signature ;const EVP_MD * md = EVP_sha1 ( ) ;if ( NULL == privkey ) goto err ;siglen = EVP_PKEY_size ( privkey ) ;if ( siglen <= 0 ) goto err ;signature = malloc ( siglen ) ;if ( NULL == signature ) goto err ;if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) {goto err ;",3906
2098,err :  if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ;,err : free ( signature ) ;if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ;,3906
2099,atomic_dec ( & user -> inotify_devs ) ;out_free_uid : free_uid ( user ) ;,fsnotify_put_group ( group ) ;atomic_dec ( & user -> inotify_devs ) ;out_free_uid : free_uid ( user ) ;,3907
2100,put_device ( & dev -> dev ) ;return 0 ;,cancel_autoload_drivers ( ) ;put_device ( & dev -> dev ) ;return 0 ;,3908
2101,uint32_t tag = 0 ;int tcm_tmr ;,int tcm_tmr ;,3909
2102,"if ( tcm_tmr < 0 ) {send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED ;goto fail ;}if ( srp_tsk -> tsk_mgmt_func == SRP_TSK_ABORT_TASK ) {rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ;if ( rc < 0 ) {tag = srp_tsk -> task_tag ;}rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , tag , TARGET_SCF_ACK_KREF ) ;","rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , srp_tsk -> task_tag ) ;if ( rc < 0 ) {tag = srp_tsk -> task_tag , TARGET_SCF_ACK_KREF ) ;",3909
2103,case \'<S2SV_blank>\' : case \'=\' :  case \'\\\\r\' :  case \'\\\,"case \'<S2SV_blank>\' : case \'=\' : case \\\'""\\\' : case \'\\\\\\\\\' : case \'\\\\r\' : case \'\\\",3910
2104,# endif  exit ( i ) ;},"# endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) {fprintf ( stderr , ""Can\\\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\\exit ( 1 ) ;}# endif exit ( i ) ;}",3911
2105,"vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;if ( ! vdev -> ctx ) return - ENOMEM ;","vdev -> ctx = kcalloc ( nvec , sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ;if ( ! vdev -> ctx ) return - ENOMEM ;",3912
2106,OPCODE_DESC * opcode_desc ;ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ;,OPCODE_DESC * opcode_desc ;if ( len < 2 ) {return NULL ;}ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ;,3913
2107,int n_read = r -> end - r -> begin ;int part_read = n_read / r -> part_size ;,unsigned int actual_size = rtype == 2 ? n * 2 : n ;unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ;unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ;int n_read = limit_r_end - limit_r_begin ;int part_read = n_read / r -> part_size ;,3914
2108,"if ( flags & __GFP_ZERO )  memset ( ptr , 0 , size ) ;","memset ( ptr , 0 , size ) ;",3915
2109,if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) )  goto out_nofree ;if ( addr_len ) * addr_len = sizeof ( sa ) ;,if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) goto out_nofree ;,3916
2110,"if ( msg -> msg_name != NULL )   memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ;out : skb_free_datagram ( sk , skb ) ;","if ( msg -> msg_name != NULL ) {memcpy ( msg -> msg_name , & sa , sizeof ( sa ) ) ;* addr_len = sizeof ( sa ) ;}out : skb_free_datagram ( sk , skb ) ;",3916
2111,uint8_t * result ;new_raw_len = RAW_DATA_LEN ( header ) + nbytes ;,uint8_t * result ;if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) {return NULL ;}new_raw_len = RAW_DATA_LEN ( header ) + nbytes ;,3917
2112,"
","if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",3918
2113,for ( ;offset ++ )  {,for ( ;offset ++ ) {,3918
2114,case 0x2f8 :  return true ;,"
",3919
2115,"struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ;struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ;struct xen_netif_tx_request * txp ;if ( unlikely ( err ) ) {pending_ring_idx_t index ;index = pending_index ( netbk -> pending_prod ++ ) ;txp = & pending_tx_info [ pending_idx ] . req ;make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;netbk -> pending_ring [ index ] = pending_idx ;xenvif_put ( vif ) ;pending_ring_idx_t index ;pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ;if ( unlikely ( err ) )  xen_netbk_idx_release ( netbk , pending_idx ) ;continue ;txp = & netbk -> pending_tx_info [ pending_idx ] . req ;make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ;index = pending_index ( netbk -> pending_prod ++ ) ;netbk -> pending_ring [ index ] = pending_idx ;xen_netbk_idx_release ( netbk , pending_idx ) ;for ( j = start ;xen_netbk_idx_release ( netbk , pending_idx ) ;}","if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ;netbk -> pending_ring [ index ] = pending_idx ;xenvif_put ( vif ) ;pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ;if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ;continue ;xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY , XEN_NETIF_RSP_ERROR ) ;index = pending_index ( netbk -> pending_prod ++ ) ;netbk -> pending_ring [ index ] = pending_idx ;xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ;for ( j = start ;xen_netbk_idx_release ( netbk , pending_idx ) ;}",3920
2116,"args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;","args . rmtvaluelen = valuelen ;args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ;args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ;",3921
2117,hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ;lf = fwnet_get_hdr_lf ( & hdr ) ;,if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ;hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ;lf = fwnet_get_hdr_lf ( & hdr ) ;,3922
2118,hdr . w1 = ntohl ( buf [ 1 ] ) ;buf += 2 ;,if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ;hdr . w1 = ntohl ( buf [ 1 ] ) ;buf += 2 ;if ( fg_off + len > dg_size ) return 0 ;,3922
2119,"spin_lock_irqsave ( & dev -> lock , flags ) ;peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ;","spin_lock_irqsave ( & dev -> lock , flags ) ;peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ;",3922
2120,s = & pit_state -> channels [ addr ] ;mutex_lock ( & pit_state -> lock ) ;,if ( addr == 3 ) return 0 ;s = & pit_state -> channels [ addr ] ;mutex_lock ( & pit_state -> lock ) ;,3923
2121,"fd = open ( authfile , O_RDONLY , 0 ) ;if ( fd < 0 ) {","fd = open ( authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY ) ;if ( fd < 0 ) {else {fd = - 1 ;}",3924
2122,goto err ;},goto err ;},3924
2123,else if ( fd >= 0 )  close ( fd ) ;,if ( fd >= 0 ) close ( fd ) ;,3924
2124,"buf = malloc ( sz + 1 ) ;SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\\","buf = safe_calloc ( sz + 1 ) ;SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , ""Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\\",3925
2125,"static mongo_message * mongo_message_create ( int len , int id , int responseTo , int op ) {mongo_message * mm = ( mongo_message * ) bson_malloc ( len ) ;mm -> head . len = len ;mm -> head . id = id ;","static mongo_message * mongo_message_create ( size_t len , int id , int responseTo , int op ) {mongo_message * mm = ( mongo_message * ) bson_malloc ( len ) ;mm -> head . len = ( int ) len ;mm -> head . id = id ;",3926
2126,for ( depth = 1 ;depth ++ ) ;image -> depth = depth ;,for ( depth = 1 ;depth ++ ) if ( depth >= 64 ) break ;image -> depth = depth ;,3927
2127,"register struct enamemem * tp ;if ( len == 0 ) return ( ""<empty>"" ) ;if ( tp -> e_name )  return ( tp -> e_name ) ;tp -> e_name = cp = ( char * ) malloc ( len * 3 ) ;if ( tp -> e_name == NULL )  ( * ndo -> ndo_error ) ( ndo , ""linkaddr_string:<S2SV_blank>malloc"" ) ;","register struct bsnamemem * tp ;if ( len == 0 ) return ( ""<empty>"" ) ;if ( tp -> bs_name ) return ( tp -> bs_name ) ;tp -> bs_name = cp = ( char * ) malloc ( len * 3 ) ;if ( tp -> bs_name == NULL ) ( * ndo -> ndo_error ) ( ndo , ""linkaddr_string:<S2SV_blank>malloc"" ) ;",3928
2128,return ( tp -> e_name ) ;},return ( tp -> bs_name ) ;},3928
2129,i += 1 ;},i ++ ;},3929
2130,"sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ;sk -> sk_write_space ( sk ) ;","sk -> sk_sndbuf = max_t ( int , val * 2 , SOCK_MIN_SNDBUF ) ;sk -> sk_write_space ( sk ) ;",3930
2131,"sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ;break ;","sk -> sk_rcvbuf = max_t ( int , val * 2 , SOCK_MIN_RCVBUF ) ;break ;",3930
2132,"memcpy ( data -> strval , * bnode , size ) ;data -> strval [ size ] = \'\\\\0\' ;","if ( ! data -> strval ) {plist_free_data ( data ) ;PLIST_BIN_ERR ( ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%"" PRIu64 ""<S2SV_blank>bytes\\\return NULL ;}memcpy ( data -> strval , * bnode , size ) ;data -> strval [ size ] = \'\\\\0\' ;",3931
2133,case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) {,case RSVP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ;while ( obj_tlen >= 4 ) {,3932
2134,"case RSVP_CTYPE_1 :  ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" ,  ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ;","case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ;",3932
2135,bool slow ;if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ;,bool slow ;if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ;,3933
2136,"
",* addr_len = sizeof ( * sin6 ) ;,3933
2137,}if ( is_udp4 ) {,}if ( is_udp4 ) {,3933
2138,smb_ofile_t * of = NULL ;uint16_t StructSize ;,uint16_t StructSize ;,3934
2139,"of = sr -> fid_ofile ;if ( ( of -> f_node -> flags & NODE_FLAGS_WRITE_THROUGH ) == 0 ) ( void ) smb_fsop_commit ( sr , of -> f_cr , of -> f_node ) ;","smb_ofile_flush ( sr , sr -> fid_ofile ;if ( ( of -> f_node -> flags & NODE_FLAGS_WRITE_THROUGH ) == 0 ) ( void ) smb_fsop_commit ( sr , of -> f_cr , of -> f_node ) ;",3934
2140,}pin -> request_count -- ;,rdev -> ena_pin = NULL ;return ;}pin -> request_count -- ;,3935
2141,"int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) )  return - 1 ;","static int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {const UINT64 offset = ( UINT64 ) fields -> BufferOffset + ( UINT64 ) fields -> Len ;if ( offset > Stream_Length ( s ) ) return - 1 ;",3936
2142,if ( rv < 0 )   goto out ;bmc -> pdev . dev . driver = & ipmidriver . driver ;,if ( rv < 0 ) {kfree ( bmc ) ;goto out ;}bmc -> pdev . dev . driver = & ipmidriver . driver ;,3937
2143,"declen = mutt_b64_decode ( out2 , out1 ) ;if ( ! TEST_CHECK ( declen == - 1 ) ) {","declen = mutt_b64_decode ( out2 , out1 , sizeof ( out2 ) ) ;if ( ! TEST_CHECK ( declen == - 1 ) ) {",3938
2144,"declen = mutt_b64_decode ( out2 , out1 ) ;if ( ! TEST_CHECK ( declen == i ) ) {","declen = mutt_b64_decode ( out2 , out1 , sizeof ( out2 ) ) ;if ( ! TEST_CHECK ( declen == i ) ) {",3938
2145,if ( ch_id >= UIPC_CH_NUM ) {,if ( TEMP_FAILURE_RETRY ( ch_id >= UIPC_CH_NUM ) {,3939
2146,"if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 )  {","if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) ) == 0 ) {",3939
2147,"n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ;if ( n == 0 ) {","n = TEMP_FAILURE_RETRY ( recv ( fd , p_buf + n_read , len - n_read , 0 ) ) ;if ( n == 0 ) {",3939
2148,PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;p = val ;q = p ;while ( * q != PS_DELIMITER ) {,int skip = 0 ;PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ;p = val ;q = p ;skip = 0 ;while ( * q != PS_DELIMITER ) {,3940
2149,"goto skip ;}php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}","skip = 1 ;}if ( ! skip ) {php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ;}}",3940
2150,"PS_ADD_VARL ( name , namelen ) ;skip : efree ( name ) ;","if ( ! skip ) {PS_ADD_VARL ( name , namelen ) ;}skip : efree ( name ) ;",3940
2151,"status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ;if ( ( status & EIR_LINKIF ) != 0 )  {enc28j60ReadPhyReg ( interface , ENC28J60_PHY_REG_PHIR ) ;enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_LINKIF ) ;value = enc28j60ReadPhyReg ( interface , ENC28J60_PHY_REG_PHSTAT2 ) ;if ( ( value & PHSTAT2_LSTAT ) != 0 )  {","status = enc28j60ReadReg ( interface , ENC28J60_EIR ) ;if ( ( status & ENC28J60_EIR_LINKIF ) != 0 ) {enc28j60ReadPhyReg ( interface , ENC28J60_PHIR ) ;enc28j60ClearBit ( interface , ENC28J60_EIR , ENC28J60_EIR_LINKIF ) ;value = enc28j60ReadPhyReg ( interface , ENC28J60_PHSTAT2 ) ;if ( ( value & ENC28J60_PHSTAT2_LSTAT ) != 0 ) {",3941
2152,"if ( ( status & EIR_PKTIF ) != 0 )  {enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_PKTIF ) ;do {enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE | EIE_PKTIE ) ;}","if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT ) != 0 ) {enc28j60ClearBit ( interface , ENC28J60_EIR , ENC28J60_EIR_PKTIF ) ;do {enc28j60SetBit ( interface , ENC28J60_EIE , ENC28J60_EIE_LINKIE | ENC28J60_EIE_PKTIE ) ;}",3941
2153,"linkname = archive_entry_hardlink ( a -> entry ) ;if ( linkname != NULL ) {# else  r = link ( linkname , a -> name ) ? errno : 0 ;","char * linkname_copy ;struct archive_string error_string ;int error_number ;linkname = archive_entry_hardlink ( a -> entry ) ;if ( linkname != NULL ) {# else archive_string_init ( & error_string ) ;linkname_copy = strdup ( linkname ) ;if ( linkname_copy == NULL ) {return ( EPERM ) ;}r = cleanup_pathname_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ;if ( r != ARCHIVE_OK ) {archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ;free ( linkname_copy ) ;return ( EPERM ) ;}r = check_symlinks_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ;if ( r != ARCHIVE_OK ) {archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ;free ( linkname_copy ) ;return ( EPERM ) ;}free ( linkname_copy ) ;r = link ( linkname , a -> name ) ? errno : 0 ;",3942
2154,"snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ;rcipher . blocksize = alg -> cra_blocksize ;","strncpy ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ;rcipher . blocksize = alg -> cra_blocksize ;",3943
2155,kfree ( bprm ) ;},if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;kfree ( bprm ) ;},3944
2156,"void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {if ( eob > 1 )  vp9_iwht4x4_16_add ( input , dest , stride ) ;else  vp9_iwht4x4_1_add ( input , dest , stride ) ;}","void vp9_iwht4x4_add ( const tran_low_t * input , uint8_t * dest , int stride , int eob ) {if ( eob > 1 ) vpx_iwht4x4_16_add ( input , dest , stride ) ;else vpx_iwht4x4_1_add ( input , dest , stride ) ;}",3945
2157,"BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ;}","if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ;}",3946
2158,"struct ip_options * opt = inet -> opt ;struct rtable * rt ;rt = skb_rtable ( skb ) ;if ( rt != NULL ) goto packet_routed ;rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ;if ( rt == NULL ) {__be32 daddr ;daddr = inet -> inet_daddr ;if ( opt && opt -> srr )   daddr = opt -> faddr ;rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ;packet_routed :  if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway )  goto no_route ;skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ;skb_reset_network_header ( skb ) ;if ( ip_dont_fragment ( sk , & rt -> dst ) && ! skb -> local_df ) iph -> frag_off = htons ( IP_DF ) ;else iph -> frag_off = 0 ;iph -> ttl = ip_select_ttl ( inet , & rt -> dst ) ;iph -> protocol = sk -> sk_protocol ;iph -> saddr = rt -> rt_src ;iph -> daddr = rt -> rt_dst ;if ( opt && opt -> optlen ) {iph -> ihl += opt -> optlen >> 2 ;ip_options_build ( skb , opt , inet -> inet_daddr , rt , 0 ) ;}","struct ip_options_rcu * inet_opt ;struct rtable * rt ;inet_opt = rcu_dereference ( inet -> inet_opt ) ;rt = skb_rtable ( skb ) ;if ( inet_opt && inet_opt -> opt . srr ) daddr = opt -> faddr ;rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ;packet_routed : if ( inet_opt && inet_opt -> opt . is_strictroute && rt -> rt_dst != rt -> rt_gateway ) goto no_route ;skb_push ( skb , sizeof ( struct iphdr ) + ( inet_opt ? inet_opt -> opt . optlen : 0 ) ) ;skb_reset_network_header ( skb ) ;if ( inet_opt && inet_opt -> opt . optlen ) {iph -> ihl += opt -> optlen >> 2 ;ip_options_build ( skb , & inet_opt -> opt , inet -> inet_daddr , rt , 0 ) ;}",3947
2159,timr -> it_overrun = - 1 ;++ timr -> it_requeue_pending ;info -> si_overrun += timr -> it_overrun_last ;},"+ timr -> it_requeue_pending ;timr -> it_overrun = - 1LL ;++ timr -> it_requeue_pending ;info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) ;}",3948
2160,Py_ssize_t i ;PyMemoTable * memo ;for ( i = 0 ;PyMemoEntry entry = memo -> mt_table [ i ] ;,PyMemoTable * memo ;for ( size_t i = 0 ;PyMemoEntry entry = memo -> mt_table [ i ] ;,3949
2161,"case SO_KEEPALIVE : # ifdef CONFIG_INET  if ( sk -> sk_protocol == IPPROTO_TCP )  tcp_set_keepalive ( sk , valbool ) ;","case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) tcp_set_keepalive ( sk , valbool ) ;",3950
2162,"ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( ret < 0 ) return ret ;case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EINVAL : 0 ;name = XATTR_NAME_POSIX_ACL_DEFAULT ;break ;default : return - EINVAL ;}if ( acl ) {size = posix_acl_xattr_size ( acl -> a_count ) ;value = kmalloc ( size , GFP_KERNEL ) ;if ( ! value ) {ret = - ENOMEM ;goto out ;","ret = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( ret < 0 ) return ret ;case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode , & acl ) ;if ( ret ) return ret ;",3951
2163,"StreamTcpSetEvent ( p , STREAM_PKT_BROKEN_ACK ) ;}","StreamTcpSetEvent ( p , STREAM_PKT_BROKEN_ACK ) ;goto error ;}",3952
2164,"u8 obuf [ ] = {0xde , 0 };info ( ""%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d"" , __func__ , i , state -> initialized ) ;state -> initialized = 1 ;return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ;}return 0 ;","int ret = 0 ;info ( ""%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d"" , __func__ , i , state -> initialized ) ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xde ;state -> data [ 1 ] = 0 ;state -> initialized = 1 ;ret = dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ;mutex_unlock ( & d -> data_mutex ) ;}return ret ;",3953
2165,void unix_notinflight ( struct file * fp )  {,"void unix_notinflight ( struct user_struct * user , struct file * fp ) {",3954
2166,fp -> f_cred -> user -> unix_inflight -- ;spin_unlock ( & unix_gc_lock ) ;,user -> unix_inflight -- ;spin_unlock ( & unix_gc_lock ) ;,3954
2167,"# ifdef AUTOKEY  filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;# endif  # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;# endif  step_callback = & ntpd_time_stepped ;","filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;# endif step_callback = & ntpd_time_stepped ;",3955
2168,int expected_count = 1 + extra_count ;void * * pslot ;,"struct zone * oldzone , * newzone ;int dirty ;int expected_count = 1 + extra_count ;void * * pslot ;",3956
2169,}spin_lock_irq ( & mapping -> tree_lock ) ;,}oldzone = page_zone ( page ) ;newzone = page_zone ( newpage ) ;spin_lock_irq ( & mapping -> tree_lock ) ;,3956
2170,"radix_tree_replace_slot ( pslot , newpage ) ;page_unfreeze_refs ( page , expected_count - 1 ) ;__dec_zone_page_state ( page , NR_FILE_PAGES ) ;__inc_zone_page_state ( newpage , NR_FILE_PAGES ) ;if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) {__dec_zone_page_state ( page , NR_SHMEM ) ;__inc_zone_page_state ( newpage , NR_SHMEM ) ;spin_unlock_irq ( & mapping -> tree_lock ) ;","dirty = PageDirty ( page ) ;if ( dirty ) {ClearPageDirty ( page ) ;SetPageDirty ( newpage ) ;radix_tree_replace_slot ( pslot , newpage ) ;page_unfreeze_refs ( page , expected_count - 1 ) ;spin_unlock ( & mapping -> tree_lock ) ;if ( newzone != oldzone ) {__dec_zone_state ( oldzone , NR_FILE_PAGES ) ;__inc_zone_state ( newzone , NR_FILE_PAGES ) ;if ( PageSwapBacked ( page ) ) {__dec_zone_state ( oldzone , NR_SHMEM ) ;__inc_zone_state ( newzone , NR_SHMEM ) ;}if ( dirty && mapping_cap_account_dirty ( mapping ) ) {__dec_zone_state ( oldzone , NR_FILE_DIRTY ) ;__inc_zone_state ( newzone , NR_FILE_DIRTY ) ;}}local_irq_enable ( ) ;",3956
2171,struct futex_hash_bucket * hb ;get_futex_key_refs ( & q -> key ) ;,struct futex_hash_bucket * hb ;,3957
2172,static char buf [ 256 ] ;int buflen = 0 ;,"static char buf [ 1024 + 1 ] ;char * bufp = buf ;size_t space_left = sizeof ( buf ) , string_size ;",3958
2173,"buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , ""%s%s"" ,   sepstr , lp -> s ) ;sepstr = sep ;if ( buflen == 0 )  ( void ) snprintf ( buf , sizeof ( buf ) , fmt == NULL ? ""#%08x"" : fmt , v ) ;","if ( space_left <= 1 ) return ( buf ) ;string_size = strlcpy ( bufp , sepstr , space_left ) ;if ( string_size >= space_left ) return ( buf ) ;bufp += string_size ;space_left -= string_size ;if ( space_left <= 1 ) return ( buf ) ;string_size = strlcpy ( bufp , lp -> s , space_left ) ;if ( string_size >= space_left ) return ( buf ) ;bufp += string_size ;space_left -= string_size ;sepstr = sep ;if ( bufp == buf ) ( void ) snprintf ( buf , sizeof ( buf ) , fmt == NULL ? ""#%08x"" : fmt , v ) ;",3958
2174,"length = extent ;profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;","length = extent ;if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;profile = BlobToStringInfo ( ( const void * ) NULL , length ) ;",3959
2175,"if ( ( r = sshbuf_get_u32 ( m , & state -> remote_protocol_flags ) ) != 0 || ( r = sshbuf_get_u32 ( m , & ssh1cipher ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & ssh1key , & ssh1keylen ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & ivout , & slen ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & ivin , & rlen ) ) != 0 ) return r ;if ( ssh1cipher > INT_MAX ) return SSH_ERR_KEY_UNKNOWN_CIPHER ;ssh_packet_set_encryption_key ( ssh , ssh1key , ssh1keylen , ( int ) ssh1cipher ) ;if ( cipher_get_keyiv_len ( state -> send_context ) != ( int ) slen || cipher_get_keyiv_len ( state -> receive_context ) != ( int ) rlen ) return SSH_ERR_INVALID_FORMAT ;if ( ( r = cipher_set_keyiv ( state -> send_context , ivout ) ) != 0 || ( r = cipher_set_keyiv ( state -> receive_context , ivin ) ) != 0 ) return r ;}else {if ( ( r = kex_from_blob ( m , & ssh -> kex ) ) != 0 || ( r = newkeys_from_blob ( m , ssh , MODE_OUT ) ) != 0 || ( r = newkeys_from_blob ( m , ssh , MODE_IN ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> rekey_limit ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> rekey_interval ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> p_send . seqnr ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> p_send . blocks ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> p_send . packets ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> p_send . bytes ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> p_read . seqnr ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> p_read . blocks ) ) != 0 || ( r = sshbuf_get_u32 ( m , & state -> p_read . packets ) ) != 0 || ( r = sshbuf_get_u64 ( m , & state -> p_read . bytes ) ) != 0 ) return r ;state -> rekey_time = monotime ( ) ;if ( ( r = ssh_set_newkeys ( ssh , MODE_IN ) ) != 0 || ( r = ssh_set_newkeys ( ssh , MODE_OUT ) ) != 0 ) return r ;}if ( ( r = sshbuf_get_string_direct ( m , & keyout , & slen ) ) != 0 || ( r = sshbuf_get_string_direct ( m , & keyin , & rlen ) ) != 0 ) return r ;if ( cipher_get_keycontext ( state -> send_context , NULL ) != ( int ) slen || cipher_get_keycontext ( state -> receive_context , NULL ) != ( int ) rlen ) return SSH_ERR_INVALID_FORMAT ;cipher_set_keycontext ( state -> send_context , keyout ) ;cipher_set_keycontext ( state -> receive_context , keyin ) ;if ( ( r = ssh_packet_set_compress_state ( ssh , m ) ) != 0 ||  ( r = ssh_packet_set_postauth ( ssh ) ) != 0 ) return r ;",if ( ( r = ssh_packet_set_postauth ( ssh ) ) != 0 ) return r ;,3960
2176,"err = device_register ( & bus -> dev ) ;if ( err ) {pr_err ( ""mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\\put_device ( & bus -> dev ) ;return - EINVAL ;",return - EINVAL ;,3961
2177,"case RESPONSE_RUN :  {nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ;g_free ( uri ) ;}break ;case RESPONSE_MARK_TRUSTED : {file = nautilus_file_get_location ( parameters -> file ) ;nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;","case GTK_RESPONSE_OK : {file = nautilus_file_get_location ( parameters -> file ) ;nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ;nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;nautilus_file_invalidate_all_attributes ( parameters -> file ) ;",3962
2178,"if ( ! file )  fatal ( ""Failed<S2SV_blank>to<S2SV_blank>output<S2SV_blank>file<S2SV_blank>%s"" , name ) ;return file ;","if ( ! file ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file<S2SV_blank>\\\'%s\\\'"" , name ) ;return file ;",3963
2179,int n = 0 ;apr_size_t len = 1 ;,int do_read = 1 ;int n = 0 ;apr_size_t len = 1 ;,3964
2180,plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1 ;sock = ap_get_conn_socket ( r -> connection ) ;if ( plaintext ) {,plaintext = ap_lua_ssl_is_https ( r -> connection ) ;while ( do_read ) {do_read = 0 ? 0 : 1 ;sock = ap_get_conn_socket ( r -> connection ) ;if ( plaintext ) {,3964
2181,"lua_pushboolean ( L , fin ) ;return 2 ;}if ( opcode == 0x09 ) {char frame [ 2 ] ;plen = 2 ;frame [ 0 ] = 0x8A ;frame [ 1 ] = 0 ;apr_socket_send ( sock , frame , & plen ) ;lua_websocket_read ( L ) ;}",do_read = 1 ;}},3964
2182,"for ( i = 0 ;i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ;i ++ )  photometric [ i ] = ( char ) data [ i ] ;","if ( data == ( unsigned char * ) NULL ) break ;for ( i = 0 ;i <= ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ;i ++ ) photometric [ i ] = ( char ) data [ i ] ;",3965
2183,case 0x0008 :  {number_scenes = StringToUnsignedLong ( ( char * ) data ) ;,case 0x0008 : {if ( data == ( unsigned char * ) NULL ) break ;number_scenes = StringToUnsignedLong ( ( char * ) data ) ;,3965
2184,"if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1051 : {if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ;break ;}case 0x1052 : {if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1053 : {if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ;break ;}case 0x1200 : case 0x3006 : {if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / bytes_per_pixel ) ;datum = ( int ) colors ;graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ;if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ;else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ;break ;}case 0x1201 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ;if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;redmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1202 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ;if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;greenmap [ i ] = ( int ) index ;p += 2 ;}break ;}case 0x1203 : {unsigned short index ;if ( data == ( unsigned char * ) NULL ) break ;colors = ( size_t ) ( length / 2 ) ;datum = ( int ) colors ;bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ;if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;p = data ;for ( i = 0 ;i < ( ssize_t ) colors ;i ++ ) {if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ;else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ;bluemap [ i ] = ( int ) index ;p += 2 ;}break ;}default : break ;}break ;}case 0x2050 : {switch ( element ) {case 0x0020 : {if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) polarity = MagickTrue ;break ;}default : break ;}break ;}default : break ;}if ( data != ( unsigned char * ) NULL ) {char * attribute ;for ( i = 0 ;dicom_info [ i ] . description != ( char * ) NULL ;i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ;if ( dicom_info [ i ] . description != ( char * ) NULL ) {attribute = AcquireString ( ""dcm:"" ) ;( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ;for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) {( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ;( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ;}attribute = DestroyString ( attribute ) ;}}if ( image_info -> verbose != MagickFalse ) {if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\\else {for ( i = 0 ;i < ( ssize_t ) MagickMax ( length , 4 ) ;i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ;if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) {ssize_t j ;datum = 0 ;for ( j = ( ssize_t ) length - 1 ;j >= 0 ;j -- ) datum = ( 256 * datum + data [ j ] ) ;( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ;}else for ( i = 0 ;i < ( ssize_t ) length ;i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ;else ( void ) FormatLocaleFile ( stdout , ""%c"" , \'.\' ) ;( void ) FormatLocaleFile ( stdout , ""\\\}}if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;if ( EOFBlob ( image ) != MagickFalse ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}}if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;image -> columns = ( size_t ) width ;image -> rows = ( size_t ) height ;if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ;if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) {Image * images ;ImageInfo * read_info ;int c ;size_t length ;unsigned int tag ;for ( i = 0 ;i < ( ssize_t ) stream_info -> remaining ;i ++ ) ( void ) ReadBlobByte ( image ) ;tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ;( void ) tag ;length = ( size_t ) ReadBlobLSBLong ( image ) ;stream_info -> offset_count = length >> 2 ;if ( stream_info -> offset_count != 0 ) {MagickOffsetType offset ;stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ;if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ;offset = TellBlob ( image ) ;for ( i = 0 ;i < ( ssize_t ) stream_info -> offset_count ;i ++ ) stream_info -> offsets [ i ] += offset ;}read_info = CloneImageInfo ( image_info ) ;SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ;images = NewImageList ( ) ;for ( scene = 0 ;scene < ( ssize_t ) number_scenes ;scene ++ ) {char filename [ MagickPathExtent ] ;const char * property ;FILE * file ;Image * jpeg_image ;int unique_file ;unsigned int tag ;tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ;length = ( size_t ) ReadBlobLSBLong ( image ) ;if ( tag == 0xFFFEE0DD ) break ;if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;file = ( FILE * ) NULL ;unique_file = AcquireUniqueFileResource ( filename ) ;if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ;if ( file == ( FILE * ) NULL ) {( void ) RelinquishUniqueFileResource ( filename ) ;ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ;break ;}for ( ;length != 0 ;length -- ) {c = ReadBlobByte ( image ) ;if ( c == EOF ) {ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ;break ;}( void ) fputc ( c , file ) ;}( void ) fclose ( file ) ;( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ;if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ;jpeg_image = ReadImage ( read_info , exception ) ;if ( jpeg_image != ( Image * ) NULL ) {ResetImagePropertyIterator ( image ) ;property = GetNextImageProperty ( image ) ;while ( property != ( const char * ) NULL ) {( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ;property = GetNextImageProperty ( image ) ;}AppendImageToList ( & images , jpeg_image ) ;}( void ) RelinquishUniqueFileResource ( filename ) ;}read_info = DestroyImageInfo ( read_info ) ;image = DestroyImage ( image ) ;return ( GetFirstImageInList ( images ) ) ;}if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) {QuantumAny range ;size_t length ;length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ;for ( i = 0 ;i ++ )  scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ;","if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) GetQuantumRange ( depth ) + 1 ) ;for ( i = 0 ;i ++ ) scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ;",3965
2185,"status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;","if ( pixel . red <= GetQuantumRange ( depth ) ) status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;",3965
2186,pixel . red = scale [ pixel . red ] ;pixel . green = scale [ pixel . green ] ;pixel . blue = scale [ pixel . blue ] ;},pixel . red = scale [ pixel . red ] ;if ( pixel . green <= GetQuantumRange ( depth ) ) pixel . green = scale [ pixel . green ] ;if ( pixel . blue <= GetQuantumRange ( depth ) ) pixel . blue = scale [ pixel . blue ] ;},3965
2187,"if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) {safe_close_ ( & client_socket_ ) ;","if ( TEMP_FAILURE_RETRY ( send ( client_socket_ , data , length , 0 ) ) == - 1 && errno == ECONNRESET ) {safe_close_ ( & client_socket_ ) ;",3966
2188,return 0 ;},"return count_mounts ( m -> mnt_ns , child ) ;}",3967
2189,assert ( p -> tokenpos <= p -> tokenlen ) ;if ( p -> tokenpos == p -> tokenlen ) {p -> tokenlen = p -> tokenlen * 2 + 256 ;,assert ( p -> tokenpos >= ( p -> tokenlen - 1 ) ) ;if ( p -> tokenpos == p -> tokenlen ) {p -> tokenlen = p -> tokenlen * 2 + 256 ;,3968
2190,"# ifdef HAVE_INT64_TIMESTAMP  char fstr [ MAXDATELEN + 1 ] ;strcpy ( fstr , ( cp + 1 ) ) ;strcpy ( fstr + strlen ( fstr ) , ""000000"" ) ;* ( fstr + 6 ) = \'\\\\0\' ;",# ifdef HAVE_INT64_TIMESTAMP char fstr [ 7 ] ;int i ;cp ++ ;for ( i = 0 ;i < 6 ;i ++ ) fstr [ i ] = * cp != \'\\\\0\' ? * cp ++ : \'0\' ;fstr [ i ] = \'\\\\0\' ;,3969
2191,"p = parse_tags ( render_priv , p , args [ cnt ] . end , k ) ;}","if ( args [ cnt ] . end < end ) {p = parse_tags ( render_priv , p , args [ cnt ] . end , k ) ;}else {assert ( q == end ) ;pwr = k ;q = p ;}}",3970
2192,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 ) return error ;ext4_mark_inode_dirty ( handle , inode ) ;if ( error == 0 )  acl = NULL ;}","error = posix_acl_update_mode ( inode , & inode -> i_mode ) ;if ( error < 0 ) return error ;",3971
2193,size_t len = 0 ;lua_pushnil ( L ) ;,"size_t len = 0 ;luaL_checkstack ( L , 3 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map"" ) ;lua_pushnil ( L ) ;",3972
2194,"xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ;if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;","xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) , sizeof ( * xcfdata ) ) ;if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ;",3973
2195,if ( flags & MSG_OOB )  goto out ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,if ( flags & MSG_OOB ) goto out ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,3974
2196,"}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",3974
2197,if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) {int i ;,if ( is_two_pass_svc ( cpi ) ) {int i ;,3975
2198,"fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ;# ifdef USE_HCACHE fc . hc = hc ;","fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ;if ( fc . messages == NULL ) return - 1 ;# ifdef USE_HCACHE fc . hc = hc ;",3976
2199,if ( byte [ i ] & 0x40 )  i -- ;,if ( byte [ i ] & 0x40 && i > 0 ) i -- ;,3977
2200,"return xfrm6_rcv_spi ( skb , spi ) ;}","return xfrm6_rcv_spi ( skb , spi ) > 0 ? : 0 ;}",3978
2201,for ( i = scm -> fp -> count - 1 ;i -- )  unix_notinflight ( scm -> fp -> fp [ i ] ) ;},"for ( i = scm -> fp -> user , scm -> fp -> count - 1 ;i -- ) unix_notinflight ( scm -> fp -> fp [ i ] ) ;}",3979
2202,the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;},the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;},3980
2203,"u8 smac [ ETH_ALEN ] ;u8 alt_smac [ ETH_ALEN ] ;u8 * psmac = smac ;u8 * palt_smac = alt_smac ;int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ;","
",3981
2204,"if ( is_iboe ) {if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ;else psmac = NULL ;if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ;else palt_smac = NULL ;}mutex_lock ( & lock ) ;if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ;","mutex_lock ( & lock ) ;if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ;",3981
2205,u8 ip_proto = 0 ;if ( ! data ) {,u8 ip_proto = 0 ;bool ret = false ;if ( ! data ) {,3982
2206,if ( ! iph || iph -> ihl < 5 )  return false ;nhoff += iph -> ihl * 4 ;,if ( ! iph || iph -> ihl < 5 ) goto out_bad ;nhoff += iph -> ihl * 4 ;,3982
2207,if ( ! iph )  return false ;ip_proto = iph -> nexthdr ;,if ( ! iph ) goto out_bad ;ip_proto = iph -> nexthdr ;,3982
2208,"if ( ! vlan )  return false ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) {","if ( ! vlan ) goto out_bad ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_VLANID ) ) {",3982
2209,if ( ! hdr )  return false ;proto = hdr -> proto ;default :  return false ;},if ( ! hdr ) goto out_bad ;proto = hdr -> proto ;default : goto out_bad ;},3982
2210,if ( ! hdr )  return false ;key_basic -> n_proto = proto ;key_control -> thoff = ( u16 ) nhoff ;return true ;}if ( ! hdr )  return false ;if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;return true ;return true ;default :  return false ;},if ( ! hdr ) goto out_bad ;goto out_good ;}if ( ! hdr ) goto out_bad ;if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) {goto out_good ;goto out_good ;default : return false ;},3982
2211,if ( ! hdr )  return false ;if ( hdr -> flags & ( GRE_VERSION | GRE_ROUTING ) ) break ;,if ( ! hdr ) goto out_bad ;if ( hdr -> flags & ( GRE_VERSION | GRE_ROUTING ) ) break ;,3982
2212,"if ( ! keyid )  return false ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {","if ( ! keyid ) goto out_bad ;if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_GRE_KEYID ) ) {",3982
2213,if ( ! eth )  return false ;proto = eth -> h_proto ;,if ( ! eth ) goto out_bad ;proto = eth -> h_proto ;,3982
2214,if ( ! opthdr )  return false ;ip_proto = opthdr [ 0 ] ;,if ( ! opthdr ) goto out_bad ;ip_proto = opthdr [ 0 ] ;,3982
2215,"key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;if ( skb_flow_dissector_uses_key ( flow_dissector ,  FLOW_DISSECTOR_KEY_PORTS ) ) {return true ;","if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) {out_good : ret = true ;out_bad : key_basic -> n_proto = proto ;key_basic -> ip_proto = ip_proto ;key_control -> thoff = ( u16 ) nhoff ;return ret ;",3982
2216,"unsigned char  * lastrow ,  * one_row , * ptr ;","unsigned char * last_row , * one_row , * ptr ;",3983
2217,"GetPixelInfo ( image , & transpix ) ;if ( bits_per_pixel == 16 ) {redbits = ( size_t ) ReadBlobByte ( image ) ;( void ) redbits ;greenbits = ( size_t ) ReadBlobByte ( image ) ;( void ) greenbits ;bluebits = ( size_t ) ReadBlobByte ( image ) ;( void ) bluebits ;ReadBlobByte ( image ) ;ReadBlobByte ( image ) ;transpix . red = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ;transpix . green = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ;transpix . blue = ( double ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ;}if ( bits_per_pixel == 8 ) {ssize_t index ;if ( flags & PALM_HAS_COLORMAP_FLAG ) {count = ( ssize_t ) ReadBlobMSBShort ( image ) ;for ( i = 0 ;i < ( ssize_t ) count ;i ++ ) {ReadBlobByte ( image ) ;index = ConstrainColormapIndex ( image , 255 - i , exception ) ;image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;}}else for ( i = 0 ;i < ( ssize_t ) ( 1L << bits_per_pixel ) ;i ++ ) {index = ConstrainColormapIndex ( image , 255 - i , exception ) ;image -> colormap [ index ] . red = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ;image -> colormap [ index ] . green = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ;image -> colormap [ index ] . blue = ( MagickRealType ) ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ;}}if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ;( void ) size ;image -> storage_class = DirectClass ;if ( bits_per_pixel < 16 ) {image -> storage_class = PseudoClass ;image -> depth = 8 ;}if ( image_info -> ping != MagickFalse ) {( void ) CloseBlob ( image ) ;return ( image ) ;}status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ;lastrow = ( unsigned char * ) NULL ;if ( compressionType == PALM_COMPRESSION_SCANLINE ) {lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row ,   2 * image -> columns ) , sizeof ( * lastrow ) ) ;if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;","last_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ;lastrow = ( unsigned char * ) NULL ;if ( compressionType == PALM_COMPRESSION_SCANLINE ) {lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * lastrow ) ) ;if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;",3983
2218,"else  one_row [ i + bit ] = lastrow [ i + bit ] ;}( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ;}","else one_row [ i + bit ] = lastrow [ i + bit ] ;}}( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ;",3983
2219,"if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;","if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;",3983
2220,"if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;","if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row ) ;ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ;",3983
2221,if ( compressionType == PALM_COMPRESSION_SCANLINE )  lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ;if ( EOFBlob ( image ) != MagickFalse ) {,if ( compressionType == PALM_COMPRESSION_SCANLINE ) last_row = ( unsigned char * ) RelinquishMagickMemory ( last_row ) ;if ( EOFBlob ( image ) != MagickFalse ) {,3983
2222,"dbg_hid ( ""%s,<S2SV_blank>size:%d\\\spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ;","dbg_hid ( ""%s,<S2SV_blank>size:%d\\\if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) {dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\\return false ;}spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ;",3984
2223,"int len ;if ( ! * path ) path = ""INBOX"" ;imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ;if ( ! imapc -> mailbox )  return CURLE_OUT_OF_MEMORY ;return CURLE_OK ;","if ( ! * path ) path = ""INBOX"" ;return Curl_urldecode ( data , path , 0 , & len ) ;if ( ! imapc -> mailbox , NULL , TRUE ) ;",3985
2224,"
",clear_buffer_delay ( bh ) ;clear_buffer_unwritten ( bh ) ;,3986
2225,bh -> b_bdev = NULL ;return may_free ;,bh -> b_bdev = NULL ;return may_free ;,3986
2226,return - ENOMEM ;},q -> fq = NULL ;return - ENOMEM ;},3987
2227,"int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode )  {int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ;if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) {result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ;}","int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode , int relocated ) {int flags = relocated ? RR_RELOC_DE : 0 ;int result = parse_rock_ridge_inode_internal ( de , inode , flags ) ;if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) {result = parse_rock_ridge_inode_internal ( de , inode , flags | RR_REGARD_XA ) ;}",3988
2228,"perror ( ""malloc<S2SV_blank>(ret)"" ) ;return NULL ;if ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) {image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ;dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ;liboff = image_infos [ idx ] . address - dyld_vmbase ;if ( image_infos [ idx ] . pathFileOffset > bin -> size ) {eprintf ( ""corrupted<S2SV_blank>file\\\free ( ret ) ;libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ;data = bin -> b -> buf + liboff ;","return NULL ;int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ;image_infos = malloc ( sz ) ;if ( ! image_infos ) {free ( ret ) ;return NULL ;}r_buf_read_at ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) {image_infos = ( struct dyld_cache_image_info * ) ( bin -> b , bin -> hdr . startaddr , ( ut8 * ) image_infos , sz ) ;dyld_vmbase = r_buf_read64le ( bin -> b -> buf + bin -> hdr . baseaddroff ) ;liboff = image_infos [ idx ] . address - dyld_vmbase ;int pfo = image_infos [ idx ] . pathFileOffset ;if ( pfo < 0 || pfo > bin -> size ) {eprintf ( ""corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\\free ( ret ) ;libname = r_buf_read_string ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ;data = bin -> b -> buf + liboff ;",3989
2229,static ssize_t aio_setup_single_vector ( struct kiocb * kiocb )   {kiocb -> ki_iovec = & kiocb -> ki_inline_vec ;kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ;kiocb -> ki_nr_segs = 1 ;,"static ssize_t aio_setup_single_vector ( int type , struct file * file , struct kiocb * kiocb ) {int bytes ;bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ;if ( bytes < 0 ) return bytes ;kiocb -> ki_iovec = & kiocb -> ki_inline_vec ;kiocb -> ki_iovec -> iov_len = bytes ;kiocb -> ki_nr_segs = 1 ;",3990
2230,"struct snd_kcontrol * kctl ;list_for_each_entry ( kctl , & card -> controls , list ) {","struct snd_kcontrol * kctl ;if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0 ;list_for_each_entry ( kctl , & card -> controls , list ) {",3991
2231,struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ;struct rng_alg * alg = crypto_rng_alg ( rng ) ;struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ;if ( oalg -> rng_make_random ) {rng -> generate = generate ;rng -> seed = rngapi_reset ;rng -> seedsize = oalg -> seedsize ;,"
",3992
2232,"struct mount * m , * child ;int ret = 0 ;","struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ;struct mount * m , * child ;int ret = 0 ;",3993
2233,"source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ;child = copy_tree ( source , source -> mnt . mnt_root , type ) ;","source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ;if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ;child = copy_tree ( source , source -> mnt . mnt_root , type ) ;",3993
2234,"p -> src . buf = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ;assert ( ( ( intptr_t ) pd -> pre [ 0 ] . buf & 0x7 ) == 0 ) ;pd -> pre [ 0 ] . buf = & pd -> pre [ 0 ] . buf [ raster_block_offset ( BLOCK_8X8 , i ,  pd -> pre [ 0 ] . stride ) ] ;if ( has_second_ref ( mbmi ) )  pd -> pre [ 1 ] . buf = & pd -> pre [ 1 ] . buf [ raster_block_offset ( BLOCK_8X8 , i ,  pd -> pre [ 1 ] . stride ) ] ;","p -> src . buf = & p -> src . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ;assert ( ( ( intptr_t ) pd -> pre [ 0 ] . buf & 0x7 ) == 0 ) ;pd -> pre [ 0 ] . buf = & pd -> pre [ 0 ] . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , pd -> pre [ 0 ] . stride ) ] ;if ( has_second_ref ( mbmi ) ) pd -> pre [ 1 ] . buf = & pd -> pre [ 1 ] . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , pd -> pre [ 1 ] . stride ) ] ;",3994
2235,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,3995
2236,"else {ret . code = kadm5_get_principals ( ( void * ) handle , arg -> exp , & ret . princs , & ret . count ) ;if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ;log_done ( ""kadm5_get_principals"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ;if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ;}gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",3995
2237,"ND_TCHECK ( * esis_header ) ;li = esis_header -> length_indicator ;optr = pptr ;if ( esis_header -> nlpid != NLPID_ESIS ) {ND_PRINT ( ( ndo , ""<S2SV_blank>nlpid<S2SV_blank>0x%02x<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> nlpid ) ) ;return ;}if ( esis_header -> version != ESIS_VERSION ) {ND_PRINT ( ( ndo , ""<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , esis_header -> version ) ) ;return ;}if ( li > length ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator(%u)<S2SV_blank>><S2SV_blank>PDU<S2SV_blank>size<S2SV_blank>(%u)!"" , li , length ) ) ;return ;}if ( li < sizeof ( struct esis_header_t ) + 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>length<S2SV_blank>indicator<S2SV_blank>%u<S2SV_blank><<S2SV_blank>min<S2SV_blank>PDU<S2SV_blank>size:"" , li ) ) ;while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ;return ;}esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ;if ( ndo -> ndo_vflag < 1 ) {ND_PRINT ( ( ndo , ""%s%s,<S2SV_blank>length<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( esis_pdu_values , ""unknown<S2SV_blank>type<S2SV_blank>(%u)"" , esis_pdu_type ) , length ) ) ;return ;}else ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u\\\",ND_TCHECK ( * tptr ) ;,3996
2238,"ND_TCHECK ( * pptr ) ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ;","ND_TCHECK ( * pptr ) ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ;",3996
2239,trunc :  return ;},"trunc : ND_PRINT ( ( ndo , ""[|esis]"" ) ) ;}",3996
2240,"if ( asprintf ( & src , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ;struct stat s ;if ( stat ( src , & s ) == 0 ) {","copy_file_as_user ( src , & s ) == 0 ) {",3997
2241,"pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;if ( rv )  fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\\else {fs_logger2 ( ""clone"" , dest ) ;}","pid_t child = fork ( ) ;if ( child < 0 ) errExit ( ""fork"" ) ;fs_logger2 ( ""clone"" , dest ) ;}",3997
2242,"gctx = group_leader -> ctx ;mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ;}mutex_lock ( & ctx -> mutex ) ;","gctx = __perf_event_ctx_lock_double ( group_leader , ctx ) ;if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) {if ( gctx != ctx ) {err = - EINVAL ;goto err_locked ;}perf_event_ctx_unlock ( group_leader , gctx ) ;move_group = 0 ;}}}else {mutex_lock ( & ctx -> mutex ) ;",3998
2243,"WARN_ON_ONCE ( move_group ) ;err = - EBUSY ;goto err_locked ;}WARN_ON_ONCE ( ctx -> parent_ctx ) ;if ( move_group ) {perf_remove_from_context ( group_leader , 0 ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_remove_from_context ( sibling , 0 ) ;put_ctx ( gctx ) ;}synchronize_rcu ( ) ;list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) {perf_event__state_init ( sibling ) ;perf_install_in_context ( ctx , sibling , sibling -> cpu ) ;get_ctx ( ctx ) ;}perf_event__state_init ( group_leader ) ;perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ;get_ctx ( ctx ) ;put_ctx ( gctx ) ;}perf_event__header_size ( event ) ;perf_event__id_header_size ( event ) ;event -> owner = current ;perf_install_in_context ( ctx , event , event -> cpu ) ;perf_unpin_context ( ctx ) ;if ( move_group )  mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;","WARN_ON_ONCE ( move_group ) perf_event_ctx_unlock ( group_leader , gctx ) ;mutex_unlock ( & ctx -> mutex ) ;",3998
2244,err_locked : if ( move_group )  mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;,err_locked : if ( move_group ) mutex_unlock ( & gctx -> mutex ) ;mutex_unlock ( & ctx -> mutex ) ;,3998
2245,"static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret ,  void * * p , void * end ,  void * dbuf , void * ticket_buf ) {void * dp , * dend ;int dlen ;struct ceph_crypto_key old_key ;void * tp , * tpend ;ceph_decode_need ( p , end , sizeof ( u32 ) + 1 , bad ) ;type = ceph_decode_32 ( p ) ;dout ( ""<S2SV_blank>ticket<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>%s\\\tkt_struct_v = ceph_decode_8 ( p ) ;dlen = ceph_x_decrypt ( secret , p , end , dbuf ,  TEMP_TICKET_BUF_LEN ) ;","static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * * p , void * end ) {void * dbuf = NULL ;void * dp , * dend ;int dlen ;struct ceph_crypto_key old_key ;void * ticket_buf = NULL ;void * tp , * tpend ;ceph_decode_need ( p , end , & dbuf , 0 ) ;dlen = ceph_x_decrypt ( secret , p , end , dbuf , TEMP_TICKET_BUF_LEN ) ;",3999
2246,"tp = ticket_buf ;if ( is_enc ) {dlen = ceph_x_decrypt ( & old_key , p , end , ticket_buf , TEMP_TICKET_BUF_LEN ) ;}dlen = ceph_decode_32 ( & tp ) ;ceph_decode_need ( p , end , dlen , bad ) ;ceph_decode_copy ( p , ticket_buf , dlen ) ;","if ( is_enc ) {dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 ) ;}tp = ticket_buf ;dlen = ceph_decode_32 ( & tp ) ;ticket_buf = kmalloc ( dlen , GFP_NOFS ) ;if ( ! ticket_buf ) {ret = - ENOMEM ;goto out ;}tp = ticket_buf ;ceph_decode_need ( p , end , dlen , bad ) ;ceph_decode_copy ( p , ticket_buf , dlen ) ;",3999
2247,out :  return ret ;bad : ret = - EINVAL ;,out : kfree ( ticket_buf ) ;kfree ( dbuf ) ;return ret ;bad : ret = - EINVAL ;,3999
2248,"stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;switch ( stlv_type ) {ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_MCID_MIN_LEN ) ;subtlv_spb_mcid = ( const struct isis_subtlv_spb_mcid * ) tptr ;tptr = tptr + sizeof ( struct isis_subtlv_spb_mcid ) ;len = len - sizeof ( struct isis_subtlv_spb_mcid ) ;ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\","ND_TCHECK2 ( * tptr , 2 ) ;stlv_type = * ( tptr ++ ) ;stlv_len = * ( tptr ++ ) ;len = len - 2 ;if ( len < stlv_len ) goto trunc ;ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;switch ( stlv_type ) {if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc ;subtlv_spb_mcid = ( const struct isis_subtlv_spb_mcid * ) tptr ;tptr = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ;len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ;stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ;if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc ;ND_PRINT ( ( ndo , ""\\\",4000
2249,"break ;}ND_TCHECK2 ( * ( tptr ) , stlv_len ) ;while ( len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) {ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\}break ;}return 0 ;","stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ;break ;}while ( stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) {ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ;ND_PRINT ( ( ndo , ""\\\stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ;break ;}tptr += stlv_len ;len -= stlv_len ;}return 0 ;",4000
2250,ctxt -> _eip = ctxt -> src . val ;ctxt -> src . val = old_eip ;case 4 :  ctxt -> _eip = ctxt -> src . val ;break ;,"rc = assign_eip_near ( ctxt , ctxt -> src . val ) ;if ( rc != X86EMUL_CONTINUE ) break ;ctxt -> src . val = old_eip ;case 4 : rc = assign_eip_near ( ctxt , ctxt -> src . val ) ;break ;",4001
2251,"file_sb_list_add ( f , inode -> i_sb ) ;if ( unlikely ( f -> f_mode & FMODE_PATH ) ) {",if ( unlikely ( f -> f_mode & FMODE_PATH ) ) {,4002
2252,file_sb_list_del ( f ) ;if ( f -> f_mode & FMODE_WRITE ) {,if ( f -> f_mode & FMODE_WRITE ) {,4002
2253,int err ;dp -> dccps_role = DCCP_ROLE_CLIENT ;if ( inet -> opt != NULL && inet -> opt -> srr ) {if ( daddr == 0 ) return - EINVAL ;nexthop = inet -> opt -> faddr ;},"int err ;struct ip_options_rcu * inet_opt ;dp -> dccps_role = DCCP_ROLE_CLIENT ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt != NULL && inet_opt -> opt . srr ) {if ( daddr == 0 ) return - EINVAL ;nexthop = inet_opt -> opt . faddr ;}",4003
2254,if ( inet -> opt == NULL || ! inet -> opt -> srr )  daddr = rt -> rt_dst ;if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ;inet -> inet_rcv_saddr = inet -> inet_saddr ;inet -> inet_dport = usin -> sin_port ;inet -> inet_daddr = daddr ;inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ;if ( inet -> opt != NULL )  inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ;,if ( inet_opt == NULL || ! inet -> opt -> srr ) daddr = rt -> rt_dst ;if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ;,4003
2255,"strcat ( line , buf ) ;strcat ( line , ""<S2SV_blank>"" ) ;e = e -> next ;line [ strlen ( line ) - 1 ] = 0 ;return line ;","strncat ( line , buf , sizeof line ) ;strncat ( line , buf ) ;strcat ( line , ""<S2SV_blank>"" , sizeof line ) ;e = e -> next ;line [ ( sizeof line ) - 1 ] = \'\\\\0\' ;line [ strlen ( line ) - 1 ] = 0 ;return line ;",4004
2256,tdata_t tilebuf ;uint32 imagew = TIFFScanlineSize ( in ) ;uint32 tilew = TIFFTileRowSize ( in ) ;int iskew = imagew - tilew ;uint8 * bufp = ( uint8 * ) buf ;,int64 iskew = ( int64 ) imagew - ( int64 ) tilew ;uint8 * bufp = ( uint8 * ) buf ;,4005
2257,if ( colb + tilew > imagew ) {uint32 width = imagew - colb ;,if ( colb > iskew ) {uint32 width = imagew - colb ;,4005
2258,if ( isLua ( L -> ci ) )  L -> oldpc = L -> ci -> u . l . savedpc ;,"
",4006
2259,int remaining = s -> icy_metaint - s -> icy_data_read ;if ( remaining < 0 ) return AVERROR_INVALIDDATA ;,uint64_t remaining ;if ( s -> icy_metaint < s -> icy_data_read ;if ( remaining < 0 ) return AVERROR_INVALIDDATA ;,4007
2260,if ( len < 5 )   return len ;b -> opcode = 0xe9 ;,"if ( len < 5 ) {# ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\\# endif return len ;}b -> opcode = 0xe9 ;",4008
2261,"ret = snprintf ( path , PATH_MAX , SBINDIR ""/init.lxc.static"" ) ;","ret = safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount ) ;",4009
2262,"ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ;if ( ret < 0 ) SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container"" ) ;","ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ;if ( ret < 0 ) SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container"" ) ;",4009
2263,"const FRAME_TYPE frame_type = cm -> frame_type ;if ( cm -> no_lpf ) {cm -> filter_level = 0 ;struct vpx_usec_timer timer ;vp8_clear_system_state ( ) ;vpx_usec_timer_start ( & timer ) ;if ( cpi -> sf . auto_filter == 0 )  vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ;else   vp8cx_pick_filter_level ( cpi -> Source , cpi ) ;if ( cm -> filter_level > 0 ) {# endif  if ( cm -> filter_level > 0 )  {","const FRAME_TYPE frame_type = cm -> frame_type ;int update_any_ref_buffers = 1 ;if ( cpi -> common . refresh_last_frame == 0 && cpi -> common . refresh_golden_frame == 0 && cpi -> common . refresh_alt_ref_frame == 0 ) {# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) {vp8cx_pick_filter_level_fast ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ;vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ;else vp8cx_pick_filter_level ( cpi -> Source , cpi ) ;if ( cm -> filter_level > 0 && update_any_ref_buffers ) {# endif if ( cm -> filter_level > 0 ) {",4010
2264,"int vp8_denoiser_filter_neon ( YV12_BUFFER_CONFIG * mc_running_avg ,  YV12_BUFFER_CONFIG * running_avg , MACROBLOCK * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) {const uint8x16_t v_level1_adjustment = vdupq_n_u8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 4 : 3 ) ;const uint8x16_t v_delta_level_1_and_2 = vdupq_n_u8 ( 1 ) ;const uint8x16_t v_delta_level_2_and_3 = vdupq_n_u8 ( 2 ) ;const uint8x16_t v_level1_threshold = vdupq_n_u8 ( 4 ) ;const uint8x16_t v_level2_threshold = vdupq_n_u8 ( 8 ) ;const uint8x16_t v_level3_threshold = vdupq_n_u8 ( 16 ) ;unsigned char * sig = signal -> thismb ;int sig_stride = 16 ;for ( i = 0 ;int8x16_t v_sum_diff = vdupq_n_s8 ( 0 ) ;uint8x16_t v_running_avg_y ;const uint8x16_t v_sig = vld1q_u8 ( sig ) ;const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ;const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ;const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ;const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ;const uint8x16_t v_level1_mask = vcleq_u8 ( v_level1_threshold , v_abs_diff ) ;const uint8x16_t v_level2_mask = vcleq_u8 ( v_level2_threshold , v_abs_diff ) ;const uint8x16_t v_level3_mask = vcleq_u8 ( v_level3_threshold , v_abs_diff ) ;const uint8x16_t v_level2_adjustment = vandq_u8 ( v_level2_mask , v_delta_level_1_and_2 ) ;const uint8x16_t v_level3_adjustment = vandq_u8 ( v_level3_mask , v_delta_level_2_and_3 ) ;const uint8x16_t v_level1and2_adjustment = vaddq_u8 ( v_level1_adjustment , v_level2_adjustment ) ;const uint8x16_t v_level1and2and3_adjustment = vaddq_u8 ( v_level1and2_adjustment , v_level3_adjustment ) ;const uint8x16_t v_abs_adjustment = vbslq_u8 ( v_level1_mask , v_level1and2and3_adjustment , v_abs_diff ) ;const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ;const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ;v_running_avg_y = vqaddq_u8 ( v_sig , v_pos_adjustment ) ;v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_neg_adjustment ) ;v_sum_diff = vqaddq_s8 ( v_sum_diff , vreinterpretq_s8_u8 ( v_pos_adjustment ) ) ;v_sum_diff = vqsubq_s8 ( v_sum_diff , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ;vst1q_u8 ( running_avg_y , v_running_avg_y ) ;{int s0 = vgetq_lane_s8 ( v_sum_diff , 0 ) + vgetq_lane_s8 ( v_sum_diff , 1 ) + vgetq_lane_s8 ( v_sum_diff , 2 ) + vgetq_lane_s8 ( v_sum_diff , 3 ) ;int s1 = vgetq_lane_s8 ( v_sum_diff , 4 ) + vgetq_lane_s8 ( v_sum_diff , 5 ) + vgetq_lane_s8 ( v_sum_diff , 6 ) + vgetq_lane_s8 ( v_sum_diff , 7 ) ;int s2 = vgetq_lane_s8 ( v_sum_diff , 8 ) + vgetq_lane_s8 ( v_sum_diff , 9 ) + vgetq_lane_s8 ( v_sum_diff , 10 ) + vgetq_lane_s8 ( v_sum_diff , 11 ) ;int s3 = vgetq_lane_s8 ( v_sum_diff , 12 ) + vgetq_lane_s8 ( v_sum_diff , 13 ) + vgetq_lane_s8 ( v_sum_diff , 14 ) + vgetq_lane_s8 ( v_sum_diff , 15 ) ;sum_diff += s0 + s1 + s2 + s3 ;if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD )  return COPY_BLOCK ;vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , running_avg_y_stride ,   signal -> thismb , sig_stride ) ;return FILTER_BLOCK ;","int vp8_denoiser_filter_neon ( unsigned char * mc_running_avg_y , int mc_running_avg_y_stride , unsigned char * running_avg_y , int running_avg_y_stride , unsigned char * sig = signal -> thismb ;int sig_stride = 16 ;for ( i = 0 ;int8x16_t v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_pos_adjustment ) , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ;const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ;const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ;const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ;v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) ;if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) return COPY_BLOCK ;vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , running_avg_y_stride , signal -> thismb , sig_stride ) ;return FILTER_BLOCK ;",4011
2265,"
","iov_iter_advance ( i , copied ) ;",4012
2266,"if ( unlikely ( copied == 0 ) ) {bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ;iov_iter_advance ( i , copied ) ;pos += copied ;","if ( unlikely ( copied == 0 ) ) {bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ;pos += copied ;",4012
2267,"static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem )  {uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ;return TEE_SUCCESS ;}","static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) {size_t req_size = 0 ;uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ;if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;return TEE_SUCCESS ;}",4013
2268,"gchar * filename ;GFile * file ;gimp_assert_mainimage ( image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ;filename = g_build_filename ( g_get_tmp_dir ( ) , ""gimp-test.xcf"" , NULL ) ;file = g_file_new_for_path ( filename ) ;","gchar * filename = NULL ;gint file_handle ;GFile * file ;file_handle = g_file_open_tmp ( ""gimp-test-XXXXXX.xcf"" , & filename , NULL ) ;g_assert ( file_handle != - 1 ) ;close ( file_handle ) ;file = g_file_new_for_path ( filename ) ;",4014
2269,"xdr_free ( xdr_func , xdr_ptr ) ;XDR_DESTROY ( & temp_xdrs ) ;","xdr_free ( xdr_func , xdr_ptr ) ;XDR_DESTROY ( & temp_xdrs ) ;",4015
2270,"if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;","if ( pos + len > CDF_SEC_SIZE ( h ) * sst -> sst_len ) {DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\\return - 1 ;",4016
2271,for ( i = num_excl_chan ;i ++ )  {,if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;for ( i = num_excl_chan ;i ++ ) {,4017
2272,"static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id ,  va_list args ) {vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ;if ( init ) {","static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx , va_list args ) {vp8_decrypt_init * init = va_arg ( args , vpx_decrypt_init * ) ;if ( init ) {",4018
2273,"zval_ptr_dtor ( value ) ;zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ;","zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ;",4019
2274,"if ( nfs_wait_on_sequence ( data -> o_arg . seqid , task ) != 0 ) return ;if ( data -> state != NULL ) {struct nfs_delegation * delegation ;if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) )  goto out_no_action ;","if ( nfs_wait_on_sequence ( data -> o_arg . fmode , data -> o_arg . open_flags ) ) goto out_no_action ;",4020
2275,struct hci_filter * f = & hci_pi ( sk ) -> filter ;uf . type_mask = f -> type_mask ;,"struct hci_filter * f = & hci_pi ( sk ) -> filter ;memset ( & uf , 0 , sizeof ( uf ) ) ;uf . type_mask = f -> type_mask ;",4021
2276,"struct scatterlist sg [ 1 ] ;if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ;sg_init_one ( sg , buf , count ) ;return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ;}","struct scatterlist sg [ 1 ] ;void * data ;int ret ;if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ;data = kmemdup ( buf , count , GFP_ATOMIC ) ;if ( ! data ) return - ENOMEM ;sg_init_one ( sg , data , count ) ;return __send_to_port ( port , sg , 1 , count , data , false ) ;kfree ( data ) ;return ret ;}",4022
2277,metadatalength = GetDuration ( mp4 ) ;if ( metadatalength > 0.0 ) {,"if ( mp4 == 0 ) {printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\\return - 1 ;}metadatalength = GetDuration ( mp4 ) ;if ( metadatalength > 0.0 ) {",4023
2278,"float in = 0.0 , out = 0.0 ;payload = GetPayload ( mp4 , payload , index ) ;","double in = 0.0 , out = 0.0 ;payload = GetPayload ( mp4 , payload , index ) ;",4023
2279,"
","double in = 0.0 , out = 0.0 ;",4023
2280,"uint32_t fourcc = GPMF_Key ( ms ) ;double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ;printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\\}","uint32_t fourcc = GPMF_Key ( ms ) ;double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ;printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\\}",4023
2281,cur_logical ++ ;pblock ++ ;,if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ;cur_logical ++ ;pblock ++ ;,4024
2282,"case TIOCGETD :  return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ;case TIOCSETD : return tiocsetd ( tty , p ) ;","case TIOCGETD : return tiocgetd ( tty , p ) ;case TIOCSETD : return tiocsetd ( tty , p ) ;",4025
2283,uint32_t track_size ;uint8_t * * tracks ;,uint8_t * * tracks ;uint32_t * track_size ;,4026
2284,"track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ;if ( midi_size < 8 ) {if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>track<S2SV_blank>header)"" , 0 ) ;midi_data += 4 ;midi_size -= 4 ;track_size = * midi_data ++ << 24 ;track_size |= * midi_data ++ << 16 ;track_size |= * midi_data ++ << 8 ;track_size |= * midi_data ++ ;midi_size -= 4 ;if ( midi_size < track_size ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}if ( track_size < 3 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ;goto _end ;}if ( ( midi_data [ track_size - 3 ] != 0xFF )   || ( midi_data [ track_size - 2 ] != 0x2F )   || ( midi_data [ track_size - 1 ] != 0x00 ) ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ;midi_data += track_size ;midi_size -= track_size ;track_end [ i ] = 0 ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;if ( midi_type == 1 ) {","track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ;track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ;if ( midi_size < tmp_val ) {if ( tmp_val < 3 ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ;if ( ( midi_data [ track_size - 3 ] != 0xFF ) || ( midi_data [ track_size - 2 ] != 0x2F ) || ( midi_data [ track_size - 1 ] != 0x00 ) ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ;midi_data += track_size ;midi_size -= track_size ;track_end [ i ] = 0 ;track_size [ i ] -- ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;if ( midi_type == 1 ) {",4026
2285,"setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {","setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {",4026
2286,goto NEXT_TRACK ;},track_size [ i ] -= 3 ;goto NEXT_TRACK ;},4026
2287,if ( * tracks [ i ] > 0x7f ) {do {track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;}}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;},"track_size [ i ] -= setup_ret ;if ( * tracks [ i ] > 0x7f ) {do {if ( ! track_size [ i ] ) break ;track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}}if ( ! track_size [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}",4026
2288,"setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {","setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , track_size [ i ] , running_event [ i ] ) ;if ( setup_ret == 0 ) {",4026
2289,track_delta [ i ] = 0 ;if ( * tracks [ i ] > 0x7f ) {track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;}}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ;,"track_size [ i ] -= setup_ret ;track_delta [ i ] = 0 ;if ( * tracks [ i ] > 0x7f ) {if ( ! track_size [ i ] ) break ;track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;}}if ( ! track_size [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ;goto _end ;}track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ;tracks [ i ] ++ ;track_size [ i ] -- ;sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ;",4026
2290,if ( mdi -> reverb ) return ( mdi ) ;_WM_freeMDI ( mdi ) ;,free ( track_size ) ;if ( mdi -> reverb ) return ( mdi ) ;_WM_freeMDI ( mdi ) ;,4026
2291,if ( group_leader -> ctx -> type != ctx -> type )  goto err_context ;,if ( group_leader -> ctx -> task != ctx -> type ) goto err_context ;,4027
2292,"ps_codec -> i4_flush_mode = 1 ;}if ( 0 == ps_codec -> i4_flush_mode ) {if ( ps_dec_ip -> pv_stream_buffer == NULL ) {ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ;ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ;return IV_FAIL ;}if ( ps_dec_ip -> u4_num_Bytes <= MIN_START_CODE_LEN ) {if ( ( WORD32 ) ps_dec_ip -> u4_num_Bytes > 0 ) ps_dec_op -> u4_num_bytes_consumed = ps_dec_ip -> u4_num_Bytes ;else ps_dec_op -> u4_num_bytes_consumed = 0 ;ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ;ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ;return IV_FAIL ;}}# ifdef APPLY_CONCEALMENT {WORD32 num_mbs ;num_mbs = ( ps_codec -> i4_wd * ps_codec -> i4_ht + 255 ) >> 8 ;ps_codec -> mb_count = 0 ;memset ( ps_codec -> mb_map , 0 , ( ( num_mbs + 7 ) >> 3 ) ) ;}# endif if ( 0 == ps_codec -> i4_share_disp_buf && ps_codec -> i4_header_mode == 0 ) {UWORD32 i ;if ( ps_dec_ip -> s_out_buffer . u4_num_bufs == 0 ) {ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ;ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ;return IV_FAIL ;}for ( i = 0 ;i < ps_dec_ip -> s_out_buffer . u4_num_bufs ;i ++ ) {if ( ps_dec_ip -> s_out_buffer . pu1_bufs [ i ] == NULL ) {ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ;ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ;return IV_FAIL ;}if ( ps_dec_ip -> s_out_buffer . u4_min_out_buf_size [ i ] == 0 ) {ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ;ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ;return IV_FAIL ;}}}ps_codec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ;ps_codec -> u4_ts = ps_dec_ip -> u4_ts ;if ( ps_codec -> i4_flush_mode ) {ps_dec_op -> u4_pic_wd = ps_codec -> i4_disp_wd ;ps_dec_op -> u4_pic_ht = ps_codec -> i4_disp_ht ;ps_dec_op -> u4_new_seq = 0 ;ps_codec -> ps_disp_buf = ( pic_buf_t * ) ihevc_disp_mgr_get ( ( disp_mgr_t * ) ps_codec -> pv_disp_buf_mgr , & ps_codec -> i4_disp_buf_id ) ;if ( ( ps_codec -> ps_disp_buf ) && ( ( 0 == ps_codec -> i4_share_disp_buf ) || ( IV_YUV_420P == ps_codec -> e_chroma_fmt ) ) ) {process_ctxt_t * ps_proc = & ps_codec -> as_process [ prev_proc_idx ] ;if ( 0 == ps_proc -> i4_init_done ) {ihevcd_init_proc_ctxt ( ps_proc , 0 ) ;}ret = ihevcd_check_out_buf_size ( ps_codec ) ;RETURN_IF ( ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) , ret ) ;ret = ihevcd_fmt_conv ( ps_codec , & ps_codec -> as_process [ prev_proc_idx ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , 0 , ps_codec -> i4_disp_ht ) ;ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> i4_disp_buf_id , BUF_MGR_DISP ) ;}ihevcd_fill_outargs ( ps_codec , ps_dec_ip , ps_dec_op ) ;if ( 1 == ps_dec_op -> u4_output_present ) {WORD32 xpos = ps_codec -> i4_disp_wd - 32 - LOGO_WD ;WORD32 ypos = ps_codec -> i4_disp_ht - 32 - LOGO_HT ;if ( ypos < 0 ) ypos = 0 ;if ( xpos < 0 ) xpos = 0 ;INSERT_LOGO ( ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , ps_codec -> i4_disp_strd , xpos , ypos , ps_codec -> e_chroma_fmt , ps_codec -> i4_disp_wd , ps_codec -> i4_disp_ht ) ;}if ( NULL == ps_codec -> ps_disp_buf ) {if ( ps_codec -> i4_reset_flag ) {ihevcd_init ( ps_codec ) ;}return ( IV_FAIL ) ;}return ( IV_SUCCESS ) ;}if ( ( 0 == ps_codec -> i4_header_mode ) && ( 1 == ps_codec -> i4_share_disp_buf ) ) {WORD32 buf_status ;buf_status = 1 ;if ( ps_codec -> pv_pic_buf_mgr ) buf_status = ihevc_buf_mgr_check_free ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr ) ;if ( 0 == buf_status ) {ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ;ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ;return IV_FAIL ;}}ps_codec -> i4_bytes_remaining = ps_dec_ip -> u4_num_Bytes ;ps_codec -> pu1_inp_bitsbuf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer ;ps_codec -> s_parse . i4_end_of_frame = 0 ;ps_codec -> i4_pic_present = 0 ;ps_codec -> i4_slice_error = 0 ;ps_codec -> ps_disp_buf = NULL ;if ( ps_codec -> i4_num_cores > 1 ) {ithread_set_affinity ( 0 ) ;}while ( MIN_START_CODE_LEN < ps_codec -> i4_bytes_remaining ) {WORD32 nal_len ;WORD32 nal_ofst ;WORD32 bits_len ;if ( ps_codec -> i4_slice_error ) {slice_header_t * ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ;WORD32 next_slice_addr = ps_slice_hdr_next -> i2_ctb_x + ps_slice_hdr_next -> i2_ctb_y * ps_codec -> s_parse . ps_sps -> i2_pic_wd_in_ctb ;if ( ps_codec -> s_parse . i4_next_ctb_indx == next_slice_addr ) ps_codec -> i4_slice_error = 0 ;}if ( ps_codec -> pu1_bitsbuf_dynamic ) {ps_codec -> pu1_bitsbuf = ps_codec -> pu1_bitsbuf_dynamic ;ps_codec -> u4_bitsbuf_size = ps_codec -> u4_bitsbuf_size_dynamic ;}else {ps_codec -> pu1_bitsbuf = ps_codec -> pu1_bitsbuf_static ;ps_codec -> u4_bitsbuf_size = ps_codec -> u4_bitsbuf_size_static ;}nal_ofst = ihevcd_nal_search_start_code ( ps_codec -> pu1_inp_bitsbuf , ps_codec -> i4_bytes_remaining ) ;ps_codec -> i4_nal_ofst = nal_ofst ;{WORD32 bytes_remaining = ps_codec -> i4_bytes_remaining - nal_ofst ;bytes_remaining = MIN ( ( UWORD32 ) bytes_remaining , ps_codec -> u4_bitsbuf_size ) ;ihevcd_nal_remv_emuln_bytes ( ps_codec -> pu1_inp_bitsbuf + nal_ofst , ps_codec -> pu1_bitsbuf , bytes_remaining , & nal_len , & bits_len ) ;if ( bits_len < ( WORD32 ) ( ps_codec -> u4_bitsbuf_size - 8 ) ) {memset ( ps_codec -> pu1_bitsbuf + bits_len , 0 , 2 * sizeof ( UWORD32 ) ) ;}}ps_codec -> i4_num_emln_bytes = nal_len - bits_len ;ps_codec -> i4_nal_len = nal_len ;ihevcd_bits_init ( & ps_codec -> s_parse . s_bitstrm , ps_codec -> pu1_bitsbuf , bits_len ) ;ret = ihevcd_nal_unit ( ps_codec ) ;if ( ps_codec -> i4_pic_present && ( ps_codec -> s_parse . i4_next_ctb_indx != ps_codec -> s_parse . ps_sps -> i4_pic_size_in_ctb ) ) {if ( ( ps_codec -> i4_bytes_remaining - ( nal_len + nal_ofst ) <= MIN_START_CODE_LEN ) || ( ps_codec -> i4_header_in_slice_mode ) ) {slice_header_t * ps_slice_hdr_next ;ps_codec -> s_parse . i4_cur_slice_idx -- ;if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ;ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ;ps_slice_hdr_next -> i2_ctb_x = 0 ;ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ;ps_codec -> i4_slice_error = 1 ;continue ;}}if ( IHEVCD_IGNORE_SLICE == ret ) {ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ;ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ;",ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ;,4028
2293,struct br_mdb_entry entry ;entry . ifindex = port -> dev -> ifindex ;,"struct br_mdb_entry entry ;memset ( & entry , 0 , sizeof ( entry ) ) ;entry . ifindex = port -> dev -> ifindex ;",4029
2294,free ( p ) ;return 0 ;,* pp = p -> next ;free ( p ) ;return 0 ;,4030
2295,"char * dbuf ;char * ticket_buf ;int ret ;dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ;ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ;ret = process_one_ticket ( ac , secret , & p , end ,  dbuf , ticket_buf ) ;if ( ret )  goto out ;}ret = 0 ;out : kfree ( ticket_buf ) ;out_dbuf : kfree ( dbuf ) ;return ret ;bad :  ret = - EINVAL ;goto out ;}","int ret ;dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ;ceph_decode_8_safe ( & p , end ) ;ret = process_one_ticket ( ac , secret , & p , end , dbuf , ticket_buf ) ;if ( ret ) return ret ;}return 0 ;bad : ret = - EINVAL ;}",4031
2296,"int fit_config_verify_required_sigs ( const void * fit , int conf_noffset ,  const void * sig_blob ) {int noffset ;int sig_node ;const char * reqd_mode ;sig_node = fdt_subnode_offset ( sig_blob , 0 , FIT_SIG_NODENAME ) ;","static int fit_config_verify_required_sigs ( const void * fit , int conf_noffset , const void * sig_blob ) {const char * name = fit_get_name ( fit , conf_noffset , NULL ) ;int noffset ;int sig_node ;const char * reqd_mode ;if ( strchr ( name , \'@\' ) ) {printf ( ""Configuration<S2SV_blank>node<S2SV_blank>\\\'%s\\\'<S2SV_blank>contains<S2SV_blank>\\\'@\\\'\\\return - EPERM ;}sig_node = fdt_subnode_offset ( sig_blob , 0 , FIT_SIG_NODENAME ) ;",4032
2297,"void vp9_rc_init_minq_luts ( ) {int i ;for ( i = 0 ;i < QINDEX_RANGE ;i ++ ) {const double maxq = vp9_convert_qindex_to_q ( i ) ;kf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.000001 , - 0.0004 , 0.15 ) ;kf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.000002 , - 0.0012 , 0.50 ) ;gf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.32 ) ;gf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.50 ) ;afq_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.33 ) ;afq_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.55 ) ;inter_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.75 ) ;}}","void vp9_rc_init_minq_luts ( void ) {init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ;# if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ;init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ;# endif }",4033
2298,if ( log_mode != LOG_MODE_CONFIGURED || new_mode != LOG_MODE_ERROR )  log_mode = new_mode ;,log_mode = new_mode ;,4034
2299,"s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {","s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ;s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , s_alDriver -> string ) ;return qfalse ;}s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ;if ( ! QAL_Init ( s_alDriver -> string ) ) {",4035
2300,"if ( args -> buffer_count < 1 ) {DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\\","if ( args -> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ) ) {DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\\",4036
2301,"
",bool disconnect ;,4037
2302,"p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;list_del_init ( & p -> mnt_expire ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ;if ( mnt_has_parent ( p ) ) {umount_mnt ( p ) ;}change_mnt_propagation ( p , MS_PRIVATE ) ;}","p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ;list_del_init ( & p -> mnt_expire ) ;disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;if ( mnt_has_parent ( p ) ) {if ( ! disconnect ) {list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ;}}else {umount_mnt ( p ) ;}change_mnt_propagation ( p , MS_PRIVATE ) ;}",4037
2303,"if ( strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) {","if ( tmp_line_len >= 1 && strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) {",4038
2304,if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ;,if ( tmp_line_len >= 1 && use_ssl && resource -> port == 0 ) resource -> port = 443 ;,4038
2305,"if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""timeout"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_double_ex ( tmpzval ) ;timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ;timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ;}else {timeout . tv_sec = FG ( default_socket_timeout ) ;timeout . tv_usec = 0 ;}stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ;if ( stream ) {php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ;}if ( errstr ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""%s"" , errstr ) ;efree ( errstr ) ;errstr = NULL ;}efree ( transport_string ) ;if ( stream && use_proxy && use_ssl ) {smart_str header = {0 };if ( ! context || php_stream_context_get_option ( context , ""ssl"" , ""peer_name"" , & tmpzval ) == FAILURE ) {MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ;ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ;php_stream_context_set_option ( stream -> context , ""ssl"" , ""peer_name"" , ssl_proxy_peer_name ) ;}smart_str_appendl ( & header , ""CONNECT<S2SV_blank>"" , sizeof ( ""CONNECT<S2SV_blank>"" ) - 1 ) ;smart_str_appends ( & header , resource -> host ) ;smart_str_appendc ( & header , \':\' ) ;smart_str_append_unsigned ( & header , resource -> port ) ;smart_str_appendl ( & header , ""<S2SV_blank>HTTP/1.0\\\\r\\\if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) {char * s , * p ;if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) {HashPosition pos ;zval * * tmpheader = NULL ;for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ;SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ;zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) {if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) {s = Z_STRVAL_PP ( tmpheader ) ;do {while ( * s == \'<S2SV_blank>\' || * s == \'\\\\t\' ) s ++ ;p = s ;while ( * p != 0 && * p != \':\' && * p != \'\\\\r\' && * p != \'\\\if ( * p == \':\' ) {p ++ ;if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) {while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\smart_str_appendl ( & header , s , p - s ) ;smart_str_appendl ( & header , ""\\\\r\\\goto finish ;}else {while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\}}s = p ;while ( * s == \'\\\\r\' || * s == \'\\\}while ( * s != 0 ) ;}}}else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) {s = Z_STRVAL_PP ( tmpzval ) ;do {while ( * s == \'<S2SV_blank>\' || * s == \'\\\\t\' ) s ++ ;p = s ;while ( * p != 0 && * p != \':\' && * p != \'\\\\r\' && * p != \'\\\if ( * p == \':\' ) {p ++ ;if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) {while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\smart_str_appendl ( & header , s , p - s ) ;smart_str_appendl ( & header , ""\\\\r\\\goto finish ;}else {while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\}}s = p ;while ( * s == \'\\\\r\' || * s == \'\\\}while ( * s != 0 ) ;}}finish : smart_str_appendl ( & header , ""\\\\r\\\if ( php_stream_write ( stream , header . c , header . len ) != header . len ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ;php_stream_close ( stream ) ;stream = NULL ;}smart_str_free ( & header ) ;if ( stream ) {char header_line [ HTTP_HEADER_BLOCK_SIZE ] ;while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) {if ( header_line [ 0 ] == \'\\\break ;}}}if ( stream ) {if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ;php_stream_close ( stream ) ;stream = NULL ;}}}if ( stream == NULL ) goto out ;if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ;eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ;php_stream_context_set ( stream , context ) ;php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ;if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""max_redirects"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_long_ex ( tmpzval ) ;redirect_max = Z_LVAL_PP ( tmpzval ) ;}if ( context && php_stream_context_get_option ( context , ""http"" , ""method"" , & tmpzval ) == SUCCESS ) {if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( ""GET"" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( ""HEAD"" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) {scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ;scratch = emalloc ( scratch_len ) ;strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ;strncat ( scratch , ""<S2SV_blank>"" , 1 ) ;}}}if ( context && php_stream_context_get_option ( context , ""http"" , ""protocol_version"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_double_ex ( tmpzval ) ;protocol_version_len = spprintf ( & protocol_version , 0 , ""%.1F"" , Z_DVAL_PP ( tmpzval ) ) ;}if ( ! scratch ) {scratch_len = strlen ( path ) + 29 + protocol_version_len ;scratch = emalloc ( scratch_len ) ;strncpy ( scratch , ""GET<S2SV_blank>"" , scratch_len ) ;}if ( ! request_fulluri && context && php_stream_context_get_option ( context , ""http"" , ""request_fulluri"" , & tmpzval ) == SUCCESS ) {zval ztmp = * * tmpzval ;zval_copy_ctor ( & ztmp ) ;convert_to_boolean ( & ztmp ) ;request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ;zval_dtor ( & ztmp ) ;}if ( request_fulluri ) {strcat ( scratch , path ) ;}else {if ( resource -> path && * resource -> path ) {strlcat ( scratch , resource -> path , scratch_len ) ;}else {strlcat ( scratch , ""/"" , scratch_len ) ;}if ( resource -> query ) {strlcat ( scratch , ""?"" , scratch_len ) ;strlcat ( scratch , resource -> query , scratch_len ) ;}}if ( protocol_version ) {strlcat ( scratch , ""<S2SV_blank>HTTP/"" , scratch_len ) ;strlcat ( scratch , protocol_version , scratch_len ) ;strlcat ( scratch , ""\\\\r\\\}else {strlcat ( scratch , ""<S2SV_blank>HTTP/1.0\\\\r\\\}php_stream_write ( stream , scratch , strlen ( scratch ) ) ;if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) {tmp = NULL ;if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) {HashPosition pos ;zval * * tmpheader = NULL ;smart_str tmpstr = {0 };for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ;SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ;zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) {if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) {smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ;smart_str_appendl ( & tmpstr , ""\\\\r\\\}}smart_str_0 ( & tmpstr ) ;if ( tmpstr . c ) {tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ;smart_str_free ( & tmpstr ) ;}}if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) {tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ;}if ( tmp && strlen ( tmp ) > 0 ) {char * s ;user_headers = estrdup ( tmp ) ;php_strtolower ( tmp , strlen ( tmp ) ) ;if ( ! header_init ) {strip_header ( user_headers , tmp , ""content-length:"" ) ;strip_header ( user_headers , tmp , ""content-type:"" ) ;}if ( ( s = strstr ( tmp , ""user-agent:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_USER_AGENT ;}if ( ( s = strstr ( tmp , ""host:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_HOST ;}if ( ( s = strstr ( tmp , ""from:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_FROM ;}if ( ( s = strstr ( tmp , ""authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_AUTH ;}if ( ( s = strstr ( tmp , ""content-length:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_CONTENT_LENGTH ;}if ( ( s = strstr ( tmp , ""content-type:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_TYPE ;}if ( ( s = strstr ( tmp , ""connection:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\have_header |= HTTP_HEADER_CONNECTION ;}if ( use_proxy && use_ssl && ( s = strstr ( tmp , ""proxy-authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\char * p = s + sizeof ( ""proxy-authorization:"" ) - 1 ;while ( s > tmp && ( * ( s - 1 ) == \'<S2SV_blank>\' || * ( s - 1 ) == \'\\\\t\' ) ) s -- ;while ( * p != 0 && * p != \'\\\\r\' && * p != \'\\\while ( * p == \'\\\\r\' || * p == \'\\\if ( * p == 0 ) {if ( s == tmp ) {efree ( user_headers ) ;user_headers = NULL ;}else {while ( s > tmp && ( * ( s - 1 ) == \'\\\\r\' || * ( s - 1 ) == \'\\\user_headers [ s - tmp ] = 0 ;}}else {memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ;}}}if ( tmp ) {efree ( tmp ) ;}}if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) {php_url_decode ( resource -> user , strlen ( resource -> user ) ) ;strcpy ( scratch , resource -> user ) ;strcat ( scratch , "":"" ) ;if ( resource -> pass ) {php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ;strcat ( scratch , resource -> pass ) ;}tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ;if ( snprintf ( scratch , scratch_len , ""Authorization:<S2SV_blank>Basic<S2SV_blank>%s\\\\r\\\php_stream_write ( stream , scratch , strlen ( scratch ) ) ;php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ;}efree ( tmp ) ;tmp = NULL ;}if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) {if ( snprintf ( scratch , scratch_len , ""From:<S2SV_blank>%s\\\\r\\\}if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) {if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) {if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s:%i\\\\r\\\}else {if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s\\\\r\\\php_stream_write ( stream , scratch , strlen ( scratch ) ) ;}}}if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) {php_stream_write_string ( stream , ""Connection:<S2SV_blank>close\\\\r\\\}if ( context && php_stream_context_get_option ( context , ""http"" , ""user_agent"" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) {ua_str = Z_STRVAL_PP ( ua_zval ) ;}else if ( FG ( user_agent ) ) {ua_str = FG ( user_agent ) ;}if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) {# define _UA_HEADER ""User-Agent:<S2SV_blank>%s\\\\r\\\size_t ua_len ;ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ;if ( ua_len > sizeof ( _UA_HEADER ) ) {ua = emalloc ( ua_len + 1 ) ;if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) {ua [ ua_len ] = 0 ;php_stream_write ( stream , ua , ua_len ) ;}else {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Cannot<S2SV_blank>construct<S2SV_blank>User-agent<S2SV_blank>header"" ) ;}if ( ua ) {efree ( ua ) ;}}}if ( user_headers ) {if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\\\r\\\php_stream_write ( stream , scratch , scratch_len ) ;have_header |= HTTP_HEADER_CONTENT_LENGTH ;}php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ;php_stream_write ( stream , ""\\\\r\\\efree ( user_headers ) ;}if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) {if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) {scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\\\r\\\php_stream_write ( stream , scratch , scratch_len ) ;}if ( ! ( have_header & HTTP_HEADER_TYPE ) ) {php_stream_write ( stream , ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\\\r\\\php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Content-type<S2SV_blank>not<S2SV_blank>specified<S2SV_blank>assuming<S2SV_blank>application/x-www-form-urlencoded"" ) ;}php_stream_write ( stream , ""\\\\r\\\php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ;}else {php_stream_write ( stream , ""\\\\r\\\}location [ 0 ] = \'\\\\0\' ;if ( ! EG ( active_symbol_table ) ) {zend_rebuild_symbol_table ( TSRMLS_C ) ;}if ( header_init ) {zval * ztmp ;MAKE_STD_ZVAL ( ztmp ) ;array_init ( ztmp ) ;ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , ""http_response_header"" , ztmp ) ;}{zval * * rh ;if ( zend_hash_find ( EG ( active_symbol_table ) , ""http_response_header"" , sizeof ( ""http_response_header"" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>http_response_header<S2SV_blank>overwritten"" ) ;goto out ;}response_header = * rh ;Z_ADDREF_P ( response_header ) ;}if ( ! php_stream_eof ( stream ) ) {size_t tmp_line_len ;if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) {zval * http_response ;if ( tmp_line_len > 9 ) {response_code = atoi ( tmp_line + 9 ) ;}else {response_code = 0 ;}if ( context && SUCCESS == php_stream_context_get_option ( context , ""http"" , ""ignore_errors"" , & tmpzval ) ) {ignore_errors = zend_is_true ( * tmpzval ) ;}if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) {reqok = 1 ;}if ( response_code >= 100 && response_code < 200 ) {while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( ""HTTP/1"" ) - 1 || strncasecmp ( tmp_line , ""HTTP/1"" , sizeof ( ""HTTP/1"" ) - 1 ) ) ) ;if ( tmp_line_len > 9 ) {response_code = atoi ( tmp_line + 9 ) ;}else {response_code = 0 ;}}if ( response_code >= 200 && response_code < 400 ) {reqok = 1 ;}else {switch ( response_code ) {case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ;break ;default : if ( ! tmp_line_len ) {tmp_line [ 0 ] = \'\\\\0\' ;}php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ;}}if ( tmp_line [ tmp_line_len - 1 ] == \'\\\-- tmp_line_len ;if ( tmp_line [ tmp_line_len - 1 ] == \'\\\\r\' ) {-- tmp_line_len ;}}MAKE_STD_ZVAL ( http_response ) ;ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ;zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ;}}else {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>socket!"" ) ;goto out ;}http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ;while ( ! body && ! php_stream_eof ( stream ) ) {size_t http_header_line_length ;if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != \'\\\char * e = http_header_line + http_header_line_length - 1 ;if ( * e != \'\\\do {if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>HTTP<S2SV_blank>headers"" ) ;goto out ;}e = http_header_line + http_header_line_length - 1 ;}while ( * e != \'\\\continue ;}while ( * e == \'\\\e -- ;}http_header_line_length = e - http_header_line + 1 ;http_header_line [ http_header_line_length ] = \'\\\\0\' ;if ( ! strncasecmp ( http_header_line , ""Location:<S2SV_blank>"" , 10 ) ) {if ( context && php_stream_context_get_option ( context , ""http"" , ""follow_location"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_long_ex ( tmpzval ) ;follow_location = Z_LVAL_PP ( tmpzval ) ;}else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) {follow_location = 0 ;}strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ;}else if ( ! strncasecmp ( http_header_line , ""Content-Type:<S2SV_blank>"" , 14 ) ) {php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ;}else if ( ! strncasecmp ( http_header_line , ""Content-Length:<S2SV_blank>"" , 16 ) ) {file_size = atoi ( http_header_line + 16 ) ;php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ;}else if ( ! strncasecmp ( http_header_line , ""Transfer-Encoding:<S2SV_blank>chunked"" , sizeof ( ""Transfer-Encoding:<S2SV_blank>chunked"" ) ) ) {if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) {long decode = 1 ;if ( context && php_stream_context_get_option ( context , ""http"" , ""auto_decode"" , & tmpzval ) == SUCCESS ) {SEPARATE_ZVAL ( tmpzval ) ;convert_to_boolean ( * tmpzval ) ;decode = Z_LVAL_PP ( tmpzval ) ;}if ( decode ) {transfer_encoding = php_stream_filter_create ( ""dechunk"" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ;if ( transfer_encoding ) {continue ;}}}}if ( http_header_line [ 0 ] == \'\\\\0\' ) {body = 1 ;}else {zval * http_header ;MAKE_STD_ZVAL ( http_header ) ;ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ;zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ;}}else {break ;}}if ( ! reqok || ( location [ 0 ] != \'\\\\0\' && follow_location ) ) {if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) {goto out ;}if ( location [ 0 ] != \'\\\\0\' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ;php_stream_close ( stream ) ;stream = NULL ;if ( location [ 0 ] != \'\\\\0\' ) {char new_path [ HTTP_HEADER_BLOCK_SIZE ] ;char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ;* new_path = \'\\\\0\' ;if ( strlen ( location ) < 8 || ( strncasecmp ( location , ""http://"" , sizeof ( ""http://"" ) - 1 ) && strncasecmp ( location , ""https://"" , sizeof ( ""https://"" ) - 1 ) && strncasecmp ( location , ""ftp://"" , sizeof ( ""ftp://"" ) - 1 ) && strncasecmp ( location , ""ftps://"" , sizeof ( ""ftps://"" ) - 1 ) ) ) {if ( * location != \'/\' ) {if ( * ( location + 1 ) != \'\\\\0\' && resource -> path ) {char * s = strrchr ( resource -> path , \'/\' ) ;if ( ! s ) {s = resource -> path ;if ( ! s [ 0 ] ) {efree ( s ) ;s = resource -> path = estrdup ( ""/"" ) ;}else {* s = \'/\' ;}}s [ 1 ] = \'\\\\0\' ;if ( resource -> path && * ( resource -> path ) == \'/\' && * ( resource -> path + 1 ) == \'\\\\0\' ) {snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s%s"" , resource -> path , location ) ;}else {snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s/%s"" , resource -> path , location ) ;}}else {snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""/%s"" , location ) ;}}else {strlcpy ( loc_path , location , sizeof ( loc_path ) ) ;}if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) {snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s:%d%s"" , resource -> scheme , resource -> host , resource -> port , loc_path ) ;}else {snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s%s"" , resource -> scheme , resource -> host , loc_path ) ;}}else {strlcpy ( new_path , location , sizeof ( new_path ) ) ;}php_url_free ( resource ) ;if ( ( resource = php_url_parse ( new_path ) ) == NULL ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ;goto out ;}# define CHECK_FOR_CNTRL_CHARS ( val ) {if ( val ) {unsigned char * s , * e ;int l ;l = php_url_decode ( val , strlen ( val ) ) ;s = ( unsigned char * ) val ;e = s + l ;while ( s < e ) {if ( iscntrl ( * s ) ) {php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ;goto out ;}s ++ ;}}}if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) {","\\\\\if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) {",4038
2306,char added ;},},4039
2307,"if ( disk != NULL ) {const int blocksize = 512 ;int ret ;if ( bio ) iob = bio ;ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) ,   ( ut8 * ) buf , size * blocksize ) ;if ( ret == - 1 )  return 1 ;}return 0 ;","if ( ! disk ) {eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\\return 1 ;}const int blocksize = 512 ;if ( bio ) {iob = bio ;}if ( iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , ( ut8 * ) buf , size * blocksize ) == - 1 ) {return 1 ;}return 0 ;",4040
2308,"case TIOCGETD :  return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ;case TIOCSETD : return tiocsetd ( tty , p ) ;","case TIOCGETD : return tiocgetd ( tty , p ) ;case TIOCSETD : return tiocsetd ( tty , p ) ;",4041
2309,"start = vma -> vm_start ;if ( expand_stack ( vma , addr ) ) return NULL ;","if ( ! mmget_still_valid ( mm ) ) return NULL ;start = vma -> vm_start ;if ( expand_stack ( vma , addr ) ) return NULL ;",4042
2310,"break ;error = coapClientGetPayload ( responseMsg , & payload , & payloadLen ) ;if ( error ) break ;if ( payloadLen != COAP_GET_BLOCK_SIZE ( value ) ) {",else {},4043
2311,if ( blockPos == 0 )  error = ERROR_END_OF_STREAM ;else   error = ERROR_FAILURE ;break ;,if ( blockPos == 0 ) {error = ERROR_END_OF_STREAM ;else error = ERROR_FAILURE ;break ;,4043
2312,"vp9_writer residual_bc ;int tile_row , tile_col ;TOKENEXTRA * tok [ 4 ] [ 1 << 6 ] , * tok_end ;size_t total_size = 0 ;vpx_memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) *  mi_cols_aligned_to_sb ( cm -> mi_cols ) ) ;tok [ 0 ] [ 0 ] = cpi -> tok ;for ( tile_row = 0 ;tile_row < tile_rows ;tile_row ++ ) {if ( tile_row ) tok [ tile_row ] [ 0 ] = tok [ tile_row - 1 ] [ tile_cols - 1 ] + cpi -> tok_count [ tile_row - 1 ] [ tile_cols - 1 ] ;for ( tile_col = 1 ;tile_col < tile_cols ;tile_col ++ ) tok [ tile_row ] [ tile_col ] = tok [ tile_row ] [ tile_col - 1 ] + cpi -> tok_count [ tile_row ] [ tile_col - 1 ] ;}TileInfo tile ;vp9_tile_init ( & tile , cm , tile_row , tile_col ) ;tok_end = tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ;if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 )  vp9_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ;else  vp9_start_encode ( & residual_bc , data_ptr + total_size ) ;write_modes ( cpi , & tile , & residual_bc , & tok [ tile_row ] [ tile_col ] , tok_end ) ;assert ( tok [ tile_row ] [ tile_col ] == tok_end ) ;vp9_stop_encode ( & residual_bc ) ;if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) {","vpx_writer residual_bc ;int tile_row , tile_col ;TOKENEXTRA * tok_end ;size_t total_size = 0 ;memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * mi_cols_aligned_to_sb ( cm -> mi_cols ) ) ;int tile_idx = tile_row * tile_cols + tile_col ;TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ] ;tok_end = tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ;if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) vp9_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ;else vp9_start_encode ( & residual_bc , data_ptr + total_size ) ;write_modes ( cpi , & tile , & residual_bc , & tok [ tile_row ] [ tile_col ] , tok_end ) ;assert ( tok [ tile_row ] [ tile_col ] == tok_end ) ;vp9_stop_encode ( & residual_bc ) ;if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) {",4044
2313,struct channel_info * info =  & synth_devs [ dev ] -> chn_info [ chn ] ;,struct channel_info * info ;if ( voice < 0 || voice >= devc -> nr_voice ) return ;if ( chn < 0 || chn > 15 ) return ;info = & synth_devs [ dev ] -> chn_info [ chn ] ;,4045
2314,for ( j = 0 ;++ j )  if ( p ++ != pages [ i + j ] ) break ;,for ( j = 1 ;+ j )  if ( p ++ != pages [ i + j ] ) break ;++ j ) if ( p ++ != pages [ i + j ] ) break ;,4046
2315,for ( j = 0 ;++ j )  if ( p ++ != pages [ i + j ] ) break ;,for ( j = 1 ;+ j )  if ( p ++ != pages [ i + j ] ) break ;++ j ) if ( p ++ != pages [ i + j ] ) break ;,4046
2316,if ( flags & MSG_OOB )  goto out ;if ( addr_len ) * addr_len = sizeof ( * sin ) ;,if ( flags & MSG_OOB ) goto out ;,4047
2317,"}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;","* addr_len = sizeof ( * sin ) ;}if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ;",4047
2318,"static void reset_fpf_position ( struct twopass_rc * p ,  const FIRSTPASS_STATS * position ) {","static void reset_fpf_position ( TWO_PASS * p , const FIRSTPASS_STATS * position ) {",4048
2319,"if ( offset > ds || offset + 6 + 2 > ds ) return ;exif_data_load_data_content ( data , EXIF_IFD_0 , d + 6 , ds - 6 , offset , 0 ) ;n = exif_get_short ( d + 6 + offset , data -> priv -> order ) ;if ( offset + 6 + 2 + 12 * n + 4 > ds ) return ;offset = exif_get_long ( d + 6 + offset + 2 + 12 * n , data -> priv -> order ) ;if ( offset ) {if ( offset > ds || offset + 6 > ds ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""Bogus<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>IFD1."" ) ;","if ( offset > ds - 6 ) {if ( offset > ds || offset + 6 > ds ) {exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""Bogus<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>IFD1."" ) ;",4049
2320,opt2 -> tot_len = tot_len ;p = ( char * ) ( opt2 + 1 ) ;,"atomic_set ( & opt2 -> refcnt , 1 ) ;opt2 -> tot_len = tot_len ;p = ( char * ) ( opt2 + 1 ) ;",4050
2321,"Stream_Read_UINT32 ( s , packetLength ) ;if ( ( packetLength > INT_MAX ) || ! Stream_EnsureCapacity ( s , packetLength ) )  {","Stream_Read_UINT32 ( s , packetLength ) || ( packetLength < header ) ;if ( ( packetLength > INT_MAX ) || ! Stream_EnsureCapacity ( s , packetLength ) ) {",4051
2322,"static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events )  {spin_lock_init ( & group -> inotify_data . idr_lock ) ;idr_init ( & group -> inotify_data . idr ) ;group -> inotify_data . user = user ;group -> inotify_data . fa = NULL ;return group ;",static struct fsnotify_group * inotify_new_group ( unsigned int max_events ) {spin_lock_init ( & group -> inotify_data . fa = NULL ;group -> inotify_data . user = user ;group -> inotify_data . user = get_current_user ( ) ;if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) {fsnotify_put_group ( group ) ;return ERR_PTR ( - EMFILE ) ;}return group ;,4052
2323,"asoc -> peer . i = new -> peer . i ;sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ;","asoc -> peer . auth_capable = new -> peer . auth_capable ;asoc -> peer . i = new -> peer . i ;sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ;",4053
2324,"static void l2tp_q931_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length )  {print_16bits_val ( ndo , ( const uint16_t * ) dat ) ;if ( length > 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , dat + 3 , length - 3 ) ;}","static void l2tp_q931_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {if ( length != 0 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;dat += 3 ;length -= 3 ;return ;}print_16bits_val ( ndo , ( const uint16_t * ) dat ) ;if ( length > 3 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , dat , length ) ;}",4054
2325,cur_token = * indx ;mailbox_list = NULL ;,clist * list ;cur_token = * indx ;mailbox_list = NULL ;goto free_display_name ;}list = clist_new ( ) ;if ( list == NULL ) {res = MAILIMF_ERROR_MEMORY ;goto free_display_name ;}mailbox_list = mailimf_mailbox_list_new ( list ) ;if ( mailbox_list == NULL ) {res = MAILIMF_ERROR_MEMORY ;clist_free ( list ) ;,4055
2326,res = r ;goto free_display_name ;,res = r ;goto free_display_name ;,4055
2327,kfree ( ubufs ) ;},},4056
2328,"void fdct16_sse2 ( __m128i * in0 , __m128i * in1 ) {fdct16_8col ( in0 ) ;","static void fdct16_sse2 ( __m128i * in0 , __m128i * in1 ) {fdct16_8col ( in0 ) ;",4057
2329,ACPI_FUNCTION_TRACE ( ns_terminate ) ;# ifdef ACPI_EXEC_APP {union acpi_operand_object * next ;next = acpi_gbl_module_code_list ;}# endif acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ;,union acpi_operand_object * next ;ACPI_FUNCTION_TRACE ( ns_terminate ) ;next = acpi_gbl_module_code_list ;acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ;,4058
2330,"if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) )  return ( 0 ) ;tif -> tif_rawcc = 0 ;","if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) ) {tif -> tif_rawcc = 0 ;tif -> tif_rawcp = tif -> tif_rawdata ;return ( 0 ) ;}tif -> tif_rawcc = 0 ;",4059
2331,free ( ctx ) ;return VPX_CODEC_OK ;,# if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ;# endif vpx_free ( ctx -> buffer_pool ) ;vpx_free ( ctx ) ;return VPX_CODEC_OK ;,4060
2332,"bool is_drop_n_account = false ;BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ;if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ;sk = pt -> af_packet_priv ;po = pkt_sk ( sk ) ;if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ;if ( dev -> header_ops ) {",bool is_drop_n_account = false ;bool do_vnet = false ;BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ;if ( do_vnet ) {,4061
2333,if ( po -> has_vnet_hdr )  netoff += sizeof ( struct virtio_net_hdr ) ;macoff = netoff - maclen ;},if ( po -> has_vnet_hdr ) {netoff += sizeof ( struct virtio_net_hdr ) ;do_vnet = true ;}macoff = netoff - maclen ;},4061
2334,if ( ( int ) snaplen < 0 )   snaplen = 0 ;},if ( ( int ) snaplen < 0 ) {snaplen = 0 ;do_vnet = false ;}},4061
2335,}},do_vnet = false ;}},4061
2336,"if ( po -> has_vnet_hdr ) {if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {","if ( po -> has_vnet_hdr ) {if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) {",4061
2337,"if ( l == 0 )  memcpy ( own_dir , ""."" , 2 ) ;else {","if ( l == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ;# endif # else memcpy ( own_dir , ""."" , 2 ) ;else {",4062
2338,"static int can_open_delegated ( struct nfs_delegation * delegation , mode_t open_flags )  {if ( ( delegation -> type & open_flags ) != open_flags )  return 0 ;","static int can_open_delegated ( struct nfs_delegation * delegation , fmode_t fmode ) {if ( ( delegation -> type & fmode ) != fmode ) return 0 ;",4063
2339,"unsigned short sel ;memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ;rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;ctxt -> _eip = 0 ;memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;return X86EMUL_CONTINUE ;}","unsigned short sel , old_sel ;struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;u8 cpl = ctxt -> ops -> cpl ( ctxt ) ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) ;memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ;rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;rc = assign_eip_far ( ctxt , ctxt -> src . valptr , ctxt -> op_bytes ) ;return rc ;}return rc ;}",4064
2340,"static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx ,  int ctrl_id , va_list args ) {* corrupted = pbi -> common . frame_to_show -> corrupted ;return VPX_CODEC_OK ;","static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , va_list args ) {const YV12_BUFFER_CONFIG * const frame = pbi -> common . frame_to_show ;if ( frame == NULL ) return VPX_CODEC_ERROR ;* corrupted = frame -> corrupted ;return VPX_CODEC_OK ;",4065
2341,"char src [ PATH_MAX + 1 ] ;memcpy ( src , dir , dir_len ) ;src [ dir_len ] = 0 ;return NULL ;}return dst ;","if ( dir_len > PATH_MAX ) {uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\\return NULL ;}char * src = uwsgi_concat2n ( dir , dir_len , """" , 0 ) ;free ( src ) ;return NULL ;}free ( src ) ;return dst ;",4066
2342,"int index , count , i ;if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ;","unsigned int index , count , i ;if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ;",4067
2343,"int index , count , i ;u8 red , green , blue ;","unsigned int index , count , i ;u8 red , green , blue ;",4067
2344,"return mptctl_getiocinfo ( arg , _IOC_SIZE ( cmd ) ) ;}return mptctl_gettargetinfo ( arg ) ;}return mptctl_readtest ( arg ) ;}return mptctl_eventquery ( arg ) ;}return mptctl_eventenable ( arg ) ;}return mptctl_eventreport ( arg ) ;}return mptctl_replace_fw ( arg ) ;}if ( cmd == MPTFWDOWNLOAD )  ret = mptctl_fw_download ( arg ) ;else if ( cmd == MPTCOMMAND )  ret = mptctl_mpt_command ( arg ) ;else if ( cmd == MPTHARDRESET )  ret = mptctl_do_reset ( arg ) ;else if ( ( cmd & ~ IOCSIZE_MASK ) == ( HP_GETHOSTINFO & ~ IOCSIZE_MASK ) )  ret = mptctl_hp_hostinfo ( arg , _IOC_SIZE ( cmd ) ) ;else if ( cmd == HP_GETTARGETINFO )  ret = mptctl_hp_targetinfo ( arg ) ;else ret = - EINVAL ;","return mptctl_getiocinfo ( iocp , arg , _IOC_SIZE ( cmd ) ) ;}return mptctl_gettargetinfo ( iocp , arg ) ;}return mptctl_readtest ( iocp , arg ) ;}return mptctl_eventquery ( iocp , arg ) ;}return mptctl_eventenable ( iocp , arg ) ;}return mptctl_eventreport ( iocp , arg ) ;}return mptctl_replace_fw ( iocp , arg ) ;}if ( cmd == MPTFWDOWNLOAD ) ret = mptctl_fw_download ( iocp , arg ) ;else if ( cmd == MPTCOMMAND ) ret = mptctl_mpt_command ( iocp , arg ) ;else if ( cmd == MPTHARDRESET ) ret = mptctl_do_reset ( iocp , arg ) ;else if ( ( cmd & ~ IOCSIZE_MASK ) == ( HP_GETHOSTINFO & ~ IOCSIZE_MASK ) ) ret = mptctl_hp_hostinfo ( iocp , arg , _IOC_SIZE ( cmd ) ) ;else if ( cmd == HP_GETTARGETINFO ) ret = mptctl_hp_targetinfo ( iocp , arg ) ;else ret = - EINVAL ;",4068
2345,"int xt_check_entry_offsets ( const void * base ,  unsigned int target_offset , unsigned int next_offset ) {const struct xt_entry_target * t ;const char * e = base ;if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ;","int xt_check_entry_offsets ( const void * base , const char * elems , unsigned int target_offset , unsigned int next_offset ) {long size_of_base_struct = elems - ( const char * ) base ;const struct xt_entry_target * t ;const char * e = base ;if ( target_offset < size_of_base_struct ) return - EINVAL ;if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ;",4069
2346,if ( sk -> sk_state & PPPOX_BOUND )  goto end ;msg -> msg_namelen = 0 ;,if ( sk -> sk_state & PPPOX_BOUND ) goto end ;,4070
2347,assert ( bidx <= PCI_BARMAX ) ;assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 ||   pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ;assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ;,"if ( addr + size > pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . size ) {pr_err ( ""%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range\\\return - ESRCH ;}",4071
2348,"void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , int xstart ,  int ystart , int xend , int yend ) {","void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t yend ) {",4072
2349,INIT_LIST_HEAD ( & card -> controls ) ;INIT_LIST_HEAD ( & card -> ctl_files ) ;,mutex_init ( & card -> user_ctl_lock ) ;INIT_LIST_HEAD ( & card -> controls ) ;INIT_LIST_HEAD ( & card -> ctl_files ) ;,4073
2350,"static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {const int ref_frame_flags = va_arg ( args , int ) ;","static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {const int ref_frame_flags = va_arg ( args , int ) ;",4074
2351,"cpi -> mb . e_mbd . update_mb_segmentation_data = 0 ;}cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 0 ;cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ;vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;set_default_lf_deltas ( cpi ) ;","memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ;memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ;set_default_lf_deltas ( cpi ) ;",4075
2352,"struct usb_serial * serial = port -> serial ;struct usb_serial_port * wport ;wport = serial -> port [ 1 ] ;tty_port_tty_set ( & wport -> port , tty ) ;","
",4076
2353,"UINT16 count ;BITMAP_DATA * newdata ;count = bitmapUpdate -> number * 2 ;newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles ,  sizeof ( BITMAP_DATA ) * count ) ;","UINT32 count = bitmapUpdate -> number * 2 ;BITMAP_DATA * newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , sizeof ( BITMAP_DATA ) * count ) ;",4077
2354,uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( cc % ( bps * stride ) != 0 ) {if ( ! tmp )  return 0 ;,uint8 * tmp ;if ( cc % ( bps * stride ) != 0 ) {tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;if ( ! tmp ) return 0 ;,4078
2355,if ( ext_depth ( inode ) )  goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ;,size_t ext_size = 0 ;if ( ext_depth ( inode ) ) goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ;,4079
2356,"memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data ,   sizeof ( EXT4_I ( inode ) -> i_data ) ) ;neh = ext_block_hdr ( bh ) ;","ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ;memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , ext_size ) ;memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;neh = ext_block_hdr ( bh ) ;",4079
2357,newinet -> opt = NULL ;newnp -> ipv6_fl_list = NULL ;,newinet -> inet_opt = NULL ;newnp -> ipv6_fl_list = NULL ;,4080
2358,"return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ;}","return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID ) ;}",4081
2359,"error = scsi_nonblockable_ioctl ( sdp , cmd , p ,  ( mode & FMODE_NDELAY ) != 0 ) ;","error = scsi_verify_blk_ioctl ( bdev , cmd ) ;if ( error < 0 ) return error ;error = scsi_nonblockable_ioctl ( sdp , cmd , p , ( mode & FMODE_NDELAY ) != 0 ) ;",4082
2360,"size += service_name_tlv_length ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;size += rw_tlv_length ;pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\\","if ( ! service_name_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += service_name_tlv_length ;}if ( ! miux_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;if ( ! rw_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += rw_tlv_length ;pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\\",4083
2361,"memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ;memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ;","memset ( p , 0 , sizeof ( * p ) ) ;memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ;memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ;",4084
2362,frame_end :  ff_er_frame_end ( & s -> er ) ;,frame_end : if ( ! s -> studio_profile ) ff_er_frame_end ( & s -> er ) ;,4085
2363,"RAnalOp next_op ;avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;","RAnalOp next_op = {0 };avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ;",4086
2364,"int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) {int start_index = rc -> worst_quality ;if ( vp9_convert_qindex_to_q ( i ) >= qstart )  break ;if ( vp9_convert_qindex_to_q ( i ) >= qtarget )  break ;","int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget , vpx_bit_depth_t bit_depth ) {int start_index = rc -> worst_quality ;if ( vp9_convert_qindex_to_q ( i , bit_depth ) >= qstart ) break ;if ( vp9_convert_qindex_to_q ( i , bit_depth ) >= qtarget ) break ;",4087
2365,"const char * old_name ;trap = lock_rename ( new_dir , old_dir ) ;if ( d_really_is_negative ( old_dentry ) || old_dentry == trap || d_mountpoint ( old_dentry ) ) goto exit ;dentry = lookup_one_len ( new_name , new_dir , strlen ( new_name ) ) ;if ( IS_ERR ( dentry ) || dentry == trap || d_really_is_positive ( dentry ) ) goto exit ;old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ;error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ;fsnotify_oldname_free ( old_name ) ;fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ;fsnotify_oldname_free ( old_name ) ;unlock_rename ( new_dir , old_dir ) ;","struct name_snapshot old_name ;trap = lock_rename ( new_dir , old_dir ) ;take_dentry_name_snapshot ( & old_name , old_dentry ) ;error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ;release_dentry_name_snapshot ( & old_name ) ;fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ;fsnotify_oldname_free ( old_name ) ;unlock_rename ( new_dir , old_dir ) ;",4088
2366,"static unsigned int XBMInteger ( Image * image , short int * hex_digits )  {if ( c == EOF )  return ( 0 ) ;}","static int XBMInteger ( Image * image , short int * hex_digits ) {if ( c == EOF ) return ( - 1 ) ;}",4089
2367,if ( c == EOF )  return ( 0 ) ;}return ( value ) ;},if ( c == EOF ) return ( - 1 ) ;}return ( ( int ) value ) ;},4089
2368,"uint16_t keylen ;rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ;","int keylen ;rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ;",4090
2369,"uint16_t keylen ;rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ;","int keylen ;rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ;",4090
2370,msg -> msg_namelen = 0 ;release_sock ( sk ) ;,release_sock ( sk ) ;,4091
2371,if ( uniforms_offset < shader_rec_offset ||  exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) {,if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) {,4092
2372,if ( s ) {struct unix_sock * u = unix_sk ( s ) ;spin_lock ( & unix_gc_lock ) ;,spin_lock ( & unix_gc_lock ) ;if ( s ) {struct unix_sock * u = unix_sk ( s ) ;,4093
2373,spin_unlock ( & unix_gc_lock ) ;}},}fp -> f_cred -> user -> unix_inflight ++ ;spin_unlock ( & unix_gc_lock ) ;},4093
2374,"newinet -> pinet6 = & newdp6 -> inet6 ;newnp = inet6_sk ( newsk ) ;memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ;ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ;ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ;ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ;inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ;newsk -> sk_backlog_rcv = dccp_v4_do_rcv ;newnp -> pktoptions = NULL ;",newinet -> inet_opt = NULL ;,4094
2375,newinet -> opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;,newinet -> opt = NULL ;newnp -> rxopt . all = np -> rxopt . all ;,4094
2376,dtls1_process_buffered_records ( s ) ;if ( dtls1_get_processed_record ( s ) ) return 1 ;,if ( dtls1_process_buffered_records ( s ) < 0 ) return - 1 ;if ( dtls1_get_processed_record ( s ) ) return 1 ;,4095
2377,"dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ;}return ( 1 ) ;}","if ( dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) < 0 ) return - 1 ;dtls1_record_bitmap_update ( s , bitmap ) ;}dtls1_record_bitmap_update ( s , bitmap ) ;return ( 1 ) ;}",4095
2378,}return opt2 ;,"atomic_set ( & opt2 -> refcnt , 1 ) ;}return opt2 ;",4096
2379,"key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ;for ( i = 0 , j = 0 ;","if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ;for ( i = 0 , j = 0 ;",4097
2380,"static void nonrd_use_partition ( VP9_COMP * cpi ,  const TileInfo * const tile ,   MODE_INFO * * mi_8x8 ,  TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ,  int * totrate , int64_t * totdist ) {VP9_COMMON * const cm = & cpi -> common ;MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;const int mis = cm -> mi_stride ;int rate = INT_MAX ;int64_t dist = INT64_MAX ;subsize = ( bsize >= BLOCK_8X8 ) ? mi_8x8 [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ;partition = partition_lookup [ bsl ] [ subsize ] ;switch ( partition ) {case PARTITION_NONE :  nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;break ;case PARTITION_VERT :  * get_sb_index ( x , subsize ) = 0 ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( mi_col + hbs < cm -> mi_cols ) {* get_sb_index ( x , subsize ) = 1 ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + hbs ,  & rate , & dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( rate != INT_MAX && dist != INT64_MAX &&  * totrate != INT_MAX && * totdist != INT64_MAX ) {* totrate += rate ;* totdist += dist ;}case PARTITION_HORZ :  * get_sb_index ( x , subsize ) = 0 ;nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ;if ( mi_row + hbs < cm -> mi_rows ) {* get_sb_index ( x , subsize ) = 1 ;nonrd_pick_sb_modes ( cpi , tile , mi_row + hbs , mi_col ,  & rate , & dist , subsize ) ;get_block_context ( x , subsize ) -> mic . mbmi = mi_8x8 [ 0 ] -> mbmi ;if ( rate != INT_MAX && dist != INT64_MAX &&  * totrate != INT_MAX && * totdist != INT64_MAX ) {* totrate += rate ;* totdist += dist ;* get_sb_index ( x , subsize ) = 0 ;nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col ,   subsize , output_enabled , totrate , totdist ) ;* get_sb_index ( x , subsize ) = 1 ;nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp ,  mi_row , mi_col + hbs , subsize , output_enabled ,  & rate , & dist ) ;if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) {nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis , tp ,   mi_row + hbs , mi_col , subsize , output_enabled ,   & rate , & dist ) ;if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) {nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis + hbs , tp , mi_row + hbs , mi_col + hbs , subsize , output_enabled , & rate , & dist ) ;if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) {* totrate += rate ;* totdist += dist ;default :  assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;}if ( bsize == BLOCK_64X64 && output_enabled ) {if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , * totrate , * totdist ) ;}}","static void nonrd_use_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , MODE_INFO * * mi , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled , RD_COST * dummy_cost , PC_TREE * pc_tree ) {VP9_COMMON * const cm = & cpi -> common ;TileInfo * tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ;const int mis = cm -> mi_stride ;subsize = ( bsize >= BLOCK_8X8 ) ? mi [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ;partition = partition_lookup [ bsl ] [ subsize ] ;if ( output_enabled && bsize != BLOCK_4X4 ) {int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;td -> counts -> partition [ ctx ] [ partition ] ++ ;switch ( partition ) {case PARTITION_NONE : pc_tree -> none . pred_pixel_ready = 1 ;nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> none ) ;pc_tree -> none . mic . mbmi = xd -> mi [ 0 ] -> mbmi ;pc_tree -> none . mbmi_ext = * x -> mbmi_ext ;pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;pc_tree -> none . skip = x -> skip ;encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ;case PARTITION_VERT : pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ;nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> vertical [ 0 ] ) ;pc_tree -> vertical [ 0 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ;pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ;pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;pc_tree -> vertical [ 0 ] . skip = x -> skip ;encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) ;if ( mi_col + hbs < cm -> mi_cols && bsize > BLOCK_8X8 ) {pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ;nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col + hbs , dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ;pc_tree -> vertical [ 1 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ;pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ;pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;pc_tree -> vertical [ 1 ] . skip = x -> skip ;encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ;break ;case PARTITION_HORZ : pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ;nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 0 ] ) ;pc_tree -> horizontal [ 0 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ;pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ;pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;pc_tree -> horizontal [ 0 ] . skip = x -> skip ;encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) ;if ( mi_row + hbs < cm -> mi_rows && bsize > BLOCK_8X8 ) {pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ;nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row + hbs , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ;pc_tree -> horizontal [ 1 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ;pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ;pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ;pc_tree -> horizontal [ 1 ] . skip = x -> skip ;encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ;if ( bsize == BLOCK_8X8 ) {nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , pc_tree -> leaf_split [ 0 ] ) ;encode_b_rt ( cpi , td , tile_data , mi , tp , mi_row , mi_col , output_enabled , dummy_cost , pc_tree -> split [ 0 ] ) ;nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp , mi_row , mi_col + hbs , subsize , output_enabled , & rate , & dist ) ;if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) {nonrd_use_partition ( cpi , td , tile_data , mi + hbs , mi_col , subsize , output_enabled , & rate , & dist ) ;if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) {nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis + hbs + hbs , tp , mi_row + hbs , mi_col + hbs + hbs , subsize , output_enabled , dummy_cost , pc_tree -> split [ 3 ] ) ;default : assert ( 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ;break ;}if ( bsize == BLOCK_64X64 && output_enabled ) {if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , * totrate , * totdist ) ;}",4098
2381,* state = CCS_VALUE ;* type = CCV_CLASS ;,if ( * state != CCS_START ) * state = CCS_VALUE ;* type = CCV_CLASS ;,4099
2382,assert ( n >= 0 && n < 32 ) ;assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ;,if ( n < 0 || n >= 32 ) {return EOF ;}assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ;,4100
2383,"nfcb_poll -> sensb_res_len = * data ++ ;pr_debug ( ""sensb_res_len<S2SV_blank>%d\\\","nfcb_poll -> sensb_res_len = min_t ( __u8 , * data ++ , NFC_SENSB_RES_MAXSIZE ) ;pr_debug ( ""sensb_res_len<S2SV_blank>%d\\\",4101
2384,"GsmXSMPClient * client ;if ( server -> priv -> xsmp_sockets == NULL ) {client = ice_conn -> context ;g_return_val_if_fail ( client != NULL , TRUE ) ;gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ;return TRUE ;","GsmClient * client ;GsmIceConnectionWatch * data ;if ( server -> priv -> xsmp_sockets == NULL ) {data = ice_conn -> context ;g_return_val_if_fail ( client != NULL , TRUE ) ;gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) , sms_conn , mask_ret , callbacks_ret ) ;return TRUE ;",4102
2385,"
",if ( ( count < 0 ) || ( ( size_t ) count > length ) ) {length = 0 ;continue ;},4103
2386,"if ( ( * name != \'\\\\0\' ) && ( * name != \'#\' ) )  if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) {","if ( ( * name != \'\\\\0\' ) && ( * name != \'#\' ) ) if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) {",4103
2387,"static void fadst4 ( const int16_t * input , int16_t * output ) {int x0 , x1 , x2 , x3 ;int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;output [ 0 ] = output [ 1 ] = output [ 2 ] = output [ 3 ] = 0 ;","static void fadst4 ( const tran_low_t * input , tran_low_t * output ) {int x0 , x1 , x2 , x3 ;int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;output [ 0 ] = ( tran_low_t ) output [ 1 ] = ( tran_low_t ) output [ 2 ] = ( tran_low_t ) output [ 3 ] = ( tran_low_t ) 0 ;",4104
2388,output [ 0 ] = fdct_round_shift ( s0 ) ;output [ 1 ] = fdct_round_shift ( s1 ) ;output [ 2 ] = fdct_round_shift ( s2 ) ;output [ 3 ] = fdct_round_shift ( s3 ) ;},output [ 0 ] = fdct_round_shift ( s0 ) ;output [ 1 ] = fdct_round_shift ( s1 ) ;output [ 2 ] = fdct_round_shift ( s2 ) ;output [ 3 ] = fdct_round_shift ( s3 ) ;},4104
2389,}msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ;,}INTL_CHECK_LOCALE_LEN ( slocale_len ) ;msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ;,4105
2390,"return true ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;","return ( * field_rtrn != NULL ) ;case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ;",4106
2391,"NetTxAncillary ancillary ;buffer = udpAllocBuffer ( 0 , & offset ) ;","NetInterface * interface ;NetTxAncillary ancillary ;if ( message -> interface != NULL ) {interface = message -> interface ;}else {interface = socket -> interface ;}buffer = udpAllocBuffer ( 0 , & offset ) ;",4107
2392,"# endif  error = udpSendBuffer ( socket -> interface , & message -> srcIpAddr ,  socket -> localPort , & message -> destIpAddr , message -> destPort , buffer , offset , & ancillary ) ;","# endif error = udpSendBuffer ( interface , & message -> srcIpAddr , socket -> localPort , & message -> destIpAddr , message -> destPort , buffer , offset , & ancillary ) ;",4107
2393,nexthdr = * prevhdr ;* prevhdr = NEXTHDR_FRAGMENT ;,if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;nexthdr = * prevhdr ;* prevhdr = NEXTHDR_FRAGMENT ;,4108
2394,"len = args -> count = min ( args -> count , max_blocksize ) ;while ( len > 0 ) {return xdr_argsize_check ( rqstp , p ) ;}","if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;len = args -> count = min ( args -> count , max_blocksize ) ;while ( len > 0 ) {return 1 ;}",4109
2395,"set_exception_intercept ( svm , MC_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;","set_exception_intercept ( svm , MC_VECTOR ) ;set_exception_intercept ( svm , AC_VECTOR ) ;set_intercept ( svm , INTERCEPT_INTR ) ;",4110
2396,"if ( av_strstart ( url , ""crypto"" , NULL ) ) {if ( url [ 6 ] == \'+\' || url [ 6 ] == \':\' ) proto_name = avio_find_protocol_name ( url + 7 ) ;if ( ! proto_name ) proto_name = avio_find_protocol_name ( url ) ;if ( ! proto_name ) return AVERROR_INVALIDDATA ;if ( ! av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) )  return AVERROR_INVALIDDATA ;","if ( av_strstart ( proto_name , ""file"" , NULL ) ) {if ( strcmp ( c -> allowed_extensions , ""ALL"" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) {av_log ( s , AV_LOG_ERROR , ""Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\\\\\'%s\\\\\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\\return AVERROR_INVALIDDATA ;}else if ( av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) ) {;}else return AVERROR_INVALIDDATA ;",4111
2397,"list_add ( & mnt -> mnt_list , & new_ns -> list ) ;}","new_ns -> mounts ++ ;list_add ( & mnt -> mnt_list , & new_ns -> list ) ;}",4112
2398,"case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_I420 :  case VPX_IMG_FMT_I422 :   case VPX_IMG_FMT_I444 :  break ;default : ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>Only<S2SV_blank>YV12,<S2SV_blank>I420,<S2SV_blank>I422,<S2SV_blank>I444<S2SV_blank>images<S2SV_blank>are<S2SV_blank>""  ""supported."" ) ;}","case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I42016 : break ;case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I444 : case VPX_IMG_FMT_I440 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 ) {ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile."" ) ;}break ;case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44416 : case VPX_IMG_FMT_I44016 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 && ctx -> cfg . g_profile != ( unsigned int ) PROFILE_3 ) {ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>16-bit<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile."" ) ;}break ;default : ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>Only<S2SV_blank>YV12,<S2SV_blank>I420,<S2SV_blank>I422,<S2SV_blank>I444<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""supported."" ) ;break ;}",4113
2399,return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;}return - 1 ;},goto bail ;}goto bail ;}goto bail ;}goto bail ;}goto bail ;}goto bail ;},4114
2400,},bail : free ( tmpbuf ) ;tmpbuf = NULL ;return - 1 ;},4114
2401,"unsigned int maxfraglen , fragheaderlen ;int exthdrlen ;int hh_len ;int mtu ;","unsigned int maxfraglen , fragheaderlen , mtu ;int exthdrlen ;int hh_len ;",4115
2402,"if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen ,  fragheaderlen , skb , rt ) ;skb_prev = skb ;","if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE ) ;skb_prev = skb ;",4115
2403,"if ( ! hdr )  return - ENOBUFS ;if ( nla_put_u32 ( msg , NL80211_ATTR_IFINDEX , dev -> ifindex ) ) goto nla_put_failure ;","if ( ! hdr ) goto nla_put_failure ;if ( nla_put_u32 ( msg , NL80211_ATTR_IFINDEX , dev -> ifindex ) ) goto nla_put_failure ;",4116
2404,"log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>chassis"" ) ;return - 1 ;}TAILQ_INIT ( & chassis -> c_mgmt ) ;if ( ( port = calloc ( 1 , sizeof ( struct lldpd_port ) ) ) == NULL ) {log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>port"" ) ;free ( chassis ) ;return - 1 ;}# ifdef ENABLE_DOT1 TAILQ_INIT ( & port -> p_vlans ) ;TAILQ_INIT ( & port -> p_ppvids ) ;TAILQ_INIT ( & port -> p_pids ) ;# endif # ifdef ENABLE_CUSTOM TAILQ_INIT ( & port -> p_custom_list ) ;# endif length = s ;pos = ( u_int8_t * ) frame ;if ( length < 2 * ETHER_ADDR_LEN + sizeof ( u_int16_t ) ) {log_warnx ( ""lldp"" , ""too<S2SV_blank>short<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( PEEK_CMP ( lldpaddr , ETHER_ADDR_LEN ) != 0 ) {log_info ( ""lldp"" , ""frame<S2SV_blank>not<S2SV_blank>targeted<S2SV_blank>at<S2SV_blank>LLDP<S2SV_blank>multicast<S2SV_blank>address<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_DISCARD ( ETHER_ADDR_LEN ) ;if ( PEEK_UINT16 != ETHERTYPE_LLDP ) {log_info ( ""lldp"" , ""non<S2SV_blank>LLDP<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}while ( length && ( ! gotend ) ) {if ( length < 2 ) {log_warnx ( ""lldp"" , ""tlv<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}tlv_size = PEEK_UINT16 ;tlv_type = tlv_size >> 9 ;tlv_size = tlv_size & 0x1ff ;( void ) PEEK_SAVE ( tlv ) ;if ( length < tlv_size ) {log_warnx ( ""lldp"" , ""frame<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}switch ( tlv_type ) {case LLDP_TLV_END : if ( tlv_size != 0 ) {log_warnx ( ""lldp"" , ""lldp<S2SV_blank>end<S2SV_blank>received<S2SV_blank>with<S2SV_blank>size<S2SV_blank>not<S2SV_blank>null<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( length ) log_debug ( ""lldp"" , ""extra<S2SV_blank>data<S2SV_blank>after<S2SV_blank>lldp<S2SV_blank>end<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;gotend = 1 ;break ;case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 2 , ""Port<S2SV_blank>Id"" ) ;tlv_subtype = PEEK_UINT8 ;if ( ( tlv_subtype == 0 ) || ( tlv_subtype > 7 ) ) {log_warnx ( ""lldp"" , ""unknown<S2SV_blank>subtype<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>id<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size - 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>id<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size - 1 ) ;if ( tlv_type == LLDP_TLV_PORT_ID ) {port -> p_id_subtype = tlv_subtype ;port -> p_id = b ;port -> p_id_len = tlv_size - 1 ;}else {chassis -> c_id_subtype = tlv_subtype ;chassis -> c_id = b ;chassis -> c_id_len = tlv_size - 1 ;}break ;case LLDP_TLV_TTL : CHECK_TLV_SIZE ( 2 , ""TTL"" ) ;chassis -> c_ttl = PEEK_UINT16 ;ttl_received = 1 ;break ;case LLDP_TLV_PORT_DESCR : case LLDP_TLV_SYSTEM_NAME : case LLDP_TLV_SYSTEM_DESCR : if ( tlv_size < 1 ) {log_debug ( ""lldp"" , ""empty<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;break ;}if ( ( b = ( char * ) calloc ( 1 , tlv_size + 1 ) ) == NULL ) {log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>string<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;goto malformed ;}PEEK_BYTES ( b , tlv_size ) ;if ( tlv_type == LLDP_TLV_PORT_DESCR ) port -> p_descr = b ;else if ( tlv_type == LLDP_TLV_SYSTEM_NAME ) chassis -> c_name = b ;else chassis -> c_descr = b ;break ;case LLDP_TLV_SYSTEM_CAP : CHECK_TLV_SIZE ( 4 , ""System<S2SV_blank>capabilities"" ) ;chassis -> c_cap_available = PEEK_UINT16 ;chassis -> c_cap_enabled = PEEK_UINT16 ;break ;case LLDP_TLV_MGMT_ADDR : CHECK_TLV_SIZE ( 1 , ""Management<S2SV_blank>address"" ) ;addr_str_length = PEEK_UINT8 ;if ( addr_str_length > sizeof ( addr_str_buffer ) ) {log_warnx ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ;PEEK_BYTES ( addr_str_buffer , addr_str_length ) ;addr_length = addr_str_length - 1 ;addr_family = addr_str_buffer [ 0 ] ;addr_ptr = & addr_str_buffer [ 1 ] ;CHECK_TLV_SIZE ( 1 + addr_str_length + 5 , ""Management<S2SV_blank>address"" ) ;iface_subtype = PEEK_UINT8 ;iface_number = PEEK_UINT32 ;af = lldpd_af_from_lldp_proto ( addr_family ) ;if ( af == LLDPD_AF_UNSPEC ) break ;if ( iface_subtype == LLDP_MGMT_IFACE_IFINDEX ) iface = iface_number ;else iface = 0 ;mgmt = lldpd_alloc_mgmt ( af , addr_ptr , addr_length , iface ) ;if ( mgmt == NULL ) {assert ( errno == ENOMEM ) ;log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>""  ""for<S2SV_blank>management<S2SV_blank>address"" ) ;goto malformed ;}","if ( errno == ENOMEM ) ;log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>management<S2SV_blank>address"" ) ;else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ;",4117
2405,char added ;},},4118
2406,pair -> added = 0 ;for ( it = tmp_subnodes -> first ;,for ( it = tmp_subnodes -> first ;,4118
2407,"if ( buf )   _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;out_ok : ret = res . acl_len ;","if ( buf ) {if ( res . acl_len > buflen ) {ret = - ERANGE ;goto out_free ;}_copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ;}out_ok : ret = res . acl_len ;",4119
2408,if ( * p == '#' ) {p ++ ;,"len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;if ( * p == '#' ) {p ++ ;",4120
2409,"void nfs4_close_sync ( struct path * path , struct nfs4_state * state , mode_t mode )  {__nfs4_close ( path , state , mode , 1 ) ;}","void nfs4_close_sync ( struct path * path , struct nfs4_state * state , fmode_t fmode ) {__nfs4_close ( path , state , fmode , 1 ) ;}",4121
2410,vpx_codec_err_t res = VPX_CODEC_OK ;yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ;yv12 -> y_crop_width = img -> d_w ;yv12 -> y_crop_height = img -> d_h ;yv12 -> y_width = img -> d_w ;yv12 -> y_height = img -> d_h ;yv12 -> uv_width = ( 1 + yv12 -> y_width ) / 2 ;yv12 -> uv_height = ( 1 + yv12 -> y_height ) / 2 ;yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ;,const int y_w = img -> d_w ;const int y_h = img -> d_h ;const int uv_w = ( img -> d_w + 1 ) / 2 ;const int uv_h = ( img -> d_h + 1 ) / 2 ;vpx_codec_err_t res = VPX_CODEC_OK ;yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ;yv12 -> y_crop_width = y_w ;yv12 -> y_crop_height = img -> d_h ;yv12 -> y_width = y_w ;yv12 -> y_height = img -> d_h ;yv12 -> uv_width = uv_w ;yv12 -> uv_height = uv_h ;yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ;,4122
2411,create_option_search_table ( ) ;goto open_rc ;,"# ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ;if ( tmp_dir == NULL ) tmp_dir = rc_dir ;# endif create_option_search_table ( ) ;goto open_rc ;",4123
