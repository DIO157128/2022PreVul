,source,target,group
0,if ( tlen < 1 ) {,if ( tlen < 1U + 1 ) {,4124
1,if ( tlen < oid_len ) {return 0 ;,if ( tlen < oid_len ) {return 0 ;,4124
2,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",4125
3,dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ;dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ;,dpb_commands_t * ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) ;dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ;,4126
4,"static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id )   {if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\\}","static int iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) {if ( sta_id >= IWLAGN_STATION_COUNT ) {IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ;return - EINVAL ;}if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\\return 0 ;}",4127
5,"if ( rtm -> rtm_flags & RTM_F_FIB_MATCH )  err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid ,  nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ;else err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ;rcu_read_unlock ( ) ;err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ;","if ( rtm -> rtm_flags & RTM_F_FIB_MATCH ) {if ( ! res . fi ) {err = fib_props [ res . type ] . error ;if ( ! err ) err = - EHOSTUNREACH ;goto errout_free ;}err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ;}else {err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ;}rcu_read_unlock ( ) ;err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ;",4128
6,"r = send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ;if ( r == data_size ) {","r = TEMP_FAILURE_RETRY ( send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ) ;if ( r == data_size ) {",4129
7,"if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ;__TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ;if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ;th = ( const struct tcphdr * ) skb -> data ;if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ;if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ;if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ;th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ;if ( ! sk ) goto no_tcp_socket ;process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ;if ( sk -> sk_state == TCP_NEW_SYN_RECV ) {struct request_sock * req = inet_reqsk ( sk ) ;struct sock * nsk ;sk = req -> rsk_listener ;tcp_v6_fill_cb ( skb , hdr , th ) ;if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) {","if ( tcp_filter ( sk , skb ) ) {",4130
8,"if ( sk_filter ( sk , skb ) )   goto discard_and_relse ;skb -> dev = NULL ;","th = ( const struct tcphdr * ) skb -> data ;hdr = ipv6_hdr ( skb ) ;if ( sk_filter ( sk , skb ) ) goto discard_and_relse ;skb -> dev = NULL ;",4130
9,"replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ;encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ;encode_nops ( & hdr ) ;}","replen = hdr . replen + op_decode_hdr_maxsz + 1 ;encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ;xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;encode_nops ( & hdr ) ;}",4131
10,"rcu_read_lock ( ) ;__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;rcu_read_unlock ( ) ;","__ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ;rcu_read_unlock ( ) ;",4132
11,"ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ;}","ret = TEMP_FAILURE_RETRY ( sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ) ;}",4133
12,"args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return xdr_argsize_check ( rqstp , p ) ;}","if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return 1 ;}",4134
13,"vcpu = kvm_arch_vcpu_create ( kvm , id ) ;if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ;","if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;vcpu = kvm_arch_vcpu_create ( kvm , id ) ;if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ;",4135
14,if ( ! handle )  return NULL ;,if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ;,4136
15,hdl -> client_state = HSM_COM_C_STATE_IN ;* p_hdl = hdl ;,if ( mkstemp ( hdl -> c_path ) == - 1 ) {res = HSM_COM_PATH_ERR ;goto cleanup ;}hdl -> client_state = HSM_COM_C_STATE_IN ;* p_hdl = hdl ;,4137
16,"skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {msg -> msg_namelen = 0 ;copied = skb -> len ;","msg -> msg_namelen = 0 ;skb = skb_recv_datagram ( sk , flags , noblock , & err ) ;if ( ! skb ) {copied = skb -> len ;",4138
17,"gint reported_length_remaining ;ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ;","gint reported_length_remaining ;struct eth_phdr eth ;void * phdr ;ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ;",4139
18,"dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ;if ( ! info_added ) {","switch ( linktype ) {case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ;phdr = & eth ;break ;default : phdr = NULL ;break ;}dissector_try_uint_new ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree , TRUE , phdr ) ;if ( ! info_added ) {",4139
19,"int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;uint16_t * const eob = & p -> eobs [ block ] ;switch ( tx_size ) {case TX_32X32 :  fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vp9_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round ,   p -> quant , p -> quant_shift , qcoeff , dqcoeff ,   pd -> dequant , p -> zbin_extra , eob , scan_order -> scan ,  scan_order -> iscan ) ;case TX_16X16 :  vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ;vp9_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff ,  pd -> dequant , p -> zbin_extra , eob ,  scan_order -> scan , scan_order -> iscan ) ;case TX_8X8 :  vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ;vp9_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff ,  pd -> dequant , p -> zbin_extra , eob ,  scan_order -> scan , scan_order -> iscan ) ;vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round ,  p -> quant , p -> quant_shift , qcoeff , dqcoeff ,  pd -> dequant , p -> zbin_extra , eob ,  scan_order -> scan , scan_order -> iscan ) ;default :  assert ( 0 ) ;}","tran_low_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;uint16_t * const eob = & p -> eobs [ block ] ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {switch ( tx_size ) {case TX_32X32 : highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , scan_order -> iscan ) ;case TX_16X16 : vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ;vp9_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;case TX_8X8 : vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ;vp9_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;default : assert ( 0 ) ;}return ;}# endif switch ( tx_size ) {case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;break ;case TX_16X16 : vpx_fdct16x16 ( src_diff , coeff , diff_stride ) ;vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;break ;case TX_8X8 : vpx_fdct8x8 ( src_diff , coeff , diff_stride ) ;vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;break ;case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ;vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ;break ;default : assert ( 0 ) ;break ;}",4140
20,"struct desc_struct * desc ;short sel ;desc = get_desc ( sel ) ;if ( ! desc )  return - EINVAL ;if ( ! ( desc -> type & BIT ( 3 ) ) )  return - EINVAL ;switch ( ( desc -> l << 1 ) | desc -> d ) {case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ;","struct desc_struct desc ;short sel ;if ( ! desc ) return - EINVAL ;if ( ! ( desc . type & BIT ( 3 ) ) ) return - EINVAL ;switch ( ( desc . l << 1 ) | desc . d ) {case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ;",4141
21,"if ( ! sock ) goto out ;vhost_disable_notify ( & net -> dev , vq ) ;vhost_hlen = nvq -> vhost_hlen ;sock_hlen = nvq -> sock_hlen ;vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? vq -> log : NULL ;mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ;while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) {sock_len += sock_hlen ;vhost_len = sock_len + vhost_hlen ;headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? UIO_MAXIOV : 1 ) ;if ( unlikely ( headcount < 0 ) ) break ;if ( ! headcount ) {if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) {","if ( unlikely ( headcount > UIO_MAXIOV ) ) {msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\\continue ;}if ( ! headcount ) {if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) {",4142
22,"msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg ,  sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;if ( unlikely ( err != sock_len ) ) {pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\\","msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;if ( unlikely ( err != sock_len ) ) {pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\\",4142
23,if ( operand >= MAX_OPERANDS ) {,if ( strlen ( token ) > 4 && operand >= MAX_OPERANDS ) {,4143
24,if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) {op -> operands_count ++ ;,if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) {op -> operands_count ++ ;,4143
25,"size_t wcs_length = len ;size_t mbs_length = len ;# endif  if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) )  return ( - 1 ) ;if ( wcs_length == 0 ) {dest -> length = wcs - dest -> s ;dest -> s [ dest -> length ] = L'\\\\0' ;wcs_length = mbs_length ;if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) return ( - 1 ) ;wcs = dest -> s + dest -> length ;}# if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , wcs_length , & shift_state ) ;# else r = mbtowc ( wcs , mbs , wcs_length ) ;if ( errno == EILSEQ ) {++ mbs ;-- mbs_length ;continue ;}else break ;wcs_length -- ;","size_t mbs_length = len ;# endif if ( NULL == archive_wstring_ensure ( dest , dest -> length + len + 1 ) ) return ( - 1 ) ;# if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , mbs_length , & shift_state ) ;# else r = mbtowc ( wcs , mbs , mbs_length ) ;+ mbs ;break ;",4144
26,"timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer ,  timer -> base -> get_time ( ) , timr -> it_interval ) ;","timr -> it_overrun += hrtimer_forward ( timer , timer -> base -> get_time ( ) , timr -> it_interval ) ;",4145
27,# endif  newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;,# endif newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;newnp -> ipv6_fl_list = NULL ;,4146
28,newinet -> inet_opt = NULL ;newnp -> ipv6_ac_list = NULL ;,newinet -> inet_opt = NULL ;newnp -> ipv6_mc_list = NULL ;newnp -> ipv6_ac_list = NULL ;,4146
29,"int alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( alt < 0 )  return alt ;return usb_set_interface ( udev ,  intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ;}","struct usb_host_interface * alt ;alt = uas_find_uas_alt_setting ( intf ) ;if ( ! alt ) return - ENODEV ;return usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ;}",4147
30,"# line 52 ""dt_test2.pgc""  date date1 ;# line 53 ""dt_test2.pgc""  timestamp ts1 , ts2 ;# line 54 ""dt_test2.pgc""  char * text ;# line 55 ""dt_test2.pgc""  interval * i1 ;# line 56 ""dt_test2.pgc""  date * dc ;# line 57 ""dt_test2.pgc""  int i , j ;","# line 62 ""dt_test2.pgc"" date date1 ;# line 63 ""dt_test2.pgc"" timestamp ts1 , ts2 ;# line 64 ""dt_test2.pgc"" char * text ;# line 65 ""dt_test2.pgc"" interval * i1 ;# line 66 ""dt_test2.pgc"" date * dc ;# line 67 ""dt_test2.pgc"" int i , j ;",4148
31,"ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ;}","ret = TEMP_FAILURE_RETRY ( epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ) ;}",4149
32,"}for ( i = 0 ;ofpact_finish_BUNDLE ( ofpacts , & bundle ) ;if ( ! error ) {","}else {for ( i = 0 ;}ofpact_finish_BUNDLE ( ofpacts , & bundle ) ;if ( ! error ) {",4150
33,"char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;if ( prefix != \'+\' && prefix != \'-\' && prefix != \'=\' ) {yyerror ( ""Logconfig<S2SV_blank>prefix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\\\'+\\\',<S2SV_blank>\\\'-\\\'<S2SV_blank>or<S2SV_blank>\\\'=\\\'\\\}else ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ;}case 216 : # line 1012 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;break ;case 217 : # line 1017 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;case 227 : # line 1048 ""ntp_parser.y""  {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;break ;case 228 : # line 1049 ""ntp_parser.y""  {( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ;break ;case 229 : # line 1054 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ;case 230 : # line 1056 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ;case 231 : # line 1061 ""ntp_parser.y"" {case 233 : # line 1067 ""ntp_parser.y"" {case 234 : # line 1071 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ;case 235 : # line 1072 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;case 236 : # line 1076 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ;case 237 :  # line 1077 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Address_node ) ) ;case 238 :  # line 1082 ""ntp_parser.y""  {","char prefix ;char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ) {case \'+\' : case \'-\' : case \'=\' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ;type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ;default : prefix = \'=\' ;type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ;( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ;YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;case 235 : # line 1082 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ;break ;case 236 : # line 1086 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;break ;case 228 : # line 1059 ""ntp_parser.y"" {( yyval . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ;case 237 : # line 1087 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ;case 231 : # line 1071 ""ntp_parser.y"" {case 233 : # line 1077 ""ntp_parser.y"" {case 234 : # line 1081 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ;case 216 : # line 1012 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;case 217 : # line 1017 ""ntp_parser.y"" {enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ;}break ;case 227 : # line 1048 ""ntp_parser.y"" {( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ;case 228 : # line 1049 ""ntp_parser.y"" {( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ;case 238 : # line 1082 ""ntp_parser.y"" {",4151
34,"case 239 :  # line 1090 ""ntp_parser.y""  {case 240 :  # line 1091 ""ntp_parser.y""  {case 241 :  # line 1095 ""ntp_parser.y""  {case 243 :  # line 1106 ""ntp_parser.y""  {case 244 :  # line 1120 ""ntp_parser.y""  {case 245 :  # line 1124 ""ntp_parser.y""  {case 246 :  # line 1125 ""ntp_parser.y""  {case 247 :  # line 1129 ""ntp_parser.y""  {case 248 :  # line 1130 ""ntp_parser.y""  {case 249 :  # line 1134 ""ntp_parser.y""  {case 250 :  # line 1135 ""ntp_parser.y""  {case 251 :  # line 1140 ""ntp_parser.y""  {case 252 :  # line 1144 ""ntp_parser.y""  {case 253 :  # line 1148 ""ntp_parser.y""  {case 254 :  # line 1152 ""ntp_parser.y""  {case 255 :  # line 1153 ""ntp_parser.y""  {case 256 :  # line 1158 ""ntp_parser.y""  {case 257 :  # line 1162 ""ntp_parser.y""  {case 258 :  # line 1163 ""ntp_parser.y""  {case 259 :  # line 1168 ""ntp_parser.y""  {case 260 :  # line 1170 ""ntp_parser.y""  {case 261 :  # line 1172 ""ntp_parser.y""  {case 262 :  # line 1174 ""ntp_parser.y""  {case 263 :  # line 1176 ""ntp_parser.y""  {# line 3826 ""ntp_parser.c""  default : break ;","case 239 : # line 1090 ""ntp_parser.y"" {case 240 : # line 1091 ""ntp_parser.y"" {case 241 : # line 1095 ""ntp_parser.y"" {case 243 : # line 1106 ""ntp_parser.y"" {case 244 : # line 1120 ""ntp_parser.y"" {case 245 : # line 1124 ""ntp_parser.y"" {case 246 : # line 1125 ""ntp_parser.y"" {case 247 : # line 1129 ""ntp_parser.y"" {case 248 : # line 1100 ""ntp_parser.y"" {case 249 : # line 1101 ""ntp_parser.y"" {case 250 : # line 1105 ""ntp_parser.y"" {case 251 : # line 1134 ""ntp_parser.y"" {case 252 : # line 1135 ""ntp_parser.y"" {case 253 : # line 1139 ""ntp_parser.y"" {case 254 : # line 1140 ""ntp_parser.y"" {case 255 : # line 1144 ""ntp_parser.y"" {case 256 : # line 1145 ""ntp_parser.y"" {case 257 : # line 1150 ""ntp_parser.y"" {case 258 : # line 1154 ""ntp_parser.y"" {case 259 : # line 1158 ""ntp_parser.y"" {case 260 : # line 1162 ""ntp_parser.y"" {case 261 : # line 1163 ""ntp_parser.y"" {case 262 : # line 1168 ""ntp_parser.y"" {case 263 : # line 1172 ""ntp_parser.y"" {# line 3836 ""ntp_parser.c"" default : break ;",4151
35,"blkif -> st_ds_req ++ ;xen_blkif_get ( blkif ) ;if ( err == - EOPNOTSUPP ) {pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\\","struct phys_req preq ;preq . sector_number = req -> u . discard . sector_number ;preq . nr_sects = req -> u . discard . nr_sectors ;err = xen_vbd_translate ( & preq , blkif , WRITE ) ;if ( err ) {pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\\goto fail_response ;}blkif -> st_ds_req ++ ;xen_blkif_get ( blkif ) ;fail_response : if ( err == - EOPNOTSUPP ) {pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\\",4152
36,"blkif -> st_ds_req ++ ;xen_blkif_get ( blkif ) ;if ( err == - EOPNOTSUPP ) {pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\\","struct phys_req preq ;preq . sector_number = req -> u . discard . sector_number ;preq . nr_sects = req -> u . discard . nr_sectors ;err = xen_vbd_translate ( & preq , blkif , WRITE ) ;if ( err ) {pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\\goto fail_response ;}blkif -> st_ds_req ++ ;xen_blkif_get ( blkif ) ;fail_response : if ( err == - EOPNOTSUPP ) {pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\\",4153
37,"int nNew = sizeof ( char * ) * ( iArg + 1 ) ;char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ;if ( ! aNew ) {","sqlite3_int64 nNew = sizeof ( char * ) * ( iArg + 1 ) ;char const * * aNew = ( const char * * ) sqlite3_realloc64 ( ( void * ) aArg , nNew ) ;if ( ! aNew ) {",4154
38,"sprintf ( descriptor -> msg , ""\\\","sprintf ( descriptor -> msg , ""\\\",4155
39,if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 )  {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT   && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&   value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )  {,if ( field_identifier == SQL_DESC_COUNT && ( intptr_t ) value < 0 ) {if ( field_identifier == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) value != SQL_PARAM_INPUT && ( intptr_t ) value != SQL_PARAM_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) value != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t ) value != SQL_PARAM_OUTPUT_STREAM ) {,4155
40,"strncpy ( hid -> name , req -> name , 128 ) ;snprintf ( hid -> phys , sizeof ( hid -> phys ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ;","strncpy ( hid -> name , sizeof ( req -> name ) - 1 ) ;snprintf ( hid -> phys , sizeof ( hid -> phys ) , ""%pMR"" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ;",4156
41,"handle_t * handle = NULL ;int ret = 0 ;ext4_debug ( ""ext4_get_block_write:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>create<S2SV_blank>flag<S2SV_blank>%d\\\create = EXT4_GET_BLOCKS_IO_CREATE_EXT ;if ( max_blocks > DIO_MAX_BLOCKS ) max_blocks = DIO_MAX_BLOCKS ;ret = ext4_get_blocks ( handle , inode , iblock , max_blocks , bh_result ,  create ) ;}ext4_journal_stop ( handle ) ;","handle_t * handle = ext4_journal_current_handle ( ) ;int ret = 0 ;int started = 0 ;ext4_debug ( ""ext4_get_block_write:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>create<S2SV_blank>flag<S2SV_blank>%d\\\create = EXT4_GET_BLOCKS_IO_CREATE_EXT ;if ( ! handle ) {if ( max_blocks > DIO_MAX_BLOCKS ) max_blocks = DIO_MAX_BLOCKS ;started = 1 ;}ret = ext4_get_blocks ( handle , inode , iblock , max_blocks , bh_result , create ) ;}if ( started ) ext4_journal_stop ( handle ) ;",4157
42,uint32_t backup_handle ;if ( req -> multisample_count != 0 ) return - EINVAL ;,uint32_t backup_handle = 0 ;if ( req -> multisample_count != 0 ) return - EINVAL ;,4158
43,if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE <  res -> backup_size ) {goto out_unlock ;},if ( ret == 0 ) {if ( res -> backup -> base . num_pages * PAGE_SIZE < res -> backup_size ) {goto out_unlock ;}else {backup_handle = req -> buffer_handle ;}},4158
44,"print_int ( ""coded_picture_number"" , frame -> coded_picture_number ) ;print_int ( ""display_picture_number"" , frame -> display_picture_number ) ;print_int ( ""interlaced_frame"" , frame -> interlaced_frame ) ;print_int ( ""top_field_first"" , frame -> top_field_first ) ;print_int ( ""repeat_pict"" , frame -> repeat_pict ) ;if ( frame -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ;else print_str_opt ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ;if ( frame -> colorspace != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ;else print_str_opt ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ;if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED )  print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ;","print_primaries ( w , frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ;",4159
45,"ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ;ret = rtJsonEncStringValue ( pJsonCtxt , utf8str ) ;","ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ;if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ;ret = rtJsonEncStringValue ( pJsonCtxt , utf8str ) ;",4160
46,"
",if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ;,4161
47,"ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num ,  & temp_poc , prev_slice_err ) ;","ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ;",4161
48,proto = EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ndo -> ndo_eflag ) {,"const u_char * bp = p ;if ( length < CHDLC_HDRLEN ) goto trunc ;ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ;proto = EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ndo -> ndo_eflag ) {",4162
49,"case ETHERTYPE_ISO :  if ( * ( p + 1 ) == 0x81 ||  * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;}","case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ;ND_TCHECK_16BITS ( p ) ;if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ;trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ;return ndo -> ndo_snapend - bp ;}",4162
50,"if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) return ;}r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ;r_anal_esil_set_pc ( esil , core -> offset ) ;r_anal_esil_parse ( esil , input + 1 ) ;r_anal_esil_dumpstack ( esil ) ;r_anal_esil_stack_free ( esil ) ;break ;case \'s\' : switch ( input [ 1 ] ) {case \'?\' : eprintf ( ""See:<S2SV_blank>ae?~aes\\\break ;case \'l\' : {ut64 pc = r_debug_reg_get ( core -> dbg , ""PC"" ) ;RAnalOp * op = r_core_anal_op ( core , pc ) ;if ( ! op ) {break ;}r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ;r_debug_reg_set ( core -> dbg , ""PC"" , pc + op -> size ) ;r_anal_esil_set_pc ( esil , pc + op -> size ) ;r_core_cmd0 ( core , "".ar*"" ) ;}break ;case \'b\' : if ( ! r_core_esil_step_back ( core ) ) {eprintf ( ""cannnot<S2SV_blank>step<S2SV_blank>back\\\}r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'u\' : if ( input [ 2 ] == \'e\' ) {until_expr = input + 3 ;}else {until_addr = r_num_math ( core -> num , input + 2 ) ;}r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'o\' : op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ;if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) {until_addr = op -> addr + op -> size ;}r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_anal_op_free ( op ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;case \'p\' : n = strchr ( input , \'<S2SV_blank>\' ) ;n1 = n ? strchr ( n + 1 , \'<S2SV_blank>\' ) : NULL ;if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) {eprintf ( ""aesp<S2SV_blank>[offset]<S2SV_blank>[num]\\\break ;}adr = r_num_math ( core -> num , n + 1 ) ;off = r_num_math ( core -> num , n1 + 1 ) ;cmd_aespc ( core , adr , off ) ;break ;case \'<S2SV_blank>\' : n = strchr ( input , \'<S2SV_blank>\' ) ;if ( ! ( n + 1 ) ) {r_core_esil_step ( core , until_addr , until_expr , NULL ) ;break ;}off = r_num_math ( core -> num , n + 1 ) ;cmd_aespc ( core , - 1 , off ) ;break ;default : r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;break ;}break ;case \'c\' : if ( input [ 1 ] == \'?\' ) {r_core_cmd_help ( core , help_msg_aec ) ;}else if ( input [ 1 ] == \'s\' ) {const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ;ut64 newaddr ;int ret ;for ( ;;) {op = r_core_anal_op ( core , addr ) ;if ( ! op ) {break ;}if ( op -> type == R_ANAL_OP_TYPE_SWI ) {eprintf ( ""syscall<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\break ;}if ( op -> type == R_ANAL_OP_TYPE_TRAP ) {eprintf ( ""trap<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\break ;}ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ;r_anal_op_free ( op ) ;op = NULL ;if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) {break ;}if ( ! ret ) break ;r_core_cmd0 ( core , "".ar*"" ) ;newaddr = r_num_get ( core -> num , pc ) ;if ( addr == newaddr ) {addr ++ ;break ;}else {addr = newaddr ;}}if ( op ) {r_anal_op_free ( op ) ;}}else {if ( input [ 1 ] == \'u\' && input [ 2 ] == \'e\' ) until_expr = input + 3 ;else if ( input [ 1 ] == \'u\' ) until_addr = r_num_math ( core -> num , input + 2 ) ;else until_expr = ""0"" ;r_core_esil_step ( core , until_addr , until_expr , NULL ) ;r_core_cmd0 ( core , "".ar*"" ) ;}break ;case \'i\' : switch ( input [ 1 ] ) {case \'s\' : case \'m\' : cmd_esil_mem ( core , input + 2 ) ;break ;case \'p\' : r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ;break ;case \'?\' : cmd_esil_mem ( core , ""?"" ) ;break ;case \'-\' : if ( esil ) {sdb_reset ( esil -> stats ) ;}r_anal_esil_free ( esil ) ;core -> anal -> esil = NULL ;break ;case 0 : r_anal_esil_free ( esil ) ;{const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ;if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) {r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ;}}if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) {r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ;esil -> verbose = ( int ) r_config_get_i ( core -> config , ""esil.verbose"" ) ;{const char * s = r_config_get ( core -> config , ""cmd.esil.intr"" ) ;if ( s ) {char * my = strdup ( s ) ;if ( my ) {r_config_set ( core -> config , ""cmd.esil.intr"" , my ) ;free ( my ) ;}}}break ;}break ;case \'k\' : switch ( input [ 1 ] ) {case \'\\\\0\' : input = ""123*"" ;case \'<S2SV_blank>\' : if ( esil && esil -> stats ) {char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ;if ( out ) {r_cons_println ( out ) ;free ( out ) ;}}else {eprintf ( ""esil.stats<S2SV_blank>is<S2SV_blank>empty.<S2SV_blank>Run<S2SV_blank>\\\'aei\\\'\\\}break ;case \'-\' : if ( esil ) {sdb_reset ( esil -> stats ) ;}break ;}break ;case \'f\' : {RListIter * iter ;RAnalBlock * bb ;RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ;if ( fcn ) {r_list_foreach ( fcn -> bbs , iter , bb ) {ut64 pc = bb -> addr ;ut64 end = bb -> addr + bb -> size ;RAnalOp op ;ut8 * buf ;int ret , bbs = end - pc ;if ( bbs < 1 || bbs > 0xfffff ) {eprintf ( ""Invalid<S2SV_blank>block<S2SV_blank>size\\\}buf = calloc ( 1 , bbs + 1 ) ;r_io_read_at ( core -> io , pc , buf , bbs ) ;int left ;while ( pc < end ) {left = R_MIN ( end - pc , 32 ) ;r_asm_set_pc ( core -> assembler , pc ) ;ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ;if ( ret ) {r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ;r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ;r_anal_esil_dumpstack ( esil ) ;r_anal_esil_stack_free ( esil ) ;pc += op . size ;}else {pc += 4 ;}}}}else {eprintf ( ""Cannot<S2SV_blank>find<S2SV_blank>function<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\\}}break ;case \'t\' : switch ( input [ 1 ] ) {case \'r\' : {RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ;if ( ! esil )  return ;","
",4163
51,struct dentry * res ;if ( nd -> flags & LOOKUP_CREATE ) {,struct dentry * res ;fmode_t fmode = nd -> intent . open . flags & ( FMODE_READ | FMODE_WRITE | FMODE_EXEC ) ;if ( nd -> flags & LOOKUP_CREATE ) {,4164
52,"state = nfs4_do_open ( dir , & path , nd -> intent . open . flags , & attr , cred ) ;put_rpccred ( cred ) ;","state = nfs4_do_open ( dir , & path , fmode , nd -> intent . open . flags , & attr , cred ) ;put_rpccred ( cred ) ;",4164
53,"nfs4_intent_set_file ( nd , & path , state ) ;return res ;","nfs4_intent_set_file ( nd , & path , state , fmode ) ;return res ;",4164
54,"static inline bool unconditional ( const struct arpt_arp * arp )  {return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ;}","static inline bool unconditional ( const struct arpt_entry * e ) {return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> arp , & uncond , sizeof ( uncond ) ) == 0 ;}",4165
55,"if ( clone_flags & CLONE_SETTLS )  thread -> tp_value = childregs -> ARM_r3 ;thread_notify ( THREAD_NOTIFY_COPY , thread ) ;","if ( clone_flags & CLONE_SETTLS ) thread -> tp_value [ 0 ] = childregs -> ARM_r3 ;thread -> tp_value [ 1 ] = get_tpuser ( ) ;thread_notify ( THREAD_NOTIFY_COPY , thread ) ;",4166
56,"if ( options_file ( configuration_file , type , & section ) )  return 1 ;if ( init_section ( 1 , & section ) )   return 1 ;s_log ( LOG_NOTICE , ""Configuration<S2SV_blank>successful"" ) ;","if ( options_file ( configuration_file , type , & section ) || init_section ( 1 , & section ) ) {s_log ( LOG_ERR , ""Configuration<S2SV_blank>failed"" ) ;options_free ( 0 ) ;return 1 ;}s_log ( LOG_NOTICE , ""Configuration<S2SV_blank>successful"" ) ;",4167
57,"int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy )  {if ( policy -> version != 0 ) return - EINVAL ;","int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy ) {if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;if ( policy -> version != 0 ) return - EINVAL ;",4168
58,nName ++ ;if ( zName == 0 ) {}},if ( zName == 0 ) {}nName = ( int ) strlen ( zName ) ;},4169
59,"_sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) ;if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {_sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\\\'t<S2SV_blank>offer"" , mech ) ;","_sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK ;if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) {_sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\\\'t<S2SV_blank>offer"" , mech ) ;",4170
60,"
",if ( shm_file == NULL ) {err = - EIDRM ;goto out_unlock0 ;},4171
61,if ( is_file_hugepages ( shm_file ) )  goto out_unlock0 ;,if ( is_file_hugepages ( shm_file ) ) goto out_unlock0 ;,4171
62,"if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) {log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ;","if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS ) {log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ;",4172
63,"if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) )  {","if ( g_settings_privatereports ) {struct stat statbuf ;if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) {error_msg ( ""Path<S2SV_blank>\\\'%s\\\'<S2SV_blank>isn\\\'t<S2SV_blank>directory"" , dirname ) ;return 404 ;}struct group * gr = getgrnam ( ""abrt"" ) ;if ( ! gr ) {error_msg ( ""Group<S2SV_blank>\\\'abrt\\\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ;return 500 ;}if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) {error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\\\'%s\\\'<S2SV_blank>isn\\\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access"" , dirname ) ;return 403 ;}struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ;const bool complete = dd && problem_dump_dir_is_complete ( dd ) ;dd_close ( dd ) ;if ( complete ) {error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\\\'%s\\\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed"" , dirname ) ;return 403 ;}}else if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) ) {",4173
64,"if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) )   return psf_fread ( ptr , 1 , bytes , psf ) ;if ( psf -> headindex + bytes > SIGNED_SIZEOF ( psf -> header ) )  {most = SIGNED_SIZEOF ( psf -> header ) - psf -> headend ;psf_fread ( psf -> header + psf -> headend , 1 , most , psf ) ;memcpy ( ptr , psf -> header + psf -> headend , most ) ;psf -> headend = psf -> headindex += most ;psf_fread ( ( char * ) ptr + most , bytes - most , 1 , psf ) ;return bytes ;};if ( psf -> headindex + bytes > psf -> headend )   {count = psf_fread ( psf -> header + psf -> headend , 1 , bytes - ( psf -> headend - psf -> headindex ) , psf ) ;if ( count != bytes - ( int ) ( psf -> headend - psf -> headindex ) )  {psf -> headend += count ;}memcpy ( ptr , psf -> header + psf -> headindex , bytes ) ;psf -> headindex += bytes ;return bytes ;","if ( psf -> header . indx + bytes >= psf -> header . len && psf_bump_header_allocation ( psf , bytes ) ) return count ;if ( psf -> headindex + bytes > SIGNED_SIZEOF ( psf -> header ) ) {most = SIGNED_SIZEOF ( psf -> header . indx + bytes > psf -> headend ) {count = psf_fread ( psf -> header . ptr + psf -> headend , 1 , bytes - ( psf -> headend - psf -> headindex ) , psf ) ;if ( count != bytes - ( int ) ( psf -> headend - psf -> headindex ) ) {psf -> headend += count ;}memcpy ( ptr , psf -> header + psf -> header . indx , bytes ) ;psf -> header . indx += bytes ;return bytes ;",4174
65,"or_circuit_t * or_circ = NULL ;const or_options_t * options = get_options ( ) ;if ( ! CIRCUIT_IS_ORIGIN ( circ ) )   or_circ = TO_OR_CIRCUIT ( circ ) ;relay_header_unpack ( & rh , cell -> payload ) ;","or_circuit_t * or_circ = NULL ;origin_circuit_t * origin_circ = NULL ;crypt_path_t * layer_hint = NULL ;const or_options_t * options = get_options ( ) ;if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) {or_circ = TO_OR_CIRCUIT ( circ ) ;}else {tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ;origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ;layer_hint = origin_circ -> cpath -> prev ;}relay_header_unpack ( & rh , cell -> payload ) ;",4175
66,"relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , layer_hint ) ;return 0 ;",4175
67,"relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_NOTDIRECTORY , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_NOTDIRECTORY , layer_hint ) ;return 0 ;",4175
68,"relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_INTERNAL , NULL ) ;return 0 ;relay_send_end_cell_from_edge ( rh . stream_id , circ ,  END_STREAM_REASON_EXITPOLICY , NULL ) ;return 0 ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_INTERNAL , layer_hint ) ;return 0 ;relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , layer_hint ) ;return 0 ;",4175
69,"origin_circuit_t * origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ;log_info ( LD_REND , ""begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream."" ) ;","tor_assert ( origin_circ ) ;log_info ( LD_REND , ""begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream."" ) ;",4175
70,"relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_DONE ,  origin_circ -> cpath -> prev ) ;connection_free ( TO_CONN ( n_stream ) ) ;","relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_DONE , layer_hint ) ;connection_free ( TO_CONN ( n_stream ) ) ;",4175
71,"for ( i = 0 ;data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ;assert ( data [ i ] ) ;","assert ( jas_image_numcmpts ( image ) ;++ i ) {data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) <= 3 ) ;for ( i = 0 ;i < 3 ;++ i ) {data [ i ] = 0 ;}for ( i = 0 ;if ( ! ( data [ i ] ) ;",4176
72,return - 1 ;}z = ( z << 8 ) | c ;nz += 8 ;,goto error ;}z = ( z << 8 ) | c ;nz += 8 ;,4176
73,return - 1 ;return - 1 ;,goto error ;goto error ;,4176
74,"
",data [ i ] = 0 ;error : for ( i = 0 ;i < 3 ;++ i ) {if ( data [ i ] ) {jas_matrix_destroy ( data [ i ] ) ;}}return - 1 ;,4176
75,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",4177
76,struct cpuinfo_x86 * c ;cpu = iminor ( file -> f_path . dentry -> d_inode ) ;,struct cpuinfo_x86 * c ;if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ;cpu = iminor ( file -> f_path . dentry -> d_inode ) ;,4178
77,"ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ;if ( credssp -> server ) {","SecInvalidateHandle ( & credssp -> context ) ;ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ;if ( credssp -> server ) {",4179
78,"rc = fuse_dev_release ( inode , file ) ;return rc ;","fuse_conn_put ( & cc -> fc ) ;rc = fuse_dev_release ( inode , file ) ;return rc ;",4180
79,return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;},"scat = & rm -> data . op_sg [ sg ] ;ret = sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ;ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ;return ret ;}",4181
80,"static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) {char buf [ 512 ] ;SvcInternal * const si = get_svc_internal ( svc_ctx ) ;if ( level > svc_ctx -> log_level ) {","static int svc_log ( SvcContext * svc_ctx , SVC_LOG_LEVEL level , const char * fmt , ... ) {char buf [ 512 ] ;SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ;if ( level > svc_ctx -> log_level ) {",4182
81,new_timer -> it_overrun = - 1 ;if ( event ) {,new_timer -> it_overrun = - 1LL ;if ( event ) {,4183
82,int  c ;,MagickBooleanType status ;int c ;,4184
83,"for ( i = 2 ;# if 0 fprintf ( stderr , ""DEBUG:<S2SV_blank>Concatenate<S2SV_blank>Image:<S2SV_blank>\\\\""%s\\\\""\\\# endif input = fopen_utf8 ( argv [ i ] , ""rb"" ) ;c = fgetc ( input ) )  ( void ) fputc ( ( char ) c , output ) ;( void ) fclose ( input ) ;( void ) remove_utf8 ( argv [ i ] ) ;return ( MagickTrue ) ;}","status = MagickTrue ;for ( i = 2 ;input = fopen_utf8 ( argv [ i ] , ""rb"" ) ;c = fgetc ( input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ;( void ) fclose ( input ) ;( void ) fclose ( input ) ;( void ) remove_utf8 ( argv [ i ] ) ;return ( MagickTrue ) ;}",4184
84,assert ( 0 ) ;return NULL ;,return NULL ;,4185
85,"priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ;if ( ! priv -> base ) {","if ( ! r ) return - EINVAL ;priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ;if ( ! priv -> base ) {",4186
86,"ret = poll ( & pfd , 1 , 1 ) ;BTIF_TRACE_VERBOSE ( ""%s()<S2SV_blank>-<S2SV_blank>polling<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>revents:<S2SV_blank>0x%x,<S2SV_blank>ret<S2SV_blank>%d"" , __FUNCTION__ , pfd . fd , pfd . revents , ret ) ;if ( ret <= 0 ) {read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ;}","ret = TEMP_FAILURE_RETRY ( poll ( & pfd , 1 , 1 ) ) ;BTIF_TRACE_VERBOSE ( ""%s()<S2SV_blank>-<S2SV_blank>polling<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>revents:<S2SV_blank>0x%x,<S2SV_blank>ret<S2SV_blank>%d"" , __FUNCTION__ , pfd . fd , pfd . revents , ret ) ;TEMP_FAILURE_RETRY ( if ( ret <= 0 ) {read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ) ;}",4187
87,int i ;int j ;,jas_matind_t i ;jas_matind_t j ;,4188
88,"void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {","static void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {",4189
89,"if ( report -> id == REPORT_KEY_STATE ) {if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ;","if ( size > 64 ) {hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\\return 0 ;}if ( report -> id == REPORT_KEY_STATE ) {if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ;",4190
90,"vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;find_next_key_frame ( cpi , & this_frame_copy ) ;","memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;find_next_key_frame ( cpi , & this_frame_copy ) ;",4191
91,"vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;define_gf_group ( cpi , & this_frame_copy ) ;vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;","memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;define_gf_group ( cpi , & this_frame_copy ) ;memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;",4191
92,"vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;","memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ;assign_std_frame_bits ( cpi , & this_frame_copy ) ;",4191
93,"Stream_Read_UINT16 ( s , iconInfo -> cbBitsMask ) ;Stream_Read_UINT16 ( s , iconInfo -> cbBitsColor ) ;if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsMask + iconInfo -> cbBitsColor )  return FALSE ;newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsMask , iconInfo -> cbBitsMask ) ;if ( ! newBitMask ) {free ( iconInfo -> bitsMask ) ;iconInfo -> bitsMask = NULL ;return FALSE ;}iconInfo -> bitsMask = newBitMask ;if ( ! iconInfo -> colorTable ) return FALSE ;","Stream_Read_UINT16 ( s , iconInfo -> cbBitsMask ) return FALSE ;if ( ! iconInfo -> colorTable ) {if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbColorTable ) return FALSE ;return FALSE ;}",4192
94,"if ( iconInfo -> colorTable )  Stream_Read ( s , iconInfo -> colorTable , iconInfo -> cbColorTable ) ;newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ;if ( ! newBitMask ) {Stream_Read ( s , iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ;return TRUE ;","if ( iconInfo -> colorTable ) Stream_Read ( s , iconInfo -> colorTable , iconInfo -> cbColorTable ) ;newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ;if ( ! newBitMask ) {if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsColor ) return FALSE ;Stream_Read ( s , iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ;return TRUE ;",4192
95,meshdrlen = extract_mesh_header_length ( p + hdrlen ) ;hdrlen += meshdrlen ;,"if ( caplen < hdrlen + 1 ) {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return hdrlen ;}meshdrlen = extract_mesh_header_length ( p + hdrlen ) ;hdrlen += meshdrlen ;",4193
96,"return - EACCES ;err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;}else if ( opcode == BPF_MOV ) {if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( insn -> imm != 0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ;if ( err ) return err ;}else {if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}}err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ;regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ;}else {if ( is_pointer_value ( env , insn -> src_reg ) ) {verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\return - EACCES ;}mark_reg_unknown ( env , regs , insn -> dst_reg ) ;regs [ insn -> dst_reg ] . var_off = tnum_cast (  regs [ insn -> dst_reg ] . var_off , 4 ) ;__update_reg_bounds ( & regs [ insn -> dst_reg ] ) ;}","coerce_reg_to_size ( & regs [ insn -> dst_reg ] , 4 ) ;",4194
97,skcipher -> setkey = alg -> setkey ;skcipher -> encrypt = alg -> encrypt ;,skcipher -> setkey = skcipher_setkey ;skcipher -> encrypt = alg -> encrypt ;,4195
98,"void vp9_fwht4x4_c ( const int16_t * input , int16_t * output , int stride ) {int i ;int a1 , b1 , c1 , d1 , e1 ;const int16_t * ip = input ;int16_t * op = output ;for ( i = 0 ;a1 = ip [ 0 * stride ] ;b1 = ip [ 1 * stride ] ;c1 = ip [ 2 * stride ] ;d1 = ip [ 3 * stride ] ;a1 += b1 ;op [ 0 ] = a1 ;op [ 4 ] = c1 ;op [ 8 ] = d1 ;op [ 12 ] = b1 ;ip ++ ;","void vp9_fwht4x4_c ( const int16_t * input , tran_low_t * output , int stride ) {int i ;tran_high_t a1 , b1 , c1 , d1 , e1 ;const int16_t * ip_pass0 = input ;int16_t * op = output ;for ( i = 0 ;a1 = ip_pass0 [ 0 * stride ] ;b1 = ip_pass0 [ 1 * stride ] ;c1 = ip_pass0 [ 2 * stride ] ;d1 = ip_pass0 [ 3 * stride ] ;a1 += b1 ;op [ 0 ] = ( tran_low_t ) a1 ;op [ 4 ] = ( tran_low_t ) c1 ;op [ 8 ] = ( tran_low_t ) d1 ;op [ 12 ] = ( tran_low_t ) b1 ;ip_pass0 ++ ;",4196
99,op [ 0 ] = a1 * UNIT_QUANT_FACTOR ;op [ 1 ] = c1 * UNIT_QUANT_FACTOR ;op [ 2 ] = d1 * UNIT_QUANT_FACTOR ;op [ 3 ] = b1 * UNIT_QUANT_FACTOR ;ip += 4 ;,op [ 0 ] = ( tran_low_t ) ( a1 * UNIT_QUANT_FACTOR ) ;op [ 1 ] = ( tran_low_t ) ( c1 * UNIT_QUANT_FACTOR ) ;op [ 2 ] = ( tran_low_t ) ( d1 * UNIT_QUANT_FACTOR ) ;op [ 3 ] = ( tran_low_t ) ( b1 * UNIT_QUANT_FACTOR ) ;ip += 4 ;,4196
100,"struct sock * sk ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;","struct sock * sk ;if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ;if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ;",4197
101,"if ( keyring ) {if ( keyring -> restrict_link ) return - EPERM ;link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ;}mutex_lock ( & key_construction_mutex ) ;if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {atomic_inc ( & key -> user -> nikeys ) ;key -> reject_error = - error ;smp_wmb ( ) ;",if ( key -> state == KEY_IS_UNINSTANTIATED ) {atomic_inc ( & key -> user -> nikeys ) ;key -> reject_error = - error ;smp_wmb ( ) ;,4198
102,"
","if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ;",4199
103,"if ( current_entry + n > ( int ) c -> entries ) {memset ( lengths + current_entry , current_length , n ) ;","if ( current_entry + n > ( int ) c -> entries ) {memset ( lengths + current_entry , current_length , n ) ;",4199
104,"c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ;}","int values = lookup1_values ( c -> entries , c -> dimensions ) ;if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ;c -> lookup_values = ( uint32 ) values ;}",4199
105,g -> values = 2 ;,"g -> values - 1 ;++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ;for ( j = 0 ;j < g -> values = 2 ;",4199
106,for ( j = 0 ;++ j )  g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;,for ( j = 0 ;+ j )  g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;++ j ) g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ;,4199
107,"
","if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup ) ;",4199
108,"m -> coupling_steps = get_bits ( f , 8 ) + 1 ;for ( k = 0 ;","m -> coupling_steps = get_bits ( f , 8 ) + 1 ;for ( k = 0 ;",4199
109,"for ( i = 0 ;i ++ )  av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;return 0 ;}","for ( i = 0 ;i ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ;}return 0 ;}",4200
110,"int kb ;kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ;if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ;","int kb , r ;kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ;r = vt_verify_kbmode ( fd ) ;if ( r == - EBUSY ) {log_debug_errno ( r , ""Keyboard<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>XLATE<S2SV_blank>or<S2SV_blank>UNICODE<S2SV_blank>mode,<S2SV_blank>not<S2SV_blank>resetting:<S2SV_blank>%m"" ) ;return 0 ;}else if ( r < 0 ) return r ;if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ;",4201
111,"ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;","struct floppy_raw_cmd cmd = * ptr ;cmd . next = NULL ;cmd . kernel_data = NULL ;ret = copy_to_user ( param , & cmd , sizeof ( * ptr ) ) ;if ( ret ) return - EFAULT ;",4202
112,if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] )  return - EINVAL ;,if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) return - EINVAL ;,4203
113,"if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) )  return 0 ;if ( ! ( mask & MAY_WRITE ) )  if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) )  return 0 ;if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) )  if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) )  return 0 ;if ( mask == MAY_READ )  if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) )  return 0 ;","if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_OVERRIDE ) ) return 0 ;if ( ! ( mask & MAY_WRITE ) ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ;if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_OVERRIDE ) ) return 0 ;if ( mask == MAY_READ ) if ( capable_wrt_inode_uidgid ( inode , CAP_DAC_READ_SEARCH ) ) return 0 ;",4204
114,"if ( token == NULL ) return ERROR_INVALID_SYNTAX ;if ( osIsdigit ( token [ 0 ] ) ) {if ( osStrlen ( token ) == 8 && token [ 2 ] == \'-\' && token [ 5 ] == \'-\' ) {dirEntry -> modified . month = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ;","if ( osStrstr ( token , NULL , 10 ) ;",4205
115,"if ( strstr ( token , ""PM"" ) != NULL )  dirEntry -> modified . hours += 12 ;else  {","if ( strstr ( token , ""PM"" ) != NULL ) {dirEntry -> modified . hours += 12 ;}else {",4205
116,"if ( strchr ( token , \'d\' ) != NULL )  dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ;if ( strchr ( token , \'w\' ) == NULL )  dirEntry -> attributes |= FTP_FILE_ATTR_READ_ONLY ;token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ;if ( token == NULL ) return ERROR_INVALID_SYNTAX ;","if ( osStrchr ( token , \'d\' ) != NULL ) {dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ;}if ( osStrchr ( token , \'w\' ) == NULL ) {dirEntry -> attributes |= FTP_FILE_ATTR_READ_ONLY ;}token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ;if ( token == NULL ) return ERROR_INVALID_SYNTAX ;",4205
117,"while ( tmp && alen < tmp ) {ND_PRINT ( ( ndo , ""\\\","while ( tmp && alen < tmp ) {ND_TCHECK2 ( * tptr , alen ) ;ND_PRINT ( ( ndo , ""\\\",4206
118,"char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ;char * mask_decoded5 ;mask_decoded = NULL ;mask_decoded2 = NULL ;mask2 = weechat_string_replace ( mask , dir_separator , ""\\\\01"" ) ;if ( ! mask2 ) goto end ;mask_decoded = weechat_buffer_string_replace_local_var ( buffer , mask2 ) ;if ( ! mask_decoded ) goto end ;mask_decoded2 = weechat_string_replace ( mask_decoded , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ;if ( ! mask_decoded2 ) goto end ;# ifdef __CYGWIN__ mask_decoded3 = weechat_string_replace ( mask_decoded2 , ""\\\\\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ;# else mask_decoded3 = strdup ( mask_decoded2 ) ;# endif if ( ! mask_decoded3 ) goto end ;mask_decoded4 = weechat_string_replace ( mask_decoded3 , ""\\\\01"" , dir_separator ) ;if ( ! mask_decoded4 ) goto end ;length = strlen ( mask_decoded4 ) + 256 + 1 ;mask_decoded5 = malloc ( length ) ;if ( ! mask_decoded5 )  goto end ;mask_decoded5 [ 0 ] = \'\\\\0\' ;strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ;if ( weechat_config_boolean ( logger_config_file_name_lower_case ) )  weechat_string_tolower ( mask_decoded5 ) ;if ( weechat_logger_plugin -> debug ) {weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) ,  mask , mask_decoded5 ) ;}if ( mask_decoded )   free ( mask_decoded ) ;if ( mask_decoded2 )  free ( mask_decoded2 ) ;if ( mask_decoded3 )  free ( mask_decoded3 ) ;if ( mask_decoded4 )  free ( mask_decoded4 ) ;return mask_decoded5 ;}","char * mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 ;mask3 = NULL ;mask4 = NULL ;mask5 = NULL ;mask6 = NULL ;mask7 = NULL ;mask_decoded2 = NULL ;length = strlen ( mask ) + 256 + 1 ;mask_decoded5 = malloc ( length ) ;if ( ! mask_decoded5 ) goto end ;mask_decoded5 [ 0 ] = \'\\\\0\' ;strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) == 0 ) mask2 [ 0 ] = \'\\\\0\' ;mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\\\01"" ) ;if ( ! mask3 ) goto end ;mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ;if ( ! mask4 ) goto end ;mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ;if ( ! mask5 ) goto end ;# ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ;# else mask6 = strdup ( mask5 ) ;# endif if ( ! mask6 ) goto end ;mask7 = weechat_string_replace ( mask6 , ""\\\\01"" , dir_separator ) ;if ( ! mask7 ) goto end ;if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) weechat_string_tolower ( mask7 ) ;if ( weechat_logger_plugin -> debug ) {weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\\\""%s\\\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) , mask , mask7 ) ;}if ( mask3 ) free ( mask_decoded ) ;if ( mask_decoded2 ) free ( mask3 ) ;if ( mask4 ) free ( mask_decoded3 ) ;if ( mask_decoded4 ) free ( mask6 ) ;return mask7 ;}",4207
119,"r_set_size ( op , size ) ;push ( 2 ) ;r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ;op1 -> value . bytes = ptr + size ;r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ;make_true ( op ) ;",op -> tas . rsize = size ;push ( 2 ) ;op [ - 3 ] . value . bytes ) ;op1 -> value . bytes = ptr + size ;if ( forward ) {op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ;op [ - 3 ] . tas . rsize = count ;}else {op [ - 1 ] . tas . rsize = count ;op [ - 3 ] . tas . rsize -= count + size ;}make_true ( op ) ;,4208
120,"char * method = manager -> method ;int i ;build_config ( working_dir , server ) ;if ( server -> method ) method = server -> method ;snprintf ( cmd , BUF_SIZE ,  ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" ,   executable , method , manager -> manager_address ,   working_dir , server -> port , working_dir , server -> port ) ;if ( manager -> acl != NULL ) {","int i ;int port ;port = atoi ( server -> port ) ;build_config ( working_dir , manager , server ) ;snprintf ( cmd , BUF_SIZE , ""%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf"" , executable , method , manager -> manager_address , working_dir , port , working_dir , server -> port ) ;if ( manager -> acl != NULL ) {",4209
121,"struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ;struct sock * sk = sock -> sk ;int chan = sa -> rc_channel ;int err = 0 ;BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa -> rc_bdaddr ) ;lock_sock ( sk ) ;if ( sk -> sk_state != BT_OPEN ) {err = - EBADFD ;goto done ;}if ( sk -> sk_type != SOCK_STREAM ) {err = - EINVAL ;goto done ;}write_lock ( & rfcomm_sk_list . lock ) ;if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) {err = - EADDRINUSE ;bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ;rfcomm_pi ( sk ) -> channel = chan ;sk -> sk_state = BT_BOUND ;","struct sockaddr_rc sa ;struct sock * sk = sock -> sk ;int chan = sa -> rc_channel ;int err = 0 ;memset ( & sa , 0 , sizeof ( sa ) ) ;len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ;memcpy ( & sa , addr , len ) ;BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa . rc_bdaddr ) ;lock_sock ( sk ) ;if ( sa . rc_channel && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) {err = - EADDRINUSE ;bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ;rfcomm_pi ( sk ) -> channel = chan ;sk -> sk_state = BT_BOUND ;",4210
122,"int open_debug_log ( void ) {if ( verify_config || test_scheduling == TRUE ) return OK ;if ( ( debug_file_fp = fopen ( debug_file , ""a+"" ) ) == NULL )  return ERROR ;( void ) fcntl ( fileno ( debug_file_fp ) , F_SETFD , FD_CLOEXEC ) ;return OK ;","int open_debug_log ( void ) {int fh ;struct stat st ;if ( verify_config || test_scheduling == TRUE ) return OK ;if ( ( fh = open ( debug_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) return ERROR ;if ( ( fstat ( fh , & st ) ) == - 1 ) {debug_file_fp = NULL ;close ( fh ) ;return ERROR ;}if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) {debug_file_fp = NULL ;close ( fh ) ;return ERROR ;}if ( ( debug_file_fp = fdopen ( fh , ""a+"" ) ) == NULL ) return ERROR ;( void ) fcntl ( fh , F_SETFD , FD_CLOEXEC ) ;return OK ;",4211
123,if ( gf -> file && gf -> file -> device )   free ( gf -> file -> device -> disk ) ;free ( gf -> file ) ;,if ( gf -> file && gf -> file -> device ) {free ( gf -> file -> device -> disk ) ;}free ( gf -> file ) ;,4212
124,"unsigned char * data = packet -> data + packet -> size ;unsigned short type = attrtype ;unsigned short len = data_len ;if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) {fprintf ( stderr , _ ( ""mndp_add_attribute:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\","unsigned char * data = packet -> data + packet -> size ) {fprintf ( stderr , _ ( ""mndp_add_attribute:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\\",4213
125,if ( data -> instance_id_fd != - 1 )  drop_cloexec ( data -> instance_id_fd ) ;sigemptyset ( & set ) ;,if ( data -> instance_id_fd ) ;if ( data -> env_fd != - 1 ) drop_cloexec ( data -> env_fd != - 1 ) drop_cloexec ( data -> instance_id_fd ) ;sigemptyset ( & set ) ;,4214
126,"cifs_small_buf_release ( req ) ;rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ;free_rsp_buf ( resp_buftype , rsp ) ;return rc ;","rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ;cifs_small_buf_release ( req ) ;free_rsp_buf ( resp_buftype , rsp ) ;return rc ;",4215
127,return ms ;free : free ( ms ) ;,ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;return ms ;free : free ( ms ) ;,4216
128,"if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) {absolute_filename = g_strdup ( filename ) ;",if ( g_path_is_absolute ( filename ) ) {absolute_filename = g_strdup ( filename ) ;,4217
129,return error ;},return error < 0 ? error : 0 ;},4218
130,}else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) )   ses -> server -> ops = & smb311_operations ;},ses -> server -> vals = & smb21_values ;}else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) {ses -> server -> ops = & smb311_operations ;ses -> server -> vals = & smb311_values ;}},4219
131,"static vpx_codec_err_t ctrl_update_entropy ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {const int update = va_arg ( args , int ) ;","static vpx_codec_err_t ctrl_update_entropy ( vpx_codec_alg_priv_t * ctx , va_list args ) {const int update = va_arg ( args , int ) ;",4220
132,int is_udplite = IS_UDPLITE ( sk ) ;int is_udp4 ;,bool checksum_valid = false ;int is_udplite = IS_UDPLITE ( sk ) ;int is_udp4 ;,4221
133,"if ( udp_lib_checksum_complete ( skb ) )  goto csum_copy_err ;if ( skb_csum_unnecessary ( skb ) )  err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;","checksum_valid = ! udp_lib_checksum_complete ( skb ) ;if ( ! checksum_valid ) goto csum_copy_err ;if ( checksum_valid || skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ;",4221
134,"if ( ! pflag ) ( void ) umask ( mask ) ;if ( argc != 1 ) {run_err ( ""ambiguous<S2SV_blank>target"" ) ;exit ( 1 ) ;}targ = * argv ;if ( targetshouldbedirectory ) verifydir ( targ ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ;for ( first = 1 ;;first = 0 ) {cp = buf ;if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ;if ( * cp ++ == \'\\\do {if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ;* cp ++ = ch ;}while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != \'\\\* cp = 0 ;if ( verbose_mode ) fprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ;if ( buf [ 0 ] == \'\\\\01\' || buf [ 0 ] == \'\\\\02\' ) {if ( iamremote == 0 ) ( void ) atomicio ( vwrite , STDERR_FILENO , buf + 1 , strlen ( buf + 1 ) ) ;if ( buf [ 0 ] == \'\\\\02\' ) exit ( 1 ) ;++ errs ;continue ;}if ( buf [ 0 ] == \'E\' ) {( void ) atomicio ( vwrite , remout , """" , 1 ) ;return ;}if ( ch == \'\\\cp = buf ;if ( * cp == \'T\' ) {setimes ++ ;cp ++ ;mtime . tv_sec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;mtime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;atime . tv_sec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;atime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'\\\\0\' ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;continue ;}if ( * cp != \'C\' && * cp != \'D\' ) {if ( first ) {run_err ( ""%s"" , cp ) ;exit ( 1 ) ;}SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ;}mode = 0 ;for ( ++ cp ;cp < buf + 5 ;cp ++ ) {if ( * cp < \'0\' || * cp > \'7\' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ;mode = ( mode << 3 ) | ( * cp - \'0\' ) ;}if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ;for ( size = 0 ;isdigit ( * cp ) ;) size = size * 10 + ( * cp ++ - \'0\' ) ;if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ( strchr ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;","+ errs ;if ( * cp == \'\\\\0\' || strchr ( cp , ""."" ) == 0 || strcmp ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;",4222
135,uint32_t len ;uint32_t n ;,uint32_t n ;,4223
136,"n = r -> iov . iov_len / 512 ;r -> sector += n ;len = r -> sector_count * 512 ;if ( len > SCSI_DMA_BUF_SIZE ) {len = SCSI_DMA_BUF_SIZE ;r -> iov . iov_len = len ;DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\\scsi_req_data ( & r -> req , len ) ;}","n = r -> qiov . size / 512 ;r -> sector += n ;scsi_init_iovec ( r ) ;DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\\scsi_req_data ( & r -> req , len ) ;",4223
137,"data = malloc ( blk_sz * n_blks ) ;memset ( data , 0 , blk_sz * n_blks ) ;","data = safe_calloc ( blk_sz * n_blks ) ;memset ( data , 0 , blk_sz * n_blks ) ;",4224
138,if ( current -> mm )  __flush_tlb_one ( start ) ;else   leave_mm ( smp_processor_id ( ) ) ;},if ( current -> mm ) {__flush_tlb_one ( start ) ;}else {leave_mm ( smp_processor_id ( ) ) ;smp_mb ( ) ;}},4225
139,"if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete )  return ERROR_INVALID_PARAMETER ;file = drive_get_file_by_id ( drive , irp -> FileId ) ;if ( ! file ) {else if ( ! drive_file_seek ( file , Offset ) ) {irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ;Length = 0 ;}else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) )  {","void * ptr ;if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) return ERROR_INVALID_PARAMETER ;ptr = Stream_Pointer ( irp -> input ) ;if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ;file = drive_get_file_by_id ( drive , irp -> FileId ) ;if ( ! file ) {else if ( ! drive_file_seek ( file , ptr , Length ) ) {",4226
140,if ( border < 0 ) {return ;,if ( border < 0 || color < 0 ) {return ;,4227
141,uint8_t * result ;new_raw_len = RAW_DATA_LEN ( header ) + nbytes ;,uint8_t * result ;if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) {return NULL ;}new_raw_len = RAW_DATA_LEN ( header ) + nbytes ;,4228
142,"return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ;}","struct dm_dev * dev = lc -> dev ;int r = 0 ;if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ;}",4229
143,"return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ;}","return segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ;}",4230
144,"savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds | prev -> ds ) )  loadsegment ( ds , next -> ds ) ;savesegment ( fs , fsindex ) ;","savesegment ( fs , fsindex ) ;savesegment ( es , prev -> es ) ;if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ;savesegment ( ds , prev -> ds ) ;if ( unlikely ( next -> ds ) ;",4231
145,if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) )  return - ENXIO ;,"if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ;if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ;",4232
146,goto fail ;},ret = - EINVAL ;goto fail ;},4233
147,"pipe_buf_get ( ipipe , ibuf ) ;* obuf = * ibuf ;","if ( ! pipe_buf_get ( ipipe , ibuf ) ) {if ( ret == 0 ) ret = - EFAULT ;break ;}* obuf = * ibuf ;",4234
148,"struct sas_task * task = TO_SAS_TASK ( cmd ) ;sas_end_task ( cmd , task ) ;scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ;}","struct domain_device * dev = cmd_to_domain_dev ( cmd ) ;struct sas_task * task = TO_SAS_TASK ( cmd ) ;sas_end_task ( cmd , task ) ;if ( dev_is_sata ( dev ) ) {list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ;return ;}scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ;}",4235
149,int pkt_len ;char line [ COSINE_LINE_LENGTH ] ;,char line [ COSINE_LINE_LENGTH ] ;,4236
150,"pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ;if ( pkt_len == - 1 ) return FALSE ;return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err ,  err_info ) ;","return parse_cosine_packet ( wth -> random_fh , phdr , pkt_len , buf , err , err_info ) ;",4236
151,"args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return xdr_argsize_check ( rqstp , p ) ;}","if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return 1 ;}",4237
152,rx_drop :  kfree_skb ( skb ) ;rcv_stats -> rx_dropped ++ ;,rx_drop : rcv_stats -> rx_dropped ++ ;,4238
153,int lineno ;int col_offset ;,string type_comment ;int lineno ;int col_offset ;,4239
154,"res = obj2ast_expr ( tmp , & annotation , arena ) ;if ( res != 0 ) goto failed ;","res = obj2ast_expr ( tmp , & annotation , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;",4239
155,"* out = arg ( arg , annotation , lineno , col_offset , end_lineno , end_col_offset ,  arena ) ;","* out = arg ( arg , annotation , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4239
156,"
","memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;",4240
157,"cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ;memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ;","cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ;memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ;",4240
158,"static vpx_codec_err_t decoder_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) {const uint8_t * data_end = data + data_sz ;vpx_codec_err_t res = VPX_CODEC_OK ;uint32_t sizes [ 8 ] ;int frames_this_pts , frame_count = 0 ;if ( data == NULL || data_sz == 0 )   return VPX_CODEC_INVALID_PARAM ;parse_superframe_index ( data , data_sz , sizes , & frames_this_pts ) ;do {if ( data_sz && ( * data_start & 0xe0 ) == 0xc0 ) {const uint8_t marker = * data_start ;const uint32_t frames = ( marker & 0x7 ) + 1 ;const uint32_t mag = ( ( marker >> 3 ) & 0x3 ) + 1 ;const uint32_t index_sz = 2 + mag * frames ;if ( data_sz >= index_sz && data_start [ index_sz - 1 ] == marker ) {data_start += index_sz ;data_sz -= index_sz ;if ( data_start < data_end ) continue ;else break ;}}if ( frames_this_pts ) {uint32_t this_sz = sizes [ frame_count ] ;if ( data_sz < this_sz ) {ctx -> base . err_detail = ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ;data_sz = this_sz ;frame_count ++ ;res = decode_one ( ctx , & data_start , data_sz , user_priv , deadline ) ;assert ( data_start >= data ) ;assert ( data_start <= data_end ) ;if ( res ) break ;while ( data_start < data_end && * data_start == 0 ) data_start ++ ;data_sz = ( unsigned int ) ( data_end - data_start ) ;while ( data_start < data_end ) ;","static vpx_codec_err_t decoder_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * const data , unsigned int data_sz , void * user_priv , long deadline ) {const uint8_t * data_end = data + data_sz ;vpx_codec_err_t res ;uint32_t frame_sizes [ 8 ] ;int frames_this_pts , frame_count = 0 ;if ( data == NULL && data_sz == 0 ) return VPX_CODEC_INVALID_PARAM ;parse_superframe_index ( data , data_sz , frame_sizes , & frame_count , ctx -> decrypt_cb , ctx -> decrypt_state ) ;if ( res != VPX_CODEC_OK ) return res ;if ( ctx -> frame_parallel_decode ) {if ( frame_count > 0 ) {int i ;for ( i = 0 ;i < frame_count ;++ i ) {const uint8_t * data_start_copy = data_start ;const uint32_t frame_size = frame_sizes [ i ] ;if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) {set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ;if ( ctx -> available_threads == 0 ) {if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) {wait_worker_and_cache_frame ( ctx ) ;}else {set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ;return VPX_CODEC_ERROR ;}}res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ;if ( res != VPX_CODEC_OK ) return res ;data_start += frame_size ;}}else {if ( ctx -> available_threads == 0 ) {if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) {wait_worker_and_cache_frame ( ctx ) ;}else {set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ;return VPX_CODEC_ERROR ;}}res = decode_one ( ctx , & data , data_sz , user_priv , deadline ) ;if ( res != VPX_CODEC_OK ) return res ;}}else {if ( frame_count > 0 ) {int i ;for ( i = 0 ;i < frame_count ;++ i ) {const uint8_t * data_start_copy = data_start ;const uint32_t frame_size = frame_sizes [ i ] ;vpx_codec_err_t res ;if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) {set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ;return VPX_CODEC_CORRUPT_FRAME ;}res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ;if ( res != VPX_CODEC_OK ) return res ;data_start += frame_size ;}}else {while ( data_start < data_end ) {const uint32_t frame_size = ( uint32_t ) ( data_end - data_start ) ;const vpx_codec_err_t res = decode_one ( ctx , & data_start , frame_size , user_priv , deadline ) ;if ( res != VPX_CODEC_OK ) return res ;while ( data_start < data_end ) {const uint8_t marker = read_marker ( ctx -> decrypt_cb , ctx -> decrypt_state , data_start ) ;if ( marker ) break ;++ data_start ;}}",4241
159,"opts = fcntl ( s , F_GETFL ) ;if ( opts < 0 ) APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ;if ( fcntl ( s , F_SETFL , opts ) < 0 )  APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ;","opts = TEMP_FAILURE_RETRY ( fcntl ( s , F_GETFL ) ) ;if ( TEMP_FAILURE_RETRY ( opts < 0 ) APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ;if ( fcntl ( s , F_SETFL , opts ) ) < 0 ) APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ;",4242
160,"if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) >  ( Rec2 . RecordLength - 2 - 2 ) / 3 )  ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;","if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ;",4243
161,unsigned int i ;bpcc -> numcmpts = box -> datalen ;,unsigned int i ;bpcc -> bpcs = 0 ;bpcc -> numcmpts = box -> datalen ;,4244
162,"
","assert ( ( ae = archive_entry_new ( ) ) != NULL ) ;archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;assert ( 0 == archive_write_header ( a , ae ) ) ;assert ( 0 == archive_write_finish_entry ( a ) ) ;assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ;assert ( archive_entry_clear ( ae ) != NULL ) ;archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;archive_entry_set_mode ( ae , S_IFREG | 0777 ) ;archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ;failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ;assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ;archive_entry_free ( ae ) ;assert ( 0 == archive_write_finish_entry ( a ) ) ;assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;",4245
163,"assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;assert ( 0 == lstat ( ""dir"" , & st ) ) ;","assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ;assert ( 0 == lstat ( ""dir"" , & st ) ) ;",4245
164,struct resv_map * reservations = vma_resv_map ( vma ) ;unsigned long reserve ;,struct resv_map * reservations = vma_resv_map ( vma ) ;struct hugepage_subpool * spool = subpool_vma ( vma ) ;unsigned long reserve ;,4246
165,"hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ;}","hugepage_subpool_put_pages ( spool , reserve ) ;}",4246
166,"szLineConv [ i ] = 0 ;strcpy ( szLine , szLineConv ) ;","if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;szLineConv [ i ] = 0 ;strcpy ( szLine , szLineConv ) ;",4247
167,"if ( skb -> pkt_type != PACKET_HOST ) goto drop ;if ( skb_warn_if_lro ( skb ) ) goto drop ;if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_FWD , skb ) ) goto drop ;if ( IPCB ( skb ) -> opt . router_alert && ip_call_ra_chain ( skb ) ) return NET_RX_SUCCESS ;skb_forward_csum ( skb ) ;if ( ip_hdr ( skb ) -> ttl <= 1 ) goto too_many_hops ;if ( ! xfrm4_route_forward ( skb ) ) goto drop ;rt = skb_rtable ( skb ) ;if ( opt -> is_strictroute && rt -> rt_uses_gateway ) goto sr_failed ;IPCB ( skb ) -> flags |= IPSKB_FORWARDED ;mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ;if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) {IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ;icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , htonl ( mtu ) ) ;goto drop ;}if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) goto drop ;iph = ip_hdr ( skb ) ;ip_decrease_ttl ( iph ) ;if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) )  ip_rt_send_redirect ( skb ) ;",if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) ip_rt_send_redirect ( skb ) ;,4248
168,"long length , offset , size , at ;int encoding ;","size_t length , offset , size , at ;int encoding ;",4249
169,"
","if ( hdr . toc_length_decompressed != strm . total_out ) {cli_dbgmsg ( ""TOC<S2SV_blank>decompress<S2SV_blank>length<S2SV_blank>%"" PRIu64 ""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>amount<S2SV_blank>decompressed<S2SV_blank>%lu\\\toc [ strm . total_out ] = \'\\\\0\' ;hdr . toc_length_decompressed = strm . total_out ;}",4249
170,"goto exit_toc ;}cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>scanning<S2SV_blank>xar<S2SV_blank>TOC<S2SV_blank>xml<S2SV_blank>in<S2SV_blank>memory.\\\rc = cli_mem_scandesc ( toc , hdr . toc_length_decompressed , ctx ) ;if ( rc != CL_SUCCESS ) {if ( rc != CL_VIRUS || ! SCAN_ALL ) goto exit_toc ;}if ( ctx -> engine -> keeptmp ) {if ( ( rc = cli_gentempfd ( ctx -> engine -> tmpdir , & tmpname , & fd ) ) != CL_SUCCESS ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>file<S2SV_blank>for<S2SV_blank>TOC.\\\goto exit_toc ;}if ( cli_writen ( fd , toc , hdr . toc_length_decompressed ) < 0 ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>TOC.\\\rc = CL_EWRITE ;xar_cleanup_temp_file ( ctx , fd , tmpname ) ;rc = xar_cleanup_temp_file ( ctx , fd , tmpname ) ;if ( rc != CL_SUCCESS ) goto exit_toc ;}reader = xmlReaderForMemory ( toc , hdr . toc_length_decompressed , ""noname.xml"" , NULL , CLAMAV_MIN_XMLREADER_FLAGS ) ;if ( reader == NULL ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>xmlReaderForMemory<S2SV_blank>error<S2SV_blank>for<S2SV_blank>TOC\\\goto exit_toc ;}rc = xar_scan_subdocuments ( reader , ctx ) ;if ( rc != CL_SUCCESS ) {cli_dbgmsg ( ""xar_scan_subdocuments<S2SV_blank>returns<S2SV_blank>%i.\\\goto exit_reader ;}fd = - 1 ;tmpname = NULL ;while ( CL_SUCCESS == ( rc = xar_get_toc_data_values ( reader , & length , & offset , & size , & encoding , & a_cksum , & a_hash , & e_cksum , & e_hash ) ) ) {int do_extract_cksum = 1 ;unsigned char * blockp ;void * a_sc , * e_sc ;void * a_mc , * e_mc ;char * expected ;if ( fd > - 1 && tmpname ) {rc = xar_cleanup_temp_file ( ctx , fd , tmpname ) ;if ( rc != CL_SUCCESS ) goto exit_reader ;}at = offset + hdr . toc_length_compressed + hdr . size ;if ( ( rc = cli_gentempfd ( ctx -> engine -> tmpdir , & tmpname , & fd ) ) != CL_SUCCESS ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>generate<S2SV_blank>temporary<S2SV_blank>file.\\\goto exit_reader ;}cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\\","cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\\",4249
171,"unsigned long in_remaining = length ;unsigned long out_size = 0 ;int lret ;memset ( & lz , 0 , sizeof ( lz ) ) ;","unsigned long in_remaining = MIN ( length , map -> len - at ) ;unsigned long out_size = 0 ;int lret ;if ( length > in_remaining ) length = in_remaining ;memset ( & lz , 0 , sizeof ( lz ) ) ;",4249
172,"cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\\","cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\\",4249
173,"cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\\rc = CL_EREAD ;","cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\\rc = CL_EREAD ;",4249
174,"unsigned long write_len ;if ( ctx -> engine -> maxfilesize )  write_len = MIN ( ( size_t ) ( ctx -> engine -> maxfilesize ) , ( size_t ) length ) ;else write_len = length ;if ( ! ( blockp = ( void * ) fmap_need_off_once ( map , at , length ) ) ) {char errbuff [ 128 ] ;cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\\if ( a_hash_ctx != NULL )  xar_hash_update ( a_hash_ctx , blockp , length , a_hash ) ;if ( cli_writen ( fd , blockp , write_len ) < 0 ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\\rc = CL_EWRITE ;","size_t writelen = MIN ( map -> len - at , length ) ;if ( ctx -> engine -> maxfilesize ) writelen = MIN ( ( size_t ) ( ctx -> engine -> maxfilesize ) , writelen ) ;if ( ! ( blockp = ( void * ) fmap_need_off_once ( map , at , writelen ) ) ) {char errbuff [ 128 ] ;cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\\\'t<S2SV_blank>read<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%zu,<S2SV_blank>errno:%s.\\\if ( a_hash_ctx != NULL ) xar_hash_update ( a_hash_ctx , blockp , writelen , a_hash ) ;if ( cli_writen ( fd , blockp , writelen ) < 0 ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\\rc = CL_EWRITE ;",4249
175,"cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>mismatch.\\\cksum_fails ++ ;}else {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>matched.\\\}free ( expected ) ;}if ( e_hash_ctx != NULL ) {xar_hash_final ( e_hash_ctx , result , e_hash ) ;e_hash_ctx = NULL ;}else {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum(unarchived-checksum)<S2SV_blank>missing.\\\cksum_fails ++ ;}if ( e_cksum != NULL ) {if ( do_extract_cksum ) {expected = cli_hex2str ( ( char * ) e_cksum ) ;if ( xar_hash_check ( e_hash , result , expected ) != 0 ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum<S2SV_blank>mismatch.\\\cksum_fails ++ ;}else {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum<S2SV_blank>matched.\\\}free ( expected ) ;}}rc = cli_magic_scandesc ( fd , ctx ) ;if ( rc != CL_SUCCESS ) {if ( rc == CL_VIRUS ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Infected<S2SV_blank>with<S2SV_blank>%s\\\if ( ! SCAN_ALL ) goto exit_tmpfile ;}else if ( rc != CL_BREAK ) {cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_magic_scandesc<S2SV_blank>error<S2SV_blank>%i\\\goto exit_tmpfile ;}}}if ( a_cksum != NULL ) {xmlFree ( a_cksum ) ;a_cksum = NULL ;}if ( e_cksum != NULL ) {xmlFree ( e_cksum ) ;e_cksum = NULL ;}}exit_tmpfile : xar_cleanup_temp_file ( ctx , fd , tmpname ) ;if ( a_hash_ctx != NULL ) xar_hash_final ( a_hash_ctx , result , a_hash ) ;if ( e_hash_ctx != NULL ) xar_hash_final ( e_hash_ctx , result , e_hash ) ;exit_reader : if ( a_cksum != NULL ) xmlFree ( a_cksum ) ;if ( e_cksum != NULL ) xmlFree ( e_cksum ) ;xmlTextReaderClose ( reader ) ;xmlFreeTextReader ( reader ) ;exit_toc : free ( toc ) ;if ( rc == CL_BREAK ) rc = CL_SUCCESS ;# else cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>can\\\'t<S2SV_blank>scan<S2SV_blank>xar<S2SV_blank>files,<S2SV_blank>need<S2SV_blank>libxml2.\\\# endif if ( cksum_fails + extract_errors != 0 ) {cli_warnmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors,<S2SV_blank>use<S2SV_blank>--debug<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info.\\\","cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors.\\\",4249
176,"
","if ( ! ND_TTEST2 ( * bp , 2 ) ) {ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ;return ;}",4250
177,opt_type = * bp ++ ;opt_len = * bp ++ ;,opt_type = * bp ++ ;opt_len = * bp ++ ;,4250
178,"spin_unlock_irqrestore ( & slave_active_lock , flags ) ;}","list_del_init ( & timeri -> ack_list ) ;list_del_init ( & timeri -> active_list ) ;spin_unlock_irqrestore ( & slave_active_lock , flags ) ;}",4251
179,uchar buf [ PGX_MAGICLEN ] ;uint_fast32_t magic ;,jas_uchar buf [ PGX_MAGICLEN ] ;uint_fast32_t magic ;,4252
180,for ( depth = 1 ;depth ++ )   if ( depth >= 64 )  break ;,"if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;for ( depth = 1 ;depth ++ ) ;",4253
181,"static int set_vt_partitioning ( VP9_COMP * cpi ,  void * data ,   const TileInfo * const tile ,  BLOCK_SIZE bsize , int mi_row , int mi_col ,  int mi_size ) {VP9_COMMON * const cm = & cpi -> common ;const int block_height = num_8x8_blocks_high_lookup [ bsize ] ;const int64_t threshold_multiplier = 25 ;int64_t threshold = threshold_multiplier * cpi -> common . base_qindex ;if ( mi_col + block_width / 2 < cm -> mi_cols &&  mi_row + block_height / 2 < cm -> mi_rows && vt . part_variances -> none . variance < threshold ) {set_block_size ( cpi , tile , mi_row , mi_col , bsize ) ;return 1 ;if ( mi_row + block_height / 2 < cm -> mi_rows &&  vt . part_variances -> vert [ 0 ] . variance < threshold &&  vt . part_variances -> vert [ 1 ] . variance < threshold ) {set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ;set_block_size ( cpi , tile , mi_row , mi_col + block_width / 2 , subsize ) ;return 1 ;if ( mi_col + block_width / 2 < cm -> mi_cols &&  vt . part_variances -> horz [ 0 ] . variance < threshold && vt . part_variances -> horz [ 1 ] . variance < threshold ) {set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ;set_block_size ( cpi , tile , mi_row + block_height / 2 , mi_col , subsize ) ;return 1 ;return 0 ;}","static int set_vt_partitioning ( VP9_COMP * cpi , MACROBLOCK * const x , MACROBLOCKD * const xd , void * data , BLOCK_SIZE bsize , int mi_row , int mi_col , int mi_size ) {VP9_COMMON * const cm = & cpi -> common ;const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ;if ( force_split == 1 ) return 0 ;if ( bsize == bsize_min ) {if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ;if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows && vt . part_variances -> none . variance < threshold ) {set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ;return 1 ;return 0 ;}else if ( bsize > bsize_min ) {if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none . variance < threshold && vt . part_variances -> vert [ 1 ] . variance < threshold ) {set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ;set_block_size ( cpi , tile , mi_row , mi_col + block_width / 2 , subsize ) ;return 1 ;}if ( mi_col + block_width / 2 < cm -> mi_cols && vt . part_variances -> horz [ 0 ] . variance < threshold ) {set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ;return 1 ;if ( mi_row + block_height / 2 < cm -> mi_rows ) {set_block_size ( cpi , x , xd , mi_row , mi_col , subsize ) ;set_block_size ( cpi , x , xd , mi_row + block_height / 2 , mi_col , subsize ) ;return 1 ;}}return 0 ;}}return 0 ;",4254
182,"static void perf_event_output ( struct perf_event * event , int nmi ,  struct perf_sample_data * data , struct pt_regs * regs ) {if ( perf_output_begin ( & handle , event , header . size , nmi , 1 ) )  goto exit ;","static void perf_event_output ( struct perf_event * event , struct perf_sample_data * data , struct pt_regs * regs ) {if ( perf_output_begin ( & handle , event , header . size , 1 ) ) goto exit ;",4255
183,"
","if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) {f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ;return 1 ;}",4256
184,"if ( sanity_check_area_boundary ( sbi , bh ) )  return 1 ;","if ( sanity_check_area_boundary ( sbi , bh ) ) return 1 ;",4256
185,ret = fscrypt_get_crypt_info ( dir ) ;if ( ret && ret != - EOPNOTSUPP ) return ret ;,ret = fscrypt_get_encryption_info ( dir ) ;if ( ret && ret != - EOPNOTSUPP ) return ret ;,4257
186,"opts -> max_size = 0 ;if ( ! ( tvp = jas_tvparser_create ( optstr ? optstr : """" ) ) ) {case OPT_MAXSIZE :  opts -> max_size = atoi ( jas_tvparser_getval ( tvp ) ) ;break ;","opts -> max_samples = 64 * JAS_MEBI ;if ( ! ( tvp = jas_tvparser_create ( optstr ? optstr : """" ) ) ) {case OPT_MAXSIZE : opts -> max_samples = atoi ( jas_tvparser_getval ( tvp ) ) ;break ;",4258
187,"# ifdef _WITH_VRRP_  fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\\","fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\\# ifdef _WITH_VRRP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\\",4259
188,},"if ( cpu_has_secondary_exec_ctrls ( ) ) {if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ;else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ;}if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;}",4260
189,"const VP9_CONFIG * oxcf = & cpi -> oxcf ;const RATE_CONTROL * rc = & cpi -> rc ;const int64_t diff = oxcf -> optimal_buffer_level - rc -> buffer_level ;const int64_t one_pct_bits = 1 + oxcf -> optimal_buffer_level / 100 ;int min_frame_target = MAX ( rc -> av_per_frame_bandwidth >> 4 ,  FRAME_OVERHEAD_BITS ) ;int target = rc -> av_per_frame_bandwidth ;if ( svc -> number_temporal_layers > 1 &&  oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) {int current_temporal_layer = svc -> temporal_layer_id ;const LAYER_CONTEXT * lc = & svc -> layer_context [ current_temporal_layer ] ;target = lc -> avg_frame_size ;return MAX ( min_frame_target , target ) ;}","const VP9EncoderConfig * oxcf = & cpi -> oxcf ;const RATE_CONTROL * rc = & cpi -> rc ;const int64_t diff = rc -> optimal_buffer_level - rc -> buffer_level ;const int64_t one_pct_bits = 1 + rc -> optimal_buffer_level / 100 ;int min_frame_target = MAX ( rc -> avg_frame_bandwidth >> 4 , FRAME_OVERHEAD_BITS ) ;int target ;if ( oxcf -> gf_cbr_boost_pct ) {const int af_ratio_pct = oxcf -> gf_cbr_boost_pct + 100 ;target = cpi -> refresh_golden_frame ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio_pct ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) : ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * 100 ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) ;}else {target = rc -> avg_frame_bandwidth ;}if ( is_one_pass_cbr_svc ( cpi ) ) {int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ;const LAYER_CONTEXT * lc = & svc -> layer_context [ current_temporal_layer ] ;target = lc -> avg_frame_size ;if ( oxcf -> rc_max_inter_bitrate_pct ) {const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ;target = MIN ( target , max_rate ) ;}return MAX ( min_frame_target , target ) ;}",4261
190,". dump = link -> dump ,  . done = link -> done , }",". start = link -> start , . dump = link -> dump , . done = link -> done , }",4262
191,if ( ! ( mask & KADM5_ATTRIBUTES ) ||  ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;,if ( password == NULL || ! ( mask & KADM5_ATTRIBUTES ) || ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ;,4263
192,struct address_space * mapping = page -> mapping ;if ( mapping ) {,struct address_space * mapping = page_file_mapping ( page ) ;if ( mapping ) {,4264
193,return ( 0 ) ;,if ( rdata -> rbuf . buf != NULL ) return ( 0 ) ;,4265
194,OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( 0 ) ;}OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( 0 ) ;},OPENSSL_free ( rdata -> rbuf . buf ) ;OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( - 1 ) ;}if ( rdata -> rbuf . buf != NULL ) OPENSSL_free ( rdata -> rbuf . buf ) ;OPENSSL_free ( rdata ) ;pitem_free ( item ) ;return ( - 1 ) ;},4265
195,"rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ;","rc = fsmMkfile ( fi , fpath , files , psm , 0 , nodigest , & setmeta , & firsthardlink ) ;",4266
196,"rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ;firsthardlink = - 1 ;","rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ;firsthardlink = - 1 ;",4266
197,"err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ;if ( err ) return err ;if ( is_pointer_value ( env , insn -> dst_reg ) ) {verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\\return - EACCES ;}err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;}else if ( opcode == BPF_MOV ) {if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( insn -> imm != 0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;}err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ;if ( err ) return err ;if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) {verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\\return - EINVAL ;err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ;if ( err ) return err ;if ( BPF_SRC ( insn -> code ) == BPF_X ) {if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ;regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ;}else {if ( is_pointer_value ( env , insn -> src_reg ) ) {verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\\return - EACCES ;}mark_reg_unknown ( env , regs , insn -> dst_reg ) ;regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ;__update_reg_bounds ( & regs [ insn -> dst_reg ] ) ;}__mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ;}","err = check_reg_arg ( env , insn -> dst_reg , insn -> imm ) ;__mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ;if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) {__mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ;}",4267
198,if ( ! * ptrptr && ! ( nmemb && size ) )  return AVERROR ( ENOMEM ) ;,if ( ! * ptrptr && nmemb && size ) ) return AVERROR ( ENOMEM ) ;,4268
199,"rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\if ( msg_flags & MSG_OOB ) goto out ;","rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\\msg -> msg_namelen = 0 ;if ( msg_flags & MSG_OOB ) goto out ;",4269
200,"
",msg -> msg_namelen = sizeof ( * sin ) ;,4269
201,}break ;,}break ;,4269
202,"
",rcu_read_lock ( ) ;,4270
203,"opt = flowlabel ? flowlabel -> opt : np -> opt ;final_p = fl6_update_dst ( & fl6 , opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","opt = flowlabel ? flowlabel -> opt : rcu_dereference ( np -> opt ) ;final_p = fl6_update_dst ( & fl6 , opt , & final ) ;rcu_read_unlock ( ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",4270
204,"u8 obuf [ ] = {0xde , 0 };info ( ""%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d"" , __func__ , i , state -> initialized ) ;state -> initialized = 1 ;return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ;}return 0 ;","int ret = 0 ;info ( ""%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d"" , __func__ , i , state -> initialized ) ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xde ;state -> data [ 1 ] = 0 ;state -> initialized = 1 ;ret = dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ;mutex_unlock ( & d -> data_mutex ) ;}return ret ;",4271
205,"const char * arch = info -> arch ;ut16 bits = info -> bits ;if ( info -> cpu && * info -> cpu ) {r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ;}r_core_bin_set_cur ( r , binfile ) ;return true ;","char * arch = info -> arch ;ut16 bits = info -> bits ;if ( cpu && * info -> cpu ) {r_config_set ( r -> config , ""anal.cpu"" , cpu ) ;}r_core_bin_set_cur ( r , binfile ) ;free ( cpu ) ;free ( arch ) ;return true ;",4272
206,"int ip_options_get ( struct net * net , struct ip_options * * optp ,  unsigned char * data , int optlen ) {struct ip_options * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen )  memcpy ( opt -> __data , data , optlen ) ;return ip_options_get_finish ( net , optp , opt , optlen ) ;","int ip_options_get ( struct net * net , struct ip_options_rcu * * optp , unsigned char * data , int optlen ) {struct ip_options_rcu * opt = ip_options_get_alloc ( optlen ) ;if ( ! opt ) return - ENOMEM ;if ( optlen ) memcpy ( opt -> opt . __data , data , optlen ) ;return ip_options_get_finish ( net , optp , opt , optlen ) ;",4273
207,"change = ue -> tlv_data_size != size ;if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ;kfree ( ue -> tlv_data ) ;ue -> tlv_data = new_data ;ue -> tlv_data_size = size ;}else {if ( ! ue -> tlv_data_size || ! ue -> tlv_data )  return - ENXIO ;if ( size < ue -> tlv_data_size )   return - ENOSPC ;if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) )   return - EFAULT ;}return change ;","mutex_lock ( & ue -> card -> user_ctl_lock ) ;change = ue -> tlv_data_size != size ;if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ;kfree ( ue -> tlv_data ) {ret = - ENXIO ;goto err_unlock ;}if ( size < ue -> tlv_data_size ) return - ENOSPC ;goto err_unlock ;}if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) return - EFAULT ;err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ;if ( ret ) return ret ;}return change ;",4274
208,"if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ;if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ;map -> m_flags &= ~ EXT4_MAP_FLAGS ;down_write ( & EXT4_I ( inode ) -> i_data_sem ) ;if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) {retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ;}else {retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ;if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) {ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ;}if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ;}if ( retval > 0 ) {unsigned int status ;if ( unlikely ( retval != map -> m_len ) ) {ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ;WARN_ON ( 1 ) ;if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) {ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ;if ( ret ) {retval = ret ;goto out_sem ;}}if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) {if ( ext4_es_is_written ( & es ) ) goto out_sem ;}status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ;if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ;ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ;if ( ret < 0 ) {retval = ret ;goto out_sem ;}}out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ;if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) {ret = check_block_validity ( inode , map ) ;if ( ret != 0 ) return ret ;}return retval ;","if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) {ret = ext4_jbd2_file_inode ( handle , inode ) ;if ( ret ) return ret ;return retval ;",4275
209,cifs_small_buf_release ( req ) ;rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ;,rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ;,4276
210,* nbytes = le32_to_cpu ( rsp -> DataLength ) ;if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) {,cifs_small_buf_release ( req ) ;* nbytes = le32_to_cpu ( rsp -> DataLength ) ;if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) {,4276
211,"struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ;struct netdev_notifier_info info ;netdev_notifier_info_init ( & info , dev ) ;return masq_device_event ( this , event , & info ) ;","struct in_device * idev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev ;struct netdev_notifier_info info ;if ( idev -> dead ) return NOTIFY_DONE ;netdev_notifier_info_init ( & info , idev -> dev ) ;return masq_device_event ( this , event , & info ) ;",4277
212,v |= ( c << 24 ) ;if ( -- n <= 0 ) {,"v |= ( JAS_CAST ( uint_fast32_t , c ) << 24 ) ;if ( -- n <= 0 ) {",4278
213,"sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ;sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ;","sctp_add_cmd_sf ( commands , SCTP_CMD_SET_ASOC , SCTP_ASOC ( new_asoc ) ) ;sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ;",4279
214,"FILE * file ;file = fopen ( stats_file , ""w"" ) ;if ( ! file ) {for ( e = LIST_HEAD ( l ) ;e ;ELEMENT_NEXT ( e ) ) {vrrp = ELEMENT_DATA ( e ) ;","FILE * file = fopen_safe ( stats_file , ""w"" ) ;if ( ! file ) {if ( ! file ) {log_message ( LOG_INFO , ""Can\\\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ;return ;}LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) {",4280
215,"int  run_cmd ( int fd , ... )  {","int run_cmd ( int fd , const char * cmd , const char * args_extra ) {",4281
216,"char cmd [ 512 ] ;term_remove ( STI ) ;dup2 ( fd , STI ) ;dup2 ( fd , STO ) ;{char * c , * ce ;const char * s ;int n ;va_list vls ;strcpy ( cmd , EXEC ) ;c = & cmd [ sizeof ( EXEC ) - 1 ] ;","int argc ;char * argv [ RUNCMD_ARGS_MAX + 1 ] ;int r ;term_remove ( STI ) ;argc = 0 ;r = split_quoted ( cmd , EXEC ) ;c = & cmd [ sizeof ( EXEC ) - 1 ] ;",4281
217,"fd_printf ( STDERR_FILENO , ""%s\\\establish_child_signal_handlers ( ) ;sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ;execl ( ""/bin/sh"" , ""sh"" , ""-c"" , cmd , NULL ) ;exit ( 42 ) ;}","fd_printf ( STDERR_FILENO , ""exec:<S2SV_blank>%s\\\exit ( 42 ) ;}",4281
218,"static void  build_config ( char * prefix , struct server * server )  {int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;path = ss_malloc ( path_size ) ;snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ;FILE * f = fopen ( path , ""w+"" ) ;if ( f == NULL ) {if ( verbose ) {LOGE ( ""unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file"" ) ;}ss_free ( path ) ;return ;}fprintf ( f , ""{\\\fprintf ( f , ""\\\\""server_port\\\\"":%d,\\\fprintf ( f , ""\\\\""password\\\\"":\\\\""%s\\\\"""" , server -> password ) ;if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\\\if ( server -> mode ) fprintf ( f , "",\\\if ( server -> method ) fprintf ( f , "",\\\if ( server -> plugin ) fprintf ( f , "",\\\","static void build_config ( char * prefix , struct manager_ctx * manager , struct server * server ) {int path_size = strlen ( prefix ) + strlen ( server -> plugin ) fprintf ( f , "",\\\",4282
219,"if ( ! dir_emit_dots ( file , ctx ) )  return 0 ;pos = 2 ;","if ( ! dir_emit_dots ( file , ctx ) ) goto out ;pos = 2 ;",4283
220,sysctl_head_finish ( head ) ;return 0 ;,out : sysctl_head_finish ( head ) ;return 0 ;,4283
221,"char * dest , * src ;char separator = \'\\\\0\' ;dest = src = a -> name ;if ( * src == \'\\\\0\' ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC ,  ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ;return ( ARCHIVE_FAILED ) ;}# if defined ( __CYGWIN__ )  cleanup_pathname_win ( a ) ;return ( ARCHIVE_FAILED ) ;}separator = * src ++ ;}for ( ;;) {if ( src [ 0 ] == \'\\\\0\' ) {break ;}else if ( src [ 0 ] == \'/\' ) {src ++ ;continue ;}else if ( src [ 0 ] == \'.\' ) {if ( src [ 1 ] == \'\\\\0\' ) {break ;}else if ( src [ 1 ] == \'/\' ) {src += 2 ;continue ;}else if ( src [ 1 ] == \'.\' ) {if ( src [ 2 ] == \'/\' || src [ 2 ] == \'\\\\0\' ) {if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) {archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\\\'..\\\'"" ) ;}}}if ( separator ) * dest ++ = \'/\' ;while ( * src != \'\\\\0\' && * src != \'/\' ) {* dest ++ = * src ++ ;}if ( * src == \'\\\\0\' ) break ;separator = * src ++ ;}if ( dest == a -> name ) {if ( separator ) * dest ++ = \'/\' ;else * dest ++ = \'.\' ;}* dest = \'\\\\0\' ;return ( ARCHIVE_OK ) ;","struct archive_string error_string ;int error_number ;int rc ;archive_string_init ( & error_string ) ;rc = cleanup_pathname_fsobj ( a -> name , & error_number , & error_string , a -> flags ) ;if ( rc != ARCHIVE_OK ) {archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ;}# if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ;archive_string_free ( & error_string ) ;return rc ;",4284
222,"ps_dec -> i1_prev_mb_qp_delta = 0 ;ps_dec -> i1_next_ctxt_idx = 0 ;ps_dec -> u4_nmb_deblk = 0 ;if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ;if ( ps_seq -> u1_mb_aff_flag == 1 ) {ps_dec -> u4_nmb_deblk = 0 ;if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ;}ps_dec -> u4_use_intrapred_line_copy = 0 ;if ( ps_seq -> u1_mb_aff_flag == 0 ) {ps_dec -> u4_use_intrapred_line_copy = 1 ;}ps_dec -> u4_app_disable_deblk_frm = 0 ;if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) {WORD32 degrade_pic ;ps_dec -> i4_degrade_pic_cnt ++ ;degrade_pic = 0 ;switch ( ps_dec -> i4_degrade_pics ) {case 4 : {degrade_pic = 1 ;break ;}case 3 : {if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ;break ;}case 2 : {if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ;break ;}case 1 : {if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) {degrade_pic = 1 ;}break ;}}if ( degrade_pic ) {if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ;if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) {if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ;if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ;}}else ps_dec -> i4_degrade_pic_cnt = 0 ;}{dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ;if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ;else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ;if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) {ps_err -> u1_cur_pic_type = PIC_TYPE_I ;ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ;}if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) {if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ;ps_err -> u1_err_flag = ACCEPT_ALL_PICS ;}}if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) {WORD32 j ;for ( j = 0 ;j < MAX_DISP_BUFS_NEW ;j ++ ) {ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ;}ps_dec -> u1_second_field = 0 ;ps_dec -> i4_cur_display_seq = 0 ;ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ;}ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ;if ( ret != OK ) return ret ;ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ;ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ;ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ;if ( ps_dec -> u1_separate_parse ) {UWORD16 pic_wd ;UWORD16 pic_ht ;UWORD32 num_mbs ;pic_wd = ps_dec -> u2_pic_wd ;pic_ht = ps_dec -> u2_pic_ht ;num_mbs = ( pic_wd * pic_ht ) >> 8 ;if ( ps_dec -> pu1_dec_mb_map ) {memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ;}if ( ps_dec -> pu1_recon_mb_map ) {memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ;}if ( ps_dec -> pu2_slice_num_map ) {memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ;}}ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ;ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ;ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ;ps_dec -> s_high_profile . u1_scaling_present = 0 ;ps_dec -> s_high_profile . u1_transform8x8_present = 0 ;if ( 1 == ps_dec -> u4_share_disp_buf ) {UWORD32 i ;for ( i = 0 ;i < MAX_DISP_BUFS_NEW ;i ++ ) {if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ;ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ;ps_dec -> u4_disp_buf_mapping [ i ] = 0 ;}}if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) {pic_buffer_t * ps_cur_pic ;WORD32 cur_pic_buf_id , cur_mv_buf_id ;col_mv_buf_t * ps_col_mv ;while ( 1 ) {ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ;if ( ps_cur_pic == NULL ) {ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ;return ERROR_UNAVAIL_PICBUF_T ;}if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) {break ;}}ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ;if ( ps_col_mv == NULL ) {ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ;return ERROR_UNAVAIL_MVBUF_T ;}ps_dec -> ps_cur_pic = ps_cur_pic ;ps_dec -> u1_pic_buf_id = cur_pic_buf_id ;ps_cur_pic -> u4_ts = ps_dec -> u4_ts ;ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ;ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ;ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ;ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ;ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ;if ( ps_dec -> u1_first_slice_in_stream ) {ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ;* ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ;}if ( ! ps_dec -> ps_cur_pic ) {WORD32 j ;H264_DEC_DEBUG_PRINT ( ""-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\\for ( j = 0 ;j < MAX_DISP_BUFS_NEW ;j ++ ) {ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ;ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ;}ps_dec -> i4_cur_display_seq = 0 ;ps_dec -> i4_prev_max_display_seq = 0 ;ps_dec -> i4_max_poc = 0 ;ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ;if ( ps_cur_pic == NULL ) {ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ;return ERROR_UNAVAIL_PICBUF_T ;}ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ;if ( ps_col_mv == NULL ) {ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ;return ERROR_UNAVAIL_MVBUF_T ;}ps_dec -> ps_cur_pic = ps_cur_pic ;ps_dec -> u1_pic_buf_id = cur_pic_buf_id ;ps_cur_pic -> u4_ts = ps_dec -> u4_ts ;ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ;ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ;ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ;ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ;ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ;ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ;}ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ;ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ;H264_DEC_DEBUG_PRINT ( ""got<S2SV_blank>a<S2SV_blank>buffer\\\}else {H264_DEC_DEBUG_PRINT ( ""did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\\}ps_dec -> u4_pic_buf_got = 1 ;ps_dec -> ps_cur_pic -> i4_poc = i4_poc ;ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ;ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ;ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ;ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ;ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ;ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ;if ( u1_field_pic_flag && u1_bottom_field_flag ) {WORD32 i4_temp_poc ;WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ;ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ;ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ;ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ;ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ;ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ;ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ;i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ;i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ;i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ;ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ;}ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ;ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ;ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ;ps_dec -> ps_cur_mb_row += 2 ;ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row ;ps_dec -> ps_top_mb_row += ( ( ps_dec -> u2_frm_wd_in_mbs + 2 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ;ps_dec -> ps_top_mb_row += 2 ;ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ;ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ;ps_dec -> u1_mv_top_p = 0 ;ps_dec -> u1_mb_idx = 0 ;ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ;ps_dec -> u2_total_mbs_coded = 0 ;ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ;ps_dec -> u4_pred_info_idx = 0 ;ps_dec -> u4_pred_info_pkd_idx = 0 ;ps_dec -> u4_dma_buf_idx = 0 ;ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ;ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ;ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ;ps_dec -> ps_part = ps_dec -> ps_parse_part_params ;ps_dec -> i2_prev_slice_mbx = - 1 ;ps_dec -> i2_prev_slice_mby = 0 ;ps_dec -> u2_mv_2mb [ 0 ] = 0 ;ps_dec -> u2_mv_2mb [ 1 ] = 0 ;ps_dec -> u1_last_pic_not_decoded = 0 ;ps_dec -> u2_cur_slice_num = 0 ;ps_dec -> u2_cur_slice_num_dec_thread = 0 ;",ps_dec -> u2_cur_slice_num_dec_thread = 0 ;,4285
223,"struct mb_cache *   ext4_xattr_create_cache ( char * name )  {return mb_cache_create ( name , HASH_BUCKET_BITS ) ;}",struct mb2_cache * ext4_xattr_create_cache ( char * name ) {return mb2_cache_create ( HASH_BUCKET_BITS ) ;},4286
224,"DEFiRet ;CHKiRet ( batchInit ( & snglRuleBatch , pBatch -> nElem ) ) ;snglRuleBatch . pbShutdownImmediate = pBatch -> pbShutdownImmediate ;while ( 1 ) {for ( iStart = 0 ;if ( iStart == pBatch -> nElem ) FINALIZE ;batchCopyElem ( & ( snglRuleBatch . pElem [ iNew ++ ] ) , & ( pBatch -> pElem [ i ] ) ) ;}","int bHaveUnprocessed ;DEFiRet ;do {bHaveUnprocessed = 0 ;for ( iStart = 0 ;if ( iStart == pBatch -> nElem ) break ;CHKiRet ( batchInit ( & snglRuleBatch , pBatch -> nElem ) ) ;snglRuleBatch . pbShutdownImmediate = pBatch -> pbShutdownImmediate ;snglRuleBatch . pElem [ iNew ] . pUsrp = pBatch -> pElem [ i ] . pUsrp ;snglRuleBatch . pElem [ iNew ] . state = pBatch -> pElem [ i ] . state ;++ iNew ;else {bHaveUnprocessed = 1 ;}}while ( bHaveUnprocessed == 1 ) ;",4287
225,"case kEmptyStream :  h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles ,  sizeof ( * h -> emptyStreamBools ) ) ;","case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ;h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , sizeof ( * h -> emptyStreamBools ) ) ;",4288
226,"h -> emptyFileBools = calloc ( empty_streams ,  sizeof ( * h -> emptyFileBools ) ) ;","if ( h -> emptyFileBools != NULL ) return ( - 1 ) ;h -> emptyFileBools = calloc ( empty_streams , sizeof ( * h -> emptyFileBools ) ) ;",4288
227,"h -> antiBools = calloc ( empty_streams ,  sizeof ( * h -> antiBools ) ) ;","if ( h -> antiBools != NULL ) return ( - 1 ) ;h -> antiBools = calloc ( empty_streams , sizeof ( * h -> antiBools ) ) ;",4288
228,if ( ( ll & 1 ) || ll < zip -> numFiles * 4 )  return ( - 1 ) ;,if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) return ( - 1 ) ;if ( zip -> entry_names != NULL ) return ( - 1 ) ;,4288
229,"h -> attrBools = calloc ( ( size_t ) zip -> numFiles ,  sizeof ( * h -> attrBools ) ) ;","if ( h -> attrBools != NULL ) return ( - 1 ) ;h -> attrBools = calloc ( ( size_t ) zip -> numFiles , sizeof ( * h -> attrBools ) ) ;",4288
230,"char buf [ L_BUF_SIZE ] ;char * rootname , * title , * xlabel , * ylabel , * ignores ;ret = fscanf ( fp , ""Gplot<S2SV_blank>Version<S2SV_blank>%d\\\if ( ret != 1 ) {fclose ( fp ) ;return ( GPLOT * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>gplot<S2SV_blank>file"" , procName , NULL ) ;}if ( version != GPLOT_VERSION_NUMBER ) {fclose ( fp ) ;return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>gplot<S2SV_blank>version"" , procName , NULL ) ;}ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\\rootname = stringNew ( buf ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;title = stringNew ( buf + 7 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;xlabel = stringNew ( buf + 14 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;ylabel = stringNew ( buf + 14 ) ;","char buf [ L_BUFSIZE ] ;char * rootname , * title , * xlabel , * ylabel , * ignores ;ret = fscanf ( fp , ""Rootname:<S2SV_blank>%511s\\\rootname = stringNew ( buf ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;title = stringNew ( buf + 7 ) ;ignores = fgets ( buf , L_BUF_SIZE , fp ) ;xlabel = stringNew ( buf + 14 ) ;ignores = fgets ( buf , L_BUFSIZE , fp ) ;ylabel = stringNew ( buf + 14 ) ;",4289
231,"ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\\stringReplace ( & gplot -> cmdname , buf ) ;ignore = fscanf ( fp , ""\\\gplot -> cmddata = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> datanames = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plotdata = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plottitles = sarrayReadStream ( fp ) ;ignore = fscanf ( fp , ""\\\gplot -> plotstyles = numaReadStream ( fp ) ;ignore = fscanf ( fp , ""Number<S2SV_blank>of<S2SV_blank>plots:<S2SV_blank>%d\\\ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\\stringReplace ( & gplot -> outname , buf ) ;","ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\\stringReplace ( & gplot -> cmdname , buf ) ;ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\\stringReplace ( & gplot -> outname , buf ) ;",4289
232,"ngx_uint_t n , sec , min , hour , mday , mon , year , wday , days , leap ;n = ( ngx_uint_t ) t ;days = n / 86400 ;wday = ( 4 + days ) % 7 ;n %= 86400 ;hour = n / 3600 ;n %= 3600 ;min = n / 60 ;sec = n % 60 ;days = days - ( 31 + 28 ) + 719527 ;","ngx_uint_t sec , min , hour , mday , mon , year , wday , days , leap ;if ( t < 0 ) {t = 0 ;}days = t / 86400 ;sec = t % 86400 ;wday = ( 4 + days ) % 7 ;hour = sec / 3600 ;n %= 3600 ;min = n / 60 ;sec %= 60 ;days = days - ( 31 + 28 ) + 719527 ;",4290
233,"if ( tpgt > TL_TPGS_PER_HBA ) {printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\\","if ( tpgt >= TL_TPGS_PER_HBA ) {printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\\",4291
234,"int len ;if ( config . eval_ldb ) return ;if ( config . hostsocket != NULL )   len = snprintf ( config . prompt , sizeof ( config . prompt ) , ""redis<S2SV_blank>%s"" ,  config . hostsocket ) ;else len = anetFormatAddr ( config . prompt , sizeof ( config . prompt ) , config . hostip , config . hostport ) ;if ( config . dbnum != 0 ) len += snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , ""[%d]"" , config . dbnum ) ;snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , ""><S2SV_blank>"" ) ;","if ( config . eval_ldb ) return ;sds prompt = sdsempty ( ) ;if ( config . hostsocket != NULL ) {prompt = sdscatfmt ( prompt , ""redis<S2SV_blank>%s"" , config . hostsocket ) ;}else {char addr [ 256 ] ;anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ;prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ;}if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , ""[%i]"" , config . dbnum ) ;prompt = sdscatlen ( prompt , ""><S2SV_blank>"" , 2 ) ;snprintf ( config . prompt , sizeof ( config . prompt ) , ""%s"" , prompt ) ;sdsfree ( prompt ) ;",4292
235,total = le32_to_cpu ( raw_super -> segment_count ) ;fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ;,"unsigned int main_segs , blocks_per_seg ;int i ;total = le32_to_cpu ( raw_super -> segment_count ) ;fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ;",4293
236,"if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ;","main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ;blocks_per_seg = sbi -> blocks_per_seg ;for ( i = 0 ;i < NR_CURSEG_NODE_TYPE ;i ++ ) {if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ;}for ( i = 0 ;i < NR_CURSEG_DATA_TYPE ;i ++ ) {if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ;}if ( unlikely ( f2fs_cp_error ( sbi ) ) ) {f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ;",4293
237,__be16 type ;off = skb_gro_offset ( skb ) ;,__be16 type ;if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ;NAPI_GRO_CB ( skb ) -> encap_mark = 1 ;off = skb_gro_offset ( skb ) ;,4294
238,". dump = link -> dump ,  . done = link -> done , }",". start = link -> start , . dump = link -> dump , . done = link -> done , }",4295
239,"rcu_read_lock ( ) ;dev = dev_get_by_name_rcu ( net , name ) ;rcu_read_unlock ( ) ;if ( ! dev && capable ( CAP_NET_ADMIN ) )   request_module ( ""%s"" , name ) ;}","int no_module ;rcu_read_lock ( ) ;no_module = ! dev ;if ( no_module && capable ( CAP_NET_ADMIN ) ) no_module = request_module ( ""netdev-%s"" , name ) ) pr_err ( ""Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>"" ""with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>"" ""instead\\\}}",4296
240,cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;,cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;,4297
241,cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;break ;,cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;break ;,4297
242,"
",const uid_t dduid = g_settings_privatereports ? 0 : fsuid ;,4298
243,"sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ;proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ;uid_t fsuid = uid ;uid_t tmp_fsuid = get_fsuid ( ) ;int suid_policy = dump_suid_policy ( ) ;if ( tmp_fsuid != uid ) {fsuid = 0 ;if ( suid_policy == DUMP_SUID_UNSAFE ) fsuid = tmp_fsuid ;else {g_user_core_flags = O_EXCL ;g_need_nonrelative = 1 ;}}if ( setting_MakeCompatCore && ulimit_c != 0 )  user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ;if ( executable == NULL ) {error_msg ( ""Can\\\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ;goto create_user_core ;}const char * signame = NULL ;switch ( signal_no ) {case SIGILL : signame = ""ILL"" ;break ;case SIGFPE : signame = ""FPE"" ;break ;case SIGSEGV : signame = ""SEGV"" ;break ;case SIGBUS : signame = ""BUS"" ;break ;case SIGABRT : signame = ""ABRT"" ;break ;case SIGTRAP : signame = ""TRAP"" ;break ;default : goto create_user_core ;}if ( ! daemon_is_ok ( ) ) {log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'core\\\'"" ) ;goto create_user_core ;}if ( g_settings_nMaxCrashReportsSize > 0 ) {if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ;}snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ;if ( check_recent_crash_file ( path , executable ) ) {goto create_user_core ;}const char * last_slash = strrchr ( executable , \'/\' ) ;if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) {if ( snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\\\'%s\\\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path"" , path ) ;int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) {unlink ( path ) ;error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\\\'%s\\\'"" , path ) ;}log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ;if ( proc_cwd != NULL ) closedir ( proc_cwd ) ;return 0 ;}unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ;if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) {goto create_user_core ;}dd = dd_create_skeleton ( path , fsuid , DEFAULT_DUMP_DIR_MODE , 0 ) ;if ( dd ) {","sprintf ( path , dduid , DEFAULT_DUMP_DIR_MODE , 0 ) ;if ( dd ) {",4298
244,"logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ;image = AcquireImage ( image_info ) ;","logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ;quantum_info = ( QuantumInfo * ) NULL ;image = AcquireImage ( image_info ) ;",4299
245,"InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ;","if ( quantum_info != ( QuantumInfo * ) NULL ) InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ;",4299
246,quantum_info = DestroyQuantumInfo ( quantum_info ) ;END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ;,quantum_info = DestroyQuantumInfo ( quantum_info ) ;END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ;,4299
247,"static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags )  {switch ( open_flags ) {case FMODE_WRITE : state -> n_wronly ++ ;nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ;}","static void update_open_stateflags ( struct nfs4_state * state , fmode_t fmode ) {switch ( open_flags ) {case FMODE_WRITE : state -> n_wronly ++ ;nfs4_state_set_mode_locked ( state , state -> state | fmode ) ;}",4300
248,"static krb5_error_code get_tag ( const uint8_t * asn1 , size_t len , taginfo * tag_out , const uint8_t * * contents_out , size_t * clen_out ,  const uint8_t * * remainder_out , size_t * rlen_out )  {","static krb5_error_code get_tag ( const uint8_t * asn1 , size_t len , taginfo * tag_out , const uint8_t * * contents_out , size_t * clen_out , const uint8_t * * remainder_out , size_t * rlen_out , int recursion ) {",4301
249,"p = asn1 ;while ( ! ( len >= 2 && p [ 0 ] == 0 && p [ 1 ] == 0 ) ) {ret = get_tag ( p , len , & t , & c , & clen , & p , & len ) ;if ( ret ) return ret ;","if ( recursion >= 32 ) return ASN1_OVERFLOW ;p = asn1 ;while ( ! ( len >= 2 && p [ 0 ] == 0 && p [ 1 ] == 0 ) ) {ret = get_tag ( p , len , & t , & c , & clen , & p , & len , recursion + 1 ) ;if ( ret ) return ret ;",4301
250,"# define ThrowCUTReaderException ( severity , tag ) {}Image * image , * palette ;","# define ThrowCUTReaderException ( severity , tag ) \\\\\\\\\\Image * image , * palette ;",4302
251,"
","( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;",4302
252,"offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {","offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {",4302
253,if ( code == gcode )  return & wordlist [ key ] ;,if ( code == gcode && wordlist [ key ] . index >= 0 ) return & wordlist [ key ] ;,4303
254,"static void  _copy_from_pages ( char * p , struct page * * pages , size_t pgbase , size_t len ) {","void _copy_from_pages ( char * p , struct page * * pages , size_t pgbase , size_t len ) {",4304
255,"int copied , err ;struct sockaddr_ll * sll ;","int copied , err ;",4305
256,"sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;if ( sock -> type == SOCK_PACKET )  msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;else  msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name )  memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa ,  msg -> msg_namelen ) ;if ( pkt_sk ( sk ) -> auxdata ) {","copied = skb -> len ;if ( copied > len ) {if ( msg -> msg_name ) {if ( sock -> type == SOCK_PACKET ) {msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ;}else {struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ;msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ;}memcpy ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ;}if ( pkt_sk ( sk ) -> auxdata ) {",4305
257,"if ( uid_eq ( uid , current_fsuid ( ) ) )  return true ;if ( gid_eq ( gid , current_fsgid ( ) ) )  return true ;","if ( uid_eq ( uid , file -> f_cred -> fsuid ) ) return true ;if ( gid_eq ( gid , file -> f_cred -> fsgid ) ) return true ;",4306
258,"char * ret ;ret = fgets ( ptr , PATH_MAX , VFile ) ;if ( ptr [ strlen ( ptr ) - 1 ] == '\\\return ret ;","char * ret ;size_t len ;ret = fgets ( ptr , PATH_MAX , VFile ) ;len = strlen ( ptr ) ;if ( len > 0 && ptr [ len - 1 ] == '\\\return ret ;",4307
259,fid -> udf . generation = inode -> i_generation ;if ( parent ) {,fid -> udf . parent_partref = 0 ;fid -> udf . generation = inode -> i_generation ;if ( parent ) {,4308
260,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits )  # define GIFOutputCode ( code ) {,# define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) # define GIFOutputCode ( code ) \\\\\,4309
261,}Quantum index ;,\\\\\Quantum index ;,4309
262,"
",next_pixel = MagickFalse ;displacement = 1 ;,4309
263,"index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;p += GetPixelChannels ( image ) ;next_pixel = MagickFalse ;displacement = 1 ;","index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ;p += GetPixelChannels ( image ) ;if ( k < 0 ) continue ;",4309
264,"SEPARATE_ZVAL ( ( var ) ) ;convert_to_long ( * var ) ;points [ i ] . x = Z_LVAL_PP ( var ) ;}SEPARATE_ZVAL ( var ) ;convert_to_long ( * var ) ;points [ i ] . y = Z_LVAL_PP ( var ) ;}if ( filled ) {gdImageFilledPolygon ( im , points , npoints , col ) ;","if ( Z_TYPE_PP ( var ) != IS_LONG ) {zval lval ;lval = * * var ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;points [ i ] . x = Z_LVAL ( lval ) ;}else {points [ i ] . x = Z_LVAL_PP ( var ) ;}}if ( Z_TYPE_PP ( var ) != IS_LONG ) {zval lval ;lval = * * var ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;points [ i ] . y = Z_LVAL ( lval ) ;}else {points [ i ] . y = Z_LVAL_PP ( var ) ;}}if ( filled ) {gdImageFilledPolygon ( im , points , npoints , col ) ;",4310
265,"gdImageGifCtx ( im , out ) ;rv = gdDPExtractData ( out , size ) ;out -> gd_free ( out ) ;","if ( ! _gdImageGifCtx ( im , out ) ) {rv = gdDPExtractData ( out , size ) ;}else {rv = NULL ;}out -> gd_free ( out ) ;",4311
266,"static void decode_mb_mode_mvs ( VP8D_COMP * pbi , MODE_INFO * mi , MB_MODE_INFO * mbmi )  {if ( pbi -> mb . update_mb_segmentation_map ) read_mb_features ( & pbi -> mbc [ 8 ] , & mi -> mbmi , & pbi -> mb ) ;","static void decode_mb_mode_mvs ( VP8D_COMP * pbi , MODE_INFO * mi , MB_MODE_INFO * mbmi ) {( void ) mbmi ;if ( pbi -> mb . update_mb_segmentation_map ) read_mb_features ( & pbi -> mbc [ 8 ] , & mi -> mbmi , & pbi -> mb ) ;",4312
267,"static inline bool unconditional ( const struct ipt_ip * ip )  {return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ;# undef FWINV }","static inline bool unconditional ( const struct ipt_entry * e ) {return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> ip , & uncond , sizeof ( uncond ) ) == 0 ;# undef FWINV }",4313
268,"err = bnep_add_connection ( & ca , nsock ) ;if ( ! err ) {","ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;err = bnep_add_connection ( & ca , nsock ) ;if ( ! err ) {",4314
269,"vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ;for ( mb_row = 0 ;","memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ;for ( mb_row = 0 ;",4315
270,const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ;struct search_domain * dom ;for ( dom = state -> head ;,char need_to_append_dot ;struct search_domain * dom ;if ( ! base_len ) return NULL ;need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ;for ( dom = state -> head ;,4316
271,goto chpwfail ;},goto bailout ;},4317
272,goto chpwfail ;}goto chpwfail ;}goto chpwfail ;},goto bailout ;}goto bailout ;}goto bailout ;},4317
273,if ( iter > CIPSO_V4_TAG_MAXCNT )  return - EINVAL ;if ( iter < CIPSO_V4_TAG_MAXCNT )   doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ;return 0 ;,if ( iter >= CIPSO_V4_TAG_MAXCNT ) return - EINVAL ;while ( iter < CIPSO_V4_TAG_MAXCNT ) doi_def -> tags [ iter ++ ] = CIPSO_V4_TAG_INVALID ;return 0 ;,4318
274,"if ( ! osStrcmp ( path , ""."" ) )  ftpClientFormatCommand ( context , ""LIST"" , NULL ) ;else   ftpClientFormatCommand ( context , ""LIST"" , path ) ;if ( ! error ) {","if ( ! osStrcmp ( path , ""."" ) ) {ftpClientFormatCommand ( context , ""LIST"" , NULL ) ;}else {ftpClientFormatCommand ( context , ""LIST"" , path ) ;}if ( ! error ) {",4319
275,"if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) {vfy |= RPMVERIFY_LSTATFAIL ;goto exit ;","if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) ) {struct stat dsb ;if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) {uid_t fuid ;if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) {sb = dsb ;}}",4320
276,"req -> started = false ;list_del ( & req -> list ) ;req -> remaining = 0 ;if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ;if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ;req -> trb = NULL ;trace_dwc3_gadget_giveback ( req ) ;usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ;spin_lock ( & dwc -> lock ) ;if ( dep -> number > 1 )  pm_runtime_put ( dwc -> dev ) ;","dwc3_gadget_del_and_unmap_request ( dep , req , status ) ;",4321
277,"ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;","jas_ulonglong tmp ;if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ;",4322
278,"if ( fop == NULL )  return - E_NOTHANDLED ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;","if ( fop == NULL ) return - E_NOTHANDLED ;if ( ninst == 0 ) return - E_INVALID ;fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;",4323
279,return new_ns ;},new_ns -> mounts = 0 ;new_ns -> pending_mounts = 0 ;return new_ns ;},4324
280,"# ifdef HAVE_OPENSSL  if ( opt_use_ssl ) {mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ;mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ;}# endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;","SSL_SET_OPTIONS ( & mysql ) ;if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;",4325
281,struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ;struct extent_tree * et ;struct extent_node * en ;struct extent_info ei ;if ( ! f2fs_may_extent_tree ( inode ) ) {if ( i_ext && i_ext -> len ) {i_ext -> len = 0 ;return true ;}return false ;}et = __grab_extent_tree ( inode ) ;if ( ! i_ext || ! i_ext -> len )  return false ;,"bool ret = __f2fs_init_extent_tree ( inode , i_ext ) ;if ( ! i_ext || ! i_ext -> len ) return false ;",4326
282,return false ;},return ret ;},4326
283,"size_t buf_size = 0 ;oe_errno = 0 ;if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_sendmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , flags ) != OE_OK ) {done :  if ( buf ) oe_free ( buf ) ;","size_t buf_size = 0 ;size_t data_size = 0 ;oe_errno = 0 ;if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_sendmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , flags ) != OE_OK ) {if ( ret > ( ssize_t ) data_size ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}done : if ( buf ) oe_free ( buf ) ;",4327
284,"static stmt_ty  ast_for_for_stmt ( struct compiling * c , const node * n , int is_async )   {asdl_seq * _target , * seq = NULL , * suite_seq ;","static stmt_ty ast_for_for_stmt ( struct compiling * c , const node * n0 , bool is_async ) {const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ;asdl_seq * _target , * seq = NULL , * suite_seq ;",4328
285,"if ( is_async ) return AsyncFor ( target , expression , suite_seq , seq ,  type_comment , LINENO ( n ) , n -> n_col_offset ,  c -> c_arena ) ;","if ( is_async ) return AsyncFor ( target , expression , suite_seq , seq , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , c -> c_arena ) ;",4328
286,while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) &&  ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error )  {,while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) {,4329
287,"if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox )  {","size_t len = 0 ;if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) {",4330
288,"snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>\\\\""%s\\\\"""" , subscribe ? """" : ""un"" , path ) ;if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\\","len = snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>"" , subscribe ? """" : ""un"" ) ;imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true ) ;if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\\",4330
289,dsize += svbranch . len ;},dsize += svbranch . len + 1 ;},4331
290,icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ;,"icon_file . directory [ i ] . size ;if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) = ReadBlobLSBLong ( image ) ;",4332
291,"length = icon_file . directory [ i ] . size ;png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ;","length = icon_file . directory [ i ] . size ;png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ;",4332
292,if ( old -> curframe != cur -> curframe )  return false ;,if ( old -> curframe != cur -> curframe ) return false ;if ( old -> speculative && ! cur -> speculative ) return false ;,4333
293,"Image  * image ;MagickBooleanType status ;unsigned int bit , byte , bytes_per_line , height , length , padding ,  value ,  version , width ;","Image * image ;int c ;MagickBooleanType status ;unsigned int bit , byte , bytes_per_line , height , length , padding , version , width ;",4334
294,image -> colormap [ 0 ] . red = QuantumRange ;image -> colormap [ 0 ] . green = QuantumRange ;image -> colormap [ 0 ] . blue = QuantumRange ;image -> colormap [ 1 ] . red = ( Quantum ) 0 ;image -> colormap [ 1 ] . green = ( Quantum ) 0 ;image -> colormap [ 1 ] . blue = ( Quantum ) 0 ;if ( image_info -> ping != MagickFalse ) {,image -> colormap [ 0 ] . red = 0.0 ;image -> colormap [ 0 ] . green = 0.0 ;image -> colormap [ 0 ] . blue = 0.0 ;if ( image_info -> ping != MagickFalse ) {,4334
295,"value = XBMInteger ( image , hex_digits ) ;* p ++ = ( unsigned char ) value ;if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) )  * p ++ = ( unsigned char ) ( value >> 8 ) ;}value = XBMInteger ( image , hex_digits ) ;* p ++ = ( unsigned char ) value ;}","c = XBMInteger ( image , hex_digits ) ;if ( c < 0 ) break ;* p ++ = ( unsigned char ) c ;if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) * p ++ = ( unsigned char ) ( c >> 8 ) ;}c = XBMInteger ( image , hex_digits ) ;if ( c < 0 ) break ;* p ++ = ( unsigned char ) c ;}if ( EOFBlob ( image ) != MagickFalse ) {data = ( unsigned char * ) RelinquishMagickMemory ( data ) ;ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;}",4334
296,"if ( bit == 0 )  byte = ( size_t ) ( * p ++ ) ;SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ;","if ( bit == 0 ) byte = ( unsigned int ) ( * p ++ ) ;SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ;",4334
297,"rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ;}","rc = expandRegular ( fi , dest , psm , 1 , nodigest , 1 ) ;}",4335
298,"if ( ! rc )  rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ;}if ( ! rc )  rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ;* firsthardlink = - 1 ;","if ( ! rc ) rc = expandRegular ( fi , dest , psm , 1 , nodigest , 0 ) ;}if ( ! rc ) rc = expandRegular ( fi , dest , psm , 0 , nodigest , 0 ) ;* firsthardlink = - 1 ;",4335
299,"int rv ;clear_bit ( WDM_RESETTING , & desc -> flags ) ;","int rv ;clear_bit ( WDM_OVERFLOW , & desc -> flags ) ;clear_bit ( WDM_RESETTING , & desc -> flags ) ;",4336
300,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_association_put ( asoc ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\out_unlock : bh_unlock_sock ( sk ) ;sctp_association_put ( asoc ) ;",4337
301,"unsigned int len ;unsigned long start = 0 , off ;fbdev = to_au1100fb_device ( fbi ) ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {",fbdev = to_au1100fb_device ( fbi ) ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {,4338
302,"if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) {return - EAGAIN ;}return 0 ;","return vm_iomap_memory ( vma , fbdev -> fb_phys , fbdev -> fb_len ) ;",4338
303,"ND_PRINT ( ( ndo , ""\\\switch ( opt ) {case IPCPOPT_2ADDR : if ( len != 10 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ;return len ;}ND_TCHECK2 ( * ( p + 6 ) , 4 ) ;ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ;break ;case IPCPOPT_IPCOMP : if ( len < 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ;return 0 ;}ND_TCHECK2 ( * ( p + 2 ) , 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;",ND_TCHECK_16BITS ( p + 2 ) ;compproto = EXTRACT_16BITS ( p + 2 ) ;,4339
304,"enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ;status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ;if ( ( status & EIR_LINKIF ) != 0 )  {enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE ) ;interface -> nicEvent = TRUE ;if ( ( status & EIR_PKTIF ) != 0 )  {enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_PKTIE ) ;interface -> nicEvent = TRUE ;if ( ( status & ( EIR_TXIF | EIE_TXERIE ) ) != 0 )  {enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIE_TXERIE ) ;flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ;enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ;return flag ;","enc28j60ClearBit ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE ) ;status = enc28j60ReadReg ( interface , ENC28J60_EIR ) ;if ( ( status & ENC28J60_EIR_LINKIF ) != 0 ) {enc28j60ClearBit ( interface , ENC28J60_EIE , ENC28J60_EIE_LINKIE ) ;interface -> nicEvent = TRUE ;if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT ) != 0 ) {enc28j60ClearBit ( interface , ENC28J60_EIE , ENC28J60_EIE_PKTIE ) ;interface -> nicEvent = TRUE ;if ( ( status & ( ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE ) ) != 0 ) {enc28j60ClearBit ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE ) ;flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ;enc28j60SetBit ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE ) ;return flag ;",4340
305,"
",if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;,4341
306,"
",if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;,4341
307,"temp = ( struct sackhole * )  pool_get ( & sackhl_pool , PR_NOWAIT ) ;","temp = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ;",4341
308,"temp = ( struct sackhole * )  pool_get ( & sackhl_pool , PR_NOWAIT ) ;","temp = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ;",4341
309,"# if ENABLE_BGP_VNC  case BGP_ATTR_VNC : attrname = ""VNC"" ;","# if ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC : attrname = ""VNC"" ;",4342
310,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ;flags = FAULT_FLAG_ALLOW_RETRY ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ;flags = FAULT_FLAG_ALLOW_RETRY ;",4343
311,"perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 ,  regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 ,  regs , address ) ;","perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , regs , address ) ;perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , regs , address ) ;",4343
312,"static int t220_frontend_attach ( struct dvb_usb_adapter * d )  {u8 obuf [ 3 ] = {0xe , 0x87 , 0 };u8 ibuf [ ] = {0 };if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x86 ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 1 ] = 0x80 ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )  err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 50 ) ;obuf [ 0 ] = 0xe ;obuf [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 )   err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config ,   & d -> dev -> i2c_adap , NULL ) ;if ( d -> fe_adap [ 0 ] . fe != NULL ) {if ( dvb_attach ( tda18271_attach , d -> fe_adap [ 0 ] . fe , 0x60 ,   & d -> dev -> i2c_adap , & tda18271_config ) ) {info ( ""Attached<S2SV_blank>TDA18271HD/CXD2820R!"" ) ;","static int t220_frontend_attach ( struct dvb_usb_adapter * adap ) {struct dvb_usb_device * d = adap -> dev ;struct dw2102_state * state = d -> priv ;mutex_lock ( & d -> data_mutex ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x87 ;state -> data [ 2 ] = 0x0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x86 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;obuf [ 0 ] = 0xe ;obuf [ 2 ] = 0 ;if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;msleep ( 50 ) ;state -> data [ 0 ] = 0xe ;state -> data [ 1 ] = 0x80 ;state -> data [ 2 ] = 1 ;if ( dvb_usb_generic_rw ( d , state -> data , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ;state -> data [ 0 ] = 0x51 ;if ( dvb_usb_generic_rw ( d , state -> data , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ;d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config , & d -> i2c_adap , NULL ) ;if ( d -> fe_adap [ 0 ] . fe != NULL ) {if ( dvb_attach ( tda18271_attach , adap -> fe_adap [ 0 ] . fe , 0x60 , & d -> i2c_adap , & tda18271_config ) ) {info ( ""Attached<S2SV_blank>TDA18271HD/CXD2820R!"" ) ;",4344
313,"if ( ! validate_event ( & fake_pmu , leader ) )  return - EINVAL ;if ( ! validate_event ( & fake_pmu , sibling ) )  return - EINVAL ;if ( ! validate_event ( & fake_pmu , event ) )  return - EINVAL ;","if ( ! validate_event ( event -> pmu , & fake_pmu , leader ) ) return - EINVAL ;if ( ! validate_event ( event -> pmu , & fake_pmu , sibling ) ) return - EINVAL ;if ( ! validate_event ( event -> pmu , & fake_pmu , event ) ) return - EINVAL ;",4345
314,"fd = open ( authfile , O_RDONLY , 0 ) ;if ( fd < 0 ) {","fd = open ( authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY ) ;if ( fd < 0 ) {else {fd = - 1 ;}",4346
315,goto err ;},goto err ;},4346
316,else if ( fd >= 0 )  close ( fd ) ;,if ( fd >= 0 ) close ( fd ) ;,4346
317,ether_setup ( dev ) ;if ( iface ) {,dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;ether_setup ( dev ) ;if ( iface ) {,4347
318,"if ( ACTION ( RUN ) )  handle_run ( req , res ) ;else if ( ACTION ( DOACTION ) )  handle_do_action ( req , res ) ;else  handle_action ( req , res ) ;}","if ( ACTION ( RUNTIME ) ) handle_runtime_action ( req , res ) ;else if ( ACTION ( VIEWLOG ) ) do_viewlog ( req , res ) ;else if ( ACTION ( DOACTION ) ) handle_doaction ( req , res ) ;else handle_service_action ( req , res ) ;}",4348
319,"list_add ( & dev -> vm_node , & kvm -> devices ) ;mutex_unlock ( & kvm -> lock ) ;if ( ops -> init ) ops -> init ( dev ) ;ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ;if ( ret < 0 ) {mutex_lock ( & kvm -> lock ) ;list_del ( & dev -> vm_node ) ;mutex_unlock ( & kvm -> lock ) ;ops -> destroy ( dev ) ;return ret ;}kvm_get_kvm ( kvm ) ;cd -> fd = ret ;",kvm_get_kvm ( kvm ) ;cd -> fd = ret ;,4349
320,"Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ;","if ( len > INT_MAX ) {php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ;RETURN_FALSE ;}Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ;Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ;",4350
321,"
",char * txt = op -> txt ;int txtLen = strlen ( op -> txt ) ;int txtLeft = R_ASM_BUFSIZE - txtLen ;txt += txtLen ;,4351
322,"for ( i = 0 ;i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;}snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ;free ( table ) ;","for ( i = 0 ;i < count && txtLen + 10 < R_ASM_BUFSIZE ;int optxtlen = strlen ( op -> txt ) ;snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ;txtLen = strlen ( txt ) ;txt += txtLen ;txtLeft -= txtLen ;}snprintf ( txt , txtLeft - 1 , ""%d"" , def ) ;free ( table ) ;",4351
323,addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ;addr . sin_port = htons ( port ) ;,addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ;addr . sin_port = htons ( port ) ;,4352
324,while ( ! EOFBlob ( image ) )  {if ( filepos != ( unsigned int ) filepos )  break ;if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) )  goto MATLAB_KO ;,while ( filepos < GetBlobSize ( image ) && ! EOFBlob ( image ) ) {if ( filepos > GetBlobSize ( image ) || filepos < 0 ) break ;if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) >= GetBlobSize ( image ) ) goto MATLAB_KO ;,4353
325,"if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) ,  ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ;goto ExitLoop ;","ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ;if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ;goto ExitLoop ;",4353
326,"static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize )  {","static UINT32 nsc_rle_encode ( const BYTE * in , BYTE * out , UINT32 originalSize ) {",4354
327,"static void vp8_init_ctx ( vpx_codec_ctx_t * ctx , const vpx_codec_mmap_t * mmap )  {int i ;ctx -> priv = mmap -> base ;ctx -> priv -> sz = sizeof ( * ctx -> priv ) ;","static void vp8_init_ctx ( vpx_codec_ctx_t * ctx ) {vpx_codec_alg_priv_t * priv = ( vpx_codec_alg_priv_t * ) vpx_calloc ( 1 , sizeof ( * priv ) ) ;ctx -> priv = ( vpx_codec_priv_t * ) priv ;ctx -> priv -> sz = sizeof ( * ctx -> priv ) ;",4355
328,if ( ctx -> config . dec )  {ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ;ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ;},priv -> si . sz = sizeof ( priv -> si ) ;priv -> decrypt_cb = NULL ;priv -> decrypt_state = NULL ;if ( ctx -> config . dec ) {priv -> cfg = * ctx -> config . dec ;ctx -> config . dec = & priv -> cfg ;},4355
329,"int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ;int32 bytes_read = 0 ;uint16 bps , nstrips , planar , strips_per_sample ;uint32 src_rowsize , dst_rowsize , rows_processed , rps ;","int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ;uint32 j ;int32 bytes_read = 0 ;uint16 bps , planar ;uint32 nstrips ;uint32 strips_per_sample ;uint32 src_rowsize , dst_rowsize , rows_processed , rps ;",4356
330,"static int override_release ( char __user * release , int len )  {int ret = 0 ;char buf [ 65 ] ;char * rest = UTS_RELEASE ;int ndots = 0 ;unsigned v ;while ( * rest ) {snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ;ret = copy_to_user ( release , buf , len ) ;}","static int override_release ( char __user * release , size_t len ) {int ret = 0 ;const char * rest = UTS_RELEASE ;char buf [ 65 ] = {0 };int ndots = 0 ;unsigned v ;size_t copy ;while ( * rest ) {copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ;copy = scnprintf ( buf , copy , ""2.6.%u%s"" , v , rest ) ;ret = copy_to_user ( release , buf , copy + 1 ) ;}",4357
331,"pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ;void * memory ;","pgprot_t prot = __get_dma_pgprot ( attrs , PAGE_KERNEL ) ;void * memory ;",4358
332,"rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb ,  plinux_opts ) ;","rc = foreach_shareopt ( shareopts , get_linux_shareopts_cb , plinux_opts ) ;",4359
333,"
","if ( s -> image_offset_x || s -> image_offset_y ) {avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ;return AVERROR_PATCHWELCOME ;}",4360
334,ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,ncomponents = bytestream2_get_be16u ( & s -> g ) ;if ( ncomponents <= 0 ) {,4360
335,"return ;}ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\\switch ( pt ) {case PT_IPV4 : ip_print ( ndo , p , length ) ;case PT_OSI :  isoclns_print ( ndo , p , length , length ) ;break ;","case PT_OSI : isoclns_print ( ndo , p , length , length ) ;break ;",4361
336,for ( i = num_excl_chan ;i ++ )  {,if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;for ( i = num_excl_chan ;i ++ ) {,4362
337,if ( esd ) {streamType = esd -> decoderConfig -> streamType ;,if ( esd && esd -> decoderConfig ) {streamType = esd -> decoderConfig -> streamType ;,4363
338,"mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ;# ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ;","mutt_bcache_del ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) ;# ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ;",4364
339,if ( val == 0 && sp -> do_auto_asconf ) {list_del ( & sp -> auto_asconf_list ) ;return 0 ;},spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;if ( val == 0 && sp -> do_auto_asconf ) {list_del ( & sp -> auto_asconf_list ) ;spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;return 0 ;},4365
340,"
",oidc_scrub_headers ( r ) ;,4366
341,char * authn_header = oidc_cfg_dir_authn_header ( r ) ;int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ;,char * authn_header = oidc_cfg_dir_authn_header ( r ) ;int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ;,4366
342,char fnam [ PROCLEN ] ;FILE * f ;char * line = NULL ;size_t len = 0 ;,char * line = NULL ;size_t len = 0 ;,4367
343,"if ( ! c2 )  goto out ;* c2 = \'\\\\0\' ;if ( strcmp ( c1 , contrl ) != 0 ) continue ;c2 ++ ;stripnewline ( c2 ) ;if ( nextcg )  * nextcg = get_next_cgroup_dir ( linecmp , cg ) ;goto out ;}goto out ;}out : fclose ( f ) ;free ( line ) ;","if ( ! c2 ) return false ;if ( nextcg ) {* nextcg = get_next_cgroup_dir ( linecmp , cg ) ;}goto out ;}out : free ( c2 ) ;",4367
344,"if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) {error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name ,  slurm_strerror ( errno ) ) ;","if ( ( fd = _open_as_other ( path_name , req ) ) == - 1 ) {error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , slurm_strerror ( errno ) ) ;",4368
345,"
","size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;",4369
346,params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,params = malloc ( alloc_size ) ;if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ;,4369
347,"static char *  base64_decode_string ( const char * enc ) {if ( enc == NULL )  return NULL ;char * dec = g_strdup ( enc ) ;gsize len ;g_base64_decode_inplace ( dec , & len ) ;dec [ len ] = '\\\\0' ;","static gchar * base64_decode_string ( const char * enc ) {gchar * dec ;gsize len ;if ( enc == NULL ) return NULL ;dec = ( gchar * ) g_base64_decode ( enc , & len ) ;if ( dec ) dec [ len ] = '\\\\0' ;",4370
348,if ( socket -> interface != NULL )  {,if ( message -> interface != NULL ) {interface = message -> interface ;}else if ( socket -> interface != NULL ) {,4371
349,stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ;stripinplane = ( strip % stripsperplane ) ;,stripsperplane = TIFFhowmany_32_maxuint_compat ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ;stripinplane = ( strip % stripsperplane ) ;,4372
350,if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) )  return - EINVAL ;,if ( validate_core_offset ( reg ) ) return - EINVAL ;if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ;,4373
351,"safe_print ( value , valsz , NULL ) ;fputs ( ""\\\safe_print ( value , valsz , ""\\\\"""" ) ;fputs ( ""\\\\"""" , stdout ) ;","safe_print ( value , valsz , ""<S2SV_blank>\\\\\\\\\\\\""\\\'$`<>"" ) ;fputs ( ""\\\safe_print ( value , valsz , ""\\\\""\\\\\\\\"" ) ;fputs ( ""\\\\"""" , stdout ) ;",4374
352,"if ( s -> rlayer . numwpipes < numpipes ) if ( ! ssl3_setup_write_buffer ( s , numpipes , 0 ) ) return - 1 ;if ( totlen == 0 && ! create_empty_fragment ) return 0 ;sess = s -> session ;if ( ( sess == NULL ) || ( s -> enc_write_ctx == NULL ) || ( EVP_MD_CTX_md ( s -> write_hash ) == NULL ) ) {clear = s -> enc_write_ctx ? 0 : 1 ;mac_size = 0 ;}else {mac_size = EVP_MD_CTX_size ( s -> write_hash ) ;if ( mac_size < 0 ) goto err ;}if ( ! clear && ! create_empty_fragment && ! s -> s3 -> empty_fragment_done ) {if ( s -> s3 -> need_empty_fragments && type == SSL3_RT_APPLICATION_DATA ) {unsigned int tmppipelen = 0 ;prefix_len = do_ssl3_write ( s , type , buf , & tmppipelen , 1 , 1 ) ;if ( prefix_len <= 0 ) goto err ;if ( prefix_len > ( SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD ) ) {SSLerr ( SSL_F_DO_SSL3_WRITE , ERR_R_INTERNAL_ERROR ) ;goto err ;}}s -> s3 -> empty_fragment_done = 1 ;}if ( create_empty_fragment ) {wb = & s -> rlayer . wbuf [ 0 ] ;# if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( size_t ) SSL3_BUFFER_get_buf ( wb ) + 2 * SSL3_RT_HEADER_LENGTH ;align = SSL3_ALIGN_PAYLOAD - 1 - ( ( align - 1 ) % SSL3_ALIGN_PAYLOAD ) ;# endif outbuf [ 0 ] = SSL3_BUFFER_get_buf ( wb ) + align ;SSL3_BUFFER_set_offset ( wb , align ) ;}else if ( prefix_len ) {wb = & s -> rlayer . wbuf [ 0 ] ;outbuf [ 0 ] = SSL3_BUFFER_get_buf ( wb ) + SSL3_BUFFER_get_offset ( wb ) + prefix_len ;}else {for ( j = 0 ;j < numpipes ;j ++ ) {wb = & s -> rlayer . wbuf [ j ] ;# if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( size_t ) SSL3_BUFFER_get_buf ( wb ) + SSL3_RT_HEADER_LENGTH ;align = SSL3_ALIGN_PAYLOAD - 1 - ( ( align - 1 ) % SSL3_ALIGN_PAYLOAD ) ;# endif outbuf [ j ] = SSL3_BUFFER_get_buf ( wb ) + align ;SSL3_BUFFER_set_offset ( wb , align ) ;}}if ( s -> enc_write_ctx && SSL_USE_EXPLICIT_IV ( s ) ) {",if ( s -> rlayer . numwpipes < numpipes ) if ( ! SSL_WRITE_ETM ( s ) ) {,4375
353,"if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) {if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , 1 ) < 0 ) goto err ;","if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) {if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , 1 ) < 0 ) goto err ;",4375
354,"if ( SSL_USE_ETM ( s ) && mac_size != 0 ) {if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) goto err ;","if ( SSL_WRITE_ETM ( s ) && mac_size != 0 ) {if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) goto err ;",4375
355,"static int read_frame_stats ( const struct twopass_rc * p ,  FIRSTPASS_STATS * frame_stats , int offset ) {const FIRSTPASS_STATS * fps_ptr = p -> stats_in ;if ( offset >= 0 ) {if ( & fps_ptr [ offset ] >= p -> stats_in_end )  return EOF ;}else if ( offset < 0 ) {if ( & fps_ptr [ offset ] < p -> stats_in_start )  return EOF ;* frame_stats = fps_ptr [ offset ] ;return 1 ;}","static const FIRSTPASS_STATS * read_frame_stats ( const struct twopass_rc * p , FIRSTPASS_STATS * frame_stats , int offset ) {if ( ( offset >= 0 ) {if ( & fps_ptr [ offset ] >= p -> stats_in_end ) || ( offset < 0 ) {if ( & fps_ptr [ offset ] < p -> stats_in_start ) ) {return NULL ;}return & p -> stats_in [ offset ] ;",4376
356,"goto err_free_mem ;}buf [ BUF_SIZE - 1 ] = \'\\\\0\' ;dev_info ( s -> dev , ""Board<S2SV_blank>ID:<S2SV_blank>%02x\\\dev_info ( s -> dev , ""Firmware<S2SV_blank>version:<S2SV_blank>%s\\\s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ;s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ;s -> vb_queue . drv_priv = s ;s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ;s -> vb_queue . ops = & airspy_vb2_ops ;s -> vb_queue . mem_ops = & vb2_vmalloc_memops ;s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ;ret = vb2_queue_init ( & s -> vb_queue ) ;if ( ret ) {dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\\goto err_free_mem ;}s -> vdev = airspy_template ;s -> vdev . queue = & s -> vb_queue ;s -> vdev . queue -> lock = & s -> vb_queue_lock ;video_set_drvdata ( & s -> vdev , s ) ;s -> v4l2_dev . release = airspy_video_release ;ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ;if ( ret ) {dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\\goto err_free_mem ;}v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ;s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ;s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ;v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ;s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ;s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ;v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ;s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ;if ( s -> hdl . error ) {ret = s -> hdl . error ;dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\\v4l2_ctrl_handler_setup ( & s -> hdl ) ;s -> v4l2_dev . ctrl_handler = & s -> hdl ;s -> vdev . v4l2_dev = & s -> v4l2_dev ;s -> vdev . lock = & s -> v4l2_lock ;ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ;if ( ret ) {dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\\goto err_unregister_v4l2_dev ;}err_unregister_v4l2_dev :  v4l2_device_unregister ( & s -> v4l2_dev ) ;",err_unregister_v4l2_dev : v4l2_device_unregister ( & s -> v4l2_dev ) ;,4377
357,"static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {","static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {",4378
358,if ( noblock )  return - EAGAIN ;,cond_resched ( ) ;,4379
359,"if ( ret < 0 ) return ret ;key -> expiry = prep -> expiry ;if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) )  zap = dereference_key_locked ( key ) ;",if ( key_is_positive ( key ) ) zap = dereference_key_locked ( key ) ;,4380
360,"for ( j = 0 ;j ++ )   av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ;av_log ( s , AV_LOG_DEBUG , ""\\\'\\\","for ( j = 0 ;j ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ;}av_log ( s , AV_LOG_DEBUG , ""\\\'\\\",4381
361,if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {ret = - ENOTCONN ;goto out ;}if ( payload_len > rds_sk_sndbuf ( rs ) ) {,lock_sock ( sk ) ;if ( daddr == 0 || rs -> rs_bound_addr == 0 ) {release_sock ( sk ) ;ret = - ENOTCONN ;goto out ;}release_sock ( sk ) ;if ( payload_len > rds_sk_sndbuf ( rs ) ) {,4382
362,case IS_STRING :  convert_to_double_ex ( tmp ) ;m1 [ i ] = Z_DVAL_PP ( tmp ) ;break ;,case IS_STRING : {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;m1 [ i ] = Z_DVAL ( dval ) ;}break ;,4383
363,case IS_STRING :  convert_to_double_ex ( tmp ) ;m2 [ i ] = Z_DVAL_PP ( tmp ) ;break ;,case IS_STRING : {zval dval ;dval = * * tmp ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;m2 [ i ] = Z_DVAL ( dval ) ;}break ;,4383
364,"jas_stream_t * stream ;jas_stream_memobj_t * obj ;if ( ! ( stream = jas_stream_create ( ) ) ) {return 0 ;}stream -> openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY ;jas_stream_initbuf ( stream , JAS_STREAM_FULLBUF , 0 , 0 ) ;stream -> ops_ = & jas_stream_memops ;if ( ! ( obj = jas_malloc ( sizeof ( jas_stream_memobj_t ) ) ) ) {jas_stream_destroy ( stream ) ;return 0 ;stream -> obj_ = ( void * ) obj ;obj -> myalloc_ = 0 ;obj -> buf_ = 0 ;obj -> bufsize_ = 1024 ;obj -> growable_ = 1 ;obj -> bufsize_ = bufsize ;obj -> growable_ = 0 ;}","char * new_buf ;size_t new_bufsize ;if ( bufsize < 0 ) {jas_deprecated ( ""negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen"" ) ;}if ( buf && bufsize <= 0 ) {jas_eprintf ( ""Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\\jas_deprecated ( ""A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>"" ""jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\\obj -> bufsize_ = 1024 ;obj -> growable_ = 1 ;obj -> bufsize_ = bufsize ;obj -> growable_ = 0 ;}",4384
365,"case SO_KEEPALIVE : # ifdef CONFIG_INET  if ( sk -> sk_protocol == IPPROTO_TCP )  tcp_set_keepalive ( sk , valbool ) ;","case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) tcp_set_keepalive ( sk , valbool ) ;",4385
366,net -> dev_base_seq = 1 ;net -> user_ns = user_ns ;,"get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;net -> dev_base_seq = 1 ;net -> user_ns = user_ns ;",4386
367,"overrun = timr -> it_overrun_last ;unlock_timer ( timr , flags ) ;","overrun = timer_overrun_to_int ( timr , 0 ) ;unlock_timer ( timr , flags ) ;",4387
368,"if ( map && nmap ) {cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ,  map , nmap ) ;}else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ;","if ( map && nmap ) cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ;else cp = ikev1_attr_print ( ndo , cp , ep2 ) ;if ( cp == NULL ) goto trunc ;",4388
369,"int length ;ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;in_uint8s ( s , length ) ;","uint32 length ;struct stream packet = * s ;ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;if ( ! s_check_rem ( s , length ) ) {rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ;}in_uint8s ( s , length ) ;",4389
370,"int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ;bool grab_newname = false ;fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , getpid ( ) ) ;return - 1 ;}fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , pid ) ;return - 1 ;}if ( setns ( fd , 0 ) < 0 ) {fprintf ( stderr , ""setns<S2SV_blank>to<S2SV_blank>container<S2SV_blank>network<S2SV_blank>namespace\\\goto out_err ;}close ( fd ) ;if ( ! * newnamep ) {if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) {fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index\\\goto out_err ;if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) {fprintf ( stderr , ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container\\\goto out_err ;char ifname [ IFNAMSIZ ] , * namep = ifname ;if ( ! if_indextoname ( ifindex , namep ) ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\\goto out_err ;if ( ! * newnamep )  goto out_err ;}if ( setns ( ofd , 0 ) < 0 ) {fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>netns\\\close ( ofd ) ;return - 1 ;}return 0 ;out_err : if ( ofd >= 0 ) close ( ofd ) ;if ( setns ( ofd , 0 ) < 0 ) fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace\\\if ( fd >= 0 ) close ( fd ) ;return - 1 ;","uid_t ruid , suid , euid ;int fret = - 1 ;int fd = - 1 , ifindex = - 1 , ofd = - 1 , ret ;bool grab_newname = false ;usernic_error ( ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , getpid ( ) ) ;return fret ;}usernic_error ( ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\\\'%d\\\'."" , pid ) ;return - 1 ;}if ( setns ( fd , CLONE_NEWNET ) ;close ( fd ) ;if ( ! * newnamep ) {if ( ! ifindex ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\\goto do_full_cleanup ;ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ;if ( ret < 0 ) {usernic_error ( ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\\goto do_full_cleanup ;char ifname [ IFNAMSIZ ] , * namep = ifname ;if ( ! if_indextoname ( ifindex , namep ) ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\\goto do_full_cleanup ;if ( ! * newnamep ) goto do_full_cleanup ;}fret = 0 ;do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ;if ( ret < 0 ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\\fret = - 1 ;}ret = setns ( ofd , CLONE_NEWNET ) ;if ( ret < 0 ) {usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>"" ""of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\\fret = - 1 ;}do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ;return fret ;",4390
371,for ( i = 0 ;i ++ )  {for ( i = 0 ;i ++ )  {}},"for ( i = 0 ;++ i ) {for ( i = 0 ;++ i ) {vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ;}}",4391
372,if ( strlen ( parv [ 1 ] ) > 400 )  {,"if ( ( parv [ 1 ] [ 0 ] == \':\' ) || strchr ( parv [ 1 ] , \'<S2SV_blank>\' ) ) {sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , ""*"" , ""AUTHENTICATE"" , ""Invalid<S2SV_blank>parameter"" ) ;return 0 ;}if ( strlen ( parv [ 1 ] ) > 400 ) {",4392
373,"if ( timeCompare ( time , context -> startTime + context -> timeout ) >= 0 ) {context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTING ;error = ERROR_TIMEOUT ;}else if ( timeCompare ( time , context -> retransmitStartTime + MQTT_SN_CLIENT_RETRY_TIMEOUT ) >= 0 ) {error = mqttSnClientSendSubscribe ( context , topicName , qos ) ;}else {error = mqttSnClientProcessEvents ( context , MQTT_SN_CLIENT_TICK_INTERVAL ) ;}}else if ( context -> state == MQTT_SN_CLIENT_STATE_RESP_RECEIVED ) {context -> state = MQTT_SN_CLIENT_STATE_ACTIVE ;if ( context -> msgType == MQTT_SN_MSG_TYPE_SUBACK ) {if ( context -> returnCode == MQTT_SN_RETURN_CODE_ACCEPTED ) {if ( strchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL )  {","if ( osStrchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL ) {",4393
374,"struct dentry * dentry = path -> dentry ;struct inode * inode = dentry -> d_inode ;file -> f_path = * path ;}return do_dentry_open ( file , inode , NULL , cred ) ;","struct inode * inode = dentry -> d_inode ;file -> f_path = * path ;file -> f_path = * path ;return do_dentry_open ( file , inode , NULL , cred ) ;",4394
375,"char data [ 8 ] ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ;return - EIO ;}switch ( data [ 0 ] ) {return - EIO ;}return snprintf ( buf , PAGE_SIZE , ""%s\\\","char * data ;data = kmalloc ( 2 , GFP_KERNEL ) ;if ( ! data ) return - ENOMEM ;ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ;ret = - EIO ;goto out ;}switch ( data [ 0 ] ) {ret = - EIO ;goto out ;}ret = snprintf ( buf , PAGE_SIZE , ""%s\\\out : kfree ( data ) ;return ret ;",4395
376,"error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ;if ( error < 0 )  return 0 ;if ( error == 0 ) acl = NULL ;","error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ;if ( error ) return error ;",4396
377,retval = xfs_attr_shortform_lookup ( args ) ;if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) {return retval ;else if ( retval == - EEXIST ) {if ( args -> flags & ATTR_CREATE ) return retval ;retval = xfs_attr_shortform_remove ( args ) ;ASSERT ( retval == 0 ) ;},if ( retval ) return retval ;args -> flags &= ~ ATTR_REPLACE ;,4397
378,"status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;if ( image == ( Image * ) NULL )  image = screen ;","if ( image == ( Image * ) NULL ) image = screen ;status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ;if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ;",4398
379,"static void  pci_msix_table_init ( struct pci_vdev * dev , int table_entries ) {int i , table_size ;assert ( table_entries > 0 ) ;assert ( table_entries <= MAX_MSIX_TABLE_ENTRIES ) ;assert ( dev -> msix . table != NULL ) ;for ( i = 0 ;}","static int pci_msix_table_init ( struct pci_vdev * dev , int table_entries ) {int i , table_size ;if ( ! dev -> msix . table ) {pr_err ( ""%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>memory!\\\return - 1 ;}for ( i = 0 ;return 0 ;}",4399
380,"int err ;err = crypto_ahash_export ( req , state ) ;if ( err ) return err ;ctx2 -> more = 1 ;err = crypto_ahash_import ( & ctx2 -> req , state ) ;","bool more ;int err ;lock_sock ( sk ) ;more = ctx -> more ;err = more ? crypto_ahash_export ( req , state ) : 0 ;release_sock ( sk ) ;if ( err ) return err ;ctx2 -> more = more ;if ( ! more ) return err ;err = crypto_ahash_import ( & ctx2 -> req , state ) ;",4400
381,case DB_VECTOR :  dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ;,"case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ;return 1 ;case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ;",4401
382,if ( x & ( 1 << i ) ) return i ;},if ( x & ( 1U << ( unsigned int ) i ) ) return i ;},4402
383,"if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\","if ( q < p ) {DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\\goto out ;}if ( q > e ) {DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\\",4403
384,"struct completion * vfork_done = tsk -> vfork_done ;deactivate_mm ( tsk , mm ) ;","struct completion * vfork_done = tsk -> vfork_done ;# ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ;# ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ;# endif # endif deactivate_mm ( tsk , mm ) ;",4404
385,"rrd_graph_options ( argc , argv , & im ) ;if ( rrd_test_error ( ) ) {rrd_info_free ( im . grinfo ) ;im_free ( & im ) ;","
",4405
386,"rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ;return NULL ;","rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ;return NULL ;",4405
387,void * zmalloc ( size_t size ) {void * ptr = malloc ( size + PREFIX_SIZE ) ;,void * zmalloc ( size_t size ) {ASSERT_NO_SIZE_OVERFLOW ( size ) ;void * ptr = malloc ( size + PREFIX_SIZE ) ;,4406
388,ret = 0 ;goto error2 ;,key_put ( keyring ) ;ret = 0 ;goto error2 ;,4407
389,pWTIntFrame -> numSamples = 0 ;},"android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;pWTIntFrame -> numSamples = 0 ;}",4408
390,return ;}return ;},}}return ;ND_TCHECK_16BITS ( bp ) ;,4409
391,"switch ( EXTRACT_16BITS ( bp ) ) {case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;","switch ( EXTRACT_16BITS ( bp ) ) {case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ;",4409
392,"int fourcc_is_ivf ( const char detect [ 4 ] ) {if ( memcmp ( detect , ""DKIF"" , 4 ) == 0 ) {","static int fourcc_is_ivf ( const char detect [ 4 ] ) {if ( memcmp ( detect , ""DKIF"" , 4 ) == 0 ) {",4410
393,OPJ_UNUSED ( p_manager ) ;if ( p_total_data_size < 12 ) {,if ( p_total_data_size < 12 ) {,4411
394,"int ret ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;","int ret ;if ( current_chrooted ( ) ) return - EPERM ;if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ;",4412
395,"
",GTextFieldSaved ( gt ) ;,4413
396,},},4413
397,"
",buflen ++ ;,4414
398,continue ;},continue ;},4414
399,"while ( len -- )  ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ;","while ( len -- > 0 ) ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ;",4415
400,"while ( len -- )  ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ;","while ( len -- > 0 ) ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ;",4415
401,"if ( length < 2 ) return 0 ;elementlen = * ( p + offset + 1 ) ;if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ;if ( length < elementlen + 2 ) return 0 ;switch ( * ( p + offset ) ) {case E_SSID : memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) )  return 0 ;","memcpy ( & ssid , p + offset , 2 ) ;if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ;",4416
402,"if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) )  return 0 ;if ( length < challenge . length ) return 0 ;","
",4416
403,"case E_RATES : memcpy ( & rates , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( rates . length != 0 ) {if ( rates . length > sizeof rates . rate ) return 0 ;if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) )  return 0 ;if ( length < rates . length ) return 0 ;memcpy ( & rates . rate , p + offset , rates . length ) ;offset += rates . length ;length -= rates . length ;}if ( ! pbody -> rates_present && rates . length != 0 ) {pbody -> rates = rates ;pbody -> rates_present = 1 ;}break ;case E_DS : memcpy ( & ds , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( ds . length != 1 ) {offset += ds . length ;length -= ds . length ;break ;}ds . channel = * ( p + offset ) ;offset += 1 ;length -= 1 ;if ( ! pbody -> ds_present ) {pbody -> ds = ds ;pbody -> ds_present = 1 ;}break ;case E_CF : memcpy ( & cf , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( cf . length != 6 ) {offset += cf . length ;length -= cf . length ;break ;}memcpy ( & cf . count , p + offset , 6 ) ;offset += 6 ;length -= 6 ;if ( ! pbody -> cf_present ) {pbody -> cf = cf ;pbody -> cf_present = 1 ;}break ;case E_TIM : memcpy ( & tim , p + offset , 2 ) ;offset += 2 ;length -= 2 ;if ( tim . length <= 3 ) {offset += tim . length ;length -= tim . length ;break ;}if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ;memcpy ( & tim . count , p + offset , 3 ) ;offset += 3 ;length -= 3 ;memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ;offset += tim . length - 3 ;","case E_RATES : memcpy ( & rates , p + offset , tim . length - 3 ) ;offset += tim . length - 3 ;",4416
404,"ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ;tptr += sizeof ( const struct eap_frame_t ) ;tlen -= sizeof ( const struct eap_frame_t ) ;switch ( eap -> type ) {case EAP_FRAME_TYPE_PACKET :  type = * ( tptr ) ;len = EXTRACT_16BITS ( tptr + 2 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\","ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , subtype ) , subtype ) ) ;ND_TCHECK_8BITS ( tptr + 4 ) ;subtype = * ( tptr + 4 ) ;ND_PRINT ( ( ndo , ""\\\",4417
405,"ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" ,  tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS :  ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST :  ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" ,  EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM :  ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" ,  tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;","ND_TCHECK_8BITS ( tptr + count ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ;case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ;if ( subtype == EAP_TYPE_TTLS ) ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;case EAP_TYPE_TLS : ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ;ND_TCHECK_32BITS ( tptr + 6 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ;}case EAP_TYPE_AKA : case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ;",4417
406,"int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) {int labelfd = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 )  goto out ;if ( strcmp ( name , ""none"" ) == 0 )  goto out ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;if ( on_exec ) {labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ;}else {labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ;}if ( labelfd < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}ret = - 1 ;goto out ;ret = - 1 ;goto out ;}if ( write ( labelfd , command , size + 1 ) < 0 ) {SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ;ret = - 1 ;goto out ;}else if ( strcmp ( name , ""SELinux"" ) == 0 ) {if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) {ret = - 1 ;ret = - 1 ;goto out ;if ( labelfd != - 1 )   close ( labelfd ) ;return ret ;}","static int lsm_set_label_at ( int lsm_labelfd , int on_exec , char * lsm_label ) {int fret = - 1 ;int ret = 0 ;if ( strcmp ( name , ""nop"" ) == 0 ) return 0 ;if ( strcmp ( name , ""none"" ) == 0 ) return 0 ;if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ;ret = - 1 ;goto out ;goto out ;if ( write ( labelfd , command , size + 1 ) < 0 ) {INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ;ret = - 1 ;goto out ;if ( labelfd != - 1 ) close ( labelfd ) ;return fret ;}",4418
407,"void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields )  {","static void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) {",4419
408,"if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 )  return 0 ;","if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 || apic -> lapic_timer . period == 0 ) return 0 ;",4420
409,"__clear_bit ( * old_keycode , dev -> keybit ) ;__set_bit ( ke -> keycode , dev -> keybit ) ;for ( i = 0 ;if ( input_fetch_keycode ( dev , i ) == * old_keycode ) {","if ( * old_keycode <= KEY_MAX ) {__clear_bit ( * old_keycode , dev -> keybit ) ;for ( i = 0 ;if ( input_fetch_keycode ( dev , i ) == * old_keycode ) {}__set_bit ( ke -> keycode , dev -> keybit ) ;",4421
410,"static void  l2tp_accm_print ( netdissect_options * ndo , const u_char * dat )  {ptr ++ ;val_h = EXTRACT_16BITS ( ptr ) ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;","static void l2tp_accm_print ( netdissect_options * ndo , const u_char * dat , u_int length ) {if ( length < 2 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}return ;}length -= 2 ;if ( length < 4 ) {ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}val_h = EXTRACT_16BITS ( ptr ) ;ptr ++ ;length -= 2 ;length -= 2 ;val_h = EXTRACT_16BITS ( ptr ) ;val_l = EXTRACT_16BITS ( ptr ) ;",4422
411,"if ( handle && ! ext4_handle_valid ( handle ) )  return 0 ;if ( list_empty ( & ei -> i_orphan ) ) goto out ;ino_next = NEXT_ORPHAN ( inode ) ;prev = ei -> i_orphan . prev ;sbi = EXT4_SB ( inode -> i_sb ) ;jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\\list_del_init ( & ei -> i_orphan ) ;if ( sbi -> s_journal && ! handle )  goto out ;",if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) return 0 ;if ( ! handle ) goto out ;,4423
412,"case L2CAP_CONF_UNACCEPT :  if ( ++ l2cap_pi ( sk ) -> conf_retry < L2CAP_CONF_MAX_RETRIES ) {char req [ 128 ] ;l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ ,  l2cap_build_conf_req ( sk , req ) , req ) ;goto done ;}","case L2CAP_CONF_UNACCEPT : if ( l2cap_pi ( sk ) -> num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP ) {int len = cmd -> len - sizeof ( * rsp ) ;char req [ 64 ] ;result = L2CAP_CONF_SUCCESS ;len = l2cap_parse_conf_rsp ( sk , rsp -> data , len , req , & result ) ;if ( len < 0 ) {struct l2cap_disconn_req req ;req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ;req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ;l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ;goto done ;}l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , len , req ) ;l2cap_pi ( sk ) -> num_conf_req ++ ;if ( result != L2CAP_CONF_SUCCESS ) goto done ;break ;}",4424
413,}audio_conv_info -> ver_major = ver_major ;,usb_conv_info -> class_data_type = USB_CONV_AUDIO ;}else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) {return 0 ;}audio_conv_info -> ver_major = ver_major ;,4425
414,"Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ;if ( ! ( ( message -> NegotiateFlags & NTLMSSP_REQUEST_TARGET ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) ) ) {","if ( Stream_GetRemainingLength ( s ) < 4 ) {Stream_Free ( s , FALSE ) ;return SEC_E_INVALID_TOKEN ;}Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ;if ( ! ( ( message -> NegotiateFlags & NTLMSSP_REQUEST_TARGET ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) ) ) {",4426
415,"if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) {bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ;","if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ( ICANON | EXTPROC ) ) {bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ;",4427
416,"f = fopen ( filepath , ""rb"" ) ;if ( f ) {","f = fopen ( filepath , ""r"" ) ;if ( f ) {",4428
417,len = b - a ;str = ( char * ) PyObject_MALLOC ( len + 1 ) ;,len = ( a != NULL && b != NULL ) ? b - a : 0 ;str = ( char * ) PyObject_MALLOC ( len + 1 ) ;,4429
418,"else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""<>"" ) ) {PyObject_FREE ( str ) ;err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\\\'<>\\\'<S2SV_blank>""  ""instead<S2SV_blank>of<S2SV_blank>\\\'!=\\\'"" ;err_ret -> error = E_SYNTAX ;break ;# endif  if ( a >= tok -> line_start )  col_offset = Py_SAFE_DOWNCAST ( a - tok -> line_start , intptr_t , int ) ;else   col_offset = - 1 ;if ( type == TYPE_IGNORE ) {","err_ret -> expected = NOTEQUAL ;err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\\\'<>\\\'<S2SV_blank>"" ""instead<S2SV_blank>of<S2SV_blank>\\\'!=\\\'"" ;# endif if ( a != NULL && a >= tok -> line_start ) {col_offset = Py_SAFE_DOWNCAST ( a - tok -> line_start , intptr_t , int ) ;}else {col_offset = - 1 ;if ( type == TYPE_IGNORE ) {",4429
419,"snapend_save = ndo -> ndo_snapend ;ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ;","snapend_save = ndo -> ndo_snapend ;ND_TCHECK_16BITS ( & ip -> ip_len ) ;ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ;",4430
420,"pid_t pid ;memset ( s_path , 0 , sizeof ( s_path ) ) ;memset ( c_path , 0 , sizeof ( c_path ) ) ;pid = getpid ( ) ;","memset ( s_path , 0 , sizeof ( s_path ) ) ;memset ( c_path , 0 , sizeof ( c_path ) ) ;",4431
421,"sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix ,   hdl -> instance , ( long unsigned ) pid ) ;if ( * mgr_hdl == NULL ) {","sprintf ( c_path , ""%s%s%d_C_XXXXXX"" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ;if ( * mgr_hdl == NULL ) {",4431
422,"static const u_char * ikev1_attrmap_print ( netdissect_options * ndo ,  const u_char * p , const u_char * ep ,  const struct attrmap * map , size_t nmap ) {if ( p [ 0 ] & 0x80 )  totlen = 4 ;else  totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ep < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;ND_PRINT ( ( ndo , ""value="" ) ) ;v = EXTRACT_16BITS ( & p [ 2 ] ) ;else  rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ;}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ;}return p + totlen ;}","static const u_char * ep2 , const struct attrmap * map , size_t nmap ) {ND_TCHECK ( p [ 0 ] ) ;}if ( ep2 < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;ND_PRINT ( ( ndo , ""value="" ) ) ;v = EXTRACT_16BITS ( & p [ 2 ] ) ;else rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , totlen - 4 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}return p + totlen ;trunc : return NULL ;}",4432
423,"if ( cid <= 0 )  continue ;dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( dctx -> remaining <= 0 ) {dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( dctx -> remaining <= 0 )   return dctx -> remaining ;}","int remaining ;if ( cid <= 0 ) continue ;remaining = avpriv_dnxhd_get_frame_size ( cid ) ;if ( remaining <= 0 ) {dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ;if ( remaining <= 0 ) return dctx -> remaining ;}",4433
424,"domount :  if ( mount ( ""proc"" , path , ""proc"" , 0 , NULL ) )  return - 1 ;","domount : if ( safe_mount ( ""proc"" , path , ""proc"" , 0 , NULL , rootfs ) < 0 ) return - 1 ;",4434
425,"if ( readonly &&  ( ( flags & O_ACCMODE ) == O_WRONLY ||   ( flags & O_ACCMODE ) == O_RDWR ) ) {verbose ( ""Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode"" ) ;","if ( readonly && ( ( flags & O_ACCMODE ) != O_RDONLY || ( flags & O_ACCMODE ) == O_RDWR ) ) {verbose ( ""Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode"" ) ;",4435
426,"if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) {giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data"" ) ;return - 1 ;}if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) {giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data"" ) ;return - 1 ;}GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ;res_dp = git__malloc ( alloc_sz ) ;GITERR_CHECK_ALLOC ( res_dp ) ;res_dp [ res_sz ] = \'\\\\0\' ;* out = res_dp ;* out_len = res_sz ;while ( delta < delta_end ) {unsigned char cmd = * delta ++ ;if ( cmd & 0x01 ) off = * delta ++ ;if ( cmd & 0x02 ) off |= * delta ++ << 8UL ;if ( cmd & 0x04 ) off |= * delta ++ << 16UL ;if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) ;if ( cmd & 0x10 ) len = * delta ++ ;if ( cmd & 0x20 ) len |= * delta ++ << 8UL ;if ( cmd & 0x40 ) len |= * delta ++ << 16UL ;if ( ! len ) len = 0x10000 ;if ( base_len < off + len || res_sz < len ) goto fail ;","# define ADD_DELTA ( o , shift ) {if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ ;if ( cmd & 0x01 ) off = * delta ++ ;if ( cmd & 0x02 ) off |= * delta ++ << 8UL ;if ( cmd & 0x04 ) off |= * delta ++ << 16UL ;if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) ;if ( cmd & 0x10 ) len = * delta ++ ;if ( cmd & 0x20 ) len |= * delta ++ << shift ) ;else goto fail ;}if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ;if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) ;if ( cmd & 0x40 ) ADD_DELTA ( len , 16UL ) ;if ( ! len ) len = 0x10000 ;# undef ADD_DELTA if ( base_len < off + len || res_sz < len ) goto fail ;",4436
427,"ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) ) ) ;if ( length > 2 ) {ND_PRINT ( ( ndo , ""/%u"" , EXTRACT_16BITS ( ptr ) ) ) ;}if ( length > 4 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length - 4 ) ;}}","if ( length == 0 ) return ;if ( length < 2 ) {ND_PRINT ( ( ndo , ""<S2SV_blank>AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ;return ;}ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) ) ) ;length -= 2 ;if ( length > 2 ) {ND_PRINT ( ( ndo , ""/%u"" , EXTRACT_16BITS ( ptr ) ) ) ;}if ( length == 0 ) return ;ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ;print_string ( ndo , ( const u_char * ) ptr , length ) ;}",4437
428,"uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm ,  KEY_ALLOC_IN_QUOTA ,  NULL , NULL ) ;","uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING | KEY_ALLOC_IN_QUOTA , NULL , NULL ) ;",4438
429,"session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm ,  KEY_ALLOC_IN_QUOTA ,  NULL , NULL ) ;","session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_UID_KEYRING | KEY_ALLOC_IN_QUOTA , NULL , NULL ) ;",4438
430,"outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>G"" , grayscale ) ;}outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>g"" , grayscale ) ;}}","sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>G"" , grayscale ) ;}sprintf ( outputbuffer , ""<S2SV_blank>%12.3f<S2SV_blank>g"" , grayscale ) ;}sendClean ( outputbuffer ) ;}",4439
431,"if ( par == STROKING ) {outpos += sprintf ( outpos , ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K"" ) ;else {}","if ( par == STROKING ) {send ( ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K"" ) ;else {}",4440
432,if ( inet -> opt && inet -> opt -> srr )  daddr = inet -> opt -> faddr ;,"struct ip_options_rcu * inet_opt ;inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ;if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ;",4441
433,"sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ;size = 8 ;sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ;size = 4 ;","snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ;size = 8 ;snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ;size = 4 ;",4442
434,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ;strasm = r_str_concat ( strasm , str ) ;","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i"" , vA ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ;strasm = r_str_concat ( strasm , str ) ;",4442
435,"# undef llint  sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;","# undef llint snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ;strasm = r_str_concat ( strasm , str ) ;",4442
436,"case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{break ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default :  sprintf ( str , ""<S2SV_blank>{}sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>{strasm = r_str_concat ( strasm , str ) ;case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default :  sprintf ( str , ""<S2SV_blank>{break ;sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}","case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , "",<S2SV_blank>[%04x]"" , vB ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{strasm = r_str_concat ( strasm , str ) ;case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;snprintf ( str , sizeof ( str ) , "",<S2SV_blank>[%04x]"" , vB ) ;strasm = r_str_concat ( strasm , str ) ;snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ;}",4442
437,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}",4442
438,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ;}",4442
439,"sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ;}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ;}",4442
440,"sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}sprintf ( str , ""<S2SV_blank>{}case 1 :  sprintf ( str , ""<S2SV_blank>{break ;case 2 :  sprintf ( str , ""<S2SV_blank>{break ;case 3 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;case 5 :  sprintf ( str , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f ,  ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ;default :  sprintf ( str , ""<S2SV_blank>{}sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;}sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ;}sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;}sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ;}","snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}case 1 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 2 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{break ;case 3 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ;case 4 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ;case 5 : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ;default : snprintf ( str , sizeof ( str ) , ""<S2SV_blank>{}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>%s<S2SV_blank>;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>class+%i"" , vB ) ;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>%s<S2SV_blank>;}snprintf ( str , sizeof ( str ) , "",<S2SV_blank>method+%i"" , vB ) ;}",4442
441,"skb_dst_force ( skb ) ;skb_queue_tail ( & sk -> sk_error_queue , skb ) ;","skb_set_err_queue ( skb ) ;skb_dst_force ( skb ) ;skb_queue_tail ( & sk -> sk_error_queue , skb ) ;",4443
442,"vpx_memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ;}","memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ;}",4444
443,"umode_t mode = inode -> i_mode ;rc = posix_acl_equiv_mode ( acl , & mode ) ;if ( rc < 0 ) return rc ;","umode_t mode ;rc = posix_acl_update_mode ( inode , & mode ) ;if ( rc < 0 ) return rc ;",4445
444,if ( rc == 0 )  acl = NULL ;,"
",4445
445,u32 data ;void * vapic ;vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ;data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ;kunmap_atomic ( vapic ) ;,"u32 data ;kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ;",4446
446,"lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ;lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ;cpuctx -> ctx . type = cpu_context ;cpuctx -> ctx . pmu = pmu ;",lockdep_set_class ( & cpuctx -> ctx . pmu = pmu ;,4447
447,"args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return xdr_argsize_check ( rqstp , p ) ;}","if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ;args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ;return 1 ;}",4448
448,}return 0 ;,return - ENOMEM ;}return 0 ;,4449
449,"sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length ,  sizeof ( * sun_pixels ) ) ;","sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length + image -> rows , sizeof ( * sun_pixels ) ) ;",4450
450,"status = dm9000ReadReg ( DM9000_REG_ISR ) ;if ( ( status & ISR_LNKCHG ) != 0 ) {dm9000WriteReg ( DM9000_REG_ISR , ISR_LNKCHG ) ;status = dm9000ReadReg ( DM9000_REG_NSR ) ;if ( ( status & NSR_LINKST ) != 0 ) {status = dm9000ReadReg ( DM9000_REG_NCR ) ;if ( ( status & NCR_FDX ) != 0 ) {","status = dm9000ReadReg ( DM9000_ISR ) ;if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) {dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG ) ;status = dm9000ReadReg ( DM9000_NSR ) ;if ( ( status & DM9000_NSR_LINKST ) != 0 ) {if ( ( status & DM9000_NSR_SPEED ) != 0 ) {status = dm9000ReadReg ( DM9000_NCR ) ;if ( ( status & DM9000_NCR_FDX ) != 0 ) {",4451
451,"if ( ( status & ISR_PR ) != 0 )  {dm9000WriteReg ( DM9000_REG_ISR , ISR_PR ) ;do {dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR | IMR_LNKCHGI | IMR_PTI | IMR_PRI ) ;}","if ( ( status & DM9000_ISR_PR ) != 0 ) {dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PR ) ;do {dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI ) ;}",4451
452,"int index , count , i ;if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ;","unsigned int index , count , i ;if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ;",4452
453,"int index , count , i ;u8 red , green , blue ;","unsigned int index , count , i ;u8 red , green , blue ;",4452
454,"u32 hash , id ;net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ;hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ;id = ip_idents_reserve ( hash , 1 ) ;fhdr -> identification = htonl ( id ) ;","static u32 ip6_idents_hashrnd_extra __read_mostly ;u32 hash , id ;net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ;net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra ) ) ;hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ;hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ;id = ip_idents_reserve ( hash , 1 ) ;fhdr -> identification = htonl ( id ) ;",4453
455,if ( p -> question -> n_keys != 1 )  return 0 ;,if ( ! p -> question ) return 0 ;if ( p -> question -> n_keys != 1 ) return 0 ;,4454
456,retval = xfs_attr_shortform_lookup ( args ) ;if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) {return retval ;else if ( retval == - EEXIST ) {if ( args -> flags & ATTR_CREATE ) return retval ;retval = xfs_attr_shortform_remove ( args ) ;ASSERT ( retval == 0 ) ;},if ( retval ) return retval ;args -> flags &= ~ ATTR_REPLACE ;,4455
457,"static void encode_b_rt ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row , int mi_col ,  int output_enabled , BLOCK_SIZE bsize ) {MACROBLOCK * const x = & cpi -> mb ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index > 0 ) return ;set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;update_state_rt ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ) ;encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ;update_stats ( cpi ) ;( * tp ) -> token = EOSB_TOKEN ;","static void encode_b_rt ( VP9_COMP * cpi , ThreadData * td , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {MACROBLOCK * const x = & td -> mb ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index > 0 ) return ;set_offsets ( cpi , td , ctx , mi_row , mi_col , bsize ) ;# if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && output_enabled && cpi -> common . frame_type != KEY_FRAME ) {vp9_denoiser_denoise ( & cpi -> denoiser , x , mi_row , mi_col , MAX ( BLOCK_8X8 , bsize ) , ctx ) ;}# endif update_state_rt ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ) ;encode_superblock ( cpi , td , tp , output_enabled , mi_row , mi_col , bsize , ctx ) ;update_stats ( & cpi -> common , td ) ;( * tp ) -> token = EOSB_TOKEN ;",4456
458,"u32 i , j , page_count = 0 , sg_per_table ;struct rd_dev_sg_table * sg_table ;struct page * pg ;struct scatterlist * sg ;sg_table = rd_dev -> sg_table_array ;for ( i = 0 ;sg = sg_table [ i ] . sg_table ;",u32 page_count ;sg_table = rd_dev -> sg_table_array ;for ( i = 0 ;sg = sg_table [ i ] . sg_table ;,4457
459,kfree ( sg_table ) ;rd_dev -> sg_table_array = NULL ;rd_dev -> sg_table_count = 0 ;,"kfree ( sg_table ) ;rd_dev -> sg_table_array , rd_dev -> sg_table_count = 0 ;",4457
460,"if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {dptr = & xargs -> tktpolicydn ;","arg = ( arg != NULL ) ? arg : """" ;if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {dptr = & xargs -> tktpolicydn ;",4458
461,auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;,"if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) {kfree_skb ( chunk -> auth_chunk ) ;sctp_association_free ( new_asoc ) ;return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ;}auth . skb = chunk -> auth_chunk ;auth . asoc = chunk -> asoc ;",4459
462,"static int64_t rd_pick_intra4x4block ( VP9_COMP * cpi , MACROBLOCK * x , int ib ,  MB_PREDICTION_MODE * best_mode , const int * bmode_costs , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , int * bestrate , int * bestratey , int64_t * bestdistortion , BLOCK_SIZE bsize , int64_t rd_thresh ) {MB_PREDICTION_MODE mode ;MACROBLOCKD * const xd = & x -> e_mbd ;const uint8_t * src_init = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , ib ,  src_stride ) ] ;uint8_t * dst_init = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , ib ,  dst_stride ) ] ;assert ( ib < 4 ) ;vpx_memcpy ( ta , a , sizeof ( ta ) ) ;vpx_memcpy ( tl , l , sizeof ( tl ) ) ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;for ( mode = DC_PRED ;","static int64_t rd_pick_intra4x4block ( VP9_COMP * cpi , MACROBLOCK * x , int row , int col , PREDICTION_MODE * best_mode , const int * bmode_costs , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , int * bestrate , int * bestratey , int64_t * bestdistortion , BLOCK_SIZE bsize , int64_t rd_thresh ) {PREDICTION_MODE mode ;MACROBLOCKD * const xd = & x -> e_mbd ;const uint8_t * src_init = & p -> src . buf [ row * 4 * src_stride + col * 4 ] ;uint8_t * dst_init = & pd -> dst . buf [ row * 4 * src_stride + col * 4 ] ;# if CONFIG_VP9_HIGHBITDEPTH uint16_t best_dst16 [ 8 * 8 ] ;# endif memcpy ( ta , a , sizeof ( ta ) ) ;memcpy ( tl , l , sizeof ( tl ) ) ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {for ( mode = DC_PRED ;",4460
463,"vpx_memcpy ( tempa , ta , sizeof ( ta ) ) ;vpx_memcpy ( templ , tl , sizeof ( tl ) ) ;for ( idy = 0 ;const int block = ib + idy * 2 + idx ;const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ;int16_t * const src_diff = raster_block_offset_int16 ( BLOCK_8X8 , block ,  p -> src_diff ) ;int16_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ;xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ;vp9_predict_intra_block ( xd , block , 1 ,  TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride ,  dst , dst_stride , idx , idy , 0 ) ;vp9_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ;if ( xd -> lossless ) {vp9_fwht4x4 ( src_diff , coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd )  goto next ;vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride ,  p -> eobs [ block ] ) ;}vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) ,   16 , & unused ) >> 2 ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd )  goto next ;vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) ,  dst , dst_stride , p -> eobs [ block ] ) ;}","memcpy ( tempa , ta , sizeof ( ta ) ) ;memcpy ( templ , tl , sizeof ( tl ) ) ;for ( idy = 0 ;const int block = ( row + idy ) * 2 + idx ;const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ;int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ;tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ;xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ;vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ;vpx_highbd_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride , xd -> bd ) ;if ( xd -> lossless ) {vp9_highbd_fwht4x4 ( src_diff , coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next_highbd ;vp9_highbd_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] , xd -> bd ) ;}if ( tx_type == DCT_DCT ) vpx_highbd_fdct4x4 ( src_diff , coeff , 8 ) ;else vp9_highbd_fht4x4 ( src_diff , coeff , 8 , tx_type ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;distortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused , xd -> bd ) >> 2 ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next_highbd ;vp9_highbd_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] , xd -> bd ) ;}",4460
464,"vpx_memcpy ( a , tempa , sizeof ( tempa ) ) ;vpx_memcpy ( l , templ , sizeof ( templ ) ) ;for ( idy = 0 ;++ idy )  vpx_memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride ,   num_4x4_blocks_wide * 4 ) ;}next :  {++ idy )  vpx_memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 ,   num_4x4_blocks_wide * 4 ) ;return best_rd ;}","memcpy ( a , tempa , sizeof ( tempa ) ) ;memcpy ( l , templ , sizeof ( templ ) ) ;for ( idy = 0 ;+ idy )  vpx_memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride ,   num_4x4_blocks_wide * 4 ) ;++ idy ) {memcpy ( best_dst16 + idy * 8 , CONVERT_TO_SHORTPTR ( dst_init + idy * dst_stride ) , num_4x4_blocks_wide * 4 * sizeof ( uint16_t ) ) ;}}next_highbd : {+ idy )  vpx_memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 ,   num_4x4_blocks_wide * 4 ) ;++ idy ) {memcpy ( CONVERT_TO_SHORTPTR ( dst_init + idy * dst_stride ) , best_dst16 + idy * 8 , num_4x4_blocks_wide * 4 * sizeof ( uint16_t ) ) ;}return best_rd ;}# endif for ( mode = DC_PRED ;mode <= TM_PRED ;++ mode ) {int64_t this_rd ;int ratey = 0 ;int64_t distortion = 0 ;int rate = bmode_costs [ mode ] ;if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) continue ;if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) {if ( conditional_skipintra ( mode , * best_mode ) ) continue ;}memcpy ( tempa , ta , sizeof ( ta ) ) ;memcpy ( templ , tl , sizeof ( tl ) ) ;for ( idy = 0 ;idy < num_4x4_blocks_high ;++ idy ) {for ( idx = 0 ;idx < num_4x4_blocks_wide ;++ idx ) {const int block = ( row + idy ) * 2 + ( col + idx ) ;const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ;uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ;int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ;tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ;xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ;vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ;vpx_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ;if ( xd -> lossless ) {const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ;vp9_fwht4x4 ( src_diff , coeff , 8 ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ;vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ;}else {int64_t unused ;const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ;const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ;vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ;vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ;ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ;distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused ) >> 2 ;if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ;vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ;}}}rate += ratey ;this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ;if ( this_rd < best_rd ) {* bestrate = rate ;* bestratey = ratey ;* bestdistortion = distortion ;best_rd = this_rd ;* best_mode = mode ;memcpy ( a , tempa , sizeof ( tempa ) ) ;memcpy ( l , templ , sizeof ( templ ) ) ;for ( idy = 0 ;idy < num_4x4_blocks_high * 4 ;++ idy ) memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , num_4x4_blocks_wide * 4 ) ;}next : {}}if ( best_rd >= rd_thresh || x -> skip_encode ) return best_rd ;for ( idy = 0 ;idy < num_4x4_blocks_high * 4 ;++ idy ) memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , num_4x4_blocks_wide * 4 ) ;return best_rd ;}",4460
465,"static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb )  {if ( get_bits1 ( gb ) ) {for ( i = 0 ;","static int read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) {if ( get_bits1 ( gb ) ) {if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ;for ( i = 0 ;",4461
466,"for ( i = 0 ;get_bits ( gb , 8 ) ;if ( get_bits1 ( gb ) ) {for ( i = 0 ;","if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ;for ( i = 0 ;get_bits ( gb , 8 ) ;if ( get_bits1 ( gb ) ) {if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ;for ( i = 0 ;",4461
467,"for ( i = 0 ;get_bits ( gb , 8 ) ;}","if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ;for ( i = 0 ;get_bits ( gb , 8 ) ;return 0 ;}",4461
468,vp9_free_frame_buffers ( cm ) ;vp9_free_internal_frame_buffers ( & cm -> int_frame_buffers ) ;},vp9_free_context_buffers ( cm ) ;vpx_free ( cm -> fc ) ;cm -> fc = NULL ;vpx_free ( cm -> frame_contexts ) ;cm -> frame_contexts = NULL ;},4462
469,if ( po -> fanout )   return - EINVAL ;lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;,lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;rcu_read_lock ( ) ;if ( po -> fanout ) {ret = - EINVAL ;lock_sock ( sk ) ;spin_lock ( & po -> bind_lock ) ;,4463
470,"sum = icmp6_cksum ( ndo , ip , dp , length ) ;if ( sum != 0 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>icmp6<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>-><S2SV_blank>0x%04x!]<S2SV_blank>"" , udp_sum , in_cksum_shouldbe ( udp_sum , sum ) ) ) ;","sum = icmp6_cksum ( ndo , ""%s"" , icmp6_tstr ) ) ;",4464
471,"trunc :  ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}","trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ;}",4464
472,"int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) {FILE * f = input_ctx -> file ;","static int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) {FILE * f = input_ctx -> file ;",4465
473,BUG_ON ( ! io ) ;iput ( io -> inode ) ;,BUG_ON ( ! io ) ;if ( io -> page ) put_page ( io -> page ) ;iput ( io -> inode ) ;,4466
474,"struct kvm_arch * ka = & v -> kvm -> arch ;void * shared_kaddr ;s64 kernel_ns , max_kernel_ns ;struct pvclock_vcpu_time_info * guest_hv_clock ;u8 pvclock_flags ;","s64 kernel_ns , max_kernel_ns ;struct pvclock_vcpu_time_info * guest_hv_clock ;u8 pvclock_flags ;",4467
475,if ( ! vcpu -> time_page )  return 0 ;,if ( ! vcpu -> pv_time_enabled ) return 0 ;,4467
476,"shared_kaddr = kmap_atomic ( vcpu -> time_page ) ;guest_hv_clock = shared_kaddr + vcpu -> time_offset ;pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ;if ( vcpu -> pvclock_set_guest_stopped_request ) {memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock ,  sizeof ( vcpu -> hv_clock ) ) ;kunmap_atomic ( shared_kaddr ) ;mark_page_dirty ( v -> kvm , vcpu -> time >> PAGE_SHIFT ) ;","if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 ;pvclock_flags = ( guest_hv_clock . flags & PVCLOCK_GUEST_STOPPED ) ;if ( vcpu -> pvclock_set_guest_stopped_request ) {kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , & vcpu -> hv_clock , sizeof ( vcpu -> hv_clock ) ) ;",4467
477,"case 2 :  # line 105 ""re_grammar.y""  {# line 1340 ""re_grammar.c""  break ;case 4 :  # line 114 ""re_grammar.y""  {# line 1348 ""re_grammar.c""  break ;case 5 :  # line 118 ""re_grammar.y""  {( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1363 ""re_grammar.c""  break ;case 6 :  # line 129 ""re_grammar.y""  {node = yr_re_node_create ( RE_NODE_EMPTY , NULL , NULL ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ;# line 1382 ""re_grammar.c""  break ;case 7 :  # line 147 ""re_grammar.y""  {# line 1390 ""re_grammar.c""  break ;case 8 :  # line 151 ""re_grammar.y""  {# line 1402 ""re_grammar.c""  break ;case 9 :  # line 162 ""re_grammar.y""  {","case 2 : # line 113 ""re_grammar.y"" {# line 1348 ""re_grammar.c"" break ;case 4 : # line 122 ""re_grammar.y"" {# line 1356 ""re_grammar.c"" break ;case 5 : # line 126 ""re_grammar.y"" {incr_ast_levels ( ) ;( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ;# line 1372 ""re_grammar.c"" break ;case 6 : # line 138 ""re_grammar.y"" {incr_ast_levels ( ) ;node = yr_re_node_create ( RE_NODE_EMPTY , NULL , NULL ) ;DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ;# line 1392 ""re_grammar.c"" break ;case 7 : # line 157 ""re_grammar.y"" {# line 1400 ""re_grammar.c"" break ;case 8 : # line 161 ""re_grammar.y"" {incr_ast_levels ( ) ;# line 1414 ""re_grammar.c"" break ;case 9 : # line 174 ""re_grammar.y"" {",4468
478,"# line 1420 ""re_grammar.c""  break ;case 10 :  # line 176 ""re_grammar.y""  {","# line 1432 ""re_grammar.c"" break ;case 10 : # line 188 ""re_grammar.y"" {",4468
479,"# line 1440 ""re_grammar.c""  break ;case 11 :  # line 192 ""re_grammar.y""  {","# line 1452 ""re_grammar.c"" break ;case 11 : # line 204 ""re_grammar.y"" {",4468
480,"# line 1458 ""re_grammar.c""  break ;case 12 :  # line 206 ""re_grammar.y""  {","# line 1470 ""re_grammar.c"" break ;case 12 : # line 218 ""re_grammar.y"" {",4468
481,"# line 1478 ""re_grammar.c""  break ;case 13 :  # line 222 ""re_grammar.y""  {","# line 1490 ""re_grammar.c"" break ;case 13 : # line 234 ""re_grammar.y"" {",4468
482,"# line 1505 ""re_grammar.c""  break ;case 14 :  # line 245 ""re_grammar.y""  {","# line 1517 ""re_grammar.c"" break ;case 14 : # line 257 ""re_grammar.y"" {",4468
483,"# line 1533 ""re_grammar.c""  break ;case 15 :  # line 269 ""re_grammar.y""  {","# line 1545 ""re_grammar.c"" break ;case 15 : # line 281 ""re_grammar.y"" {",4468
484,"# line 1559 ""re_grammar.c""  break ;case 16 :  # line 291 ""re_grammar.y""  {","# line 1571 ""re_grammar.c"" break ;case 16 : # line 303 ""re_grammar.y"" {",4468
485,"# line 1586 ""re_grammar.c""  break ;case 17 :  # line 314 ""re_grammar.y""  {# line 1594 ""re_grammar.c""  break ;case 18 :  # line 318 ""re_grammar.y""  {# line 1604 ""re_grammar.c""  break ;case 19 :  # line 324 ""re_grammar.y""  {# line 1614 ""re_grammar.c""  break ;case 20 :  # line 330 ""re_grammar.y""  {# line 1624 ""re_grammar.c""  break ;case 21 :  # line 336 ""re_grammar.y""  {# line 1634 ""re_grammar.c""  break ;case 22 :  # line 345 ""re_grammar.y""  {# line 1642 ""re_grammar.c""  break ;case 23 :  # line 349 ""re_grammar.y""  {# line 1652 ""re_grammar.c""  break ;case 24 :  # line 355 ""re_grammar.y""  {# line 1664 ""re_grammar.c""  break ;case 25 :  # line 363 ""re_grammar.y""  {# line 1674 ""re_grammar.c""  break ;case 26 :  # line 369 ""re_grammar.y""  {# line 1684 ""re_grammar.c""  break ;case 27 :  # line 375 ""re_grammar.y""  {# line 1694 ""re_grammar.c""  break ;case 28 :  # line 381 ""re_grammar.y""  {# line 1704 ""re_grammar.c""  break ;case 29 :  # line 387 ""re_grammar.y""  {# line 1714 ""re_grammar.c""  break ;case 30 :  # line 393 ""re_grammar.y""  {# line 1724 ""re_grammar.c""  break ;case 31 :  # line 399 ""re_grammar.y""  {# line 1736 ""re_grammar.c""  break ;# line 1740 ""re_grammar.c""  default : break ;","# line 1598 ""re_grammar.c"" break ;case 17 : # line 326 ""re_grammar.y"" {# line 1606 ""re_grammar.c"" break ;case 18 : # line 330 ""re_grammar.y"" {# line 1616 ""re_grammar.c"" break ;case 19 : # line 336 ""re_grammar.y"" {# line 1626 ""re_grammar.c"" break ;case 20 : # line 342 ""re_grammar.y"" {# line 1636 ""re_grammar.c"" break ;case 21 : # line 348 ""re_grammar.y"" {# line 1646 ""re_grammar.c"" break ;case 22 : # line 357 ""re_grammar.y"" {incr_ast_levels ( ) ;# line 1656 ""re_grammar.c"" break ;case 23 : # line 363 ""re_grammar.y"" {# line 1666 ""re_grammar.c"" break ;case 24 : # line 369 ""re_grammar.y"" {# line 1678 ""re_grammar.c"" break ;case 25 : # line 377 ""re_grammar.y"" {# line 1688 ""re_grammar.c"" break ;case 26 : # line 383 ""re_grammar.y"" {# line 1698 ""re_grammar.c"" break ;case 27 : # line 389 ""re_grammar.y"" {# line 1708 ""re_grammar.c"" break ;case 28 : # line 395 ""re_grammar.y"" {# line 1718 ""re_grammar.c"" break ;case 29 : # line 401 ""re_grammar.y"" {# line 1728 ""re_grammar.c"" break ;case 30 : # line 407 ""re_grammar.y"" {# line 1738 ""re_grammar.c"" break ;case 31 : # line 413 ""re_grammar.y"" {# line 1750 ""re_grammar.c"" break ;# line 1740 ""re_grammar.c"" default : break ;",4468
486,"u32 now ;if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ;challenge_timestamp = now ;challenge_count = 0 ;}if ( ++ challenge_count <= sysctl_tcp_challenge_ack_limit ) {","u32 count , now ;if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ;u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ;challenge_timestamp = now ;WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ;}count = READ_ONCE ( challenge_count ) ;if ( count > 0 ) {WRITE_ONCE ( challenge_count , count - 1 ) ;",4469
487,"err = tfm -> seed ( tfm , seed , slen ) ;kfree ( buf ) ;","err = crypto_rng_alg ( tfm ) -> seed ( tfm , seed , slen ) ;kfree ( buf ) ;",4470
488,update_db_bp_intercept ( & svm -> vcpu ) ;},},4471
489,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( pool ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,4472
490,"static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk ,  int tstype )  {int err ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {","static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , int tstype , bool opt_stats ) {int err ;BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) ;serr = SKB_EXT_ERR ( skb ) ;serr -> ee . ee_info = tstype ;serr -> opt_stats = opt_stats ;if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) {",4473
491,switch ( c = ( * dis_getc ) ( stream ) )  {,"if ( count >= dis_umaxd ) {if ( count > dis_umaxd ) goto overflow ;if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ;}switch ( c = ( * dis_getc ) ( stream ) ) {",4474
492,},dc -> vmsd = & vmstate_stellaris_enet ;},4475
493,"void vp9_first_pass ( VP9_COMP * cpi ) {int mb_row , mb_col ;MACROBLOCK * const x = & cpi -> mb ;VP9_COMMON * const cm = & cpi -> common ;const PICK_MODE_CONTEXT * ctx = & x -> sb64_context ;int i ;YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ;int recon_y_stride = lst_yv12 -> y_stride ;int recon_uv_stride = lst_yv12 -> uv_stride ;int uv_mb_height = 16 >> ( lst_yv12 -> y_height > lst_yv12 -> uv_height ) ;int64_t coded_error = 0 ;","void vp9_first_pass ( VP9_COMP * cpi , const struct lookahead_entry * source ) {int mb_row , mb_col ;MACROBLOCK * const x = & cpi -> td . mb ;VP9_COMMON * const cm = & cpi -> common ;const PICK_MODE_CONTEXT * ctx = & cpi -> td . pc_root -> none ;int i ;const int64_t coded_error = 0 ;",4476
494,"int intrapenalty = 256 ;int neutral_count = 0 ;int new_mv_count = 0 ;int sum_in_vectors = 0 ;uint32_t lastmv_as_int = 0 ;struct twopass_rc * twopass = & cpi -> twopass ;const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ;vp9_clear_system_state ( ) ;if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) {MV_REFERENCE_FRAME ref_frame = LAST_FRAME ;twopass = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . twopass ;scaled_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ;ref_frame = LAST_FRAME ;else if ( cpi -> ref_frame_flags & VP9_ALT_FLAG ) {scaled_ref_buf = vp9_get_scaled_ref_frame ( cpi , ALTREF_FRAME ) ;ref_frame = ALTREF_FRAME ;if ( scaled_ref_buf != NULL ) {first_ref_buf = scaled_ref_buf ;recon_y_stride = first_ref_buf -> y_stride ;recon_uv_stride = first_ref_buf -> uv_stride ;uv_mb_height = 16 >> ( first_ref_buf -> y_height > first_ref_buf -> uv_height ) ;set_ref_ptrs ( cm , xd , ref_frame , NONE ) ;vp9_setup_dst_planes ( xd , new_yv12 , 0 , 0 ) ;vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ;","int intrapenalty = 256 ;int neutral_count = 0 ;MV lastmv = {0 , 0 };int recon_y_stride , recon_uv_stride , uv_mb_height ;YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ;TWO_PASS * twopass = & cpi -> twopass ;const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ;LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . number_temporal_layers == 1 ) {MV_REFERENCE_FRAME ref_frame = LAST_FRAME ;twopass = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : NULL ;double intra_factor ;double brightness_factor ;BufferPool * const pool = cm -> buffer_pool ;assert ( new_yv12 != NULL ) ;assert ( ( lc != NULL ) || frame_is_intra_only ( cm ) || ( lst_yv12 != NULL ) ) ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {vp9_zero_array ( cpi -> twopass . frame_mb_stats_buf , cm -> initial_mbs ) ;}# endif vpx_clear_system_state ( ) ;intra_factor = 0.0 ;brightness_factor = 0.0 ;neutral_count = 0.0 ;set_first_pass_params ( cpi ) ;vp9_set_quantizer ( cm , find_fp_qindex ( cm -> bit_depth ) ) ;if ( lc != NULL ) {twopass = & lc -> twopass ;cpi -> lst_fb_idx = cpi -> svc . spatial_layer_id ;cpi -> ref_frame_flags = VP9_LAST_FLAG ;if ( cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id < REF_FRAMES ) {cpi -> gld_fb_idx = cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id ;cpi -> ref_frame_flags |= VP9_GOLD_FLAG ;cpi -> refresh_golden_frame = ( lc -> current_video_frame_in_layer == 0 ) ;}else {cpi -> refresh_golden_frame = 0 ;}if ( lc -> current_video_frame_in_layer == 0 ) cpi -> ref_frame_flags = 0 ;first_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ;if ( first_ref_buf == NULL ) first_ref_buf = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;if ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) {gld_yv12 = vp9_get_scaled_ref_frame ( cpi , GOLDEN_FRAME ) ;if ( gld_yv12 == NULL ) {gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ;else {set_ref_ptrs ( cm , xd , ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ? LAST_FRAME : NONE , ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ? GOLDEN_FRAME : NONE ) ;cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , & cpi -> scaled_source ) ;}vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ;recon_y_stride = new_yv12 -> y_stride ;recon_uv_stride = new_yv12 -> uv_stride ;uv_mb_height = 16 >> ( new_yv12 -> y_height > new_yv12 -> uv_height ) ;vp9_setup_dst_planes ( xd -> plane , new_yv12 , 0 , 0 ) ;if ( ! frame_is_intra_only ( cm ) ) {}",4476
495,for ( mb_row = 0 ;int_mv best_ref_mv ;best_ref_mv . as_int = 0 ;,"for ( mb_row = 0 ;MV best_ref_mv = {0 , 0 };",4476
496,"double error_weight = 1.0 ;const BLOCK_SIZE bsize = get_bsize ( cm , mb_row , mb_col ) ;vp9_clear_system_state ( ) ;xd -> plane [ 0 ] . dst . buf = new_yv12 -> y_buffer + recon_yoffset ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {const int energy = vp9_block_energy ( cpi , x , bsize ) ;error_weight = vp9_vaq_inv_q_ratio ( energy ) ;this_error = vp9_encode_intra ( x , use_dc_pred ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;this_error = ( int ) ( this_error * error_weight ) ;intra_error += ( int64_t ) this_error ;x -> mv_col_min = - ( ( mb_col * 16 ) + BORDER_MV_PIXELS_B16 ) ;if ( cm -> current_video_frame > 0 ) {int tmp_err , motion_error ;int_mv mv , tmp_mv ;motion_error = zz_motion_search ( x ) ;mv . as_int = tmp_mv . as_int = 0 ;first_pass_motion_search ( cpi , x , & best_ref_mv . as_mv , & mv . as_mv , & motion_error ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;motion_error = ( int ) ( motion_error * error_weight ) ;if ( best_ref_mv . as_int ) {tmp_err = INT_MAX ;first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv , & tmp_err ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;tmp_err = ( int ) ( tmp_err * error_weight ) ;mv . as_int = tmp_mv . as_int ;}if ( cm -> current_video_frame > 1 && gld_yv12 != NULL ) {int gf_motion_error ;gf_motion_error = zz_motion_search ( x ) ;first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv ,  & gf_motion_error ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;","const BLOCK_SIZE bsize = get_bsize ( cm , mb_row , mb_col ) ;double log_intra ;int level_sample ;# if CONFIG_FP_MB_STATS const int mb_index = mb_row * cm -> mb_cols + mb_col ;# endif vpx_clear_system_state ( ) ;xd -> plane [ 0 ] . dst . buf = new_yv12 -> y_buffer + recon_yoffset ;x -> skip_encode = 0 ;xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ;xd -> mi [ 0 ] -> mbmi . tx_size = use_dc_pred ? ( bsize >= BLOCK_16X16 ? TX_16X16 : TX_8X8 ) : TX_4X4 ;vp9_encode_intra_block_plane ( x , bsize , 0 ) ;this_error = vpx_get_mb_ss ( x -> plane [ 0 ] . src_diff ) ;if ( this_error < UL_INTRA_THRESH ) {++ intra_skip_count ;else if ( ( mb_col > 0 ) && ( image_data_start_row == INVALID_ROW ) ) {image_data_start_row = mb_row ;}# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) {switch ( cm -> bit_depth ) {case VPX_BITS_8 : break ;case VPX_BITS_10 : this_error >>= 4 ;break ;case VPX_BITS_12 : this_error >>= 8 ;break ;default : assert ( 0 && ""cm->bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>"" ""VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ;return ;}# endif vpx_clear_system_state ( ) ;log_intra = log ( this_error + 1.0 ) ;if ( log_intra < 10.0 ) intra_factor += 1.0 + ( ( 10.0 - log_intra ) * 0.05 ) ;else intra_factor += 1.0 ;# if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) level_sample = CONVERT_TO_SHORTPTR ( x -> plane [ 0 ] . src . buf ) [ 0 ] ;else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ;# else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ;# endif if ( ( level_sample < DARK_THRESH ) && ( log_intra < 9.0 ) ) brightness_factor += 1.0 + ( 0.01 * ( DARK_THRESH - level_sample ) ) ;else brightness_factor += 1.0 ;intra_error += ( int64_t ) this_error ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ;}# endif x -> mv_col_min = - ( ( mb_col * 16 ) + BORDER_MV_PIXELS_B16 ) ;if ( ( lc == NULL && cm -> current_video_frame > 0 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 0 ) ) {int tmp_err , motion_error , raw_motion_error ;MV mv = {0 , 0 }, tmp_mv = {0 , 0 };struct buf_2d unscaled_last_source_buf_2d ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ;else {motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ;}# else motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ;# endif unscaled_last_source_buf_2d . buf = cpi -> unscaled_last_source -> y_buffer + recon_yoffset ;unscaled_last_source_buf_2d . stride = cpi -> unscaled_last_source -> y_stride ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {raw_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d , xd -> bd ) ;}else {raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ;# else raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ;# endif if ( raw_motion_error > 25 || lc != NULL ) {first_pass_motion_search ( cpi , x , & best_ref_mv , & mv , & motion_error ) ;if ( ! is_zero_mv ( & best_ref_mv ) ) {tmp_err = INT_MAX ;first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & tmp_err ) ;mv = tmp_mv ;}if ( ( ( lc == NULL && cm -> current_video_frame > 1 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 1 ) ) && gld_yv12 != NULL ) {int gf_motion_error ;# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {gf_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ;}else {gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ;}# else gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ;# endif first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & gf_motion_error ) ;if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) {vp9_clear_system_state ( ) ;",4476
497,best_ref_mv . as_int = 0 ;if ( motion_error <= this_error ) {if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) &&   this_error < 2 * intrapenalty )   ++ neutral_count ;mv . as_mv . row *= 8 ;mv . as_mv . col *= 8 ;this_error = motion_error ;xd -> mi [ 0 ] -> mbmi . mode = NEWMV ;xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = mv ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;sum_mvr += mv . as_mv . row ;sum_mvr_abs += abs ( mv . as_mv . row ) ;sum_mvc += mv . as_mv . col ;sum_mvc_abs += abs ( mv . as_mv . col ) ;sum_mvrs += mv . as_mv . row * mv . as_mv . row ;sum_mvcs += mv . as_mv . col * mv . as_mv . col ;++ intercount ;best_ref_mv . as_int = mv . as_int ;if ( mv . as_int ) {++ mvcount ;if ( mv . as_int != lastmv_as_int )  ++ new_mv_count ;lastmv_as_int = mv . as_int ;if ( mb_row < cm -> mb_rows / 2 ) {if ( mv . as_mv . row > 0 )  -- sum_in_vectors ;else if ( mv . as_mv . row < 0 )  ++ sum_in_vectors ;if ( mv . as_mv . row > 0 )  ++ sum_in_vectors ;else if ( mv . as_mv . row < 0 )  -- sum_in_vectors ;if ( mv . as_mv . col > 0 )  -- sum_in_vectors ;else if ( mv . as_mv . col < 0 )  ++ sum_in_vectors ;if ( mv . as_mv . col > 0 )  ++ sum_in_vectors ;else if ( mv . as_mv . col < 0 )  -- sum_in_vectors ;,"}else {sr_coded_error += motion_error ;}best_ref_mv . row = 0 ;best_ref_mv . col = 0 ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ;cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_DCINTRA_MASK ;cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ;if ( this_error > FPMB_ERROR_LARGE_TH ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ;}else if ( this_error < FPMB_ERROR_SMALL_TH ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ;}}# endif if ( motion_error <= this_error ) {vpx_clear_system_state ( ) ;if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) && ( this_error < ( 2 * intrapenalty ) ) ) {neutral_count += 1.0 ;}else if ( ( this_error > NCOUNT_INTRA_THRESH ) && ( this_error < ( NCOUNT_INTRA_FACTOR * motion_error ) ) ) {neutral_count += ( double ) motion_error / DOUBLE_DIVIDE_CHECK ( ( double ) this_error ) ;}mv . row *= 8 ;mv . col *= 8 ;this_error = motion_error ;xd -> mi [ 0 ] . as_mv -> mbmi . mode = NEWMV ;xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = mv ;xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ;+ intercount ;+ mvcount ;sum_mvr += mv . row ;sum_mvr_abs += abs ( mv . row ) ;sum_mvc += mv . as_mv . col ;sum_mvc_abs += abs ( mv . col ) ;sum_mvrs += mv . as_mv . row * mv . row ;sum_mvcs += mv . as_mv . col * mv . col ;++ intercount ;best_ref_mv . as_int = mv . as_int ;if ( mv . as_mv . col > 0 && mv . as_mv . col >= abs ( mv . as_mv . row ) ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_RIGHT_MASK ;}else if ( mv . as_mv . row < 0 && abs ( mv . as_mv . row ) >= abs ( mv . as_mv . col ) ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_UP_MASK ;}else if ( mv . as_mv . col < 0 && abs ( mv . as_mv . col ) >= abs ( mv . as_mv . row ) ) {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_LEFT_MASK ;}else {cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_DOWN_MASK ;}}# endif if ( ! is_equal_mv ( & mv , & lastmv ) ) ++ new_mv_count ;lastmv = mv ;if ( mb_row < cm -> mb_rows / 2 ) {if ( mv . row > 0 ) -- sum_in_vectors ;else if ( mv . row < 0 ) ++ sum_in_vectors ;if ( mv . row > 0 ) ++ sum_in_vectors ;else if ( mv . row < 0 ) -- sum_in_vectors ;if ( mv . col > 0 ) -- sum_in_vectors ;else if ( mv . col < 0 ) ++ sum_in_vectors ;if ( mv . col > 0 ) ++ sum_in_vectors ;else if ( mv . col < 0 ) -- sum_in_vectors ;",4476
498,x -> plane [ 1 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - uv_mb_height * cm -> mb_cols ;x -> plane [ 2 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - uv_mb_height * cm -> mb_cols ;vp9_clear_system_state ( ) ;}vp9_clear_system_state ( ) ;fps . frame = cm -> current_video_frame ;fps . spatial_layer_id = cpi -> svc . spatial_layer_id ;fps . intra_error = ( double ) ( intra_error >> 8 ) ;fps . coded_error = ( double ) ( coded_error >> 8 ) ;fps . pcnt_inter = ( double ) intercount / cm -> MBs ;fps . pcnt_second_ref = ( double ) second_ref_count / cm -> MBs ;fps . pcnt_neutral = ( double ) neutral_count / cm -> MBs ;if ( mvcount > 0 ) {fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / mvcount ) ) / mvcount ;fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / mvcount ) ) / mvcount ;fps . mv_in_out_count = ( double ) sum_in_vectors / ( mvcount * 2 ) ;fps . pcnt_motion = ( double ) mvcount / cm -> MBs ;},"vpx_clear_system_state ( ) ;}if ( ( image_data_start_row > cm -> mb_rows / 2 ) || ( image_data_start_row == INVALID_ROW ) ) {image_data_start_row = cm -> mb_rows / 2 ;}if ( image_data_start_row > 0 ) {intra_skip_count = MAX ( 0 , intra_skip_count - ( image_data_start_row * cm -> mb_cols * 2 ) ) ;}fps . frame = cm -> current_video_frame ;fps . spatial_layer_id = cpi -> svc . spatial_layer_id ;fps . coded_error = ( double ) ( coded_error >> 8 ) + min_err ;fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) + min_err ;fps . intra_error = ( double ) ( intra_error >> 8 ) ;fps . coded_error = ( double ) ( coded_error >> 8 ) ;fps . pcnt_inter = ( double ) intercount / num_mbs ;fps . pcnt_second_ref = ( double ) second_ref_count / num_mbs ;fps . pcnt_neutral = ( double ) neutral_count / num_mbs ;fps . intra_skip_pct = ( double ) intra_skip_count / num_mbs ;fps . inactive_zone_rows = ( double ) image_data_start_row ;fps . inactive_zone_cols = ( double ) 0 ;if ( mvcount > 0 ) {fps . MVrv = ( ( double ) sum_mvrs - ( ( double ) sum_mvr * sum_mvr / mvcount ) ) / mvcount ;fps . MVcv = ( ( double ) sum_mvcs - ( ( double ) sum_mvc * sum_mvc / mvcount ) ) / mvcount ;fps . mv_in_out_count = ( double ) sum_in_vectors / ( mvcount * 2 ) ;fps . pcnt_motion = ( double ) mvcount / num_mbs ;}",4476
499,"fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ;twopass -> this_frame_stats = fps ;accumulate_stats ( & twopass -> total_stats , & fps ) ;}vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ;}if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) {vp9_update_reference_frames ( cpi ) ;swap_yv12 ( lst_yv12 , new_yv12 ) ;}vp9_extend_frame_borders ( lst_yv12 ) ;if ( cm -> current_video_frame == 0 && gld_yv12 != NULL ) {vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ;}","fps . duration = ( double ) ( source -> ts_end - cpi -> source -> ts_start ) ;twopass -> this_frame_stats = fps ;accumulate_stats ( & twopass -> total_stats , & fps ) ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {output_fpmb_stats ( twopass -> frame_mb_stats_buf , cm , cpi -> output_pkt_list ) ;}# endif }ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] ) ;}vpx_extend_frame_borders ( new_yv12 ) ;if ( lc != NULL ) {vp9_update_reference_frames ( cpi ) ;ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> lst_fb_idx ] , cm -> new_fb_idx ) ;}if ( cm -> current_video_frame == 0 && cpi -> gld_fb_idx != INVALID_IDX && lc == NULL ) {ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] ) ;}",4476
500,},if ( cpi -> use_svc ) vp9_inc_frame_in_layer ( cpi ) ;},4476
501,static const int16_t * filter = vp9_down2_symeven_half_filter ;const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) / 2 ;,const int16_t * filter = vp9_down2_symeven_half_filter ;const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) / 2 ;,4477
502,break ;case L2CAP_CR_PEND : l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_CONNECT_PEND ;,l2cap_pi ( sk ) -> num_conf_req ++ ;break ;case L2CAP_CR_PEND : l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_CONNECT_PEND ;,4478
503,"if ( user -> uid_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;","if ( user -> uid_keyring && user -> session_keyring ) {kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ;",4479
504,"int bson_check_string ( bson * b , const char * string ,  const int length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 0 , 0 ) ;","int bson_check_string ( bson * b , const char * string , const size_t length ) {return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 0 , 0 ) ;",4480
505,"efx -> mac_op -> update_stats ( efx ) ;memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ;","net_dev -> gso_max_segs = EFX_TSO_MAX_SEGS ;efx -> mac_op -> update_stats ( efx ) ;memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ;",4481
506,"static void encode_frame ( vpx_codec_ctx_t * codec ,  vpx_image_t * img , int frame_index ,  VpxVideoWriter * writer ) {vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {","static int encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img , int frame_index , VpxVideoWriter * writer ) {int got_pkts = 0 ;vpx_codec_iter_t iter = NULL ;while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) {got_pkts = 1 ;if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {",4482
507,},return got_pkts ;},4482
508,if ( default_IsEncrypted ) * default_IsEncrypted = GF_FALSE ;,if ( seig_entry && default_IsEncrypted ) * default_IsEncrypted = GF_FALSE ;,4483
509,if ( ! seig_entry -> key_info [ 0 ] )  seig_entry = NULL ;,if ( ! seig_entry -> key_info [ 0 ] ) seig_entry = NULL ;,4483
510,# endif  msg -> msg_namelen = 0 ;copied = data_skb -> len ;,# endif copied = data_skb -> len ;,4484
511,"for ( cnt = 0 , i = 0 ;cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;","for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;",4485
512,"
","if ( ( st32 ) verdef -> vd_next < 1 ) {eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\\break ;}",4485
513,i += verdef -> vd_next ;},i += verdef -> vd_next ;},4485
514,int size ;int depth = 0 ;,int size ;int base_size ;int depth = 0 ;,4486
515,"size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ;path = ( PATH * ) palloc ( size ) ;SET_VARSIZE ( path , size ) ;path -> npts = npts ;if ( ( ! path_decode ( TRUE , npts , s , & isopen , & s , & ( path -> p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == \'\\\\0\' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\\\""%s\\\\"""" , str ) ) ) ;","base_size = sizeof ( path -> p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ;size = offsetof ( PATH , p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == \'\\\\0\' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\\\""%s\\\\"""" , str ) ) ) ;",4486
516,"if ( size > INT_MAX )  size = INT_MAX ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;","if ( size > INT_MAX ) size = INT_MAX ;if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT ;sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ;",4487
517,static int  mptctl_gettargetinfo ( unsigned long arg )  {MPT_ADAPTER * ioc ;VirtDevice * vdevice ;int * pdata ;int iocnum ;,"static int mptctl_gettargetinfo ( MPT_ADAPTER * ioc , unsigned long arg ) {VirtDevice * vdevice ;int * pdata ;",4488
518,"return - EFAULT ;}if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) {printk ( KERN_DEBUG MYNAM ""%s::mptctl_gettargetinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\\return - ENODEV ;",return - EFAULT ;,4488
519,return in ;},return NULL ;},4489
520,"# ifdef HAVE_SECCOMP  if ( arg_seccomp_block_secondary )  copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ;","# ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;if ( arg_seccomp_block_secondary ) copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ;",4490
521,"static void prefetch_dec ( void )  {prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;","static void prefetch_dec ( void ) {dec_tables . counter_head ++ ;dec_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ;",4491
522,"hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset ,  src_fd . entrylength ) ;","if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) {err = - EIO ;goto out ;}hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , src_fd . entrylength ) ;",4492
523,"
",if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) {,4493
524,flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ;stream_id = flags & 0x7F ;,}flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ;stream_id = flags & 0x7F ;,4493
525,}if ( end - p >= 88 ) {,}if ( end - p >= 88 ) {,4493
526,}p += chunksize ;,"if ( chunksize > end - p ) {av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\\return AVERROR_INVALIDDATA ;}}p += chunksize ;",4493
527,"if ( ! authctxt -> valid ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;return 0 ;}","
",4494
528,"
","if ( ! authctxt -> valid || authctxt -> user == NULL ) {debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ;goto done ;}",4494
529,"if ( ( b = sshbuf_new ( ) ) == NULL )  fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ;","if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ;",4494
530,"SEPARATE_ZVAL ( var2 ) ;convert_to_double ( * var2 ) ;matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ;}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ;RETURN_FALSE ;}}","if ( Z_TYPE_PP ( var2 ) != IS_DOUBLE ) {zval dval ;dval = * * var ;zval_copy_ctor ( & dval ) ;convert_to_double ( & dval ) ;matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ;}else {matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ;}}php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ;RETURN_FALSE ;}}",4495
531,"static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type ,  u32 * mask ) {if ( IS_ERR ( algt ) )  return ;if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) )  * type |= CRYPTO_ALG_INTERNAL ;if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) )  * mask |= CRYPTO_ALG_INTERNAL ;","static inline bool mcryptd_check_internal ( struct rtattr * * tb , u32 * type , u32 * mask ) {if ( IS_ERR ( algt ) ) return false ;* type |= algt -> type & CRYPTO_ALG_INTERNAL ;* mask |= algt -> mask & CRYPTO_ALG_INTERNAL ;if ( * type & * mask & CRYPTO_ALG_INTERNAL ) return true ;else return false ;",4496
532,"MACROBLOCK * const x = & cpi -> mb ;VP9_COMMON * const cm = & cpi -> common ;xd -> mi = cm -> mi_grid_visible ;xd -> mi [ 0 ] = cm -> mi ;vp9_zero ( cm -> counts ) ;vp9_zero ( cpi -> coef_counts ) ;vp9_zero ( cpi -> tx_stepdown_count ) ;vp9_zero ( cpi -> rd_comp_pred_diff ) ;vp9_zero ( cpi -> rd_filter_diff ) ;vp9_zero ( cpi -> rd_tx_select_diff ) ;vp9_zero ( cpi -> rd_tx_select_threshes ) ;cm -> tx_mode = select_tx_mode ( cpi ) ;cpi -> mb . e_mbd . lossless = cm -> base_qindex == 0 && cm -> y_dc_delta_q == 0 && cm -> uv_dc_delta_q == 0 && cm -> uv_ac_delta_q == 0 ;switch_lossless_mode ( cpi , cpi -> mb . e_mbd . lossless ) ;vp9_frame_init_quantizer ( cpi ) ;vp9_initialize_rd_consts ( cpi ) ;vp9_initialize_me_consts ( cpi , cm -> base_qindex ) ;init_encode_frame_mb_context ( cpi ) ;if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM )  build_activity_map ( cpi ) ;cm -> prev_mi = get_prev_mi ( cm ) ;if ( sf -> use_nonrd_pick_mode ) {PICK_MODE_CONTEXT * ctx = & cpi -> mb . sb64_context ;for ( i = 0 ;","ThreadData * const td = & cpi -> td ;MACROBLOCK * const x = & td -> mb ;VP9_COMMON * const cm = & cpi -> common ;RD_COUNTS * const rdc = & cpi -> td . rd_counts ;xd -> mi = cm -> mi_grid_visible ;xd -> mi [ 0 ] = cm -> mi ;vp9_zero ( * td -> counts ) ;vp9_zero ( rdc -> coef_counts ) ;vp9_zero ( rdc -> comp_pred_diff ) ;vp9_zero ( cpi -> rd_comp_pred_diff ) ;vp9_zero ( rdc -> filter_diff ) ;xd -> lossless = cm -> base_qindex == 0 && cm -> y_dc_delta_q == 0 && cm -> uv_dc_delta_q == 0 && cm -> uv_ac_delta_q == 0 ;switch_lossless_mode ( cpi , cpi -> mb . e_mbd . lossless ) ;vp9_frame_init_quantizer ( cpi ) ;cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> intra_only && cm -> last_show_frame ;cm -> prev_mi = get_prev_mi ( cm ) ;if ( sf -> use_nonrd_pick_mode ) {PICK_MODE_CONTEXT * ctx = & cpi -> td . pc_root -> none ;for ( i = 0 ;",4497
533,"if ( cpi -> sf . partition_search_type == SOURCE_VAR_BASED_PARTITION &&  cm -> current_video_frame > 0 ) {int check_freq = cpi -> sf . search_type_check_frequency ;if ( ( cm -> current_video_frame - 1 ) % check_freq == 0 ) {cpi -> use_large_partition_rate = 0 ;}if ( ( cm -> current_video_frame - 1 ) % check_freq == 1 ) {const int mbs_in_b32x32 = 1 << ( ( b_width_log2_lookup [ BLOCK_32X32 ] - b_width_log2_lookup [ BLOCK_16X16 ] ) + ( b_height_log2_lookup [ BLOCK_32X32 ] - b_height_log2_lookup [ BLOCK_16X16 ] ) ) ;cpi -> use_large_partition_rate = cpi -> use_large_partition_rate * 100 * mbs_in_b32x32 / cm -> MBs ;}if ( ( cm -> current_video_frame - 1 ) % check_freq >= 1 ) {if ( cpi -> use_large_partition_rate < 15 ) cpi -> sf . partition_search_type = FIXED_PARTITION ;}}{int tile_col , tile_row ;const int tile_cols = 1 << cm -> log2_tile_cols ;const int tile_rows = 1 << cm -> log2_tile_rows ;","if ( cm -> frame_type != KEY_FRAME && cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) cpi -> ref_frame_flags &= ( ~ VP9_GOLD_FLAG ) ;if ( sf -> partition_search_type == SOURCE_VAR_BASED_PARTITION ) source_var_based_partition_search_method ( cpi ) ;{int tile_col , tile_row ;const int tile_cols = 1 << cm -> log2_tile_cols ;const int tile_rows = 1 << cm -> log2_tile_rows ;",4497
534,"if ( sf -> use_nonrd_pick_mode && cm -> frame_type != KEY_FRAME ) encode_nonrd_sb_row ( cpi , & tile , mi_row , & tp ) ;else  encode_rd_sb_row ( cpi , & tile , mi_row , & tp ) ;}cpi -> tok_count [ tile_row ] [ tile_col ] = ( unsigned int ) ( tp - tp_old ) ;assert ( tp - cpi -> tok <= get_token_alloc ( cm -> mb_rows , cm -> mb_cols ) ) ;}}}if ( sf -> skip_encode_sb ) {int j ;","if ( sf -> use_nonrd_pick_mode && cm -> frame_type != KEY_FRAME ) encode_nonrd_sb_row ( cpi , x , & tile , mi_row , & tp ) ;else encode_tiles ( cpi ) ;if ( sf -> skip_encode_sb ) {int j ;",4497
535,"int yr_re_exec ( uint8_t * re_code , uint8_t * input_data ,  size_t input_size ,  int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {","int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) {",4498
536,"# define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3  # define prolog if ( bytes_matched >= max_bytes_matched ) {# define fail_if_error ( e ) switch ( e ) {if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ;input -= character_size ;input_incr = - input_incr ;max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ;max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ;","# define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 # define prolog {if ( ( bytes_matched >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) {}# define fail_if_error ( e ) {switch ( e ) {}if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ;max_bytes_matched = ( int ) yr_min ( input_forwards_size , RE_SCAN_LIMIT ) ;}input -= character_size ;input_incr = - input_incr ;else {max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ;max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ;",4498
537,match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ;,"match = _yr_re_is_word_char ( input , character_size ) ;",4498
538,match = IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;match = ! IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;,"match = IS_WORD_CHAR ( * input ) ;action = match ? ACTION_NONE : ACTION_KILL ;match = ! _yr_re_is_word_char ( input , character_size ) ;action = match ? ACTION_NONE : ACTION_KILL ;",4498
539,case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 &&  ! ( flags & RE_FLAGS_NOT_AT_START ) &&  ! ( flags & RE_FLAGS_BACKWARDS ) )  match = TRUE ;else if ( bytes_matched >= max_bytes_matched )  match = TRUE ;else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) )  match = TRUE ;else match = FALSE ;case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS )  kill = input_size > ( size_t ) bytes_matched ;else  kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS ||  input_size > ( size_t ) bytes_matched ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;,"case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && input_backwards_size < character_size ) {match = TRUE ;}else if ( bytes_matched >= max_bytes_matched ) {match = TRUE ;}else {assert ( input < input_data + input_forwards_size ) ;assert ( input >= input_data - input_backwards_size ) ;assert ( input - input_incr < input_data + input_forwards_size ) ;assert ( input - input_incr >= input_data - input_backwards_size ) ;match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ;}case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS ) kill = input_backwards_size > ( size_t ) bytes_matched ;else kill = input_backwards_size > 0 || ( bytes_matched != 0 ) ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || input_forwards_size > ( size_t ) bytes_matched ;action = kill ? ACTION_KILL : ACTION_CONTINUE ;",4498
540,"}if ( flags & RE_FLAGS_WIDE && bytes_matched < max_bytes_matched && * ( input + 1 ) != 0 ) {_yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ;","
",4498
541,"ALOGE ( ""b/26366256"" ) ;return ;","ALOGE ( ""b/26366256"" ) ;android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;return ;",4499
542,"r = - ENOMEM ;if ( ! u . lapic ) goto out ;r = kvm_vcpu_ioctl_get_lapic ( vcpu , u . lapic ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( argp , u . lapic , sizeof ( struct kvm_lapic_state ) ) ) goto out ;r = 0 ;break ;}case KVM_SET_LAPIC : {r = - EINVAL ;if ( ! vcpu -> arch . apic ) goto out ;u . lapic = memdup_user ( argp , sizeof ( * u . lapic ) ) ;if ( IS_ERR ( u . lapic ) ) return PTR_ERR ( u . lapic ) ;r = kvm_vcpu_ioctl_set_lapic ( vcpu , u . lapic ) ;break ;}case KVM_INTERRUPT : {struct kvm_interrupt irq ;r = - EFAULT ;if ( copy_from_user ( & irq , argp , sizeof irq ) ) goto out ;r = kvm_vcpu_ioctl_interrupt ( vcpu , & irq ) ;break ;}case KVM_NMI : {r = kvm_vcpu_ioctl_nmi ( vcpu ) ;break ;}case KVM_SET_CPUID : {struct kvm_cpuid __user * cpuid_arg = argp ;struct kvm_cpuid cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_set_cpuid ( vcpu , & cpuid , cpuid_arg -> entries ) ;break ;}case KVM_SET_CPUID2 : {struct kvm_cpuid2 __user * cpuid_arg = argp ;struct kvm_cpuid2 cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_set_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ;break ;}case KVM_GET_CPUID2 : {struct kvm_cpuid2 __user * cpuid_arg = argp ;struct kvm_cpuid2 cpuid ;r = - EFAULT ;if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ;r = kvm_vcpu_ioctl_get_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( cpuid_arg , & cpuid , sizeof cpuid ) ) goto out ;r = 0 ;break ;}case KVM_GET_MSRS : r = msr_io ( vcpu , argp , kvm_get_msr , 1 ) ;break ;case KVM_SET_MSRS : r = msr_io ( vcpu , argp , do_set_msr , 0 ) ;break ;case KVM_TPR_ACCESS_REPORTING : {struct kvm_tpr_access_ctl tac ;r = - EFAULT ;if ( copy_from_user ( & tac , argp , sizeof tac ) ) goto out ;r = vcpu_ioctl_tpr_access_reporting ( vcpu , & tac ) ;if ( r ) goto out ;r = - EFAULT ;if ( copy_to_user ( argp , & tac , sizeof tac ) ) goto out ;r = 0 ;break ;};case KVM_SET_VAPIC_ADDR : {struct kvm_vapic_addr va ;r = - EINVAL ;if ( ! irqchip_in_kernel ( vcpu -> kvm ) ) goto out ;r = - EFAULT ;if ( copy_from_user ( & va , argp , sizeof va ) ) goto out ;r = 0 ;kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ;","r = kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ;",4500
543,"int ip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk ,  __be32 saddr , __be32 daddr , struct ip_options * opt )  {skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ;skb_reset_network_header ( skb ) ;","int ip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk , __be32 saddr , __be32 daddr , struct ip_options_rcu * opt ) {skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> opt . optlen : 0 ) ) ;skb_reset_network_header ( skb ) ;",4501
544,"if ( opt && opt -> optlen ) {iph -> ihl += opt -> optlen >> 2 ;ip_options_build ( skb , opt , daddr , rt , 0 ) ;}","if ( opt && opt -> opt . optlen ) {iph -> ihl += opt -> opt . optlen >> 2 ;ip_options_build ( skb , & opt -> opt , daddr , rt , 0 ) ;}",4501
545,BUG_ON ( direction != ITER_PIPE ) ;i -> type = direction ;,BUG_ON ( direction != ITER_PIPE ) ;WARN_ON ( pipe -> nrbufs == pipe -> buffers ) ;i -> type = direction ;,4502
546,"log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\\continue ;","if ( file -> file_type == FILE_TYPE_GEOMETRY ) {log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\\}else {log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\\}continue ;",4503
547,"# define ThrowPICTException ( exception , message ) {}char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;","# define ThrowPICTException ( exception , message ) \\\\\\\\\\char geometry [ MagickPathExtent ] , header_ole [ 4 ] ;",4504
548,if ( length != 0x000a )  {,"if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length != 0x000a ) {",4504
549,"
","if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;",4504
550,"if ( ReadRectangle ( image , & frame ) == MagickFalse )  ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;","if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ;",4504
551,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,"if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;length = ReadBlobMSBShort ( image ) ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;for ( i = 0 ;",4504
552,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,4504
553,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,length = ReadBlobMSBShort ( image ) ;for ( i = 0 ;,4504
554,if ( length == 0 )  break ;,if ( length == 0 ) break ;,4504
555,if ( length > 154 )  {,if ( length > 154 ) {,4504
556,for ( i = 0 ;i ++ )  if ( ReadBlobByte ( image ) == EOF ) break ;for ( i = 0 ;i ++ )  if ( ReadBlobByte ( image ) == EOF ) break ;,"for ( i = 0 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;for ( i = 0 ;i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ;",4504
557,# ifdef CONFIG_SMP  free_percpu ( s -> s_files ) ;# endif for ( i = 0 ;,for ( i = 0 ;,4505
558,get_page ( * page ) ;out : ret = 0 ;,if ( unlikely ( ! try_get_page ( * page ) ) ) {ret = - ENOMEM ;goto unmap ;}out : ret = 0 ;,4506
559,"ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ;if ( ret ) goto error ;","ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len , 0 ) ;if ( ret ) goto error ;",4507
560,"while ( nr > 0 ) {c = tty -> ops -> write ( tty , b , nr ) ;if ( c < 0 ) {","struct n_tty_data * ldata = tty -> disc_data ;while ( nr > 0 ) {mutex_lock ( & ldata -> output_lock ) ;c = tty -> ops -> write ( tty , b , nr ) ;mutex_unlock ( & ldata -> output_lock ) ;if ( c < 0 ) {",4508
561,"perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ;# ifdef DEBUG_MATHEMU printk ( ""In<S2SV_blank>do_mathemu()...<S2SV_blank>pc<S2SV_blank>is<S2SV_blank>%08lx\\\","perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ;# ifdef DEBUG_MATHEMU printk ( ""In<S2SV_blank>do_mathemu()...<S2SV_blank>pc<S2SV_blank>is<S2SV_blank>%08lx\\\",4509
562,"flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |  EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ;if ( mode & FALLOC_FL_KEEP_SIZE )  flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;mutex_lock ( & inode -> i_mutex ) ;if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) {","mutex_lock ( & inode -> i_mutex ) ;if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) {",4510
563,"if ( max_blocks > 0 ) {truncate_pagecache_range ( inode , start , end - 1 ) ;","}flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ;if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ;if ( partial_begin || partial_end ) {ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ;if ( ret ) goto out_mutex ;}if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) {new_size = offset + len ;ret = inode_newsize_ok ( inode , new_size ) ;if ( ret ) goto out_mutex ;if ( max_blocks > 0 ) {flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;truncate_pagecache_range ( inode , start , end - 1 ) ;",4510
564,"prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ;}","enc_tables . counter_head ++ ;enc_tables . counter_tail ++ ;prefetch_table ( ( const void * ) & enc_tables , sizeof ( encT ) ) ;}",4511
565,"memcpy ( buf + x , data + 2 , i ) ;data += 2 + i ;x += i ;}}if ( p < packets ) break ;}if ( l < lines ) {state -> errcode = IMAGING_CODEC_OVERRUN ;return - 1 ;}break ;case 12 : y = I16 ( data ) ;ymax = y + I16 ( data + 2 ) ;data += 4 ;for ( ;y < ymax && y < state -> ysize ;y ++ ) {UINT8 * out = ( UINT8 * ) im -> image [ y ] ;int p , packets = * data ++ ;for ( p = x = 0 ;p < packets ;p ++ , x += i ) {x += data [ 0 ] ;if ( data [ 1 ] & 0x80 ) {i = 256 - data [ 1 ] ;if ( x + i > state -> xsize ) break ;memset ( out + x , data [ 2 ] , i ) ;data += 3 ;}else {i = data [ 1 ] ;if ( x + i > state -> xsize ) break ;memcpy ( out + x , data + 2 , i ) ;data += i + 2 ;}}if ( p < packets ) break ;}if ( y < ymax ) {state -> errcode = IMAGING_CODEC_OVERRUN ;return - 1 ;}break ;case 13 : for ( y = 0 ;y < state -> ysize ;y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;break ;case 15 : for ( y = 0 ;y < state -> ysize ;y ++ ) {UINT8 * out = ( UINT8 * ) im -> image [ y ] ;data += 1 ;for ( x = 0 ;x < state -> xsize ;x += i ) {if ( data [ 0 ] & 0x80 ) {i = 256 - data [ 0 ] ;if ( x + i > state -> xsize ) break ;memcpy ( out + x , data + 1 , i ) ;data += i + 1 ;}else {i = data [ 0 ] ;if ( x + i > state -> xsize ) break ;memset ( out + x , data [ 1 ] , i ) ;data += 2 ;}}if ( x != state -> xsize ) {state -> errcode = IMAGING_CODEC_OVERRUN ;return - 1 ;}}break ;case 16 : for ( y = 0 ;y < state -> ysize ;y ++ ) {UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;memcpy ( buf + x , data , state -> xsize ) ;data += state -> xsize ;","memcpy ( buf , data , state -> xsize ) ;data += state -> xsize ;",4512
566,gfp_mask = sk -> sk_allocation ;if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ;,int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;err = - EMSGSIZE ;if ( npages > MAX_SKB_FRAGS ) goto failure ;gfp_mask = sk -> sk_allocation ;if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ;,4513
567,int npages ;int i ;if ( ! data_len )  break ;npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;,int i ;if ( ! data_len ) break ;npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ;,4513
568,"if ( settings . num_threads > 64 ) {fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\\}break ;case \'D\' : if ( ! optarg || ! optarg [ 0 ] ) {fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\\return 1 ;}settings . prefix_delimiter = optarg [ 0 ] ;settings . detail_enabled = 1 ;break ;case \'L\' : if ( enable_large_pages ( ) == 0 ) {preallocate = true ;}else {fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\\return 1 ;}break ;case \'C\' : settings . use_cas = false ;break ;case \'b\' : settings . backlog = atoi ( optarg ) ;break ;case \'B\' : protocol_specified = true ;if ( strcmp ( optarg , ""auto"" ) == 0 ) {settings . binding_protocol = negotiating_prot ;}else if ( strcmp ( optarg , ""binary"" ) == 0 ) {settings . binding_protocol = binary_prot ;}else if ( strcmp ( optarg , ""ascii"" ) == 0 ) {settings . binding_protocol = ascii_prot ;}else {fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\\exit ( EX_USAGE ) ;}break ;case \'I\' : buf = strdup ( optarg ) ;unit = buf [ strlen ( buf ) - 1 ] ;if ( unit == \'k\' || unit == \'m\' || unit == \'K\' || unit == \'M\' ) {buf [ strlen ( buf ) - 1 ] = \'\\\\0\' ;size_max = atoi ( buf ) ;if ( unit == \'k\' || unit == \'K\' ) size_max *= 1024 ;if ( unit == \'m\' || unit == \'M\' ) size_max *= 1024 * 1024 ;settings . item_size_max = size_max ;}else {settings . item_size_max = atoi ( buf ) ;}free ( buf ) ;break ;case \'S\' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\\exit ( EX_USAGE ) ;# endif settings . sasl = true ;break ;case \'F\' : settings . flush_enabled = false ;break ;case \'X\' : settings . dump_enabled = false ;break ;case \'o\' : subopts_orig = subopts = strdup ( optarg ) ;while ( * subopts != \'\\\\0\' ) {switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) {case MAXCONNS_FAST : settings . maxconns_fast = true ;break ;case HASHPOWER_INIT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\\return 1 ;}settings . hashpower_init = atoi ( subopts_value ) ;if ( settings . hashpower_init < 12 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\\return 1 ;}else if ( settings . hashpower_init > 32 ) {fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\\return 1 ;}break ;case NO_HASHEXPAND : start_assoc_maint = false ;break ;case SLAB_REASSIGN : settings . slab_reassign = true ;break ;case SLAB_AUTOMOVE : if ( subopts_value == NULL ) {settings . slab_automove = 1 ;break ;}settings . slab_automove = atoi ( subopts_value ) ;if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) {fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\\return 1 ;}break ;case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_ratio = atof ( subopts_value ) ;if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) {fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\\return 1 ;}break ;case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\\return 1 ;}settings . slab_automove_window = atoi ( subopts_value ) ;if ( settings . slab_automove_window < 3 ) {fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\\return 1 ;}break ;case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\\return 1 ;}settings . tail_repair_time = atoi ( subopts_value ) ;if ( settings . tail_repair_time < 10 ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\\return 1 ;}break ;case HASH_ALGORITHM : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\\return 1 ;};if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) {hash_type = JENKINS_HASH ;}else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) {hash_type = MURMUR3_HASH ;}else {fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\\return 1 ;}break ;case LRU_CRAWLER : start_lru_crawler = true ;break ;case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_sleep = atoi ( subopts_value ) ;if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) {fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\\return 1 ;}break ;case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) {fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\\return 1 ;}settings . lru_crawler_tocrawl = tocrawl ;break ;case LRU_MAINTAINER : start_lru_maintainer = true ;settings . lru_segmented = true ;break ;case HOT_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . hot_lru_pct = atoi ( subopts_value ) ;if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case WARM_LRU_PCT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\\return 1 ;}settings . warm_lru_pct = atoi ( subopts_value ) ;if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) {fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\\return 1 ;}break ;case HOT_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\\return 1 ;}settings . hot_max_factor = atof ( subopts_value ) ;if ( settings . hot_max_factor <= 0 ) {fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case WARM_MAX_FACTOR : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\\return 1 ;}settings . warm_max_factor = atof ( subopts_value ) ;if ( settings . warm_max_factor <= 0 ) {fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\\return 1 ;}break ;case TEMPORARY_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\\return 1 ;}settings . temp_lru = true ;settings . temporary_ttl = atoi ( subopts_value ) ;break ;case IDLE_TIMEOUT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\\return 1 ;}settings . idle_timeout = atoi ( subopts_value ) ;break ;case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\\return 1 ;}settings . logger_watcher_buf_size *= 1024 ;break ;case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\\return 1 ;}settings . logger_buf_size *= 1024 ;case SLAB_SIZES : slab_sizes_unparsed = subopts_value ;break ;case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\\}if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\\}slab_chunk_size_changed = true ;break ;case TRACK_SIZES : item_stats_sizes_init ( ) ;break ;case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ;break ;case INLINE_ASCII_RESP : settings . inline_ascii_response = true ;break ;case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ;break ;case NO_SLAB_REASSIGN : settings . slab_reassign = false ;break ;case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ;break ;case NO_MAXCONNS_FAST : settings . maxconns_fast = false ;break ;case NO_LRU_CRAWLER : settings . lru_crawler = false ;start_lru_crawler = false ;break ;case NO_LRU_MAINTAINER : start_lru_maintainer = false ;settings . lru_segmented = false ;break ;# ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\\return 1 ;}ext_cf . page_size *= 1024 * 1024 ;break ;case EXT_PAGE_COUNT : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\\return 1 ;}break ;case EXT_WBUF_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\\return 1 ;}ext_cf . wbuf_size *= 1024 * 1024 ;settings . ext_wbuf_size = ext_cf . wbuf_size ;break ;case EXT_THREADS : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\\return 1 ;}break ;case EXT_IO_DEPTH : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\\return 1 ;}break ;case EXT_ITEM_SIZE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\\return 1 ;}break ;case EXT_ITEM_AGE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\\return 1 ;}break ;case EXT_LOW_TTL : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\\return 1 ;}break ;case EXT_RECACHE_RATE : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\\return 1 ;}break ;case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\\return 1 ;}break ;case EXT_DROP_UNDER : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\\return 1 ;}break ;case EXT_MAX_FRAG : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\\return 1 ;}break ;case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) {fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\\return 1 ;}if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) {fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\\return 1 ;}break ;case EXT_DROP_UNREAD : settings . ext_drop_unread = true ;break ;case EXT_PATH : storage_file = strdup ( subopts_value ) ;break ;# endif case MODERN : break ;case NO_MODERN : if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size ;}settings . slab_reassign = false ;settings . slab_automove = 0 ;settings . maxconns_fast = false ;settings . inline_ascii_response = true ;settings . lru_segmented = false ;hash_type = JENKINS_HASH ;start_lru_crawler = false ;start_lru_maintainer = false ;break ;case NO_DROP_PRIVILEGES : settings . drop_privileges = false ;break ;# ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ;break ;# endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\\\""%s\\\\""\\\return 1 ;}}free ( subopts_orig ) ;break ;default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\\\""%c\\\\""\\\return 1 ;}}if ( settings . item_size_max < 1024 ) {fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) {fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max > 1024 * 1024 ) {if ( ! slab_chunk_size_changed ) {settings . slab_chunk_size_max = settings . slab_page_size / 2 ;}}if ( settings . slab_chunk_size_max > settings . item_size_max ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\\exit ( EX_USAGE ) ;}if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) {fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\\exit ( EX_USAGE ) ;}# ifdef EXTSTORE if ( storage_file ) {if ( settings . item_size_max > ext_cf . wbuf_size ) {fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\\exit ( EX_USAGE ) ;}if ( settings . inline_ascii_response ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( settings . udpport ) {fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\\exit ( EX_USAGE ) ;}}# endif if ( slab_sizes_unparsed != NULL ) {if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) {use_slab_sizes = true ;}else {exit ( EX_USAGE ) ;}}if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) {fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\\exit ( EX_USAGE ) ;}if ( settings . temp_lru && ! start_lru_maintainer ) {fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\\exit ( EX_USAGE ) ;}if ( hash_init ( hash_type ) != 0 ) {fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\\exit ( EX_USAGE ) ;}if ( settings . inter != NULL && strchr ( settings . inter , \',\' ) ) {settings . num_threads_per_udp = 1 ;}else {settings . num_threads_per_udp = settings . num_threads ;}if ( settings . sasl ) {if ( ! protocol_specified ) {settings . binding_protocol = binary_prot ;}else {if ( settings . binding_protocol != binary_prot ) {fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\\exit ( EX_USAGE ) ;}}}if ( tcp_specified && settings . port != 0 && ! udp_specified ) {settings . udpport = settings . port ;}else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {",if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) {,4514
569,"char * prime_arg1 ,  * prime_arg2 ;gss_buffer_desc client_name ,  service_name ;","char * prime_arg1 = NULL , * prime_arg2 = NULL ;gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;",4515
570,"else {ret . code = kadm5_rename_principal ( ( void * ) handle , arg -> src , arg -> dest ) ;if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ;krb5_klog_syslog ( LOG_NOTICE , _ ( ""Request:<S2SV_blank>kadm5_rename_principal,<S2SV_blank>"" ""%.*s%s<S2SV_blank>to<S2SV_blank>%.*s%s,<S2SV_blank>%s,<S2SV_blank>"" ""client=%.*s%s,<S2SV_blank>service=%.*s%s,<S2SV_blank>addr=%s"" ) , ( int ) tlen1 , prime_arg1 , tdots1 , ( int ) tlen2 , prime_arg2 , tdots2 , errmsg ? errmsg : _ ( ""success"" ) , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) ) ;if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ;}free ( prime_arg1 ) ;free ( prime_arg2 ) ;exit_func : free_server_handle ( handle ) ;",exit_func : free ( prime_arg1 ) ;free ( prime_arg2 ) ;free_server_handle ( handle ) ;,4515
571,if ( param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;break ;}if ( param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;break ;}if ( param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;break ;,"if ( param2 < 0 || param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;if ( param2 < 0 ) {android_errorWriteLog ( 0x534e4554 , ""32438598"" ) ;ALOGW ( ""\\\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ;}break ;}if ( param2 < 0 || param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;if ( param2 < 0 ) {android_errorWriteLog ( 0x534e4554 , ""32436341"" ) ;ALOGW ( ""\\\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ;}break ;}if ( param2 < 0 || param2 >= NUM_EQ_BANDS ) {p -> status = - EINVAL ;if ( param2 < 0 ) {android_errorWriteLog ( 0x534e4554 , ""32247948"" ) ;ALOGW ( ""\\\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ;}break ;",4516
572,"resend : if ( ! setup_stratum_socket ( pool ) ) {sockd = false ;goto out ;}sockd = true ;if ( recvd ) {clear_sock ( pool ) ;sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[]}"" , swork_id ++ ) ;}else {if ( pool -> sessionid ) sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\"",<S2SV_blank>\\\\""%s\\\\""]}"" , swork_id ++ , pool -> sessionid ) ;else sprintf ( s , ""{\\\\""id\\\\"":<S2SV_blank>%d,<S2SV_blank>\\\\""method\\\\"":<S2SV_blank>\\\\""mining.subscribe\\\\"",<S2SV_blank>\\\\""params\\\\"":<S2SV_blank>[\\\\"""" PACKAGE ""/"" VERSION ""\\\\""]}"" , swork_id ++ ) ;}if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) {",resend : if ( ! valid_hex ( nonce1 ) ) {,4517
573,"applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ;if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;nonce1 = json_array_string ( res_val , 1 ) ;if ( ! nonce1 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;","applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;if ( n2size < 2 || n2size > 16 ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;if ( ! n2size ) {applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ;free ( sessionid ) ;",4517
574,"if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) {error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name ,  slurm_strerror ( errno ) ) ;","if ( ( fd = _open_as_other ( path_name , req ) ) == - 1 ) {error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , slurm_strerror ( errno ) ) ;",4518
575,"walk -> private += __mincore_unmapped_range ( addr , end ,  walk -> vma , walk -> private ) ;","unsigned char * vec = walk -> private ;unsigned long nr = ( end - addr ) >> PAGE_SHIFT ;memset ( vec , 0 , nr ) ;walk -> private += nr ;",4519
576,"if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) ||  ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) {for ( i = 0 ;segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ;","if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ;if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) {for ( i = 0 ;if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ;",4520
577,"void * zrealloc ( void * ptr , size_t size ) {# ifndef HAVE_MALLOC_SIZE void * realptr ;","void * zrealloc ( void * ptr , size_t size ) {ASSERT_NO_SIZE_OVERFLOW ( size ) ;# ifndef HAVE_MALLOC_SIZE void * realptr ;",4521
578,"FRAME_CONTEXT * const fc = & cm -> fc ;vp9_reader r ;if ( vp9_reader_init ( & r , data , partition_size ) )  vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ;","FRAME_CONTEXT * const fc = cm -> fc ;vpx_reader r ;if ( vpx_reader_init ( & r , data , partition_size , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ;",4522
579,return vp9_reader_has_error ( & r ) ;},return vpx_reader_has_error ( & r ) ;},4522
580,"if ( numrows < 0 || numcols < 0 ) {return 0 ;}return 0 ;}matrix -> datasize_ = numrows * numcols ;if ( matrix -> maxrows_ > 0 ) {if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) {jas_matrix_destroy ( matrix ) ;return 0 ;jas_matrix_destroy ( matrix ) ;return 0 ;","size_t size ;matrix = 0 ;if ( numrows < 0 || numcols < 0 ) {goto error ;}goto error ;}matrix -> datasize_ = 0 ;if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) {goto error ;jas_matrix_destroy ( matrix ) ;return 0 ;",4523
581,},error : if ( matrix ) {jas_matrix_destroy ( matrix ) ;}return 0 ;},4523
582,"
",else {matvar -> name [ tmp - 1 ] = \'\\\\0\' ;},4524
583,}matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ;,}matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ;,4524
584,* dst = * src ;clear_task_ebb ( dst ) ;,__switch_to_tm ( src ) ;tm_recheckpoint_new_task ( src ) ;* dst = * src ;clear_task_ebb ( dst ) ;,4525
585,"int flags = fcntl ( semaphore -> fd , F_GETFL ) ;if ( flags == - 1 ) {if ( fcntl ( semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) == - 1 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>O_NONBLOCK<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ;if ( eventfd_read ( semaphore -> fd , & value ) == - 1 ) return false ;if ( fcntl ( semaphore -> fd , F_SETFL , flags ) == - 1 )  LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>resetore<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ;","int flags = TEMP_FAILURE_RETRY ( fcntl ( semaphore -> fd , F_GETFL ) ) ;if ( flags == - 1 ) {if ( TEMP_FAILURE_RETRY ( fcntl ( semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) ) == - 1 ) {LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>O_NONBLOCK<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ;if ( TEMP_FAILURE_RETRY ( eventfd_read ( semaphore -> fd , & value ) == - 1 ) return false ;if ( fcntl ( semaphore -> fd , F_SETFL , flags ) ) == - 1 ) LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>resetore<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ;",4526
586,"
",ND_TCHECK ( bp -> bp_flags ) ;,4527
587,"ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" ,  bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ;","ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ;",4527
588,"int idx , ret = - EINVAL ;if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ;BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ;hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ;","int idx , ret = 0 ;if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ;if ( guest_irq >= irq_rt -> nr_rt_entries ) ;hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] ) ) {pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\\goto out ;}hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) {if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ;",4528
589,"struct net * net = sock_net ( asoc -> base . sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( asoc -> base . sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error )  asoc -> base . sk -> sk_err = - error ;out_unlock :  bh_unlock_sock ( asoc -> base . sk ) ;sctp_transport_put ( transport ) ;","struct sock * sk = asoc -> base . sk ;struct net * net = sock_net ( sk ) ;bh_lock_sock ( asoc -> base . sk ) ;if ( sock_owned_by_user ( sk ) ) {pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\\if ( error ) sk -> sk_err = - error ;out_unlock : bh_unlock_sock ( sk ) ;sctp_transport_put ( transport ) ;",4529
590,"if ( ! CDROM_CAN ( CDC_MEDIA_CHANGED ) ) return - ENOSYS ;if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ;if ( ( unsigned int ) arg >= cdi -> capacity )  return - EINVAL ;",if ( arg >= cdi -> capacity ) return - EINVAL ;,4530
591,msg -> msg_namelen = 0 ;lock_sock ( sk ) ;,lock_sock ( sk ) ;,4531
592,struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ;if ( mnt != parent ) {,struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ;if ( dentry != vfsmnt -> mnt_root ) {bptr = * buffer ;blen = * buflen ;error = 3 ;break ;}if ( mnt != parent ) {,4532
593,"vcpu = kvm_arch_vcpu_create ( kvm , id ) ;if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ;","if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;vcpu = kvm_arch_vcpu_create ( kvm , id ) ;if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ;",4533
594,"void usage_exit ( ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><frame>\\\","void usage_exit ( void ) {fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><frame>\\\",4534
595,ld -> bytes_left = ld -> buffer_size - words * 4 ;if ( ld -> bytes_left >= 4 ) {,if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ;else ld -> bytes_left = ld -> buffer_size - words * 4 ;if ( ld -> bytes_left >= 4 ) {,4535
596,"
","status = SetImageExtent ( image , image -> columns , image -> rows ) ;if ( status == MagickFalse ) {InheritException ( exception , & image -> exception ) ;return ( DestroyImageList ( image ) ) ;}",4536
597,"SetImageColorspace ( image , GRAYColorspace ) ;quantum_type = IndexQuantum ;","SetImageColorspace ( image , GRAYColorspace ) ;quantum_type = IndexQuantum ;",4536
598,"# if ( IPV6_SUPPORT == ENABLED )  if ( strchr ( str , ':' ) )  {else # endif # if ( IPV4_SUPPORT == ENABLED )  if ( strchr ( str , '.' ) )  {","# if ( IPV6_SUPPORT == ENABLED ) if ( osStrchr ( str , ':' ) != NULL ) {else # endif # if ( IPV4_SUPPORT == ENABLED ) if ( osStrchr ( str , '.' ) != NULL ) {",4537
599,"pfn = kvm_pin_pages ( slot , gfn , page_size ) ;if ( is_error_noslot_pfn ( pfn ) ) {kvm_unpin_pages ( kvm , pfn , page_size ) ;goto unmap_pages ;","pfn = kvm_pin_pages ( slot , gfn , page_size >> PAGE_SHIFT ) ;if ( is_error_noslot_pfn ( pfn ) ) {kvm_unpin_pages ( kvm , pfn , page_size >> PAGE_SHIFT ) ;goto unmap_pages ;",4538
600,"switch ( bank )  {case BANK_0 :  enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ;break ;case BANK_1 :  enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ;enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ;break ;case BANK_2 :  enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ;enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ;break ;case BANK_3 :  enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ;break ;default : break ;","if ( bank == BANK_0 ) {enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ;break ;case BANK_1 : enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ;}else if ( bank == BANK_1 ) {enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ;break ;case BANK_3 : enc28j60SetBit ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ;",4539
601,"char * buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;","char * buff ;if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}buff = malloc ( bytes_to_copy ) ;if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\\\""%c%c%c%c\\\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ;",4540
602,"c -> c_normalize = PyObject_GetAttrString ( m , ""normalize"" ) ;Py_DECREF ( m ) ;if ( ! c -> c_normalize ) return 0 ;c -> c_normalize_args = Py_BuildValue ( ""(sN)"" , ""NFKC"" , Py_None ) ;if ( ! c -> c_normalize_args ) {Py_CLEAR ( c -> c_normalize ) ;return 0 ;}PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , NULL ) ;","
",4541
603,if ( upid == - 1 )  type = PIDTYPE_MAX ;,if ( upid == INT_MIN ) return - ESRCH ;if ( upid == - 1 ) type = PIDTYPE_MAX ;,4542
604,"SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;","if ( SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;",4543
605,"dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ;rr -> length = 0 ;","dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) < 0 ) {SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;return - 1 ;}rr -> length = 0 ;",4543
606,"
",hdr -> sadb_msg_reserved = 0 ;,4544
607,"pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;","pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;return 0 ;",4544
608,"case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;break ;","case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ;break ;",4545
609,"case 0xe9 : case 0xeb :  jmp_rel ( ctxt , ctxt -> src . val ) ;ctxt -> dst . type = OP_NONE ;","case 0xe9 : case 0xeb : rc = jmp_rel ( ctxt , ctxt -> src . val ) ;ctxt -> dst . type = OP_NONE ;",4545
610,"case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) ctxt -> dst . val = ctxt -> src . val ;case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) )  jmp_rel ( ctxt , ctxt -> src . val ) ;break ;","case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) rc = ctxt -> dst . val = ctxt -> src . val ;case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) jmp_rel ( ctxt , ctxt -> src . val ) ;break ;",4545
611,if ( current -> mm )  __flush_tlb_one ( start ) ;else   leave_mm ( smp_processor_id ( ) ) ;},if ( current -> mm ) {__flush_tlb_one ( start ) ;}else {leave_mm ( smp_processor_id ( ) ) ;smp_mb ( ) ;}},4546
612,"static int conditional_skipintra ( MB_PREDICTION_MODE mode ,  MB_PREDICTION_MODE best_intra_mode ) {","static int conditional_skipintra ( PREDICTION_MODE mode , PREDICTION_MODE best_intra_mode ) {",4547
613,struct channel_info * info =  & synth_devs [ dev ] -> chn_info [ chn ] ;,struct channel_info * info ;if ( voice < 0 || voice >= devc -> nr_voice ) return ;if ( chn < 0 || chn > 15 ) return ;info = & synth_devs [ dev ] -> chn_info [ chn ] ;,4548
614,}ZVAL_NULL ( * rval ) ;,zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;}ZVAL_NULL ( * rval ) ;,4549
615,"size_t copied , len , cur_len ;ssize_t total_written = 0 ;","size_t bytes , copied , len , cur_len ;ssize_t total_written = 0 ;",4550
616,"copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it ,  0 , copied ) ;cur_len -= copied ;}cur_len = save_len - cur_len ;wdata -> sync_mode = WB_SYNC_ALL ;","bytes = min_t ( const size_t , cur_len , PAGE_SIZE ) ;copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , bytes ) ;cur_len -= copied ;if ( copied < bytes ) break ;}cur_len = save_len - cur_len ;if ( ! cur_len ) {for ( i = 0 ;i < nr_pages ;i ++ ) put_page ( wdata -> pages [ i ] ) ;kfree ( wdata ) ;rc = - EFAULT ;break ;}for ( ;nr_pages > i + 1 ;nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) ;wdata -> sync_mode = WB_SYNC_ALL ;",4550
617,break ;case XDR_ENCODE : tl = * tl_data_head ;,* tl_data_head = NULL ;break ;case XDR_ENCODE : tl = * tl_data_head ;,4551
618,"static void write_inter_mode ( vp9_writer * w , MB_PREDICTION_MODE mode ,   const vp9_prob * probs ) {assert ( is_inter_mode ( mode ) ) ;","static void write_inter_mode ( vpx_writer * w , MB_PREDICTION_MODE mode , const vpx_prob * probs ) {assert ( is_inter_mode ( mode ) ) ;",4552
619,"struct va_format vaf ;char nfunc [ 32 ] ;memset ( nfunc , 0 , sizeof ( nfunc ) ) ;memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) ,  nfunc , line , qedi -> host_no , & vaf ) ;else  pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ;ret : va_end ( va ) ;","struct va_format vaf ;if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ;else pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func , line , & vaf ) ;ret : va_end ( va ) ;",4553
620,"int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ;int32 bytes_read = 0 ;uint16 bps , nstrips , planar , strips_per_sample ;uint32 src_rowsize , dst_rowsize , rows_processed , rps ;","int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ;uint32 j ;int32 bytes_read = 0 ;uint16 bps , planar ;uint32 nstrips ;uint32 strips_per_sample ;uint32 src_rowsize , dst_rowsize , rows_processed , rps ;",4554
621,int i ;int j ;,jas_matind_t i ;jas_matind_t j ;,4555
622,"private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info ,  size_t count , const uint64_t clsid [ 2 ] )  {","private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , size_t count , const cdf_directory_t * root_storage ) {",4556
623,"if ( ! NOTMIME ( ms ) )   str = cdf_clsid_to_mime ( clsid , clsid2mime ) ;for ( i = 0 ;","if ( ! NOTMIME ( ms ) && root_storage ) str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid , clsid2mime ) ;for ( i = 0 ;",4556
624,"numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;if ( argc > MAX_PACK_ARGS ) {archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ;return ARCHIVE_WARN ;}","if ( argc >= MAX_PACK_ARGS ) {archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ;return ARCHIVE_WARN ;}numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ;",4557
625,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,4558
626,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",4558
627,if ( ( msr -> msc_reqbody_spilltodisk )  && ( msr -> msc_reqbody_length + length > ( apr_size_t ) msr -> txcfg -> reqbody_inmemory_limit ) ) {,if ( ( msr -> msc_reqbody_spilltodisk ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON ) && ( msr -> msc_reqbody_length + length > ( apr_size_t ) msr -> txcfg -> reqbody_inmemory_limit ) ) {,4559
628,"SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;","if ( SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;",4560
629,"dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ;rr -> length = 0 ;","dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) < 0 ) {SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;return - 1 ;}rr -> length = 0 ;",4560
630,"parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ;service = & new_service_options ;","parse_global_option ( CMD_SET_DEFAULTS , & new_global_options , NULL , NULL ) ;service = & new_service_options ;",4561
631,char fnam [ PROCLEN ] ;FILE * f ;char * line = NULL ;size_t len = 0 ;,char * line = NULL ;size_t len = 0 ;,4562
632,"if ( ! c2 )  goto out ;* c2 = \'\\\\0\' ;if ( strcmp ( c1 , contrl ) != 0 ) continue ;c2 ++ ;stripnewline ( c2 ) ;if ( nextcg )  * nextcg = get_next_cgroup_dir ( linecmp , cg ) ;goto out ;}goto out ;}out : fclose ( f ) ;free ( line ) ;","if ( ! c2 ) return false ;if ( nextcg ) {* nextcg = get_next_cgroup_dir ( linecmp , cg ) ;}goto out ;}out : free ( c2 ) ;",4562
633,"sy = data -> ds . dimension_size [ 1 ] ;sz = data -> ds . dimension_size [ 2 ] ;dzy = dz * dy ;szy = sz * sy ;size = data -> datalayout_chunk [ data -> ds . dimensionality ] ;log ( ""elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\\if ( ! ( output = malloc ( elements * size ) ) ) {return MYSOFA_NO_MEMORY ;}for ( e = 0 ;e < entries_used * 2 ;e ++ ) {if ( node_type == 0 ) {key = readValue ( reader , reader -> superblock . size_of_lengths ) ;}else {size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ;filter_mask = ( uint32_t ) readValue ( reader , 4 ) ;if ( filter_mask ) {log ( ""TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\\free ( output ) ;return MYSOFA_INVALID_FORMAT ;}for ( j = 0 ;j < data -> ds . dimensionality ;j ++ ) {start [ j ] = readValue ( reader , 8 ) ;log ( ""start<S2SV_blank>%d<S2SV_blank>%lu\\\}if ( readValue ( reader , 8 ) ) {break ;}child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ;log ( ""<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\\store = ftell ( reader -> fhd ) ;if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) {free ( output ) ;return errno ;}if ( ! ( input = malloc ( size_of_chunk ) ) ) {free ( output ) ;return MYSOFA_NO_MEMORY ;}if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) {free ( output ) ;free ( input ) ;return MYSOFA_INVALID_FORMAT ;}olen = elements * size ;err = gunzip ( size_of_chunk , input , & olen , output ) ;free ( input ) ;log ( ""<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\\if ( err || olen != elements * size ) {free ( output ) ;return MYSOFA_INVALID_FORMAT ;}switch ( data -> ds . dimensionality ) {case 1 : for ( i = 0 ;i < olen ;i ++ ) {b = i / elements ;x = i % elements + start [ 0 ] ;if ( x < sx ) {j = x * size + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;",j = x * size + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;,4563
634,if ( y < sy && x < sx ) {j = ( ( x * sy + y ) * size ) + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;,if ( y < sy && x < sx ) {j = ( ( x * sy + y ) * size ) + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;,4563
635,if ( z < sz && y < sy && x < sx ) {j = ( x * szy + y * sz + z ) * size + b ;( ( char * ) data -> data ) [ j ] = output [ i ] ;},if ( z < sz && y < sy && x < sx ) {j = ( x * szy + y * sz + z ) * size + b ;if ( j >= 0 && j < elements * size ) {( ( char * ) data -> data ) [ j ] = output [ i ] ;},4563
636,"uint32_t off = offset , tmp , finish ;struct ipmi_rs * rsp ;finish = fru -> size ;lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" ,  offset + length , finish - offset ) ;}do {tmp = fru -> access ? off >> 1 : off ;","uint32_t off = offset ;uint32_t tmp , finish ;uint32_t size_left_in_buffer ;struct ipmi_rs * rsp ;memset ( frubuf + fru -> size , 0 , length - fru -> size ) ;finish = fru -> size ;lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" , offset + length , finish - offset ) ;length = finish - offset ;}size_left_in_buffer = length ;do {tmp = fru -> access ? off >> 1 : off ;",4564
637,"memcpy ( ( frubuf + off ) - offset , rsp -> data + 1 , tmp ) ;off += tmp ;if ( tmp == 0 && off < finish )  return 0 ;","if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) {printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ;return - 1 ;}memcpy ( ( frubuf + off ) - offset , rsp -> data + 1 , tmp ) ;off += tmp ;size_left_in_buffer -= tmp ;if ( tmp == 0 && off < finish ) return 0 ;",4564
638,if ( g -> sect <= 0 ||  g -> head <= 0 ||  g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,if ( g -> sect <= 0 || g -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ;,4565
639,if ( ret )   return - EFAULT ;ptr -> next = NULL ;i < 16 ;i ++ ) ptr -> reply [ i ] = 0 ;ptr -> resultcode = 0 ;ptr -> kernel_data = NULL ;if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) {,ptr -> next = NULL ;ptr -> kernel_data = NULL ;if ( ret ) return - EFAULT ;if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) {,4566
640,"int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ;if ( ( ! s -> willclose || s -> chunksize < 0 ) &&  target_end >= 0 && s -> off >= target_end ) return AVERROR_EOF ;if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) &&  target_end >= 0 && s -> off < target_end ) {av_log ( h , AV_LOG_ERROR ,  ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\\","uint64_t target_end = s -> end_off ? s -> end_off : s -> filesize ;if ( ( ! s -> willclose || s -> chunksize == UINT64_MAX ) && s -> off >= target_end ) return AVERROR_EOF ;if ( ! len && ( ! s -> willclose || s -> chunksize == UINT64_MAX ) && s -> off < target_end ) {av_log ( h , AV_LOG_ERROR , ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 ""\\\",4567
641,"error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ;if ( error ) return ( error ) ;leaf = bp -> b_addr ;entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ;ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ;# ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ;ASSERT ( args -> index < ichdr . count ) ;ASSERT ( args -> index >= 0 ) ;if ( entry -> flags & XFS_ATTR_LOCAL ) {name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ;namelen = name_loc -> namelen ;name = ( char * ) name_loc -> nameval ;}else {name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ;namelen = name_rmt -> namelen ;name = ( char * ) name_rmt -> name ;}ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ;ASSERT ( namelen == args -> namelen ) ;ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ;# endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ;if ( args -> rmtblkno ) {ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ;name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ;name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ;name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ;","error = xfs_attr3_leaf_read ( args -> rmtvaluelen ) ;xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ;",4568
642,"
",if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;,4569
643,"bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ;if ( bh ) {","bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ;if ( bh ) {",4569
644,"vp8_mse16x16 ( orig + col , orig_stride ,  recon + col , recon_stride , & sse ) ;","vpx_mse16x16 ( orig + col , orig_stride , recon + col , recon_stride , & sse ) ;",4570
645,case USB_DEVICE_ID_KYE_ERGO_525V :  if ( * rsize >= 74 &&   rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 &&  rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) {,case USB_DEVICE_ID_KYE_ERGO_525V : if ( * rsize >= 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) {,4571
646,attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ;if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ;,"size_t alloc_size = 0 ;if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ;attrs = malloc ( alloc_size ) ;if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ;",4572
647,char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ;rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ;uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ;int len = 0 ;,union {char bytes [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ;rfbSetEncodingsMsg msg ;}buf ;rfbSetEncodingsMsg * se = & buf . msg ;uint32_t * encs = ( uint32_t * ) ( & buf . bytes [ sz_rfbSetEncodingsMsg ] ) ;int len = 0 ;,4573
648,"if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ;return TRUE ;","if ( ! WriteToRFBServer ( client , buf . bytes , len ) ) return FALSE ;return TRUE ;",4573
649,"return MSPACK_ERR_SIGNATURE ;}hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ;hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ;hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ;hdr -> length = 0 ;hdr -> filename = NULL ;hdr -> extra = NULL ;hdr -> extra_length = 0 ;if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) {if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;hdr -> length = EndGetI32 ( & buf [ 0 ] ) ;}if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) {if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ;}if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) {if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ;i = EndGetI16 ( & buf [ 0 ] ) ;if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ;}if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) {off_t pos = sys -> tell ( fh ) ;char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ;if ( ! fn ) return MSPACK_ERR_NOMEMORY ;hdr -> filename = fn ;if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) {if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 9 ) ? i + 1 : 9 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) )  return MSPACK_ERR_SEEK ;}if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 4 ) ? i + 1 : 4 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) )  return MSPACK_ERR_SEEK ;}if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ;","int len ;char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ;if ( ! fn ) return MSPACK_ERR_NOMEMORY ;hdr -> filename = fn ;if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) {if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 9 ) ? i + 1 : 9 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) return MSPACK_ERR_SEEK ;}if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ;for ( i = 0 ;pos += ( i < 4 ) ? i + 1 : 4 ;if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) return MSPACK_ERR_SEEK ;}if ( ! ( hdr -> filename = fn ) ) return MSPACK_ERR_NOMEMORY ;",4574
650,case NPPVpluginNameString : case NPPVpluginDescriptionString :  case NPPVformValue :  type = RPC_TYPE_STRING ;case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory :  type = RPC_TYPE_BOOLEAN ;break ;,case NPPVpluginNameString : case NPPVpluginDescriptionString : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId : type = RPC_TYPE_STRING ;case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ;break ;,4575
651,unsigned int i ;bpcc -> numcmpts = box -> datalen ;,unsigned int i ;bpcc -> bpcs = 0 ;bpcc -> numcmpts = box -> datalen ;,4576
652,"return print_value ( item , 0 , 1 ) ;}","return print_value ( item , 0 , 1 , 0 ) ;}",4577
653,"int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) ,  top = p -> top ;",int i ;int ubits = BN_num_bits ( u ) ;int vbits = BN_num_bits ( v ) ;int top = p -> top ;,4578
654,if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 )   break ;if ( ubits < vbits ) {,if ( ubits <= BN_BITS2 ) {if ( udp [ 0 ] == 0 ) goto err ;if ( udp [ 0 ] == 1 ) break ;}if ( ubits < vbits ) {,4578
655,"if ( setpwnam ( pw ) < 0 )  err ( EXIT_FAILURE , _ ( ""setpwnam<S2SV_blank>failed\\\","if ( setpwnam ( pw , "".chsh"" ) < 0 ) err ( EXIT_FAILURE , _ ( ""setpwnam<S2SV_blank>failed\\\",4579
656,"int namelen = strlen ( name ) ;int len ;while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) {len = ff_amf_tag_size ( data , data_end ) ;if ( len < 0 )  len = data_end - data ;data ++ ;for ( ;if ( ! size )  break ;if ( size < 0 || size >= data_end - data ) return - 1 ;if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) {switch ( * data ++ ) {case AMF_DATA_TYPE_NUMBER :  snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ;break ;case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ;break ;case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ;av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ;break ;default : return - 1 ;}return 0 ;}len = ff_amf_tag_size ( data , data_end ) ;if ( len < 0 || len >= data_end - data ) return - 1 ;data += len ;}return - 1 ;","GetByteContext gb ;if ( len < 0 ) len = data_end - data ;data ++ ;for ( ;if ( data >= data_end ) return - 1 ;if ( size == namelen && ! memcmp ( data - size , name , dst , dst_size ) ;",4580
657,"size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;size += rw_tlv_length ;skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ;","if ( ! miux_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += miux_tlv_length ;rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ;if ( ! rw_tlv ) {err = - ENOMEM ;goto error_tlv ;}size += rw_tlv_length ;skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ;",4581
658,const uint8_t * src = in -> data [ 0 ] ;,const uint8_t * src = in -> data [ plane ] && in -> linesize [ 0 ] ;,4582
659,for ( plane = 0 ;uint8_t * dst = out -> data [ plane ] ;,for ( plane = 0 ;uint8_t * dst = out -> data [ plane ] ;,4582
660,"int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ;","int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ;if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ;",4583
661,",  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL }LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL },  {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL },  {","LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/tty"" , NULL , MS_BIND , NULL }, {LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/tty"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL }, {",4584
662,"r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ;saved_errno = errno ;","r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL ) ;saved_errno = errno ;",4584
663,"if ( ! empty_tuple ||  PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 ||   PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) {Py_XDECREF ( empty_tuple ) ;","if ( ! empty_tuple || _PyDict_SetItemId ( d , ""_fields"" , empty_tuple ) < 0 || PyDict_SetItemString ( d , & PyId__fields , empty_tuple ) < 0 ) {Py_XDECREF ( empty_tuple ) ;",4585
664,if (  # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) {,p -> replacement_session_keyring = NULL ;if ( # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) {,4586
665,if ( * length < 2 ) return ( ( unsigned short ) ~ 0 ) ;for ( i = 0 ;i < 2 ;i ++ ) {c = ( int ) ( * ( * p ) ++ ) ;( * length ) -- ;buffer [ i ] = ( unsigned char ) c ;}value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ;value |= buffer [ 1 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,if ( * length < 2 ) return ( ( unsigned short ) buffer [ 0 ] << 8 ) ;value |= ( unsigned short ) buffer [ 1 ] ;quantum . unsigned_value = ( value & 0xffff ) ;return ( quantum . signed_value ) ;,4587
666,dsize += svbranch . len ;},dsize += svbranch . len + 1 ;},4588
667,"
",atomic_dec ( & chip -> active ) ;,4589
668,"if ( err < 0 ) goto __error ;usb_chip [ chip -> index ] = chip ;chip -> num_interfaces ++ ;usb_set_intfdata ( intf , chip ) ;atomic_dec ( & chip -> active ) ;mutex_unlock ( & register_mutex ) ;return 0 ;__error : if ( chip ) {if ( ! chip -> num_interfaces )  snd_card_free ( chip -> card ) ;atomic_dec ( & chip -> active ) ;}",},4589
669,"separator = strchr ( line , \':\' ) ;if ( separator != NULL ) {","separator = osStrchr ( line , \':\' ) ;if ( separator != NULL ) {",4590
670,"memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ;up -> family = kp -> encap_family ;","memset ( up , 0 , sizeof ( * up ) ) ;memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ;up -> family = kp -> encap_family ;",4591
671,"static void encode_share_access ( struct xdr_stream * xdr , int open_flags )  {switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) {case FMODE_READ : WRITE32 ( NFS4_SHARE_ACCESS_READ ) ;default :  BUG ( ) ;}","static void encode_share_access ( struct xdr_stream * xdr , fmode_t fmode ) {switch ( fmode & ( FMODE_READ | FMODE_WRITE ) ) {case FMODE_READ : WRITE32 ( NFS4_SHARE_ACCESS_READ ) ;default : WRITE32 ( 0 ) ;}",4592
672,"if ( ! sock ) goto out ;vhost_disable_notify ( & net -> dev , vq ) ;vhost_hlen = nvq -> vhost_hlen ;sock_hlen = nvq -> sock_hlen ;vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? vq -> log : NULL ;mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ;while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) {sock_len += sock_hlen ;vhost_len = sock_len + vhost_hlen ;headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? UIO_MAXIOV : 1 ) ;if ( unlikely ( headcount < 0 ) ) break ;if ( ! headcount ) {if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) {","if ( unlikely ( headcount > UIO_MAXIOV ) ) {msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\\continue ;}if ( ! headcount ) {if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) {",4593
673,"msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg ,  sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;if ( unlikely ( err != sock_len ) ) {pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\\","msg . msg_iovlen = in ;err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;if ( unlikely ( err != sock_len ) ) {pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\\",4593
674,"if ( size < sizeof ( outarg ) ) goto err ;err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ;err = - ENAMETOOLONG ;if ( outarg . namelen > FUSE_NAME_MAX ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ;if ( err ) goto err ;","if ( size != sizeof ( outarg ) + outarg . namelen > FUSE_NAME_MAX ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) goto err ;name . name = buf ;name . len = outarg . namelen ;err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ;",4594
675,trust_data . dwUIChoice = WTD_UI_ALL ;trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ;return r ;},"trust_data . dwUIChoice = WTD_UI_NONE ;trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ;switch ( r ) {case ERROR_SUCCESS : break ;case TRUST_E_NOSIGNATURE : uprintf ( ""PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ;MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ;break ;default : uprintf ( ""PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ;MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ;break ;}return r ;}",4595
676,"if ( level >= ms -> c . len ) {len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ;ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ;","if ( level >= ms -> c . len = 20 + level ) * sizeof ( * ms -> c . li ) ;ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ;",4596
677,"pid_t child ;char template [ ] = ""virtiofsd-XXXXXX"" ;char * tmpdir ;child = fork ( ) ;if ( child < 0 ) {fuse_log ( FUSE_LOG_ERR , ""fork()<S2SV_blank>failed:<S2SV_blank>%m\\\exit ( 1 ) ;}if ( child > 0 ) {pid_t waited ;int wstatus ;setup_wait_parent_capabilities ( ) ;do {waited = waitpid ( child , & wstatus , 0 ) ;}while ( waited < 0 && errno == EINTR && ! se -> exited ) ;if ( se -> exited ) {exit ( 0 ) ;}if ( WIFEXITED ( wstatus ) ) {exit ( WEXITSTATUS ( wstatus ) ) ;}exit ( 1 ) ;}prctl ( PR_SET_PDEATHSIG , SIGTERM ) ;",pid_t child ;,4597
678,"tmpdir = mkdtemp ( template ) ;if ( ! tmpdir ) {if ( mount ( ""/proc/self/fd"" , tmpdir , NULL , MS_BIND , NULL ) < 0 ) {fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>%s,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\\lo -> proc_self_fd = open ( tmpdir , O_PATH ) ;if ( lo -> proc_self_fd == - 1 ) {fuse_log ( FUSE_LOG_ERR , ""open(%s,<S2SV_blank>O_PATH):<S2SV_blank>%m\\\exit ( 1 ) ;fuse_log ( FUSE_LOG_ERR , ""umount2(%s,<S2SV_blank>MNT_DETACH):<S2SV_blank>%m\\\","tmpdir = mkdtemp ( template ) ;if ( ! tmpdir ) {if ( mount ( ""/proc/self/fd"" , tmpdir , NULL , MS_BIND , NULL ) < 0 ) {fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>%s,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\\lo -> proc_self_fd = open ( tmpdir , O_PATH ) ;if ( lo -> proc_self_fd == - 1 ) {fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\\exit ( 1 ) ;fuse_log ( FUSE_LOG_ERR , ""open(/proc,<S2SV_blank>O_PATH):<S2SV_blank>%m\\\",4597
679,"int c_sz ;if ( ! file_read ( frame , 6 , _fin ) ) return 0 ;if ( memcmp ( frame , ""FRAME"" , 5 ) ) {fprintf ( stderr , ""Loss<S2SV_blank>of<S2SV_blank>framing<S2SV_blank>in<S2SV_blank>Y4M<S2SV_blank>input<S2SV_blank>data\\\return - 1 ;}if ( frame [ 5 ] != \'\\\char c ;int j ;for ( j = 0 ;j < 79 && file_read ( & c , 1 , _fin ) && c != \'\\\j ++ ) {}if ( j == 79 ) {fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>header\\\return - 1 ;}}if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) {fprintf ( stderr , ""Error<S2SV_blank>reading<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>data.\\\return - 1 ;}if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {fprintf ( stderr , ""Error<S2SV_blank>reading<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>data.\\\return - 1 ;}( * _y4m -> convert ) ( _y4m , _y4m -> dst_buf , _y4m -> aux_buf ) ;memset ( _img , 0 , sizeof ( * _img ) ) ;_img -> fmt = _y4m -> vpx_fmt ;_img -> w = _img -> d_w = _y4m -> pic_w ;_img -> h = _img -> d_h = _y4m -> pic_h ;_img -> x_chroma_shift = _y4m -> dst_c_dec_h >> 1 ;_img -> y_chroma_shift = _y4m -> dst_c_dec_v >> 1 ;_img -> bps = _y4m -> vpx_bps ;pic_sz = _y4m -> pic_w * _y4m -> pic_h ;c_w = ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ;c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ;c_sz = c_w * c_h ;_img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w ;_img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ;_img -> planes [ PLANE_Y ] = _y4m -> dst_buf ;_img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ;_img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ;_img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ;return 1 ;",int c_sz ;int bytes_per_sample = _y4m -> bps ;pic_sz = _y4m -> pic_w * _y4m -> pic_h * bytes_per_sample ;c_w = ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ;c_w *= bytes_per_sample ;c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ;c_sz = c_w * c_h ;_img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w * bytes_per_sample ;_img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ;_img -> planes [ PLANE_Y ] = _y4m -> dst_buf ;_img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ;_img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ;_img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ;return 1 ;,4598
680,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;",4599
681,"exit :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret <= 0 ? ret : - EIO ;","exit : mutex_unlock ( & dev -> lock , flags ) ;return ret <= 0 ? ret : - EIO ;",4599
682,"( void ) AcquireUniqueFilename ( postscript_file ) ;ps_file = fopen_utf8 ( postscript_file , ""wb"" ) ;if ( ps_file == ( FILE * ) NULL ) goto FINISH ;( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ;( void ) ReadBlob ( image , 2 * MaxTextExtent , magick ) ;( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ;while ( PS_Size -- > 0 ) {( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ;}( void ) fclose ( ps_file ) ;magic_info = GetMagicInfo ( magick , 2 * MaxTextExtent , exception ) ;if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ;if ( exception -> severity != UndefinedException ) goto FINISH_UNL ;if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ;( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ;FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ;","( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ;FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ;",4600
683,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;",4601
684,"exit :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret <= 0 ? ret : - EIO ;","exit : mutex_unlock ( & dev -> lock , flags ) ;return ret <= 0 ? ret : - EIO ;",4601
685,WORD32 i ;WORD32 sps_id ;,"WORD32 i , j ;WORD32 sps_id ;",4602
686,for ( i = 0 ;i < ps_pps -> i1_num_extra_slice_header_bits ;i ++ ) {,for ( j = 0 ;j < ps_codec -> i4_max_dpb_size ;j ++ ) {,4602
687,"for ( i = 0 ;i ++ )  {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ;break ;","for ( i = 0 ;i ++ ) {ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , j , BUF_MGR_REF ) ;break ;",4602
688,static void  sraSpanRemove ( sraSpan * span ) {span -> _prev -> _next = span -> _next ;},static void sraSpanRemove ( sraSpan * span ) {if ( span ) {span -> _prev -> _next = span -> _next ;}},4603
689,"
","if ( ! N ) {ret = - EINVAL ;parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ;goto out_free ;}",4604
690,prog [ N ] . pred = NULL ;prog [ N ] . target = 1 ;,prog [ N ] . pred = NULL ;prog [ N ] . target = 1 ;,4604
691,"switch ( s -> nal_unit_type ) {case HEVC_NAL_VPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_vps ( gb , s -> avctx , & s -> ps ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_SPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_sps ( gb , s -> avctx , & s -> ps , s -> apply_defdispwin ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_PPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_pps ( gb , s -> avctx , & s -> ps ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_SEI_PREFIX : case HEVC_NAL_SEI_SUFFIX : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) {ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ;if ( ret < 0 ) goto fail ;}ret = ff_hevc_decode_nal_sei ( gb , s -> avctx , & s -> sei , & s -> ps , s -> nal_unit_type ) ;if ( ret < 0 ) goto fail ;break ;case HEVC_NAL_TRAIL_R : case HEVC_NAL_TRAIL_N : case HEVC_NAL_TSA_N : case HEVC_NAL_TSA_R : case HEVC_NAL_STSA_N : case HEVC_NAL_STSA_R : case HEVC_NAL_BLA_W_LP : case HEVC_NAL_BLA_W_RADL : case HEVC_NAL_BLA_N_LP : case HEVC_NAL_IDR_W_RADL : case HEVC_NAL_IDR_N_LP : case HEVC_NAL_CRA_NUT : case HEVC_NAL_RADL_N : case HEVC_NAL_RADL_R : case HEVC_NAL_RASL_N : case HEVC_NAL_RASL_R : ret = hls_slice_header ( s ) ;if ( ret < 0 )  return ret ;if ( ( s -> avctx -> skip_frame >= AVDISCARD_BIDIR && s -> sh . slice_type == HEVC_SLICE_B ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONINTRA && s -> sh . slice_type != HEVC_SLICE_I ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONKEY && ! IS_IRAP ( s ) ) ) {break ;}if ( s -> sh . first_slice_in_pic_flag ) {if ( s -> ref ) {av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\\goto fail ;}if ( s -> max_ra == INT_MAX ) {",switch ( s -> max_ra == INT_MAX ) {,4605
692,if ( ! chan ) {err = - EINVAL ;goto out_free ;}if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ;request -> channels [ i ] = chan ;,request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;,4606
693,"nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) {if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;","nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) {if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) {request -> ssids [ i ] . ssid_len = nla_len ( attr ) ;i ++ ;",4606
694,static inline __u32 dccp_v6_init_sequence ( struct sk_buff * skb )  {,static inline __u64 dccp_v6_init_sequence ( struct sk_buff * skb ) {,4607
695,task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ;task -> tk_owner = current -> tgid ;,task -> tk_rebind_retry = 2 ;task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ;task -> tk_owner = current -> tgid ;,4608
696,"expr_ty returns ;if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) {","expr_ty returns ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) {",4609
697,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
698,"* out = FunctionDef ( name , args , body , decorator_list , returns , lineno ,  col_offset , end_lineno , end_col_offset , arena ) ;","* out = FunctionDef ( name , args , body , decorator_list , returns , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
699,"expr_ty returns ;if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) {","expr_ty returns ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) {",4609
700,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
701,"* out = AsyncFunctionDef ( name , args , body , decorator_list , returns ,   lineno , col_offset , end_lineno , end_col_offset ,  arena ) ;","* out = AsyncFunctionDef ( name , args , body , decorator_list , returns , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
702,"
",string type_comment ;,4609
703,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
704,"if ( _PyObject_LookupAttrId ( obj , & PyId_targets , & tmp ) < 0 ) {return 1 ;","if ( _PyObject_LookupAttrId ( obj , & PyId_targets , & tmp ) < 0 ) {return 1 ;",4609
705,"* out = Assign ( targets , value , lineno , col_offset , end_lineno ,  end_col_offset , arena ) ;","* out = Assign ( targets , value , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
706,"asdl_seq * orelse ;if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) {","asdl_seq * orelse ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) {",4609
707,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
708,"* out = For ( target , iter , body , orelse , lineno , col_offset , end_lineno ,  end_col_offset , arena ) ;","* out = For ( target , iter , body , orelse , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
709,"asdl_seq * orelse ;if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) {","asdl_seq * orelse ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) {",4609
710,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
711,"* out = AsyncFor ( target , iter , body , orelse , lineno , col_offset ,  end_lineno , end_col_offset , arena ) ;","* out = AsyncFor ( target , iter , body , orelse , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
712,"
",string type_comment ;,4609
713,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
714,"if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) {return 1 ;","if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) {return 1 ;",4609
715,"* out = With ( items , body , lineno , col_offset , end_lineno ,  end_col_offset , arena ) ;","* out = With ( items , body , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
716,"asdl_seq * body ;if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) {","asdl_seq * body ;string type_comment ;if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) {",4609
717,"
","if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;type_comment = NULL ;}else {int res ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4609
718,"* out = AsyncWith ( items , body , lineno , col_offset , end_lineno ,  end_col_offset , arena ) ;","* out = AsyncWith ( items , body , type_comment , lineno , col_offset , end_lineno , end_col_offset , arena ) ;",4609
719,"if ( s -> width != avctx -> width && s -> height != avctx -> height ) {ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ;","if ( s -> width != avctx -> width || s -> height != avctx -> height ) {ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ;",4610
720,"struct list_head tmplist ;newsk -> sk_sndbuf = oldsk -> sk_sndbuf ;if ( oldsp -> do_auto_asconf ) {memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ;inet_sk_copy_descendant ( newsk , oldsk ) ;","newsk -> sk_sndbuf = oldsk -> sk_sndbuf ;sctp_copy_descendant ( newsk , oldsk ) ;",4611
721,struct snd_ctl_elem_id id ;unsigned int idx ;,struct snd_ctl_elem_id id ;unsigned int count ;unsigned int idx ;,4612
722,"up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < kcontrol -> count ;idx ++ , id . index ++ , id . numid ++ )  snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;","count = kcontrol -> count ;up_write ( & card -> controls_rwsem ) ;for ( idx = 0 ;idx < count ;idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ;",4612
723,"DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\\","DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>%"" SIZE_T_FORMAT ""u\\\",4613
724,"if ( nelements == 0 ) {DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\goto out ;","if ( nelements > CDF_ELEMENT_LIMIT || nelements == 0 ) {DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\goto out ;",4613
725,"DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\\","
",4613
726,"disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;","disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || IS_MNT_LOCKED_AND_LAZY ( p ) ) ;pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ;",4614
727,"uint16_t numChannels , chansSpecified , chanMask = 0 ;uint32_t sampleRate ;","uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ;uint32_t sampleRate ;",4615
728,"if ( numChannels < chansSpecified || numChannels < 1 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;","if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;",4615
729,"
","if ( ! config -> num_channels ) {error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ;return WAVPACK_SOFT_ERROR ;}",4615
730,total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;break ;,total_samples = dff_chunk_header . ckDataSize / config -> num_channels ;break ;,4615
731,"BIGNUM a , c , d , e ;int i ;BN_init ( & a ) ;BN_init ( & c ) ;BN_init ( & d ) ;BN_init ( & e ) ;BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ;a . neg = rand_neg ( ) ;BN_sqr ( & c , & a , ctx ) ;if ( bp != NULL ) {BN_print ( bp , & a ) ;BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ;BN_print ( bp , & a ) ;BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ;}BN_print ( bp , & c ) ;BIO_puts ( bp , ""\\\}BN_div ( & d , & e , & c , & a , ctx ) ;BN_sub ( & d , & d , & a ) ;if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) )  {fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\\return 0 ;}}BN_free ( & a ) ;BN_free ( & c ) ;BN_free ( & d ) ;BN_free ( & e ) ;return ( 1 ) ;","BIGNUM * a , * c , * d , * e ;int i , ret = 0 ;a = BN_new ( ) ;c = BN_new ( ) ;d = BN_new ( ) ;e = BN_new ( ) ;if ( a == NULL || c == NULL || d == NULL || e == NULL ) {goto err ;}BN_bntest_rand ( a , 40 + i * 10 , 0 , 0 ) ;a -> neg = rand_neg ( ) ;BN_sqr ( c , a , ctx ) ;if ( bp != NULL ) {if ( ! results ) {BN_print ( bp , a ) ;BIO_puts ( bp , a ) ;BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ;}BN_print ( bp , c ) ;BIO_puts ( bp , ""\\\}BN_div ( d , e , c , a , ctx ) ;BN_sub ( & d , & d , & a ) ;if ( ! BN_is_zero ( d ) || ! BN_is_zero ( & e ) ) {fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\\goto err ;}BN_hex2bn ( & a , ""80000000000000000000000080000001FFFFFFFE000000000000000000000000"" ) ;BN_sqr ( c , a , ctx ) ;if ( bp != NULL ) {BN_print ( bp , a ) ;BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ;BN_print ( bp , a ) ;BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ;}BN_print ( bp , c ) ;BIO_puts ( bp , ""\\\}BN_mul ( d , a , a , ctx ) ;if ( BN_cmp ( c , d ) ) {fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\\goto err ;}ret = 1 ;err : if ( a != NULL ) BN_free ( a ) ;if ( c != NULL ) BN_free ( c ) ;if ( d != NULL ) BN_free ( d ) ;if ( e != NULL ) BN_free ( e ) ;return ret ;",4616
732,"wsprintf ( time_buf , TEXT ( ""%d<S2SV_blank>%S<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ) ,  ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] ,  ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;png_snprintf6 ( near_time_buf , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ,  ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] ,  ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;# else png_snprintf6 ( png_ptr -> time_buffer , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ,  ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] ,  ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;","wsprintf ( time_buf , TEXT ( ""%d<S2SV_blank>%S<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ) , ptime -> day % 32 , short_months [ ( ptime -> month - 1U ) % 12 ] , ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;png_snprintf6 ( near_time_buf , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" , ptime -> day % 32 , short_months [ ( ptime -> month - 1U ) % 12 ] , ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;# else png_snprintf6 ( png_ptr -> time_buffer , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" , ptime -> day % 32 , short_months [ ( ptime -> month - 1U ) % 12 ] , ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ;",4617
733,"if ( cfo . op != KD_FONT_OP_SET ) log_warning ( ""Fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>remaining<S2SV_blank>consoles"" ) ;for ( i = 1 ;i <= 63 ;i ++ ) {char ttyname [ sizeof ( ""/dev/tty63"" ) ] ;_cleanup_close_ int fd_d = - 1 ;if ( i == src_idx || verify_vc_allocation ( i ) < 0 ) continue ;xsprintf ( ttyname , ""/dev/tty%u"" , i ) ;fd_d = open_terminal ( ttyname , O_RDWR | O_CLOEXEC | O_NOCTTY ) ;if ( fd_d < 0 ) {log_warning_errno ( fd_d , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>tty%u,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied:<S2SV_blank>%m"" , i ) ;continue ;}if ( verify_vc_kbmode ( fd_d ) < 0 )  continue ;",if ( vt_verify_kbmode ( fd_d ) < 0 ) continue ;,4618
734,"if ( rdf_parser -> uri_filter )  raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;","raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;if ( rdf_parser -> uri_filter ) raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ;",4619
735,fpm_globals . max_requests = wp -> config -> pm_max_requests ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,fpm_globals . max_requests = wp -> config -> pm_max_requests ;fpm_globals . listening_socket = dup ( wp -> listening_socket ) ;if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) {,4620
736,goto retry ;},"err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ;if ( err ) goto out ;err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ;if ( err ) goto out ;goto retry ;}",4621
737,"fprintf ( file , ""<S2SV_blank>%s=\\\\""%s\\\\"""" , tag -> bit_name , tag -> bit_val ) ;}","fputc ( \'<S2SV_blank>\' , file ) ;fputs ( tag -> bit_name , file ) ;fputc ( \'=\' , file ) ;save_quoted ( tag -> bit_val , file ) ;}",4622
738,"end = ( char * ) defs + shdr -> sh_size ;sdb_set ( sdb , ""section_name"" , section_name , 0 ) ;sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ;sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ;sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ;sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ;sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ;for ( cnt = 0 , i = 0 ;i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;",end = ( char * ) defs > i ) ;Sdb * sdb_verdef = sdb_new0 ( ) ;,4623
739,if ( vdaux < 1 ) {sdb_free ( sdb_verdef ) ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) {sdb_free ( sdb_verdef ) ;if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) {sdb_free ( sdb_verdef ) ;,4623
740,if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) {sdb_free ( sdb_verdef ) ;,4623
741,next_input = input + i * input_incr ;if ( bytes_matched + i >= max_bytes_matched )  break ;if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) {,if ( bytes_matched + i >= max_bytes_matched ) break ;next_input = input + i * input_incr ;if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) {,4624
742,ip = next_opcode ;break ;,"bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;ip = next_opcode ;break ;",4624
743,"
",dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;,4625
744,random_ether_addr ( dev -> dev_addr ) ;dev -> tx_queue_len = TUN_READQ_SIZE ;,random_ether_addr ( dev -> dev_addr ) ;dev -> tx_queue_len = TUN_READQ_SIZE ;,4625
745,"near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ;}near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ;}near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ;near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ;near_sad [ 2 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 - 16 , xd -> dst . y_stride , UINT_MAX ) ;}","near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride ) ;}near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride ) ;}near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride ) ;near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride ) ;near_sad [ 2 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride ) ;}",4626
746,"if ( near_sad [ 4 ] != INT_MAX )  near_sad [ 4 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ;if ( near_sad [ 5 ] != INT_MAX )  near_sad [ 5 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - 16 , pre_y_stride , UINT_MAX ) ;near_sad [ 3 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer , pre_y_stride , UINT_MAX ) ;if ( near_sad [ 6 ] != INT_MAX )  near_sad [ 6 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + 16 , pre_y_stride , UINT_MAX ) ;if ( near_sad [ 7 ] != INT_MAX )  near_sad [ 7 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ;}","if ( near_sad [ 4 ] != INT_MAX ) near_sad [ 4 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - pre_y_stride * 16 , pre_y_stride ) ;if ( near_sad [ 5 ] != INT_MAX ) near_sad [ 5 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - 16 , pre_y_stride ) ;near_sad [ 3 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer , pre_y_stride ) ;if ( near_sad [ 6 ] != INT_MAX ) near_sad [ 6 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + 16 , pre_y_stride ) ;if ( near_sad [ 7 ] != INT_MAX ) near_sad [ 7 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + pre_y_stride * 16 , pre_y_stride ) ;}",4626
747,"
","xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;",4627
748,out_dqrele :  xfs_qm_dqrele ( udqp ) ;,out_dqrele : xfs_qm_dqrele ( udqp ) ;,4627
749,static void parse_input ( h2o_http2_conn_t * conn )  {,static int parse_input ( h2o_http2_conn_t * conn ) {,4628
750,close_connection ( conn ) ;return ;return ;EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ;},return close_connection ( conn ) ;return 0 ;EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ;return 0 ;},4628
751,"forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  NULL , NULL ) ;forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  NULL , NULL ) ;","forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , offset , flags , NULL , NULL ) ;forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , offset , flags , NULL , NULL ) ;",4629
752,"backward_matches = exec ( ac_match -> backward_code ,  data + offset ,  offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ;","backward_matches = exec ( ac_match -> backward_code , data + offset , data_size - offset , offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ;",4629
753,"if ( av_strstart ( url , ""crypto"" , NULL ) ) {if ( url [ 6 ] == \'+\' || url [ 6 ] == \':\' ) proto_name = avio_find_protocol_name ( url + 7 ) ;if ( ! proto_name ) proto_name = avio_find_protocol_name ( url ) ;if ( ! proto_name ) return AVERROR_INVALIDDATA ;if ( ! av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) )  return AVERROR_INVALIDDATA ;","if ( av_strstart ( proto_name , ""file"" , NULL ) ) {if ( strcmp ( c -> allowed_extensions , ""ALL"" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) {av_log ( s , AV_LOG_ERROR , ""Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\\\\\'%s\\\\\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\\return AVERROR_INVALIDDATA ;}else if ( av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) ) {;}else return AVERROR_INVALIDDATA ;",4630
754,while ( buflen > 0 ) {union_desc = ( struct usb_cdc_union_desc * ) buf ;return union_desc ;},"while ( buflen >= sizeof ( * union_desc ) ) {union_desc = ( struct usb_cdc_union_desc * ) buf ;if ( union_desc -> bLength > buflen ) {dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\\return NULL ;}if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ;dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\\return NULL ;}",4631
755,"i += 2 ;found_default = 1 ;}else if ( found_default ) {ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ;return NULL ;}arg = ast_for_arg ( c , ch ) ;if ( ! arg ) return NULL ;asdl_seq_SET ( posargs , k ++ , arg ) ;i += 2 ;break ;case STAR : if ( i + 1 >= NCH ( n ) ||  ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) {ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ;res = handle_keywordonly_args ( c , n , i ,  kwonlyargs , kwdefaults ) ;if ( res == - 1 ) return NULL ;i = res ;}else {vararg = ast_for_arg ( c , ch ) ;if ( ! vararg ) return NULL ;i += 3 ;if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) {int res = 0 ;res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ;if ( res == - 1 ) return NULL ;i = res ;}}case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ;assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ;kwarg = ast_for_arg ( c , ch ) ;if ( ! kwarg ) return NULL ;i += 3 ;break ;","i += 1 ;if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) i += 1 ;break ;case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) {ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) {vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ;if ( ! vararg -> type_comment ) return NULL ;i += 2 ;if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ;break ;case TYPE_COMMENT : assert ( i ) ;if ( kwarg ) arg = kwarg ;arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ;if ( ! arg -> type_comment ) return NULL ;i += 1 ;",4632
756,"if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) )  return ( 0 ) ;tif -> tif_rawcc = 0 ;","if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) ) {tif -> tif_rawcc = 0 ;tif -> tif_rawcp = tif -> tif_rawdata ;return ( 0 ) ;}tif -> tif_rawcc = 0 ;",4633
757,ASSERT ( redir_index < IOAPIC_NUM_PINS ) ;redir_content = ioapic -> redirtbl [ redir_index ] . bits ;result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ;,if ( redir_index < IOAPIC_NUM_PINS ) ;redir_content = ioapic -> redirtbl [ redir_index ] . bits ;else redir_content = ~ 0ULL ;result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ;,4634
758,"vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;","memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;",4635
759,"if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {error = - EOPNOTSUPP ;goto out_errno ;}error = fh_want_write ( fh ) ;if ( error )  goto out_errno ;error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ;if ( error ) goto out_drop_write ;error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  ACL_TYPE_DEFAULT ) ;","error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;}error = fh_want_write ( fh ) ;if ( error ) goto out_errno ;fh_lock ( fh ) ;error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ;if ( error ) goto out_drop_lock ;error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ;",4636
760,pvc . sap_family = AF_ATMPVC ;pvc . sap_addr . itf = vcc -> dev -> number ;,"memset ( & pvc , 0 , sizeof ( pvc ) ) ;pvc . sap_family = AF_ATMPVC ;pvc . sap_addr . itf = vcc -> dev -> number ;",4637
761,cancel_delayed_work_sync ( & ln -> grace_period_end ) ;locks_end_grace ( & ln -> lockd_manager ) ;,"
",4638
762,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;exit :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;exit : mutex_unlock ( & dev -> lock , flags ) ;return ret ;",4639
763,out :  kfree ( resp ) ;return res ;,out : kfree ( req ) ;kfree ( resp ) ;return res ;,4640
764,"umode_t mode = inode -> i_mode ;error = posix_acl_equiv_mode ( acl , & mode ) ;if ( error <= 0 ) {acl = NULL ;if ( error < 0 ) return error ;}error = xfs_set_mode ( inode , mode ) ;","umode_t mode ;error = posix_acl_equiv_mode ( acl , & mode , & acl ) ;if ( error ) return error ;}error = xfs_set_mode ( inode , mode ) ;",4641
765,"RING_IDX cons = vif -> tx . req_cons ;int frags = 0 ;if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ;do {if ( frags >= work_to_do ) {netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\\return - frags ;netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\\return - frags ;","netdev_err ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\\netbk_fatal_tx_err ( vif ) ;return - frags ;netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\\return - frags ;netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\\return - frags ;netdev_err ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\\netbk_fatal_tx_err ( vif ) ;return - frags ;",4642
766,"const struct aodv_hello * ah ;switch ( ep -> type ) {if ( length < sizeof ( struct aodv_hello ) )  goto trunc ;ND_PRINT ( ( ndo , ""\\\","const struct aodv_hello * ah ;ND_TCHECK ( * ep ) ;switch ( ep -> type ) {if ( length < sizeof ( struct aodv_hello ) ) goto trunc ;if ( ep -> length < 4 ) {ND_PRINT ( ( ndo , ""\\\break ;}ND_PRINT ( ( ndo , ""\\\",4643
767,"down_write ( & mm -> mmap_sem ) ;vma = find_vma_prev ( mm , start , & prev ) ;","down_write ( & mm -> mmap_sem ) ;if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;vma = find_vma_prev ( mm , start , & prev ) ;",4644
768,},DeleteCriticalSection ( & reference_queue_mutex ) ;},4645
769,"char * ksep , * vsep , * val ;size_t klen , vlen ;vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {return 0 ;","char * start , * ksep , * vsep , * val ;size_t klen , vlen ;start = var -> ptr + var -> already_scanned ;vsep = memchr ( start , '&' , var -> end - var -> ptr ) ;if ( ! vsep ) {if ( ! eof ) {var -> already_scanned = var -> end - var -> ptr ;return 0 ;",4646
770,return 1 ;},var -> already_scanned = 0 ;return 1 ;},4646
771,"strncpy ( szSec , opt_string , sepIdx ) ;szSec [ sepIdx ] = 0 ;sep ++ ;sep2 = strchr ( sep , \'=\' ) ;if ( ! sep2 ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\\{const size_t sepIdx = sep2 - sep ;strncpy ( szKey , sep , sepIdx ) ;szKey [ sepIdx ] = 0 ;strcpy ( szVal , sep2 + 1 ) ;}","if ( sepIdx >= sizeof ( szSec ) ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\\return ;strncpy ( szSec , opt_string , sepIdx ) ;szSec [ sepIdx ] = 0 ;if ( strlen ( sep2 + 1 ) >= sizeof ( szVal ) ) {fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\\strcpy ( szVal , sep2 + 1 ) ;}",4647
772,"out_put :  fput_light ( sock -> file , fput_needed ) ;if ( err == 0 )  return datagrams ;if ( datagrams != 0 ) {return datagrams ;}return err ;}","if ( err == 0 ) goto out_put ;if ( datagrams == 0 ) return datagrams ;if ( datagrams != 0 ) {out_put : fput_light ( sock -> file , fput_needed ) ;return datagrams ;}",4648
773,message -> srcIpAddr = queueItem -> srcIpAddr ;message -> srcPort = queueItem -> srcPort ;,message -> interface = queueItem -> interface ;message -> srcIpAddr = queueItem -> srcIpAddr ;message -> srcPort = queueItem -> srcPort ;,4649
774,"int hns_nic_net_xmit_hw ( struct net_device * ndev ,  struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) {","netdev_tx_t hns_nic_net_xmit_hw ( struct net_device * ndev , struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) {",4650
775,wmb ( ) ;assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ;,netif_trans_update ( ndev ) ;ndev -> stats . tx_bytes += skb -> len ;ndev -> stats . tx_packets ++ ;wmb ( ) ;assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ;,4650
776,"static void  horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {assert ( ( cc % stride ) == 0 ) ;if ( cc > stride ) {","static int horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) {if ( ( cc % stride ) != 0 ) {TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%stride)!=0"" ) ;return 0 ;}if ( cc > stride ) {",4651
777,},return 1 ;},4651
778,"vma_stop ( priv , vma ) ;if ( priv -> task ) put_task_struct ( priv -> task ) ;","if ( ! IS_ERR ( vma ) ) vma_stop ( priv , vma ) ;if ( priv -> task ) put_task_struct ( priv -> task ) ;",4652
779,"if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX )  OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 )   OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( oe_syscall_recvv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > 0 )  {","size_t data_size = 0 ;if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size , & data_size ) != 0 ) OE_RAISE_ERRNO ( OE_ENOMEM ) ;if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ;if ( oe_syscall_recvv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) {if ( ret > ( ssize_t ) ( data_size ) ) {ret = - 1 ;OE_RAISE_ERRNO ( OE_EINVAL ) ;}if ( ret > 0 ) {",4653
780,"slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & bind_method ) ;slapi_pblock_get ( pb , SLAPI_OPERATION , & operation ) ;slapi_pblock_get ( pb , SLAPI_CONNECTION , & conn ) ;if ( text ) {pbtext = text ;else {slapi_pblock_get ( pb , SLAPI_PB_RESULT_TEXT , & pbtext ) ;}","slapi_pblock_get ( pb , SLAPI_RESULT_TEXT , & pbtext ) ;",4654
781,if ( jas_init ( ) ) {abort ( ) ;infile = 0 ;verbose = 0 ;,"size_t max_samples ;char optstr [ 32 ] ;if ( jas_init ( ) ) {abort ( ) ;max_samples = 64 * JAS_MEBI ;infile = 0 ;verbose = 0 ;case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ;break ;",4655
782,"case OPT_MAXMEM :  max_mem = strtoull ( jas_optarg , 0 , 10 ) ;","case OPT_MAXMEM : max_mem = strtoull ( jas_optarg , 0 , 10 ) ;",4655
783,"
","snprintf ( optstr , sizeof ( optstr ) , ""max_samples=%-zu"" , max_samples ) ;",4655
784,"if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) {jas_stream_close ( instream ) ;if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\\","if ( ! ( image = jas_image_decode ( instream , fmtid , optstr ) ) ) {jas_stream_close ( instream ) ;if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {jas_eprintf ( ""format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\\return EXIT_FAILURE ;}if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) {fprintf ( stderr , ""warning:<S2SV_blank>image<S2SV_blank>has<S2SV_blank>no<S2SV_blank>components\\\",4655
785,"if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) {abort ( ) ;}printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\\jas_image_destroy ( image ) ;","printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\\jas_image_destroy ( image ) ;",4655
786,"static void update_state ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx ,  int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const struct segmentation * const seg = & cm -> seg ;const int mis = cm -> mi_stride ;if ( seg -> enabled && output_enabled ) {if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) {mi_addr -> mbmi . segment_id =  vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}else if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) {vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi ,  mi_row , mi_col , bsize , 1 ) ;vp9_init_plane_quantizers ( cpi , x ) ;","static void update_state ( VP9_COMP * cpi , ThreadData * td , PICK_MODE_CONTEXT * ctx , int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ) {RD_COUNTS * const rdc = & td -> rd_counts ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;const struct segmentation * const seg = & cm -> seg ;const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ;const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ;const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ;const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ;MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ;int w , h ;const int mis = cm -> mi_stride ;* x -> mbmi_ext = ctx -> mbmi_ext ;if ( seg -> enabled ) {if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) {mi_addr -> mbmi . segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) {vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , mi_row , mi_col , bsize , ctx -> rate , ctx -> dist , x -> skip ) ;",4656
787,"if ( bsize < BLOCK_32X32 ) {if ( bsize < BLOCK_16X16 ) ctx -> tx_rd_diff [ ALLOW_16X16 ] = ctx -> tx_rd_diff [ ALLOW_8X8 ] ;ctx -> tx_rd_diff [ ALLOW_32X32 ] = ctx -> tx_rd_diff [ ALLOW_16X16 ] ;}vpx_memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk ,   sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ;if ( ! output_enabled ) return ;if ( ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) {for ( i = 0 ;i < TX_MODES ;i ++ ) cpi -> rd_tx_select_diff [ i ] += ctx -> tx_rd_diff [ i ] ;}","memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk , sizeof ( ctx -> zcoeff_blk [ 0 ] ) * ctx -> num_4x4_blk ) ;if ( ! output_enabled ) return ;",4656
788,"vp9_update_mv_count ( cm , xd ) ;if ( cm -> interp_filter == SWITCHABLE ) {++ cm -> counts . switchable_interp [ ctx ] [ mbmi -> interp_filter ] ;}cpi -> rd_comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ;cpi -> rd_comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ;cpi -> rd_comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ;for ( i = 0 ;++ i )  cpi -> rd_filter_diff [ i ] += ctx -> best_filter_diff [ i ] ;}}",vp9_update_mv_count ( td ) ;if ( cm -> interp_filter == SWITCHABLE ) {+ cm -> counts . switchable_interp [ ctx ] [ mbmi -> interp_filter ] ;++ td -> counts -> switchable_interp [ ctx ] [ mbmi -> interp_filter ] ;}rdc -> comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ;rdc -> comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ;rdc -> comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ;for ( i = 0 ;+ i )  cpi -> rd_filter_diff [ i ] += ctx -> best_filter_diff [ i ] ;++ i ) rdc -> filter_diff [ i ] += ctx -> best_filter_diff [ i ] ;}for ( h = 0 ;h < y_mis ;++ h ) {MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ;for ( w = 0 ;w < x_mis ;++ w ) {MV_REF * const mv = frame_mv + w ;mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ;mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ;mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ;mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ;}}},4656
789,"int x , y , pos ;Wbmp * wbmp ;if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) {gd_error ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP"" ) ;return ;}pos = 0 ;for ( y = 0 ;y < gdImageSY ( image ) ;y ++ ) {for ( x = 0 ;x < gdImageSX ( image ) ;x ++ ) {if ( gdImageGetPixel ( image , x , y ) == fg ) {wbmp -> bitmap [ pos ] = WBMP_BLACK ;","_gdImageWBMPCtx ( image , x , y ) == fg ) {wbmp -> bitmap [ pos ] = WBMP_BLACK ;",4657
790,"oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ;oidc_debug ( r , ""enter<S2SV_blank>(url=%s)"" , url ) ;","char * error_str = NULL ;char * error_description = NULL ;oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ;oidc_debug ( r , ""enter<S2SV_blank>(url=%s)"" , url ) ;",4658
791,"const char * error_description = NULL ;apr_uri_t uri ;if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) {const char * error_description = apr_psprintf ( r -> pool , ""Logout<S2SV_blank>URL<S2SV_blank>malformed:<S2SV_blank>%s"" , url ) ;oidc_error ( r , ""%s"" , error_description ) ;return oidc_util_html_send_error ( r , c -> error_template ,  ""Malformed<S2SV_blank>URL"" , error_description ,  HTTP_INTERNAL_SERVER_ERROR ) ;return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , error_description , HTTP_INTERNAL_SERVER_ERROR ) ;","if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) {return oidc_util_html_send_error ( r , c -> error_template , ""Malformed<S2SV_blank>URL"" , error_description , HTTP_INTERNAL_SERVER_ERROR ) ;return oidc_util_html_send_error ( r , c -> error_template , error_str , error_description , HTTP_BAD_REQUEST ) ;",4658
792,"uint16 bitspersample , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;","uint16 bitspersample = 1 , samplesperpixel = 1 ;uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ;",4659
793,"int error ;struct pci_emul_dummy * dummy ;error = pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ;assert ( error == 0 ) ;error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) ;assert ( error == 0 ) ;error = pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ;assert ( error == 0 ) ;assert ( error == 0 ) ;return 0 ;","struct pci_emul_dummy * dummy ;return pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ;assert ( error == 0 ) ;error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) || pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ;assert ( error == 0 ) ;assert ( error == 0 ) ;return 0 ;",4660
794,"ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ;if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;return - 1 ;}","ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;",4661
795,"static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags )  {if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {}else if ( ctx -> might_cancel ) {timerfd_remove_cancel ( ctx ) ;}","static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) {spin_lock ( & ctx -> cancel_lock ) ;if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) {else {__timerfd_remove_cancel ( ctx ) ;}spin_unlock ( & ctx -> cancel_lock ) ;}",4662
796,"case TUNNEL_PASS : if ( length < 3 )  {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ;}",case TUNNEL_PASS : if ( length < 3 ) goto trunc ;,4663
797,"if ( length < 1 )  {ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ;return ;}case EGRESS_VLAN_NAME :  ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , tok2str ( rfc4675_tagged , ""Unknown<S2SV_blank>tag"" , * data ) , * data ) ) ;for ( i = 0 ;* data && i < length ;i ++ , data ++ )  ND_PRINT ( ( ndo , ""%c"" , ( * data < 32 || * data > 126 ) ? \'.\' : * data ) ) ;","if ( length < 1 ) goto trunc ;case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ;ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , tok2str ( rfc4675_tagged , ""Unknown<S2SV_blank>tag"" , * data ) , * data ) ) ;for ( i = 0 ;i < length && * data ;i ++ , data ++ ) ND_PRINT ( ( ndo , ""%c"" , ( * data < 32 || * data > 126 ) ? \'.\' : * data ) ) ;",4663
798,"if ( archive_string_ensure ( as , as -> length + len + 1 ) == NULL ) return ( - 1 ) ;","if ( archive_string_ensure ( as , as -> length + max ( len + 1 ) == NULL ) return ( - 1 ) ;",4664
799,"if ( archive_string_ensure ( as ,  as -> length + len * 2 + 1 ) == NULL )  return ( - 1 ) ;","if ( archive_string_ensure ( as , as -> length + len * 2 , ( size_t ) MB_CUR_MAX ) + 1 ) == NULL ) return ( - 1 ) ;",4664
800,"if ( strlen ( str ) >= sizeof ( lowstr ) )  {return NULL ;}return NULL ;}result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ;if ( ! result ) return NULL ;if ( dtype != DTK_DELTA ) {if ( tm2interval ( tm , fsec , result ) != 0 )  {","if ( strlen ( str ) > MAXDATELEN ) {return NULL ;}free ( result ) ;return NULL ;}if ( tm2interval ( tm , fsec , result ) != 0 ) {errno = PGTYPES_INTVL_BAD_INTERVAL ;return NULL ;}if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) {if ( tm2interval ( tm , fsec , result ) != 0 ) {",4665
801,if ( phy -> port -> num_phys == 0 )  sas_port_delete ( phy -> port ) ;phy -> port = NULL ;,"if ( phy -> port -> num_phys == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list ) ;phy -> port = NULL ;",4666
802,"log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\\continue ;","if ( file -> file_type == FILE_TYPE_GEOMETRY ) {log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\\}else {log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\\}continue ;",4667
803,vpx_scale_rtcd ( ) ;once ( setup_rtcd_internal ) ;,once ( setup_rtcd_internal ) ;,4668
804,"static VALUE from_document ( VALUE klass , VALUE document )  {Data_Get_Struct ( document , xmlDoc , doc ) ;doc = doc -> doc ;if ( has_blank_nodes_p ( DOC_NODE_CACHE ( doc ) ) ) {","static VALUE from_document ( int argc , VALUE * argv , VALUE klass ) {VALUE document ;VALUE parse_options ;int parse_options_int ;int scanned_args = 0 ;scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ;Data_Get_Struct ( document , xmlDoc , doc ) ;doc = doc -> doc ;if ( scanned_args == 1 ) {parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ;}parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) ;if ( has_blank_nodes_p ( DOC_NODE_CACHE ( doc ) ) ) {rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;",4669
805,return rb_schema ;return Qnil ;,return rb_schema ;return Qnil ;,4669
806,usb_unanchor_urb ( urb ) ;break ;,usb_unanchor_urb ( urb ) ;usb_free_urb ( urb ) ;break ;,4670
807,"int fd = accept ( socket -> fd , NULL , NULL ) ;if ( fd == INVALID_FD ) {","int fd = TEMP_FAILURE_RETRY ( accept ( socket -> fd , NULL , NULL ) ) ;if ( fd == INVALID_FD ) {",4671
808,"int perf_event_task_enable ( void )  {struct perf_event * event ;list_for_each_entry ( event , & current -> perf_event_list , owner_entry )   perf_event_for_each_child ( event , perf_event_enable ) ;mutex_unlock ( & current -> perf_event_mutex ) ;","int perf_event_task_enable ( void ) {struct perf_event_context * ctx ;struct perf_event * event ;list_for_each_entry ( event , _perf_event_enable ) ;perf_event_ctx_unlock ( event , ctx ) ;}mutex_unlock ( & current -> perf_event_mutex ) ;",4672
809,"struct desc_struct * desc ;short sel ;if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ;if ( user_64bit_mode ( regs ) ) {unsigned long base ;if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ;else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ;else base = 0 ;return base ;}desc = get_desc ( sel ) ;if ( ! desc )  return - 1L ;return get_desc_base ( desc ) ;}",struct desc_struct desc ;short sel ;desc = get_desc ( sel ) ;if ( ! desc ) return - 1L ;return get_desc_base ( & desc ) ;},4673
810,"if ( ! pflag ) ( void ) umask ( mask ) ;if ( argc != 1 ) {run_err ( ""ambiguous<S2SV_blank>target"" ) ;exit ( 1 ) ;}targ = * argv ;if ( targetshouldbedirectory ) verifydir ( targ ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ;for ( first = 1 ;;first = 0 ) {cp = buf ;if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ;if ( * cp ++ == \'\\\do {if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ;* cp ++ = ch ;}while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != \'\\\* cp = 0 ;if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ;if ( buf [ 0 ] == \'\\\\01\' || buf [ 0 ] == \'\\\\02\' ) {if ( iamremote == 0 ) {( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ;( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ;}if ( buf [ 0 ] == \'\\\\02\' ) exit ( 1 ) ;++ errs ;continue ;}if ( buf [ 0 ] == \'E\' ) {( void ) atomicio ( vwrite , remout , """" , 1 ) ;return ;}if ( ch == \'\\\cp = buf ;if ( * cp == \'T\' ) {setimes ++ ;cp ++ ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;mtime . tv_sec = ull ;mtime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;atime . tv_sec = ull ;atime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'\\\\0\' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;continue ;}if ( * cp != \'C\' && * cp != \'D\' ) {if ( first ) {run_err ( ""%s"" , cp ) ;exit ( 1 ) ;}SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ;}mode = 0 ;for ( ++ cp ;cp < buf + 5 ;cp ++ ) {if ( * cp < \'0\' || * cp > \'7\' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ;mode = ( mode << 3 ) | ( * cp - \'0\' ) ;}if ( ! pflag ) mode &= ~ mask ;if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ;size = ( off_t ) ull ;if ( ( strchr ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;","+ errs ;if ( * cp == \'\\\\0\' || strchr ( cp , ""."" ) == 0 || strcmp ( cp , \'/\' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;",4674
811,"len = netlink_send ( fd , message ) ;syslog ( LOG_ERR , ""netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ;pfd . events = POLLIN ;pfd . revents = 0 ;len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ;if ( len < 0 ) {syslog ( LOG_ERR , ""recv<S2SV_blank>failed;close ( fd ) ;","len = recvfrom ( fd , message ) ;syslog ( LOG_ERR , ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) ) ;struct sockaddr * addr_p = ( struct sockaddr * ) & addr ;socklen_t addr_l = sizeof ( addr ) ;pfd . events = POLLIN ;pfd . revents = 0 ;len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 , addr_p , & addr_l ) ;if ( len < 0 || addr . nl_pid ) {syslog ( LOG_ERR , ""recv<S2SV_blank>failed;close ( fd ) ;",4675
812,"gss_buffer_desc client_name , service_name ;OM_uint32 minor_stat ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;OM_uint32 minor_stat ;,4676
813,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",4676
814,int data_len = elt -> length -   sizeof ( struct oz_get_desc_rsp ) + 1 ;u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;,"u16 offs , total_size ;u8 data_len ;if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ;data_len = elt -> length - ( sizeof ( struct oz_get_desc_rsp ) - 1 ) ;offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ;total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ;",4677
815,"
","case OZ_SET_CONFIG_RSP : {struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_SET_INTERFACE_RSP : {struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ;}break ;case OZ_VENDOR_CLASS_RSP : {struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ;oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ;}break ;",4677
816,"static struct nfs4_opendata * nfs4_opendata_alloc ( struct path * path ,  struct nfs4_state_owner * sp , int flags ,  const struct iattr * attrs ) {","static struct nfs4_opendata * nfs4_opendata_alloc ( struct path * path , struct nfs4_state_owner * sp , fmode_t fmode , int flags , const struct iattr * attrs ) {",4678
817,"p -> o_arg . open_flags = flags ,  p -> o_arg . clientid = server -> nfs_client -> cl_clientid ;",p -> o_arg . open_flags = flags ;p -> o_arg . fmode = fmode & ( FMODE_READ | FMODE_WRITE ) ;p -> o_arg . clientid = server -> nfs_client -> cl_clientid ;,4678
818,int err = 0 ;if ( ! asoc ) return - EINVAL ;,"int err = 0 ;if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL ;if ( ! asoc ) return - EINVAL ;",4679
819,"struct page * pages [ NFS4ACL_MAXPAGES ] ;struct nfs_getaclargs args = {. fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , }struct nfs_getaclres res = {. acl_len = buflen , };void * resp_buf ;struct rpc_message msg = {. rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , };struct page * localpage = NULL ;int ret ;if ( buflen < PAGE_SIZE ) {localpage = alloc_page ( GFP_KERNEL ) ;resp_buf = page_address ( localpage ) ;if ( localpage == NULL )  return - ENOMEM ;args . acl_pages [ 0 ] = localpage ;args . acl_pgbase = 0 ;args . acl_len = PAGE_SIZE ;else {resp_buf = buf ;buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ;if ( res . acl_len > args . acl_len )   nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ;else  nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ;if ( buf ) {ret = - ERANGE ;if ( res . acl_len > buflen )  goto out_free ;if ( localpage )   memcpy ( buf , resp_buf , res . acl_len ) ;}out_free :  if ( localpage )   __free_page ( localpage ) ;return ret ;","struct page * pages [ NFS4ACL_MAXPAGES ] = {NULL , }int ret = - ENOMEM , npages , i , acl_len = 0 ;npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ;if ( npages == 0 ) npages = 1 ;for ( i = 0 ;i < npages ;i ++ ) {pages [ i ] = alloc_page ( GFP_KERNEL ) ;if ( ! pages [ i ] ) goto out_free ;if ( npages > 1 ) {args . acl_scratch = alloc_page ( GFP_KERNEL ) ;if ( ! args . acl_scratch ) goto out_free ;args . acl_len = npages * PAGE_SIZE ;args . acl_pgbase = 0 ;if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ;resp_buf = page_address ( pages [ 0 ] ) ;dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\\acl_len = res . acl_len - res . acl_data_offset ;if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ;else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ;if ( acl_len > buflen ) goto out_free ;if ( localpage ) memcpy ( buf , resp_buf , res . acl_len ) ;}out_free : for ( i = 0 ;i < npages ;i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ;if ( args . acl_scratch ) __free_page ( args . acl_scratch ) ;return ret ;",4680
820,"struct ip_options * opt ;opt = inet_sk ( sk ) -> opt ;if ( opt == NULL || opt -> cipso == 0 )  return - ENOMSG ;return cipso_v4_getattr ( opt -> __data + opt -> cipso - sizeof ( struct iphdr ) ,  secattr ) ;}","struct ip_options_rcu * opt ;opt = inet_sk ( sk ) -> inet_opt ) ;if ( opt == NULL || opt -> cipso == 0 ) return - ENOMSG ;return cipso_v4_getattr ( opt -> opt . __data + opt -> opt . cipso - sizeof ( struct iphdr ) , secattr ) ;rcu_read_unlock ( ) ;return res ;}",4681
821,"replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ;encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ;encode_nops ( & hdr ) ;}","replen = hdr . replen + op_decode_hdr_maxsz + 1 ;encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ;xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;encode_nops ( & hdr ) ;}",4682
822,"# else  char common_name [ FIELD_SIZE + 1 ] ;if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host ,  FIELD_SIZE ) == 0 )  cert_valid = 1 ;","# else if ( validate_hostname ( tunnel -> config -> gateway_host , FIELD_SIZE ) == 0 ) cert_valid = 1 ;",4683
823,task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ;task -> tk_owner = current -> tgid ;,task -> tk_rebind_retry = 2 ;task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ;task -> tk_owner = current -> tgid ;,4684
824,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |  NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ;if ( ses -> server -> sign ) {flags |= NTLMSSP_NEGOTIATE_SIGN ;}sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ;,flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL ;if ( ses -> server -> sign ) flags |= NTLMSSP_NEGOTIATE_SIGN ;sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ;,4685
825,"vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ;bsi . segment_rd = best_rd ;","memset ( & bsi , 0 , sizeof ( bsi ) ) ;bsi . segment_rd = best_rd ;",4686
826,"if ( n < 0 ) {if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ;syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ;goto error ;}if ( n == 0 ) {syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ;goto error ;}t = time ( NULL ) ;type = buf [ 0 ] ;p = buf + 1 ;DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ;","if ( l > ( unsigned ) ( buf + n - p ) ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ;",4687
827,"if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) {syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ;goto error ;}break ;case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ;while ( d && ( nrep < 255 ) ) {if ( d -> t < t ) {syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ;}else {if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ;if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) {m = d -> headers [ HEADER_LOCATION ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ;rp += d -> headers [ HEADER_LOCATION ] . l ;m = d -> headers [ HEADER_NT ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ;rp += d -> headers [ HEADER_NT ] . l ;m = d -> headers [ HEADER_USN ] . l ;CODELENGTH ( m , rp ) ;memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ;rp += d -> headers [ HEADER_USN ] . l ;nrep ++ ;}}d = d -> next ;}for ( serv = servicelisthead . lh_first ;serv && ( nrep < 255 ) ;serv = serv -> entries . le_next ) {if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ;if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) {m = strlen ( serv -> location ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> location , m ) ;rp += m ;m = strlen ( serv -> st ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> st , m ) ;rp += m ;m = strlen ( serv -> usn ) ;CODELENGTH ( m , rp ) ;memcpy ( rp , serv -> usn , m ) ;rp += m ;nrep ++ ;}}rbuf [ 0 ] = nrep ;syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ;if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) {syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ;goto error ;}break ;case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ;if ( ! newserv ) {syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ;goto error ;}memset ( newserv , 0 , sizeof ( struct service ) ) ;if ( containsForbiddenChars ( p , l ) ) {syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ;goto error ;}newserv -> st = malloc ( l + 1 ) ;if ( ! newserv -> st ) {syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ;goto error ;}memcpy ( newserv -> st , p , l ) ;newserv -> st [ l ] = \'\\\\0\' ;p += l ;if ( p >= buf + n ) {DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ;if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( l > ( unsigned ) ( buf + n - p ) ) {DECODELENGTH_CHECKLIMIT ( l , p , buf + n - p ) ) ;if ( p + l > buf + n - p ) ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",4687
828,"if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",4687
829,"if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;","if ( p + l > buf + n ) {syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ;",4687
830,vhost_net_ubuf_put_and_wait ( oldubufs ) ;mutex_lock ( & vq -> mutex ) ;,vhost_net_ubuf_put_wait_and_free ( oldubufs ) ;mutex_lock ( & vq -> mutex ) ;,4688
831,if ( ubufs )  vhost_net_ubuf_put_and_wait ( ubufs ) ;err_ubufs : fput ( sock -> file ) ;,if ( ubufs ) vhost_net_ubuf_put_wait_and_free ( ubufs ) ;err_ubufs : fput ( sock -> file ) ;,4688
832,}cpi -> zeromv_count = 0 ;vpx_free ( cpi -> gf_active_flags ) ;cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;,"memset ( cpi -> gf_active_flags ) ;# if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {vp8_denoiser_free ( & cpi -> denoiser ) ;vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ;}# endif cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;",4689
833,"vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;# if CONFIG_MULTITHREAD if ( width < 640 ) cpi -> mt_sync_range = 1 ;","vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;# if CONFIG_MULTITHREAD if ( width < 640 ) cpi -> mt_sync_range = 1 ;",4689
834,},},4689
835,"jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\\return - 1 ;","jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\\return - 1 ;}if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) {jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\\return - 1 ;}if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) {jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\\return - 1 ;",4690
836,"jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data ,  tile -> tcomps [ 2 ] . data ) ;","jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , tile -> tcomps [ 2 ] . data ) ;",4690
837,"outpos +=  sprintf ( outpos , ""\\\}","sprintf ( outputbuffer , ""\\\sendClean ( outputbuffer ) ;}",4691
838,"if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) {err = ""argument<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\\\'yes\\\'<S2SV_blank>or<S2SV_blank>\\\'no\\\'"" ;","if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 || class == CLIENT_TYPE_MASTER ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\\\'master\\\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" ;",4692
839,"if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;","if ( class == - 1 ) {err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class"" ;",4692
840,"while ( * end_ptr != \\\'\\\\""\\\' && * end_ptr && ++ len ) if ( * end_ptr ++ == \'\\\\\\\\\' ) end_ptr ++ ;out = ( char * ) cJSON_malloc ( len + 1 ) ;","while ( * end_ptr != \\\'\\\\""\\\' && * end_ptr && ++ len ) {if ( * end_ptr ++ == \'\\\\\\\\\' ) {if ( * end_ptr == \'\\\\0\' ) {return 0 ;}end_ptr ++ ;}}out = ( char * ) cJSON_malloc ( len + 1 ) ;",4693
841,"
",if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;,4694
842,"sk_wait_data ( sk , & timeo , NULL ) ;if ( signal_pending ( current ) ) {","sk_wait_data ( sk , & timeo , NULL ) ;if ( signal_pending ( current ) ) {",4694
843,"bool inode_owner_or_capable ( const struct inode * inode )  {if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ;if ( inode_capable ( inode , CAP_FOWNER ) )  return true ;","bool inode_owner_or_capable ( const struct inode * inode ) {struct user_namespace * ns ;if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ;ns = current_user_ns ( ) ;if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid ) ) return true ;",4695
844,"if ( ! fs_searchpaths )  Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;for ( search = fs_searchpaths ;search = search -> next )   {len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;","qboolean isLocalConfig ;if ( ! fs_searchpaths ) Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ;isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ;for ( search = fs_searchpaths ;search = search -> next ) {if ( isLocalConfig && search -> pack ) continue ;len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ;",4696
845,"static void write_profile ( BITSTREAM_PROFILE profile ,  struct vp9_write_bit_buffer * wb ) {assert ( profile < MAX_PROFILES ) ;vp9_wb_write_bit ( wb , profile & 1 ) ;vp9_wb_write_bit ( wb , profile >> 1 ) ;}","static void write_profile ( BITSTREAM_PROFILE profile , struct vpx_write_bit_buffer * wb ) {assert ( profile < MAX_PROFILES ) ;vp9_wb_write_bit ( wb , 2 , 2 ) ;break ;case PROFILE_2 : vpx_wb_write_literal ( wb , 1 , 2 ) ;break ;case PROFILE_3 : vpx_wb_write_literal ( wb , 6 , 3 ) ;break ;default : assert ( 0 ) ;}}",4697
846,if ( ! unconditional ( & e -> arp ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,4698
847,"struct IGDdatas * datas = ( struct IGDdatas * ) d ;memcpy ( datas -> cureltname , name , l ) ;","struct IGDdatas * datas = ( struct IGDdatas * ) d ;if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1 ;memcpy ( datas -> cureltname , name , l ) ;",4699
848,"if ( PyDict_SetItemString ( d , ""mod"" , ( PyObject * ) mod_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""Module"" , ( PyObject * ) Module_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""Suite"" , ( PyObject * ) Suite_type ) < 0 ) return  NULL ;","if ( PyModule_AddIntMacro ( m , PyCF_TYPE_COMMENTS ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""FunctionType"" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""mod"" , ( PyObject * ) mod_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""Module"" , ( PyObject * ) Module_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""Suite"" , ( PyObject * ) Suite_type ) < 0 ) return NULL ;",4700
849,"if ( PyDict_SetItemString ( d , ""withitem"" , ( PyObject * ) withitem_type ) < 0 )  return NULL ;","if ( PyDict_SetItemString ( d , ""withitem"" , ( PyObject * ) withitem_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""type_ignore"" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ;if ( PyDict_SetItemString ( d , ""TypeIgnore"" , ( PyObject * ) TypeIgnore_type ) < 0 ) return NULL ;",4700
850,l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;l_mco_size = 5 + l_tcp -> m_nb_mcc_records ;,l_mco_size = 5 + l_tcp -> m_nb_mcc_records ;,4701
851,"opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ;l_current_data += 2 ;","l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ;l_current_data += 2 ;",4701
852,"L3 = emitjump ( J , F , OP_JUMP ) ;}","emit ( J , F , OP_ENDTRY ) ;L3 = emitjump ( J , F , OP_JUMP ) ;}",4702
853,"struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , unsigned int height , unsigned int subsampling_x , unsigned int subsampling_y ,  unsigned int depth ) {struct lookahead_ctx * ctx = NULL ;unsigned int i ;ctx -> max_sz = depth ;i ++ )  if ( vp9_alloc_frame_buffer ( & ctx -> buf [ i ] . img ,  width , height , subsampling_x , subsampling_y ,  VP9_ENC_BORDER_IN_PIXELS ) )  goto bail ;","struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , unsigned int height , unsigned int subsampling_x , unsigned int subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif unsigned int depth ) {struct lookahead_ctx * ctx = NULL ;const int legacy_byte_alignment = 0 ;unsigned int i ;ctx -> max_sz = depth ;i ++ ) if ( vpx_alloc_frame_buffer ( & ctx -> buf [ i ] . img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment ) ) goto bail ;",4703
854,if ( err ) return err ;,if ( err ) {kvfree ( in ) ;return err ;,4704
855,"if ( err )   goto err_cqwq ;cqc = MLX5_ADDR_OF ( create_cq_in , in , cq_context ) ;","}if ( err ) goto err_cqwq ;cqc = MLX5_ADDR_OF ( create_cq_in , in , cq_context ) ;",4704
856,"if ( ! mp -> ports && ! mp -> mglist &&  netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;","if ( ! mp -> ports && ! mp -> mglist && mp -> timer_armed && netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ;",4705
857,"static ext4_io_end_t * ext4_init_io_end ( struct inode * inode )  {io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ;if ( io ) {io -> inode = inode ;io -> flag = 0 ;io -> offset = 0 ;io -> size = 0 ;io -> error = 0 ;INIT_WORK ( & io -> work , ext4_end_io_work ) ;","static ext4_io_end_t * ext4_init_io_end ( struct inode * inode , gfp_t flags ) {io = kmalloc ( sizeof ( * io ) , flags ) ;if ( io ) {io -> page = NULL ;INIT_WORK ( & io -> work , ext4_end_io_work ) ;",4706
858,"row += nrow )  {rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ;if ( _TIFFReadEncodedStripAndAllocBuffer ( tif ,  TIFFComputeStrip ( tif , row + img -> row_offset , 0 ) , ( void * * ) ( & buf ) , maxstripsize ,  ( ( row + img -> row_offset ) % rowsperstrip + nrowsub ) * scanline ) == ( tmsize_t ) ( - 1 )  && ( buf == NULL || img -> stoponerr ) ) {","row += nrow ) {uint32 temp ;rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ;temp = ( row + img -> row_offset ) % rowsperstrip + nrowsub ;if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) {TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripContig"" ) ;return 0 ;}if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , TIFFComputeStrip ( tif , row + img -> row_offset , 0 ) , ( void * * ) ( & buf ) , maxstripsize , temp * scanline ) == ( tmsize_t ) ( - 1 ) && ( buf == NULL || img -> stoponerr ) ) {",4707
859,passert ( GLOBALS_ARE_RESET ( ) ) ;},},4708
860,"int copied , error = - EINVAL ;msg -> msg_namelen = 0 ;","int copied , error = - EINVAL ;",4709
861,if ( count >= 4 ) {int retTIFFReadRawTile ;,if ( count > 4 ) {int retTIFFReadRawTile ;,4710
862,const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ;const int ph = 4 * num_4x4_blocks_high_lookup [ bsize ] ;,const VP9_COMMON * const cm = & cpi -> common ;const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ;const int ph = 4 * num_4x4_blocks_high_lookup [ bsize ] ;,4711
863,"uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ;const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ;struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ;struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ;int last_besterr [ 2 ] = {for ( ref = 0 ;ref_mv [ ref ] = mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] ;if ( scaled_ref_frame [ ref ] ) {","const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ;struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ;struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ;int last_besterr [ 2 ] = {# if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ;uint8_t * second_pred ;# else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ;# endif for ( ref = 0 ;ref_mv [ ref ] = x -> mbmi_ext -> ref_mvs [ refs [ ref ] ] [ 0 ] ;if ( scaled_ref_frame [ ref ] ) {",4711
864,for ( ite = 0 ;struct buf_2d ref_yv12 [ 2 ] ;int_mv tmp_mv ;int search_range = 3 ;,"# if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ;# else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ;# endif for ( ite = 0 ;struct buf_2d ref_yv12 [ 2 ] ;MV tmp_mv ;int search_range = 3 ;",4711
865,"vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf ,  ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv ,  & xd -> block_refs [ ! id ] -> sf ,  pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ;if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = ref_yv12 [ id ] ;tmp_mv . as_int = frame_mv [ refs [ id ] ] . as_int ;tmp_mv . as_mv . col >>= 3 ;tmp_mv . as_mv . row >>= 3 ;bestsme = vp9_refining_search_8p_c ( x , & tmp_mv . as_mv , sadpb ,  search_range , & cpi -> fn_ptr [ bsize ] , x -> nmvjointcost , x -> mvcost , & ref_mv [ id ] . as_mv , second_pred , pw , ph ) ;if ( bestsme < INT_MAX )  bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv ,  second_pred , & cpi -> fn_ptr [ bsize ] , 1 ) ;","# if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) {second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ;vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ;}# else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ;# endif if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = ref_yv12 [ id ] ;tmp_mv = frame_mv [ refs [ id ] ] . as_mv ;tmp_mv . col >>= 3 ;tmp_mv . as_mv . row >>= 3 ;bestsme = vp9_refining_search_8p_c ( x , & tmp_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] . as_mv , second_pred ) ;if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv , second_pred , & cpi -> fn_ptr [ bsize ] , 1 ) ;",4711
866,"bestsme = cpi -> find_fractional_mv_step_comp (   x , & tmp_mv . as_mv ,   & ref_mv [ id ] . as_mv ,  cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] ,  0 , cpi -> sf . subpel_iters_per_step ,  x -> nmvjointcost , x -> mvcost , & dis , & sse , second_pred , pw , ph ) ;if ( id )  xd -> plane [ 0 ] . pre [ 0 ] = scaled_first_yv12 ;if ( bestsme < last_besterr [ id ] ) {frame_mv [ refs [ id ] ] . as_int = tmp_mv . as_int ;last_besterr [ id ] = bestsme ;","bestsme = cpi -> find_fractional_mv_step_comp ( x , & tmp_mv , & ref_mv [ id ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , 0 , cpi -> sf . mv . subpel_iters_per_step , NULL , x -> nmvjointcost , x -> mvcost , & dis , & sse , second_pred , pw , ph ) ;if ( id ) xd -> plane [ 0 ] . pre [ 0 ] = ref_yv12 [ 0 ] ;if ( bestsme < last_besterr [ id ] ) {frame_mv [ refs [ id ] ] . as_mv = tmp_mv ;last_besterr [ id ] = bestsme ;",4711
867,"* rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ ref ] ] . as_mv ,  & mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv ,  x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;vpx_free ( second_pred ) ;}","* rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ ref ] ] . as_mv , & x -> mbmi_ext -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ;}",4711
868,"if ( ( tot_len - offset - 4 ) < bodyLength ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;","if ( ( ( tot_len - offset - 4 ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) ) {AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short"" , AIRPDCAP_DEBUG_LEVEL_3 ) ;",4712
869,v -> sum_error = s ;v -> count = c ;if ( c > 0 )  v -> variance = ( int ) ( 256 * ( v -> sum_square_error - v -> sum_error * v -> sum_error / v -> count ) / v -> count ) ;else v -> variance = 0 ;,v -> log2_count = c ;,4713
870,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , p_total_data_size , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",4714
871,"if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) {","if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , p_total_data_size , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) {",4714
872,"if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream ,  p_manager ) ) {","if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , p_manager ) ) {",4714
873,"void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name )  {","static void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) {",4715
874,dst [ dst_byte_offset ] = 0 ;current_bit_offset = 0 ;,current_bit_offset = 0 ;,4716
875,"ret = copy_to_user ( uattr , attr , usize ) ;if ( ret ) return - EFAULT ;","ret = copy_to_user ( uattr , attr , attr -> size ) ;if ( ret ) return - EFAULT ;",4717
876,ulong tmp ;assert ( ( ! sgnd && prec >= 1 ) || ( sgnd && prec >= 2 ) ) ;,jas_ulong tmp ;assert ( ( ! sgnd && prec >= 1 ) || ( sgnd && prec >= 2 ) ) ;,4718
877,"assert ( ops != NULL ) ;pr_notice ( ""pci<S2SV_blank>init<S2SV_blank>%s\\\\r\\\","if ( ! ops ) {pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\\continue ;}pr_notice ( ""pci<S2SV_blank>init<S2SV_blank>%s\\\\r\\\",4719
878,"assert ( error == 0 ) ;bzero ( & mr , sizeof ( struct mem_range ) ) ;assert ( error == 0 ) ;bzero ( & mr , sizeof ( struct mem_range ) ) ;assert ( error == 0 ) ;return 0 ;","if ( error != 0 ) goto pci_emul_init_fail ;bzero ( & mr , sizeof ( struct mem_range ) ) ;if ( error != 0 ) goto pci_emul_init_fail ;bzero ( & mr , sizeof ( struct mem_range ) ) ;if ( error != 0 ) goto pci_emul_init_fail ;return 0 ;",4719
879,"assert ( ops != NULL ) ;pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ;","if ( ! ops ) {pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\\continue ;}pci_emul_deinit ( ctx , ops , bus , slot , func , fi ) ;",4719
880,"BN_ULONG t1 , t2 ;BN_ULONG c1 , c2 , c3 ;","BN_ULONG c1 , c2 , c3 ;",4720
881,"for ( j = 0 ;j ++ )   av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ;av_log ( s , AV_LOG_DEBUG , ""\\\'\\\","for ( j = 0 ;j ++ ) {if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ;}av_log ( s , AV_LOG_DEBUG , ""\\\'\\\",4721
882,"
","if ( strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ;",4722
883,if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) )  goto error ;,if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) goto error ;,4722
884,"unsigned char * const seg_map = cpi -> segmentation_map ;const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ;if ( ! apply_cyclic_refresh || ( cm -> frame_type == KEY_FRAME ) ||  ( cpi -> svc . temporal_layer_id > 0 ) ) {vpx_memset ( seg_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;if ( cm -> frame_type == KEY_FRAME )   cr -> sb_index = 0 ;return ;int i , block_count , bl_index , sb_rows , sb_cols , sbs_in_frame ;int xmis , ymis , x , y , qindex2 ;const float rate_ratio_qdelta = 2.0 ;vp9_clear_system_state ( ) ;","const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ;if ( cm -> current_video_frame == 0 ) cr -> low_content_avg = 0.0 ;if ( ! apply_cyclic_refresh || ( cm -> frame_type == KEY_FRAME ) || ( cpi -> svc . temporal_layer_id > 0 ) || ( cpi -> svc . spatial_layer_id > 0 ) ) {unsigned char * const seg_map = cpi -> segmentation_map ;memset ( seg_map , 0 , cm -> mi_rows * cm -> mi_cols ) ;if ( cm -> frame_type == KEY_FRAME ) {memset ( cr -> last_coded_q_map , MAXQ , cm -> mi_rows * cm -> mi_cols * sizeof ( * cr -> last_coded_q_map ) ) ;cr -> sb_index = 0 ;}return ;int qindex2 ;const float rate_ratio_qdelta = 2.0 ;vp9_clear_system_state ( ) ;",4723
885,"vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ;vp9_enable_segfeature ( seg , 1 , SEG_LVL_ALT_Q ) ;qindex_delta = vp9_compute_qdelta_by_rate ( rc , cm -> frame_type , cm -> base_qindex , rate_ratio_qdelta ) ;if ( - qindex_delta > cr -> max_qdelta_perc * cm -> base_qindex / 100 ) qindex_delta = - cr -> max_qdelta_perc * cm -> base_qindex / 100 ;qindex2 = clamp ( cm -> base_qindex + cm -> y_dc_delta_q + qindex_delta , 0 , MAXQ ) ;cr -> rdmult = vp9_compute_rd_mult ( cpi , qindex2 ) ;vp9_set_segdata ( seg , 1 , SEG_LVL_ALT_Q , qindex_delta ) ;sb_cols = ( cm -> mi_cols + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ;sb_rows = ( cm -> mi_rows + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ;","vp9_disable_segfeature ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q , qindex_delta ) ;sb_cols = ( cm -> mi_cols + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ;sb_rows = ( cm -> mi_rows + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ;",4723
886,"bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ;}","bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPU_ID ) ;}",4724
887,"( void ) SeekBlob ( image , 0 , SEEK_SET ) ;while ( EOFBlob ( image ) != MagickFalse ) {","quantum_info = ( QuantumInfo * ) NULL ;( void ) SeekBlob ( image , 0 , SEEK_SET ) ;while ( EOFBlob ( image ) != MagickFalse ) {",4725
888,"status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;","if ( quantum_info != ( QuantumInfo * ) NULL ) status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ;",4725
889,"quantum_info = DestroyQuantumInfo ( quantum_info ) ;rotate_image = RotateImage ( image , 90.0 , exception ) ;","quantum_info = DestroyQuantumInfo ( quantum_info ) ;rotate_image = RotateImage ( image , 90.0 , exception ) ;",4725
890,interface = intf -> cur_altsetting ;endpoint = & interface -> endpoint [ 0 ] . desc ;,interface = intf -> cur_altsetting ;if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL ;endpoint = & interface -> endpoint [ 0 ] . desc ;,4726
891,"register u_int length = h -> len ;register u_int caplen = h -> caplen ;if ( caplen < CHDLC_HDRLEN ) {ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ;return ( caplen ) ;return ( chdlc_print ( ndo , p , length ) ) ;}","return chdlc_print ( ndo , p , length ) ) ;",4727
892,if ( ! ( block = nlmsvc_find_block ( cookie ) ) ) return ;if ( block ) {if ( status == nlm_lck_denied_grace_period ) {}nlmsvc_release_block ( block ) ;,if ( status == nlm_lck_denied_grace_period ) {}nlmsvc_release_block ( block ) ;,4728
893,"case 1 :  hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset ,  fd . entrylength ) ;","case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) {err = - EIO ;goto out ;}if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) {err = - EIO ;goto out ;}hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , fd . entrylength ) ;",4729
894,"hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset ,  fd . entrylength ) ;","hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , fd . entrylength ) ;",4729
895,dec -> xstart = siz -> xoff ;dec -> ystart = siz -> yoff ;,size_t size ;dec -> xstart = siz -> xoff ;dec -> ystart = siz -> yoff ;,4730
896,"dec -> numtiles = dec -> numhtiles * dec -> numvtiles ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;for ( tileno = 0 , tile = dec -> tiles ;++ tileno ,  ++ tile ) {","if ( ! jas_safe_size_mul ( dec -> numhtiles * dec -> numvtiles ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;dec -> numtiles = size ;JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\\if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) {return - 1 ;}for ( tileno = 0 , tile = dec -> tiles ;+ tileno ,  ++ tile ) {++ tileno , ++ tile ) {",4730
897,tfrc . tfrctx_x = hc -> tx_x ;tfrc . tfrctx_x_recv = hc -> tx_x_recv ;,"memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;tfrc . tfrctx_x = hc -> tx_x ;tfrc . tfrctx_x_recv = hc -> tx_x_recv ;",4731
898,"assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ;memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ;","memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ;",4732
899,"if ( jp2_getuint16 ( in , & pclr -> numlutents ) ||  jp2_getuint8 ( in , & pclr -> numchans ) ) {","pclr -> bpc = 0 ;if ( jp2_getuint16 ( in , & pclr -> numlutents ) || jp2_getuint8 ( in , & pclr -> numchans ) ) {",4733
900,"if ( item_num > 65536 ) {av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\","if ( item_num > 65536 || item_num < 0 ) {av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\\",4734
901,"char buf [ L_BUF_SIZE ] ;char * cmdname ;# ifndef _WIN32  snprintf ( buf , L_BUF_SIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ;# else  snprintf ( buf , L_BUF_SIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ;# endif # ifndef OS_IOS ignore = system ( buf ) ;","char buf [ L_BUFSIZE ] ;char * cmdname ;# ifndef _WIN32 snprintf ( buf , L_BUFSIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ;# else snprintf ( buf , L_BUFSIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ;# endif # ifndef OS_IOS ignore = system ( buf ) ;",4735
902,"dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\\","dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\\",4736
903,"int  run_cmd ( int fd , ... )  {","int run_cmd ( int fd , const char * cmd , const char * args_extra ) {",4737
904,"char cmd [ 512 ] ;term_remove ( STI ) ;dup2 ( fd , STI ) ;dup2 ( fd , STO ) ;{char * c , * ce ;const char * s ;int n ;va_list vls ;strcpy ( cmd , EXEC ) ;c = & cmd [ sizeof ( EXEC ) - 1 ] ;","int argc ;char * argv [ RUNCMD_ARGS_MAX + 1 ] ;int r ;term_remove ( STI ) ;argc = 0 ;r = split_quoted ( cmd , EXEC ) ;c = & cmd [ sizeof ( EXEC ) - 1 ] ;",4737
905,"fd_printf ( STDERR_FILENO , ""%s\\\establish_child_signal_handlers ( ) ;sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ;execl ( ""/bin/sh"" , ""sh"" , ""-c"" , cmd , NULL ) ;exit ( 42 ) ;}","fd_printf ( STDERR_FILENO , ""exec:<S2SV_blank>%s\\\exit ( 42 ) ;}",4737
906,err :  aio_free_ring ( ctx ) ;free_percpu ( ctx -> cpu ) ;,err : free_percpu ( ctx -> cpu ) ;,4738
907,"if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) {return - 1 ;","if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) {jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\return - 1 ;}if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) {return - 1 ;",4739
908,"char * driver_override , * old = pdev -> driver_override , * cp ;if ( count > PATH_MAX ) return - EINVAL ;if ( strlen ( driver_override ) ) {pdev -> driver_override = driver_override ;kfree ( old ) ;return count ;","char * driver_override , * old , * cp ;if ( count > PATH_MAX ) return - EINVAL ;device_lock ( dev ) ;old = pdev -> driver_override ;if ( strlen ( driver_override ) ) {pdev -> driver_override = driver_override ;device_unlock ( dev ) ;kfree ( old ) ;return count ;",4740
909,"if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK )  save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;gtk_widget_destroy ( textview ) ;","if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK ) {save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ;problem_data_reload_from_dump_dir ( ) ;update_gui_state_from_problem_data ( 0 ) ;}gtk_widget_destroy ( textview ) ;",4741
910,"# endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn ,  root_storage -> d_storage_uuid ) ) < 0 )  expn = ""Can\\\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ;","# endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn , root_storage ) ) < 0 ) expn = ""Can\\\'t<S2SV_blank>expand<S2SV_blank>summary_info"" ;",4742
911,"err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 ,  & msg -> addrto , & msg -> ifindex ) ;if ( err ) {err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message"" ) ;goto free_msg ;}dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" ,   str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ;if ( len < sizeof ( * msg -> icmp6_hdr ) ) {","err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 , & msg -> addrto , & msg -> ifindex , & msg -> hoplimit ) ;if ( err ) {err ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" , str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ;if ( len < sizeof ( * msg -> icmp6_hdr ) ) {",4743
912,"int i ;int ret ;ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ;if ( ! pci_is_enabled ( dev ) ) return ret ;if ( dev -> resource [ i ] . flags & IORESOURCE_IO )  * value |= PCI_COMMAND_IO ;if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ;}","int ret = pci_read_config_word ( dev , offset , value , data ) ;if ( ! pci_is_enabled ( dev ) ) return ret ;if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) * value |= cmd -> val & ~ PCI_COMMAND_GUEST ;",4744
913,"static MB_PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) {return ( MB_PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ;}","static PREDICTION_MODE read_intra_mode ( vpx_reader * r , const vp9_prob * p ) {return ( PREDICTION_MODE ) vpx_read_tree ( r , vp9_intra_mode_tree , p ) ;}",4745
914,struct mlx5_ib_create_qp_resp resp ;struct mlx5_ib_cq * send_cq ;,struct mlx5_ib_create_qp_resp resp = {};struct mlx5_ib_cq * send_cq ;,4746
915,"vpx_memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ;vpx_memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ;vpx_memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ;}","memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ;memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ;memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ;}",4747
916,"hlist_add_head ( & mp -> mglist , & br -> mglist ) ;mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ;","if ( hlist_unhashed ( & mp -> mglist ) ) hlist_add_head ( & mp -> mglist , & br -> mglist ) ;mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ;",4748
917,"if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) {s -> width = s -> height = 0 ;","if ( ( ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ) < 0 ) {s -> width = s -> height = 0 ;",4749
918,"DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\","if ( NULL == filegen ) {msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ;continue ;}DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\\\'%s%s\\\'\\\",4750
919,filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;,"if ( NULL == filegen ) {msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\\\'%s\\\'<S2SV_blank>unrecognized"" , filegen_file ) ;continue ;}filegen_flag = filegen -> flag ;filegen_type = filegen -> type ;",4750
920,"if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) {pte_unmap_unlock ( ptep , ptl ) ;","if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) {pte_unmap_unlock ( ptep , ptl ) ;",4751
921,kfree ( ubufs ) ;},},4752
922,"static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd ,  int mi_row , int mi_col , vp9_reader * r ) {struct segmentation * const seg = & cm -> seg ;const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;if ( ! seg -> update_map )   return 0 ;segment_id = read_segment_id ( r , seg ) ;set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;return segment_id ;","static int read_intra_segment_id ( VP9_COMMON * const cm , int mi_offset , int x_mis , int y_mis , vpx_reader * r ) {struct segmentation * const seg = & cm -> seg ;if ( ! seg -> update_map ) {copy_segment_id ( cm , mi_offset , x_mis , y_mis , segment_id ) ;return segment_id ;",4753
923,"static int  ext2_xattr_cache_insert ( struct buffer_head * bh )  {struct mb_cache_entry * ce ;int error ;ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ;if ( ! ce ) return - ENOMEM ;error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {}else {ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash ,  atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ;mb_cache_entry_release ( ce ) ;","static int ext2_xattr_cache_insert ( struct mb2_cache * cache , struct buffer_head * bh ) {int error ;ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ;if ( ! ce ) return - ENOMEM ;error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr ) ;if ( error ) {mb_cache_entry_free ( ce ) ;if ( error == - EBUSY ) {else ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash ) ;",4754
924,"# define COPY_PORT ( dest , src ) do {","if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) {dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\\return - ENODEV ;}# define COPY_PORT ( dest , src ) do {",4755
925,"swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ;","swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ;",4755
926,"VP9_COMMON * const cm = & pbi -> common ;int i ;vp9_remove_common ( cm ) ;vp9_worker_end ( & pbi -> lf_worker ) ;vpx_free ( pbi -> lf_worker . data1 ) ;for ( i = 0 ;VP9Worker * const worker = & pbi -> tile_workers [ i ] ;vp9_worker_end ( worker ) ;vpx_free ( worker -> data1 ) ;vpx_free ( worker -> data2 ) ;}if ( pbi -> num_tile_workers ) {const int sb_rows = mi_cols_aligned_to_sb ( cm -> mi_rows ) >> MI_BLOCK_SIZE_LOG2 ;vp9_loop_filter_dealloc ( & pbi -> lf_row_sync , sb_rows ) ;}","int i ;vp9_remove_common ( cm ) ;vp9_worker_end ( & pbi -> lf_worker ) ;vpx_free ( pbi -> lf_worker . data1 ) ;vpx_free ( pbi -> tile_data ) ;for ( i = 0 ;VPxWorker * const worker = & pbi -> tile_workers [ i ] ;vpx_get_worker_interface ( ) -> end ( worker ) ;}vpx_free ( pbi -> tile_worker_data ) ;vpx_free ( worker -> data2 ) ;}if ( pbi -> num_tile_workers > 0 ) {vp9_loop_filter_dealloc ( & pbi -> lf_row_sync , sb_rows ) ;}",4756
927,"char * fpath = NULL , * cgdir = NULL , * controller ;const char * cgroup ;","char * fpath = NULL , * cgdir = NULL , * controller , * next = NULL ;const char * cgroup ;",4757
928,"fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\\if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;return ret ;}","if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , & next ) ) {if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) {ret = - EACCES ;goto out ;}if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ;else ret = - ENOENT ;if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) {ret = - EACCES ;goto out ;}if ( ! cgfs_remove ( controller , cgroup ) ) {ret = - EINVAL ;free ( next ) ;return ret ;}",4757
929,"if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint ,  jas_image_numcmpts ( dec -> image ) ) ) {","if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) {",4758
930,"for ( i = 1 ;i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ;if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) {","for ( i = 1 ;i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;if ( jas_image_cmptdtype ( dec -> image , i ) != dtype ) {",4758
931,"if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts (  dec -> image ) ) ) {for ( i = 0 ;i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ;++ i ) {","if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) {+ i ) {for ( i = 0 ;i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;++ i ) {",4758
932,"dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans :  JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ;if ( dec -> cmap ) {if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint ,  jas_image_numcmpts ( dec -> image ) ) ) {","dec -> numchans = dec -> cmap ? dec -> cmap -> data . cmap . numchans : JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;if ( dec -> cmap ) {if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ) {",4758
933,"for ( i = 0 ;i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ;jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ;","for ( i = 0 ;i < JAS_CAST ( jas_uint , jas_image_numcmpts ( dec -> image ) ) ;jas_image_setcmpttype ( dec -> image , i , JAS_IMAGE_CT_UNKNOWN ) ;",4758
934,"return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb ,  jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ;","return ( tsfb -> numlvls > 0 && jas_seq2d_size ( a ) ) ? jpc_tsfb_synthesize2 ( tsfb , jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ;",4759
935,spin_lock_init ( & port -> phy_list_lock ) ;INIT_LIST_HEAD ( & port -> phy_list ) ;,INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;spin_lock_init ( & port -> phy_list_lock ) ;INIT_LIST_HEAD ( & port -> phy_list ) ;,4760
936,if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA )  ret = - EADDRNOTAVAIL ;,if ( ret || ! cm_id -> device || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) ret = - EADDRNOTAVAIL ;,4761
937,"dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ;if ( dh == NULL ) {","dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ;if ( dh == NULL ) {",4762
938,"lua_pushvalue ( L , i ) ;mp_encode_lua_type ( L , buf , 0 ) ;","luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ;lua_pushvalue ( L , i ) ;mp_encode_lua_type ( L , buf , 0 ) ;",4763
939,if ( pmd_none_or_clear_bad ( pmd ) )  continue ;,if ( pmd_none_or_trans_huge_or_clear_bad ( pmd ) ) continue ;,4764
940,"r = vapic_enter ( vcpu ) ;if ( r ) {srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;return r ;}kvm_vcpu_block ( vcpu ) ;vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ;if ( kvm_check_request ( KVM_REQ_UNHALT , vcpu ) ) {kvm_apic_accept_events ( vcpu ) ;switch ( vcpu -> arch . mp_state ) {case KVM_MP_STATE_HALTED : vcpu -> arch . pv . pv_unhalted = false ;vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ;case KVM_MP_STATE_RUNNABLE : vcpu -> arch . apf . halted = false ;break ;case KVM_MP_STATE_INIT_RECEIVED : break ;default : r = - EINTR ;break ;}}}if ( r <= 0 ) break ;clear_bit ( KVM_REQ_PENDING_TIMER , & vcpu -> requests ) ;if ( kvm_cpu_has_pending_timer ( vcpu ) ) kvm_inject_pending_timer_irqs ( vcpu ) ;if ( dm_request_for_irq_injection ( vcpu ) ) {r = - EINTR ;vcpu -> run -> exit_reason = KVM_EXIT_INTR ;++ vcpu -> stat . request_irq_exits ;}kvm_check_async_pf_completion ( vcpu ) ;if ( signal_pending ( current ) ) {r = - EINTR ;vcpu -> run -> exit_reason = KVM_EXIT_INTR ;++ vcpu -> stat . signal_exits ;}if ( need_resched ( ) ) {srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;kvm_resched ( vcpu ) ;vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ;}}srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ;vapic_exit ( vcpu ) ;return r ;",+ vcpu -> stat . request_irq_exits ;+ vcpu -> stat . signal_exits ;return r ;,4765
941,"guint pkt_len ;int pktnum , hr , min , sec , csec ;","int pkt_len , pktnum , hr , min , sec , csec ;",4766
942,"num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {* err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\\\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ;return FALSE ;","num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ;if ( num_items_scanned != 1 ) {* err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\\\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ;return FALSE ;}if ( pkt_len < 0 ) {* err = WTAP_ERR_BAD_FILE ;* err_info = g_strdup ( ""toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ;return FALSE ;",4766
943,struct llc_pktinfo info ;info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ;,"struct llc_pktinfo info ;memset ( & info , 0 , sizeof ( info ) ) ;info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ;",4767
944,"unsigned int len ;unsigned long start = 0 , off ;struct au1200fb_device * fbdev = info -> par ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {",struct au1200fb_device * fbdev = info -> par ;if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) {,4768
945,"return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT ,  vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;","return vm_iomap_memory ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ;",4768
946,"rpc_delay ( task , 3 * HZ ) ;goto retry_timeout ;","if ( task -> tk_rebind_retry == 0 ) break ;task -> tk_rebind_retry -- ;rpc_delay ( task , 3 * HZ ) ;goto retry_timeout ;",4769
947,"__mincore_unmapped_range ( addr , end , vma , vec ) ;goto out ;if ( pte_none ( pte ) )  __mincore_unmapped_range ( addr , addr + PAGE_SIZE ,  vma , vec ) ;if ( non_swap_entry ( entry ) ) {* vec = 1 ;}else {# ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ;# else WARN_ON ( 1 ) ;* vec = 1 ;# endif }","memset ( vec , 1 , nr ) ;goto out ;if ( pte_none ( pte ) ) * vec = 0 ;* vec = ! ! non_swap_entry ( entry ) ;",4770
948,}else {,rdp -> nego -> transport -> credssp = NULL ;}else {,4771
949,"if ( memcmp ( ef -> sb -> oem_name , ""EXFAT<S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) != 0 ) {exfat_close ( ef -> dev ) ;free ( ef -> sb ) ;exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ;return - EIO ;}ef -> zero_cluster = malloc ( CLUSTER_SIZE ( * ef -> sb ) ) ;if ( ef -> zero_cluster == NULL ) {exfat_close ( ef -> dev ) ;free ( ef -> sb ) ;exfat_error ( ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>zero<S2SV_blank>sector"" ) ;return - ENOMEM ;}if ( ! verify_vbr_checksum ( ef -> dev , ef -> zero_cluster , SECTOR_SIZE ( * ef -> sb ) ) ) {free ( ef -> zero_cluster ) ;exfat_close ( ef -> dev ) ;free ( ef -> sb ) ;return - EIO ;}memset ( ef -> zero_cluster , 0 , CLUSTER_SIZE ( * ef -> sb ) ) ;if ( ef -> sb -> version . major != 1 || ef -> sb -> version . minor != 0 ) {free ( ef -> zero_cluster ) ;exfat_close ( ef -> dev ) ;exfat_error ( ""unsupported<S2SV_blank>exFAT<S2SV_blank>version:<S2SV_blank>%hhu.%hhu"" , ef -> sb -> version . major , ef -> sb -> version . minor ) ;free ( ef -> sb ) ;return - EIO ;}if ( ef -> sb -> fat_count != 1 ) {free ( ef -> zero_cluster ) ;exfat_close ( ef -> dev ) ;exfat_error ( ""unsupported<S2SV_blank>FAT<S2SV_blank>count:<S2SV_blank>%hhu"" , ef -> sb -> fat_count ) ;free ( ef -> sb ) ;return - EIO ;}if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 )  {free ( ef -> zero_cluster ) ;exfat_close ( ef -> dev ) ;exfat_error ( ""too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^%d"" , ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits ) ;free ( ef -> sb ) ;return - EIO ;}","
",4772
950,"exo_job_info_message ( EXO_JOB ( job ) , g_file_info_get_display_name ( info ) ) ;retry_copy : real_target_file = thunar_transfer_job_copy_file ( job , node -> source_file , target_file , & err ) ;","exo_job_info_message ( EXO_JOB ( job ) , ""%s"" , g_file_info_get_display_name ( info ) ) ;retry_copy : real_target_file = thunar_transfer_job_copy_file ( job , node -> source_file , target_file , & err ) ;",4773
951,"
",if ( shm_file == NULL ) {err = - EIDRM ;goto out_unlock0 ;},4774
952,if ( is_file_hugepages ( shm_file ) )  goto out_unlock0 ;,if ( is_file_hugepages ( shm_file ) ) goto out_unlock0 ;,4774
953,dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ;dev -> netdev_ops = & macvlan_netdev_ops ;,dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ;dev -> netdev_ops = & macvlan_netdev_ops ;,4775
954,}line . clock_type = get_status ( port ) -> clocking ;,"}memset ( & line , 0 , sizeof ( line ) ) ;line . clock_type = get_status ( port ) -> clocking ;",4776
955,if ( ! ( opt_len == 12 && flags & TH_SYN ) &&  ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) &&  ! ( opt_len == 24 && flags & TH_ACK ) )  return 0 ;,if ( ! ( opt_len == 12 && ( flags & TH_SYN ) ) && ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) && ! ( opt_len == 24 && ( flags & TH_ACK ) ) ) return 0 ;,4777
956,if ( packet -> tcp != NULL ) {if ( ( dport == 1521 || sport == 1521 )  && ( ( ( packet -> payload [ 0 ] == 0x07 ) && ( packet -> payload [ 1 ] == 0xff ) && ( packet -> payload [ 2 ] == 0x00 ) )  || ( ( packet -> payload_packet_len >= 232 ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( packet -> payload [ 0 ] == 0x01 ) ) && ( packet -> payload [ 1 ] != 0x00 ) && ( packet -> payload [ 2 ] == 0x00 ) && ( packet -> payload [ 3 ] == 0x00 ) ) ) ) {,if ( packet -> payload_packet_len >= 3 && packet -> tcp != NULL ) {if ( ( dport == 1521 || sport == 1521 ) && ( ( ( packet -> payload [ 0 ] == 0x07 ) && ( packet -> payload [ 1 ] == 0xff ) && ( packet -> payload [ 2 ] == 0x00 ) ) || ( ( packet -> payload_packet_len >= 232 ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( packet -> payload [ 0 ] == 0x01 ) ) && ( packet -> payload [ 1 ] != 0x00 ) && ( packet -> payload [ 2 ] == 0x00 ) && ( packet -> payload [ 3 ] == 0x00 ) ) ) ) {,4778
957,"strcpy ( the_url , url_arg ) ;ext = strrchr ( the_url , \'.\' ) ;","if ( strlen ( url_arg ) >= sizeof ( the_url ) ) {fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\\strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ;the_url [ sizeof ( the_url ) - 1 ] = 0 ;}else {strcpy ( the_url , url_arg ) ;}ext = strrchr ( the_url , \'.\' ) ;",4779
958,"if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ;gf_dm_sess_del ( sess ) ;","if ( ! e ) {strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ;the_url [ sizeof ( the_cfg ) - 1 ] = 0 ;}gf_dm_sess_del ( sess ) ;",4779
959,"strcpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ;gf_term_connect ( term , str ) ;","strncpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ;gf_term_connect ( term , str ) ;",4779
960,"int X509_verify ( X509 * a , EVP_PKEY * r )  {return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;","int X509_verify ( X509 * a , EVP_PKEY * r ) {if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;",4780
961,"int res ;const void * data ;int len ;u_int32_t vendor ;if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) {return ;res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ;if ( res == - 1 ) {add_assoc_long ( return_value , ""attr"" , res ) ;add_assoc_long ( return_value , ""vendor"" , vendor ) ;add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ;return ;","const void * data , * raw ;int len ;u_int32_t vendor ;unsigned char type ;size_t data_len ;if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & raw , & len ) == FAILURE ) {return ;if ( rad_get_vendor_attr ( & vendor , & type , & data , & data_len , raw , len ) == - 1 ) {add_assoc_long ( return_value , ""attr"" , type ) ;add_assoc_long ( return_value , ""vendor"" , vendor ) ;add_assoc_stringl ( return_value , ""data"" , ( char * ) data , data_len , 1 ) ;return ;",4781
962,"sas_unregister_dev ( port , dev ) ;continue ;","sas_unregister_dev ( port , dev ) ;sas_destruct_devices ( port ) ;continue ;",4782
963,"if ( ret == 0 )  clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;up_write ( & key -> sem ) ;","if ( ret == 0 ) mark_key_instantiated ( key , 0 ) ;up_write ( & key -> sem ) ;",4783
964,"static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile ,  TOKENEXTRA * * tp , int mi_row ,  int mi_col , BLOCK_SIZE bsize , int * rate ,  int64_t * dist , int do_recon , int64_t best_rd ) {MACROBLOCK * const x = & cpi -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ;int i , pl ;int this_rate , sum_rate = 0 , best_rate = INT_MAX ;int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ;int64_t sum_rd = 0 ;int partition_none_allowed = ! force_horz_split && ! force_vert_split ;int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ;if ( bsize < BLOCK_8X8 ) {if ( x -> ab_index != 0 ) {* rate = 0 ;* dist = 0 ;return ;}}assert ( num_8x8_blocks_wide_lookup [ bsize ] ==  num_8x8_blocks_high_lookup [ bsize ] ) ;if ( bsize == BLOCK_16X16 ) {set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ;}else {x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;}if ( cpi -> sf . auto_min_max_partition_size ) {partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size &&  bsize >= cpi -> sf . min_partition_size ) ;partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&  bsize > cpi -> sf . min_partition_size ) || force_horz_split ) ;partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size &&  bsize > cpi -> sf . min_partition_size ) || force_vert_split ) ;do_split &= bsize > cpi -> sf . min_partition_size ;}if ( cpi -> sf . use_square_partition_only ) {partition_horz_allowed &= force_horz_split ;partition_vert_allowed &= force_vert_split ;}save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;if ( cpi -> sf . disable_split_var_thresh && partition_none_allowed ) {unsigned int source_variancey ;vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ;source_variancey = get_sby_perpixel_variance ( cpi , x , bsize ) ;if ( source_variancey < cpi -> sf . disable_split_var_thresh ) {do_split = 0 ;if ( source_variancey < cpi -> sf . disable_split_var_thresh / 2 )  do_rect = 0 ;}}if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) do_split = 0 ;if ( partition_none_allowed ) {rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize ,  ctx , best_rd ) ;if ( this_rate != INT_MAX ) {if ( bsize >= BLOCK_8X8 ) {pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ;}sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ;if ( sum_rd < best_rd ) {int64_t stop_thresh = 4096 ;int64_t stop_thresh_rd ;best_rate = this_rate ;best_dist = this_dist ;best_rd = sum_rd ;if ( bsize >= BLOCK_8X8 )  * ( get_sb_partitioning ( x , bsize ) ) = bsize ;stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ;stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ;if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) {do_split = 0 ;do_rect = 0 ;}}if ( ! x -> in_active_map ) {do_split = 0 ;do_rect = 0 ;}restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * mi_step ;* get_sb_index ( x , subsize ) = i ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize ,   & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd ) {","static void rd_pick_partition ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int * rate , int64_t * dist , int do_recon , int64_t best_rd ) {TileInfo * const tile_info = & tile_data -> tile_info ;MACROBLOCK * const x = & td -> mb ;MACROBLOCKD * const xd = & x -> e_mbd ;PICK_MODE_CONTEXT * ctx = & pc_tree -> none ;int i , pl ;RD_COST this_rdc , sum_rdc , best_rdc ;BLOCK_SIZE min_size = x -> min_partition_size ;BLOCK_SIZE max_size = x -> max_partition_size ;# if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ;int none_complexity = 0 ;# endif int partition_none_allowed = ! force_horz_split && ! force_vert_split ;int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize >= BLOCK_8X8 ;assert ( num_8x8_blocks_wide_lookup [ bsize ] ) ;vp9_rd_cost_init ( & this_rdc ) ;vp9_rd_cost_init ( & sum_rdc ) ;vp9_rd_cost_reset ( & best_rdc ) ;best_rdc . rdcost = best_rd ;set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize == num_8x8_blocks_high_lookup [ bsize ] ) ;if ( bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ;else {x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ;if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) {int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ;if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size ) ;for ( i = 0 ;const int x_idx = ( i & 1 ) * mi_step ;* get_sb_index ( x , subsize ) = i ;if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ;rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ;if ( this_rate == INT_MAX ) {sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;if ( sum_rd < best_rd ) {",4784
965,"restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;}if ( partition_horz_allowed && do_rect ) {subsize = get_subsize ( bsize , PARTITION_HORZ ) ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed )  get_block_context ( x , subsize ) -> pred_interp_filter =  ctx -> mic . mbmi . interp_filter ;if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) {update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col ,  subsize , 0 ) ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed )  get_block_context ( x , subsize ) -> pred_interp_filter =  ctx -> mic . mbmi . interp_filter ;rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate ,  & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}else {sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}if ( sum_rd < best_rd ) {pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;sum_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ;if ( sum_rd < best_rd ) {best_rd = sum_rd ;best_rate = sum_rate ;best_dist = sum_dist ;* ( get_sb_partitioning ( x , bsize ) ) = subsize ;restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;}if ( partition_vert_allowed && do_rect ) {subsize = get_subsize ( bsize , PARTITION_VERT ) ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed )  get_block_context ( x , subsize ) -> pred_interp_filter =  ctx -> mic . mbmi . interp_filter ;if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) {update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col ,  subsize , 0 ) ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed )  get_block_context ( x , subsize ) -> pred_interp_filter =  ctx -> mic . mbmi . interp_filter ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate ,  & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}sum_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ;","restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;}if ( partition_horz_allowed && do_rect ) {subsize = get_subsize ( bsize , PARTITION_HORZ ) ;* get_sb_index ( x , subsize ) = 0 ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) {update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , subsize , 0 ) ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;else {sum_rate += this_rate ;sum_dist += this_dist ;if ( sum_rd < best_rd ) {pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;# if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) {set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ;src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ;}# endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) {int mb_row = mi_row >> 1 ;int mb_col = mi_col >> 1 ;int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ;int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ;int r , c ;for ( r = mb_row ;r < mb_row_end ;r ++ ) {for ( c = mb_col ;c < mb_col_end ;c ++ ) {const int mb_index = r * cm -> mb_cols + c ;MOTION_DIRECTION this_mv ;MOTION_DIRECTION right_mv ;MOTION_DIRECTION bottom_mv ;this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ;if ( c != mb_col_end - 1 ) {right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ;none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ;}if ( r != mb_row_end - 1 ) {bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ;none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ;}}}if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) {partition_none_allowed = 0 ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) {update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , subsize , 0 ) ;if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && partition_none_allowed ) get_block_context ( x , subsize ) -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ;rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , & this_dist , subsize , get_block_context ( x , subsize ) , best_rd - sum_rd ) ;sum_rd = INT64_MAX ;}sum_rate += this_rate ;sum_dist += this_dist ;sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ;}this_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ;",4784
966,"restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ;}( void ) best_rd ;* rate = best_rate ;* dist = best_dist ;if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) {int output_enabled = ( bsize == BLOCK_64X64 ) ;if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) {vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled ,  best_rate ) ;}if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , best_rate , best_dist ) ;encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;}","restore_context ( cpi , td , tile_data , tp , mi_row , mi_col , output_enabled , bsize ) ;assert ( best_rate < INT_MAX ) ;assert ( best_dist < INT64_MAX ) ;}",4784
967,"
",cpu = cpumask_first ( mask ) ;,4785
968,"event_data -> snk_config =  sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ;","event_data -> snk_config = sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ;",4785
969,"daddy = malloc ( sizeof ( creator_template ) ) ;memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ;","daddy = safe_calloc ( sizeof ( creator_template ) ) ;memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ;",4786
970,# ifndef _MSC_VER   char fpath [ grub_strlen ( currpath ) + 1 ] ;# else char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ;# endif  char * name = fpath ;,char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ;char * name = fpath ;,4787
971,* currfound = currnode ;return 0 ;,* currfound = currnode ;free ( fpath ) ;return 0 ;,4787
972,"return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ;}if ( grub_errno )   return grub_errno ;break ;return grub_error ( GRUB_ERR_SYMLINK_LOOP ,  ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ;free_node ( oldnode , c ) ;return grub_errno ;","free ( fpath ) ;return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ;}if ( grub_errno ) {free ( fpath ) ;return grub_errno ;}break ;free ( fpath ) ;free ( fpath ) ;return grub_error ( GRUB_ERR_SYMLINK_LOOP , ""too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks"" ) ;free ( fpath ) ;free_node ( oldnode , c ) ;return grub_errno ;",4787
973,"return grub_errno ;}return 0 ;}return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ;}","return grub_errno ;}free ( fpath ) ;return 0 ;}free ( fpath ) ;return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ;}",4787
974,int error ;raw_inode = ext4_raw_inode ( iloc ) ;,"unsigned int inode_size = EXT4_INODE_SIZE ( inode -> i_sb ) ;struct ext4_inode_info * ei = EXT4_I ( inode ) ;int error ;if ( ( EXT4_GOOD_OLD_INODE_SIZE + ei -> i_extra_isize > inode_size ) || ( ei -> i_extra_isize & 3 ) ) {EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>extra_isize<S2SV_blank>%u<S2SV_blank>(inode<S2SV_blank>size<S2SV_blank>%u)"" , ei -> i_extra_isize , EXT4_INODE_SIZE ( inode -> i_sb ) ) ;return - EFSCORRUPTED ;}if ( ( new_extra_isize < ei -> i_extra_isize ) || ( new_extra_isize < 4 ) || ( new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE ) ) return - EINVAL ;raw_inode = ext4_raw_inode ( iloc ) ;",4788
975,"if ( track -> timescale > UINT16_MAX ) {if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( ""lpcm"" ) ;","if ( track -> timescale > UINT16_MAX || ! track -> par -> channels ) {if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( ""lpcm"" ) ;",4789
976,"if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}ret = oe_open ( pathname , flags , mode ) ;if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ;goto done ;}case OE_SYS_lseek : {int fd = ( int ) arg1 ;ssize_t off = ( ssize_t ) arg2 ;int whence = ( int ) arg3 ;ret = oe_lseek ( fd , off , whence ) ;goto done ;}case OE_SYS_pread64 : {const int fd = ( int ) arg1 ;void * const buf = ( void * ) arg2 ;const size_t count = ( size_t ) arg3 ;const oe_off_t offset = ( oe_off_t ) arg4 ;ret = oe_pread ( fd , buf , count , offset ) ;goto done ;}case OE_SYS_pwrite64 : {const int fd = ( int ) arg1 ;const void * const buf = ( void * ) arg2 ;const size_t count = ( size_t ) arg3 ;const oe_off_t offset = ( oe_off_t ) arg4 ;ret = oe_pwrite ( fd , buf , count , offset ) ;goto done ;}case OE_SYS_readv : {int fd = ( int ) arg1 ;const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ;int iovcnt = ( int ) arg3 ;ret = oe_readv ( fd , iov , iovcnt ) ;goto done ;}case OE_SYS_writev : {int fd = ( int ) arg1 ;const struct oe_iovec * iov = ( const struct oe_iovec * ) arg2 ;int iovcnt = ( int ) arg3 ;ret = oe_writev ( fd , iov , iovcnt ) ;goto done ;}case OE_SYS_read : {int fd = ( int ) arg1 ;void * buf = ( void * ) arg2 ;size_t count = ( size_t ) arg3 ;ret = oe_read ( fd , buf , count ) ;goto done ;}case OE_SYS_write : {int fd = ( int ) arg1 ;const void * buf = ( void * ) arg2 ;size_t count = ( size_t ) arg3 ;ret = oe_write ( fd , buf , count ) ;goto done ;}case OE_SYS_close : {int fd = ( int ) arg1 ;ret = oe_close ( fd ) ;goto done ;}case OE_SYS_dup : {int fd = ( int ) arg1 ;ret = oe_dup ( fd ) ;goto done ;}case OE_SYS_flock : {int fd = ( int ) arg1 ;int operation = ( int ) arg2 ;ret = oe_flock ( fd , operation ) ;goto done ;}case OE_SYS_fsync : {const int fd = ( int ) arg1 ;ret = oe_fsync ( fd ) ;goto done ;}case OE_SYS_fdatasync : {const int fd = ( int ) arg1 ;ret = oe_fdatasync ( fd ) ;goto done ;}# if defined ( OE_SYS_dup2 ) case OE_SYS_dup2 : {int oldfd = ( int ) arg1 ;int newfd = ( int ) arg2 ;ret = oe_dup2 ( oldfd , newfd ) ;goto done ;}# endif case OE_SYS_dup3 : {int oldfd = ( int ) arg1 ;int newfd = ( int ) arg2 ;int flags = ( int ) arg3 ;if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_dup2 ( oldfd , newfd ) ;goto done ;}# if defined ( OE_SYS_stat ) case OE_SYS_stat : {const char * pathname = ( const char * ) arg1 ;struct oe_stat_t * buf = ( struct oe_stat_t * ) arg2 ;ret = oe_stat ( pathname , buf ) ;goto done ;}# endif case OE_SYS_newfstatat : {int dirfd = ( int ) arg1 ;const char * pathname = ( const char * ) arg2 ;struct oe_stat_t * buf = ( struct oe_stat_t * ) arg3 ;int flags = ( int ) arg4 ;if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_stat ( pathname , buf ) ;goto done ;}case OE_SYS_fstat : {const int fd = ( int ) arg1 ;struct oe_stat_t * const buf = ( struct oe_stat_t * ) arg2 ;ret = oe_fstat ( fd , buf ) ;goto done ;}# if defined ( OE_SYS_link ) case OE_SYS_link : {const char * oldpath = ( const char * ) arg1 ;const char * newpath = ( const char * ) arg2 ;ret = oe_link ( oldpath , newpath ) ;goto done ;}# endif case OE_SYS_linkat : {int olddirfd = ( int ) arg1 ;const char * oldpath = ( const char * ) arg2 ;int newdirfd = ( int ) arg3 ;const char * newpath = ( const char * ) arg4 ;int flags = ( int ) arg5 ;if ( olddirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( newdirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_link ( oldpath , newpath ) ;goto done ;}# if defined ( OE_SYS_unlink ) case OE_SYS_unlink : {const char * pathname = ( const char * ) arg1 ;ret = oe_unlink ( pathname ) ;goto done ;}# endif case OE_SYS_unlinkat : {int dirfd = ( int ) arg1 ;const char * pathname = ( const char * ) arg2 ;int flags = ( int ) arg3 ;if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != OE_AT_REMOVEDIR && flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}if ( flags == OE_AT_REMOVEDIR ) ret = oe_rmdir ( pathname ) ;else ret = oe_unlink ( pathname ) ;goto done ;}# if defined ( OE_SYS_rename ) case OE_SYS_rename : {const char * oldpath = ( const char * ) arg1 ;const char * newpath = ( const char * ) arg2 ;ret = oe_rename ( oldpath , newpath ) ;goto done ;}# endif case OE_SYS_renameat : {int olddirfd = ( int ) arg1 ;const char * oldpath = ( const char * ) arg2 ;int newdirfd = ( int ) arg3 ;const char * newpath = ( const char * ) arg4 ;int flags = ( int ) arg5 ;if ( olddirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( newdirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_rename ( oldpath , newpath ) ;goto done ;}case OE_SYS_truncate : {const char * path = ( const char * ) arg1 ;ssize_t length = ( ssize_t ) arg2 ;ret = oe_truncate ( path , length ) ;goto done ;}# if defined ( OE_SYS_mkdir ) case OE_SYS_mkdir : {const char * pathname = ( const char * ) arg1 ;uint32_t mode = ( uint32_t ) arg2 ;ret = oe_mkdir ( pathname , mode ) ;goto done ;}# endif case OE_SYS_mkdirat : {int dirfd = ( int ) arg1 ;const char * pathname = ( const char * ) arg2 ;uint32_t mode = ( uint32_t ) arg3 ;if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}ret = oe_mkdir ( pathname , mode ) ;goto done ;}# if defined ( OE_SYS_rmdir ) case OE_SYS_rmdir : {const char * pathname = ( const char * ) arg1 ;ret = oe_rmdir ( pathname ) ;goto done ;}# endif # if defined ( OE_SYS_access ) case OE_SYS_access : {const char * pathname = ( const char * ) arg1 ;int mode = ( int ) arg2 ;ret = oe_access ( pathname , mode ) ;goto done ;}# endif case OE_SYS_faccessat : {int dirfd = ( int ) arg1 ;const char * pathname = ( const char * ) arg2 ;int mode = ( int ) arg3 ;int flags = ( int ) arg4 ;if ( dirfd != OE_AT_FDCWD ) {oe_errno = OE_EBADF ;goto done ;}if ( flags != 0 ) {oe_errno = OE_EINVAL ;goto done ;}ret = oe_access ( pathname , mode ) ;goto done ;}case OE_SYS_getdents64 : {unsigned int fd = ( unsigned int ) arg1 ;struct oe_dirent * ent = ( struct oe_dirent * ) arg2 ;unsigned int count = ( unsigned int ) arg3 ;ret = oe_getdents64 ( fd , ent , count ) ;goto done ;}case OE_SYS_ioctl : {int fd = ( int ) arg1 ;unsigned long request = ( unsigned long ) arg2 ;long p1 = arg3 ;long p2 = arg4 ;long p3 = arg5 ;long p4 = arg6 ;ret = oe_ioctl ( fd , request , p1 , p2 , p3 , p4 ) ;goto done ;}case OE_SYS_fcntl : {int fd = ( int ) arg1 ;int cmd = ( int ) arg2 ;uint64_t arg = ( uint64_t ) arg3 ;ret = oe_fcntl ( fd , cmd , arg ) ;goto done ;}case OE_SYS_mount : {const char * source = ( const char * ) arg1 ;const char * target = ( const char * ) arg2 ;const char * fstype = ( const char * ) arg3 ;unsigned long flags = ( unsigned long ) arg4 ;void * data = ( void * ) arg5 ;ret = oe_mount ( source , target , fstype , flags , data ) ;goto done ;}case OE_SYS_umount2 : {const char * target = ( const char * ) arg1 ;int flags = ( int ) arg2 ;( void ) flags ;ret = oe_umount ( target ) ;goto done ;}case OE_SYS_getcwd : {char * buf = ( char * ) arg1 ;size_t size = ( size_t ) arg2 ;if ( ! oe_getcwd ( buf , size ) ) {ret = - 1 ;}else {ret = ( long ) size ;}goto done ;}case OE_SYS_chdir : {char * path = ( char * ) arg1 ;ret = oe_chdir ( path ) ;goto done ;}case OE_SYS_socket : {int domain = ( int ) arg1 ;int type = ( int ) arg2 ;int protocol = ( int ) arg3 ;ret = oe_socket ( domain , type , protocol ) ;goto done ;}case OE_SYS_connect : {int sd = ( int ) arg1 ;const struct oe_sockaddr * addr = ( const struct oe_sockaddr * ) arg2 ;",struct oe_sockaddr * addr = ( const struct oe_sockaddr * ) arg2 ;,4790
977,const struct oe_sockaddr * dest_add =   ( const struct oe_sockaddr * ) arg5 ;oe_socklen_t * addrlen = ( oe_socklen_t * ) arg6 ;,const struct oe_sockaddr * dest_add = ( const struct oe_sockaddr * ) arg5 ;oe_socklen_t * addrlen = ( oe_socklen_t * ) arg6 ;,4790
978,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,4791
979,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func : free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",4791
980,reset_globals ( ) ;passert ( GLOBALS_ARE_RESET ( ) ) ;},},4792
981,"fail :  ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" ,  __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ;","fail : ext3_msg ( sb , KERN_ERR , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ;",4793
982,sr -> bytes_to_send = finfo . size ;sr -> headers . content_length = finfo . size ;,sr -> fd_is_fdt = MK_FALSE ;sr -> bytes_to_send = finfo . size ;sr -> headers . content_length = finfo . size ;,4794
983,"hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;","hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ;hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;",4795
984,void uwbd_stop ( struct uwb_rc * rc )  {kthread_stop ( rc -> uwbd . task ) ;,void uwbd_stop ( struct uwb_rc * rc ) {if ( rc -> uwbd . task ) kthread_stop ( rc -> uwbd . task ) ;,4796
985,"u64 rem ;nsec = rtc_time ( ) * sgi_clock_period ;sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ;","u32 rem ;nsec = rtc_time ( ) * sgi_clock_period ;sgi_clock_offset . tv_sec = tp -> tv_sec - div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ;if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ;",4797
986,"static int check_best_zero_mv ( const VP9_COMP * cpi , const uint8_t mode_context [ MAX_REF_FRAMES ] , int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ,  int disable_inter_mode_mask , int this_mode , int ref_frame ,  int second_ref_frame ) {if ( ! ( disable_inter_mode_mask & ( 1 << INTER_OFFSET ( ZEROMV ) ) ) && ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frame ] . as_int == 0 && ( second_ref_frame == NONE ||  frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) {int rfc = mode_context [ ref_frame ] ;int c1 = cost_mv_ref ( cpi , NEARMV , rfc ) ;if ( this_mode == NEARMV ) {if ( c1 > c3 ) return 0 ;}else if ( this_mode == NEARESTMV ) {if ( c2 > c3 ) return 0 ;}else {assert ( this_mode == ZEROMV ) ;if ( second_ref_frame == NONE ) {if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) ||   ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) )  return 0 ;if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 &&  frame_mv [ NEARESTMV ] [ second_ref_frame ] . as_int == 0 ) ||  ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 &&  frame_mv [ NEARMV ] [ second_ref_frame ] . as_int == 0 ) ) return 0 ;","static int check_best_zero_mv ( const VP9_COMP * cpi , const uint8_t mode_context [ MAX_REF_FRAMES ] , int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) {if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] == NONE || frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) {int rfc = mode_context [ ref_frame ] ;int c1 = cost_mv_ref ( cpi , NEARMV , rfc ) ;if ( ref_frames [ 1 ] == NONE ) {if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) || ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) ) return 0 ;if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ second_ref_frame ] . as_int == 0 ) || ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] ] . as_int == 0 ) ) return 0 ;",4798
987,value = 0 ;if ( bits < 0 ) {if ( msg -> oob ) {if ( bits == 8 ) {,if ( msg -> readcount > msg -> cursize ) {return 0 ;}value = 0 ;if ( bits < 0 ) {if ( msg -> oob ) {if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}if ( bits == 8 ) {,4799
988,nbits = bits & 7 ;for ( i = 0 ;,"nbits = bits & 7 ;if ( msg -> bit , msg -> cursize << 3 + nbits > msg -> cursize << 3 ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}for ( i = 0 ;",4799
989,"Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;value |= ( get << ( i + nbits ) ) ;}","Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ;value |= ( get << ( i + nbits ) ) ;if ( msg -> bit > msg -> cursize << 3 ) {msg -> readcount = msg -> cursize + 1 ;return 0 ;}}",4799
990,dictionary * iniparser_load ( const char * ininame )  {,"dictionary * iniparser_load ( const char * ininame , load_options options ) {",4800
991,"case LINE_ERROR :  fprintf ( stderr , ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d):\\\fprintf ( stderr , ""-><S2SV_blank>%s\\\errs ++ ;","case LINE_ERROR : if ( options & HIDE_ERRORED_LINE_CONTENT ) {fprintf ( stderr , ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d)\\\}else {fprintf ( stderr , ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d):\\\fprintf ( stderr , ""-><S2SV_blank>%s\\\}errs ++ ;",4800
992,"static void finish_object ( struct object * obj ,  struct strbuf * path , const char * name ,  void * cb_data ) {","static void finish_object ( struct object * obj , const char * name , void * cb_data ) {",4801
993,"
",ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;,4802
994,"ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ;break ;","ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ;break ;",4802
995,"memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ;up -> family = kp -> encap_family ;","memset ( up , 0 , sizeof ( * up ) ) ;memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ;up -> family = kp -> encap_family ;",4803
996,"fprintf ( fp , ""%s=%s\\\}","if ( strchr ( value , \'\\\fprintf ( fp , ""%s=%s\\\}",4804
997,"end = strchr ( * value + 1 , \\\'""\\\' ) ;if ( ! end ) {end ++ ;}","char * p = end = * value + 1 ;while ( * p ) {if ( * p == \'\\\\\\\\\' ) {p ++ ;* end = * p ;}else {* end = * p ;if ( * p == \\\'""\\\' ) break ;}p ++ ;end ++ ;}if ( * end != \\\'""\\\' ) {end = ++ p ;}",4805
998,"static const char * parse_string ( cJSON * item , const char * str )  {const char * ptr = str + 1 ;char * ptr2 ;ep = str ;return 0 ;}while ( * ptr != \\\'\\\\""\\\' && * ptr && ++ len )   if ( * ptr ++ == \'\\\\\\\\\' )   ptr ++ ;if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) )  return 0 ;while ( * ptr != \\\'\\\\""\\\' && * ptr ) {if ( * ptr != \'\\\\\\\\\' ) * ptr2 ++ = * ptr ++ ;","static const char * parse_string ( cJSON * item , const char * str , const char * ptr = str + 1 ;char * ptr2 ;* ep = str ;return 0 ;}while ( * ptr != \\\'\\\\""\\\' && * ptr && ++ len ) if ( * ptr ++ == \'\\\\\\\\\' ) ptr ++ ;if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) ) return 0 ;while ( * end_ptr != \\\'\\\\""\\\' && * ptr ) {if ( * ptr != \'\\\\\\\\\' ) * ptr2 ++ = * ptr ++ ;",4806
999,"case \'u\' :  sscanf ( ptr + 1 , ""%4x"" , & uc ) ;ptr += 4 ;if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 )  break ;if ( uc >= 0xD800 && uc <= 0xDBFF ) {if ( ptr [ 1 ] != \'\\\\\\\\\' || ptr [ 2 ] != \'u\' )  break ;sscanf ( ptr + 3 , ""%4x"" , & uc2 ) ;ptr += 6 ;if ( uc2 < 0xDC00 || uc2 > 0xDFFF )  break ;uc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ;}if ( uc < 0x80 )  len = 1 ;else if ( uc < 0x800 ) len = 2 ;",case \'u\' : uc = parse_hex4 ( ptr + 1 ) ;ptr += 4 ;if ( ptr >= end_ptr ) {* ep = str ;return 0 ;}if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) {* ep = str ;return 0 ;}if ( uc >= 0xD800 && uc <= 0xDBFF ) {if ( ptr + 6 > end_ptr ) {* ep = str ;return 0 ;}if ( ptr [ 1 ] != \'\\\\\\\\\' || ptr [ 2 ] != \'u\' ) {* ep = str ;return 0 ;}uc2 = parse_hex4 ( ptr + 3 ) ;ptr += 6 ;if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) {* ep = str ;return 0 ;}uc = 0x10000 + ( ( ( uc & 0x3FF ) ) << 10 ) | ( uc2 & 0x3FF ) ;}if ( uc < 0x80 ) len = 1 ;else if ( uc < 0x800 ) len = 2 ;,4806
1000,"++ ptr ;}if ( * ptr == \\\'\\\\""\\\' )  ++ ptr ;item -> valuestring = out ;item -> type = cJSON_String ;","+ ptr ;ptr ++ ;}if ( * ptr == \\\'\\\\""\\\' ) ptr ++ ;",4806
1001,"bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX )  + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;","bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride ) + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ;",4807
1002,"thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ;if ( thissad < bestsad ) {","thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride ) ;if ( thissad < bestsad ) {",4807
1003,u8 opcode = BPF_OP ( insn -> code ) ;dst_reg = & regs [ dst ] ;,u8 opcode = BPF_OP ( insn -> code ) ;int ret ;dst_reg = & regs [ dst ] ;,4808
1004,case BPF_ADD :  if ( known && ( ptr_reg -> off + smin_val ==  ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) {,"case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\\return ret ;}if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) {",4808
1005,"case BPF_SUB :  if ( dst_reg == off_reg ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\\","case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ;if ( ret < 0 ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\\return ret ;}if ( dst_reg == off_reg ) {verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\\",4808
1006,"psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ;sweepgen ( L , g , psurvival , g -> reallyold ) ;","g -> gcstate = GCSswpallgc ;psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ;sweepgen ( L , g , psurvival , g -> reallyold ) ;",4809
1007,static unsigned int stack_maxrandom_size ( void )  {unsigned int max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ;},static unsigned long stack_maxrandom_size ( void ) {unsigned long max = 0 ;if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) {max = ( ( - 1UL ) & STACK_RND_MASK ) << PAGE_SHIFT ;},4810
1008,"# endif  for ( row = 0 ;vpx_memcpy ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;","# endif # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) {assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ;for ( row = 0 ;memcpy_short_addr ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;",4811
1009,"vpx_memcpy ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;","memcpy_short_addr ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;",4811
1010,"vpx_memcpy ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;}","memcpy_short_addr ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;return ;}else {assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ;}# endif for ( row = 0 ;row < src_ybc -> y_height ;++ row ) {memcpy ( dst , src , src_ybc -> y_width ) ;src += src_ybc -> y_stride ;dst += dst_ybc -> y_stride ;}src = src_ybc -> u_buffer ;dst = dst_ybc -> u_buffer ;for ( row = 0 ;row < src_ybc -> uv_height ;++ row ) {memcpy ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;dst += dst_ybc -> uv_stride ;}src = src_ybc -> v_buffer ;dst = dst_ybc -> v_buffer ;for ( row = 0 ;row < src_ybc -> uv_height ;++ row ) {memcpy ( dst , src , src_ybc -> uv_width ) ;src += src_ybc -> uv_stride ;dst += dst_ybc -> uv_stride ;}vp8_yv12_extend_frame_borders_c ( dst_ybc ) ;}",4811
1011,s -> chunksize = - 1 ;for ( ;,s -> chunksize = UINT64_MAX ;for ( ;,4812
1012,"static vpx_codec_err_t ctrl_set_roi_map ( vpx_codec_alg_priv_t * ctx ,  int ctr_id , va_list args ) {return VPX_CODEC_INVALID_PARAM ;","static vpx_codec_err_t ctrl_set_roi_map ( vpx_codec_alg_priv_t * ctx , va_list args ) {( void ) ctx ;( void ) args ;return VPX_CODEC_INVALID_PARAM ;",4813
1013,while ( lp -> s != NULL ) {if ( lp -> pictype == l2info -> pictype ) {case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ;,"ND_TCHECK ( p [ 0 ] ) ;while ( lp -> s != NULL ) {if ( lp -> pictype == l2info -> pictype ) {case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;l2info -> cookie_type = LS_COOKIE_ID ;",4814
1014,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;,"case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;l2info -> bundle = l2info -> cookie [ 1 ] ;",4814
1015,case LS_COOKIE_ID :  l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,4814
1016,case LS_COOKIE_ID :  l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ;l2info -> proto = EXTRACT_16BITS ( p ) ;,4814
1017,"if ( first_mb_in_slice == 0 ) {if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) {field_end ( h , 1 ) ;}h0 -> current_slice = 0 ;if ( ! h0 -> first_field ) {if ( h -> cur_pic_ptr && ! h -> droppable ) {ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ;}h -> cur_pic_ptr = NULL ;}}slice_type = get_ue_golomb_31 ( & h -> gb ) ;if ( slice_type > 9 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\\return AVERROR_INVALIDDATA ;}if ( slice_type > 4 ) {slice_type -= 5 ;h -> slice_type_fixed = 1 ;}else h -> slice_type_fixed = 0 ;slice_type = golomb_to_pict_type [ slice_type ] ;h -> slice_type = slice_type ;h -> slice_type_nos = slice_type & 3 ;h -> pict_type = h -> slice_type ;pps_id = get_ue_golomb ( & h -> gb ) ;if ( pps_id >= MAX_PPS_COUNT ) {av_log ( h -> avctx , AV_LOG_ERROR , ""pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\\return AVERROR_INVALIDDATA ;}if ( ! h0 -> pps_buffers [ pps_id ] ) {av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\\return AVERROR_INVALIDDATA ;}h -> pps = * h0 -> pps_buffers [ pps_id ] ;if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) {av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\\return AVERROR_INVALIDDATA ;}if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) {h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ;h -> current_sps_id = h -> pps . sps_id ;h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ;if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ;if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) {h -> bit_depth_luma = h -> sps . bit_depth_luma ;h -> chroma_format_idc = h -> sps . chroma_format_idc ;needs_reinit = 1 ;}if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ;}h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ;h -> avctx -> level = h -> sps . level_idc ;h -> avctx -> refs = h -> sps . ref_frame_count ;must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ;if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ;h -> mb_width = h -> sps . mb_width ;h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ;h -> mb_num = h -> mb_width * h -> mb_height ;h -> mb_stride = h -> mb_width + 1 ;h -> b_stride = h -> mb_width * 4 ;h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ;h -> width = 16 * h -> mb_width ;h -> height = 16 * h -> mb_height ;ret = init_dimensions ( h ) ;if ( ret < 0 ) return ret ;if ( h -> sps . video_signal_type_present_flag ) {h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ;if ( h -> sps . colour_description_present_flag ) {if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ;h -> avctx -> color_primaries = h -> sps . color_primaries ;h -> avctx -> color_trc = h -> sps . color_trc ;h -> avctx -> colorspace = h -> sps . colorspace ;}}if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) {if ( h != h0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>"" ""slice<S2SV_blank>%d\\\return AVERROR_INVALIDDATA ;}flush_change ( h ) ;if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ;h -> avctx -> pix_fmt = ret ;av_log ( h -> avctx , AV_LOG_INFO , ""Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>"" ""pix_fmt:<S2SV_blank>%s\\\if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\\return ret ;}}if ( ! h -> context_initialized ) {if ( h != h0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\\return AVERROR_PATCHWELCOME ;}if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ;h -> avctx -> pix_fmt = ret ;if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) {av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\\return ret ;}}if ( h == h0 && h -> dequant_coeff_pps != pps_id ) {h -> dequant_coeff_pps = pps_id ;init_dequant_tables ( h ) ;}h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ;h -> mb_mbaff = 0 ;h -> mb_aff_frame = 0 ;last_pic_structure = h0 -> picture_structure ;last_pic_droppable = h0 -> droppable ;h -> droppable = h -> nal_ref_idc == 0 ;if ( h -> sps . frame_mbs_only_flag ) {h -> picture_structure = PICT_FRAME ;}else {if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) {av_log ( h -> avctx , AV_LOG_ERROR , ""This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\\return - 1 ;}field_pic_flag = get_bits1 ( & h -> gb ) ;if ( field_pic_flag ) {bottom_field_flag = get_bits1 ( & h -> gb ) ;h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ;}else {h -> picture_structure = PICT_FRAME ;h -> mb_aff_frame = h -> sps . mb_aff ;}}h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ;if ( h0 -> current_slice != 0 ) {if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) {av_log ( h -> avctx , AV_LOG_ERROR , ""Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\\h -> picture_structure = last_pic_structure ;h -> droppable = last_pic_droppable ;return AVERROR_INVALIDDATA ;}else if ( ! h0 -> cur_pic_ptr ) {",if ( h0 -> cur_pic_ptr ) {,4815
1018,"if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;","if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) {ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ;",4815
1019,"case \'l\' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;case \'L\' : {","case \'l\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ;}case \'L\' : {",4816
1020,"case \'i\' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;","case \'i\' : {RBinObject * obj = r_bin_cur_object ( core -> bin ) ;RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ;}case \'I\' : RBININFO ( ""info"" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ;",4816
1021,"static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd ,  int mi_row , int mi_col , vp9_reader * r ) {struct segmentation * const seg = & cm -> seg ;const BLOCK_SIZE bsize = mbmi -> sb_type ;int predicted_segment_id , segment_id ;predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map ,  bsize , mi_row , mi_col ) ;if ( ! seg -> update_map )  return predicted_segment_id ;if ( seg -> temporal_update ) {const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ;mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ;segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ;set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;return segment_id ;","static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vpx_reader * r ) {struct segmentation * const seg = & cm -> seg ;int predicted_segment_id , segment_id ;const int mi_offset = mi_row * cm -> mi_cols + mi_col ;const int bw = xd -> plane [ 0 ] . n4_w >> 1 ;const int bh = xd -> plane [ 0 ] . n4_h >> 1 ;const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ;const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ;predicted_segment_id = cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;if ( ! seg -> update_map ) {copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ;return predicted_segment_id ;}if ( seg -> temporal_update ) {const vpx_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ;mbmi -> seg_id_predicted = vpx_read ( r , pred_prob ) ;segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ;set_segment_id ( cm , mi_offset , x_mis , y_mis , segment_id ) ;return segment_id ;",4817
1022,"int i , len ;size_t len_sent = 0 ;const char __user * p ;char * buf ;p = ( const char __user * ) current -> mm -> arg_start ;audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;if ( ! buf ) {audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ;for ( i = 0 ;i < context -> execve . argc ;i ++ ) {len = audit_log_single_execve_arg ( context , ab , i , & len_sent , p , buf ) ;if ( len <= 0 ) break ;p += len ;kfree ( buf ) ;","long len_max ;long len_rem ;long len_full ;long len_buf ;long len_abuf ;long len_tmp ;bool require_data ;bool encode ;unsigned int iter ;unsigned int arg ;char * buf_head ;char * buf ;const char __user * p = ( const char __user * ) current -> mm -> arg_start ;char abuf [ 96 ] ;WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ;len_max = MAX_EXECVE_AUDIT_LEN ;buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ;if ( ! buf_head ) {audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ;buf = buf_head ;audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ;len_rem = len_max ;len_buf = 0 ;len_full = 0 ;require_data = true ;encode = false ;iter = 0 ;arg = 0 ;do {if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ;if ( require_data ) {if ( buf != buf_head ) {memmove ( buf_head , buf , len_buf ) ;buf = buf_head ;len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ;if ( len_tmp == - EFAULT ) {send_sig ( SIGKILL , current , 0 ) ;goto out ;}else if ( len_tmp == ( len_max - len_buf ) ) {require_data = true ;encode = true ;len_full = len_full * 2 ;p += len_tmp ;}else {require_data = false ;if ( ! * ab ) goto out ;}len_tmp = 0 ;if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) {if ( iter == 0 ) {len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d_len=%lu"" , arg , len_full ) ;}len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d[%d]="" , arg , iter ++ ) ;}else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d="" , arg ) ;WARN_ON ( len_tmp >= sizeof ( abuf ) ) ;abuf [ sizeof ( abuf ) - 1 ] = \'\\\\0\' ;audit_log_format ( * ab , ""%s"" , abuf ) ;len_rem -= len_tmp ;len_tmp = len_buf ;if ( encode ) {if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ;audit_log_n_hex ( * ab , buf , len_tmp ) ;len_rem -= len_tmp * 2 ;len_abuf -= len_tmp * 2 ;}else {if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ;audit_log_n_string ( * ab , buf , len_tmp ) ;len_rem -= len_tmp + 2 ;len_abuf -= len_tmp ;}len_buf -= len_tmp ;buf += len_tmp ;}if ( ( len_buf == 0 ) && ! require_data ) {arg ++ ;iter = 0 ;len_full = 0 ;require_data = true ;encode = false ;}}while ( arg < context -> execve . argc ) ;out : kfree ( buf_head ) ;",4818
1023,"unsigned long flags ;int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;exit :  spin_unlock_irqrestore ( & dev -> lock , flags ) ;return ret ;","int ret ;spin_lock_irqsave ( & dev -> lock , flags ) ;ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ;exit : mutex_unlock ( & dev -> lock , flags ) ;return ret ;",4819
1024,"if ( JAS_CAST ( ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) {jas_eprintf ( ""warning:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>in<S2SV_blank>marker<S2SV_blank>segment<S2SV_blank>(%ld<S2SV_blank>bytes)\\\","if ( JAS_CAST ( jas_ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) {jas_eprintf ( ""warning:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>in<S2SV_blank>marker<S2SV_blank>segment<S2SV_blank>(%ld<S2SV_blank>bytes)\\\",4820
1025,int i ;for ( i = 0 ;,"int i ;account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ;free_uid ( pipe -> user ) ;for ( i = 0 ;",4821
1026,"if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ;if ( executable == NULL ) {error_msg ( ""Can\\\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ;goto create_user_core ;}const char * signame = NULL ;switch ( signal_no ) {case SIGILL : signame = ""ILL"" ;break ;case SIGFPE : signame = ""FPE"" ;break ;case SIGSEGV : signame = ""SEGV"" ;break ;case SIGBUS : signame = ""BUS"" ;break ;case SIGABRT : signame = ""ABRT"" ;break ;case SIGTRAP : signame = ""TRAP"" ;break ;default : goto create_user_core ;}if ( ! daemon_is_ok ( ) ) {log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'core\\\'"" ) ;goto create_user_core ;}if ( g_settings_nMaxCrashReportsSize > 0 ) {if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ;}snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ;if ( check_recent_crash_file ( path , executable ) ) {goto create_user_core ;}const char * last_slash = strrchr ( executable , \'/\' ) ;if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) {snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ;int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ;off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ;if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) {unlink ( path ) ;error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\\\'%s\\\'"" , path ) ;}log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ;return 0 ;}unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ;if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) {goto create_user_core ;}dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ;if ( dd ) {char * rootdir = get_rootdir ( pid ) ;dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ;char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ;","if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , NULL ) ;char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ;",4822
1027,"double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags )  {GPMF_stream metadata_stream , * ms = & metadata_stream ;uint32_t teststart = 0 ;uint32_t testend = mp4 -> indexcount ;double rate = 0.0 ;if ( mp4 -> indexcount < 1 ) return 0.0 ;if ( mp4 -> indexcount > 3 )  {teststart ++ ;testend -- ;}uint32_t * payload = GetPayload ( handle , NULL , teststart ) ;uint32_t payloadsize = GetPayloadSize ( handle , teststart ) ;int32_t ret = GPMF_Init ( ms , payload , payloadsize ) ;if ( ret != GPMF_OK )  goto cleanup ;uint32_t missing_samples = 0 ;while ( ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) )  {missing_samples = 1 ;payload = GetPayload ( handle , payload , teststart ) ;payloadsize = GetPayloadSize ( handle , teststart ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;}","double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags , double * firstsampletime , double * lastsampletime ) {payload = GetPayload ( handle , NULL , teststart ) ;payloadsize = GetPayloadSize ( handle , teststart ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;if ( ret != GPMF_OK ) goto cleanup ;uint64_t minimumtimestamp = 0 ;uint64_t starttimestamp = 0 ;uint64_t endtimestamp = 0 ;double intercept = 0.0 ;while ( teststart < mp4 -> indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) {payload = GetPayload ( handle , payload , teststart ) ;payloadsize = GetPayloadSize ( handle , teststart ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;}if ( ret == GPMF_OK && payload ) {uint32_t samples = GPMF_PayloadSampleCount ( ms ) ;GPMF_stream find_stream ;GPMF_CopyState ( ms , & find_stream ) ;if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) startsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) - samples ;GPMF_CopyState ( ms , & find_stream ) ;if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) starttimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & find_stream ) ) ;if ( starttimestamp ) {GPMF_stream any_stream ;GPMF_Init ( & any_stream , payload , payloadsize ) ;minimumtimestamp = starttimestamp ;while ( GPMF_OK == GPMF_FindNext ( & any_stream , GPMF_KEY_TIME_STAMP , GPMF_RECURSE_LEVELS ) ) {uint64_t timestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & any_stream ) ) ;if ( timestamp < minimumtimestamp ) minimumtimestamp = timestamp ;}}testend = mp4 -> indexcount ;do {testend -- ;payload = GetPayload ( handle , NULL , teststart ) ;uint32_t payloadsize = GetPayloadSize ( handle , payload , testend ) ;payloadsize = GetPayloadSize ( handle , teststart ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;}",4823
1028,"uint32_t samples = GPMF_Repeat ( ms ) ;GPMF_stream find_stream ;if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) && GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) )  {payload = GetPayload ( handle , payload , testend ) ;payloadsize = GetPayloadSize ( handle , testend ) ;if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) {if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) {endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ;rate = ( double ) ( endsamples - startsamples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ;goto cleanup ;}}rate = ( double ) ( samples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ;}else {uint32_t payloadpos = 0 , payloadcount = 0 ;double slope , top = 0.0 , bot = 0.0 , meanX = 0 , meanY = 0 ;uint32_t * repeatarray = malloc ( mp4 -> indexcount * 4 + 4 ) ;memset ( repeatarray , 0 , mp4 -> indexcount * 4 + 4 ) ;samples = 0 ;for ( payloadpos = teststart ;payloadpos < testend ;payloadcount ++ , payloadpos ++ )  {if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) )  {float in , out ;do {GetPayloadTime ( handle , payloadpos , & in , & out ) ;meanX += out ;uint32_t repeat = GPMF_Repeat ( ms ) ;samples += repeat ;float in , out ;repeatarray [ payloadpos ] = samples ;GetPayloadTime ( handle , payloadpos , & in , & out ) ;meanX += out ;}if ( repeatarray ) {meanY /= ( double ) payloadcount ;meanX /= ( double ) payloadcount ;for ( payloadpos = teststart ;payloadpos < testend ;payloadpos ++ ) {float in , out ;top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] - meanY ) ;bot += ( ( double ) out - meanX ) * ( ( double ) out - meanX ) ;}# if 0   {double intercept ;intercept = meanY - slope * meanX ;printf ( ""%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)\\\}goto cleanup ;}cleanup : if ( payload )  {FreePayload ( payload ) ;}return rate ;","uint32_t samples = GPMF_Repeat ( ms ) ;GPMF_stream find_stream ;if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) && GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) {payload = GetPayload ( handle , testend ) ;if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ;if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ;else {uint32_t i ;for ( i = teststart ;i <= testend ;i ++ ) {if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) {float in , out ;do {GetPayloadTime ( handle , payloadpos , & in , & out ) ;meanX += out ;uint32_t repeat = GPMF_Repeat ( ms ) ;samples += repeat ;double in , out ;repeatarray [ payloadpos ] = samples ;if ( GPMF_OK == GetPayloadTime ( handle , payloadpos , & in , & out ) ) meanX += out ;}if ( repeatarray ) {double in , out ;top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] - meanY ) ;bot += ( ( double ) out - meanX ) * ( ( double ) out - meanX ) ;}# if 0 printf ( ""%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f\\\}if ( firstsampletime && lastsampletime ) {uint32_t endpayload = mp4 -> indexcount ;do {endpayload -- ;payload = GetPayload ( handle , payload , endpayload ) ;payloadsize = GetPayloadSize ( handle , endpayload ) ;ret = GPMF_Init ( ms , payload , payloadsize ) ;}while ( endpayload > 0 && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ;if ( endpayload > 0 && ret == GPMF_OK ) {uint32_t totalsamples = endsamples - startsamples ;float timo = 0.0 ;GPMF_CopyState ( ms , & find_stream ) ;if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_OFFSET , GPMF_CURRENT_LEVEL ) ) GPMF_FormattedData ( & find_stream , & timo , 4 , 0 , 1 ) ;double first , last ;first = - intercept / rate - timo ;last = first + ( double ) totalsamples / rate ;if ( firstsampletime ) * firstsampletime = first ;if ( lastsampletime ) * lastsampletime = last ;}}}}cleanup : if ( payload ) FreePayload ( payload ) ;return rate ;",4823
1029,r1 . event = event ;r1 . tstamp = * tstamp ;,"memset ( & r1 , 0 , sizeof ( r1 ) ) ;r1 . event = event ;r1 . tstamp = * tstamp ;",4824
1030,"if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 ||  ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\","if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) {duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\\",4825
1031,"int old_bin_num , bin_num ;old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ;bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ;if ( old_bin_num == bin_num ) {# endif  return ptr ;}",int old_bin_num = ZEND_MM_SRUN_BIN_NUM ( info ) ;if ( size <= ZEND_MM_MAX_SMALL_SIZE ) {int bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ;if ( old_bin_num == bin_num ) {# endif return ptr ;}},4826
1032,int hstartcol ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartcol = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartcol ;n = m ;srcptr = & a [ ( 1 - parity ) * stride ] ;,int hstartrow ;if ( bufsize > QMFB_SPLITBUFSIZE ) {hstartrow = ( numrows + 1 - parity ) >> 1 ;m = numrows - hstartrow ;n = m ;srcptr = & a [ hstartrow * stride ] ;,4827
1033,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,dstptr = & a [ hstartcol * stride ] ;srcptr = buf ;,4827
1034,"unsigned long cs ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE )  return rc ;if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ;if ( ctxt -> mode >= X86EMUL_MODE_PROT16 && ( cs & 3 ) > cpl ) return X86EMUL_UNHANDLEABLE ;rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ;return rc ;","unsigned long eip , cs ;u16 old_cs ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & eip , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ;rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ;return rc ;",4828
1035,lock_sock ( sk ) ;opt -> src_addr = sp -> sa_addr . pptp ;,if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;lock_sock ( sk ) ;opt -> src_addr = sp -> sa_addr . pptp ;,4829
1036,"gss_buffer_desc client_name ,  service_name ;",gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ;gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ;,4830
1037,"gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;exit_func :  free_server_handle ( handle ) ;","exit_func : gss_release_buffer ( & minor_stat , & client_name ) ;gss_release_buffer ( & minor_stat , & service_name ) ;free_server_handle ( handle ) ;",4830
1038,psf_close_rsrc ( psf ) ;free ( psf -> container_data ) ;,psf_close_rsrc ( psf ) ;free ( psf -> header . ptr ) ;free ( psf -> container_data ) ;,4831
1039,"int is_valid ;if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;giterr_clear ( ) ;is_valid = error != GIT_ECERTIFICATE ;","int is_valid = ( error == GIT_OK ) ;if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ;giterr_clear ( ) ;",4832
1040,hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ;hmp_chunk [ i ] += chunk_ofs [ i ] ++ ;,hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ;chunk_length [ i ] -= chunk_ofs [ i ] ;hmp_chunk [ i ] += chunk_ofs [ i ] ++ ;,4833
1041,"}uint32_t setup_ret = 0 ;if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , 0 ) ) == 0 ) {goto _hmp_end ;chunk_end [ i ] = 1 ;hmp_chunk [ i ] += 3 ;","chunk_length [ i ] -= 3 ;}uint32_t setup_ret = 0 ;if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , chunk_length [ i ] , 0 ) ) == 0 ) {goto _hmp_end ;chunk_end [ i ] = 1 ;chunk_length [ i ] -= 3 ;hmp_chunk [ i ] += 3 ;",4833
1042,}var_len_shift = 0 ;if ( * hmp_chunk [ i ] < 0x80 ) {do {chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;var_len_shift += 7 ;}}chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;hmp_chunk [ i ] ++ ;},"chunk_length [ i ] -= setup_ret ;}var_len_shift = 0 ;if ( chunk_length [ i ] && * hmp_chunk [ i ] < 0x80 ) {do {if ( ! chunk_length [ i ] ) break ;chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;var_len_shift += 7 ;chunk_length [ i ] -- ;}}if ( ! chunk_length [ i ] ) {_WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ;goto _hmp_end ;}chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ;hmp_chunk [ i ] ++ ;chunk_length [ i ] -- ;}",4833
1043,"c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ;macinf -> lchid [ j + chan ] = c_t + 1 ;macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ;rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ;}","c_t = ( tvb_get_bits8 ( tvb , tb_bit_off , 4 ) + 1 ) % 0xf ;macinf -> lchid [ j + chan ] = c_t ;macinf -> content [ j + chan ] = lchId_type_table [ c_t ] ;rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t ] ;}",4834
1044,struct sctp_sockaddr_entry * laddr ;union sctp_addr * baddr = NULL ;__u8 matchlen = 0 ;__u8 bmatchlen ;,"struct ipv6_pinfo * np = inet6_sk ( sk ) ;struct sctp_sockaddr_entry * laddr ;union sctp_addr * baddr = NULL ;struct in6_addr * final_p , final ;__u8 matchlen = 0 ;__u8 bmatchlen ;",4835
1045,"dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ;if ( ! asoc || saddr ) goto out ;","final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , fl6 , final_p , false ) ;if ( ! asoc || saddr ) goto out ;",4835
1046,"dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ;}","final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , fl6 , final_p , false ) ;}",4835
1047,"r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end ,  & cpat , & cpat_end ) ;if ( r != 0 ) return r ;",return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION ;,4836
1048,"long start ;char * header ;header = calloc ( 1 , 1024 ) ;start = ftell ( fp ) ;fseek ( fp , 0 , SEEK_SET ) ;","char * header ;header = calloc ( 1 , 1024 ) ;long start = ftell ( fp ) ;fseek ( fp , 0 , SEEK_SET ) ;",4837
1049,"pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows *  number_planes_filled * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * number_planes_filled ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;","pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ;if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ;pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ;pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ;",4838
1050,"case IPSECDOI_ID_IPV4_ADDR : if ( len < 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]"" , len ) ) ;","case IPSECDOI_ID_IPV4_ADDR : if ( len < 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" , len ) ) ;",4839
1051,"if ( len < 20 )  ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ;","if ( len < 20 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]"" , len ) ) ;",4839
1052,"if ( data -> multi_easy )   curl_multi_cleanup ( data -> multi_easy ) ;Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ;","if ( data -> multi_easy ) {curl_multi_cleanup ( data -> multi_easy ) ;data -> multi_easy = NULL ;}Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ;",4840
1053,"res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ;rcu_read_unlock ( ) ;","res = ip6_xmit ( sk , skb , & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ;rcu_read_unlock ( ) ;",4841
1054,BREAK_TO_DEBUGGER ( ) ;return NULL ;,kfree ( clk_src ) ;BREAK_TO_DEBUGGER ( ) ;return NULL ;,4842
1055,"uleft_col [ i ] = uleft [ i * left_stride ] ;vleft_col [ i ] = vleft [ i * left_stride ] ;}switch ( x -> mode_info_context -> mbmi . uv_mode ) {case DC_PRED : {int expected_udc ;int expected_vdc ;int shift ;int Uaverage = 0 ;int Vaverage = 0 ;if ( x -> up_available ) {for ( i = 0 ;i < 8 ;i ++ ) {Uaverage += uabove_row [ i ] ;Vaverage += vabove_row [ i ] ;}}if ( x -> left_available ) {for ( i = 0 ;i < 8 ;i ++ ) {Uaverage += uleft_col [ i ] ;Vaverage += vleft_col [ i ] ;}}if ( ! x -> up_available && ! x -> left_available ) {expected_udc = 128 ;expected_vdc = 128 ;}else {shift = 2 + x -> up_available + x -> left_available ;expected_udc = ( Uaverage + ( 1 << ( shift - 1 ) ) ) >> shift ;expected_vdc = ( Vaverage + ( 1 << ( shift - 1 ) ) ) >> shift ;}for ( i = 0 ;i < 8 ;i ++ ) {vpx_memset ( upred_ptr , expected_udc , 8 ) ;vpx_memset ( vpred_ptr , expected_vdc , 8 ) ;upred_ptr += pred_stride ;","memset ( upred_ptr , expected_udc , 8 ) ;vpx_memset ( vpred_ptr , expected_vdc , 8 ) ;upred_ptr += pred_stride ;",4843
1056,"vpx_memcpy ( upred_ptr , uabove_row , 8 ) ;vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ;upred_ptr += pred_stride ;","vpx_memcpy ( upred_ptr , uabove_row , 8 ) ;vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ;upred_ptr += pred_stride ;",4843
1057,"vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ;vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ;upred_ptr += pred_stride ;","vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ;vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ;upred_ptr += pred_stride ;",4843
1058,"if ( ctxt -> rip_relative )  ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;","if ( ctxt -> rip_relative && likely ( ctxt -> memopp ) ) ctxt -> memopp -> addr . mem . ea = address_mask ( ctxt , ctxt -> memopp -> addr . mem . ea + ctxt -> _eip ) ;",4844
1059,"security_decrypt ( s -> p , length , rdp ) ;if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ;","if ( ! security_decrypt ( s -> p , length , rdp ) ) return FALSE ;if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ;",4845
1060,"control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;goto skip_normal_probe ;","control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ;if ( ! data_interface || ! control_interface ) return - ENODEV ;goto skip_normal_probe ;",4846
1061,"
","if ( nelements == 0 ) {DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\\goto out ;}",4847
1062,o = 2 ;},o = 2 ;},4847
1063,"for ( j = 0 ;j < nelements ;uint32_t l = CDF_GETUINT32 ( q , o ) ;","for ( j = 0 ;j < nelements && i < sh . sh_properties ;uint32_t l = CDF_GETUINT32 ( q , o ) ;",4847
1064,"static int   rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent )  {pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) ,  pdu_type , pdu_len ) ) ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU :  case RPKI_RTR_END_OF_DATA_PDU :  msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU :  break ;case RPKI_RTR_CACHE_RESPONSE_PDU :  ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ;tlen = pdu_len ;tptr += sizeof ( * pdu ) ;tlen -= sizeof ( * pdu ) ;if ( encapsulated_pdu_length &&  ( encapsulated_pdu_length <= tlen ) ) {if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) )  goto trunc ;tptr += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = 0 ;if ( tlen > 4 ) {text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;}ND_TCHECK2 ( * tptr , text_length ) ;if ( text_length && ( text_length <= tlen ) ) {ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ;if ( fn_printn ( ndo , tptr , text_length , ndo -> ndo_snapend ) ) goto trunc ;}break ;default : hexdump = TRUE ;return 0 ;trunc :  return 1 ;}","static u_int rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , const u_int len , const u_char recurse , const u_int indent ) {ND_TCHECK_8BITS ( tptr ) ;if ( * tptr != 0 ) {ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ;return len ;}if ( len < sizeof ( rpki_rtr_pdu ) ) {ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ;goto invalid ;}ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ;pdu_header = ( const rpki_rtr_pdu * ) tptr ;pdu_type = pdu_header -> pdu_type ;hexdump = FALSE ;ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,<S2SV_blank>%s<S2SV_blank>PDU<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , pdu_type , pdu_len ) ) ;if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid ;switch ( pdu_type ) {case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;msg = ( const u_char * ) ( pdu_header + 1 ) ;case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;break ;case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ;ND_PRINT ( ( ndo , ""%sSession<S2SV_blank>ID:<S2SV_blank>0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv4<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ipaddr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ;ND_TCHECK2 ( * tptr , pdu_len ) ;pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ;ND_PRINT ( ( ndo , ""%sIPv6<S2SV_blank>Prefix<S2SV_blank>%s/%u-%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>0x%02x"" , indent_string ( indent + 2 ) , ip6addr_string ( ndo , pdu -> prefix ) , pdu -> prefix_length , pdu -> max_length , EXTRACT_32BITS ( pdu -> as ) , pdu -> flags ) ) ;tlen = sizeof ( rpki_rtr_pdu ) ;if ( pdu_len < tlen + 4 ) goto invalid ;ND_TCHECK2 ( * tptr , tlen + 4 ) ;pdu = ( const rpki_rtr_pdu_error_report * ) tptr ;encapsulated_pdu_length = EXTRACT_32BITS ( pdu -> encapsulated_pdu_length ) ;tlen += 4 ;if ( encapsulated_pdu_length && ( encapsulated_pdu_length <= tlen ) ) {rpki_rtr_pdu_print ( ndo , tptr + tlen , encapsulated_pdu_length , 0 , indent + 2 ) ;tlen += encapsulated_pdu_length ;tlen -= encapsulated_pdu_length ;text_length = EXTRACT_32BITS ( tptr ) ;tptr += 4 ;tlen -= 4 ;ND_TCHECK2 ( * tptr , pdu_len ) ;hexdump = TRUE ;return 0 ;trunc : ND_PRINT ( ( ndo , ""\\\return len ;}",4848
1065,xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn +  picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn +  picomp -> numrlvls - rlvlno - 1 ) ) ;,"if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",4849
1066,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) )   || ! ( pi -> x % ( 1 << rpx ) ) ) &&   ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) )   || ! ( pi -> y % ( 1 << rpy ) ) ) ) {prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;","if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) ) {prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;",4849
1067,"if ( pack -> hdr . ver == 2 ) {print ( ""[L2TP<S2SV_blank>tid=%u<S2SV_blank>sid=%u"" , ntohs ( pack -> hdr . tid ) , ntohs ( pack -> hdr . sid ) ) ;}else {print ( ""[L2TP<S2SV_blank>cid=%u"" , pack -> hdr . cid ) ;log_ppp_debug ( ""<S2SV_blank>Ns=%u<S2SV_blank>Nr=%u"" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ;}","switch ( pack -> hdr . flags & L2TP_VER_MASK ) {case 2 : print ( ""[L2TP<S2SV_blank>tid=%u<S2SV_blank>sid=%u"" , ntohs ( pack -> hdr . tid ) , ntohs ( pack -> hdr . sid ) ) ;break ;case 3 : print ( ""[L2TP<S2SV_blank>cid=%u"" , pack -> hdr . cid ) ;break ;default : print ( ""[L2TP<S2SV_blank>unknown<S2SV_blank>version]\\\return ;}",4850
1068,"if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ;GET_HANDLE ( ) ;if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) {st = EINVAL ;k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ;goto cleanup ;}if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ;filtuser = ldap_filter_correct ( user ) ;if ( filtuser == NULL ) {st = ENOMEM ;goto cleanup ;}if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ;else optype = MODIFY_PRINCIPAL ;if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ;if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ;if ( entry -> mask & KADM5_LOAD ) {unsigned int tree = 0 ;int numlentries = 0 ;char * filter = NULL ;if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) {filter = NULL ;if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ;found_entry = FALSE ;for ( tree = 0 ;found_entry == FALSE && tree < ntrees ;++ tree ) {if ( principal_dn == NULL ) {LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ;}else {LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ;}if ( st == LDAP_SUCCESS ) {numlentries = ldap_count_entries ( ld , result ) ;if ( numlentries > 1 ) {free ( filter ) ;st = EINVAL ;k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\\\""%s\\\\""<S2SV_blank>found"" ) , user ) ;goto cleanup ;}else if ( numlentries == 1 ) {found_entry = TRUE ;if ( principal_dn == NULL ) {ent = ldap_first_entry ( ld , result ) ;if ( ent != NULL ) {if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) {ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ;st = set_ldap_error ( context , st , 0 ) ;free ( filter ) ;goto cleanup ;}}}}}else if ( st != LDAP_NO_SUCH_OBJECT ) {st = set_ldap_error ( context , st , 0 ) ;free ( filter ) ;goto cleanup ;}ldap_msgfree ( result ) ;result = NULL ;}free ( filter ) ;if ( found_entry == FALSE && principal_dn != NULL ) {create_standalone_prinicipal = TRUE ;standalone_principal_dn = strdup ( principal_dn ) ;CHECK_NULL ( standalone_principal_dn ) ;}}if ( principal_dn == NULL && xargs . dn == NULL ) {if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) {subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;}else if ( xargs . containerdn ) {if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) {if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) {int ost = st ;st = EINVAL ;k5_prependmsg ( context , ost , st , _ ( ""\\\'%s\\\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ;}goto cleanup ;}subtree = strdup ( xargs . containerdn ) ;}else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) {subtree = strdup ( ldap_context -> lrparams -> containerref ) ;}else {subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;}CHECK_NULL ( subtree ) ;if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ;CHECK_NULL ( standalone_principal_dn ) ;create_standalone_prinicipal = TRUE ;free ( subtree ) ;subtree = NULL ;}if ( xargs . dn_from_kbd == TRUE ) {int dnlen = 0 , subtreelen = 0 ;char * dn = NULL ;krb5_boolean outofsubtree = TRUE ;if ( xargs . dn != NULL ) {dn = xargs . dn ;}else if ( xargs . linkdn != NULL ) {dn = xargs . linkdn ;}else if ( standalone_principal_dn != NULL ) {dn = standalone_principal_dn ;}if ( subtreelist == NULL ) {st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ;if ( st ) goto cleanup ;}for ( tre = 0 ;tre < ntrees ;++ tre ) {if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) {outofsubtree = FALSE ;break ;}else {dnlen = strlen ( dn ) ;subtreelen = strlen ( subtreelist [ tre ] ) ;if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) {outofsubtree = FALSE ;break ;}}}if ( outofsubtree == TRUE ) {st = EINVAL ;k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ;goto cleanup ;}if ( standalone_principal_dn == NULL ) {char * attributes [ ] = {""krbticketpolicyreference"" , ""krbprincipalname"" , NULL };ldap_msgfree ( result ) ;result = NULL ;LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ;if ( st == LDAP_SUCCESS ) {ent = ldap_first_entry ( ld , result ) ;if ( ent != NULL ) {if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) {ldap_value_free ( values ) ;}if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) {krb_identity_exists = TRUE ;ldap_value_free ( values ) ;}}}else {st = set_ldap_error ( context , st , OP_SEARCH ) ;goto cleanup ;}}}if ( xargs . dn != NULL && krb_identity_exists == TRUE ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}if ( xargs . linkdn != NULL ) {if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}{char * * linkdns = NULL ;int j = 0 ;if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) {snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;goto cleanup ;}if ( linkdns != NULL ) {st = EINVAL ;snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ;k5_setmsg ( context , st , ""%s"" , errbuf ) ;for ( j = 0 ;linkdns [ j ] != NULL ;++ j ) free ( linkdns [ j ] ) ;free ( linkdns ) ;goto cleanup ;}}establish_links = TRUE ;}if ( entry -> mask & KADM5_LAST_SUCCESS ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_LAST_FAILED ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) {krb5_kvno fail_auth_count ;fail_auth_count = entry -> fail_auth_count ;if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ;st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ;if ( st != 0 ) goto cleanup ;}else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) {int attr_mask = 0 ;krb5_boolean has_fail_count ;st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ;if ( st != 0 ) goto cleanup ;has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ;# ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ;if ( st != 0 ) goto cleanup ;}else {# endif if ( has_fail_count ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ;if ( st != 0 ) goto cleanup ;}st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ;if ( st != 0 ) goto cleanup ;# ifdef LDAP_MOD_INCREMENT }# endif }else if ( optype == ADD_PRINCIPAL ) {st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ;}if ( entry -> mask & KADM5_MAX_LIFE ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_MAX_RLIFE ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_ATTRIBUTES ) {if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_PRINCIPAL ) {memset ( strval , 0 , sizeof ( strval ) ) ;strval [ 0 ] = user ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_PW_EXPIRATION ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {free ( strval [ 0 ] ) ;goto cleanup ;}free ( strval [ 0 ] ) ;}if ( entry -> mask & KADM5_POLICY ) {memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ;for ( tl_data = entry -> tl_data ;tl_data ;tl_data = tl_data -> tl_data_next ) {if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) {if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) {goto cleanup ;}break ;}}if ( princ_ent . aux_attributes & KADM5_POLICY ) {memset ( strval , 0 , sizeof ( strval ) ) ;if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ;strval [ 0 ] = polname ;if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;}else {st = EINVAL ;k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ;goto cleanup ;}}else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) {if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_POLICY_CLR ) {if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ;}if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) {krb5_kvno mkvno ;if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ;bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ;if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" ,   LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 )  goto cleanup ;","if ( bersecretkey == NULL ) {+ tree ) {+ tre ) {+ j ) free ( linkdns [ j ] ) ;if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) {st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) goto cleanup ;",4851
1069,"puts ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>""  ""All<S2SV_blank>rights<S2SV_blank>reserved.\\\","puts ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>2015,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>"" ""All<S2SV_blank>rights<S2SV_blank>reserved.\\\",4852
1070,"char * r = pool_alloc ( strlen ( s ) + 1 ) ;strcpy ( r , s ) ;return r ;","size_t len = strlen ( s ) + 1 ;char * r = pool_alloc ( len ) ;memcpy ( r , s , len ) ;return r ;",4853
1071,"if ( size_left && size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;","if ( size_left < 4 ) {LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ;",4854
1072,"static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data ,  OPJ_UINT32 * p_data_written ,  const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) {opj_write_bytes ( p_data , J2K_MS_SOT ,  2 ) ;","static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) {if ( p_total_data_size < 12 ) {opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\\return OPJ_FALSE ;}opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ;",4855
1073,"static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps )  {mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ;kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;","static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps ) {int i ;mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ;for ( i = 0 ;i < 3 ;i ++ ) kvm_pit_load_count ( kvm , i , ps -> channels [ 0 ] . count , 0 ) ;mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ;",4856
1074,"struct timeval tv [ 2 ] ;# define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) {why = str ;goto screwup ;}if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size"" ) ;setimes = targisdir = 0 ;mask = umask ( 0 ) ;if ( ! pflag ) ( void ) umask ( mask ) ;if ( argc != 1 ) {run_err ( ""ambiguous<S2SV_blank>target"" ) ;exit ( 1 ) ;}targ = * argv ;if ( targetshouldbedirectory ) verifydir ( targ ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ;if ( src != NULL && ! iamrecursive && ! Tflag ) {if ( brace_expand ( src , & patterns , & npatterns ) != 0 ) fatal ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>expand<S2SV_blank>pattern"" , __func__ ) ;}for ( first = 1 ;;first = 0 ) {cp = buf ;if ( atomicio ( read , remin , cp , 1 ) != 1 ) goto done ;if ( * cp ++ == \'\\\do {if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ;* cp ++ = ch ;}while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != \'\\\* cp = 0 ;if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ;if ( buf [ 0 ] == \'\\\\01\' || buf [ 0 ] == \'\\\\02\' ) {if ( iamremote == 0 ) {( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ;( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ;}if ( buf [ 0 ] == \'\\\\02\' ) exit ( 1 ) ;++ errs ;continue ;}if ( buf [ 0 ] == \'E\' ) {( void ) atomicio ( vwrite , remout , """" , 1 ) ;goto done ;}if ( ch == \'\\\cp = buf ;if ( * cp == \'T\' ) {setimes ++ ;cp ++ ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;mtime . tv_sec = ull ;mtime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ;atime . tv_sec = ull ;atime . tv_usec = strtol ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'\\\\0\' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ;( void ) atomicio ( vwrite , remout , """" , 1 ) ;continue ;}if ( * cp != \'C\' && * cp != \'D\' ) {if ( first ) {run_err ( ""%s"" , cp ) ;exit ( 1 ) ;}SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ;}mode = 0 ;for ( ++ cp ;cp < buf + 5 ;cp ++ ) {if ( * cp < \'0\' || * cp > \'7\' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ;mode = ( mode << 3 ) | ( * cp - \'0\' ) ;}if ( ! pflag ) mode &= ~ mask ;if ( * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ;ull = strtoull ( cp , & cp , 10 ) ;if ( ! cp || * cp ++ != \'<S2SV_blank>\' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ;if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ;size = ( off_t ) ull ;if ( * cp == \'\\\\0\' || strchr ( cp , \'/\' ) != NULL || strcmp ( cp , ""."" ) == 0 || strcmp ( cp , "".."" ) == 0 ) {run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ;exit ( 1 ) ;}if ( npatterns > 0 ) {for ( n = 0 ;n < npatterns ;n ++ ) {if ( fnmatch ( patterns [ n ] , cp , 0 ) == 0 ) break ;}if ( n >= npatterns ) SCREWUP ( ""filename<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>request"" ) ;}if ( targisdir ) {static char * namebuf ;static size_t cursize ;size_t need ;need = strlen ( targ ) + strlen ( cp ) + 250 ;if ( need > cursize ) {free ( namebuf ) ;namebuf = xmalloc ( need ) ;cursize = need ;}( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ;np = namebuf ;}else np = targ ;curfile = cp ;exists = stat ( np , & stb ) == 0 ;if ( buf [ 0 ] == \'D\' ) {int mod_flag = pflag ;if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ;if ( exists ) {if ( ! S_ISDIR ( stb . st_mode ) ) {errno = ENOTDIR ;goto bad ;}if ( pflag ) ( void ) chmod ( np , mode ) ;}else {mod_flag = 1 ;if ( mkdir ( np , mode | S_IRWXU ) == - 1 ) goto bad ;}vect [ 0 ] = xstrdup ( np ) ;sink ( 1 , vect , src ) ;if ( setimes ) {setimes = 0 ;if ( utimes ( vect [ 0 ] , tv ) == - 1 )  run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ;","+ errs ;( void ) utimes ( vect [ 0 ] , tv ) == - 1 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ;",4857
1075,"timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) {","m -> msg_namelen = 0 ;timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ;restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) {",4858
1076,"inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;rc = PTR_ERR ( inode ) ;","s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ;rc = - EINVAL ;if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) {pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\\goto out_free ;}inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ;rc = PTR_ERR ( inode ) ;",4859
1077,"}else if ( options . compression == COMP_DELAYED ) {myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = ""none,zlib@openssh.com"" ;","}if ( options . compression == COMP_DELAYED ) {myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = ""none,zlib@openssh.com"" ;",4860
1078,"struct flowi4 fl4 ;struct rtable * rt ;if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) )  return ;if ( ! IS_ERR ( rt ) )   __sk_dst_set ( sk , & rt -> dst ) ;rcu_read_unlock ( ) ;","struct dst_entry * dst ;struct flowi4 fl4 ;struct rtable * rt ;dst = __sk_dst_get ( sk ) ;if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst , 0 ) ) {rcu_read_unlock ( ) ;return ;}dst = ! IS_ERR ( rt ) ) __sk_dst_set ( sk , & rt -> dst : NULL ;sk_dst_set ( sk , dst ) ;rcu_read_unlock ( ) ;",4861
1079,"num = port >= 0 ? port : 0 ;mutex_lock ( & client -> ports_mutex ) ;write_lock_irqsave ( & client -> ports_lock , flags ) ;list_for_each_entry ( p , & client -> ports_list_head , list ) {if ( p -> addr . port > num ) break ;if ( port < 0 ) num = p -> addr . port + 1 ;}list_add_tail ( & new_port -> list , & p -> list ) ;client -> num_ports ++ ;new_port -> addr . port = num ;write_unlock_irqrestore ( & client -> ports_lock , flags ) ;mutex_unlock ( & client -> ports_mutex ) ;sprintf ( new_port -> name , ""port-%d"" , num ) ;",snd_use_lock_use ( & new_port -> use_lock ) ;num = port >= 0 ? port : 0 ;mutex_lock ( & client -> ports_mutex ) ;,4862
1080,"return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) ,  RTL8150_REQ_GET_REGS , RTL8150_REQT_READ ,  indx , 0 , data , size , 500 ) ;}","void * buf ;int ret ;buf = kmalloc ( size , GFP_NOIO ) ;if ( ! buf ) return - ENOMEM ;ret = usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , RTL8150_REQ_GET_REGS , RTL8150_REQT_READ , indx , 0 , buf , size , 500 ) ;if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ;kfree ( buf ) ;return ret ;}",4863
1081,if ( strlen ( l_line ) == l_line_length ) {,if ( 3 == strlen ( l_line ) == l_line_length ) {,4864
1082,"if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) {* o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;","if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) {* o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ;",4864
1083,"
",LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;,4864
1084,l_row -- ;l_column -- ;,l_row -- ;l_column -- ;,4864
1085,"struct ip_options * opt = NULL ;struct inet_sock * sk_inet ;if ( sk == NULL ) return 0 ;buf_len = CIPSO_V4_OPT_LEN_MAX ;buf = kmalloc ( buf_len , GFP_ATOMIC ) ;if ( buf == NULL ) {ret_val = - ENOMEM ;goto socket_setattr_failure ;ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ;if ( ret_val < 0 ) goto socket_setattr_failure ;buf_len = ret_val ;opt_len = ( buf_len + 3 ) & ~ 3 ;opt = kzalloc ( sizeof ( * opt ) + opt_len , GFP_ATOMIC ) ;if ( opt == NULL ) {ret_val = - ENOMEM ;goto socket_setattr_failure ;}memcpy ( opt -> __data , buf , buf_len ) ;opt -> optlen = opt_len ;opt -> cipso = sizeof ( struct iphdr ) ;kfree ( buf ) ;buf = NULL ;sk_inet = inet_sk ( sk ) ;if ( sk_inet -> is_icsk ) {sk_conn = inet_csk ( sk ) ;if ( sk_inet -> opt )   sk_conn -> icsk_ext_hdr_len -= sk_inet -> opt -> optlen ;sk_conn -> icsk_ext_hdr_len += opt -> optlen ;sk_conn -> icsk_sync_mss ( sk , sk_conn -> icsk_pmtu_cookie ) ;}opt = xchg ( & sk_inet -> opt , opt ) ;kfree ( opt ) ;","struct ip_options_rcu * old , * opt = NULL ;struct inet_sock * sk_inet ;if ( old ) sk_conn -> icsk_ext_hdr_len -= sk_inet -> opt -> optlen ;sk_conn -> icsk_ext_hdr_len += opt -> opt . optlen ;sk_conn -> icsk_sync_mss ( sk , sk_conn -> icsk_pmtu_cookie ) ;opt = xchg ( & sk_inet -> opt , opt ) ;kfree ( opt ) ;",4865
1086,"int zero_bits = * in & 0x07 ;size_t octets_left = inlen - 1 ;int i , count = 0 ;memset ( outbuf , 0 , outlen ) ;","int i , count = 0 ;int zero_bits ;size_t octets_left ;if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ;if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ;zero_bits = * in & 0x07 ;octets_left = inlen - 1 ;int i , count = 0 ;memset ( outbuf , 0 , outlen ) ;",4866
1087,"if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs ,  & len , & iovec , compat ) ;else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs ,  len , iovec ) ;if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ;","if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , & len , & iovec , compat , & iter ) ;else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , len , iovec , & iter ) ;if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ;",4867
1088,"iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ;ret = iter_op ( req , & iter ) ;ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ;","ret = iter_op ( req , & iter ) ;ret = rw_op ( req , iter . iov , iter . nr_segs , req -> ki_pos ) ;",4867
1089,"unsigned char challenge [ 30 ] ;unsigned char signature [ 256 ] ;unsigned int siglen = sizeof signature ;const EVP_MD * md = EVP_sha1 ( ) ;if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) {goto err ;","unsigned char * signature = NULL ;unsigned int siglen = sizeof signature ;const EVP_MD * md = EVP_sha1 ( ) ;if ( NULL == privkey ) goto err ;siglen = EVP_PKEY_size ( privkey ) ;if ( siglen <= 0 ) goto err ;signature = malloc ( siglen ) ;if ( NULL == signature ) goto err ;if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) {goto err ;",4868
1090,err :  if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ;,err : free ( signature ) ;if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ;,4868
1091,out_err :  kfree ( init_name ) ;return rv ;,out_err : if ( rv && new_smi -> io . io_cleanup ) {new_smi -> io . io_cleanup ( & new_smi -> io ) ;new_smi -> io . io_cleanup = NULL ;}kfree ( init_name ) ;return rv ;,4869
1092,"static void encode_loopfilter ( struct loopfilter * lf ,  struct vp9_write_bit_buffer * wb ) {int i ;vp9_wb_write_literal ( wb , lf -> filter_level , 6 ) ;vp9_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ;vp9_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ;if ( lf -> mode_ref_delta_enabled ) {vp9_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ;if ( lf -> mode_ref_delta_update ) {const int changed = delta != lf -> last_ref_deltas [ i ] ;vp9_wb_write_bit ( wb , changed ) ;if ( changed ) {vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ;vp9_wb_write_bit ( wb , delta < 0 ) ;}const int changed = delta != lf -> last_mode_deltas [ i ] ;vp9_wb_write_bit ( wb , changed ) ;if ( changed ) {vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ;vp9_wb_write_bit ( wb , delta < 0 ) ;}","static void encode_loopfilter ( struct loopfilter * lf , struct vpx_write_bit_buffer * wb ) {int i ;vpx_wb_write_literal ( wb , lf -> filter_level , 6 ) ;vpx_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ;vpx_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ;if ( lf -> mode_ref_delta_enabled ) {vpx_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ;if ( lf -> mode_ref_delta_update ) {vpx_wb_write_bit ( wb , changed ) ;if ( changed ) {vpx_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ;vpx_wb_write_bit ( wb , delta < 0 ) ;}vpx_wb_write_bit ( wb , changed ) ;if ( changed ) {vpx_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ;vpx_wb_write_bit ( wb , delta < 0 ) ;}",4870
1093,"char * header , * c ;header = get_header ( fp ) ;if ( ( c = strstr ( header , ""%PDF-"" ) ) &&  ( c + strlen ( ""%PDF-M.m"" ) + 2 ) )  {","char * header = get_header ( fp ) ;const char * c ;if ( ( c = strstr ( header , ""%PDF-"" ) ) && ( ( c + 6 ) [ 0 ] == \'.\' ) && isdigit ( ( c + 5 ) [ 0 ] ) && isdigit ( ( c + 7 ) [ 0 ] ) ) {",4871
1094,"struct in6_addr * saddr = NULL , * final_p , final ;struct flowi6 fl6 ;memset ( & fl6 , 0 , sizeof ( fl6 ) ) ;if ( np -> sndflow ) {fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ;IP6_ECN_flow_init ( fl6 . flowlabel ) ;if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) {struct ip6_flowlabel * flowlabel ;flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ;if ( flowlabel == NULL ) return - EINVAL ;fl6_sock_release ( flowlabel ) ;}}if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ;addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ;if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ;if ( addr_type & IPV6_ADDR_LINKLOCAL ) {if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) {if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ;sk -> sk_bound_dev_if = usin -> sin6_scope_id ;}if ( ! sk -> sk_bound_dev_if ) return - EINVAL ;}sk -> sk_v6_daddr = usin -> sin6_addr ;np -> flow_label = fl6 . flowlabel ;if ( addr_type == IPV6_ADDR_MAPPED ) {u32 exthdrlen = icsk -> icsk_ext_hdr_len ;struct sockaddr_in sin ;SOCK_DEBUG ( sk , ""connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\\if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ;sin . sin_family = AF_INET ;sin . sin_port = usin -> sin6_port ;sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ;icsk -> icsk_af_ops = & dccp_ipv6_mapped ;sk -> sk_backlog_rcv = dccp_v4_do_rcv ;err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ;if ( err ) {icsk -> icsk_ext_hdr_len = exthdrlen ;icsk -> icsk_af_ops = & dccp_ipv6_af_ops ;sk -> sk_backlog_rcv = dccp_v6_do_rcv ;goto failure ;}np -> saddr = sk -> sk_v6_rcv_saddr ;return err ;}if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ;fl6 . flowi6_proto = IPPROTO_DCCP ;fl6 . daddr = sk -> sk_v6_daddr ;fl6 . saddr = saddr ? * saddr : np -> saddr ;fl6 . flowi6_oif = sk -> sk_bound_dev_if ;fl6 . fl6_dport = usin -> sin6_port ;fl6 . fl6_sport = inet -> inet_sport ;security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ;final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;","struct in6_addr * saddr = NULL , * final_p , final ;struct ipv6_txoptions * opt ;struct flowi6 fl6 ;memset ( & fl6 , opt , & final ) ;dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ;",4872
1095,if ( np -> opt != NULL )   icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen +   np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,if ( np -> opt != NULL ) icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + np -> opt -> opt_nflen ) ;inet -> inet_dport = usin -> sin6_port ;,4872
1096,"return ;}ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\\switch ( pt ) {case PT_IPV4 : ip_print ( ndo , p , length ) ;case PT_OSI :  isoclns_print ( ndo , p , length , length ) ;break ;","case PT_OSI : isoclns_print ( ndo , p , length , length ) ;break ;",4873
1097,"strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ;}","strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 ) ;}",4874
1098,"option = stok ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;","option = ssplit ( option , ""<S2SV_blank>=\\\\t,"" , & ovalue ) ;ovalue = strim ( ovalue , ""\\\\""\\\'"" , MPR_TRIM_BOTH ) ;",4875
1099,"u_char * b , * s , * t , c ;int i , proto ;b = ( uint8_t * ) malloc ( length ) ;if ( b == NULL ) return ;for ( s = ( u_char * ) p , t = b , i = length ;i > 0 ;c = * s ++ ;if ( i > 1 ) {i -- ;c = * s ++ ^ 0x20 ;}else continue ;","u_char * b , * t , c ;const u_char * s ;int i , proto ;b = ( u_char * ) malloc ( length ) ;if ( b == NULL ) return ;for ( s = p , t = b , i = length ;i > 0 && ND_TTEST ( * s ) ;c = * s ++ ;if ( i <= 1 || ! ND_TTEST ( * s ) ) break ;i -- ;c = * s ++ ^ 0x20 ;",4876
1100,WORD16 i2_level_arr [ 4 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,WORD16 ai2_level_arr [ 7 ] ;WORD16 * i2_level_arr = & ai2_level_arr [ 3 ] ;tu_sblk4x4_coeff_data_t * ps_tu_4x4 ;,4877
1101,"dst_ctx = & per_cpu_ptr ( pmu -> pmu_cpu_context , dst_cpu ) -> ctx ;mutex_lock ( & src_ctx -> mutex ) ;list_for_each_entry_safe ( event , tmp , & src_ctx -> event_list , event_entry ) {mutex_unlock ( & src_ctx -> mutex ) ;synchronize_rcu ( ) ;mutex_lock ( & dst_ctx -> mutex ) ;","mutex_lock_double ( & src_ctx -> mutex , & dst_ctx -> mutex ) ;list_for_each_entry_safe ( event , tmp , & src_ctx -> event_list , event_entry ) {synchronize_rcu ( ) ;",4878
1102,},mutex_unlock ( & src_ctx -> mutex ) ;},4878
1103,atomic_inc ( & prog -> aux -> refcnt ) ;fdput ( f ) ;,prog = bpf_prog_inc ( prog ) ;fdput ( f ) ;,4879
1104,"static INLINE void write_buffer_8x8 ( int16_t * output , __m128i * res , int stride ) {_mm_store_si128 ( ( __m128i * ) ( output + 0 * stride ) , res [ 0 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 1 * stride ) , res [ 1 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 2 * stride ) , res [ 2 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 3 * stride ) , res [ 3 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 4 * stride ) , res [ 4 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 5 * stride ) , res [ 5 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 6 * stride ) , res [ 6 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 7 * stride ) , res [ 7 ] ) ;}","static INLINE void write_buffer_8x8 ( tran_low_t * output , __m128i * res , int stride ) {store_output ( & res [ 0 ] , ( output + 0 * stride ) ) ;store_output ( & res [ 1 ] , ( output + 1 * stride ) , res [ 1 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 2 * stride ) ) ;store_output ( & res [ 2 ] , ( output + 3 * stride ) , res [ 3 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 4 * stride ) ) ;store_output ( & res [ 3 ] , ( output + 5 * stride ) , res [ 5 ] ) ;_mm_store_si128 ( ( __m128i * ) ( output + 6 * stride ) ) ;store_output ( & res [ 4 ] , ( output + 7 * stride ) , res [ 7 ] ) ;}",4880
1105,"
",if ( unlikely ( page_count ( page ) <= 0 ) ) {if ( pages ) {spin_unlock ( ptl ) ;remainder = 0 ;err = - ENOMEM ;break ;}},4881
1106,same_page :  if ( pages ) {,same_page : if ( pages ) {,4881
1107,if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) {continue ;,if ( bin -> methods [ i ] . class_id > bin -> header . types_size ) {continue ;,4882
1108,uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ;if ( send_buf_size < pkg_size ) {assert ( send_buf != NULL ) ;},uint32_t pkg_size ;if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) {return - 1 ;}pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ;if ( send_buf_size < pkg_size ) {if ( send_buf == NULL ) {return - 1 ;}},4883
1109,"case UPDATE_TYPE_SYNCHRONIZE :  update_read_synchronize ( update , s ) ;rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ;","case UPDATE_TYPE_SYNCHRONIZE : if ( ! update_read_synchronize ( update , s ) ) goto fail ;rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ;",4884
1110,"# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE &&  * p == SSL3_MT_CLIENT_HELLO ) &&  ! dtls1_record_replay_check ( s , bitmap ) ) {","# endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) {",4885
1111,"ND_TCHECK ( pptr [ 0 ] ) ;plen = pptr [ 0 ] ;if ( 0 == plen ) {snprintf ( buf , buflen , ""default<S2SV_blank>route<S2SV_blank>target"" ) ;return 1 ;}if ( 32 > plen ) return - 1 ;plen -= 32 ;if ( 64 < plen ) return - 1 ;memset ( & route_target , 0 , sizeof ( route_target ) ) ;ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ;memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ;if ( plen % 8 ) {snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" ,  as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) ,  bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ;","char asbuf [ sizeof ( astostr ) ] ;ND_TCHECK ( pptr [ 5 ] , ( plen + 7 ) / 8 ) ;memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ;if ( plen % 8 ) {snprintf ( buf , buflen , ""origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ;",4886
1112,"static void consume_one_event ( unsigned cpu ,  struct evtchn_fifo_control_block * control_block ,  unsigned priority , unsigned long * ready ,  bool drop ) {","static void consume_one_event ( unsigned cpu , struct evtchn_loop_ctrl * ctrl , struct evtchn_fifo_control_block * control_block , unsigned priority , unsigned long * ready ) {",4887
1113,"if ( unlikely ( drop ) )  pr_warn ( ""Dropping<S2SV_blank>pending<S2SV_blank>event<S2SV_blank>for<S2SV_blank>port<S2SV_blank>%u\\\else  handle_irq_for_port ( port ) ;}","if ( unlikely ( ! ctrl ) ) pr_warn ( ""Dropping<S2SV_blank>pending<S2SV_blank>event<S2SV_blank>for<S2SV_blank>port<S2SV_blank>%u\\\else handle_irq_for_port ( port , ctrl ) ;}",4887
1114,"cstate = 0 ;if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {return - 1 ;}if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth ||  ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) {return - 1 ;if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) {jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\\return - 1 ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;jas_free ( siz -> comps ) ;return - 1 ;if ( jas_stream_eof ( in ) ) {jas_free ( siz -> comps ) ;return - 1 ;}return 0 ;}","siz -> comps = 0 ;cstate = 0 ;if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) {goto error ;if ( ! siz -> width || ! siz -> height ) {jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\goto error ;}if ( ! siz -> tilewidth || ! siz -> tileheight ) {jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\\goto error ;}if ( ! siz -> numcomps || siz -> numcomps > 16384 ) {jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> xoff >= siz -> width ) {jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> yoff >= siz -> height ) {jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) {jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;}if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) {jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\\goto error ;goto error ;goto error ;goto error ;goto error ;",4888
1115,if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;},"
",4889
1116,"chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;}skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ;chunk -> subh . v = NULL ;if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) {chunk -> singleton = 0 ;}else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) {sctp_chunk_free ( chunk ) ;chunk = queue -> in_progress = NULL ;return NULL ;",chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ;chunk -> pdiscard = 1 ;chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ;,4889
1117,last_id = ntohs ( * pid ) ;if ( last_id > 20000 ) wrap = 1 ;,if ( plen < 0 ) return 0 ;last_id = ntohs ( * pid ) ;if ( last_id > 20000 ) wrap = 1 ;,4890
1118,"
",char * rbuff = NULL ;,4891
1119,"ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Sending<S2SV_blank>request<S2SV_blank>to<S2SV_blank>chained<S2SV_blank>program:<S2SV_blank>%s\\\ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Request:<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\\fprintf ( sgfpw , ""%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\\fflush ( sgfpw ) ;chain_ret = ( char * ) malloc ( sizeof ( char ) * MAX_URL_SIZE ) ;","ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Sending<S2SV_blank>request<S2SV_blank>to<S2SV_blank>chained<S2SV_blank>program:<S2SV_blank>%s\\\ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Request:<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\\rbuff = replace ( httpinf . url , ""%"" , ""%25"" ) ;fprintf ( sgfpw , ""%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\\fflush ( sgfpw ) ;xfree ( rbuff ) ;chain_ret = ( char * ) malloc ( sizeof ( char ) * MAX_URL_SIZE ) ;",4891
1120,if ( ! values [ k ] . name )  continue ;,if ( ! values [ k ] . name ) {continue ;},4892
1121,msg -> msg_namelen = 0 ;do {,do {,4893
1122,"# ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds ,  encT ) ;# elif defined ( USE_ARM_ASM )  return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ;# else return do_encrypt_fn ( ctx , bx , ax ) ;","# ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , enc_tables . T ) ;# elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , enc_tables . T ) ;# else return do_encrypt_fn ( ctx , bx , ax ) ;",4894
1123,rect . x = Z_LVAL_PP ( tmp ) ;}rect . y = Z_LVAL_PP ( tmp ) ;}rect . width = Z_LVAL_PP ( tmp ) ;}rect . height = Z_LVAL_PP ( tmp ) ;},if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . x = Z_LVAL ( lval ) ;}else {rect . x = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . y = Z_LVAL ( lval ) ;}else {rect . y = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . width = Z_LVAL ( lval ) ;}else {rect . width = Z_LVAL_PP ( tmp ) ;}}if ( Z_TYPE_PP ( tmp ) != IS_LONG ) {zval lval ;lval = * * tmp ;zval_copy_ctor ( & lval ) ;convert_to_long ( & lval ) ;rect . height = Z_LVAL ( lval ) ;}else {rect . height = Z_LVAL_PP ( tmp ) ;}},4895
1124,"if ( s -> width != avctx -> width && s -> height != avctx -> height ) {ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ;","if ( s -> width != avctx -> width || s -> height != avctx -> height ) {ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ;",4896
1125,"if ( length == 1 && bp [ 0 ] == 0xff ) {ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ;}if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) {","ND_TCHECK ( bp [ 0 ] ) ;if ( length == 1 && bp [ 0 ] == 0xff ) {ND_PRINT ( ( ndo , ""isakmp-nat-keep-alive"" ) ) ;}ND_TCHECK ( bp [ 3 ] ) ;if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) {",4897
1126,"if ( sizeof ( content_type ) - 1 == klen && 0 == strncasecmp ( key , content_type , sizeof ( content_type ) - 1 ) ) {rb_hash_aset ( hh , content_type_val , rb_str_new ( val , vlen ) ) ;}else if ( sizeof ( content_length ) - 1 == klen && 0 == strncasecmp ( key , content_length , sizeof ( content_length ) - 1 ) ) {rb_hash_aset ( hh , content_length_val , rb_str_new ( val , vlen ) ) ;}char hkey [ 1024 ] ;char * k = hkey ;volatile VALUE sval = rb_str_new ( val , vlen ) ;strcpy ( hkey , ""HTTP_"" ) ;k = hkey + 5 ;if ( ( int ) ( sizeof ( hkey ) - 5 ) <= klen ) {klen = sizeof ( hkey ) - 6 ;strncpy ( k , key , klen ) ;hkey [ klen + 5 ] = \'\\\\0\' ;for ( k = hkey + 5 ;\'\\\\0\' != * k ;k ++ ) {if ( \'-\' == * k ) {* k = \'_\' ;* k = toupper ( * k ) ;rb_hash_aset ( hh , rb_str_new ( hkey , klen + 5 ) , sval ) ;}}","VALUE v ;if ( sizeof ( content_type ) - 1 == klen && 0 == strncasecmp ( key , content_type , sizeof ( content_type ) - 1 ) ) {if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_type_val , Qnil ) ) ) {rb_hash_aset ( hh , content_type_val , rb_str_new ( val , vlen ) ) ;}volatile VALUE a = rb_ary_new ( ) ;rb_ary_push ( a , v ) ;rb_ary_push ( a , rb_str_new ( val , vlen ) ) ;rb_hash_aset ( hh , content_type_val , a ) ;}kval = rb_str_new ( hkey , klen + 5 ) ;if ( Qnil == ( v = rb_hash_lookup2 ( hh , kval , Qnil ) ) ) {rb_hash_aset ( hh , kval , sval ) ;volatile VALUE a = rb_ary_new ( ) ;rb_ary_push ( a , v ) ;rb_ary_push ( a , sval ) ;rb_hash_aset ( hh , kval , a ) ;}",4898
1127,"# define ThrowCUTReaderException ( severity , tag ) {}Image * image , * palette ;","# define ThrowCUTReaderException ( severity , tag ) \\\\\\\\\\Image * image , * palette ;",4899
1128,"
","( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;",4899
1129,"offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {","offset = SeekBlob ( image , 6 , SEEK_SET ) ;if ( offset < 0 ) {",4899
1130,"archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC ,   ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;archive_clear_error ( & a -> archive ) ;","const size_t max_write = INT_MAX ;archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , ARCHIVE_STATE_DATA , ""archive_write_data"" ) ;if ( s > max_write ) s = max_write ;archive_clear_error ( & a -> archive ) ;",4900
1131,if ( 0 == ps_dec -> u2_header_done ) {ps_dec -> u2_horizontal_size = u2_width ;ps_dec -> u2_vertical_size = u2_height ;if ( 0 == ps_dec -> u4_frm_buf_stride )  {,if ( 0 == ps_dec -> i4_pic_count ) {return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ;}else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) {IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ;ps_dec -> u2_reinit_max_height = u2_height ;ps_dec -> u2_reinit_max_width = u2_width ;return e_error ;}else {if ( 0 == ps_dec -> u4_frm_buf_stride ) {,4901
1132,else if ( ( u2_width > ps_dec -> u2_create_max_width )   || ( u2_height > ps_dec -> u2_create_max_height ) )  {,else if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( u2_height > ps_dec -> u2_create_max_height ) ) {,4901
1133,return e_error ;},return e_error ;}if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) {return IMPEG2D_UNSUPPORTED_DIMENSIONS ;},4901
1134,xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn +  picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn +  picomp -> numrlvls - rlvlno - 1 ) ) ;,"if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) {return - 1 ;}xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ;",4902
1135,"if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) )   || ! ( pi -> x % ( 1 << rpx ) ) ) &&   ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) )   || ! ( pi -> y % ( 1 << rpy ) ) ) ) {prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;","if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) ) {prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ;",4902
1136,"if ( p -> tcph -> th_flags & TH_RST ) {if ( ! StreamTcpValidateRst ( ssn , p ) ) return - 1 ;","if ( StateSynSentValidateTimestamp ( ssn , p ) == false ) return - 1 ;if ( p -> tcph -> th_flags & TH_RST ) {if ( ! StreamTcpValidateRst ( ssn , p ) ) return - 1 ;",4903
1137,int result = RLC_OK ;bn_t t ;,int result = RLC_ERR ;bn_t t ;,4904
1138,if ( ! bn_is_zero ( t ) ) {result = RLC_ERR ;},result = RLC_OK ;if ( bn_is_zero ( t ) ) {result = RLC_ERR ;},4904
1139,if ( pad != RSA_PAD ) {result = RLC_ERR ;}break ;},if ( pad == RSA_PAD ) {result = RLC_ERR ;}break ;},4904
1140,if ( ! unconditional ( & e -> arp ) )  return false ;,if ( ! unconditional ( e ) ) return false ;,4905
1141,"char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ;rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ;uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ;int i , len ;","union {char bytes [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ;rfbSetColourMapEntriesMsg msg ;}buf ;rfbSetColourMapEntriesMsg * scme = & buf . msg ;uint16_t * rgb = ( uint16_t * ) ( & buf . bytes [ sz_rfbSetColourMapEntriesMsg ] ) ;int i , len ;",4906
1142,"if ( rfbWriteExact ( cl , buf , len ) < 0 ) {rfbLogPerror ( ""rfbSetClientColourMapBGR233:<S2SV_blank>write"" ) ;","if ( rfbWriteExact ( cl , buf . bytes , len ) < 0 ) {rfbLogPerror ( ""rfbSetClientColourMapBGR233:<S2SV_blank>write"" ) ;",4906
1143,char key [ 32 ] = {Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;,size_t vstart_off = i ;char key [ 32 ] = {Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ;,4907
1144,if ( vdaux < 1 || vstart + vdaux < vstart ) {sdb_free ( sdb_verdef ) ;vstart += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {,if ( vdaux < 1 || shdr -> sh_size - vstart_off < vdaux ) {sdb_free ( sdb_verdef ) ;vstart += vdaux ;vstart_off += vdaux ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {,4907
1145,if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,vstart_off += aux . vda_next ;if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) {sdb_free ( sdb_verdef ) ;,4907
1146,if ( current -> active_mm != mm )   goto out ;if ( ! current -> mm ) {goto out ;},if ( current -> active_mm != mm ) {smp_mb ( ) ;goto out ;}if ( ! current -> mm ) {smp_mb ( ) ;goto out ;},4908
1147,spin_lock_bh ( & g_cdev . lock ) ;pd = g_cdev . active_pd ;,if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;spin_lock_bh ( & g_cdev . lock ) ;pd = g_cdev . active_pd ;,4909
1148,"free_ep_req ( midi -> out_ep , req ) ;return err ;","if ( req -> buf != NULL ) free_ep_req ( midi -> out_ep , req ) ;return err ;",4910
1149,"handle = server -> connrec -> use_ssl ?  net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey ,  server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ;","handle = server -> connrec -> use_ssl ? net_connect_ip_ssl ( ip , port , server -> connrec -> address , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ;",4911
1150,"if ( frame_is_intra_only ( cm ) ) {active_best_quality = rc -> best_quality ;double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q ,  ( last_boosted_q * 0.75 ) ) ;active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;}else if ( cm -> current_video_frame > 0 ) {double q_adj_factor = 1.0 ;double q_val ;active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] ,   rc -> kf_boost ,  kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val ,  q_val * q_adj_factor ) ;}","int * rtc_minq ;ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ;if ( frame_is_intra_only ( cm ) ) {active_best_quality = rc -> best_quality ;double last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ;int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , ( last_boosted_q * 0.75 ) , cm -> bit_depth ) ;active_best_quality = get_kf_active_quality ( rc , rc -> avg_frame_qindex [ KEY_FRAME ] , rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;q_val = vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth ) ;active_best_quality += vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor , cm -> bit_depth ) ;}",4912
1151,"active_best_quality = get_active_quality (  q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ;if ( rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality )  active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ;else  active_best_quality = inter_minq [ active_worst_quality ] ;}if ( rc -> avg_frame_qindex [ KEY_FRAME ] < active_worst_quality )  active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ;else  active_best_quality = inter_minq [ active_worst_quality ] ;}# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY  if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) {if ( ! ( cm -> current_video_frame == 0 ) )  * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ;}","active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ;if ( rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) active_best_quality = rtc_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ;else active_best_quality = rtc_minq [ active_worst_quality ] ;}if ( rc -> avg_frame_qindex [ KEY_FRAME ] < active_worst_quality ) active_best_quality = rtc_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ;else active_best_quality = rtc_minq [ active_worst_quality ] ;}# if LIMIT_QRANGE_FOR_ALTREF_AND_KEY if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced && ! ( cm -> current_video_frame == 0 ) ) {int qdelta = 0 ;vpx_clear_system_state ( ) ;qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ;* top_index = active_worst_quality + qdelta ;* top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index ;}",4912
1152,"size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE ,  CORE_MMU_USER_PARAM_SIZE ) ;if ( ADD_OVERFLOW ( uaddr , len , & a ) )  return TEE_ERROR_ACCESS_DENIED ;for ( a = uaddr ;a < ( uaddr + len ) ;uint32_t attr ;","uaddr_t end_addr = 0 ;size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , CORE_MMU_USER_PARAM_SIZE ) ;if ( ADD_OVERFLOW ( uaddr , len , & end_addr ) ) return TEE_ERROR_ACCESS_DENIED ;for ( a = ROUNDDOWN ( uaddr , addr_incr ) ;a < end_addr ;uint32_t attr ;",4913
1153,Py_INCREF ( Py_None ) ;return Py_None ;,Py_RETURN_NONE ;,4914
1154,"old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ;old_eip = ctxt -> _eip ;if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) )  return X86EMUL_CONTINUE ;ctxt -> _eip = 0 ;memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ;if ( rc != X86EMUL_CONTINUE ) return rc ;return em_push ( ctxt ) ;","struct desc_struct old_desc , new_desc ;const struct x86_emulate_ops * ops = ctxt -> ops ;int cpl = ctxt -> ops -> cpl ( ctxt ) ;old_eip = ctxt -> _eip ;ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ;rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ;if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE ;rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;if ( rc != X86EMUL_CONTINUE ) goto fail ;rc = em_push ( ctxt ) ;if ( rc != X86EMUL_CONTINUE ) goto fail ;return rc ;fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ;return rc ;",4915
1155,"UINT16 count ;BITMAP_DATA * newdata ;count = bitmapUpdate -> number * 2 ;newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles ,  sizeof ( BITMAP_DATA ) * count ) ;","UINT32 count = bitmapUpdate -> number * 2 ;BITMAP_DATA * newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , sizeof ( BITMAP_DATA ) * count ) ;",4916
1156,"if ( buf )   grub_memcpy ( buf , data + pos + real_offset , len ) ;grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ;","if ( buf ) {if ( pos + real_offset + len >= size ) {grub_errno = GRUB_ERR_BAD_FS ;return grub_errno ;}grub_memcpy ( buf , data + pos + real_offset , len ) ;}grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ;",4917
1157,"void * dllhandle ;if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\","void * dllhandle ;if ( COM_CompareExtension ( name , "".pk3"" ) ) {Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\\\""%s\\\\"""" , name ) ;return NULL ;}if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\\\""%s\\\\""...\\\",4918
1158,if ( chunk_num > chm -> num_chunks ) return NULL ;if ( ! chm -> chunk_cache ) {,if ( chunk_num >= chm -> num_chunks ) return NULL ;if ( ! chm -> chunk_cache ) {,4919
1159,if ( ! el )  return 0 ;,"if ( ! el ) {if ( c -> rbytes > 1024 ) {char * ptr = c -> rcurr ;while ( * ptr == \'<S2SV_blank>\' ) {++ ptr ;}if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) {conn_set_state ( c , conn_closing ) ;return 1 ;}}return 0 ;}",4920
1160,"rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ;if ( rc -> uwbd . task == NULL )  printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;else  rc -> uwbd . pid = rc -> uwbd . task -> pid ;}","struct task_struct * task = kthread_run ( uwbd , rc , ""uwbd"" ) ;if ( IS_ERR ( task ) ) {rc -> uwbd . task = NULL ;printk ( KERN_ERR ""UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;}else {rc -> uwbd . task = task ;rc -> uwbd . pid = rc -> uwbd . task -> pid ;}}",4921
1161,"start = vma -> vm_start ;if ( expand_stack ( vma , addr ) ) return NULL ;","if ( ! mmget_still_valid ( mm ) ) return NULL ;start = vma -> vm_start ;if ( expand_stack ( vma , addr ) ) return NULL ;",4922
1162,for ( i = scm -> fp -> count - 1 ;,"for ( i = scm -> fp -> user , scm -> fp -> count - 1 ;",4923
1163,i -- )  unix_inflight ( scm -> fp -> fp [ i ] ) ;return max_level ;,i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ;return max_level ;,4923
1164,"if ( _PyObject_HasAttrId ( obj , & PyId_arg ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_identifier ( tmp , & arg , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}else {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""arg\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ;if ( exists_not_none ( obj , & PyId_annotation ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_annotation ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_expr ( tmp , & annotation , arena ) ;if ( res != 0 ) goto failed ;}else {annotation = NULL ;if ( exists_not_none ( obj , & PyId_type_comment ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( res != 0 ) goto failed ;if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & lineno , arena ) ;else {if ( _PyObject_HasAttrId ( obj , & PyId_col_offset ) ) {tmp = _PyObject_GetAttrId ( obj , & PyId_col_offset ) ;if ( tmp == NULL ) goto failed ;res = obj2ast_int ( tmp , & col_offset , arena ) ;else {","if ( lookup_attr_id ( obj , & PyId_arg ) ) {int res ;tmp = _PyObject_GetAttrId ( obj , & PyId_arg , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\\\""arg\\\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ;else {res = obj2ast_identifier ( tmp , & arg , arena ) ;if ( res != 0 ) goto failed ;if ( lookup_attr_id ( obj , & PyId_annotation , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {annotation = NULL ;int res ;res = obj2ast_expr ( tmp , & annotation , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL || tmp == Py_None ) {Py_CLEAR ( tmp ) ;else {res = obj2ast_string ( tmp , & type_comment , arena ) ;if ( lookup_attr_id ( obj , & PyId_lineno , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {else {res = obj2ast_int ( tmp , & lineno , arena ) ;if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) {return 1 ;}if ( tmp == NULL ) {else {int res ;res = obj2ast_int ( tmp , & col_offset , arena ) ;if ( res != 0 ) goto failed ;Py_CLEAR ( tmp ) ;}",4924
1165,"int count , i ;count = be32_to_cpu ( aclp -> acl_cnt ) ;","unsigned int count , i ;count = be32_to_cpu ( aclp -> acl_cnt ) ;",4925
1166,"duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;","duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\\err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ;if ( err ) return err ;",4926
1167,"stat ( options -> in_file , & filestats ) ;plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ;","stat ( options -> in_file , & filestats ) ;if ( filestats . st_size < 8 ) {printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\\return - 1 ;}plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ;",4927
1168,if ( client -> priv -> protocol_timeout ) {g_source_remove ( client -> priv -> protocol_timeout ) ;client -> priv -> protocol_timeout = 0 ;},"
",4928
1169,"checkstackp ( L , nextra , where ) ;L -> top = where + nextra ;","checkstackGCp ( L , nextra , where ) ;L -> top = where + nextra ;",4929
1170,MODE_INFO * const mic = xd -> mi [ 0 ] ;const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ;const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;,MODE_INFO * const mic = xd -> above_mi ;const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ;const MODE_INFO * left_mi = xd -> left_mi ;const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;,4930
1171,"const int * bmode_costs = mb -> mbmode_cost ;vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ;vpx_memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ;for ( idy = 0 ;MB_PREDICTION_MODE best_mode = DC_PRED ;int r = INT_MAX , ry = INT_MAX ;const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , i ) ;const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , i ) ;bmode_costs = mb -> y_mode_costs [ A ] [ L ] ;}this_rd = rd_pick_intra4x4block ( cpi , mb , i , & best_mode , bmode_costs , t_above + idx , t_left + idy , & r , & ry , & d , bsize , best_rd - total_rd ) ;","const int * bmode_costs = cpi -> mbmode_cost ;vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ;memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ;for ( idy = 0 ;PREDICTION_MODE best_mode = DC_PRED ;int r = INT_MAX , ry = INT_MAX ;const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , i ) ;const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , i ) ;bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ;}this_rd = rd_pick_intra4x4block ( cpi , mb , idy , idx , & best_mode , bmode_costs , t_above + idx , t_left + idy , & r , & ry , & d , bsize , best_rd - total_rd ) ;",4930
1172,"if ( settings . verbose > 1 ) {fprintf ( stderr , ""%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\\}}if ( c -> protocol == binary_prot ) {if ( c -> rbytes < sizeof ( c -> binary_header ) ) {return 0 ;}else {# ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) {memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ;c -> rcurr = c -> rbuf ;if ( settings . verbose > 1 ) {fprintf ( stderr , ""%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\\}}# endif protocol_binary_request_header * req ;req = ( protocol_binary_request_header * ) c -> rcurr ;if ( settings . verbose > 1 ) {int ii ;fprintf ( stderr , ""<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:"" , c -> sfd ) ;for ( ii = 0 ;ii < sizeof ( req -> bytes ) ;++ ii ) {if ( ii % 4 == 0 ) {fprintf ( stderr , ""\\\}fprintf ( stderr , ""<S2SV_blank>0x%02x"" , req -> bytes [ ii ] ) ;}fprintf ( stderr , ""\\\}c -> binary_header = * req ;c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ;c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ;c -> binary_header . request . cas = ntohll ( req -> request . cas ) ;if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) {if ( settings . verbose ) {fprintf ( stderr , ""Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\\}return - 1 ;}c -> msgcurr = 0 ;c -> msgused = 0 ;c -> iovused = 0 ;if ( add_msghdr ( c ) != 0 ) {out_string ( c , ""SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory"" ) ;return 0 ;}c -> cmd = c -> binary_header . request . opcode ;c -> keylen = c -> binary_header . request . keylen ;c -> opaque = c -> binary_header . request . opaque ;c -> cas = 0 ;dispatch_bin_command ( c ) ;c -> rbytes -= sizeof ( c -> binary_header ) ;c -> rcurr += sizeof ( c -> binary_header ) ;}}else {char * el , * cont ;if ( c -> rbytes == 0 ) return 0 ;el = memchr ( c -> rcurr , \'\\\if ( ! el ) {if ( c -> rbytes > 1024 ) {char * ptr = c -> rcurr ;while ( * ptr == \'<S2SV_blank>\' ) {++ ptr ;}if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) {conn_set_state ( c , conn_closing ) ;","+ ii ) {if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr , ""get<S2SV_blank>"" , 4 ) && strncmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" , 5 ) ) ) {+ ptr ;",4931
1173,"int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( pos != last_pos ) {","int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ;if ( avio_feof ( s -> pb ) ) {ret = AVERROR_INVALIDDATA ;goto end ;}if ( pos != last_pos ) {",4932
1174,static int udp_push_pending_frames ( struct sock * sk )  {,int udp_push_pending_frames ( struct sock * sk ) {,4933
1175,"for ( pass = 0 ;pass < 10 ;proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ;","for ( pass = 0 ;pass < 10 || image ;proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ;",4934
1176,if ( source == target )  return 0 ;,"if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) ) return 0 ;",4935
1177,"bool tsonly ;if ( ! sk ) return ;# ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP &&  sk -> sk_type == SOCK_STREAM )  skb = tcp_get_timestamping_opt_stats ( sk ) ;else  # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ;","bool tsonly , opt_stats = false ;if ( ! sk ) return ;# ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) {skb = tcp_get_timestamping_opt_stats ( sk ) ;opt_stats = true ;}else # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ;",4936
1178,"__skb_complete_tx_timestamp ( skb , sk , tstype ) ;}","__skb_complete_tx_timestamp ( skb , sk , tstype , opt_stats ) ;}",4936
1179,return 0 ;},_TIFFfree ( working_copy ) ;return 0 ;},4937
1180,struct loop_device * lo = disk -> private_data ;int err ;if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ;mutex_lock ( & lo -> lo_ctl_mutex ) ;if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) {err = loop_clr_fd ( lo ) ;if ( ! err ) return ;else if ( lo -> lo_state == Lo_bound ) {blk_mq_freeze_queue ( lo -> lo_queue ) ;blk_mq_unfreeze_queue ( lo -> lo_queue ) ;}mutex_unlock ( & lo -> lo_ctl_mutex ) ;},mutex_lock ( & loop_index_mutex ) ;__lo_release ( disk -> private_data ) ;mutex_unlock ( & lo -> lo_ctl_mutex ) ;,4938
1181,"# if ENABLE_BGP_VNC  case BGP_ATTR_VNC : # endif case BGP_ATTR_ENCAP : ret = bgp_attr_encap ( type , peer , length , attr , flag , startp ) ;","# if ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC : # endif case BGP_ATTR_ENCAP : ret = bgp_attr_encap ( type , peer , length , attr , flag , startp ) ;",4939
1182,"for ( plane = 0 ;inpic -> data [ plane ] && plane < 4 ;h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ;","plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ] ;h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ;",4940
1183,"return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) ,  re -> flags | RE_FLAGS_SCAN ,  NULL , NULL ) ;","return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) , 0 , re -> flags | RE_FLAGS_SCAN , NULL , NULL ) ;",4941
1184,"static const u_char *  ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep )  {if ( p [ 0 ] & 0x80 )  totlen = 4 ;else  totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ;if ( ep < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ;}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ;}return p + totlen ;}","static const u_char * ep2 ) {ND_TCHECK ( p [ 0 ] ) ;if ( p [ 0 ] & 0x80 ) totlen = 4 ;else {ND_TCHECK_16BITS ( & p [ 2 ] ) ;}if ( ep2 < p + totlen ) {ND_PRINT ( ( ndo , ""[|attr]"" ) ) ;return ep + 1 ;}ND_PRINT ( ( ndo , ""("" ) ) ;rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ;if ( ! rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , totlen - 4 ) ) {ND_PRINT ( ( ndo , "")"" ) ) ;goto trunc ;}}return p + totlen ;trunc : return NULL ;}",4942
1185,"( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ;return 1 ;}","return ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ;}",4943
1186,"inl = i2d ( data , NULL ) ;buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ;","if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) {ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ;goto err ;}inl = i2d ( data , NULL ) ;buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ;",4944
1187,". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) ,  . match_data . cmp = type -> match ,  . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , }int ret ;if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ;",". index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , }int ret ;if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ;",4945
1188,"if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) {bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ;struct bpf_insn mask_and_div [ ] = {BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , };struct bpf_insn mask_and_mod [ ] = {BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , };struct bpf_insn * patchlet ;if ( insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) {patchlet = mask_and_div + ( is64 ? 1 : 0 ) ;cnt = ARRAY_SIZE ( mask_and_div ) - ( is64 ? 1 : 0 ) ;}else {patchlet = mask_and_mod + ( is64 ? 1 : 0 ) ;cnt = ARRAY_SIZE ( mask_and_mod ) - ( is64 ? 1 : 0 ) ;}new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ;if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) {cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\\return - EINVAL ;}new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ;if ( ! new_prog ) return - ENOMEM ;delta += cnt - 1 ;env -> prog = prog = new_prog ;insn = new_prog -> insnsi + i + delta ;continue ;}if ( insn -> code != ( BPF_JMP | BPF_CALL ) )  continue ;if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ;if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ;if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ;if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ;if ( insn -> imm == BPF_FUNC_tail_call ) {prog -> cb_access = 1 ;env -> prog -> aux -> stack_depth = MAX_BPF_STACK ;env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ;insn -> imm = 0 ;insn -> code = BPF_JMP | BPF_TAIL_CALL ;if ( ! bpf_map_ptr_unpriv ( aux ) )  continue ;if ( bpf_map_ptr_poisoned ( aux ) ) {verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\\","if ( insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) {const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ;const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ;struct bpf_insn insn_buf [ 16 ] ;struct bpf_insn * patch = & insn_buf [ 0 ] ;bool issrc , isneg ;u32 off_reg ;if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ;if ( bpf_map_ptr_poisoned ( aux ) ) {verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\\",4946
1189,"if ( prog -> jit_requested && BITS_PER_LONG == 64 &&  ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) {if ( bpf_map_ptr_poisoned ( aux ) )   goto patch_call_imm ;map_ptr = BPF_MAP_PTR ( aux -> map_state ) ;ops = map_ptr -> ops ;if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) {cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {","if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) {if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ;map_ptr = BPF_MAP_PTR ( aux -> map_state ) ;ops = map_ptr -> ops ;if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) {cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ;if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) {",4946
1190,"BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem ,  ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ;","BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ;",4946
1191,iterator = rfbGetClientIterator ( rfbScreen ) ;while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) {,"memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ;iterator = rfbGetClientIterator ( rfbScreen ) ;while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) {",4947
1192,"if ( Stream_GetRemainingLength ( s ) < 2 )  return FALSE ;Stream_Read_UINT16 ( s , * length ) ;if ( * length == 0x8000 )  {rdp_read_flow_control_pdu ( s , type ) ;* channel_id = 0 ;if ( ( ( size_t ) * length - 2 ) > Stream_GetRemainingLength ( s ) )  return FALSE ;if ( * length > 4 )  Stream_Read_UINT16 ( s , * channel_id ) ;","UINT16 len ;if ( Stream_GetRemainingLength ( s ) < 2 ) return FALSE ;Stream_Read_UINT16 ( s , len ) ;* length = len ;if ( len == 0x8000 ) {if ( ! rdp_read_flow_control_pdu ( s , type ) ) return FALSE ;* channel_id = 0 ;if ( ( len < 4 ) || ( ( len - 2 ) > Stream_GetRemainingLength ( s ) ) ) return FALSE ;if ( len > 4 ) Stream_Read_UINT16 ( s , * channel_id ) ;",4948
1193,"err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ;if ( err < 0 ) {","err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCGIFHWADDR , & ifr ) ) ;if ( err < 0 ) {",4949
1194,"err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ;if ( err < 0 ) {","err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ) ;if ( err < 0 ) {",4949
1195,"err = ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ;if ( err < 0 ) {","err = TEMP_FAILURE_RETRY ( ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ) ;if ( err < 0 ) {",4949
1196,"int get_down2_steps ( int in_length , int out_length ) {int steps = 0 ;","static int get_down2_steps ( int in_length , int out_length ) {int steps = 0 ;",4950
1197,"if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Cherry<S2SV_blank>Cymotion<S2SV_blank>report<S2SV_blank>descriptor\\\","if ( * rsize >= 18 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) {hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Cherry<S2SV_blank>Cymotion<S2SV_blank>report<S2SV_blank>descriptor\\\",4951
1198,prefix = report [ i ] ;i ++ ;size = PREF_SIZE ( prefix ) ;case 2 : data16 = get_unaligned_le16 ( & report [ i ] ) ;break ;case 3 :  size = 4 ;data32 = get_unaligned_le32 ( & report [ i ] ) ;,"prefix = report [ i ++ ] ;size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ;if ( i + size > length ) {dev_err ( ddev , ""Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\\break ;}case 4 : data32 = get_unaligned_le32 ( & report [ i ] ) ;",4952
1199,# ifndef PGEN  Py_INCREF ( err_ret -> filename ) ;,if ( * flags & PyPARSE_TYPE_COMMENTS ) {tok -> type_comments = 1 ;}# ifndef PGEN Py_INCREF ( err_ret -> filename ) ;,4953
1200,"static void set_segment_id ( VP9_COMMON * cm , BLOCK_SIZE bsize ,  int mi_row , int mi_col , int segment_id ) {const int mi_offset = mi_row * cm -> mi_cols + mi_col ;const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;for ( y = 0 ;y < ymis ;y ++ )   for ( x = 0 ;x < xmis ;x ++ )   cm -> last_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ;}","static void set_segment_id ( VP9_COMMON * cm , int mi_offset , int x_mis , int y_mis , int segment_id ) {const int mi_offset = mi_row * cm -> mi_cols + mi_col ;const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;for ( y = 0 ;y < y_mis ;y ++ ) for ( x = 0 ;x < x_mis ;x ++ ) cm -> current_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ;}",4954
1201,"if ( keyring ) {if ( keyring -> restrict_link ) return - EPERM ;link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ;}mutex_lock ( & key_construction_mutex ) ;if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {atomic_inc ( & key -> user -> nikeys ) ;key -> reject_error = - error ;smp_wmb ( ) ;",if ( key -> state == KEY_IS_UNINSTANTIATED ) {atomic_inc ( & key -> user -> nikeys ) ;key -> reject_error = - error ;smp_wmb ( ) ;,4955
1202,"size_t i , maxcount ;const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ;","size_t maxcount ;const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ;",4956
1203,"ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ;* count = 0 ;for ( i = 0 ;i < CDF_TOLE4 ( si -> si_count ) ;i ++ ) {if ( i >= CDF_LOOP_LIMIT ) {DPRINTF ( ( ""Unpack<S2SV_blank>summary<S2SV_blank>info<S2SV_blank>loop<S2SV_blank>limit"" ) ) ;errno = EFTYPE ;if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) ,  info , count , & maxcount ) == - 1 ) {return - 1 ;}}","ssi -> si_count = CDF_TOLE4 ( si -> si_count ) ;* count = 0 ;if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) , info , count , & maxcount ) == - 1 ) {}",4956
1204,"static inline void header_put_byte ( SF_PRIVATE * psf , char x )  {if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 1 )   psf -> header [ psf -> headindex ++ ] = x ;}","static inline void header_put_byte ( SF_PRIVATE * psf , char x ) {psf -> header ) - 1 ) psf -> header [ psf -> headindex ++ ] = x ;}",4957
1205,"Total += vp8_mse16x16 ( src + j , source -> y_stride ,  dst + j , dest -> y_stride , & sse ) ;","Total += vpx_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ;",4958
