,source,target
0,<S2SV_StartBug> data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x8b ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = offset ; <S2SV_EndBug> <S2SV_StartBug> return l ; <S2SV_EndBug> <S2SV_StartBug> if ( a -> bits == 64 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x25 ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; <S2SV_EndBug> <S2SV_StartBug> if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; <S2SV_EndBug> ,<S2SV_ModStart> % 6 <S2SV_ModStart> data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> } <S2SV_ModStart> } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } <S2SV_ModStart> op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED <S2SV_ModEnd> <S2SV_ModStart> op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 <S2SV_ModEnd> <S2SV_ModStart> if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> <S2SV_ModStart> op -> operands [ 1 ] . regs [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1,"<S2SV_StartBug> if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> "
2,"<S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , const struct stat * fsb <S2SV_ModStart> uid_t luid = dsb . st_uid ; <S2SV_ModStart> && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> "
3,"<S2SV_StartBug> int r = ( int ) recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , <S2SV_EndBug> <S2SV_StartBug> p_dcb -> mtu , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
4,<S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> ,<S2SV_ModStart> d_flags |= DCACHE_RCUACCESS ; dentry -> 
5,"<S2SV_StartBug> uint8_t * buf = mempool_alloc ( buf_pool ) ; <S2SV_EndBug> <S2SV_StartBug> uint8_t * ptr ; <S2SV_EndBug> <S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> ptr = buf + sizeof ( pack -> hdr ) ; <S2SV_EndBug> <S2SV_StartBug> avp -> M = attr -> M ; <S2SV_EndBug> <S2SV_StartBug> avp -> length = sizeof ( * avp ) + attr -> length ; <S2SV_EndBug> <S2SV_StartBug> n = sendto ( sock , buf , ntohs ( pack -> hdr . length ) , 0 , <S2SV_EndBug> <S2SV_StartBug> if ( n != ntohs ( pack -> hdr . length ) ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>write<S2SV_blank>(%i/%i)\\n"" , n , ntohs ( pack -> hdr . length ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct l2tp_hdr_t * hdr <S2SV_ModEnd> <S2SV_ModStart> buf , * <S2SV_ModStart> , len ; buf = mempool_alloc ( buf_pool <S2SV_ModEnd> <S2SV_ModStart> hdr = ( struct l2tp_hdr_t * ) buf ; ptr = ( uint8_t * ) ( hdr + 1 ) ; len = <S2SV_ModEnd> <S2SV_ModStart> flags = htons ( ( attr -> M ? L2TP_AVP_FLAG_M : 0 ) | ( attr -> H ? L2TP_AVP_FLAG_H : 0 ) | ( ( <S2SV_ModEnd> <S2SV_ModStart> ) & L2TP_AVP_LEN_MASK ) <S2SV_ModEnd> <S2SV_ModStart> hdr -> flags = htons ( pack -> hdr . flags ) ; <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> "
6,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug> ","<S2SV_ModStart> > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
7,<S2SV_StartBug> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { <S2SV_EndBug> ,<S2SV_ModStart> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo -> 
8,"<S2SV_StartBug> ""zlib@openssh.com,zlib,none"" : ""none,zlib@openssh.com,zlib"" ; <S2SV_EndBug> ","<S2SV_ModStart> ""zlib@openssh.com,none"" : ""none,zlib@openssh.com"" <S2SV_ModEnd> "
9,<S2SV_StartBug> len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ; <S2SV_EndBug> ,<S2SV_ModStart> = 20 + level <S2SV_ModEnd> 
10,"<S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sk -> sk_state != TCP_CLOSE ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if ( "
11,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ; 
12,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> <S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> <S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> 
13,<S2SV_StartBug> void close_connection ( h2o_http2_conn_t * conn ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return - 1 ; } return 0 ; <S2SV_ModEnd> 
14,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
15,<S2SV_StartBug> while ( res == 0 && dev ) { <S2SV_EndBug> <S2SV_StartBug> dev = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
16,"<S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> case CFM_CHASSIS_ID_MAC_ADDRESS : <S2SV_EndBug> <S2SV_StartBug> hexdump |= cfm_network_addr_print ( ndo , tptr ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mgmt_addr_length ) { <S2SV_EndBug> <S2SV_StartBug> cfm_tlv_len -= mgmt_addr_length ; <S2SV_EndBug> <S2SV_StartBug> tptr += cfm_tlv_len ; <S2SV_EndBug> ","<S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)"" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> + 1 , chassis_id_length <S2SV_ModStart> break <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> goto next_tlv <S2SV_ModEnd> <S2SV_ModStart> ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> ""<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)"" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u"" , mgmt_addr_length ) ) ; <S2SV_ModStart> ; hex_print ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>"" , tptr , mgmt_addr_length ) <S2SV_ModStart> next_tlv : "
17,"<S2SV_StartBug> jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" <S2SV_ModStart> if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" ) ; return - 1 ; } "
18,<S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
19,"<S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> ","<S2SV_ModStart> char * p ; int len ; <S2SV_ModStart> len = <S2SV_ModEnd> <S2SV_ModStart> ; if ( retnamlen + len <S2SV_ModEnd> <S2SV_ModStart> p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> "
20,<S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( inbuffer = ReadInput ( inname ) ) == 0 ) return ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( - 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
21,"<S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , delim ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false <S2SV_ModStart> , false "
22,"<S2SV_StartBug> static INLINE void right_shift_8x8 ( __m128i * res , int const bit ) { <S2SV_EndBug> <S2SV_StartBug> if ( bit_m02 >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , bit ) ; <S2SV_EndBug> ","<S2SV_ModStart> const int bit ) { <S2SV_ModEnd> <S2SV_ModStart> bit == 2 ) { const __m128i const_rounding = _mm_set1_epi16 ( 1 ) ; res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , const_rounding ) ; res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , const_rounding ) ; res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , const_rounding ) ; res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , const_rounding ) ; res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , const_rounding ) ; res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , const_rounding ) ; res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , const_rounding ) ; res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , const_rounding <S2SV_ModEnd> <S2SV_ModStart> if ( bit == 1 ) { res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 1 ) ; res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 1 ) ; res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 1 ) ; res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 1 ) ; res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 1 ) ; res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 1 ) ; res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 1 ) ; res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 1 ) ; } else { res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 2 ) ; res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 2 ) ; res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 2 ) ; res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 2 ) ; res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 2 ) ; res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 2 ) ; res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 2 ) ; res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 2 ) ; } <S2SV_ModEnd> "
23,<S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> ,<S2SV_ModStart> EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> 
24,<S2SV_StartBug> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <S2SV_EndBug> ,<S2SV_ModStart> inet_sk ( newsk ) -> mc_list = NULL ; 
25,"<S2SV_StartBug> status = nfsd4_encode_bitmap ( xdr , NFSD_SUPPATTR_EXCLCREAT_WORD0 , <S2SV_EndBug> ","<S2SV_ModStart> u32 supp [ 3 ] ; memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ; supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ; supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ; <S2SV_ModStart> supp [ 0 ] , supp [ 1 ] , supp [ 2 ] <S2SV_ModEnd> "
26,<S2SV_StartBug> if ( wsctx && wsctx -> readbuflen ) <S2SV_EndBug> ,<S2SV_ModStart> readlen <S2SV_ModEnd> 
27,"<S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( newnp -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( opt ) { <S2SV_ModEnd> <S2SV_ModStart> opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> opt <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
28,<S2SV_StartBug> prev = NULL ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> skip_mm : 
29,<S2SV_StartBug> pExpr -> iTable = pX -> iIdxCur ; <S2SV_EndBug> ,"<S2SV_ModStart> assert ( pExpr -> y . pTab != 0 ) ; pExpr -> affExpr = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ; "
30,<S2SV_StartBug> char * path = server . diskstore_path ; <S2SV_EndBug> ,<S2SV_ModStart> ds_path <S2SV_ModEnd> 
31,"<S2SV_StartBug> Stream_Read_UINT32 ( s , scopeCount ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE 
32,"<S2SV_StartBug> void vp9_idct4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> <S2SV_StartBug> vp9_idct4x4_16_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct4x4_1_add ( input , dest , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_idct4x4_16_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct4x4_1_add <S2SV_ModEnd> 
33,<S2SV_StartBug> INST_HANDLER ( sts ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 4 ) { return ; } 
34,"<S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0U ; i < maxh ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> if ( j < maxw ) { <S2SV_EndBug> <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> , offx , loopmaxw <S2SV_ModStart> size_t i <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> <S2SV_ModStart> dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
35,"<S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> <S2SV_ModStart> ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> "
36,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> <S2SV_StartBug> DATA_SYNC ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } } 
37,<S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { 
38,<S2SV_StartBug> ExprList_Init ( & state -> expr_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> state -> fmode = 0 ; 
39,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ret ) invalidate_lstat_cache ( ) ; 
40,<S2SV_StartBug> if ( ! awaiting_character ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! recovery_started 
41,"<S2SV_StartBug> int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
42,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( a ) ; 
43,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_type ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> stmt_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( body , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type = NULL ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; name = NULL ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = ExceptHandler ( type , name , body , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
44,"<S2SV_StartBug> u8 reset ; <S2SV_EndBug> <S2SV_StartBug> hx = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ret = usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) <S2SV_EndBug> <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> <S2SV_StartBug> reset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( hx ) ; <S2SV_EndBug> ","<S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> u16 cpu_cs_register = <S2SV_ModEnd> <S2SV_ModStart> ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> buf [ 0 ] = 0 ; if ( <S2SV_ModEnd> <S2SV_ModStart> cpu_cs_register , buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> "
45,"<S2SV_StartBug> void set_header ( HttpResponse res , const char * name , const char * value ) { <S2SV_EndBug> <S2SV_StartBug> h -> value = Str_dup ( value ) ; <S2SV_EndBug> ","<S2SV_ModStart> , ... <S2SV_ModStart> va_list ap ; va_start ( ap , value ) ; <S2SV_ModStart> Str_vcat ( value , ap ) ; va_end ( ap <S2SV_ModEnd> "
46,"<S2SV_StartBug> char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded = NULL ; <S2SV_EndBug> <S2SV_StartBug> mask2 = weechat_string_replace ( mask , dir_separator , ""\\01"" ) ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 = malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! mask_decoded5 ) <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ; <S2SV_EndBug> <S2SV_StartBug> weechat_string_tolower ( mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> mask , mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mask_decoded ) <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded2 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded3 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded4 ) ; <S2SV_EndBug> <S2SV_StartBug> return mask_decoded5 ; <S2SV_EndBug> ","<S2SV_ModStart> mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> <S2SV_ModStart> mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> <S2SV_ModStart> length = strlen ( mask <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> if ( strftime ( mask2 <S2SV_ModEnd> <S2SV_ModStart> mask <S2SV_ModEnd> <S2SV_ModStart> == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\01"" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , ""\\01"" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> mask7 <S2SV_ModEnd> <S2SV_ModStart> mask7 <S2SV_ModEnd> <S2SV_ModStart> mask3 <S2SV_ModEnd> <S2SV_ModStart> mask3 ) ; if ( mask4 <S2SV_ModEnd> <S2SV_ModStart> mask4 ) ; if ( mask5 <S2SV_ModEnd> <S2SV_ModStart> mask5 ) ; if ( mask6 <S2SV_ModEnd> <S2SV_ModStart> mask6 <S2SV_ModEnd> <S2SV_ModStart> mask7 <S2SV_ModEnd> "
47,<S2SV_StartBug> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) && <S2SV_EndBug> ,<S2SV_ModStart> if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { <S2SV_ModStart> } else { xWantedSize = 0 ; } <S2SV_ModStart> ( xWantedSize > 0 ) && 
48,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , rel ) ; <S2SV_EndBug> ",<S2SV_ModStart> int rc ; <S2SV_ModStart> rc = <S2SV_ModStart> ; if ( rc != X86EMUL_CONTINUE ) return rc 
49,"<S2SV_StartBug> if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , ""chunked"" ) != NULL ) ) { <S2SV_EndBug> ",<S2SV_ModStart> m_strcasestr <S2SV_ModEnd> 
50,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> return get_desc_base ( desc ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> & "
51,<S2SV_StartBug> if ( read != entry . uncompressed_filesize ) { <S2SV_EndBug> ,<S2SV_ModStart> || read <= 8 
52,"<S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ",<S2SV_ModStart> userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> if ( likely ( ! ret ) ) <S2SV_ModStart> else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> 
53,"<S2SV_StartBug> vp9_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( x -> e_mbd . cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride , x -> e_mbd . bd ) ; return ; } # endif vpx_subtract_block <S2SV_ModEnd> "
54,<S2SV_StartBug> static unsigned short len = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
55,"<S2SV_StartBug> return g_NPN_GetValue_real ( instance , variable , value ) ; <S2SV_EndBug> ",<S2SV_ModStart> case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : 
56,"<S2SV_StartBug> ( IN_DEV_SHARED_MEDIA ( out_dev ) || <S2SV_EndBug> <S2SV_StartBug> inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> skb -> protocol == htons ( ETH_P_IP ) && <S2SV_ModStart> IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ; <S2SV_ModEnd> 
57,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
58,"<S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ","<S2SV_ModStart> struct smb_vol * vol ) { <S2SV_ModEnd> <S2SV_ModStart> list_for_each_entry ( ses <S2SV_ModEnd> <S2SV_ModStart> , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> <S2SV_ModStart> vol -> <S2SV_ModStart> if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; } "
59,"<S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> ",<S2SV_ModStart> rc = <S2SV_ModStart> rc = <S2SV_ModStart> rc = 
60,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> q ++ ; p <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> 
61,"<S2SV_StartBug> skb = sock_alloc_send_skb ( sk , <S2SV_EndBug> <S2SV_StartBug> skb -> csum = 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct frag_hdr fhdr ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) <S2SV_ModEnd> "
62,"<S2SV_StartBug> PIXA * pixa ; <S2SV_EndBug> <S2SV_StartBug> pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> pixDisplayWithTitle ( pix1 , 100 , 0 , NULL , rp -> display ) ; <S2SV_EndBug> <S2SV_StartBug> pixDestroy ( & pix1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , * pixa2 <S2SV_ModStart> pixa2 = pixaCreate ( 3 ) ; pix1 = pixRead ( ""weasel8.png"" ) ; pixGammaTRC ( pix1 , pix1 , 1.0 , 0 , 270 ) ; pixaAddPix ( pixa2 , pix1 , L_COPY ) ; pixGetDimensions ( pix1 , & w , & h , NULL ) ; pixRasterop ( pix1 , 0 , 0 , 5 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 <S2SV_ModEnd> <S2SV_ModStart> 0 , 2 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 40 , 0 , 3 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 0 , w , 3 , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 15 , w , 3 , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 35 , w , 2 , PIX_SET , NULL , 0 , 0 ) ; pixaAddPix ( pixa2 , pix1 , L_COPY ) ; pixFillMapHoles ( pix1 , w , h , L_FILL_WHITE ) ; pixaAddPix ( pixa2 , pix1 , L_INSERT ) ; pix2 = pixaDisplayTiledInColumns ( pixa2 , 3 , 1.0 , 20 , 1 ) ; regTestWritePixAndCheck ( rp , pix2 , IFF_PNG <S2SV_ModEnd> <S2SV_ModStart> pix2 , 50 , 850 <S2SV_ModEnd> <S2SV_ModStart> pixaDestroy ( & pixa2 ) ; pixDestroy ( & pix2 ) ; pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ; pixWrite ( ""/tmp/lept/adapt/results.jpg"" , pix1 , IFF_JFIF_JPEG ) ; pixDisplayWithTitle ( pix1 , 50 , 0 , NULL , rp -> display ) ; "
63,"<S2SV_StartBug> strncpy ( str , ""?["" , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> espruino_snprintf ( str , len , ""?[%d]"" , token <S2SV_ModEnd> "
64,"<S2SV_StartBug> static void count_segs ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi = mi_8x8 ; <S2SV_EndBug> <S2SV_StartBug> const BLOCK_SIZE bsize = mi_8x8 [ 0 ] -> mbmi . sb_type ; <S2SV_EndBug> <S2SV_StartBug> const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <S2SV_EndBug> ","<S2SV_ModStart> const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> xd -> mi <S2SV_ModEnd> <S2SV_ModStart> get_segment_id <S2SV_ModEnd> "
65,<S2SV_StartBug> if ( dst == NULL || src == NULL ) return ERROR ; <S2SV_EndBug> ,<S2SV_ModStart> ) return ERROR ; if ( src -> entry_count + dst -> entry_count < src -> entry_count ) return ERROR ; if ( src -> data_count + dst -> data_count < src -> data_count 
66,"
","
"
67,"<S2SV_StartBug> cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) : <S2SV_EndBug> ",<S2SV_ModStart> jas_stream_memopen2 <S2SV_ModEnd> 
68,<S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> dev_kfree_skb ( skb ) ; 
69,<S2SV_StartBug> malloc_called += 1 ; <S2SV_EndBug> ,<S2SV_ModStart> = <S2SV_ModEnd> 
70,"<S2SV_StartBug> StringBuffer_append ( res -> outputbuffer , ""%s"" , buf ) ; <S2SV_EndBug> ",<S2SV_ModStart> escapeHTML ( res -> outputbuffer <S2SV_ModEnd> 
71,<S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug> ,<S2SV_ModStart> 62 <S2SV_ModEnd> 
72,<S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING ) <S2SV_EndBug> <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> 
73,<S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( HAVE_IP ( 6 ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , 0 "
74,<S2SV_StartBug> boolean_t owner = B_FALSE ; <S2SV_EndBug> <S2SV_StartBug> mutex_enter ( & zdp -> z_acl_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> is_attr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
75,"<S2SV_StartBug> if ( ( o2 + 10 < o2 ) || ( o2 + 10 < 10 ) || ( o2 + 10 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( o2 + 4 < o2 ) || ( o2 + 4 < 4 ) || ( o2 + 4 > buf_size ) ) return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( o2 + 12 < o2 ) || ( o2 + 12 < 12 ) || ( o2 + 12 > buf_size ) ) return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( o2 + 2 < o2 ) || ( o2 + 2 < 2 ) || ( o2 + 2 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dataofs + s > buf_size && n -> version == sanyoV1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ","<S2SV_ModStart> CHECKOVERFLOW ( o2 , buf_size , 10 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o2 , buf_size , 4 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o2 , buf_size , 12 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o2 , buf_size , 2 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteOlympus"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_olympus_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; continue ; } <S2SV_ModEnd> <S2SV_ModStart> > ( buf_size - s ) <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteOlympus"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteOlympus"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s <S2SV_ModEnd> "
76,"<S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
77,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> ,<S2SV_ModStart> || stringset == ETH_SS_PRIV_FLAGS 
78,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } 
79,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; } 
80,"<S2SV_StartBug> char sbuf [ 128 ] ; <S2SV_EndBug> <S2SV_StartBug> err = __video_do_ioctl ( file , cmd , parg ) ; <S2SV_EndBug> ","<S2SV_ModStart> return video_usercopy <S2SV_ModEnd> <S2SV_ModStart> arg , __video_do_ioctl ) <S2SV_ModEnd> "
81,"<S2SV_StartBug> 0xD5 , 0x75 , 0xF1 , 0x23 , 0xC1 , 0x81 , 0x4B , 0x44 , 0x23 , 0xBE , <S2SV_EndBug> <S2SV_StartBug> 0xC5 , 0x5F , 0x86 , 0x42 , 0x7F , 0x38 , 0xA3 , 0x95 , 0xEE , 0xA0 , <S2SV_EndBug> ","<S2SV_ModStart> 0xCF , 0x9F , 0x3A , 0x9C , 0xC5 , 0xA5 , 0x89 , 0x27 , 0x6D , 0x2C , 0x2C , 0xF3 , 0xA6 , 0x00 , 0xD2 , 0x7C , 0xEA , 0xFA , 0xF2 , 0x43 , 0x4F , 0x49 , 0x0A , 0xFC , 0xA6 , 0xE7 , 0x75 , 0xCA , 0x07 , 0xDC , 0xA5 , 0xF2 , 0x83 , 0x4E , 0x5A , 0xA0 , 0xA0 , 0xF5 , 0x9C , 0xFD , 0x02 , 0xE6 , 0x9E , 0xFC , 0x01 , 0x59 , 0xD7 , 0xB6 , 0xC1 , 0x4E , 0xC0 , 0xB6 , 0x71 , 0x49 , 0xF0 , 0xC7 , 0xD5 , 0x2F , 0x8D , 0xDF , 0xD3 , 0xF1 , 0x82 , 0x82 , 0x23 , 0x33 , 0x13 , 0x93 , 0xEB , 0x50 , 0x29 , 0xFD , 0x1B , 0x5A , 0x2F , 0xD5 , 0x08 , 0x99 , 0x64 , 0xE9 , 0x7B , 0x1A , 0xDD , 0x68 , 0x16 , 0x08 , 0xD0 , 0x13 , 0x82 , 0xB6 , 0x86 , 0x62 , 0x76 , 0xAA , 0x16 , 0x14 , 0xCC , 0x86 , 0x72 , 0x26 , 0x45 , 0x8E , 0x2A , 0x82 , 0x5B , 0x6F , 0xC1 , 0xDF , 0xAA , 0x18 , 0x43 , 0xB8 , 0xAD , 0x84 , 0x52 , 0xF2 , 0xD9 , 0x9C , 0xC0 , 0x47 , 0x52 , 0x1B , 0x8E , 0x42 , 0xC4 , 0xD3 , 0x61 , 0x7B , 0x65 , 0xA7 , 0x69 , 0x03 , 0xB5 , 0xD4 , 0x6C , 0x83 , 0x6A , 0x46 , 0x73 , 0xAF , 0x76 , 0x77 , 0x70 , 0xC2 , 0xD0 , 0x74 , 0xFE , 0x78 , 0xF5 , 0x75 , 0x3B , 0xCE , 0xE2 , 0xB6 , 0xA0 , 0x25 , 0xE9 , 0xE8 , 0x4B , 0xA2 , 0xF1 , 0x20 , 0x88 , 0x13 , 0x07 , 0xED , 0x66 , 0xBC , 0x46 , 0xA1 , 0xB3 , 0x44 , 0xAF , 0x2C , 0xED , 0x73 , 0x75 , 0x3D , 0x14 , 0x6E , 0x43 , 0x92 , 0x40 , 0x99 , 0xB0 , 0xD1 , 0xBF , 0x2C , 0x4D , 0x0F , 0x2A , 0x63 , 0xF4 , 0x85 , 0x7B , 0x1B , 0x0E , 0x48 , 0x5A , 0x06 , 0x02 , 0xA6 , 0x3D , 0x9E , 0x78 , 0x05 , 0xA8 , 0x7C , 0xAD , 0x54 , 0x49 , 0xDE , 0x7A , 0xE6 , 0x36 , 0x5C , 0x50 , 0xFC , 0x09 <S2SV_ModEnd> <S2SV_ModStart> 0x9E , 0x83 , 0x53 , 0x8C <S2SV_ModEnd> <S2SV_ModStart> 0xEF , 0x12 , 0x36 , 0x4F , 0x22 , 0x16 , 0x2A , 0x15 , 0x88 , 0x83 , 0xA9 , 0x00 , 0x66 , 0x9E , 0xD1 , 0xDC , 0x0F , 0x54 , 0xC0 , 0x32 , 0x5C , 0x4C , 0x5E , 0xE2 , 0x3D , 0xBC , 0x56 , 0x89 , 0x75 , 0x28 , 0xA3 <S2SV_ModEnd> "
82,"<S2SV_StartBug> static char * print_string_ptr ( const char * str ) <S2SV_EndBug> <S2SV_StartBug> char * ptr2 , * out ; <S2SV_EndBug> <S2SV_StartBug> int len = 0 ; <S2SV_EndBug> <S2SV_StartBug> return cJSON_strdup ( """" ) ; <S2SV_EndBug> <S2SV_StartBug> ++ len ; <S2SV_EndBug> <S2SV_StartBug> ++ ptr ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( out = ( char * ) cJSON_malloc ( len + 3 ) ) ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> char * ptr2 , * out ; <S2SV_ModEnd> <S2SV_ModStart> , flag = 0 ; <S2SV_ModEnd> <S2SV_ModStart> { if ( p ) out = ensure ( p , 3 ) ; else out = ( char * ) cJSON_malloc ( 3 ) ; if ( ! out ) return 0 ; strcpy ( out , ""\\""\\"""" ) ; return out ; } for ( ptr = str ; * ptr ; ptr ++ ) flag |= ( ( * ptr > 0 && * ptr < 32 ) || ( * ptr == \'\\""\' ) || ( * ptr == '\\\\' ) ) ? 1 : 0 ; if ( ! flag ) { len = ptr - str ; if ( p ) out = ensure ( p , len + 3 ) ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) return 0 ; ptr2 = out ; * ptr2 ++ = \'\\""\' ; strcpy ( ptr2 , str ) ; ptr2 [ len ] = \'\\""\' ; ptr2 [ len + 1 ] = 0 ; return out ; } ptr = str ; <S2SV_ModEnd> <S2SV_ModStart> len ++ ; <S2SV_ModEnd> <S2SV_ModStart> ptr ++ ; } if ( p ) out = ensure ( p , <S2SV_ModEnd> <S2SV_ModStart> ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) <S2SV_ModEnd> <S2SV_ModStart> break ; } } } * ptr2 ++ = \'\\""\' ; <S2SV_ModEnd> "
83,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE ) <S2SV_EndBug> ",<S2SV_ModStart> && ps_stream -> u4_offset < ps_stream -> u4_max_offset 
84,"<S2SV_StartBug> alloc_limit_assert ( ""checked_xcalloc"" , ( num * size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> "
85,"<S2SV_StartBug> char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int dlen = mutt_b64_decode ( out , it ) ; <S2SV_EndBug> ","<S2SV_ModStart> const int olen = <S2SV_ModEnd> <S2SV_ModStart> ; char * out = mutt_mem_malloc ( olen <S2SV_ModStart> , olen "
86,<S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
87,"<S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
88,<S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> RCU_INIT_POINTER ( mm -> exe_file , NULL ) ; "
89,"<S2SV_StartBug> const int qzbin_factor = q == 0 ? 64 : ( vp9_dc_quant ( q , 0 ) < 148 ? 84 : 80 ) ; <S2SV_EndBug> <S2SV_StartBug> quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q ) <S2SV_EndBug> <S2SV_StartBug> : vp9_ac_quant ( q , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> y_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> <S2SV_StartBug> quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q ) <S2SV_EndBug> <S2SV_StartBug> : vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ; <S2SV_EndBug> <S2SV_StartBug> quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> uv_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> <S2SV_StartBug> quants -> a_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; <S2SV_EndBug> <S2SV_StartBug> cm -> a_dequant [ q ] [ i ] = quant ; <S2SV_EndBug> <S2SV_StartBug> quants -> y_quant_shift [ q ] [ i ] = quants -> y_quant_shift [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> cm -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> ","<S2SV_ModStart> get_qzbin_factor ( q , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> int qrounding_factor_fp = i == 0 ? 48 : 42 ; if ( q == 0 ) qrounding_factor_fp = 64 ; <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> <S2SV_ModStart> quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; cpi <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> uv_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> uv_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> <S2SV_ModStart> quants -> uv_zbin <S2SV_ModEnd> <S2SV_ModStart> uv_round <S2SV_ModEnd> <S2SV_ModStart> cpi -> uv_dequant [ q ] [ i ] = quant ; <S2SV_ModEnd> <S2SV_ModStart> y_quant_fp [ q ] [ i ] = quants -> y_quant_fp [ q ] [ 1 ] ; quants -> y_round_fp [ q ] [ i ] = quants -> y_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> uv_quant_fp [ q ] [ i ] = quants -> uv_quant_fp [ q ] [ 1 ] ; quants -> uv_round_fp [ q ] [ i ] = quants -> uv_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
90,<S2SV_StartBug> static inline int <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
91,<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> ,"<S2SV_ModStart> * buf , * buf2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; <S2SV_ModEnd> <S2SV_ModStart> buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> "
92,"<S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( <S2SV_ModStart> ) <S2SV_ModStart> cache_id ( <S2SV_ModStart> ) <S2SV_ModStart> cache_id ( <S2SV_ModStart> ) 
93,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>method=%s"" , len - 4 , <S2SV_EndBug> <S2SV_StartBug> if ( 1 < ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> <S2SV_StartBug> return ( const u_char * ) ext + len ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" <S2SV_ModEnd> <S2SV_ModStart> len > 4 ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
94,"<S2SV_StartBug> if ( ( doff + s < doff ) || ( doff + s < s ) || ( doff + s > size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff + s , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> doff >= size ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Tag<S2SV_blank>starts<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , doff , size ) ; return 0 ; } if ( <S2SV_ModEnd> <S2SV_ModStart> - doff <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>data<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" <S2SV_ModEnd> "
95,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> p = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
96,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( svc ) ; <S2SV_EndBug> <S2SV_StartBug> const int layer = svc -> temporal_layer_id ; <S2SV_EndBug> <S2SV_StartBug> lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ; <S2SV_EndBug> <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> <S2SV_StartBug> if ( layer == 0 ) { <S2SV_EndBug> <S2SV_StartBug> lc -> avg_frame_size = lrc -> av_per_frame_bandwidth ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> framerate / oxcf -> ts_rate_decimator [ layer - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> ts_target_bitrate [ layer - 1 ] * 1000 ; <S2SV_EndBug> ,<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> st_idx = svc -> spatial_layer_id * svc -> number_temporal_layers + <S2SV_ModEnd> <S2SV_ModStart> const int tl = svc -> temporal_layer_id ; lc -> framerate = cpi <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> layer_target_bitrate [ st_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
97,<S2SV_StartBug> if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) { <S2SV_EndBug> <S2SV_StartBug> rc = ses -> server -> ops -> generate_signingkey ( ses ) ; <S2SV_EndBug> <S2SV_StartBug> goto keygen_exit ; <S2SV_EndBug> <S2SV_StartBug> keygen_exit : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
98,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
99,<S2SV_StartBug> f = po -> fanout ; <S2SV_EndBug> <S2SV_StartBug> if ( ! f ) <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & fanout_mutex ) ; <S2SV_ModStart> f ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & fanout_mutex ) ; } 
100,"<S2SV_StartBug> memcpy ( own_dir , ""."" , 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ; # else <S2SV_ModStart> # endif "
101,<S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( size_left < 4 ) { LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } "
102,"<S2SV_StartBug> dbuf_copy ( c -> infile , pos + 4 , data_len , d -> iccprofile_file ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! d -> iccprofile_file ) { de_warn ( c , ""Bad<S2SV_blank>ICC<S2SV_blank>profile<S2SV_blank>segment"" ) ; return ; } "
103,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
104,"<S2SV_StartBug> int size_chk , err ; <S2SV_EndBug> <S2SV_StartBug> size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( headroom >= chunk_size - XDP_PACKET_HEADROOM <S2SV_ModEnd> 
105,<S2SV_StartBug> int rec ; <S2SV_EndBug> <S2SV_StartBug> int rec_len = file -> record_length ; <S2SV_EndBug> <S2SV_StartBug> for ( rec = 1 ; ; rec ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t rec ; size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> if ( rec > file -> record_count ) { rv = 0 ; break ; } 
106,"<S2SV_StartBug> vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
107,"<S2SV_StartBug> static const char * parse_value ( cJSON * item , const char * value ) <S2SV_EndBug> <S2SV_StartBug> return parse_string ( item , value ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_number ( item , value ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_array ( item , value ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_object ( item , value ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * * ep ) { if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> , ep ) ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> , ep ) ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> , ep ) ; } * ep = value ; <S2SV_ModEnd> "
108,"<S2SV_StartBug> if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> validate_core_offset ( reg ) ) return - EINVAL ; if ( 
109,<S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> 
110,"<S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
111,"<S2SV_StartBug> dbg_hid ( ""%s,<S2SV_blank>size:%d\\n"" , __func__ , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return false ; } "
112,"<S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n"" <S2SV_ModEnd> "
113,"<S2SV_StartBug> int xml_init ( modsec_rec * msr , char * * error_msg ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> xmlParserInputBufferCreateFilenameFunc entity ; <S2SV_ModStart> if ( msr -> txcfg -> xml_external_entity == 0 ) { entity = xmlParserInputBufferCreateFilenameDefault ( xml_unload_external_entity ) ; } 
114,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.data.%d"" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%f<S2SV_blank>%f\\n"" , valx , valy ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
115,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
116,"<S2SV_StartBug> dev_data = pci_get_drvdata ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return pci_write_config_word ( dev , offset , value ) ; <S2SV_EndBug> ","<S2SV_ModStart> u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ; "
117,<S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> ,<S2SV_ModStart> 91 <S2SV_ModEnd> <S2SV_ModStart> 51 <S2SV_ModEnd> 
118,<S2SV_StartBug> # ifdef __linux <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
119,"<S2SV_StartBug> if ( strcmp ( im -> mode , ""1"" ) == 0 && state -> xsize > state -> bytes * 8 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( strcmp ( im -> mode , ""P"" ) == 0 && state -> xsize > state -> bytes ) { <S2SV_EndBug> <S2SV_StartBug> ptr = buf ; <S2SV_EndBug> ","<S2SV_ModStart> ( state -> xsize * state -> bits + 7 ) / 8 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ptr = buf ; for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xC0 ) == 0xC0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3F ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = IMAGING_CODEC_OVERRUN ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
120,<S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
121,"<S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> "
122,"<S2SV_StartBug> strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry1 ) ) , PARAMS_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( params , ""/"" , PARAMS_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( params , gtk_entry_get_text ( GTK_ENTRY ( entry2 ) ) , PARAMS_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> ETH_ASCII_ADDR_LEN <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> IP6_ASCII_ADDR_LEN <S2SV_ModEnd> 
123,"<S2SV_StartBug> if ( poll ( & pfd , 1 , 500 ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( sent = send ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
124,"<S2SV_StartBug> bufobj = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> _PyObject_CallNoArg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
125,<S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart> q -> fq = NULL ; 
126,<S2SV_StartBug> gdImagePtr im ; <S2SV_EndBug> ,"<S2SV_ModStart> check_file ( ""heap_overflow_1.tga"" ) ; check_file ( ""heap_overflow_2.tga"" <S2SV_ModEnd> "
127,<S2SV_StartBug> # if PY_MINOR_VERSION >= 4 <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
128,"<S2SV_StartBug> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; <S2SV_EndBug> <S2SV_StartBug> struct rd_dev_sg_table * sg_table ; <S2SV_EndBug> <S2SV_StartBug> while ( total_sg_needed ) { <S2SV_EndBug> ","<S2SV_ModStart> struct rd_dev_sg_table * sg_table ; u32 <S2SV_ModEnd> <S2SV_ModStart> int rc <S2SV_ModEnd> <S2SV_ModStart> rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; if ( rc ) return rc ; <S2SV_ModEnd> "
129,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , gplot -> title ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , gplot -> xlabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , gplot -> ylabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
130,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
131,"<S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , "
132,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> skb_free_datagram ( sk , skb ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
133,<S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> ,<S2SV_ModStart> return 
134,<S2SV_StartBug> list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ; "
135,<S2SV_StartBug> ld -> bytes_left = ld -> buffer_size - words * 4 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else 
136,"<S2SV_StartBug> profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
137,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
138,"<S2SV_StartBug> sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & sync , 0 , sizeof ( sync ) ) ; "
139,"<S2SV_StartBug> if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || <S2SV_EndBug> <S2SV_StartBug> set_tls_desc ( target , <S2SV_EndBug> ",<S2SV_ModStart> int i ; <S2SV_ModStart> for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ; 
140,"<S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> ",<S2SV_ModStart> 50 <S2SV_ModEnd> 
141,<S2SV_StartBug> ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ; "
142,<S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
143,<S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> put_disk ( disk ) ; 
144,"<S2SV_StartBug> static int getnum ( lua_State * L , const char * * fmt , int df ) { <S2SV_EndBug> <S2SV_StartBug> if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
145,"<S2SV_StartBug> void vp9_choose_segmap_coding_method ( VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> vp9_prob no_pred_tree [ SEG_TREE_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob t_pred_tree [ SEG_TREE_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob t_nopred_prob [ PREDICTION_PROBS ] ; <S2SV_EndBug> <S2SV_StartBug> const int mis = cm -> mi_stride ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_tile_init ( & tile , cm , 0 , tile_col ) ; <S2SV_EndBug> <S2SV_StartBug> mi_row += 8 , mi_ptr += 8 * mis ) { <S2SV_EndBug> <S2SV_StartBug> count_segs_sb ( cpi , & tile , mi , no_pred_segcounts , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , MACROBLOCKD * xd ) { <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> MODE_INFO * * mi_ptr ; <S2SV_ModStart> cm -> mi_stride ) { MODE_INFO * * <S2SV_ModEnd> <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
146,"<S2SV_StartBug> g_return_if_fail ( RS_IS_FILTER ( filter ) ) ; <S2SV_EndBug> <S2SV_StartBug> g_file_set_contents ( ""/tmp/rs-filter-graph"" , str -> str , str -> len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 0 != system ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>/tmp/rs-filter-graph.png<S2SV_blank></tmp/rs-filter-graph"" ) ) <S2SV_EndBug> <S2SV_StartBug> if ( 0 != system ( ""gnome-open<S2SV_blank>/tmp/rs-filter-graph.png"" ) ) <S2SV_EndBug> <S2SV_StartBug> g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; gchar * dot_filename ; gchar * png_filename ; gchar * command_line <S2SV_ModStart> dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ; png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ; g_file_set_contents ( dot_filename <S2SV_ModEnd> <S2SV_ModStart> command_line = g_strdup_printf ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s"" , png_filename , dot_filename ) ; <S2SV_ModStart> command_line <S2SV_ModEnd> <S2SV_ModStart> g_free ( command_line ) ; command_line = g_strdup_printf ( ""gnome-open<S2SV_blank>%s"" , png_filename ) ; <S2SV_ModStart> command_line <S2SV_ModEnd> <S2SV_ModStart> ) ; g_free ( command_line ) ; g_free ( dot_filename ) ; g_free ( png_filename "
147,"<S2SV_StartBug> if ( ( fd = open ( clonedev , O_RDWR ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( err = ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> int flags = fcntl ( fd , F_GETFL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> <S2SV_ModStart> ) 
148,<S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> multi_arf_enabled ) { <S2SV_EndBug> <S2SV_StartBug> arf_idx = ( cpi -> frame_coding_order [ sn ] < 0 ) ? <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> if ( vp9_preserve_existing_gf ( cpi ) ) { <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> oxcf . pass == 2 ) && cpi -> multi_arf_allowed ) { const GF_GROUP * const gf_group = & cpi -> twopass . gf_group <S2SV_ModEnd> <S2SV_ModStart> gf_group -> arf_update_idx [ gf_group -> index <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
149,"<S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
150,<S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL 
151,"<S2SV_StartBug> id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ; <S2SV_EndBug> <S2SV_StartBug> shp -> shm_cprid = task_tgid_vnr ( current ) ; <S2SV_EndBug> ",<S2SV_ModStart> shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <S2SV_ModStart>  <S2SV_ModEnd> 
152,"<S2SV_StartBug> . daddr = ( param -> replyopts . srr ? <S2SV_EndBug> <S2SV_StartBug> param -> replyopts . faddr : iph -> saddr ) , <S2SV_EndBug> ",<S2SV_ModStart> opt . opt . <S2SV_ModStart> . opt . opt 
153,<S2SV_StartBug> bprm -> interp = interp ; <S2SV_EndBug> <S2SV_StartBug> return search_binary_handler ( bprm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> retval = bprm_change_interp ( interp , <S2SV_ModEnd> <S2SV_ModStart> file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ; "
154,"<S2SV_StartBug> sprintf ( addr , ""%d.%d.%d.%d"" , a , b , c , d ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( addr , sizeof ( addr ) <S2SV_ModEnd> "
155,"<S2SV_StartBug> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> ",<S2SV_ModStart> static 
156,"<S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
157,<S2SV_StartBug> hash_param . data = 0 ; <S2SV_EndBug> <S2SV_StartBug> hash_param . len = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> instance -> private_key <S2SV_ModEnd> <S2SV_ModStart> instance -> private_key_len <S2SV_ModEnd> 
158,"<S2SV_StartBug> unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ; "
159,"<S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> 
160,<S2SV_StartBug> # ifndef NETSNMP_NO_WRITE_SUPPORT <S2SV_EndBug> <S2SV_StartBug> # ifndef NETSNMP_NO_WRITE_SUPPORT <S2SV_EndBug> ,<S2SV_ModStart> if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> <S2SV_ModStart> if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> 
161,"<S2SV_StartBug> static struct ip_options * ip_options_get_alloc ( const int optlen ) <S2SV_EndBug> <S2SV_StartBug> return kzalloc ( sizeof ( struct ip_options ) + ( ( optlen + 3 ) & ~ 3 ) , <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> 
162,<S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> cursor <S2SV_ModEnd> 
163,<S2SV_StartBug> local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( args -> nr_local == 0 ) return - EINVAL 
164,<S2SV_StartBug> assert ( plen <= * len ) ; <S2SV_EndBug> ,<S2SV_ModStart> && plen > 0 
165,"<S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) == size_send ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
166,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> ","<S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> "
167,"<S2SV_StartBug> if ( ! capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> unsigned int copylen ; <S2SV_ModStart> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL <S2SV_ModStart> copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; <S2SV_ModStart> copylen <S2SV_ModEnd> 
168,<S2SV_StartBug> if ( tgt_clobbers & ~ site_clobbers ) <S2SV_EndBug> <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> ,"<S2SV_ModStart> len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> "
169,<S2SV_StartBug> if ( o == NULL ) return ; <S2SV_EndBug> ,"<S2SV_ModStart> || checkType ( c , o , OBJ_STREAM ) "
170,"<S2SV_StartBug> CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ; <S2SV_EndBug> <S2SV_StartBug> CHECK_TLV_SIZE ( 4 , ""Organisational"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( addr_str_length > sizeof ( addr_str_buffer ) ) { log_warnx ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } <S2SV_ModStart> 1 + ( int ) sizeof ( orgid ) <S2SV_ModEnd> "
171,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> ","<S2SV_ModStart> result ; int <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0 "
172,<S2SV_StartBug> goto read_error ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
173,"<S2SV_StartBug> cred = rpc_lookup_cred ( ) ; <S2SV_EndBug> <S2SV_StartBug> state = nfs4_do_open ( dir , & path , openflags , NULL , cred ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_intent_set_file ( nd , & path , state ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_close_sync ( & path , state , openflags ) ; <S2SV_EndBug> ","<S2SV_ModStart> fmode_t fmode = openflags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , fmode <S2SV_ModStart> , fmode <S2SV_ModStart> fmode <S2SV_ModEnd> "
174,<S2SV_StartBug> int target = rc -> av_per_frame_bandwidth * kf_ratio ; <S2SV_EndBug> ,<S2SV_ModStart> const <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> 
175,"<S2SV_StartBug> if ( test_bit ( DMF_FREEING , & md -> flags ) || <S2SV_EndBug> <S2SV_StartBug> dm_deleting_md ( md ) ) <S2SV_EndBug> <S2SV_StartBug> dm_get ( md ) ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & _minor_lock ) ; <S2SV_ModStart> { md = NULL ; goto out ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; out : spin_unlock ( & _minor_lock 
176,"<S2SV_StartBug> return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."" "
177,<S2SV_StartBug> if ( group_leader -> ctx -> type != ctx -> type ) <S2SV_EndBug> ,<S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> 
178,<S2SV_StartBug> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <S2SV_EndBug> ,"<S2SV_ModStart> error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ; "
179,"<S2SV_StartBug> MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> int offset = ( mi_row * MI_SIZE ) * yv12 -> y_stride + ( mi_col * MI_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , <S2SV_EndBug> ","<S2SV_ModStart> const struct buf_2d * ref <S2SV_ModEnd> <S2SV_ModStart> unsigned int sse , var ; uint8_t * last_y ; <S2SV_ModStart> last <S2SV_ModEnd> <S2SV_ModStart> assert ( last != NULL ) ; last_y = & last -> y_buffer [ <S2SV_ModEnd> <S2SV_ModStart> * last <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> <S2SV_ModStart> ref -> buf , ref -> stride , last_y , last <S2SV_ModEnd> "
180,"<S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> alloc_limit_assert ( ""checked_xmalloc"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug> ","<S2SV_ModStart> num , size_t <S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> <S2SV_ModStart> num , "
181,<S2SV_StartBug> int m ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; } "
182,<S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug> <S2SV_StartBug> if ( p ++ != pages [ i + j ] ) <S2SV_EndBug> ,<S2SV_ModStart> ++ p <S2SV_ModEnd> <S2SV_ModStart> ++ p <S2SV_ModEnd> 
183,<S2SV_StartBug> hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } 
184,"<S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 
185,<S2SV_StartBug> new -> cid_mask = new -> lid_mask = 0xffff ; <S2SV_EndBug> ,<S2SV_ModStart> ( 1 << KVM_X2APIC_CID_BITS ) - 1 ; 
186,<S2SV_StartBug> if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> in_dev -> dead ) goto no_promotions ; if ( <S2SV_ModStart> no_promotions : 
187,<S2SV_StartBug> SvcInternal * si ; <S2SV_EndBug> <S2SV_StartBug> si = ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> <S2SV_StartBug> free ( si -> buffer ) ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
188,"<S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strlcpy <S2SV_ModEnd> <S2SV_ModStart> sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> <S2SV_ModStart> sizeof ( extra_response -> value ) <S2SV_ModEnd> 
189,"<S2SV_StartBug> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; <S2SV_EndBug> <S2SV_StartBug> struct rd_dev_sg_table * sg_table ; <S2SV_EndBug> <S2SV_StartBug> while ( total_sg_needed ) { <S2SV_EndBug> ","<S2SV_ModStart> struct rd_dev_sg_table * sg_table ; u32 <S2SV_ModEnd> <S2SV_ModStart> int rc <S2SV_ModEnd> <S2SV_ModStart> rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; if ( rc ) return rc ; <S2SV_ModEnd> "
190,<S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> break <S2SV_ModEnd> 
191,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ; "
192,<S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
193,<S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> ref ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart>  <S2SV_ModEnd> 
194,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; fs_logger2 ( ""clone"" , dest <S2SV_ModEnd> "
195,"<S2SV_StartBug> static inline long decode_twos_comp ( ulong c , int prec ) <S2SV_EndBug> ",<S2SV_ModStart> jas_ulong <S2SV_ModEnd> 
196,"<S2SV_StartBug> x -> quantize_b_pair = vp8_fast_quantize_b_pair ; <S2SV_EndBug> <S2SV_StartBug> & distortion , & intra_error ) ; <S2SV_EndBug> <S2SV_StartBug> x -> quantize_b = vp8_regular_quantize_b ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , mb_row , mb_col <S2SV_ModStart>  <S2SV_ModEnd> "
197,<S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
198,<S2SV_StartBug> char lowstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> ,<S2SV_ModStart> MAXDATEFIELDS <S2SV_ModEnd> <S2SV_ModStart> > MAXDATELEN <S2SV_ModEnd> 
199,<S2SV_StartBug> free_uid ( group -> inotify_data . user ) ; <S2SV_EndBug> ,<S2SV_ModStart> atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ; 
200,"<S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug> ","<S2SV_ModStart> , remaining <S2SV_ModStart> remaining <S2SV_ModEnd> <S2SV_ModStart> int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> <S2SV_ModStart> remaining -= 10 ; <S2SV_ModStart> int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> <S2SV_ModStart> remaining -= 12 ; <S2SV_ModStart> if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> <S2SV_ModStart> remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> <S2SV_ModStart> ! remaining ) return 0 ; if ( <S2SV_ModStart> { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> } <S2SV_ModStart> ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9' "
201,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
202,<S2SV_StartBug> if ( ! ( flags | RT6_LOOKUP_F_DST_NOREF ) ) <S2SV_EndBug> ,<S2SV_ModStart> & <S2SV_ModEnd> 
203,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
204,<S2SV_StartBug> pu1_buf = ( UWORD8 * ) ps_codec -> pv_mv_bank_buf_base ; <S2SV_EndBug> ,<S2SV_ModStart> ps_codec -> i4_max_dpb_size = max_dpb_size ; 
205,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> "
206,"<S2SV_StartBug> static int nfs4_open_recover_helper ( struct nfs4_opendata * opendata , mode_t openflags , struct nfs4_state * * res ) <S2SV_EndBug> <S2SV_StartBug> opendata -> o_arg . open_flags = openflags ; <S2SV_EndBug> <S2SV_StartBug> nfs4_close_state ( & opendata -> path , newstate , openflags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> 0 ; opendata -> o_arg . fmode = fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
207,<S2SV_StartBug> # if ( ETH_SUPPORT == ENABLED ) <S2SV_EndBug> ,<S2SV_ModStart> message -> interface = queueItem -> interface ; 
208,<S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! state -> last_str || <S2SV_EndBug> ,<S2SV_ModStart> state -> fmode = 1 ; <S2SV_ModStart>  <S2SV_ModEnd> 
209,"<S2SV_StartBug> if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + len <S2SV_ModStart> + len 
210,<S2SV_StartBug> vstart += verdef -> vd_aux ; <S2SV_EndBug> ,<S2SV_ModStart> int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> 
211,"<S2SV_StartBug> int sec ; <S2SV_EndBug> <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> guint offset = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/"" , <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> pkt_len ; int <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ""%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/"" <S2SV_ModEnd> <S2SV_ModStart> ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE "
212,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> o2nm_unlock_subsystem ( ) ; 
213,"<S2SV_StartBug> memcpy ( new , ours , sizeof ( * new ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ) ; memset ( dte , 0 , sizeof ( * dte "
214,<S2SV_StartBug> if ( ! PPEEK_IS ( ')' ) ) return ONIGERR_INVALID_GROUP_NAME ; <S2SV_EndBug> ,"<S2SV_ModStart> { r = ONIGERR_INVALID_GROUP_NAME ; onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; return r ; } <S2SV_ModEnd> "
215,"<S2SV_StartBug> FRAME_CONTEXT * fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> fc -> intra_inter_prob [ i ] = adapt_prob ( pre_fc -> intra_inter_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> fc -> comp_inter_prob [ i ] = adapt_prob ( pre_fc -> comp_inter_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> fc -> comp_ref_prob [ i ] = adapt_prob ( pre_fc -> comp_ref_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> fc -> single_ref_prob [ i ] [ j ] = adapt_prob ( pre_fc -> single_ref_prob [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_inter_mode_tree , pre_fc -> inter_mode_probs [ i ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_intra_mode_tree , pre_fc -> y_mode_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_intra_mode_tree , pre_fc -> uv_mode_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_partition_tree , pre_fc -> partition_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_switchable_interp_tree , pre_fc -> switchable_interp_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> fc -> tx_probs . p8x8 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p8x8 [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> fc -> tx_probs . p16x16 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> fc -> tx_probs . p32x32 [ i ] [ j ] = adapt_prob ( pre_fc -> tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug> <S2SV_StartBug> fc -> skip_probs [ i ] = adapt_prob ( pre_fc -> skip_probs [ i ] , counts -> skip [ i ] ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs ( <S2SV_ModEnd> 
216,<S2SV_StartBug> struct snd_kcontrol * kctl ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0 
217,"<S2SV_StartBug> void * shared_kaddr ; <S2SV_EndBug> <S2SV_StartBug> struct pvclock_vcpu_time_info * guest_hv_clock ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vcpu -> time_page ) <S2SV_EndBug> <S2SV_StartBug> shared_kaddr = kmap_atomic ( vcpu -> time_page ) ; <S2SV_EndBug> <S2SV_StartBug> pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock , <S2SV_EndBug> <S2SV_StartBug> kunmap_atomic ( shared_kaddr ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pv_time_enabled <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
218,"<S2SV_StartBug> int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> 
219,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_negative ( key <S2SV_ModEnd> 
220,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
221,"<S2SV_StartBug> void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> while ( node && node -> symbol == INTERNAL_NODE ) { <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; } "
222,<S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( <S2SV_ModStart> , sizeof buf ) "
223,<S2SV_StartBug> next_byte : <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> pc - pc_start > 14 ) { goto illegal_op ; } 
224,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else 
225,"<S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; 
226,<S2SV_StartBug> const float factor = 0.5 ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> av_per_frame_bandwidth < factor * number_blocks || <S2SV_EndBug> ,<S2SV_ModStart> 0.25 <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> 
227,"<S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rows , <S2SV_ModEnd> <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> <S2SV_ModStart> rows <S2SV_ModEnd> "
228,"<S2SV_StartBug> char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug> ","<S2SV_ModStart> ""/lxc/lock/var/lib/lxc/"" <S2SV_ModEnd> "
229,"<S2SV_StartBug> result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
230,"<S2SV_StartBug> uint32_t off = offset , tmp , finish ; <S2SV_EndBug> <S2SV_StartBug> finish = fru -> size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> memcpy ( frubuf , rsp -> data + 1 , tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp == 0 && off < finish ) { <S2SV_EndBug> ","<S2SV_ModStart> ; uint32_t tmp ; uint32_t finish ; uint32_t size_left_in_buffer <S2SV_ModEnd> <S2SV_ModStart> memset ( frubuf + fru -> size , 0 , length - fru -> size ) ; <S2SV_ModStart> length = finish - offset ; <S2SV_ModStart> size_left_in_buffer = length ; <S2SV_ModStart> if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) { printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ; return - 1 ; } <S2SV_ModStart> size_left_in_buffer -= tmp ; "
231,<S2SV_StartBug> if ( buffer ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
232,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> peer = NULL ; 
233,<S2SV_StartBug> static uid_t uid_server = 0 ; <S2SV_EndBug> <S2SV_StartBug> uid_server = getuid ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( gid_cluster != 0 && gid_client != 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> uid_client != 0 ) { crm_trace ( ""Giving<S2SV_blank>access<S2SV_blank>to<S2SV_blank>group<S2SV_blank>%u"" , gid_cluster ) ; qb_ipcs_connection_auth_set ( c , - 1 <S2SV_ModEnd> "
234,<S2SV_StartBug> if ( client -> type == USER_CLIENT ) <S2SV_EndBug> ,<S2SV_ModStart> && client -> data . user . fifo 
235,"<S2SV_StartBug> stmt_ty s ; <S2SV_EndBug> <S2SV_StartBug> mod_ty res = NULL ; <S2SV_EndBug> <S2SV_StartBug> res = Module ( stmts , arena ) ; <S2SV_EndBug> <S2SV_StartBug> default : <S2SV_EndBug> ","<S2SV_ModStart> asdl_seq * type_ignores = NULL ; <S2SV_ModStart> ; asdl_seq * argtypes = NULL ; expr_ty ret , arg <S2SV_ModStart> ch = CHILD ( n , NCH ( n ) - 1 ) ; REQ ( ch , ENDMARKER ) ; num = NCH ( ch ) ; type_ignores = _Py_asdl_seq_new ( num , arena ) ; if ( ! type_ignores ) goto out ; for ( i = 0 ; i < num ; i ++ ) { type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ; if ( ! ti ) goto out ; asdl_seq_SET ( type_ignores , i , ti ) ; } <S2SV_ModStart> , type_ignores <S2SV_ModStart> case func_type_input : n = CHILD ( n , 0 ) ; REQ ( n , func_type ) ; if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) { ch = CHILD ( n , 1 ) ; num = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { num ++ ; } } argtypes = _Py_asdl_seq_new ( num , arena ) ; if ( ! argtypes ) goto out ; j = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ; if ( ! arg ) goto out ; asdl_seq_SET ( argtypes , j ++ , arg ) ; } } } else { argtypes = _Py_asdl_seq_new ( 0 , arena ) ; if ( ! argtypes ) goto out ; } ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! ret ) goto out ; res = FunctionType ( argtypes , ret , arena ) ; break ; "
236,"<S2SV_StartBug> uint8_t chipRevision ; <S2SV_EndBug> <S2SV_StartBug> vendorId = ( dm9000ReadReg ( DM9000_REG_VIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_VIDL ) ; <S2SV_EndBug> <S2SV_StartBug> productId = ( dm9000ReadReg ( DM9000_REG_PIDH ) << 8 ) | dm9000ReadReg ( DM9000_REG_PIDL ) ; <S2SV_EndBug> <S2SV_StartBug> chipRevision = dm9000ReadReg ( DM9000_REG_CHIPR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chipRevision != DM9000A_CHIP_REV && chipRevision != DM9000B_CHIP_REV ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_GPR , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_NCR , NCR_RST ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_NCR ) & NCR_RST ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_RST ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadPhyReg ( DM9000_PHY_REG_BMCR ) & BMCR_RST ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>CHIPR<S2SV_blank>=<S2SV_blank>0x%02"" PRIX8 ""\\r\\n"" , chipRevision ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR1<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\r\\n"" , dm9000ReadPhyReg ( DM9000_PHY_REG_PHYIDR1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_INFO ( ""<S2SV_blank><S2SV_blank>PHYIDR2<S2SV_blank>=<S2SV_blank>0x%04"" PRIX16 ""\\r\\n"" , dm9000ReadPhyReg ( DM9000_PHY_REG_PHYIDR2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_NCR , DM9000_LBK_PHY ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WritePhyReg ( DM9000_PHY_REG_BMCR , BMCR_LOOPBACK | BMCR_SPEED_SEL | BMCR_AN_EN | BMCR_DUPLEX_MODE ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_PAR0 + i , interface -> macAddr . b [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MAR0 + i , 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MAR7 , 0x80 ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR ) ; <S2SV_EndBug> ","<S2SV_ModStart> chipRev <S2SV_ModEnd> <S2SV_ModStart> DM9000_VIDH <S2SV_ModEnd> <S2SV_ModStart> DM9000_VIDL <S2SV_ModEnd> <S2SV_ModStart> DM9000_PIDH <S2SV_ModEnd> <S2SV_ModStart> DM9000_PIDL ) ; chipRev <S2SV_ModEnd> <S2SV_ModStart> DM9000_CHIPR <S2SV_ModEnd> <S2SV_ModStart> chipRev != DM9000_CHIPR_REV_A && chipRev != DM9000_CHIPR_REV_B <S2SV_ModEnd> <S2SV_ModStart> DM9000_GPR <S2SV_ModEnd> <S2SV_ModStart> DM9000_NCR , DM9000_NCR_RST <S2SV_ModEnd> <S2SV_ModStart> DM9000_NCR ) & DM9000_NCR_RST <S2SV_ModEnd> <S2SV_ModStart> DM9000_BMCR , DM9000_BMCR_RST <S2SV_ModEnd> <S2SV_ModStart> DM9000_BMCR ) & DM9000_BMCR_RST <S2SV_ModEnd> <S2SV_ModStart> chipRev <S2SV_ModEnd> <S2SV_ModStart> DM9000_PHYIDR1 <S2SV_ModEnd> <S2SV_ModStart> DM9000_PHYIDR2 <S2SV_ModEnd> <S2SV_ModStart> DM9000_NCR , DM9000_NCR_LBK_PHY <S2SV_ModEnd> <S2SV_ModStart> DM9000_BMCR , DM9000_BMCR_LOOPBACK | DM9000_BMCR_SPEED_SEL | DM9000_BMCR_AN_EN | DM9000_BMCR_DUPLEX_MODE <S2SV_ModEnd> <S2SV_ModStart> DM9000_PAR0 <S2SV_ModEnd> <S2SV_ModStart> DM9000_MAR0 <S2SV_ModEnd> <S2SV_ModStart> DM9000_MAR7 <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR , DM9000_IMR_PAR ) ; dm9000WriteReg ( DM9000_NSR , DM9000_NSR_WAKEST | DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ; dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG | DM9000_ISR_UDRUN | DM9000_ISR_ROO | DM9000_ISR_ROS | DM9000_ISR_PT | DM9000_ISR_PR ) ; dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI ) ; dm9000WriteReg ( DM9000_RCR , DM9000_RCR_DIS_LONG | DM9000_RCR_DIS_CRC | DM9000_RCR_RXEN <S2SV_ModEnd> "
237,<S2SV_StartBug> int64_t old_off = s -> off ; <S2SV_EndBug> <S2SV_StartBug> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <S2SV_EndBug> ,<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
238,<S2SV_StartBug> vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ; <S2SV_EndBug> ,<S2SV_ModStart> -> <S2SV_ModEnd> 
239,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horDiff32 ( tif , cp0 , cc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 <S2SV_ModStart> return 1 ; 
240,"<S2SV_StartBug> static void nfs_set_open_stateid_locked ( struct nfs4_state * state , nfs4_stateid * stateid , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags ) { <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
241,<S2SV_StartBug> cf . can_id = 0 ; <S2SV_EndBug> <S2SV_StartBug> * ( u64 * ) ( & cf . data ) = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & cf , 0 , sizeof ( cf ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
242,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> g_free_not_null ( ircconn -> sasl_username ) ; g_free_not_null ( ircconn -> sasl_password ) ; 
243,<S2SV_StartBug> sock -> sk -> sk_uid = iattr -> ia_uid ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( sock -> sk ) <S2SV_ModStart> else err = - ENOENT ; 
244,<S2SV_StartBug> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <S2SV_EndBug> ,<S2SV_ModStart> size_t size = bytes + CHK_OVERHEAD_SIZE ; if ( size < bytes ) { return NULL ; } uint8_t <S2SV_ModEnd> <S2SV_ModStart> uint8_t <S2SV_ModEnd> <S2SV_ModStart> size <S2SV_ModEnd> 
245,"<S2SV_StartBug> if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , <S2SV_EndBug> ","<S2SV_ModStart> rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } if ( "
246,<S2SV_StartBug> return code ; <S2SV_EndBug> ,"<S2SV_ModStart> { * status = ""DECODE_PA_FOR_USER"" ; return code ; } <S2SV_ModEnd> "
247,"<S2SV_StartBug> # line 585 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> case 'O' : goto yy13 ; <S2SV_EndBug> <S2SV_StartBug> case 'R' : goto yy2 ; <S2SV_EndBug> <S2SV_StartBug> case 'S' : goto yy10 ; <S2SV_EndBug> <S2SV_StartBug> case 'a' : goto yy11 ; <S2SV_EndBug> <S2SV_StartBug> case 'b' : goto yy6 ; <S2SV_EndBug> <S2SV_StartBug> case 'd' : goto yy8 ; <S2SV_EndBug> <S2SV_StartBug> case 'i' : goto yy7 ; <S2SV_EndBug> <S2SV_StartBug> case 'r' : goto yy4 ; <S2SV_EndBug> <S2SV_StartBug> case 's' : goto yy9 ; <S2SV_EndBug> <S2SV_StartBug> case '}' : goto yy14 ; <S2SV_EndBug> <S2SV_StartBug> default : goto yy16 ; <S2SV_EndBug> <S2SV_StartBug> # line 962 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 646 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy89 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ';' ) goto yy87 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy83 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy77 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy53 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy46 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy39 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy32 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy25 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == ':' ) goto yy17 ; <S2SV_EndBug> <S2SV_StartBug> yy14 : <S2SV_EndBug> <S2SV_StartBug> # line 956 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 695 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> goto yy20 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych == '+' ) goto yy19 ; <S2SV_EndBug> <S2SV_StartBug> goto yy20 ; <S2SV_EndBug> <S2SV_StartBug> goto yy20 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych >= ';' ) goto yy18 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych != \'""\' ) goto yy18 ; <S2SV_EndBug> <S2SV_StartBug> # line 804 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> if ( * start == 'C' ) { <S2SV_EndBug> <S2SV_StartBug> len2 = len = parse_uiv ( start + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * p = start + 2 ; <S2SV_EndBug> <S2SV_StartBug> # line 878 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( yych <= '9' ) goto yy27 ; <S2SV_EndBug> <S2SV_StartBug> # line 793 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> zend_long elements = parse_iv ( start + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> # line 959 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> if ( yych == '+' ) goto yy40 ; <S2SV_EndBug> <S2SV_StartBug> if ( yych <= '9' ) goto yy41 ; <S2SV_EndBug> <S2SV_StartBug> # line 735 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1292 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 646 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> ZVAL_BOOL ( rval , parse_iv ( start + 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1306 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 640 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> id = parse_iv ( start + 2 ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> * p = YYCURSOR ; <S2SV_EndBug> <S2SV_StartBug> id = parse_iv ( start + 2 ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> zval_ptr_dtor ( rval ) ; <S2SV_EndBug> <S2SV_StartBug> if ( Z_ISREF_P ( rval_ref ) ) { <S2SV_EndBug> <S2SV_StartBug> ZVAL_COPY ( rval , rval_ref ) ; <S2SV_EndBug> <S2SV_StartBug> ZVAL_NEW_REF ( rval_ref , rval_ref ) ; <S2SV_EndBug> <S2SV_StartBug> ZVAL_COPY ( rval , rval_ref ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1412 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> ","<S2SV_ModStart> 576 <S2SV_ModEnd> <S2SV_ModStart> yy4 <S2SV_ModEnd> <S2SV_ModStart> yy6 <S2SV_ModEnd> <S2SV_ModStart> yy7 <S2SV_ModEnd> <S2SV_ModStart> yy8 <S2SV_ModEnd> <S2SV_ModStart> yy9 <S2SV_ModEnd> <S2SV_ModStart> yy10 <S2SV_ModEnd> <S2SV_ModStart> yy11 <S2SV_ModEnd> <S2SV_ModStart> yy13 <S2SV_ModEnd> <S2SV_ModStart> yy14 <S2SV_ModEnd> <S2SV_ModStart> yy15 <S2SV_ModEnd> <S2SV_ModStart> yy2 ; } yy2 : ++ YYCURSOR <S2SV_ModEnd> <S2SV_ModStart> 951 <S2SV_ModEnd> <S2SV_ModStart> 636 <S2SV_ModEnd> <S2SV_ModStart> yy17 <S2SV_ModEnd> <S2SV_ModStart> yy19 <S2SV_ModEnd> <S2SV_ModStart> yy21 <S2SV_ModEnd> <S2SV_ModStart> yy22 <S2SV_ModEnd> <S2SV_ModStart> yy23 <S2SV_ModEnd> <S2SV_ModStart> yy24 <S2SV_ModEnd> <S2SV_ModStart> yy25 <S2SV_ModEnd> <S2SV_ModStart> yy26 <S2SV_ModEnd> <S2SV_ModStart> yy27 <S2SV_ModEnd> <S2SV_ModStart> yy28 <S2SV_ModEnd> <S2SV_ModStart> : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy29 ; goto yy3 ; yy15 <S2SV_ModStart> 945 <S2SV_ModEnd> <S2SV_ModStart> 689 ""ext/standard/var_unserializer.c"" <S2SV_ModEnd> <S2SV_ModStart> yy31 <S2SV_ModEnd> <S2SV_ModStart> yy30 ; yy18 : YYCURSOR = YYMARKER ; goto yy3 ; yy19 : ++ YYCURSOR ; # line 629 ""ext/standard/var_unserializer.re"" { * p = YYCURSOR ; ZVAL_NULL ( rval ) ; return 1 ; } # line 707 ""ext/standard/var_unserializer.c"" yy21 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy33 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy33 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; goto yy18 ; } yy22 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy36 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy37 ; goto yy18 ; yy23 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy39 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy40 ; goto yy18 ; yy24 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '1' ) goto yy42 ; goto yy18 ; yy25 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych <= ',' ) { if ( yych == '+' ) goto yy43 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy44 ; if ( yych <= '.' ) goto yy45 ; goto yy18 ; } } else { if ( yych <= 'I' ) { if ( yych <= '9' ) goto yy46 ; if ( yych <= 'H' ) goto yy18 ; goto yy48 ; } else { if ( yych == 'N' ) goto yy49 ; goto yy18 ; } } yy26 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy50 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy50 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy51 ; goto yy18 ; } yy27 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy53 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy53 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy54 ; goto yy18 ; } yy28 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy56 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy56 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy57 ; goto yy18 ; } yy29 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy59 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy60 ; goto yy18 ; yy30 <S2SV_ModEnd> <S2SV_ModStart> yy31 ; } goto yy18 ; yy31 <S2SV_ModEnd> <S2SV_ModStart> yy31 <S2SV_ModEnd> <S2SV_ModStart> <= ':' ) goto yy62 ; goto yy18 ; yy33 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy34 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; if ( yych == <S2SV_ModEnd> <S2SV_ModStart> yy63 ; goto yy18 ; yy36 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy37 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy37 ; if ( yych <= ':' ) goto yy65 ; goto yy18 ; yy39 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy40 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy40 ; if ( yych <= ':' ) goto yy66 ; goto yy18 ; yy42 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy67 ; goto yy18 ; yy43 : yych = * ++ YYCURSOR ; if ( yych == '.' ) goto yy45 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy46 ; goto yy18 ; yy44 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { <S2SV_ModEnd> <S2SV_ModStart> '.' ) goto yy18 ; } else { if ( yych <= '9' ) goto yy46 ; if ( yych == 'I' ) goto yy48 ; goto yy18 ; } yy45 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy69 ; goto yy18 ; yy46 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ':' ) { if ( yych <= '.' ) { if ( yych <= '-' ) goto yy18 ; goto yy69 ; } else { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy46 ; goto yy18 ; } } else { if ( yych <= 'E' ) { if ( yych <= ';' ) goto yy71 ; if ( yych <= 'D' ) goto yy18 ; goto yy73 ; } else { if ( yych == 'e' ) goto yy73 ; goto yy18 ; } } yy48 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy74 ; goto yy18 ; yy49 : yych = * ++ YYCURSOR ; if ( yych == 'A' ) goto yy75 ; goto yy18 ; yy50 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy51 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy51 ; if ( yych == ';' ) goto yy76 ; goto yy18 ; yy53 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy54 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy54 ; if ( yych <= ':' ) goto yy78 ; goto yy18 ; yy56 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy57 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy57 ; if ( yych == ';' ) goto yy79 ; goto yy18 ; yy59 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy60 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy60 ; if ( yych <= ':' ) goto yy81 ; goto yy18 ; yy62 : yych = * ++ YYCURSOR ; if ( yych == <S2SV_ModStart> yy82 ; goto yy18 ; yy63 : <S2SV_ModEnd> <S2SV_ModStart> 580 ""ext/standard/var_unserializer.re"" { zend_long id ; * p = YYCURSOR <S2SV_ModEnd> <S2SV_ModStart> id = parse_iv <S2SV_ModEnd> <S2SV_ModStart> - 1 ; if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) { return 0 ; } if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) { return 0 ; } if ( Z_ISREF_P ( rval_ref ) ) { ZVAL_COPY ( rval , rval_ref ) ; } else { ZVAL_NEW_REF ( rval_ref , rval_ref ) ; ZVAL_COPY ( rval , rval_ref ) ; } return 1 ; } # line 982 ""ext/standard/var_unserializer.c"" yy65 : yych = * ++ YYCURSOR ; if ( yych == \'""\' ) goto yy84 ; goto yy18 ; yy66 : yych = * ++ YYCURSOR ; if ( yych == '{' ) goto yy86 ; goto yy18 ; yy67 : ++ YYCURSOR ; # line 635 ""ext/standard/var_unserializer.re"" <S2SV_ModEnd> <S2SV_ModStart> YYCURSOR ; ZVAL_BOOL ( rval , parse_iv ( <S2SV_ModStart> ) ) ; return 1 <S2SV_ModEnd> <S2SV_ModStart> 999 ""ext/standard/var_unserializer.c"" yy69 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { <S2SV_ModEnd> <S2SV_ModStart> yy69 ; if ( yych <= ':' ) goto yy18 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy73 ; } else { if ( yych == 'e' ) goto yy73 ; goto yy18 ; } } yy71 : <S2SV_ModEnd> <S2SV_ModStart> 683 ""ext/standard/var_unserializer.re"" { # if SIZEOF_ZEND_LONG == 4 use_double : # endif * p = YYCURSOR ; ZVAL_DOUBLE ( rval , zend_strtod ( ( const char * ) <S2SV_ModEnd> <S2SV_ModStart> , NULL ) ) ; return 1 <S2SV_ModEnd> <S2SV_ModStart> 1028 ""ext/standard/var_unserializer.c"" yy73 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { <S2SV_ModEnd> <S2SV_ModStart> yy88 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy88 <S2SV_ModEnd> <S2SV_ModStart> yy89 ; goto yy18 ; } yy74 : yych = * ++ YYCURSOR ; if ( yych == 'F' ) goto yy91 ; goto yy18 ; yy75 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy91 ; goto yy18 ; yy76 : <S2SV_ModEnd> <S2SV_ModStart> 641 <S2SV_ModEnd> <S2SV_ModStart> 1076 ""ext/standard/var_unserializer.c"" yy78 : yych = * ++ YYCURSOR ; if ( yych == \'""\' ) goto yy92 ; goto yy18 ; yy79 : <S2SV_ModEnd> <S2SV_ModStart> 605 ""ext/standard/var_unserializer.re"" { zend_long id ; <S2SV_ModEnd> <S2SV_ModStart> if ( ! var_hash ) return 0 ; id = <S2SV_ModEnd> <S2SV_ModStart> - 1 ; if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) { return 0 ; } if ( rval_ref == rval ) { return 0 ; } if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) { return 0 ; } ZVAL_COPY ( rval , rval_ref <S2SV_ModStart> 1107 ""ext/standard/var_unserializer.c"" yy81 : yych = * ++ YYCURSOR ; if ( yych == \'""\' ) goto yy94 ; goto yy18 ; yy82 <S2SV_ModEnd> <S2SV_ModStart> 793 ""ext/standard/var_unserializer.re"" { size_t len , len2 , len3 , maxlen ; zend_long elements ; char * str ; zend_string * class_name ; zend_class_entry * ce ; int incomplete_class = 0 ; int custom_object = 0 ; zval user_func ; zval retval ; zval args [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> if ( * start == 'C' ) { custom_object = 1 ; } len2 = len = parse_uiv <S2SV_ModEnd> <S2SV_ModStart> ; maxlen = max - YYCURSOR ; if ( maxlen < len || len == 0 ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ':' ) { * p = YYCURSOR + 1 ; return 0 ; } len3 = strspn ( str , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\"" ) ; if ( len3 != len ) { * p = YYCURSOR + len3 - len ; return 0 ; } class_name = zend_string_init ( str , len , 0 ) ; do { if ( ! unserialize_allowed_class ( class_name , classes ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } BG ( serialize_lock ) ++ ; ce = zend_lookup_class ( class_name ) ; if ( ce ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; return 0 ; } break ; } BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; return 0 ; } if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == '\\0' ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } ZVAL_STRING ( & user_func , PG ( unserialize_callback_func ) ) ; ZVAL_STR_COPY ( & args [ 0 ] , class_name ) ; BG ( serialize_lock ) ++ ; if ( call_user_function_ex ( CG ( function_table ) , NULL , & user_func , & retval , 1 , args , 0 , NULL ) != SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; return 0 ; } php_error_docref ( NULL , E_WARNING , ""defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found"" , Z_STRVAL ( user_func ) ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; break ; } BG ( serialize_lock ) -- ; zval_ptr_dtor ( & retval ) ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; return 0 ; } BG ( serialize_lock ) ++ ; if ( ( ce = zend_lookup_class ( class_name ) ) == NULL ) { php_error_docref ( NULL , E_WARNING , ""Function<S2SV_blank>%s()<S2SV_blank>hasn\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for"" , Z_STRVAL ( user_func ) ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; } BG ( serialize_lock ) -- ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; break ; } while ( 1 ) ; * p = YYCURSOR ; if ( custom_object ) { int ret ; ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ; if ( ret && incomplete_class ) { php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ; } zend_string_release ( class_name ) ; return ret ; } elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; if ( elements < 0 ) { zend_string_release ( class_name ) ; return 0 ; } if ( incomplete_class ) { php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ; } zend_string_release ( class_name ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 1266 ""ext/standard/var_unserializer.c"" yy84 : ++ YYCURSOR ; # line 724 ""ext/standard/var_unserializer.re"" { size_t len , maxlen ; zend_string * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } if ( ( str = unserialize_str ( & YYCURSOR , len , maxlen ) ) == NULL ) { return 0 ; } if ( * ( YYCURSOR ) != \'""\' ) { zend_string_free ( str ) ; * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { efree ( str ) ; * p = YYCURSOR + 1 ; <S2SV_ModEnd> <S2SV_ModStart> YYCURSOR += 2 ; * p = YYCURSOR ; ZVAL_STR ( rval , str <S2SV_ModEnd> <S2SV_ModStart> # line 1303 ""ext/standard/var_unserializer.c"" yy86 : ++ YYCURSOR ; # line 758 ""ext/standard/var_unserializer.re"" { zend_long elements = parse_iv ( start + 2 ) ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; if ( elements < 0 || elements >= HT_MAX_SIZE ) { return 0 ; } array_init_size <S2SV_ModEnd> <S2SV_ModStart> elements ) ; if ( elements ) { zend_hash_real_init ( Z_ARRVAL_P ( rval ) , 0 ) ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_ARRVAL_P ( rval ) , elements , 0 ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 1330 ""ext/standard/var_unserializer.c"" yy88 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy96 ; goto yy18 <S2SV_ModEnd> <S2SV_ModStart> if ( yych <= '-' ) goto yy96 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; } yy89 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy89 ; if ( yych == ';' ) goto yy71 ; goto yy18 ; yy91 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy97 ; goto yy18 ; yy92 : ++ YYCURSOR ; # line 782 ""ext/standard/var_unserializer.re"" { zend_long elements ; if ( ! var_hash ) return 0 ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 || elements >= HT_MAX_SIZE ) { return 0 ; } return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 1366 ""ext/standard/var_unserializer.c"" yy94 : ++ YYCURSOR ; # line 692 ""ext/standard/var_unserializer.re"" { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; ZVAL_STRINGL <S2SV_ModEnd> <S2SV_ModStart> str , len ) ; <S2SV_ModEnd> <S2SV_ModStart> 1401 ""ext/standard/var_unserializer.c"" yy96 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy89 ; goto yy18 ; yy97 : ++ YYCURSOR ; # line 667 ""ext/standard/var_unserializer.re"" { * p = YYCURSOR ; if ( ! strncmp ( ( char * ) start + 2 , ""NAN"" , 3 ) ) { ZVAL_DOUBLE ( rval , php_get_nan ( ) ) ; } else if ( ! strncmp ( ( char * ) start + 2 , ""INF"" , 3 ) ) { ZVAL_DOUBLE ( rval , php_get_inf ( ) ) ; } else if ( ! strncmp ( ( char * ) start + 2 , ""-INF"" , 4 ) ) { ZVAL_DOUBLE ( rval , - php_get_inf ( ) ) ; } else { ZVAL_NULL ( rval ) ; } return 1 ; } # line 1425 ""ext/standard/var_unserializer.c"" } # line 953 ""ext/standard/var_unserializer.re"" return <S2SV_ModEnd> "
248,<S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
249,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> gossip_err ( ""%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error <S2SV_ModEnd> <S2SV_ModStart> ""%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
250,"<S2SV_StartBug> FILE * file = fopen ( dump_file , ""w"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
251,"<S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> current_euid <S2SV_ModEnd> <S2SV_ModStart> in_egroup_p ( root_gid <S2SV_ModEnd> 
252,<S2SV_StartBug> # ifdef KEY_DEBUGGING <S2SV_EndBug> ,<S2SV_ModStart> if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ; 
253,"<S2SV_StartBug> int64_t vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int * returnrate , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> const struct segmentation * seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> int64_t best_tx_rd [ TX_MODES ] ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO best_mbmode = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob comp_mode_p ; <S2SV_EndBug> <S2SV_StartBug> int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ; <S2SV_EndBug> <S2SV_StartBug> int64_t dist_uv [ TX_SIZES ] ; <S2SV_EndBug> <S2SV_StartBug> int skip_uv [ TX_SIZES ] ; <S2SV_EndBug> <S2SV_StartBug> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; <S2SV_EndBug> <S2SV_StartBug> int ref_frame_mask = 0 ; <S2SV_EndBug> <S2SV_StartBug> x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp , <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> best_tx_rd [ i ] = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> * returnrate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_buffer_inter ( cpi , x , tile , <S2SV_EndBug> <S2SV_StartBug> frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> for ( mode_index = 0 ; mode_index < MAX_REFS ; ++ mode_index ) { <S2SV_EndBug> <S2SV_StartBug> int64_t tx_cache [ TX_MODES ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> second_ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mode_index > 2 && cpi -> sf . mode_skip_start < MAX_MODES ) { <S2SV_EndBug> <S2SV_StartBug> if ( mode_index == 3 ) { <S2SV_EndBug> <S2SV_StartBug> switch ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] ) { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask = 0 ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask = 0x0010 ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask = 0x0008 ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask = 0x0000 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( mode_skip_mask & ( 1 << mode_index ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ( ( int64_t ) cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] * <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_thresh_freq_sub8x8 [ bsize ] [ mode_index ] >> 5 ) ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( second_ref_frame > INTRA_FRAME ) && <S2SV_EndBug> <S2SV_StartBug> mbmi -> ref_frame [ 0 ] = ref_frame ; <S2SV_EndBug> <S2SV_StartBug> comp_pred = second_ref_frame > INTRA_FRAME ; <S2SV_EndBug> <S2SV_StartBug> set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( comp_pred ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && <S2SV_EndBug> <S2SV_StartBug> mbmi -> tx_size = TX_4X4 ; <S2SV_EndBug> <S2SV_StartBug> if ( rate_uv_intra [ TX_4X4 ] == INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> choose_intra_uv_mode ( cpi , ctx , bsize , TX_4X4 , <S2SV_EndBug> <S2SV_StartBug> & rate_uv_intra [ TX_4X4 ] , <S2SV_EndBug> <S2SV_StartBug> & rate_uv_tokenonly [ TX_4X4 ] , <S2SV_EndBug> <S2SV_StartBug> & dist_uv [ TX_4X4 ] , & skip_uv [ TX_4X4 ] , <S2SV_EndBug> <S2SV_StartBug> & mode_uv [ TX_4X4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> rate2 += rate_uv_intra [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> rate_uv = rate_uv_tokenonly [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> distortion2 += dist_uv [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> distortion_uv = dist_uv [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> uv_mode = mode_uv [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_LAST ] : <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_ALTR ] ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_GOLD ] : this_rd_thresh ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> cpi -> sf . disable_filter_search_var_thresh ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . adaptive_pred_interp_filter == 1 && <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . adaptive_pred_interp_filter == 2 ) { <S2SV_EndBug> <S2SV_StartBug> mbmi -> interp_filter = switchable_filter_index ; <S2SV_EndBug> <S2SV_StartBug> tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile , <S2SV_EndBug> <S2SV_StartBug> rs = vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ switchable_filter_index ] = tmp_rd ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = <S2SV_EndBug> <S2SV_StartBug> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , <S2SV_EndBug> <S2SV_StartBug> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , tmp_rd ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> sf . use_rd_breakout && <S2SV_EndBug> <S2SV_StartBug> tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile , <S2SV_EndBug> <S2SV_StartBug> rate2 += vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> super_block_uvrd ( cpi , x , & rate_uv , & distortion_uv , & uv_skippable , <S2SV_EndBug> <S2SV_StartBug> & uv_sse , BLOCK_8X8 , tmp_best_rdu ) ; <S2SV_EndBug> <S2SV_StartBug> tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; <S2SV_EndBug> <S2SV_StartBug> const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id , <S2SV_EndBug> <S2SV_StartBug> } else if ( mb_skip_allowed ) { <S2SV_EndBug> <S2SV_StartBug> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; <S2SV_EndBug> <S2SV_StartBug> best_mode_index = mode_index ; <S2SV_EndBug> <S2SV_StartBug> * returnrate = rate2 ; <S2SV_EndBug> <S2SV_StartBug> * returndistortion = distortion2 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> select_txfm_size ) <S2SV_EndBug> <S2SV_StartBug> swap_block_ptr ( x , ctx , max_plane ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] , <S2SV_EndBug> <S2SV_StartBug> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> sf . mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && <S2SV_EndBug> <S2SV_StartBug> ( mode_index > MIN_EARLY_TERM_INDEX ) ) { <S2SV_EndBug> <S2SV_StartBug> const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int scale = 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( second_ref_frame <= INTRA_FRAME && <S2SV_EndBug> <S2SV_StartBug> single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( second_ref_frame > INTRA_FRAME && <S2SV_EndBug> <S2SV_StartBug> single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ? <S2SV_EndBug> <S2SV_StartBug> else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> adj_rd = cpi -> mask_filter_rd - ref + 10 ; <S2SV_EndBug> <S2SV_StartBug> adj_rd = cpi -> rd_filter_cache [ i ] - ref ; <S2SV_EndBug> <S2SV_StartBug> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rd >= best_rd_so_far ) <S2SV_EndBug> <S2SV_StartBug> if ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> TX_SIZE uv_tx_size ; <S2SV_EndBug> <S2SV_StartBug> uv_tx_size = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] , <S2SV_EndBug> <S2SV_StartBug> & rate_uv_tokenonly [ uv_tx_size ] , <S2SV_EndBug> <S2SV_StartBug> & dist_uv [ uv_tx_size ] , <S2SV_EndBug> <S2SV_StartBug> & skip_uv [ uv_tx_size ] , <S2SV_EndBug> <S2SV_StartBug> BLOCK_8X8 , uv_tx_size ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rd == INT64_MAX && bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> * returndistortion = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> return best_rd ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_rd_thresh ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip ) { <S2SV_EndBug> <S2SV_StartBug> store_coding_context ( x , ctx , best_mode_index , <S2SV_EndBug> <S2SV_StartBug> best_pred_diff , best_tx_diff , best_filter_diff ) ; <S2SV_EndBug> ","<S2SV_ModStart> void <S2SV_ModEnd> <S2SV_ModStart> TileDataEnc * tile_data , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; RD_OPT * const rd_opt = & cpi -> rd ; SPEED_FEATURES * const sf = & cpi -> sf <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; int ref_index , best_ref_index <S2SV_ModEnd> <S2SV_ModStart> vpx_prob comp_mode_p <S2SV_ModEnd> <S2SV_ModStart> , rate_uv_tokenonly <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; PREDICTION_MODE mode_uv = DC_PRED ; const <S2SV_ModEnd> <S2SV_ModStart> vp9_get_intra_cost_penalty ( <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> ref_frame_skip_mask [ 2 ] = { 0 } ; int64_t mask_filter = 0 ; int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ; int internal_active_edge = vp9_active_edge_sb ( cpi , mi_row , mi_col ) && vp9_internal_image_edge ( cpi ) <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> ; vp9_zero ( best_mbmode ) ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_cache [ i ] = INT64_MAX <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> SWITCHABLE_FILTER_CONTEXTS <S2SV_ModEnd> <S2SV_ModStart> best_filter_rd <S2SV_ModEnd> <S2SV_ModStart> rate_uv_intra <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> setup_buffer_inter <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else { ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; } frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; <S2SV_ModEnd> <S2SV_ModStart> ref_index = 0 ; ref_index <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart> best_mbmode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << GOLDEN_FRAME ) | ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << LAST_FRAME ) | ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << GOLDEN_FRAME ) | ( 1 << LAST_FRAME ) <S2SV_ModEnd> <S2SV_ModStart> break ; } } } if ( ( ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frame ) ) && ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! internal_active_edge && rd_less_than_thresh ( best_rd , rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart> ref_index ] , tile_data -> thresh_freq_fact <S2SV_ModEnd> <S2SV_ModStart> ref_index ] ) <S2SV_ModEnd> <S2SV_ModStart> comp_pred = <S2SV_ModEnd> <S2SV_ModStart> ; if ( comp_pred ) { if ( ! cpi -> allow_comp_inter_inter ) continue ; if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ; if ( ( sf -> mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && best_mbmode . <S2SV_ModEnd> <S2SV_ModStart> == INTRA_FRAME ) continue ; } if ( ref_frame > INTRA_FRAME && vp9_is_scaled ( & cm -> frame_refs [ ref_frame - 1 ] . sf ) ) continue ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( comp_pred ) mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ; else if ( ref_frame != INTRA_FRAME ) mode_excluded = cm -> reference_mode == COMPOUND_REFERENCE ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { continue ; } else if ( ! segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) continue ; } mbmi -> tx_size = TX_4X4 ; mbmi -> uv_mode = DC_PRED ; mbmi -> ref_frame [ 0 ] = ref_frame ; mbmi -> ref_frame [ 1 ] = second_ref_frame <S2SV_ModEnd> <S2SV_ModStart> x -> skip = 0 ; set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> x , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart> rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart> rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> MB_MODE_INFO_EXT * mbmi_ext = x -> mbmi_ext ; <S2SV_ModStart> rd_pick_best_sub8x8_mode <S2SV_ModEnd> <S2SV_ModStart> & mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> cpi , xd <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> mask_filter <S2SV_ModEnd> <S2SV_ModStart> mask_filter <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> rd_pick_best_sub8x8_mode <S2SV_ModEnd> <S2SV_ModStart> & x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> cpi , xd <S2SV_ModEnd> <S2SV_ModStart> memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; if ( ! <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> best_ref_index = ref_index <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> dist = distortion2 ; rd_cost -> rdcost = this_rd <S2SV_ModEnd> <S2SV_ModStart> select_tx_size <S2SV_ModEnd> <S2SV_ModStart> 1 , 0 , 0 , <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> TX_4X4 <S2SV_ModEnd> <S2SV_ModStart> ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> ref_index <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { qstep >>= ( xd -> bd - 8 ) ; } # endif <S2SV_ModStart> ! comp_pred <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> comp_pred <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> mask_filter <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { rd_cost -> rate = INT_MAX ; rd_cost -> rdcost = INT64_MAX ; return ; } if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> best_mbmode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> TX_4X4 <S2SV_ModEnd> <S2SV_ModStart> ) { rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> dist <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> rdcost = INT64_MAX ; return <S2SV_ModEnd> <S2SV_ModStart> vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , sf -> adaptive_rd_thresh , bsize , best_ref_index ) ; <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> best_ref_index <S2SV_ModEnd> <S2SV_ModStart> best_filter_diff , 0 ) <S2SV_ModEnd> "
254,<S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> the_url <S2SV_ModEnd> 
255,<S2SV_StartBug> if ( vma ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
256,<S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> x = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> y = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } else { x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } else { y = <S2SV_ModStart> } 
257,<S2SV_StartBug> L -> oldpc = pc + 1 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
258,"<S2SV_StartBug> int64_t off = s -> off ; <S2SV_EndBug> <S2SV_StartBug> ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
259,"<S2SV_StartBug> uint_fast32_t rawsize ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_create0 ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> inmem_ = true ; <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , <S2SV_EndBug> <S2SV_StartBug> ++ cmptparm ) { <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> ++ image -> numcmpts_ ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> image = 0 ; JAS_DBGLOG ( 100 , ( ""jas_image_create(%d,<S2SV_blank>%p,<S2SV_blank>%d)\\n"" , numcmpts , cmptparms , clrspc ) ) ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> # if 0 <S2SV_ModStart> # endif <S2SV_ModStart> if ( ! jas_safe_size_mul3 ( cmptparm -> width , cmptparm -> height , ( cmptparm -> prec + 7 ) , & rawsize ) ) { goto error ; } rawsize /= 8 ; inmem = ( rawsize < JAS_IMAGE_INMEMTHRESH ) ; <S2SV_ModStart> goto error ; } ++ image -> numcmpts_ ; } jas_image_setbbox ( image ) ; return image ; error : if ( image ) { <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> "
260,<S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ,<S2SV_ModStart> ; cmap -> ents = 0 
261,<S2SV_StartBug> if ( client -> priv -> protocol_timeout > 0 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
262,<S2SV_StartBug> VP9_COMMON * const cm = & ctx -> pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> cm -> new_fb_idx = - 1 ; <S2SV_EndBug> <S2SV_StartBug> cm -> get_fb_cb = ctx -> get_ext_fb_cb ; <S2SV_EndBug> <S2SV_StartBug> cm -> release_fb_cb = ctx -> release_ext_fb_cb ; <S2SV_EndBug> <S2SV_StartBug> cm -> cb_priv = ctx -> ext_priv ; <S2SV_EndBug> <S2SV_StartBug> cm -> get_fb_cb = vp9_get_frame_buffer ; <S2SV_EndBug> <S2SV_StartBug> cm -> release_fb_cb = vp9_release_frame_buffer ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_alloc_internal_frame_buffers ( & cm -> int_frame_buffers ) ) <S2SV_EndBug> <S2SV_StartBug> cm -> cb_priv = & cm -> int_frame_buffers ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> BufferPool * const pool = cm -> buffer_pool ; <S2SV_ModStart> INVALID_IDX ; cm -> byte_alignment = ctx -> byte_alignment ; cm -> skip_loop_filter = ctx -> skip_loop_filter <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> pool <S2SV_ModEnd> <S2SV_ModStart> } 
263,"<S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug> ","<S2SV_ModStart> int newLen , <S2SV_ModStart> int udfLen , <S2SV_ModEnd> <S2SV_ModStart> newLen <S2SV_ModEnd> <S2SV_ModStart> newLen - CRC_LEN <S2SV_ModEnd> <S2SV_ModStart> newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> "
264,<S2SV_StartBug> hw_init ( LOW_FREQUENCY ) ; <S2SV_EndBug> <S2SV_StartBug> # if BOOT_TO_DFU <S2SV_EndBug> ,<S2SV_ModStart> # if BOOT_TO_DFU flash_option_bytes_init ( 1 ) ; # else flash_option_bytes_init ( 0 ) ; # endif <S2SV_ModStart>  <S2SV_ModEnd> 
265,"<S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> ",<S2SV_ModStart> inode_dio_wait ( inode ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
266,"<S2SV_StartBug> static void sas_destruct_devices ( struct work_struct * work ) <S2SV_EndBug> <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> asd_sas_port * port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
267,"<S2SV_StartBug> while ( ! EOFBlob ( image ) ) <S2SV_EndBug> <S2SV_StartBug> if ( filepos != ( unsigned int ) filepos ) <S2SV_EndBug> <S2SV_StartBug> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> filepos < GetBlobSize ( image ) && <S2SV_ModStart> > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" "
268,"<S2SV_StartBug> char * fmtname ; <S2SV_EndBug> <S2SV_StartBug> while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> case OPT_INFILE : <S2SV_EndBug> <S2SV_StartBug> if ( infile ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ; int debug <S2SV_ModStart> debug = 0 ; <S2SV_ModStart> OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> jas_setdbglevel ( debug ) ; <S2SV_ModStart> jas_stream_close ( instream ) ; 
269,<S2SV_StartBug> ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ; <S2SV_EndBug> ,"<S2SV_ModStart> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ; ps_codec -> "
270,<S2SV_StartBug> nfca_poll -> rats_res_len = * data ++ ; <S2SV_EndBug> <S2SV_StartBug> nfcb_poll -> attrib_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , 20 ) <S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , 50 ) "
271,<S2SV_StartBug> p = find_eoq ( cmd + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> cmd [ 0 ] ? <S2SV_ModStart> : NULL 
272,<S2SV_StartBug> struct hns_roce_ib_alloc_ucontext_resp resp ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
273,"<S2SV_StartBug> int retval = 0 ; <S2SV_EndBug> <S2SV_StartBug> retval = - ENODEV ; <S2SV_EndBug> <S2SV_StartBug> bytes_read = snprintf ( in_buffer , 20 , ""%lld\\n"" , dev -> bbu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * ppos < bytes_read ) { <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ","<S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> "
274,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> "
275,"<S2SV_StartBug> int16_t vp9_dc_quant ( int qindex , int delta ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> <S2SV_ModStart> case VPX_BITS_10 : return dc_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return dc_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1 ; } # else ( void ) bit_depth ; return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif "
276,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> else { matvar -> name [ tmp - 1 ] = '\\0' ; } 
277,"<S2SV_StartBug> err = aead_register_instance ( tmpl , inst ) ; <S2SV_EndBug> ",<S2SV_ModStart> inst -> free = pcrypt_free ; 
278,<S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && addr >= shmlba 
279,"<S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ","<S2SV_ModStart> count = <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" <S2SV_ModStart> if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
280,<S2SV_StartBug> STREAM out ; <S2SV_EndBug> ,"<S2SV_ModStart> struct stream packet = * in ; if ( ! s_check_rem ( in , 4 ) ) { rdp_protocol_error ( ""rdpsnd_process_training(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>training<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
281,"<S2SV_StartBug> dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL "
282,<S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int64_t critical_level = oxcf -> optimal_buffer_level >> 2 ; <S2SV_EndBug> <S2SV_StartBug> int active_worst_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> current_video_frame > 1 ) <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ INTER_FRAME ] * 5 / 4 ) ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ KEY_FRAME ] * 3 / 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ( int ) ( ( rc -> worst_quality - rc -> avg_frame_qindex [ INTER_FRAME ] ) * <S2SV_EndBug> <S2SV_StartBug> ( oxcf -> optimal_buffer_level - rc -> buffer_level ) / <S2SV_EndBug> ,"<S2SV_ModStart> RATE_CONTROL * rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> ; int ambient_qp ; unsigned int num_frames_weight_key = 5 * cpi -> svc . number_temporal_layers <S2SV_ModStart> ambient_qp = <S2SV_ModEnd> <S2SV_ModStart> < num_frames_weight_key ) ? MIN ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) : <S2SV_ModEnd> <S2SV_ModStart> ; active_worst_quality = MIN ( rc -> worst_quality , ambient_qp * 5 / 4 ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> > rc -> optimal_buffer_level ) { int max_adjustment_down = active_worst_quality / 3 ; if ( max_adjustment_down ) { buff_lvl_step = ( ( rc -> maximum_buffer_size - rc -> optimal_buffer_level ) / max_adjustment_down ) ; if ( buff_lvl_step ) adjustment = ( int ) ( ( rc -> buffer_level - rc -> optimal_buffer_level ) / buff_lvl_step ) ; active_worst_quality -= adjustment ; } } else if ( rc -> buffer_level > critical_level ) { if ( critical_level ) { buff_lvl_step = ( rc -> optimal_buffer_level - critical_level ) ; if ( buff_lvl_step ) { adjustment = ( int ) ( ( rc -> worst_quality - ambient_qp ) * ( rc -> optimal_buffer_level - rc -> buffer_level ) / buff_lvl_step ) ; } active_worst_quality = ambient_qp <S2SV_ModEnd> "
283,<S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> g_try_malloc0 <S2SV_ModEnd> 
284,<S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> if ( ! pcu -> data_intf ) return - EINVAL ; 
285,"<S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp [ hlen ] & 0xf0 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""K"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * mh , hlen + 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> <S2SV_ModStart> bp [ hlen ] , <S2SV_ModEnd> "
286,"<S2SV_StartBug> Convert_art ( & dls , & defaultArt , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> dls . artCount = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> if ( dls . pDLS ) { <S2SV_ModStart> } 
287,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>n<S2SV_blank>len=%d"" , ntohs ( e . len ) - 4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) ) <S2SV_EndBug> <S2SV_StartBug> return ( const u_char * ) ext + ntohs ( e . len ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>n<S2SV_blank>len=%u"" <S2SV_ModEnd> <S2SV_ModStart> ntohs ( e . len ) > 4 ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> > 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
288,"<S2SV_StartBug> strcpy ( plugin_name , argv [ i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( argv [ i ] ) + 4 + 1 > FN_REFLEN ) { fprintf ( stderr , ""ERROR:<S2SV_blank>argument<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" ) ; return 1 ; } "
289,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
290,"<S2SV_StartBug> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) <S2SV_EndBug> <S2SV_StartBug> __wait_discard_cmd ( sbi , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> , bool umount <S2SV_ModStart> ! umount <S2SV_ModEnd> "
291,<S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
292,<S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> ,"<S2SV_ModStart> raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ; "
293,<S2SV_StartBug> if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_EndBug> <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> entry -> policy == NULL <S2SV_ModEnd> <S2SV_ModStart> KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & <S2SV_ModStart>  <S2SV_ModEnd> 
294,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_err ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
295,"<S2SV_StartBug> static void read_tx_mode_probs ( struct tx_probs * tx_probs , vp9_reader * r ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> 
296,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
297,<S2SV_StartBug> if ( length == SIZE_MAX ) { <S2SV_EndBug> ,<S2SV_ModStart> || length > INT_MAX 
298,"<S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ; "
299,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } 
300,<S2SV_StartBug> if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR && <S2SV_EndBug> ,<S2SV_ModStart> is_nmi ( exit_intr_info <S2SV_ModEnd> 
301,<S2SV_StartBug> tok -> err = json_tokener_success ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; } 
302,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> "
303,<S2SV_StartBug> hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <S2SV_EndBug> ,<S2SV_ModStart> + ( hwc -> idx - X86_PMC_IDX_FIXED ) 
304,<S2SV_StartBug> static off_t ivf_header_pos = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> ebml . debug ) <S2SV_EndBug> <S2SV_StartBug> off_t currpos = ftello ( stream -> file ) ; <S2SV_EndBug> <S2SV_StartBug> case VPX_CODEC_PSNR_PKT : <S2SV_EndBug> ,"<S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const int64_t <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS case VPX_CODEC_FPMB_STATS_PKT : stats_write ( & stream -> fpmb_stats , pkt -> data . firstpass_mb_stats . buf , pkt -> data . firstpass_mb_stats . sz ) ; stream -> nbytes += pkt -> data . raw . sz ; break ; # endif "
305,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
306,"<S2SV_StartBug> struct snd_ctl_elem_id id ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> ",<S2SV_ModStart> ; unsigned int count <S2SV_ModStart> count = kcontrol -> count ; <S2SV_ModStart>  <S2SV_ModEnd> 
307,<S2SV_StartBug> Proto * p = clLvalue ( s2v ( ci -> func ) ) -> p ; <S2SV_EndBug> <S2SV_StartBug> if ( isLua ( ci -> previous ) ) <S2SV_EndBug> <S2SV_StartBug> L -> oldpc = ci -> previous -> u . l . savedpc ; <S2SV_EndBug> ,"<S2SV_ModStart> ci_func ( ci <S2SV_ModEnd> <S2SV_ModStart> = ci <S2SV_ModStart> pcRel ( ci <S2SV_ModEnd> <S2SV_ModStart> , ci_func ( ci ) -> p ) "
308,"<S2SV_StartBug> if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) { <S2SV_EndBug> <S2SV_StartBug> ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%"" PRIsize , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> || ( total_length > BT_SHB_INSANE_MAX ) <S2SV_ModStart> ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%"" PRIsize ""<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)"" <S2SV_ModEnd> <S2SV_ModStart> , total_length , BT_SHB_INSANE_MAX <S2SV_ModEnd> "
309,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ",<S2SV_ModStart> int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> rc = <S2SV_ModStart> rc <S2SV_ModEnd> 
310,"<S2SV_StartBug> CRM_LOG_ASSERT ( client_obj -> request_id ) ; <S2SV_EndBug> <S2SV_StartBug> rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( client_obj -> ipc ) { <S2SV_ModStart> } else { crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ; } "
311,"<S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> alloc_limit_assert ( ""checked_xmalloc"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug> ","<S2SV_ModStart> num , size_t <S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> <S2SV_ModStart> num , "
312,"<S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , int ctr_id , <S2SV_EndBug> <S2SV_StartBug> ( cfg -> rc_end_usage == VPX_CBR || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
313,<S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> ,<S2SV_ModStart> && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE 
314,"<S2SV_StartBug> dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
315,"<S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( box -> len == 1 ) { <S2SV_EndBug> ","<S2SV_ModStart> jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>"" ""type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%"" PRIuFAST32 ""\\n"" <S2SV_ModEnd> <S2SV_ModStart> JAS_DBGLOG ( 10 , ( ""big<S2SV_blank>length\\n"" ) ) ; "
316,<S2SV_StartBug> state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fstrndup <S2SV_ModEnd> <S2SV_ModStart> , len "
317,"<S2SV_StartBug> if ( ! test_bit ( HCI_UP , & hdev -> flags ) ) <S2SV_EndBug> <S2SV_StartBug> return - ENETDOWN ; <S2SV_EndBug> <S2SV_StartBug> hci_req_sync_unlock ( hdev ) ; <S2SV_EndBug> ",<S2SV_ModStart> hci_req_sync_lock ( hdev ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else ret = - ENETDOWN ; 
318,<S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_crop_width = img -> d_w ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> uv_height = yv12 -> y_height / 2 ; <S2SV_EndBug> ,<S2SV_ModStart> const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> y_w ; yv12 -> y_crop_height = y_h ; yv12 -> y_width = y_w ; yv12 -> y_height = y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h ; yv12 -> uv_width = uv_w ; yv12 -> uv_height = uv_h ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
319,<S2SV_StartBug> void * buffer ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL 
320,<S2SV_StartBug> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <S2SV_EndBug> ,<S2SV_ModStart> || num >= 256 
321,"
","
"
322,<S2SV_StartBug> state = vterm_state_new ( vt ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( state == NULL ) return NULL 
323,"<S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug> ","<S2SV_ModStart> int profile , level ; <S2SV_ModStart> , & profile , & level ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n"" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; "
324,"<S2SV_StartBug> const uint8_t * end , * ptr = avpkt -> data ; <S2SV_EndBug> <S2SV_StartBug> end = avpkt -> data + avpkt -> size ; <S2SV_EndBug> <S2SV_StartBug> while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 ) <S2SV_EndBug> <S2SV_StartBug> size *= 94 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ncolors ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < avctx -> width ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> <S2SV_ModStart> end - ptr > 9 && <S2SV_ModStart> ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> <S2SV_ModStart> 95 <S2SV_ModEnd> <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> end - ptr < cpp <S2SV_ModEnd> <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> end - ptr < cpp <S2SV_ModEnd> "
325,"<S2SV_StartBug> static struct nfs4_state * nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred ) <S2SV_EndBug> <S2SV_StartBug> status = _nfs4_do_open ( dir , path , flags , sattr , cred , & res ) ; <S2SV_EndBug> ","<S2SV_ModStart> , fmode_t fmode <S2SV_ModStart> , fmode "
326,"<S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> ",<S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false <S2SV_ModStart> false 
327,<S2SV_StartBug> iris_info . dimension = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" "
328,<S2SV_StartBug> bprm -> interp = interp ; <S2SV_EndBug> <S2SV_StartBug> return search_binary_handler ( bprm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> retval = bprm_change_interp ( interp , <S2SV_ModEnd> <S2SV_ModStart> file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ; "
329,<S2SV_StartBug> INIT_LIST_HEAD ( & f -> f_u . fu_list ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
330,<S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 2 ; <S2SV_EndBug> ,<S2SV_ModStart> ; ps_dec -> u1_first_pb_nal_in_pic = 1 
331,"<S2SV_StartBug> ( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> ",<S2SV_ModStart> - 1 
332,<S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
333,<S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> established = 1 ; kgctx . 
334,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
335,<S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> 
336,<S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug> ,"<S2SV_ModStart> ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if ( "
337,<S2SV_StartBug> if ( ! rc -> source_alt_ref_pending ) <S2SV_EndBug> <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } 
338,"<S2SV_StartBug> static void kiocb_batch_free ( struct kiocb_batch * batch ) <S2SV_EndBug> <S2SV_StartBug> struct kiocb * req , * n ; <S2SV_EndBug> <S2SV_StartBug> kmem_cache_free ( kiocb_cachep , req ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct kioctx * ctx , <S2SV_ModStart> ; if ( list_empty ( & batch -> head ) ) return ; spin_lock_irq ( & ctx -> ctx_lock ) <S2SV_ModStart> list_del ( & req -> ki_list ) ; <S2SV_ModStart> ctx -> reqs_active -- ; } spin_unlock_irq ( & ctx -> ctx_lock ) ; <S2SV_ModEnd> "
339,<S2SV_StartBug> sax -> sax25_family = AF_NETROM ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( sax , 0 , sizeof ( sax ) ) ; "
340,"<S2SV_StartBug> size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> "
341,<S2SV_StartBug> uchar * dp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
342,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
343,<S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> ,<S2SV_ModStart> u64 <S2SV_ModEnd> 
344,<S2SV_StartBug> char * buf ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! s_check ( s ) ) { rdp_protocol_error ( ""rdpsnddbg_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , s ) ; } "
345,<S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> ,<S2SV_ModStart> RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case 
346,"<S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> ","<S2SV_ModStart> images ) { const Image * next ; <S2SV_ModEnd> <S2SV_ModStart> columns , <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> columns , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
347,"<S2SV_StartBug> int vp9_decode_frame ( VP9Decoder * pbi , <S2SV_EndBug> <S2SV_StartBug> const size_t first_partition_size = read_uncompressed_header ( pbi , & rb ) ; <S2SV_EndBug> <S2SV_StartBug> * p_data_end = data + 1 ; <S2SV_EndBug> <S2SV_StartBug> pbi -> do_loopfilter_inline = <S2SV_EndBug> <S2SV_StartBug> ( cm -> log2_tile_rows | cm -> log2_tile_cols ) == 0 && cm -> lf . filter_level ; <S2SV_EndBug> <S2SV_StartBug> if ( pbi -> oxcf . max_threads > 1 && ! vp9_worker_reset ( & pbi -> lf_worker ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( pbi -> oxcf . max_threads > 1 && tile_rows == 1 && tile_cols > 1 && <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> new_fb -> corrupted |= xd -> corrupted ; <S2SV_EndBug> <S2SV_StartBug> ""A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> refresh_frame_context ) <S2SV_EndBug> <S2SV_StartBug> cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> void vp9_decode_frame ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; struct vpx_read_bit_buffer rb ; int context_updated = 0 ; uint8_t clear_data [ MAX_VP9_HEADER_SIZE ] <S2SV_ModEnd> <S2SV_ModStart> init_read_bit_buffer ( pbi , & rb , data , data_end , clear_data ) ) <S2SV_ModEnd> <S2SV_ModStart> ( cm -> profile <= PROFILE_2 ? 1 : 2 ) ; return ; } data += vpx_rb_bytes_read <S2SV_ModEnd> <S2SV_ModStart> cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> last_intra_only && cm -> last_show_frame && ( cm -> last_frame_type != KEY_FRAME ) ; vp9_setup_block_planes ( xd , cm -> subsampling_x , cm -> subsampling_y ) ; * cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ; if ( ! cm -> fc -> initialized ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Uninitialized<S2SV_blank>entropy<S2SV_blank>context."" ) ; vp9_zero ( cm -> counts ) ; xd -> corrupted = 0 ; new_fb -> corrupted = read_compressed_header ( pbi , data , first_partition_size ) ; if ( new_fb -> corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>header<S2SV_blank>is<S2SV_blank>corrupted."" ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> && ! cm -> skip_loop_filter ) { vp9_loop_filter_frame_init ( cm , cm -> lf . filter_level ) ; } if ( pbi -> frame_parallel_decode && cm -> frame_parallel_decoding_mode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; if ( cm -> refresh_frame_context ) { context_updated = 1 ; cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ; } vp9_frameworker_lock_stats ( worker ) ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } if ( pbi -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! xd -> corrupted ) { if ( ! cm -> skip_loop_filter ) { vp9_loop_filter_frame_mt ( new_fb , cm , pbi -> mb . plane , cm -> lf . filter_level , 0 , 0 , pbi -> tile_workers , pbi -> num_tile_workers , & pbi -> lf_row_sync ) ; } } else { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted."" ) ; } <S2SV_ModStart> if ( ! xd -> corrupted ) { if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) { vp9_adapt_coef_probs ( cm ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_adapt_mode_probs ( cm ) ; vp9_adapt_mv_probs ( cm , cm -> allow_high_precision_mv ) ; } } else { debug_check_frame_counts ( cm ) ; } } else { <S2SV_ModEnd> <S2SV_ModStart> ""Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted."" <S2SV_ModEnd> <S2SV_ModStart> && ! context_updated <S2SV_ModStart> * <S2SV_ModStart>  <S2SV_ModEnd> "
348,<S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> ,"<S2SV_ModStart> unix_dgram_peer_wake_disconnect ( sk , skpair ) ; "
349,"<S2SV_StartBug> ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
350,<S2SV_StartBug> if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) { <S2SV_EndBug> ,<S2SV_ModStart> new_len > old_len ) { unsigned long pgoff ; if ( <S2SV_ModStart> goto Efault ; pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ; pgoff += vma -> vm_pgoff ; if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval <S2SV_ModEnd> 
351,"<S2SV_StartBug> if ( dashsize ) outpos += sprintf ( outpos , ""<S2SV_blank>[%12.3f]<S2SV_blank>%12.3f<S2SV_blank>d"" , dashsize , phase ) ; <S2SV_EndBug> <S2SV_StartBug> else outpos += sprintf ( outpos , ""<S2SV_blank>[]<S2SV_blank>0<S2SV_blank>d"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> { sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; } else send ( <S2SV_ModEnd> 
352,"<S2SV_StartBug> l2tp_msgtype_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proto_ver_print ( ndo , ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_framing_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_bearer_cap_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> print_16bits_val ( ndo , ptr ) ; <S2SV_EndBug> <S2SV_StartBug> print_octets ( ndo , ( const u_char * ) ptr , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> print_32bits_val ( ndo , ( const uint32_t * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_bearer_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_framing_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proxy_auth_type_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_proxy_auth_id_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_call_errors_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> <S2SV_StartBug> l2tp_accm_print ( ndo , ( const u_char * ) ptr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> if ( len - 6 < 8 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> if ( len - 6 < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> if ( len - 6 < 16 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> if ( len - 6 < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; break ; } <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 <S2SV_ModStart> , len - 6 "
353,<S2SV_StartBug> o4 = o * sizeof ( uint32_t ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( q + o >= e ) goto out ; 
354,"<S2SV_StartBug> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> case DW_FORM_data2 : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> # if 0 <S2SV_ModStart> # endif <S2SV_ModStart> if ( value -> encoding . block . data ) { <S2SV_ModStart> } <S2SV_ModStart> if ( value -> encoding . block . data ) { <S2SV_ModStart> } 
355,"<S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ; "
356,"<S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> memset ( box , 0 , sizeof ( jp2_box_t ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> jp2_box_create0 ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
357,"<S2SV_StartBug> char * name ; <S2SV_EndBug> <S2SV_StartBug> if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL <S2SV_ModEnd> 
358,"<S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ","<S2SV_ModStart> 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> <S2SV_ModStart> - 1 "
359,"<S2SV_StartBug> unsigned v = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_planes = get_rac ( c , state ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_h_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_v_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> transparency = get_rac ( c , state ) ; <S2SV_EndBug> ","<S2SV_ModStart> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency "
360,<S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> ,<S2SV_ModStart> vt_verify_kbmode <S2SV_ModEnd> 
361,<S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_SENSF_RES_MAXSIZE ) "
362,<S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> interface = interface ; queueItem -> 
363,<S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> encap_mark <S2SV_ModEnd> 
364,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> int i ; <S2SV_ModStart> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> 
365,<S2SV_StartBug> if ( malloc_called != 20 || free_called != 20 ) <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> 
366,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int numrows ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & xoff , & yoff ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( fscanf ( in , ""%d<S2SV_blank>%d"" , & numcols , & numrows ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t numrows ; jas_matind_t numcols ; jas_matind_t xoff ; jas_matind_t yoff ; long tmp_xoff ; long tmp_yoff ; long tmp_numrows ; long tmp_numcols <S2SV_ModEnd> <S2SV_ModStart> ""%ld<S2SV_blank>%ld"" , & tmp_xoff , & tmp_yoff <S2SV_ModEnd> <S2SV_ModStart> { return 0 ; } xoff = tmp_xoff ; yoff = tmp_yoff <S2SV_ModEnd> <S2SV_ModStart> ""%ld<S2SV_blank>%ld"" , & tmp_numcols , & tmp_numrows <S2SV_ModEnd> <S2SV_ModStart> { return 0 ; } numrows = tmp_numrows ; numcols = tmp_numcols <S2SV_ModEnd> <S2SV_ModStart> { return 0 ; } <S2SV_ModEnd> "
367,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
368,"<S2SV_StartBug> else if ( Ustrcmp ( argrest , ""Mr"" ) == 0 ) received_protocol = argv [ ++ i ] ; <S2SV_EndBug> <S2SV_StartBug> uschar * hn = Ustrchr ( argrest , ':' ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> hn ; if ( received_protocol ) { fprintf ( stderr , ""received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n"" ) ; exit ( EXIT_FAILURE ) ; } "
369,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> r -> buflen <S2SV_ModEnd> "
370,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> 
371,"<S2SV_StartBug> static void encode_sb_rt ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> <S2SV_StartBug> encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , <S2SV_EndBug> <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , <S2SV_EndBug> <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> , PC_TREE * pc_tree <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> <S2SV_ModStart> encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> encode_sb_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> <S2SV_ModStart> 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> "
372,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
373,<S2SV_StartBug> field [ nf ] = lp ; <S2SV_EndBug> <S2SV_StartBug> if ( nf > MAXDATEFIELDS ) <S2SV_EndBug> ,<S2SV_ModStart> ; if ( nf >= MAXDATEFIELDS ) return - 1 <S2SV_ModStart>  <S2SV_ModEnd> 
374,"<S2SV_StartBug> u_int16_t port ; <S2SV_EndBug> <S2SV_StartBug> unsigned int ret ; <S2SV_EndBug> <S2SV_StartBug> nf_ct_helper_log ( skb , exp -> master , ""all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo , <S2SV_EndBug> <S2SV_StartBug> nf_ct_helper_log ( skb , exp -> master , ""cannot<S2SV_blank>mangle<S2SV_blank>packet"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct nf_conn * ct = exp -> master ; union nf_inet_addr newaddr ; <S2SV_ModStart> ; newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 <S2SV_ModStart> ct <S2SV_ModEnd> <S2SV_ModStart> snprintf ( buffer , sizeof ( buffer ) , ""%u<S2SV_blank>%u"" , ntohl ( newaddr . ip ) , port ) ; pr_debug ( ""nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\'%s\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\n"" , buffer , & newaddr . ip , port ) ; <S2SV_ModStart> ct <S2SV_ModEnd> <S2SV_ModStart> ct <S2SV_ModEnd> "
375,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; } "
376,<S2SV_StartBug> ipc_lock_object ( & shp -> shm_perm ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( shp -> shm_file == NULL ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } 
377,<S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> x = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> y = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } else { x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } else { y = <S2SV_ModStart> } 
378,<S2SV_StartBug> if ( test_tsk_need_resched ( rq -> curr ) ) <S2SV_EndBug> ,<S2SV_ModStart> rq -> curr -> se . on_rq && 
379,"<S2SV_StartBug> rc = fsmVerify ( fpath , fi ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & sb "
380,<S2SV_StartBug> if ( dc_size > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( dc_count > ( 6LL * td -> xsize * td -> ysize + 63 ) / 64 ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != dc_w * dc_h * 3 <S2SV_ModEnd> 
381,"<S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> 
382,<S2SV_StartBug> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> <S2SV_StartBug> pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
383,<S2SV_StartBug> if ( name_len == 0 ) goto chunk_end ; <S2SV_EndBug> <S2SV_StartBug> READ_ENCINT ( length ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue 
384,<S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mntget ( path -> mnt ) ; 
385,"<S2SV_StartBug> while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val ) <S2SV_EndBug> <S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> ",<S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> < <S2SV_ModEnd> 
386,"<S2SV_StartBug> if ( msg -> maxsize - msg -> cursize < 4 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bits == 8 ) { <S2SV_EndBug> <S2SV_StartBug> nbits = bits & 7 ; <S2SV_EndBug> <S2SV_StartBug> Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> overflowed ) { <S2SV_ModEnd> <S2SV_ModStart> msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> , msg -> maxsize << 3 <S2SV_ModStart> if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } "
387,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
388,<S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> established = 1 ; kgctx . 
389,"<S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( rsvp_obj_ctype ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , <S2SV_EndBug> ",<S2SV_ModStart> switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; 
390,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
391,<S2SV_StartBug> image -> storage_class = PseudoClass ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> case RMT_NONE : <S2SV_EndBug> <S2SV_StartBug> * sun_colormap ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
392,<S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; <S2SV_EndBug> <S2SV_StartBug> rc -> frames_till_gf_update_due = rc -> frames_to_key ; <S2SV_EndBug> ,<S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart> ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 <S2SV_ModEnd> <S2SV_ModStart> { rc -> frames_till_gf_update_due = rc -> frames_to_key ; rc -> constrained_gf_group = 1 ; } else { rc -> constrained_gf_group = 0 ; } <S2SV_ModEnd> 
393,"<S2SV_StartBug> opendata = nfs4_opendata_alloc ( & ctx -> path , state -> owner , 0 , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
394,"<S2SV_StartBug> ERR ( ""callocing<S2SV_blank>this<S2SV_blank>failed"" ) ; <S2SV_EndBug> <S2SV_StartBug> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ERR ( ""sockect<S2SV_blank>open<S2SV_blank>failed"" ) ; <S2SV_EndBug> <S2SV_StartBug> addr . sin6_family = AF_INET6 ; <S2SV_EndBug> <S2SV_StartBug> addr . sin6_addr = in6addr_any ; <S2SV_EndBug> <S2SV_StartBug> ERR ( ""Bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ERR ( ""listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed"" <S2SV_ModEnd> <S2SV_ModStart> AF_INET <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed"" ) ; goto error ; } struct sockaddr_in <S2SV_ModEnd> <S2SV_ModStart> sin_family = AF_INET ; addr . sin_port <S2SV_ModEnd> <S2SV_ModStart> sin_addr . s_addr = htonl ( 0x7F000001 ) <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket"" <S2SV_ModEnd> "
395,"<S2SV_StartBug> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PKTAP"" ) ; <S2SV_EndBug> <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , <S2SV_EndBug> <S2SV_StartBug> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <S2SV_EndBug> ","<S2SV_ModStart> int wtap_encap ; struct eth_phdr eth ; void * phdr ; <S2SV_ModStart> wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> <S2SV_ModStart> wtap_encap <S2SV_ModEnd> <S2SV_ModStart> , TRUE , phdr "
396,"<S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> cm -> last_frame_type = cm -> frame_type ; <S2SV_EndBug> <S2SV_StartBug> cpi , ( cpi -> sf . recode_loop >= ALLOW_RECODE_KFARFGF || <S2SV_EndBug> <S2SV_StartBug> rc -> last_q [ KEY_FRAME ] = cm -> base_qindex ; <S2SV_EndBug> <S2SV_StartBug> 3 * rc -> avg_frame_qindex [ KEY_FRAME ] + cm -> base_qindex , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! rc -> is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) ) { <S2SV_EndBug> <S2SV_StartBug> rc -> last_q [ 2 ] = cm -> base_qindex ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 2 ] = ROUND_POWER_OF_TWO ( <S2SV_EndBug> <S2SV_StartBug> 3 * rc -> avg_frame_qindex [ 2 ] + cm -> base_qindex , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> rc -> tot_q += vp9_convert_qindex_to_q ( cm -> base_qindex ) ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_q = rc -> tot_q / ( double ) rc -> ni_frames ; <S2SV_EndBug> <S2SV_StartBug> rc -> ni_tot_qi += cm -> base_qindex ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cm -> base_qindex < rc -> last_boosted_qindex ) || <S2SV_EndBug> <S2SV_StartBug> ( ( cpi -> static_mb_pct < 100 ) && <S2SV_EndBug> <S2SV_StartBug> ( ( cm -> frame_type == KEY_FRAME ) || cpi -> refresh_alt_ref_frame || <S2SV_EndBug> <S2SV_StartBug> rc -> last_boosted_qindex = cm -> base_qindex ; <S2SV_EndBug> <S2SV_StartBug> rc -> total_target_bits += ( cm -> show_frame ? rc -> av_per_frame_bandwidth : 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> play_alternate && cpi -> refresh_alt_ref_frame && <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> const int qindex = cm -> base_qindex ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { vp9_cyclic_refresh_postencode ( cpi ) ; } <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> qindex <S2SV_ModEnd> <S2SV_ModStart> qindex <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> use_svc ) { int i = 0 ; SVC * svc = & cpi -> svc ; for ( i = 0 ; i < svc -> number_temporal_layers ; ++ i ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * lrc = & lc -> rc ; lrc -> last_q [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; lrc -> avg_frame_qindex [ KEY_FRAME ] = rc -> avg_frame_qindex [ KEY_FRAME ] ; } } } else { if ( rc -> is_src_frame_alt_ref || ! <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_CBR <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME ] = qindex <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME ] = <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME ] + qindex <S2SV_ModEnd> <S2SV_ModStart> qindex , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> qindex <S2SV_ModEnd> <S2SV_ModStart> } if ( ( qindex <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( ! rc -> constrained_gf_group && ( <S2SV_ModStart> qindex ; } if ( cm -> frame_type == KEY_FRAME ) rc -> last_kf_qindex = qindex ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth : 0 <S2SV_ModEnd> <S2SV_ModStart> ! cpi -> use_svc ) { if ( is_altref_enabled ( cpi ) <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> if ( oxcf -> pass != 0 ) { cpi -> resize_pending = rc -> next_frame_size_selector != rc -> frame_size_selector ; rc -> frame_size_selector = rc -> next_frame_size_selector ; } "
397,<S2SV_StartBug> int delegation_type = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> fmode_t <S2SV_ModEnd> 
398,"<S2SV_StartBug> rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
399,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> check_stack_depth ( ) ; 
400,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> 
401,"<S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
402,"<S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long eip <S2SV_ModEnd> <S2SV_ModStart> eip <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , eip "
403,"<S2SV_StartBug> r = parse_gid ( e + 1 , & gid ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ; 
404,"<S2SV_StartBug> static void reconstruct_inter_block ( int plane , int block , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> int x , y , eob ; <S2SV_EndBug> <S2SV_StartBug> eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y , <S2SV_EndBug> <S2SV_StartBug> inverse_transform_block ( xd , plane , block , tx_size , <S2SV_EndBug> <S2SV_StartBug> & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] , <S2SV_EndBug> <S2SV_StartBug> * args -> eobtotal += eob ; <S2SV_EndBug> ","<S2SV_ModStart> int reconstruct_inter_block ( <S2SV_ModEnd> <S2SV_ModStart> , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col , TX_SIZE tx_size ) { <S2SV_ModEnd> <S2SV_ModStart> const scan_order * sc = & vp9_default_scan_orders [ tx_size ] ; const int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_inter ( xd , plane <S2SV_ModEnd> <S2SV_ModStart> row <S2SV_ModEnd> <S2SV_ModStart> col <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> "
405,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
406,<S2SV_StartBug> length += len ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ; 
407,"<S2SV_StartBug> mask |= FS_EVENT_ON_CHILD ; <S2SV_EndBug> <S2SV_StartBug> if ( path ) <S2SV_EndBug> <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct name_snapshot name ; <S2SV_ModStart> take_dentry_name_snapshot ( & name , dentry ) ; <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> ) ; release_dentry_name_snapshot ( & name "
408,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <S2SV_EndBug> ",<S2SV_ModStart> CDF_SHORT_SEC_SIZE <S2SV_ModEnd> 
409,<S2SV_StartBug> tcon -> bad_network_name = true ; <S2SV_EndBug> ,<S2SV_ModStart> if ( tcon ) 
410,"<S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> } 
411,"<S2SV_StartBug> agoo_log_cat ( & agoo_con_cat , ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]"" , <S2SV_EndBug> <S2SV_StartBug> getpid ( ) , ( unsigned long long ) cnt , b -> id , con -> sock ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]<S2SV_blank>from<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> , con -> remote "
412,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = strdup_if_nonnull ( & target -> cr_principal , source -> cr_principal ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = kstrdup ( <S2SV_ModEnd> <S2SV_ModStart> , GFP_KERNEL ) ; target -> cr_raw_principal = kstrdup ( source -> cr_raw_principal , GFP_KERNEL <S2SV_ModStart> ( source -> cr_principal && ! target -> cr_principal ) || ( source -> cr_raw_principal && ! target -> cr_raw_principal ) ) return - ENOMEM <S2SV_ModEnd> "
413,<S2SV_StartBug> assert ( offset >= capoff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
414,"<S2SV_StartBug> r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , root "
415,"<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else "
416,"<S2SV_StartBug> unsigned int block_size , <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 , k = 0 ; i < block_size ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < block_size ; j ++ , k ++ ) { <S2SV_EndBug> <S2SV_StartBug> modifier += 1 << ( strength - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> byte += stride - block_size ; <S2SV_EndBug> ","<S2SV_ModStart> block_width , unsigned int block_height <S2SV_ModEnd> <S2SV_ModStart> const int rounding = strength > 0 ? 1 << ( strength - 1 ) : 0 ; <S2SV_ModStart> block_height <S2SV_ModEnd> <S2SV_ModStart> block_width <S2SV_ModEnd> <S2SV_ModStart> rounding <S2SV_ModEnd> <S2SV_ModStart> block_width <S2SV_ModEnd> "
417,<S2SV_StartBug> assert ( idx >= 1 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , dev -> bar [ idx ] . type ) ; return <S2SV_ModEnd> "
418,"<S2SV_StartBug> return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ; <S2SV_EndBug> ",<S2SV_ModStart> if ( uid >= AID_APP ) { return 0 ; } 
419,<S2SV_StartBug> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; <S2SV_EndBug> ,<S2SV_ModStart> ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8 
420,<S2SV_StartBug> void ext4_xattr_destroy_cache ( struct mb_cache * cache ) <S2SV_EndBug> <S2SV_StartBug> mb_cache_destroy ( cache ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_destroy <S2SV_ModEnd> 
421,<S2SV_StartBug> mu_run_test ( test_r_str_unescape ) ; <S2SV_EndBug> ,<S2SV_ModStart> test_r_str_escape_sh ) ; mu_run_test ( 
422,<S2SV_StartBug> sbinfo -> max_blocks = config . nr_blocks ; <S2SV_EndBug> <S2SV_StartBug> sbinfo -> free_blocks = config . nr_blocks ; <S2SV_EndBug> <S2SV_StartBug> if ( ! inode ) <S2SV_EndBug> <S2SV_StartBug> root = d_alloc_root ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( sbinfo ) ; <S2SV_EndBug> ,"<S2SV_ModStart> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sbinfo -> spool = NULL ; if ( <S2SV_ModEnd> <S2SV_ModStart> != - 1 ) { sbinfo -> spool = hugepage_new_subpool ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sbinfo -> spool <S2SV_ModEnd> <S2SV_ModStart> } sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ; if ( ! inode ) goto out_free ; <S2SV_ModStart> if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ; "
423,<S2SV_StartBug> U2FHID_INIT_RESP initresp ; <S2SV_EndBug> <S2SV_StartBug> if ( resplen > sizeof ( initresp ) ) <S2SV_EndBug> <S2SV_StartBug> dev -> cid = initresp . cid ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionInterface = initresp . versionInterface ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMajor = initresp . versionMajor ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMinor = initresp . versionMinor ; <S2SV_EndBug> <S2SV_StartBug> dev -> capFlags = initresp . capFlags ; <S2SV_EndBug> ,"<S2SV_ModStart> int offs = sizeof ( nonce ) <S2SV_ModEnd> <S2SV_ModStart> < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> "
424,<S2SV_StartBug> return MS_FALSE ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , ""Invalid<S2SV_blank>time<S2SV_blank>filter."" , ""msPostGISLayerSetTimeFilter()"" ) ; return MS_FALSE ; } "
425,"<S2SV_StartBug> return recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
426,"<S2SV_StartBug> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ",<S2SV_ModStart> task_active_pid_ns ( current ) <S2SV_ModEnd> 
427,"<S2SV_StartBug> static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
428,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY "
429,"<S2SV_StartBug> ND_TCHECK ( pptr [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> plen -= 32 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <S2SV_EndBug> ","<S2SV_ModStart> char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> asbuf <S2SV_ModEnd> "
430,<S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_protocol <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_protocol <S2SV_ModEnd> <S2SV_ModStart> skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! skb <S2SV_ModEnd> 
431,<S2SV_StartBug> vstart += verdef -> vd_aux ; <S2SV_EndBug> ,<S2SV_ModStart> int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> 
432,<S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> 
433,"<S2SV_StartBug> zap = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> rcu_assign_keypointer ( key , upayload ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_ModStart> else zap = NULL ; "
434,"<S2SV_StartBug> void vp9_fht8x8_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct8x8_c ( input , output , stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 64 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> outptr [ j * 8 + i ] = temp_out [ j ] ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct8x8_c <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> 
435,"<S2SV_StartBug> 1 , 0 , xcp , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
436,"<S2SV_StartBug> if ( s -> chunksize >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> s -> chunksize = strtoll ( line , NULL , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\'\\n"" , <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int64_t target = h -> is_streamed ? 0 : s -> off ; <S2SV_EndBug> <S2SV_StartBug> av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\n"" , s -> off , av_err2str ( read_ret ) ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\n"" , target ) ; <S2SV_EndBug> ","<S2SV_ModStart> != UINT64_MAX <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> h <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\n"" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> "
437,<S2SV_StartBug> int iSrc ; <S2SV_EndBug> <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . 
438,<S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
439,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" "
440,<S2SV_StartBug> void unix_inflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> struct user_struct * user , <S2SV_ModStart>  <S2SV_ModEnd> "
441,"<S2SV_StartBug> const u_char * bp , enum pimv2_addrtype at , int silent ) <S2SV_EndBug> <S2SV_StartBug> int len , hdrlen ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> len = sizeof ( struct in_addr ) ; <S2SV_EndBug> <S2SV_StartBug> len = sizeof ( struct in6_addr ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( pimv2_addr_len ) { <S2SV_EndBug> <S2SV_StartBug> len = pimv2_addr_len ; <S2SV_EndBug> <S2SV_StartBug> switch ( at ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> return hdrlen + len ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , len + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> return hdrlen + 2 + len ; <S2SV_EndBug> ","<S2SV_ModStart> u_int len , <S2SV_ModStart> u_int addr_len , <S2SV_ModStart> hdrlen ; if ( addr_len == 0 ) { if ( len < 2 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> addr_len = ( u_int ) <S2SV_ModEnd> <S2SV_ModStart> addr_len = ( u_int ) <S2SV_ModEnd> <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len -= hdrlen ; <S2SV_ModStart> if ( len < addr_len ) goto trunc ; <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart> if ( len < addr_len + 2 ) goto trunc ; <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart> addr_len <S2SV_ModEnd> "
442,"<S2SV_StartBug> n = r -> sector_count ; <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = n * 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , <S2SV_ModEnd> <S2SV_ModStart> n , scsi_read_complete , r ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
443,<S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> ,<S2SV_ModStart> ; assert ( match_offset + match_length <= callback_args -> data_size ) 
444,<S2SV_StartBug> string -> space = 1 ; <S2SV_EndBug> <S2SV_StartBug> string -> space *= 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( string -> space < 0 ) <S2SV_EndBug> <S2SV_StartBug> new_len = string -> space = G_MAXINT - 8 ; <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart> 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> more_space > max_space ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n"" , G_STRLOC , new_len ) ; } } <S2SV_ModEnd> <S2SV_ModStart> more_space <S2SV_ModEnd> "
445,<S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> 
446,<S2SV_StartBug> szLineConv [ i ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; 
447,"<S2SV_StartBug> ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) <S2SV_EndBug> ",<S2SV_ModStart> ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; <S2SV_ModStart> ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; 
448,"<S2SV_StartBug> cmdline_status = options_cmdline ( arg1 , arg2 ) ; <S2SV_EndBug> <S2SV_StartBug> return cmdline_status ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> log_flush ( LOG_MODE_BUFFER ) ; <S2SV_ModStart> { log_flush ( LOG_MODE_ERROR ) ; return cmdline_status ; } options_free ( 1 ) <S2SV_ModEnd> <S2SV_ModStart> { unbind_ports ( ) ; options_free ( 1 ) ; options_defaults ( ) ; options_apply ( ) ; log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> 
449,"<S2SV_StartBug> len = get_line_size ( * b , * avail , nl ) ; <S2SV_EndBug> ","<S2SV_ModStart> + len , * avail - len <S2SV_ModEnd> "
450,"<S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
451,"<S2SV_StartBug> static INLINE int cost_coeffs ( MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int c , cost ; <S2SV_EndBug> <S2SV_StartBug> : get_uv_tx_size ( mbmi ) == tx_size ) ; <S2SV_EndBug> <S2SV_StartBug> int prev_t = vp9_dct_value_tokens_ptr [ v ] . token ; <S2SV_EndBug> <S2SV_StartBug> cost = ( * token_costs ) [ 0 ] [ pt ] [ prev_t ] + vp9_dct_value_cost_ptr [ v ] ; <S2SV_EndBug> <S2SV_StartBug> int t ; <S2SV_EndBug> <S2SV_StartBug> t = vp9_dct_value_tokens_ptr [ v ] . token ; <S2SV_EndBug> <S2SV_StartBug> cost += ( * token_costs ) [ ! prev_t ] [ ! prev_t ] [ t ] + vp9_dct_value_cost_ptr [ v ] ; <S2SV_EndBug> <S2SV_StartBug> cost += ( * token_costs ) [ ! prev_t ] [ pt ] [ t ] + vp9_dct_value_cost_ptr [ v ] ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; # else const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; # endif <S2SV_ModStart> , pd <S2SV_ModStart> int16_t prev_t ; EXTRABIT e ; vp9_get_token_extra ( v , & prev_t , & e ) <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( prev_t , e , cat6_high_cost ) <S2SV_ModEnd> <S2SV_ModStart> int16_t <S2SV_ModEnd> <S2SV_ModStart> vp9_get_token_extra ( v , & t , & e ) <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( t , e , cat6_high_cost ) <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( t , e , cat6_high_cost ) <S2SV_ModEnd> "
452,<S2SV_StartBug> if ( net != c_net || ! tc -> t_sock ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
453,"<S2SV_StartBug> CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ; CU_add_test ( parserTestSuite , "
454,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> m -> msg_namelen = 0 ; 
455,<S2SV_StartBug> return NF_ACCEPT ; <S2SV_EndBug> ,<S2SV_ModStart> err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> 
456,"<S2SV_StartBug> separator = strchr ( line , ':' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
457,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( plenbytes < 0 ) return plenbytes ; 
458,"<S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( <S2SV_ModStart> ) <S2SV_ModStart> cache_id ( <S2SV_ModStart> ) <S2SV_ModStart> cache_id ( <S2SV_ModStart> ) 
459,<S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) <S2SV_EndBug> <S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0x40 ) <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & "
460,<S2SV_StartBug> struct serial_icounter_struct icount ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
461,"<S2SV_StartBug> r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , root "
462,<S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; } "
463,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ThrowDCMException <S2SV_ModEnd> 
464,"<S2SV_StartBug> strlcpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
465,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; 
466,<S2SV_StartBug> int err ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL 
467,<S2SV_StartBug> return ( ( f != NULL && <S2SV_EndBug> <S2SV_StartBug> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <S2SV_EndBug> <S2SV_StartBug> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <S2SV_EndBug> ,<S2SV_ModStart> if ( f == NULL || <S2SV_ModEnd> <S2SV_ModStart> == NULL || <S2SV_ModEnd> <S2SV_ModStart> == NULL || f -> addressFamily -> length < 2 ) return 0 ; return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
468,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> ",<S2SV_ModStart> { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> } <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> } <S2SV_ModStart> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; 
469,"<S2SV_StartBug> if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( is_link ( ""/etc/skel/.zshrc"" ) ) { <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>/etc/skel/.zshrc<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> errExit ( ""chown"" ) ; <S2SV_EndBug> <S2SV_StartBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( arg_csh ) { <S2SV_EndBug> ","<S2SV_ModStart> is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> copy_file_as_user ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else if ( arg_csh ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <S2SV_ModStart> fname <S2SV_ModEnd> <S2SV_ModStart> ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname <S2SV_ModEnd> <S2SV_ModStart> stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { copy_file_as_user ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) ; fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir <S2SV_ModEnd> <S2SV_ModStart> ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n"" , fname ) ; exit ( 1 ) ; } if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { copy_file_as_user ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 <S2SV_ModEnd> <S2SV_ModStart> ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
470,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
471,"<S2SV_StartBug> ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
472,"<S2SV_StartBug> ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> type , length ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> EXTRACT_64BITS ( tptr + 3 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , tptr + 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length - 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart> tlen = len ; while ( tlen >= 3 ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( length < 8 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
473,<S2SV_StartBug> state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fstrndup <S2SV_ModEnd> <S2SV_ModStart> , len "
474,<S2SV_StartBug> for ( y = 0 ; y < s -> ymin ; y ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> FFMIN ( <S2SV_ModStart> , s -> h ) "
475,"<S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & sta -> ps_lock ) ; <S2SV_ModStart> ) ; spin_unlock ( & sta -> ps_lock 
476,"<S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> & enc_tables <S2SV_ModEnd> <S2SV_ModStart> enc_tables <S2SV_ModEnd> 
477,<S2SV_StartBug> struct ssh * ssh = active_state ; <S2SV_EndBug> <S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
478,<S2SV_StartBug> if ( l >= ( len - o ) ) { <S2SV_EndBug> ,<S2SV_ModStart> - 4 
479,"<S2SV_StartBug> ap_log_cerror ( APLOG_MARK , APLOG_ERR , 0 , session -> c , <S2SV_EndBug> <S2SV_StartBug> if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) { <S2SV_EndBug> ","<S2SV_ModStart> APLOG_DEBUG <S2SV_ModEnd> <S2SV_ModStart> if ( status == APR_ECONNRESET ) { ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , status , session -> c , ""h2-stream(%ld-%d):<S2SV_blank>on_header,<S2SV_blank>reset<S2SV_blank>stream"" , session -> id , stream -> id ) ; nghttp2_submit_rst_stream ( ngh2 , NGHTTP2_FLAG_NONE , stream -> id , NGHTTP2_INTERNAL_ERROR ) ; } else "
480,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%(2*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
481,"<S2SV_StartBug> CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; <S2SV_EndBug> <S2SV_StartBug> ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_EndBug> <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> caf_chunk_header . mChunkSize > 1024 ) { error_line ( ""this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes"" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> uint32_t <S2SV_ModEnd> <S2SV_ModStart> buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
482,"<S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ; <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> "
483,<S2SV_StartBug> char build [ ATUSB_BUILD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> * build <S2SV_ModEnd> <S2SV_ModStart> ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <S2SV_ModStart> kfree ( build ) ; "
484,<S2SV_StartBug> if ( isspace ( * s ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) 
485,"<S2SV_StartBug> uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
486,"<S2SV_StartBug> zval * options = NULL , * classes = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { <S2SV_EndBug> <S2SV_StartBug> zval_ptr_dtor ( return_value ) ; <S2SV_EndBug> <S2SV_StartBug> var_push_dtor ( & var_hash , return_value ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; zval * retval <S2SV_ModStart> retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> retval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ZVAL_COPY ( return_value , retval <S2SV_ModEnd> "
487,"<S2SV_StartBug> int cond_len , then_len , jump_len ; <S2SV_EndBug> <S2SV_StartBug> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <S2SV_EndBug> <S2SV_StartBug> int else_len = compile_length_tree ( Else , reg ) ; <S2SV_EndBug> <S2SV_StartBug> COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <S2SV_EndBug> <S2SV_StartBug> r = compile_tree ( Else , reg , env ) ; <S2SV_EndBug> ","<S2SV_ModStart> else_len , <S2SV_ModStart> + <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModStart> SIZE_OP_ATOMIC_END + <S2SV_ModStart> add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r = "
488,"<S2SV_StartBug> if ( pt [ 6 ] & AX25_HBIT ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModStart> } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModEnd> <S2SV_ModStart> } 
489,"<S2SV_StartBug> uint8_t * outbuf ; <S2SV_EndBug> <S2SV_StartBug> command = buf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> rc = scsi_disk_emulate_command ( r , outbuf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
490,"<S2SV_StartBug> assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; "
491,"<S2SV_StartBug> const uint8_t * p , u_int length , u_int caplen ) <S2SV_EndBug> <S2SV_StartBug> if ( caplen <= 1 ) { <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> <S2SV_StartBug> if ( caplen > 1 ) <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , ""\\n\\t"" , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ND_TTEST ( * p ) <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> 
492,<S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> <S2SV_StartBug> tp -> e_name = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> 
493,<S2SV_StartBug> if ( ctx -> mb_height > 68 || <S2SV_EndBug> <S2SV_StartBug> ctx -> data_offset = 0x280 ; <S2SV_EndBug> ,"<S2SV_ModStart> ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
494,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> opt = np -> opt ; <S2SV_EndBug> <S2SV_StartBug> return err < 0 ? err : len ; <S2SV_EndBug> ,<S2SV_ModStart> struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> <S2SV_ModStart> txopt_put ( opt_to_free ) ; 
495,<S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; } "
496,<S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( 
497,<S2SV_StartBug> filename [ filename_size ++ ] = '\\0' ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
498,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
499,<S2SV_StartBug> spin_lock_init ( & port -> phy_list_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> INIT_LIST_HEAD ( & port -> sas_port_del_list ) ; 
500,"<S2SV_StartBug> hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , 0 ) ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chunk_end [ i ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( * hmp_chunk [ i ] < 0x80 ) { <S2SV_EndBug> <S2SV_StartBug> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmp_chunk [ i ] < 0x80 ) ; <S2SV_EndBug> <S2SV_StartBug> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; <S2SV_EndBug> <S2SV_StartBug> hmp_chunk [ i ] ++ ; <S2SV_EndBug> ","<S2SV_ModStart> [ i ] ; chunk_length [ i ] -= chunk_ofs <S2SV_ModStart> chunk_length [ i ] -= 3 ; <S2SV_ModStart> [ i ] , chunk_length <S2SV_ModStart> ; chunk_length [ i ] -= 3 <S2SV_ModStart> chunk_length [ i ] -= setup_ret ; <S2SV_ModStart> chunk_length [ i ] && <S2SV_ModStart> if ( ! chunk_length [ i ] ) break ; <S2SV_ModStart> chunk_length [ i ] -- ; <S2SV_ModStart> if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmp_end ; } <S2SV_ModStart> ; chunk_length [ i ] -- "
501,"<S2SV_StartBug> mem_free ( gr . gr_ctx . value , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & min_stat , & gd -> checksum ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
502,"<S2SV_StartBug> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ",<S2SV_ModStart> task_active_pid_ns ( current ) <S2SV_ModEnd> 
503,<S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> kern_unmount <S2SV_ModEnd> 
504,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
505,"<S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
506,"<S2SV_StartBug> struct LayerData * cx_layer_list = NULL ; <S2SV_EndBug> <S2SV_StartBug> memset ( & superframe , 0 , sizeof ( superframe ) ) ; <S2SV_EndBug> <S2SV_StartBug> case VPX_CODEC_CX_FRAME_PKT : { <S2SV_EndBug> <S2SV_StartBug> si -> bytes_sum [ si -> layer ] += frame_pkt_size ; <S2SV_EndBug> <S2SV_StartBug> ld_list_add ( & cx_layer_list , layer_data ) ; <S2SV_EndBug> ","<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> svc_log_reset ( svc_ctx ) ; res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC case VPX_CODEC_SPATIAL_SVC_LAYER_PSNR : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { int j ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n"" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . psnr [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_DEBUG , ""SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>"" ""%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n"" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . sse [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 3 ] ) ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . psnr [ j ] ; si -> sse_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . sse [ j ] ; } } ++ si -> psnr_pkt_received ; break ; } case VPX_CODEC_SPATIAL_SVC_LAYER_SIZES : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) <S2SV_ModEnd> <S2SV_ModStart> i ] += cx_pkt -> data . layer_sizes [ i ] ; break ; } # endif # endif default : { break ; } } } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
507,<S2SV_StartBug> void * parg = NULL ; <S2SV_EndBug> <S2SV_StartBug> int is_ext_ctrl ; <S2SV_EndBug> <S2SV_StartBug> case _IOC_NONE : <S2SV_EndBug> <S2SV_StartBug> case _IOC_WRITE : <S2SV_EndBug> <S2SV_StartBug> if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) <S2SV_ModEnd> <S2SV_ModStart> if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
508,<S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> 
509,"<S2SV_StartBug> pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 << <S2SV_EndBug> ","<S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> "
510,"<S2SV_StartBug> sraSpanInsertAfter ( sraSpan * newspan , sraSpan * after ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> after ) { if ( newspan && <S2SV_ModStart> } 
511,<S2SV_StartBug> while ( c && which > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = c -> next ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , which -- ; <S2SV_ModEnd> "
512,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug> ,<S2SV_ModStart> cond_resched ( ) <S2SV_ModEnd> 
513,"<S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len < j + msg -> len + 1 ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n"" ) ; return - 1 ; } "
514,"<S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart>  <S2SV_ModEnd> "
515,<S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug> ,<S2SV_ModStart> skcipher_setkey <S2SV_ModEnd> 
516,"<S2SV_StartBug> c . c_normalize_args = NULL ; <S2SV_EndBug> <S2SV_StartBug> PyTuple_SET_ITEM ( c . c_normalize_args , 1 , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
517,"<S2SV_StartBug> void vp9_encode_block_intra ( MACROBLOCK * x , int plane , int block , <S2SV_EndBug> <S2SV_StartBug> unsigned char * skip ) { <S2SV_EndBug> <S2SV_StartBug> struct encode_b_args arg = { x , NULL , skip } ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> void * arg <S2SV_ModEnd> <S2SV_ModStart> * const args = arg ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; tran_low_t * coeff = BLOCK_OFFSET ( p -> coeff , block ) ; tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; tran_low_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; const scan_order * scan_order ; TX_TYPE tx_type = DCT_DCT ; PREDICTION_MODE mode ; const int bwl = b_width_log2_lookup [ plane_bsize ] ; const int diff_stride = 4 * ( 1 << bwl ) ; uint8_t * src , * dst ; int16_t * src_diff ; uint16_t * eob = & p -> eobs [ block ] ; const int src_stride = p -> src . stride ; const int dst_stride = pd -> dst . stride ; int i , j ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * ( j * dst_stride + i ) ] ; src = & p -> src . buf [ 4 * ( j * src_stride + i ) ] ; src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ; if ( tx_size == TX_4X4 ) { tx_type = get_tx_type_4x4 ( pd -> plane_type , xd , block ) ; scan_order = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; mode = plane == 0 ? get_y_mode ( xd -> mi [ 0 ] , block ) : mbmi -> uv_mode ; } else { mode = plane == 0 ? mbmi -> mode : mbmi -> uv_mode ; if ( tx_size == TX_32X32 ) { scan_order = & vp9_default_scan_orders [ TX_32X32 ] ; } else { tx_type = get_tx_type ( pd -> plane_type , xd ) ; scan_order = & vp9_scan_orders [ tx_size ] [ tx_type ] ; } } vp9_predict_intra_block ( xd , bwl , tx_size , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , i , j , plane ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( tx_size ) { case TX_32X32 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_idct32x32_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_16X16 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; else vp9_highbd_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_highbd_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_8X8 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; else vp9_highbd_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_highbd_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_4X4 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type != DCT_DCT ) vp9_highbd_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { if ( tx_type == DCT_DCT ) { x -> highbd_itxm_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } else { vp9_highbd_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type , xd -> bd ) ; } } break ; default : assert ( 0 ) ; return ; } if ( * eob ) * ( args -> skip ) = 0 ; return ; } # endif switch ( tx_size ) { case TX_32X32 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_idct32x32_add ( dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_16X16 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; vp9_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_8X8 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; vp9_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_4X4 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; if ( tx_type != DCT_DCT ) vp9_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { if ( tx_type == DCT_DCT ) x -> itxm_add ( dqcoeff , dst , dst_stride , * eob ) ; else vp9_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type ) ; } break ; default : assert ( 0 ) ; break ; } if ( * eob ) * ( args -> skip ) = 0 <S2SV_ModEnd> "
518,"<S2SV_StartBug> UnpackRaster : <S2SV_EndBug> <S2SV_StartBug> image -> rows = Bitmap2Header1 . Height ; <S2SV_EndBug> <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart>  <S2SV_ModEnd> "
519,<S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( <S2SV_ModStart> * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , ""Malformed<S2SV_blank>AUTHENTICATE"" ) ; if ( "
520,"<S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <S2SV_EndBug> <S2SV_StartBug> ECDSA_SIG_free ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> p <S2SV_ModEnd> <S2SV_ModStart> goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } "
521,"<S2SV_StartBug> switch ( af ) { <S2SV_EndBug> <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> ","<S2SV_ModStart> size_t pathlen = 0 ; <S2SV_ModStart> pathlen = sizeof ( <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> "
522,<S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug> ,"<S2SV_ModStart> ; lock_sock ( sk ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart>  <S2SV_ModEnd> "
523,<S2SV_StartBug> ! no_port_forwarding_flag && ! options . disable_forwarding ) { <S2SV_EndBug> ,<S2SV_ModStart> && use_privsep 
524,"<S2SV_StartBug> RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 1 ; i < cfg -> ts_number_layers ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing"" ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; -- i ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK_BOOL ( extra_cfg , enable_auto_alt_ref ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , cpu_used , - 16 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , arnr_type , 1 , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; <S2SV_EndBug> <S2SV_StartBug> int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ss_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> || ( int ) ( stats -> count + 0.5 ) != n_packets_per_layer [ layer_id ] - 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && <S2SV_EndBug> <S2SV_StartBug> extra_cfg -> bit_depth > BITS_8 ) <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && <S2SV_EndBug> <S2SV_StartBug> extra_cfg -> bit_depth == BITS_8 ) <S2SV_EndBug> ","<S2SV_ModStart> 100 <S2SV_ModEnd> <S2SV_ModStart> 100 <S2SV_ModEnd> <S2SV_ModStart> extra_cfg , min_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; RANGE_CHECK ( extra_cfg , max_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; if ( extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , 2 , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( extra_cfg -> min_gf_interval > 0 && extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , extra_cfg -> min_gf_interval , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( cfg -> rc_resize_allowed == 1 ) { RANGE_CHECK ( cfg , rc_scaled_width , 0 , cfg -> g_w ) ; RANGE_CHECK ( cfg , rc_scaled_height , 0 , cfg -> g_h ) ; } RANGE_CHECK ( <S2SV_ModStart> ss_number_layers * cfg -> ts_number_layers > VPX_MAX_LAYERS ) ERROR ( ""ss_number_layers<S2SV_blank>*<S2SV_blank>ts_number_layers<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; if ( cfg -> ts_number_layers > <S2SV_ModEnd> <S2SV_ModStart> sl , tl <S2SV_ModEnd> <S2SV_ModStart> sl = 1 ; sl <S2SV_ModEnd> <S2SV_ModStart> ss_number_layers ; ++ sl ) { for ( tl = 1 ; tl < cfg -> <S2SV_ModStart> tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cfg -> ts_number_layers ) ; if ( cfg -> layer_target_bitrate [ layer ] < cfg -> layer_target_bitrate [ layer <S2SV_ModEnd> <S2SV_ModStart> } } <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> tl <S2SV_ModEnd> <S2SV_ModStart> tl ] ) ERROR ( ""ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2"" ) ; } # if CONFIG_SPATIAL_SVC if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && cfg -> g_pass == VPX_RC_LAST_PASS ) { unsigned int i , alt_ref_sum = 0 ; for ( i = 0 ; i < cfg -> ss_number_layers ; ++ i ) { if ( cfg -> ss_enable_auto_alt_ref [ <S2SV_ModStart> ++ alt_ref_sum ; } if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers ) ERROR ( ""Not<S2SV_blank>enough<S2SV_blank>ref<S2SV_blank>buffers<S2SV_blank>for<S2SV_blank>svc<S2SV_blank>alt<S2SV_blank>ref<S2SV_blank>frames"" ) ; if ( cfg -> ss_number_layers * cfg -> ts_number_layers > 3 && cfg -> g_error_resilient == 0 ) ERROR ( ""Multiple<S2SV_blank>frame<S2SV_blank>context<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>more<S2SV_blank>than<S2SV_blank>3<S2SV_blank>layers"" ) ; } # endif <S2SV_ModEnd> <S2SV_ModStart> RANGE_CHECK <S2SV_ModEnd> <S2SV_ModStart> , 0 , 2 <S2SV_ModStart> 8 , 8 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ; RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ; RANGE_CHECK ( extra_cfg , content , VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart> > 1 || cfg -> ts_number_layers <S2SV_ModStart> unsigned <S2SV_ModStart> # if ! CONFIG_VP9_HIGHBITDEPTH if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) { ERROR ( ""Profile<S2SV_blank>><S2SV_blank>1<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build<S2SV_blank>configuration"" ) ; } # endif <S2SV_ModStart> cfg -> g_bit_depth > VPX_BITS_8 ) { ERROR ( ""Codec<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart> cfg -> g_input_bit_depth > 8 ) { ERROR ( ""Source<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2"" ) ; } if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth == VPX_BITS_8 ) { ERROR ( ""Codec<S2SV_blank>bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1"" ) ; } RANGE_CHECK ( extra_cfg , color_space , VPX_CS_UNKNOWN , VPX_CS_SRGB <S2SV_ModEnd> "
525,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
526,<S2SV_StartBug> char added ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
527,<S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cd -> disk ) continue ; 
528,<S2SV_StartBug> if ( sum_calculated != headersum ) { <S2SV_EndBug> ,<S2SV_ModStart> lha -> compsize < 0 ) goto invalid ; if ( 
529,"<S2SV_StartBug> int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
530,<S2SV_StartBug> if ( net != & init_net ) <S2SV_EndBug> ,<S2SV_ModStart> protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if ( 
531,"<S2SV_StartBug> rb_define_method ( req_class , ""rack_version"" , rack_version , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> rack_version_val = rb_str_new_cstr ( ""rack.version"" ) ; rb_gc_register_address ( & rack_version_val ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""remote_addr"" , remote_addr , 0 ) ; rb_define_method ( req_class , <S2SV_ModStart> ) ; remote_addr_val = rb_str_new_cstr ( ""REMOTE_ADDR"" ) ; rb_gc_register_address ( & remote_addr_val "
532,"<S2SV_StartBug> static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
533,"<S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt = ipv6_renew_options ( sk , np -> opt , optname , <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> tot_len = sizeof ( * opt ) + optlen ; <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; opt = <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> atomic_set ( & opt -> refcnt , 1 ) ; <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> "
534,"<S2SV_StartBug> JSObjectRef globalobject ; <S2SV_EndBug> <S2SV_StartBug> globalobject = JSContextGetGlobalObject ( context ) ; <S2SV_EndBug> <S2SV_StartBug> JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
535,"<S2SV_StartBug> const int zbin = cpi -> zbin_mode_boost + x -> act_zbin_adj ; <S2SV_EndBug> <S2SV_StartBug> x -> plane [ 0 ] . quant_shift = quants -> y_quant_shift [ qindex ] ; <S2SV_EndBug> <S2SV_StartBug> x -> plane [ 0 ] . zbin_extra = ( int16_t ) ( ( cm -> y_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ; <S2SV_EndBug> <S2SV_StartBug> x -> plane [ i ] . quant_shift = quants -> uv_quant_shift [ qindex ] ; <S2SV_EndBug> <S2SV_StartBug> x -> plane [ i ] . zbin_extra = ( int16_t ) ( ( cm -> uv_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> <S2SV_StartBug> x -> skip_block = vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_initialize_me_consts ( cpi , x -> q_index ) ; <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> quant_fp = quants -> y_quant_fp [ qindex ] ; x -> plane [ 0 ] . round_fp = quants -> y_round_fp [ qindex ] ; x -> plane [ 0 ] . <S2SV_ModStart> xd -> plane [ 0 ] . dequant = cpi <S2SV_ModEnd> <S2SV_ModStart> ; x -> plane [ 0 ] . quant_thred [ 0 ] = x -> plane [ 0 ] . zbin [ 0 ] * x -> plane [ 0 ] . zbin [ 0 ] ; x -> plane [ 0 ] . quant_thred [ 1 ] = x -> plane [ 0 ] . zbin [ 1 ] * x -> plane [ 0 ] . zbin [ 1 <S2SV_ModEnd> <S2SV_ModStart> quant_fp = quants -> uv_quant_fp [ qindex ] ; x -> plane [ i ] . round_fp = quants -> uv_round_fp [ qindex ] ; x -> plane [ i ] . <S2SV_ModStart> xd -> plane [ i ] . dequant = cpi <S2SV_ModEnd> <S2SV_ModStart> ; x -> plane [ i ] . quant_thred [ 0 ] = x -> plane [ i ] . zbin [ 0 ] * x -> plane [ i ] . zbin [ 0 ] ; x -> plane [ i ] . quant_thred [ 1 ] = x -> plane [ i ] . zbin [ 1 ] * x -> plane [ i ] . zbin [ 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> , x "
536,<S2SV_StartBug> if ( label_exec ( opt_exec_label ) == - 1 ) <S2SV_EndBug> ,"<S2SV_ModStart> setsid ( ) == ( pid_t ) - 1 ) die_with_error ( ""setsid"" ) ; if ( "
537,<S2SV_StartBug> same_page : <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } } 
538,<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> oxcf -> tuning = vp8_cfg . tuning ; <S2SV_EndBug> ,<S2SV_ModStart> else ( void ) mr_cfg ; # <S2SV_ModStart> ; oxcf -> screen_content_mode = vp8_cfg . screen_content_mode 
539,<S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
540,<S2SV_StartBug> if ( ctx -> pbi ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> pbi = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> frame_workers != NULL ) { int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; vpx_get_worker_interface ( ) -> end ( worker ) ; vp9_remove_common ( & frame_worker_data -> pbi -> common ) ; # if CONFIG_VP9_POSTPROC vp9_free_postproc_buffers ( & frame_worker_data -> pbi -> common ) ; # endif vp9_decoder_remove ( frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> vpx_free ( frame_worker_data -> scratch_buffer ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & frame_worker_data -> stats_mutex ) ; pthread_cond_destroy ( & frame_worker_data -> stats_cond ) ; # endif vpx_free ( frame_worker_data ) ; } # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif } if ( ctx -> buffer_pool ) { vp9_free_ref_frame_buffers ( ctx -> buffer_pool ) ; vp9_free_internal_frame_buffers ( & ctx -> buffer_pool -> int_frame_buffers ) ; } vpx_free ( ctx -> frame_workers ) ; vpx_free ( ctx -> buffer_pool ) ; <S2SV_ModEnd> 
541,"<S2SV_StartBug> c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> macinf -> lchid [ j + chan ] = c_t + 1 ; <S2SV_EndBug> <S2SV_StartBug> macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ; <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> + 1 ) % 0xf <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
542,<S2SV_StartBug> if ( setuid ( current_user . uid ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( setgid ( current_user . gid ) < 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> # if HAVE_DECL_SETRESUID if ( setresuid ( current_user . uid , current_user . uid , current_user . uid ) < 0 ) # else <S2SV_ModStart> # endif <S2SV_ModStart> # if HAVE_DECL_SETRESGID if ( setresgid ( current_user . gid , current_user . gid , current_user . gid ) < 0 ) # else <S2SV_ModStart> # endif "
543,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> 
544,<S2SV_StartBug> int copy = output_size - count ; <S2SV_EndBug> <S2SV_StartBug> if ( avail < copy ) copy = avail ; <S2SV_EndBug> ,<S2SV_ModStart> png_size_t <S2SV_ModEnd> <S2SV_ModStart> ( png_size_t ) <S2SV_ModStart> ( png_size_t ) 
545,"<S2SV_StartBug> pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 << <S2SV_EndBug> ","<S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> "
546,"<S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> unsigned int ret <S2SV_ModEnd> <S2SV_ModStart> md5_transform <S2SV_ModEnd> <S2SV_ModStart> random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> 
547,"<S2SV_StartBug> if ( using_compacted_format ( ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; } "
548,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc32 ( tif , cp0 , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
549,<S2SV_StartBug> if ( c -> chunk_size == 0 ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> ,<S2SV_ModStart> <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <S2SV_ModEnd> <S2SV_ModStart> av_assert0 ( len <= c -> chunk_size ) ; 
550,<S2SV_StartBug> u16 source_node_id ; <S2SV_EndBug> <S2SV_StartBug> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 <S2SV_EndBug> <S2SV_StartBug> ( ver == RFC2734_SW_VERSION <S2SV_EndBug> <S2SV_StartBug> || ver == RFC3146_SW_VERSION <S2SV_EndBug> <S2SV_StartBug> ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> gasp_version ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> gasp_version ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> fwnet_incoming_packet ( dev , buf_ptr + 2 , length - IEEE1394_GASP_HDR_SIZE , gasp_source_id ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
551,<S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> 0 
552,<S2SV_StartBug> len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= EVP_GCM_TLS_TAG_LEN ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> { if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ; <S2SV_ModStart> } 
553,"<S2SV_StartBug> int r , len , group = 0 ; <S2SV_EndBug> <S2SV_StartBug> Node * * tp ; <S2SV_EndBug> <S2SV_StartBug> goto end_of_token ; <S2SV_EndBug> <S2SV_StartBug> qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> ; parse_depth = env -> parse_depth <S2SV_ModStart> parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ; 
554,"<S2SV_StartBug> const int length , const char check_utf8 , const char check_dot , <S2SV_EndBug> <S2SV_StartBug> int position = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> 
555,"<S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
556,<S2SV_StartBug> if ( getCcalls ( L ) <= CSTACKERR ) <S2SV_EndBug> <S2SV_StartBug> luaE_freeCI ( L ) ; <S2SV_EndBug> ,<S2SV_ModStart> { luaE_exitCcall <S2SV_ModEnd> <S2SV_ModStart> luaE_enterCcall ( L ) ; } 
557,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
558,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""who-has<S2SV_blank>"" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""at<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""for<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> "
559,"<S2SV_StartBug> h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> <S2SV_StartBug> h -> emptyFileBools = calloc ( empty_streams , <S2SV_EndBug> <S2SV_StartBug> h -> antiBools = calloc ( empty_streams , <S2SV_EndBug> <S2SV_StartBug> if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) <S2SV_EndBug> <S2SV_StartBug> h -> attrBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> ",<S2SV_ModStart> if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> ) return ( - 1 ) ; if ( zip -> entry_names != NULL <S2SV_ModStart> if ( h -> attrBools != NULL ) return ( - 1 ) ; 
560,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> ,<S2SV_ModStart> MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> s -> studio_profile <S2SV_ModEnd> 
561,<S2SV_StartBug> len = file ? file -> size : 4096 ; <S2SV_EndBug> ,<S2SV_ModStart> && file -> size > 0 
562,"<S2SV_StartBug> if ( data_sz <= 8 ) <S2SV_EndBug> <S2SV_StartBug> struct vp9_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; <S2SV_EndBug> ","<S2SV_ModStart> return decoder_peek_si_internal ( data , data_sz , si <S2SV_ModEnd> <S2SV_ModStart> , NULL ) <S2SV_ModEnd> "
563,<S2SV_StartBug> vstart += entry -> vn_aux ; <S2SV_EndBug> ,<S2SV_ModStart> st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> 
564,<S2SV_StartBug> return code ; <S2SV_EndBug> ,"<S2SV_ModStart> { * status = ""DECODE_PA_FOR_USER"" ; return code ; } <S2SV_ModEnd> "
565,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
566,<S2SV_StartBug> if ( pSubSrc -> nSrc > 1 || isAgg || IsVirtual ( pSubSrc -> a [ 0 ] . pTab ) ) { <S2SV_EndBug> ,<S2SV_ModStart> || ( p -> selFlags & SF_Distinct ) != 0 
567,"<S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <S2SV_EndBug> ",<S2SV_ModStart> DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ <S2SV_ModEnd> <S2SV_ModStart> ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ 16 ] <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
568,<S2SV_StartBug> struct pipe_buffer * buf ; <S2SV_EndBug> <S2SV_StartBug> orig_sz = size ; <S2SV_EndBug> <S2SV_StartBug> if ( off ) <S2SV_EndBug> <S2SV_StartBug> size += off - pipe -> bufs [ idx ] . offset ; <S2SV_EndBug> <S2SV_StartBug> if ( size <= buf -> len ) <S2SV_EndBug> <S2SV_StartBug> size -= buf -> len ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = size ; <S2SV_EndBug> <S2SV_StartBug> off = i -> iov_offset = buf -> offset + size ; <S2SV_EndBug> <S2SV_StartBug> i -> count -= orig_sz ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> left ; <S2SV_ModEnd> <S2SV_ModStart> size ; pipe_truncate ( i ) <S2SV_ModEnd> "
569,"<S2SV_StartBug> PyObject * logical = NULL ; <S2SV_EndBug> <S2SV_StartBug> FriBidiParType base = FRIBIDI_TYPE_RTL ; <S2SV_EndBug> <S2SV_StartBug> { ""logical"" , ""base_direction"" , ""encoding"" , ""clean"" , ""reordernsm"" , NULL } ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""O|isii"" , kwargs , <S2SV_EndBug> <S2SV_StartBug> & logical , & base , & encoding , & clean , & reordernsm ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) <S2SV_EndBug> <S2SV_StartBug> if ( PyUnicode_Check ( logical ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( PyString_Check ( logical ) ) <S2SV_EndBug> ","<S2SV_ModStart> PyUnicodeObject <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""U|iii"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } return unicode_log2vis <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
570,<S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> ,<S2SV_ModStart> 0660 <S2SV_ModEnd> 
571,<S2SV_StartBug> i1_is_end_of_poc = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> 1 ; <S2SV_ModEnd> <S2SV_ModStart> if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; <S2SV_ModEnd> "
572,<S2SV_StartBug> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> u4_first_slice_in_pic = 0 ; 
573,<S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ,<S2SV_ModStart> ( int ) <S2SV_ModStart> ( int ) <S2SV_ModStart> <= 0 || ( int ) ( g -> sect * g -> head ) 
574,"<S2SV_StartBug> u64 base_addr , size ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( get_securelevel ( ) > 0 ) return - EPERM 
575,"<S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> <S2SV_StartBug> out_drop_write : <S2SV_EndBug> ","<S2SV_ModStart> error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> "
576,<S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
577,"<S2SV_StartBug> uint32_t authResult = 0 , reasonLen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return FALSE ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ReadReason ( client <S2SV_ModEnd> 
578,<S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
579,"<S2SV_StartBug> cJSON * cJSON_CreateIntArray ( int64_t * numbers , int count ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; a && i < count ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> n = cJSON_CreateInt ( numbers [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i ) <S2SV_EndBug> ",<S2SV_ModStart> const int <S2SV_ModEnd> <S2SV_ModStart> i ++ <S2SV_ModEnd> <S2SV_ModStart> cJSON_CreateNumber <S2SV_ModEnd> <S2SV_ModStart> if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; } 
580,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , true "
581,<S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> ,<S2SV_ModStart> UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> size <S2SV_ModEnd> 
582,<S2SV_StartBug> devc -> voc [ voice ] . panning = value ; <S2SV_EndBug> ,<S2SV_ModStart> if ( voice < 0 || voice >= devc -> nr_voice ) return ; 
583,<S2SV_StartBug> if ( server . vm_enabled && listLength ( server . io_ready_clients ) ) { <S2SV_EndBug> <S2SV_StartBug> server . vm_blocked_clients -- ; <S2SV_EndBug> ,<S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> cache_blocked_clients <S2SV_ModEnd> 
584,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
585,<S2SV_StartBug> while ( entries -- ) <S2SV_EndBug> ,<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_PARSEFUJI_PROCESSED ; # endif 
586,<S2SV_StartBug> int Q = cpi -> active_worst_quality ; <S2SV_EndBug> ,<S2SV_ModStart> if ( cpi -> force_maxqp == 1 ) { cpi -> active_worst_quality = cpi -> worst_quality ; return cpi -> worst_quality ; } 
587,<S2SV_StartBug> f = po -> fanout ; <S2SV_EndBug> <S2SV_StartBug> if ( ! f ) <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & fanout_mutex ) ; <S2SV_ModStart> f ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & fanout_mutex ) ; } 
588,"<S2SV_StartBug> void vp9_predict_intra_block ( const MACROBLOCKD * xd , int block_idx , int bwl_in , <S2SV_EndBug> <S2SV_StartBug> TX_SIZE tx_size , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const int bwl = bwl_in - tx_size ; <S2SV_EndBug> <S2SV_StartBug> const int wmask = ( 1 << bwl ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> const int have_top = ( block_idx >> bwl ) || xd -> up_available ; <S2SV_EndBug> <S2SV_StartBug> const int have_left = ( block_idx & wmask ) || xd -> left_available ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> bw <S2SV_ModEnd> <S2SV_ModStart> bwl_in ) ; const int txw = ( 1 << tx_size ) <S2SV_ModEnd> <S2SV_ModStart> loff <S2SV_ModEnd> <S2SV_ModStart> aoff || xd -> left_available ; const int have_right = ( aoff + txw ) < bw ; const int x = aoff * 4 ; const int y = loff * 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { build_intra_predictors_high ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane , xd -> bd ) ; return ; } # endif <S2SV_ModEnd> "
589,"<S2SV_StartBug> z . kind = 0 ; <S2SV_EndBug> <S2SV_StartBug> # define PARSE_STRING s = parse_field ( ndo , & parse , & parselen ) ; if ( ! s ) lose = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( lose ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int truncated = 0 ; <S2SV_ModStart> , & truncated ) ; if ( truncated ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ; return ; "
590,"<S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> 
591,"<S2SV_StartBug> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MagickPathExtent ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
592,<S2SV_StartBug> for ( i = 0 ; i < len ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> ,"<S2SV_ModStart> && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> <S2SV_ModStart> if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> break ; } else <S2SV_ModStart> if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> "
593,"<S2SV_StartBug> void rdp_read_flow_control_pdu ( wStream * s , UINT16 * type ) <S2SV_EndBug> <S2SV_StartBug> UINT8 pduType ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! type ) return FALSE ; if ( Stream_GetRemainingLength ( s ) < 6 ) return FALSE <S2SV_ModStart> return TRUE ; 
594,"<S2SV_StartBug> ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep ) <S2SV_EndBug> <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> } if ( ep2 <S2SV_ModEnd> <S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> if ( ! <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) { <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> trunc : return NULL ; "
595,<S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
596,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen = args -> valuelen ; 
597,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
598,<S2SV_StartBug> while ( bin ) <S2SV_EndBug> <S2SV_StartBug> numones -= 1 ; <S2SV_EndBug> ,<S2SV_ModStart> && ( numones <= 16 ) <S2SV_ModStart>  <S2SV_ModEnd> 
599,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
600,"<S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( bp ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""0x%08x"" , EXTRACT_32BITS ( bp ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""v%d"" , * bp ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>?0x%04x?"" , EXTRACT_16BITS ( bp + 2 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( olen != 2 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } <S2SV_ModStart> if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } <S2SV_ModStart> if ( olen != 4 ) { ND_PRINT ( ( ndo , ""ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)"" , olen ) ) ; } else { <S2SV_ModStart> } "
601,<S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( node -> nd_item . ci_parent ) <S2SV_ModStart> else return NULL ; 
602,<S2SV_StartBug> int64_t cur_offset = avio_tell ( pb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , ""Empty<S2SV_blank>audio<S2SV_blank>Packet\\n"" ) ; return AVERROR ( EINVAL ) ; } "
603,<S2SV_StartBug> if ( count >= 4 ) { <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
604,<S2SV_StartBug> } else { <S2SV_EndBug> ,"<S2SV_ModStart> { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } } "
605,"<S2SV_StartBug> ep = ( const u_char * ) ndo -> ndo_snapend ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( pim -> pim_rsv ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>RFC2117-encoding"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( PIM_TYPE ( pim -> pim_typever ) ) { <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 4 + olen ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ptr < ( bp + olen ) ) { <S2SV_EndBug> <S2SV_StartBug> advance = pimv2_addr_print ( ndo , ptr , pimv2_unicast , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> bp += olen ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( bp + 4 ) , PIMV2_REGISTER_FLAG_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> EXTRACT_32BITS ( bp + 4 ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> bp += 8 ; len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> switch ( IP_V ( ip ) ) { <S2SV_EndBug> <S2SV_StartBug> case 0 : <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; len -= 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp + 4 > ep ) <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp + 4 > ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_source , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> jp_done : <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( bp + 1 >= ep ) break ; <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) break ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp + 1 >= ep ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , <S2SV_EndBug> <S2SV_StartBug> if ( bp + 1 >= ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp + 2 >= ep ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> bs_done : <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; len -= 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) <S2SV_EndBug> <S2SV_StartBug> bp += 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( bp + 1 >= ep ) break ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bp >= ep ) break ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>grp="" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_group , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>forwarder="" ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( advance = pimv2_addr_print ( ndo , bp , pimv2_unicast , 0 ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> int pimv2_addr_len ; <S2SV_ModStart> if ( len < 2 ) goto trunc ; <S2SV_ModStart> ) ; if ( len < 4 ) goto trunc ; ND_TCHECK ( pim -> pim_cksum <S2SV_ModStart> bp += 4 ; len -= 4 ; <S2SV_ModStart> while ( len > 0 ) { if ( len < 4 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>Value:<S2SV_blank>"" , tok2str ( pimv2_hello_option_values , ""Unknown"" , otype ) , otype , olen ) ) ; bp += 4 ; len -= 4 ; if ( len < olen ) goto trunc ; <S2SV_ModStart> olen ) <S2SV_ModEnd> <S2SV_ModStart> u_int plen = len ; <S2SV_ModStart> plen , pimv2_unicast , pimv2_addr_len , 0 ) ; if ( advance < 0 ) goto trunc ; ptr += advance ; plen -= <S2SV_ModEnd> <S2SV_ModStart> olen ; len -= <S2SV_ModStart> if ( len < 4 ) goto trunc ; <S2SV_ModStart> bp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 ; if ( len == 0 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( ip -> ip_vhl ) ; <S2SV_ModStart> ND_TCHECK ( ip -> ip_dst ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>group="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance <S2SV_ModEnd> <S2SV_ModStart> advance ; ND_PRINT ( ( ndo , ""<S2SV_blank>source="" <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len < 4 ) goto trunc ; ND_TCHECK2 ( * bp , 4 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len < 4 ) goto trunc ; ND_TCHECK2 ( * bp , 4 ) ; <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>tag=%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> len < 2 ) goto trunc ; ND_TCHECK ( bp [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> len -= 2 <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModEnd> <S2SV_ModStart> len < 2 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRPcnt=%d"" , frpcnt = bp [ 1 ] ) ) ; if ( len < 4 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> 4 ; len -= <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp ) ; <S2SV_ModEnd> <S2SV_ModStart> len < 3 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , "",prio=%d"" , bp [ 2 ] ) ) ; if ( len < 4 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> len -= 4 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>group="" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance <S2SV_ModEnd> <S2SV_ModStart> advance ; ND_PRINT ( ( ndo , ""<S2SV_blank>src="" <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len < 8 ) goto trunc ; ND_TCHECK2 ( * bp , 8 ) <S2SV_ModEnd> <S2SV_ModStart> if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> len < 2 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>prio=%d"" , bp [ 1 ] ) ) ; if ( len < 4 ) goto trunc ; ND_TCHECK_16BITS <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>holdtime="" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) <S2SV_ModStart> len -= 4 <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; <S2SV_ModStart> len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; <S2SV_ModStart> len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> len -= advance ; if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp <S2SV_ModEnd> "
606,<S2SV_StartBug> if ( p -> selFlags & SF_UsesEphemeral ) { <S2SV_EndBug> ,<S2SV_ModStart> pParse -> nErr ) goto multi_select_end ; if ( 
607,<S2SV_StartBug> struct fscrypt_info * ci = inode -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ci || <S2SV_EndBug> ,"<S2SV_ModStart> crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> <S2SV_ModStart> ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n"" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> "
608,"<S2SV_StartBug> vp9_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , & p -> eobs [ block ] , scan , iscan ) ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_quantize_b <S2SV_ModEnd> <S2SV_ModStart> & p -> eobs [ block ] , scan , iscan ) ; return ; } # endif vpx_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant <S2SV_ModEnd> "
609,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } 
610,"<S2SV_StartBug> CRM_LOG_ASSERT ( client_obj -> request_id ) ; <S2SV_EndBug> <S2SV_StartBug> rid , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( client_obj -> ipc ) { <S2SV_ModStart> } else { crm_trace ( ""Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s"" , client_obj -> name , from_peer ? ""(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)"" : """" ) ; } "
611,"<S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , "
612,<S2SV_StartBug> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) <S2SV_EndBug> ,<S2SV_ModStart> fp && 
613,<S2SV_StartBug> int i ; <S2SV_EndBug> ,"<S2SV_ModStart> ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user ) "
614,"<S2SV_StartBug> ""vm_enabled:%d\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> server . vm_enabled != 0 , <S2SV_EndBug> <S2SV_StartBug> if ( server . vm_enabled ) { <S2SV_EndBug> <S2SV_StartBug> ""vm_conf_max_memory:%llu\\r\\n"" <S2SV_EndBug> <S2SV_StartBug> , ( unsigned long long ) server . vm_max_memory , <S2SV_EndBug> <S2SV_StartBug> ( unsigned long long ) server . vm_page_size , <S2SV_EndBug> ","<S2SV_ModStart> ""ds_enabled:%d\\r\\n"" <S2SV_ModEnd> <S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> ""cache_max_memory:%llu\\r\\n"" ""cache_blocked_clients:%lu\\r\\n"" <S2SV_ModEnd> <S2SV_ModStart> cache_max_memory <S2SV_ModEnd> <S2SV_ModStart> ) server . cache_blocked_clients <S2SV_ModEnd> "
615,"<S2SV_StartBug> p = strchr ( context -> buffer , \'\\""\' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
616,"<S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> ","<S2SV_ModStart> , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> "
617,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
618,<S2SV_StartBug> img -> bps = 12 ; <S2SV_EndBug> ,<S2SV_ModStart> bit_depth = 8 ; img -> 
619,<S2SV_StartBug> s = & pit_state -> channels [ addr ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( addr == 3 ) return 0 ; 
620,"<S2SV_StartBug> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ! dev_name || 
621,"<S2SV_StartBug> int i , n_items , end_lineno , end_col_offset ; <S2SV_EndBug> <S2SV_StartBug> REQ ( n , with_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> n_items = ( NCH ( n ) - 2 ) / 2 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 1 ; i < NCH ( n ) - 2 ; i += 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncWith ( items , body , LINENO ( n0 ) , n0 -> n_col_offset , <S2SV_EndBug> <S2SV_StartBug> return With ( items , body , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> nch_minus_type , has_type_comment , <S2SV_ModStart> string type_comment ; <S2SV_ModStart> has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ; nch_minus_type = NCH ( n ) - has_type_comment ; <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> nch_minus_type <S2SV_ModEnd> <S2SV_ModStart> has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> type_comment , <S2SV_ModStart> , type_comment "
622,"<S2SV_StartBug> while ( * s && * s != \'\\""\' ) <S2SV_EndBug> <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) 
623,"<S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 4 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> ; if ( i + 4 + optlen > length ) return - 1 
624,"<S2SV_StartBug> if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""xxxx"" ; <S2SV_ModEnd> <S2SV_ModStart> length = 4 <S2SV_ModEnd> "
625,"<S2SV_StartBug> s -> off = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> 
626,"<S2SV_StartBug> ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> } 
627,<S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> optimal_buffer_level / 100 ) ; <S2SV_EndBug> ,<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> 
628,<S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> <S2SV_StartBug> tp -> e_name = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> 
629,"<S2SV_StartBug> static int can_open_cached ( struct nfs4_state * state , int mode ) <S2SV_EndBug> <S2SV_StartBug> switch ( mode & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> fmode_t mode , int open_mode <S2SV_ModEnd> <S2SV_ModStart> if ( open_mode & O_EXCL ) goto out ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out : "
630,<S2SV_StartBug> if ( src < ( uint8_t * ) buf || src > ( uint8_t * ) buf + buf_size ) <S2SV_EndBug> ,<S2SV_ModStart> + src_size < src || src + src_size 
631,<S2SV_StartBug> if ( * p == FAC_CCITT_DEST_NSAP ) { <S2SV_EndBug> ,<S2SV_ModStart> l < 10 || l > 20 ) return - 1 ; if ( 
632,<S2SV_StartBug> int nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> 
633,<S2SV_StartBug> if ( len > count ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> 
634,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , tstr <S2SV_ModEnd> "
635,"<S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> ",<S2SV_ModStart> nd -> last_type = LAST_BIND ; 
636,<S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ; 
637,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> ptr = cp [ 2 ] - 1 ; <S2SV_EndBug> <S2SV_StartBug> switch ( cp [ 3 ] & 0xF ) { <S2SV_EndBug> <S2SV_StartBug> type = ""<S2SV_blank>^<S2SV_blank>"" ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> ( 0 ) <S2SV_ModStart> ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> return ( 0 ) ; trunc : return ( - 1 ) ; "
638,<S2SV_StartBug> void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) <S2SV_EndBug> <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> WORD32 <S2SV_ModEnd> <S2SV_ModStart> if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> return 0 ; 
639,<S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else <S2SV_ModEnd> 
640,"<S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
641,"<S2SV_StartBug> int mi_index = 0 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ; <S2SV_EndBug> <S2SV_StartBug> print_mi_data ( cm , mvs , ""Skips:"" , offsetof ( MB_MODE_INFO , skip ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( mvs , ""V<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi_8x8 [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , <S2SV_EndBug> <S2SV_StartBug> mi_index += 8 ; <S2SV_EndBug> <S2SV_StartBug> fclose ( mvs ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> ""Ref<S2SV_blank>frame:"" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ; print_mi_data ( cm , mvs , ""Transform:"" , offsetof ( MB_MODE_INFO , tx_size ) ) ; print_mi_data ( cm , mvs , ""UV<S2SV_blank>Modes:"" , offsetof ( MB_MODE_INFO , uv_mode ) ) ; log_frame_info ( cm , ""Skips:"" <S2SV_ModEnd> <S2SV_ModStart> ""S<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""%2d<S2SV_blank>"" , mi [ 0 <S2SV_ModEnd> <S2SV_ModStart> skip ) ; mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> log_frame_info ( cm , ""Vectors<S2SV_blank>"" , mvs ) ; mi = cm -> mi_grid_visible ; for ( mi_row = 0 ; mi_row < rows ; mi_row ++ ) { fprintf ( mvs , ""V<S2SV_blank>"" ) ; for ( mi_col = 0 ; mi_col < cols ; mi_col ++ ) { fprintf ( mvs , ""%4d:%4d<S2SV_blank>"" , mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv . col ) ; mi ++ ; } fprintf ( mvs , ""\\n"" ) ; mi += 8 ; } fprintf ( mvs , ""\\n"" ) ; "
642,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\n"" ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> child = ( pid_t ) - 1 ; <S2SV_ModStart> && child != ( pid_t ) - 1 <S2SV_ModStart> if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> } 
643,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ; 
644,<S2SV_StartBug> return le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ; 
645,"<S2SV_StartBug> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> - EINVAL <S2SV_ModEnd> 
646,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> found = cm -> width == cfg -> y_crop_width && <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> use_svc && ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( cpi -> svc . number_spatial_layers > 1 && cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . is_key_frame ) || ( is_two_pass_svc ( cpi ) && cpi -> svc . encode_empty_frame_state == ENCODING && cpi -> svc . layer_context [ 0 ] . frames_from_key_frame < cpi -> svc . number_temporal_layers + 1 ) ) ) { found = 0 ; } else if ( cfg != NULL ) { <S2SV_ModStart> } vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
647,<S2SV_StartBug> BUG_IF ( tree_root == NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> return 0 
648,<S2SV_StartBug> int err ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL 
649,"<S2SV_StartBug> VTermState * state = vterm_allocator_malloc ( vt , sizeof ( VTermState ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( state == NULL ) return NULL 
650,"<S2SV_StartBug> static int _nfs4_do_open ( struct inode * dir , struct path * path , int flags , struct iattr * sattr , struct rpc_cred * cred , struct nfs4_state * * res ) <S2SV_EndBug> <S2SV_StartBug> nfs4_return_incompatible_delegation ( path -> dentry -> d_inode , flags & ( FMODE_READ | FMODE_WRITE ) ) ; <S2SV_EndBug> <S2SV_StartBug> opendata = nfs4_opendata_alloc ( path , sp , flags , sattr ) ; <S2SV_EndBug> ","<S2SV_ModStart> fmode_t fmode , <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> , fmode "
651,<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ; "
652,<S2SV_StartBug> while ( tmp && alen < tmp ) { <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * tptr , alen ) ; "
653,<S2SV_StartBug> libettercap_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( write_output ( ) != E_SUCCESS ) <S2SV_EndBug> ,"<S2SV_ModStart> int ret_value = 0 ; <S2SV_ModStart> ret_value = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled."" , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>"" <S2SV_ModEnd> "
654,"<S2SV_StartBug> printf ( ""%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\n"" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\n"" , ( long long ) <S2SV_ModEnd> <S2SV_ModStart> ( long long ) "
655,"<S2SV_StartBug> static void update_stats ( VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> const int seg_ref_active = vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , <S2SV_EndBug> <S2SV_StartBug> FRAME_COUNTS * const counts = & cm -> counts ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , ThreadData * td ) { const MACROBLOCK * x = & td <S2SV_ModEnd> <S2SV_ModStart> const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const BLOCK_SIZE bsize = mbmi -> sb_type ; <S2SV_ModStart> FRAME_COUNTS * const counts = td -> counts ; const int inter_block = is_inter_block ( mbmi ) ; <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( inter_block && ! segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) { const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ; if ( bsize >= BLOCK_8X8 ) { const PREDICTION_MODE mode = mbmi -> mode ; ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int j = idy * 2 + idx ; const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ; ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ; } } } } "
656,"<S2SV_StartBug> attach_shadowed ( mnt , parent , shadows ) ; <S2SV_EndBug> ",<S2SV_ModStart> n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ; 
657,<S2SV_StartBug> const char * errstr ; <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> # if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) <S2SV_ModStart> = NULL ; # else int status ; # endif <S2SV_ModEnd> <S2SV_ModStart> if ( errstr ) return - 1 ; # else status = <S2SV_ModEnd> <S2SV_ModStart> if ( status != 1 <S2SV_ModEnd> <S2SV_ModStart> # endif 
658,"<S2SV_StartBug> SkipRGBMipmaps ( image , dds_info , 3 ) ; <S2SV_EndBug> ","<S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
659,"<S2SV_StartBug> void vp9_fht8x8_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct8x8_sse2 ( input , output , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct8x8_sse2 <S2SV_ModEnd> 
660,"<S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; } "
661,"<S2SV_StartBug> if ( osStrlen ( topicName ) == 2 && strchr ( topicName , '#' ) == NULL && <S2SV_EndBug> <S2SV_StartBug> strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
662,"<S2SV_StartBug> len = min_t ( unsigned int , len , sizeof ( sec ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> sec . key_size = 0 ; 
663,<S2SV_StartBug> if ( ! data ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> || len < 2 ) { <S2SV_ModEnd> <S2SV_ModStart> } 
664,"<S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name ) { const <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
665,"<S2SV_StartBug> size_t input_size , <S2SV_EndBug> <S2SV_StartBug> int max_bytes_matched = input_size ; <S2SV_EndBug> ","<S2SV_ModStart> input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> "
666,"<S2SV_StartBug> void vp9_rc_init ( const VP9_CONFIG * oxcf , int pass , RATE_CONTROL * rc ) { <S2SV_EndBug> <S2SV_StartBug> if ( pass == 0 && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 0 ] = oxcf -> worst_allowed_q ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 1 ] = oxcf -> worst_allowed_q ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 0 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 1 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 2 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> <S2SV_StartBug> rc -> last_q [ 0 ] = oxcf -> best_allowed_q ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> int i ; <S2SV_ModStart> rc_mode == VPX_CBR <S2SV_ModEnd> <S2SV_ModStart> KEY_FRAME <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME <S2SV_ModEnd> <S2SV_ModStart> KEY_FRAME <S2SV_ModEnd> <S2SV_ModStart> INTER_FRAME <S2SV_ModEnd> <S2SV_ModStart> } rc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; rc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; rc -> buffer_level = rc -> starting_buffer_level ; rc -> bits_off_target = rc -> starting_buffer_level ; rc -> rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> total_actual_bits = 0 ; rc -> total_target_bits = 0 ; rc -> total_target_vs_actual = 0 ; rc -> frames_since_key = 8 ; rc -> this_key_frame_forced = 0 ; rc -> next_key_frame_forced = 0 ; rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 0 ; rc -> frames_till_gf_update_due = 0 ; rc -> ni_av_qi = oxcf -> worst_allowed_q ; rc -> ni_tot_qi = 0 ; rc -> ni_frames = 0 ; rc -> tot_q = 0.0 ; rc -> avg_q = vp9_convert_qindex_to_q ( oxcf -> worst_allowed_q , oxcf -> bit_depth ) ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { rc -> rate_correction_factors [ i ] = 1.0 ; } rc -> min_gf_interval = oxcf -> min_gf_interval ; rc -> max_gf_interval = oxcf -> max_gf_interval ; if ( rc -> min_gf_interval == 0 ) rc -> min_gf_interval = vp9_rc_get_default_min_gf_interval ( oxcf -> width , oxcf -> height , oxcf -> init_framerate ) ; if ( rc -> max_gf_interval == 0 ) rc -> max_gf_interval = vp9_rc_get_default_max_gf_interval ( oxcf -> init_framerate , rc -> min_gf_interval ) ; rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
667,<S2SV_StartBug> unsigned int array_index_stack [ ARRAY_INDEX_STACK_SIZE ] ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
668,"<S2SV_StartBug> ""session<S2SV_blank>authenticated"" , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> cb_new_auth <S2SV_ModEnd> 
669,"<S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> ",<S2SV_ModStart> & 255 <S2SV_ModStart> & 255 
670,"<S2SV_StartBug> static MB_PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> const int mode = vp9_read_tree ( r , vp9_inter_mode_tree , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . inter_mode_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> "
671,<S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,"<S2SV_ModStart> info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
672,"<S2SV_StartBug> static void optimize_b ( int plane , int block , BLOCK_SIZE plane_bsize , <S2SV_EndBug> <S2SV_StartBug> TX_SIZE tx_size , MACROBLOCK * mb , <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & mb -> plane [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * coeff = BLOCK_OFFSET ( mb -> plane [ plane ] . coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int eob = p -> eobs [ block ] , final_eob , sz = 0 ; <S2SV_EndBug> <S2SV_StartBug> PLANE_TYPE type = pd -> plane_type ; <S2SV_EndBug> <S2SV_StartBug> uint8_t token_cache [ 1024 ] ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * dequant_ptr = pd -> dequant ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * scan = so -> scan ; <S2SV_EndBug> <S2SV_StartBug> rdmult = mb -> rdmult * err_mult ; <S2SV_EndBug> <S2SV_StartBug> if ( ! is_inter_block ( & mb -> e_mbd . mi [ 0 ] -> mbmi ) ) <S2SV_EndBug> <S2SV_StartBug> rddiv = mb -> rddiv ; <S2SV_EndBug> <S2SV_StartBug> * ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ; <S2SV_EndBug> <S2SV_StartBug> token_cache [ scan [ i ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ <S2SV_EndBug> <S2SV_StartBug> qcoeff [ scan [ i ] ] ] . token ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = eob ; i -- > i0 ; ) { <S2SV_EndBug> <S2SV_StartBug> rc = scan [ i ] ; <S2SV_EndBug> <S2SV_StartBug> x = qcoeff [ rc ] ; <S2SV_EndBug> <S2SV_StartBug> t0 = ( vp9_dct_value_tokens_ptr + x ) -> token ; <S2SV_EndBug> <S2SV_StartBug> base_bits = * ( vp9_dct_value_cost_ptr + x ) ; <S2SV_EndBug> <S2SV_StartBug> dx = mul * ( dqcoeff [ rc ] - coeff [ rc ] ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> t0 = t1 = ( vp9_dct_value_tokens_ptr + x ) -> token ; <S2SV_EndBug> <S2SV_StartBug> base_bits = * ( vp9_dct_value_cost_ptr + x ) ; <S2SV_EndBug> <S2SV_StartBug> if ( shortcut ) { <S2SV_EndBug> <S2SV_StartBug> dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; <S2SV_EndBug> <S2SV_StartBug> pt = combine_entropy_contexts ( * a , * l ) ; <S2SV_EndBug> <S2SV_StartBug> rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t0 ] ; <S2SV_EndBug> <S2SV_StartBug> rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t1 ] ; <S2SV_EndBug> <S2SV_StartBug> final_eob = i0 - 1 ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( qcoeff , 0 , sizeof ( * qcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dqcoeff , 0 , sizeof ( * dqcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> x = tokens [ i ] [ best ] . qc ; <S2SV_EndBug> <S2SV_StartBug> if ( x ) { <S2SV_EndBug> <S2SV_StartBug> rc = scan [ i ] ; <S2SV_EndBug> <S2SV_StartBug> * a = * l = ( final_eob > 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> int optimize_b ( MACROBLOCK * mb , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int ctx <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart> uint8_t token_cache [ 1024 ] ; const tran_low_t * const <S2SV_ModEnd> <S2SV_ModStart> tran_low_t * const <S2SV_ModEnd> <S2SV_ModStart> tran_low_t * const <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; const <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const int16_t * dequant_ptr = pd -> dequant ; const uint8_t * const band_translate = get_band_translate ( tx_size ) ; const scan_order * const so = get_scan ( xd , tx_size , type , block ) <S2SV_ModEnd> <S2SV_ModStart> const scan = so -> scan ; const int16_t * const nb = so -> neighbors ; int next = eob , sz = 0 ; int64_t rdmult = mb -> rdmult * plane_rd_mult [ type ] , rddiv = mb -> rddiv ; int64_t rd_cost0 , rd_cost1 ; int rate0 , rate1 , error0 , error1 ; int16_t t0 , t1 ; EXTRABIT e0 ; int best , band , pt , i , final_eob ; # if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; # else <S2SV_ModEnd> <S2SV_ModStart> cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; # endif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> [ 1 ] = <S2SV_ModEnd> <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> vp9_get_token ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> const int <S2SV_ModStart> int <S2SV_ModStart> vp9_get_token_extra ( x , & t0 , & e0 ) <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( t0 , e0 , cat6_high_cost <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { dx >>= xd -> bd - 8 ; } # endif <S2SV_ModStart> e0 = 0 ; <S2SV_ModStart> vp9_get_token_extra ( x , & t0 , & e0 ) ; t1 = t0 <S2SV_ModEnd> <S2SV_ModStart> vp9_get_cost ( t0 , e0 , cat6_high_cost <S2SV_ModEnd> <S2SV_ModStart> ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH <S2SV_ModStart> ( <S2SV_ModStart> >> ( xd -> bd - 8 ) ) <S2SV_ModStart> } else { dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; } # else dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx <S2SV_ModEnd> <S2SV_ModStart> ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> const int <S2SV_ModStart> const int rc = scan [ i ] ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return final_eob <S2SV_ModEnd> "
673,"<S2SV_StartBug> int vp9_decode_block_tokens ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> int plane , int block , BLOCK_SIZE plane_bsize , <S2SV_EndBug> <S2SV_StartBug> int x , int y , TX_SIZE tx_size , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_EndBug> <S2SV_StartBug> const scan_order * so = get_scan ( xd , tx_size , pd -> plane_type , block ) ; <S2SV_EndBug> <S2SV_StartBug> const int eob = decode_coefs ( cm , xd , pd -> plane_type , <S2SV_EndBug> <S2SV_StartBug> BLOCK_OFFSET ( pd -> dqcoeff , block ) , tx_size , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , ctx , so -> scan , so -> neighbors , r ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_set_contexts ( xd , pd , plane_bsize , tx_size , eob > 0 , x , y ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const scan_order * sc <S2SV_ModEnd> <S2SV_ModStart> vpx_reader * r , int seg_id <S2SV_ModEnd> <S2SV_ModStart> ] ; const int16_t * const dequant = pd -> seg_dequant [ seg_id <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tx_size , <S2SV_ModEnd> <S2SV_ModStart> sc <S2SV_ModEnd> <S2SV_ModStart> sc <S2SV_ModEnd> <S2SV_ModStart> dec_set_contexts <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
674,"
","
"
675,<S2SV_StartBug> free_called += 1 ; <S2SV_EndBug> ,<S2SV_ModStart> = <S2SV_ModEnd> 
676,<S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> ,<S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> 
677,<S2SV_StartBug> goto err_unregister_v4l2_dev ; <S2SV_EndBug> <S2SV_StartBug> err_unregister_v4l2_dev : <S2SV_EndBug> ,<S2SV_ModStart> err_free_controls <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
678,<S2SV_StartBug> max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; <S2SV_EndBug> <S2SV_StartBug> max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( CheckMemoryOverflow <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } "
679,<S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> ,<S2SV_ModStart> HAVE_LZMA_H <S2SV_ModEnd> 
680,"<S2SV_StartBug> mcryptd_check_internal ( tb , & type , & mask ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return - EINVAL 
681,"<S2SV_StartBug> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <S2SV_EndBug> <S2SV_StartBug> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { <S2SV_EndBug> <S2SV_StartBug> case TEE_PARAM_TYPE_MEMREF_INPUT : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> <S2SV_ModStart> uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> <S2SV_ModStart> if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> return TEE_SUCCESS ; "
682,"<S2SV_StartBug> mcryptd_check_internal ( tb , & type , & mask ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return - EINVAL 
683,<S2SV_StartBug> void fdct8_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) 
684,"<S2SV_StartBug> if ( output ) <S2SV_EndBug> <S2SV_StartBug> strcpy ( output , ( const char * ) output_u8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t len = strlen ( ( char * ) output_u8 ) ; if ( len > 63 ) { free ( output_u8 ) ; return IDN2_TOO_BIG_DOMAIN ; } <S2SV_ModStart>  <S2SV_ModEnd> 
685,<S2SV_StartBug> if ( ! unconditional ( & e -> ip ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
686,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
687,<S2SV_StartBug> if ( key_is_instantiated ( keyring ) ) { <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
688,"<S2SV_StartBug> int isopen ; <S2SV_EndBug> <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> ","<S2SV_ModStart> base_size ; int <S2SV_ModStart> base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> base_size ; if ( base_size / npts != <S2SV_ModStart> || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> "
689,"<S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> ) return FALSE <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE ; } return TRUE ; <S2SV_ModEnd> 
690,<S2SV_StartBug> * ( * fill ) ++ = suffix [ code ] ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( code >= clear ) { fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n"" , code , clear ) ; return 0 ; } "
691,<S2SV_StartBug> if ( ! from_buffer ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
692,<S2SV_StartBug> char added ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
693,"<S2SV_StartBug> separator = strchr ( context -> buffer , ':' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
694,"<S2SV_StartBug> if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . content = fi ; <S2SV_EndBug> <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . control = fi ; <S2SV_EndBug> <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . spaninfo = fi ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> name_len == 40 && memcmp ( name , content_name , 40 <S2SV_ModEnd> <S2SV_ModStart> chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> <S2SV_ModStart> control <S2SV_ModEnd> <S2SV_ModStart> name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> <S2SV_ModStart> spaninfo <S2SV_ModEnd> <S2SV_ModStart> name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
695,"<S2SV_StartBug> void generate_filename ( const char * pattern , char * out , size_t q_len , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> break ; 
696,"<S2SV_StartBug> if ( args -> skip ) <S2SV_EndBug> <S2SV_StartBug> if ( ! is_inter_block ( mbmi ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_encode_block_intra ( x , plane , block , plane_bsize , tx_size , & mbmi -> skip ) ; <S2SV_EndBug> <S2SV_StartBug> dist_block ( plane , block , tx_size , args ) ; <S2SV_EndBug> <S2SV_StartBug> rd1 = RDCOST ( x -> rdmult , x -> rddiv , args -> rate , args -> dist ) ; <S2SV_EndBug> <S2SV_StartBug> rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , args -> sse ) ; <S2SV_EndBug> <S2SV_StartBug> args -> this_rate += args -> rate ; <S2SV_EndBug> <S2SV_StartBug> args -> this_dist += args -> dist ; <S2SV_EndBug> <S2SV_StartBug> args -> this_sse += args -> sse ; <S2SV_EndBug> <S2SV_StartBug> args -> skip = 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int rate ; int64_t dist ; int64_t sse ; if ( args -> exit_early <S2SV_ModEnd> <S2SV_ModStart> { struct encode_b_args arg = { x , NULL , & mbmi -> skip } ; vp9_encode_block_intra ( <S2SV_ModEnd> <S2SV_ModStart> arg ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } else if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_NONE ) { <S2SV_ModEnd> <S2SV_ModStart> x , plane , block , tx_size , & dist , & sse ) ; } else if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_AC_ONLY ) { tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ plane ] . coeff , block ) ; tran_low_t * const dqcoeff = BLOCK_OFFSET ( xd -> plane [ plane ] . dqcoeff , block ) ; vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; if ( x -> plane [ plane ] . eobs [ block ] ) { const int64_t orig_sse = ( int64_t ) coeff [ 0 ] * coeff [ 0 ] ; const int64_t resd_sse = coeff [ 0 ] - dqcoeff [ 0 ] ; int64_t dc_correct = orig_sse - resd_sse * resd_sse ; # if CONFIG_VP9_HIGHBITDEPTH dc_correct >>= ( ( xd -> bd - 8 ) * 2 ) ; # endif if ( tx_size != TX_32X32 ) dc_correct >>= 2 ; dist = MAX ( 0 , sse - dc_correct ) ; } } else { x -> plane [ plane ] . eobs [ block ] = 0 ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , dist ) ; if ( args -> this_rd + rd > args -> best_rd ) { args -> exit_early = 1 ; return ; } rate = <S2SV_ModEnd> <S2SV_ModStart> rate , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> exit_early <S2SV_ModEnd> <S2SV_ModStart> args -> skippable &= ! x -> plane [ plane ] . eobs [ block ] ; "
697,"<S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) <S2SV_EndBug> <S2SV_StartBug> ""InsufficientImageDataInFile"" , image -> filename ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> <S2SV_ModStart> ""UnexpectedEndOfFile"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
698,"<S2SV_StartBug> u8 * gb_cur , * version_tlv , version , version_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += version_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += lto_length ; <S2SV_EndBug> <S2SV_StartBug> gb_len += wks_length ; <S2SV_EndBug> <S2SV_StartBug> & miux_length ) ; <S2SV_EndBug> ","<S2SV_ModStart> version , version_length ; u8 lto_length , wks_length , miux_length ; u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ! version_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! lto_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! wks_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> if ( ! miux_tlv ) { ret = - ENOMEM ; goto out ; } "
699,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; 
700,"<S2SV_StartBug> mrb_value value ; <S2SV_EndBug> <S2SV_StartBug> fiber_check_cfunc ( mrb , c ) ; <S2SV_EndBug> <S2SV_StartBug> if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_TERMINATED ) { <S2SV_EndBug> <S2SV_StartBug> mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <S2SV_EndBug> <S2SV_StartBug> if ( c -> status == MRB_FIBER_CREATED ) { <S2SV_EndBug> <S2SV_StartBug> if ( len >= c -> stend - c -> stack ) { <S2SV_EndBug> <S2SV_StartBug> fiber_switch_context ( mrb , c ) ; <S2SV_EndBug> ","<S2SV_ModStart> enum mrb_fiber_state status ; <S2SV_ModStart> ; status = c -> status <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> old_c <S2SV_ModEnd> <S2SV_ModStart> fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
701,<S2SV_StartBug> uint_t i ; <S2SV_EndBug> <S2SV_StartBug> if ( length < sizeof ( DhcpMessage ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> if ( option -> code == DHCP_OPT_END ) <S2SV_EndBug> <S2SV_StartBug> if ( ( i + 1 ) >= length || ( i + 1 + option -> length ) >= length ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> { } else <S2SV_ModEnd> <S2SV_ModStart> ) { break ; } else { if ( ( i + 1 ) >= length <S2SV_ModStart> sizeof ( DhcpOption ) <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> } } 
702,<S2SV_StartBug> ipv6_select_ident ( fptr ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , ( struct rt6_info * ) skb_dst ( skb ) "
703,"<S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> - <S2SV_ModStart> - 
704,<S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> ,<S2SV_ModStart> status = MagickFalse ; break <S2SV_ModEnd> 
705,<S2SV_StartBug> int i ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> 
706,<S2SV_StartBug> struct iovec * iovec ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> <S2SV_ModStart> iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ; "
707,<S2SV_StartBug> if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & 
708,<S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug> ,<S2SV_ModStart> static 
709,<S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
710,"<S2SV_StartBug> # line 496 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 861 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 558 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 855 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 607 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 708 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> if ( incomplete_class ) { <S2SV_EndBug> <S2SV_StartBug> # line 785 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 699 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> return object_common2 ( UNSERIALIZE_PASSTHRU , <S2SV_EndBug> <S2SV_StartBug> object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 819 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 678 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 861 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 643 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 917 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 610 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 971 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 600 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1069 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 585 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1143 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 558 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1197 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 551 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1212 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 544 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1222 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 521 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1268 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 500 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1312 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 863 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> ","<S2SV_ModStart> 501 <S2SV_ModEnd> <S2SV_ModStart> 875 <S2SV_ModEnd> <S2SV_ModStart> 563 <S2SV_ModEnd> <S2SV_ModStart> 869 <S2SV_ModEnd> <S2SV_ModStart> 612 <S2SV_ModEnd> <S2SV_ModStart> 717 <S2SV_ModEnd> <S2SV_ModStart> elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> 795 <S2SV_ModEnd> <S2SV_ModStart> 704 ""ext/standard/var_unserializer.re"" { long elements ; <S2SV_ModEnd> <S2SV_ModStart> elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <S2SV_ModStart> elements <S2SV_ModEnd> <S2SV_ModStart> 833 <S2SV_ModEnd> <S2SV_ModStart> 683 <S2SV_ModEnd> <S2SV_ModStart> 875 <S2SV_ModEnd> <S2SV_ModStart> 648 <S2SV_ModEnd> <S2SV_ModStart> 931 <S2SV_ModEnd> <S2SV_ModStart> 615 <S2SV_ModEnd> <S2SV_ModStart> 985 <S2SV_ModEnd> <S2SV_ModStart> 605 <S2SV_ModEnd> <S2SV_ModStart> 1083 <S2SV_ModEnd> <S2SV_ModStart> 590 <S2SV_ModEnd> <S2SV_ModStart> 1157 <S2SV_ModEnd> <S2SV_ModStart> 563 <S2SV_ModEnd> <S2SV_ModStart> 1211 <S2SV_ModEnd> <S2SV_ModStart> 556 <S2SV_ModEnd> <S2SV_ModStart> 1226 <S2SV_ModEnd> <S2SV_ModStart> 549 <S2SV_ModEnd> <S2SV_ModStart> 1236 <S2SV_ModEnd> <S2SV_ModStart> 526 <S2SV_ModEnd> <S2SV_ModStart> 1282 <S2SV_ModEnd> <S2SV_ModStart> 505 <S2SV_ModEnd> <S2SV_ModStart> 1326 <S2SV_ModEnd> <S2SV_ModStart> 877 <S2SV_ModEnd> "
711,"<S2SV_StartBug> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
712,<S2SV_StartBug> * ( * fill ) ++ = suffix [ code ] ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( code >= clear ) { fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n"" , code , clear ) ; return 0 ; } "
713,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
714,<S2SV_StartBug> p -> exit_signal = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( clone_flags & CLONE_PARENT ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ; else p -> exit_signal = current -> group_leader -> exit_signal ; <S2SV_ModStart> p -> exit_signal = args -> exit_signal ; 
715,"<S2SV_StartBug> const u_char * ep , uint32_t phase , uint32_t doi0 _U_ , <S2SV_EndBug> <S2SV_StartBug> uint32_t proto0 _U_ , int depth ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ; <S2SV_EndBug> <S2SV_StartBug> size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case IPSECDOI_NTYPE_REPLAY_STATUS : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> isakmp_print ( ndo , cp , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> _U_ <S2SV_ModStart> _U_ <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) <S2SV_ModStart> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , "")"" ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } "
716,"<S2SV_StartBug> iframe -> iv = nghttp2_mem_malloc ( mem , sizeof ( nghttp2_settings_entry ) * <S2SV_EndBug> ","<S2SV_ModStart> if ( iframe -> max_niv - 1 > session -> max_settings ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_ENHANCE_YOUR_CALM , ""SETTINGS:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>setting<S2SV_blank>entries"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } "
717,"<S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
718,<S2SV_StartBug> data -> o_arg . open_flags ) ; <S2SV_EndBug> ,<S2SV_ModStart> fmode <S2SV_ModEnd> 
719,"<S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> ; if ( components < 0 ) break 
720,<S2SV_StartBug> if ( ! static_key_enabled ( work -> key ) ) <S2SV_EndBug> ,<S2SV_ModStart> BUG_ON <S2SV_ModEnd> <S2SV_ModStart> ; static_key_slow_dec <S2SV_ModEnd> 
721,<S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> ,<S2SV_ModStart> errout_free <S2SV_ModEnd> <S2SV_ModStart> errout_free : 
722,"<S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) "
723,"<S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
724,<S2SV_StartBug> * ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> _x2c <S2SV_ModEnd> 
725,"<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ",<S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> 
726,"<S2SV_StartBug> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> if ( size > urb -> transfer_buffer_length ) { <S2SV_ModEnd> <S2SV_ModStart> return 0 ; <S2SV_ModStart> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } } "
727,<S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ; "
728,"<S2SV_StartBug> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> strlcpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> 
729,<S2SV_StartBug> cJSON * c ; <S2SV_EndBug> ,"<S2SV_ModStart> return cJSON_ParseWithOpts ( value , 0 , 0 ) ; <S2SV_ModEnd> "
730,<S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; } 
731,<S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers 
732,<S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> 
733,"<S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , const struct stat * fsb <S2SV_ModStart> uid_t luid = dsb . st_uid ; <S2SV_ModStart> && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> "
734,"<S2SV_StartBug> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; "
735,<S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && in -> data [ plane ] && in -> linesize [ plane ] 
736,"<S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_free_nolock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
737,<S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> ,<S2SV_ModStart> ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> 
738,<S2SV_StartBug> if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> ,"<S2SV_ModStart> print_primaries ( w , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
739,<S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug> ,<S2SV_ModStart> s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 
740,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff "
741,<S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> ,<S2SV_ModStart> return 
742,<S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
743,"<S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug> ",<S2SV_ModStart> check_stack_depth ( ) ; 
744,<S2SV_StartBug> struct sock * sk ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL 
745,<S2SV_StartBug> static void usage ( char * progname ) { <S2SV_EndBug> <S2SV_StartBug> progname ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> exec_name <S2SV_ModEnd> 
746,"<S2SV_StartBug> int watchdog = 0 ; <S2SV_EndBug> <S2SV_StartBug> num = SSL_shutdown ( c -> ssl ) ; <S2SV_EndBug> <S2SV_StartBug> err = SSL_get_error ( c -> ssl , ( int ) num ) ; <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_WANT_WRITE : <S2SV_EndBug> <S2SV_StartBug> num = writesocket ( c -> sock_wfd -> fd , c -> ssl_buff , c -> ssl_ptr ) ; <S2SV_EndBug> <S2SV_StartBug> num = readsocket ( c -> sock_rfd -> fd , <S2SV_EndBug> <S2SV_StartBug> write_wants_read = 0 ; <S2SV_EndBug> <S2SV_StartBug> num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> <S2SV_StartBug> if ( num && parse_socket_error ( c , ""SSL_write"" ) ) <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ; <S2SV_EndBug> <S2SV_StartBug> case SSL_ERROR_SSL : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_shutdown"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : <S2SV_ModEnd> <S2SV_ModStart> SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ; <S2SV_ModEnd> <S2SV_ModStart> default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 <S2SV_ModEnd> <S2SV_ModStart> ssize_t <S2SV_ModStart> ssize_t <S2SV_ModStart> int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> SSL_ERROR_SSL : sslerror ( ""SSL_write"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : case <S2SV_ModStart> parse_socket_error ( c , ""SSL_write"" ) && num <S2SV_ModEnd> <S2SV_ModStart> default : s_log ( LOG_ERR , ""SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { int num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; read_wants_read = 0 ; read_wants_write = 0 ; switch ( err = SSL_get_error ( c -> ssl , num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_read"" ) ; throw_exception ( c , 1 ) ; <S2SV_ModStart> ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" <S2SV_ModEnd> <S2SV_ModStart> SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_read"" ) && num <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
747,<S2SV_StartBug> return err ; <S2SV_EndBug> ,<S2SV_ModStart> goto free_data <S2SV_ModEnd> 
748,"<S2SV_StartBug> evas_object_resize ( app_data -> window , DEFAULT_WIDTH , DEFAULT_HEIGHT ) ; <S2SV_EndBug> ","<S2SV_ModStart> window_width , window_height <S2SV_ModEnd> "
749,<S2SV_StartBug> if ( refill_pi_state_cache ( ) ) <S2SV_EndBug> <S2SV_StartBug> goto out_put_key1 ; <S2SV_EndBug> ,"<S2SV_ModStart> uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } "
750,"<S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> ","<S2SV_ModStart> sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> <S2SV_ModStart> param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> <S2SV_ModStart> false <S2SV_ModEnd> <S2SV_ModStart> param . addip <S2SV_ModEnd> <S2SV_ModStart> err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
751,<S2SV_StartBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ; <S2SV_EndBug> <S2SV_StartBug> cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_EndBug> ,<S2SV_ModStart> ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS 
752,<S2SV_StartBug> while ( c != EOF && c != '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> c = tok_nextc ( tok ) ; <S2SV_EndBug> ,"<S2SV_ModStart> const char * prefix , * p , * type_start ; <S2SV_ModStart> } if ( tok -> type_comments ) { p = tok -> start ; prefix = type_comment_prefix ; while ( * prefix && p < tok -> cur ) { if ( * prefix == '<S2SV_blank>' ) { while ( * p == '<S2SV_blank>' || * p == '\\t' ) { p ++ ; } } else if ( * prefix == * p ) { p ++ ; } else { break ; } prefix ++ ; } if ( ! * prefix ) { int is_type_ignore = 1 ; tok_backup ( tok , c ) ; type_start = p ; is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ; p += 6 ; while ( is_type_ignore && p < tok -> cur ) { if ( * p == '#' ) break ; is_type_ignore = is_type_ignore && ( * p == '<S2SV_blank>' || * p == '\\t' ) ; p ++ ; } if ( is_type_ignore ) { if ( blankline ) { tok_nextc ( tok ) ; tok -> atbol = 1 ; } return TYPE_IGNORE ; } else { * p_start = ( char * ) type_start ; * p_end = tok -> cur ; return TYPE_COMMENT ; } } "
753,<S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ; <S2SV_EndBug> ,<S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> alt_ref_source <S2SV_ModEnd> <S2SV_ModStart> alt_ref_source <S2SV_ModEnd> 
754,"<S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_LCIS ) ; <S2SV_EndBug> <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_P1SR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ISR_RXIS ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_RXIS ) ; <S2SV_EndBug> <S2SV_StartBug> frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_REG_RXFCTR ) ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_RXIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_ISR ) ; if ( ( status & KSZ8851_ISR_LCIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR , KSZ8851_ISR_LCIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_P1SR ) ; if ( ( status & KSZ8851_P1SR_LINK_GOOD ) != 0 ) { if ( ( status & KSZ8851_P1SR_OPERATION_SPEED <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_P1SR_OPERATION_DUPLEX <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR_RXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_ISR , KSZ8851_ISR_RXIS <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_RXFCTR <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_RXIE <S2SV_ModEnd> "
755,<S2SV_StartBug> convert_to_double_ex ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> } 
756,<S2SV_StartBug> vp9_free_context_buffers ( cm ) ; <S2SV_EndBug> ,"<S2SV_ModStart> vp9_set_mb_mi ( cm , 0 , 0 ) ; "
757,"<S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( vec , 1 , nr <S2SV_ModEnd> <S2SV_ModStart> * vec = 0 <S2SV_ModEnd> <S2SV_ModStart> * vec = ! ! <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> "
758,"<S2SV_StartBug> buffer = zend_string_alloc ( len , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> "
759,<S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> <S2SV_ModStart> > vdev -> config_len ) { return ; } <S2SV_ModEnd> 
760,"<S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <S2SV_EndBug> ","<S2SV_ModStart> u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> <S2SV_ModStart> , NSEC_PER_SEC , & rem ) <S2SV_ModStart> tv_nsec = rem <S2SV_ModEnd> "
761,<S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> ,<S2SV_ModStart> sanitize_dead_code ( env ) ; if ( ret == 0 ) 
762,<S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> ,<S2SV_ModStart> new_addr = realloc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
763,<S2SV_StartBug> if ( errcode != 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> && state -> status == NULL ) state -> status = ""UNKNOWN_REASON"" <S2SV_ModEnd> "
764,"<S2SV_StartBug> if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) <S2SV_EndBug> ",<S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> <S2SV_ModStart> HeapOverflowSanityCheck <S2SV_ModEnd> 
765,"<S2SV_StartBug> if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
766,<S2SV_StartBug> if ( clone_info ) <S2SV_EndBug> <S2SV_StartBug> DeleteImageFromList ( & tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( tmp == image2 ) image2 = ( Image * ) NULL ; 
767,"<S2SV_StartBug> int open_mode = opendata -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( can_open_cached ( state , open_mode ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( can_open_cached ( state , open_mode ) ) { <S2SV_EndBug> <S2SV_StartBug> update_open_stateflags ( state , open_mode ) ; <S2SV_EndBug> <S2SV_StartBug> ! can_open_delegated ( delegation , open_mode ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( update_open_stateid ( state , NULL , & stateid , open_mode ) ) <S2SV_EndBug> ","<S2SV_ModStart> O_EXCL ; fmode_t fmode = opendata -> o_arg . fmode <S2SV_ModEnd> <S2SV_ModStart> fmode , <S2SV_ModStart> fmode , <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> "
768,<S2SV_StartBug> if ( vma ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
769,<S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> ,<S2SV_ModStart> UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> size <S2SV_ModEnd> 
770,"<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = rc -> best_quality ; <S2SV_EndBug> <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cm -> current_video_frame > 0 ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> rc -> kf_boost , <S2SV_EndBug> <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> <S2SV_StartBug> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> const int cq_level = get_active_cq_level ( rc , oxcf ) ; <S2SV_ModStart> int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_kf_active_quality ( rc , <S2SV_ModEnd> <S2SV_ModStart> cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth ) ; } <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_CQ <S2SV_ModEnd> <S2SV_ModStart> cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q <S2SV_ModEnd> <S2SV_ModStart> cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_CQ <S2SV_ModEnd> <S2SV_ModStart> cq_level ) ) { active_best_quality = cq_level <S2SV_ModEnd> <S2SV_ModStart> { int qdelta = 0 ; vpx_clear_system_state ( ) ; <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 1.75 , cm -> bit_depth ) ; } * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
771,<S2SV_StartBug> for ( j = 1 ; j <= len ; j ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array"" ) ; "
772,"<S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_tag<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , * level , offset ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , last_off <S2SV_ModStart> ; last_off = off <S2SV_ModStart> if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ; "
773,"<S2SV_StartBug> Py_INCREF ( id ) ; <S2SV_EndBug> <S2SV_StartBug> PyDict_DelItemString ( value , ""$id"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( id == NULL ) { id = Py_None ; <S2SV_ModStart> } else { Py_INCREF ( id ) ; <S2SV_ModStart> } 
774,<S2SV_StartBug> case BGP_CAPCODE_RESTART : <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_16BITS ( opt + i + 2 ) ; 
775,<S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; 
776,"<S2SV_StartBug> static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , <S2SV_EndBug> <S2SV_StartBug> MODEL_NODES * sizeof ( vp9_prob ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
777,"<S2SV_StartBug> return ( ( png_charp ) PNG_STRING_NEWLINE ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2014<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" PNG_STRING_NEWLINE ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( png_charp ) ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1998-2014<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" <S2SV_ModEnd> <S2SV_ModStart> ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" <S2SV_ModEnd> "
778,<S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug> ,"<S2SV_ModStart> ! client -> auth_user ) { disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ; return false ; } if ( "
779,"<S2SV_StartBug> rc = cmd_start ( adata , cmdstr , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( rc == IMAP_RES_CONTINUE ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( flags & IMAP_CMD_SINGLE ) { if ( adata -> nextcmd != adata -> lastcmd ) imap_exec ( adata , NULL , IMAP_CMD_POLL ) ; } <S2SV_ModStart> if ( ( flags & IMAP_CMD_SINGLE ) && ( adata -> nextcmd == adata -> lastcmd ) ) break ; "
780,<S2SV_StartBug> if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( "
781,"<S2SV_StartBug> ar2 -> intf [ 0 ] = interface ; <S2SV_EndBug> <S2SV_StartBug> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; <S2SV_EndBug> <S2SV_StartBug> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> <S2SV_StartBug> fail3 : <S2SV_EndBug> <S2SV_StartBug> ati_remote2_urb_cleanup ( ar2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n"" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail4 <S2SV_ModEnd> <S2SV_ModStart> fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
782,"<S2SV_StartBug> pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> + EXTRA_BS_OFFSET 
783,<S2SV_StartBug> same_page : <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } } 
784,<S2SV_StartBug> u8 odata [ 16 ] ; <S2SV_EndBug> ,<S2SV_ModStart> * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> 
785,<S2SV_StartBug> if ( status ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } if ( <S2SV_ModStart> ( <S2SV_ModStart> && ( <S2SV_ModEnd> <S2SV_ModStart> <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 "
786,"<S2SV_StartBug> struct mb_cache_entry * * pce ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> again : <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( ce ) ) { <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> <S2SV_ModStart> ce = mb2_cache_entry_find_first <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> "
787,"<S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> hugepage_subpool_get_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
788,"<S2SV_StartBug> lua_pushvalue ( L , i ) ; <S2SV_EndBug> ","<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ; "
789,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
790,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
791,<S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> 
792,<S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; } "
793,"<S2SV_StartBug> int hdrlen ; <S2SV_EndBug> <S2SV_StartBug> if ( caplen < 3 ) { <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 10 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 14 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> case 0x00 : <S2SV_EndBug> <S2SV_StartBug> case 0x01 : <S2SV_EndBug> <S2SV_StartBug> case 0x02 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> caplen -= hdrlen ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> + 2 <S2SV_ModStart> caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> if ( ndo -> ndo_vflag ) <S2SV_ModStart> FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> <S2SV_ModStart> FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> <S2SV_ModStart> FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hdrlen <S2SV_ModEnd> "
794,<S2SV_StartBug> struct pmu * leader_pmu = event -> group_leader -> pmu ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( is_software_event ( event ) ) return 1 
795,"<S2SV_StartBug> id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; <S2SV_EndBug> <S2SV_StartBug> msq -> q_stime = msq -> q_rtime = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
796,<S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> 
797,"<S2SV_StartBug> vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
798,"<S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> arg = ( arg != NULL ) ? arg : """" ; "
799,<S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; 
800,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> ","<S2SV_ModStart> lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> "
801,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
802,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
803,"<S2SV_StartBug> if ( copy_from_user ( & sas , optval , len ) ) <S2SV_EndBug> <S2SV_StartBug> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
804,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
805,<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> ,"<S2SV_ModStart> * buf , * buf2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; <S2SV_ModEnd> <S2SV_ModStart> buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> "
806,<S2SV_StartBug> if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR && <S2SV_EndBug> ,<S2SV_ModStart> is_nmi ( exit_intr_info <S2SV_ModEnd> 
807,<S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT <S2SV_EndBug> ,<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> 
808,<S2SV_StartBug> return vp9_filteredinterp_filters1000 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_filteredinterp_filters875 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_filteredinterp_filters750 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_filteredinterp_filters625 ; <S2SV_EndBug> <S2SV_StartBug> return vp9_filteredinterp_filters500 ; <S2SV_EndBug> ,<S2SV_ModStart> filteredinterp_filters1000 <S2SV_ModEnd> <S2SV_ModStart> filteredinterp_filters875 <S2SV_ModEnd> <S2SV_ModStart> filteredinterp_filters750 <S2SV_ModEnd> <S2SV_ModStart> filteredinterp_filters625 <S2SV_ModEnd> <S2SV_ModStart> filteredinterp_filters500 <S2SV_ModEnd> 
809,"<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( * p == FAC_NATIONAL_RAND ) <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( * p == FAC_NATIONAL_DIGIS ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( len < 2 ) return - 1 ; <S2SV_ModStart> len < 3 ) return - 1 ; if ( <S2SV_ModStart> if ( len < 4 ) return - 1 ; <S2SV_ModStart> if ( len < 2 ) return - 1 ; l = p [ 1 ] ; if ( len < 2 + l ) return - 1 <S2SV_ModEnd> <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l % AX25_ADDR_LEN ) return - 1 ; 
810,"<S2SV_StartBug> static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_stats * frame_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> common . fc . coef_probs [ tx_size ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob upd = DIFF_UPDATE_PROB ; <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> <S2SV_StartBug> case ONE_LOOP : <S2SV_EndBug> <S2SV_StartBug> const int prev_coef_contexts_to_update = <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> if ( l >= prev_coef_contexts_to_update || <S2SV_EndBug> <S2SV_StartBug> if ( t == PIVOT_NODE ) <S2SV_EndBug> <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s > 0 && newp != * oldp ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , 0 , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> , vp9_coeff_probs_model * new_coef_probs ) { vp9_coeff_probs_model * old_coef_probs = <S2SV_ModEnd> <S2SV_ModStart> -> coef_probs [ tx_size ] ; const vpx_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; int stepsize = cpi -> sf . coeff_prob_appx_step <S2SV_ModEnd> <S2SV_ModStart> vpx_prob newp = new_coef_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_prob oldp = old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> , stepsize <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> , stepsize <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS <S2SV_ModEnd> <S2SV_ModStart> vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> old_coef_probs <S2SV_ModEnd> <S2SV_ModStart> , stepsize ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> "
811,<S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> ,"<S2SV_ModStart> r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> "
812,"<S2SV_StartBug> void vp9_fht16x16_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct16x16_sse2 ( input , output , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct16x16_sse2 <S2SV_ModEnd> 
813,<S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> ,<S2SV_ModStart> c -> mpeg4_studio_profile <S2SV_ModEnd> 
814,<S2SV_StartBug> int c_sz ; <S2SV_EndBug> ,<S2SV_ModStart> ; ( void ) _aux 
815,"<S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
816,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> CDF_SHORT_SEC_SIZE <S2SV_ModEnd> <S2SV_ModStart> CDF_SEC_SIZE ( h ) <S2SV_ModEnd> <S2SV_ModStart> CDF_SEC_SIZE ( h ) <S2SV_ModEnd> 
817,<S2SV_StartBug> struct fb_vblank vblank ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & vblank , 0 , sizeof ( vblank ) ) "
818,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ret >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> ext4_free_io_end ( io ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags ; int ret <S2SV_ModEnd> <S2SV_ModStart> < <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & inode -> i_mutex ) ; return ; } spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModEnd> <S2SV_ModStart> ext4_free_io_end ( io ) ; "
819,<S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> ,<S2SV_ModStart> n2size < 1 ) <S2SV_ModEnd> 
820,<S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart>  <S2SV_ModEnd> 
821,<S2SV_StartBug> BOOL ret = FALSE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> data = NULL ; <S2SV_EndBug> <S2SV_StartBug> ret = TRUE ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> return TRUE ; err : sud -> directory <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> FALSE <S2SV_ModEnd> 
822,"<S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ; } "
823,<S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> rc . key_frame_rate_correction_factor = factor ; <S2SV_EndBug> <S2SV_StartBug> ! cpi -> rc . is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) <S2SV_EndBug> <S2SV_StartBug> cpi -> rc . rate_correction_factor = factor ; <S2SV_EndBug> ,"<S2SV_ModStart> RATE_CONTROL * const rc = & cpi -> rc ; factor /= rcf_mult [ cpi -> rc . frame_size_selector ] ; factor = fclamp ( factor , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModStart> rc -> rate_correction_factors [ KF_STD ] = factor ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> <S2SV_ModStart> rc -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rc -> rate_correction_factors [ GF_ARF_STD ] <S2SV_ModEnd> <S2SV_ModStart> rc -> rate_correction_factors [ INTER_NORMAL ] <S2SV_ModEnd> "
824,<S2SV_StartBug> mutex_init ( & tu -> tread_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ioctl_lock <S2SV_ModEnd> 
825,<S2SV_StartBug> ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) { memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ; } } "
826,<S2SV_StartBug> char buf [ 32 ] ; <S2SV_EndBug> <S2SV_StartBug> char buf [ 100 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 100 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
827,<S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> ,<S2SV_ModStart> if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; 
828,"<S2SV_StartBug> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request"" ) , <S2SV_ModEnd> "
829,"<S2SV_StartBug> n = s -> method -> ssl_get_message ( s , <S2SV_EndBug> <S2SV_StartBug> if ( ! ok ) return ( ( int ) n ) ; <S2SV_EndBug> <S2SV_StartBug> # ifndef OPENSSL_NO_PSK <S2SV_EndBug> <S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) <S2SV_EndBug> ","<S2SV_ModStart> EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> algorithm_auth <S2SV_ModEnd> "
830,"<S2SV_StartBug> OPJ_UINT32 x , y ; <S2SV_EndBug> <S2SV_StartBug> x = y = 0U ; <S2SV_EndBug> <S2SV_StartBug> * pix = c1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return OPJ_TRUE ; <S2SV_EndBug> ","<S2SV_ModStart> , written <S2SV_ModStart> written = <S2SV_ModStart> ; written ++ <S2SV_ModStart> written ++ ; <S2SV_ModStart> if ( written != width * height ) { fprintf ( stderr , ""warning,<S2SV_blank>image\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\n"" ) ; return OPJ_FALSE ; } "
831,"<S2SV_StartBug> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> ",<S2SV_ModStart> | O_NOFOLLOW 
832,"<S2SV_StartBug> l2tp_proto_ver_print ( netdissect_options * ndo , const uint16_t * dat ) <S2SV_EndBug> ","<S2SV_ModStart> , u_int length ) { if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModEnd> "
833,"<S2SV_StartBug> kvmclock_reset ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vcpu -> arch . time_offset & <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . time_page = <S2SV_EndBug> <S2SV_StartBug> gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; <S2SV_EndBug> ","<S2SV_ModStart> u64 gpa_offset ; <S2SV_ModStart> gpa_offset <S2SV_ModEnd> <S2SV_ModStart> gpa_offset <S2SV_ModEnd> <S2SV_ModStart> if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> <S2SV_ModStart> & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> "
834,<S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> ,<S2SV_ModStart> 91 <S2SV_ModEnd> <S2SV_ModStart> 51 <S2SV_ModEnd> 
835,"<S2SV_StartBug> static int enable ( void ) { <S2SV_EndBug> <S2SV_StartBug> LOG_INFO ( ""%s"" , __func__ ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool start_restricted <S2SV_ModEnd> <S2SV_ModStart> LOG_TAG , ""%s:<S2SV_blank>start<S2SV_blank>restricted<S2SV_blank>=<S2SV_blank>%d"" , __func__ , start_restricted ) ; restricted_mode = start_restricted <S2SV_ModEnd> "
836,"<S2SV_StartBug> if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ","<S2SV_ModStart> size_t data_size = 0 ; <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } "
837,<S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> ,<S2SV_ModStart> const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> 
838,<S2SV_StartBug> while ( * s && * s != '}' ) { <S2SV_EndBug> <S2SV_StartBug> if ( * s == '\\n' ) * s = '<S2SV_blank>' ; <S2SV_EndBug> <S2SV_StartBug> if ( ( * s == '<S2SV_blank>' || * s == '\\n' ) && ( s [ 1 ] == '<S2SV_blank>' || s [ 1 ] == '\\n' ) ) s ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } if ( ( * s == '<S2SV_blank>' ) && ( s [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> s [ 1 ] == '\\n' || s [ 1 ] == 0 ) ) { s ++ ; } else { * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( isdigit ( * s ) ) { * t ++ = * s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) { t -- ; } if ( t > str && t [ - 1 ] == '.' ) { t -- ; if ( t > str && ! isdigit ( t [ - 1 ] ) ) { * t ++ = '0' ; } } period = 0 ; * t ++ = * s ++ ; } else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
839,"<S2SV_StartBug> int res , ret ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( uaddr == uaddr2 ) return - EINVAL 
840,"<S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> return 0 ; "
841,<S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> ,<S2SV_ModStart> uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
842,<S2SV_StartBug> end = dup ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dup == NULL ) { return PyErr_NoMemory ( ) ; } 
843,<S2SV_StartBug> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
844,<S2SV_StartBug> if ( split_flag ) { <S2SV_EndBug> ,<S2SV_ModStart> && size >= MIN_BLOCK_SIZE 
845,<S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( 
846,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> ","<S2SV_ModStart> ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> intptr_t <S2SV_ModEnd> <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) "
847,"<S2SV_StartBug> mark_desktop_file_trusted ( job , <S2SV_EndBug> ",<S2SV_ModStart> mark_desktop_file_executable <S2SV_ModEnd> 
848,<S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> ,<S2SV_ModStart> const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> 
849,<S2SV_StartBug> msg -> msg_namelen = sizeof ( * sipx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> "
850,<S2SV_StartBug> if ( gfs ) <S2SV_EndBug> ,<S2SV_ModStart> last_name = 0 ; 
851,<S2SV_StartBug> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) <S2SV_EndBug> ,<S2SV_ModStart> ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco ) 
852,<S2SV_StartBug> down_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( id . index > UINT_MAX - kcontrol -> count ) goto error ; 
853,"<S2SV_StartBug> Browser_Window * window ; <S2SV_EndBug> <S2SV_StartBug> ECORE_GETOPT_VALUE_BOOL ( quitOption ) , <S2SV_EndBug> <S2SV_StartBug> if ( args < argc ) { <S2SV_EndBug> ","<S2SV_ModStart> ; char * window_size_string = NULL <S2SV_ModStart> ECORE_GETOPT_VALUE_STR ( window_size_string ) , <S2SV_ModStart> window_size_string ) parse_window_size ( window_size_string , & window_width , & window_height ) ; if ( "
854,"<S2SV_StartBug> int nmi , int sample ) <S2SV_EndBug> <S2SV_StartBug> handle -> nmi = nmi ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
855,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
856,<S2SV_StartBug> line = data + npy * wpl ; <S2SV_EndBug> ,<S2SV_ModStart> if ( npx < 0 || npx >= w || npy < 0 || npy >= h ) continue ; 
857,<S2SV_StartBug> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> ,<S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor 
858,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
859,<S2SV_StartBug> event_data -> snk_config = <S2SV_EndBug> ,<S2SV_ModStart> cpu = cpumask_first ( mask ) ; 
860,"<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> if ( * p == FAC_NATIONAL_RAND ) <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( * p == FAC_NATIONAL_DIGIS ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( len < 2 ) return - 1 ; <S2SV_ModStart> len < 3 ) return - 1 ; if ( <S2SV_ModStart> if ( len < 4 ) return - 1 ; <S2SV_ModStart> if ( len < 2 ) return - 1 ; l = p [ 1 ] ; if ( len < 2 + l ) return - 1 <S2SV_ModEnd> <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ; <S2SV_ModStart> if ( l % AX25_ADDR_LEN ) return - 1 ; 
861,<S2SV_StartBug> DevInfo . MaxRDMBufferSize = BUFFER_4K ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ; "
862,<S2SV_StartBug> if ( s -> s3 -> flags & TLS1_FLAGS_ENCRYPT_THEN_MAC ) { <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> ,<S2SV_ModStart> tlsext_use_etm <S2SV_ModEnd> <S2SV_ModStart> tlsext_use_etm = 0 <S2SV_ModEnd> 
863,"<S2SV_StartBug> variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ; <S2SV_EndBug> <S2SV_StartBug> var = sse - ( ( ( int64_t ) avg * avg ) / ( bw * bh ) ) ; <S2SV_EndBug> <S2SV_StartBug> var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , <S2SV_EndBug> <S2SV_StartBug> vp9_64_zeros , 0 , & sse ) ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { aq_highbd_8_variance <S2SV_ModEnd> <S2SV_ModStart> CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , bw , bh , & sse , & avg ) ; sse >>= 2 * ( xd -> bd - 8 ) ; avg >>= ( xd -> bd - 8 ) ; } else { aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_ModStart> } # else aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ; # endif <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , & sse ) ; } else { var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_ModStart> } # else var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , & sse ) ; # endif "
864,<S2SV_StartBug> if ( image -> numcomps < 4 ) return ; <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , ""%s:%d:color_cmyk_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; } <S2SV_ModEnd> "
865,<S2SV_StartBug> goto discard ; <S2SV_EndBug> ,<S2SV_ModStart> consume_skb ( skb ) ; return 0 <S2SV_ModEnd> 
866,"<S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) <S2SV_EndBug> <S2SV_StartBug> ""InsufficientImageDataInFile"" , image -> filename ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> <S2SV_ModStart> ""UnexpectedEndOfFile"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
867,"<S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> ","<S2SV_ModStart> images ) { const Image * next ; <S2SV_ModEnd> <S2SV_ModStart> columns , <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> columns , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
868,"<S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
869,"
","
"
870,"<S2SV_StartBug> int * out_rate_sum , int64_t * out_dist_sum ) { <S2SV_EndBug> <S2SV_StartBug> int var = cpi -> fn_ptr [ bsize ] . vf ( p -> src . buf , p -> src . stride , <S2SV_EndBug> <S2SV_StartBug> vp9_model_rd_from_var_lapndz ( sse + var , 1 << num_pels_log2_lookup [ bsize ] , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , unsigned int * var_y , unsigned int * sse_y <S2SV_ModStart> const int64_t dc_thr = p -> quant_thred [ 0 ] >> 6 ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> 6 ; const uint32_t dc_quant = pd -> dequant [ 0 ] ; const uint32_t ac_quant = pd -> dequant [ 1 ] ; unsigned <S2SV_ModStart> int skip_dc = 0 ; * var_y = var ; * sse_y = sse ; if ( cpi -> common . tx_mode == TX_MODE_SELECT ) { if ( sse > ( var << 2 ) ) xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; else xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ; else if ( xd -> mi [ 0 ] -> mbmi . tx_size > TX_16X16 ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_16X16 ; } else { xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; } { const BLOCK_SIZE unit_size = txsize_to_bsize [ xd -> mi [ 0 ] -> mbmi . tx_size ] ; const unsigned int num_blk_log2 = ( b_width_log2_lookup [ bsize ] - b_width_log2_lookup [ unit_size ] ) + ( b_height_log2_lookup [ bsize ] - b_height_log2_lookup [ unit_size ] ) ; const unsigned int sse_tx = sse >> num_blk_log2 ; const unsigned int var_tx = var >> num_blk_log2 ; x -> skip_txfm [ 0 ] = SKIP_TXFM_NONE ; if ( var_tx < ac_thr || var == 0 ) { x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_ONLY ; if ( sse_tx - var_tx < dc_thr || sse == var ) x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } else { if ( sse_tx - var_tx < dc_thr || sse == var ) skip_dc = 1 ; } } if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC ) { * out_rate_sum = 0 ; * out_dist_sum = sse << 4 ; return ; } if ( ! skip_dc ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> - var , num_pels_log2_lookup [ bsize ] , dc_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ; } else { vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ; } # else vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ; # endif } if ( ! skip_dc ) { * out_rate_sum = rate >> 1 <S2SV_ModEnd> <S2SV_ModStart> else { * out_rate_sum = 0 ; * out_dist_sum = ( sse - var ) << 4 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ; } else { vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ; } # else vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ; # endif * out_rate_sum += rate ; * out_dist_sum += dist << 4 ; } "
871,"<S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
872,<S2SV_StartBug> while ( buf [ len - 1 ] == 0x20 ) len -- ; <S2SV_EndBug> ,<S2SV_ModStart> ( len > 0 ) && ( <S2SV_ModStart> ) 
873,"<S2SV_StartBug> * prev = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vma -> vm_file || ! vma -> vm_file -> f_mapping <S2SV_EndBug> <S2SV_StartBug> || ! vma -> vm_file -> f_mapping -> host ) { <S2SV_EndBug> <S2SV_StartBug> up_read ( & current -> mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> error = do_fallocate ( vma -> vm_file , <S2SV_EndBug> <S2SV_StartBug> offset , end - start ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct file * f ; <S2SV_ModStart> f = vma -> vm_file ; <S2SV_ModStart> f || ! f <S2SV_ModEnd> <S2SV_ModStart> f <S2SV_ModEnd> <S2SV_ModStart> get_file ( f ) ; <S2SV_ModStart> f <S2SV_ModEnd> <S2SV_ModStart> ) ; fput ( f 
874,"<S2SV_StartBug> while ( ( ch = getopt ( ac , av , ""cDdksE:a:t:"" ) ) != - 1 ) { <S2SV_EndBug> <S2SV_StartBug> k_flag ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ac == 0 && ! c_flag && ! s_flag ) { <S2SV_EndBug> <S2SV_StartBug> if ( pledge ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> ""cDdksE:a:P:t:"" <S2SV_ModEnd> <S2SV_ModStart> ; break ; case 'P' : if ( pkcs11_whitelist != NULL ) fatal ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ; pkcs11_whitelist = xstrdup ( optarg ) <S2SV_ModStart> pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; if ( <S2SV_ModStart> ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" <S2SV_ModEnd> "
875,<S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> 
876,"<S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> <S2SV_StartBug> out_dio : <S2SV_EndBug> ",<S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out_mmap <S2SV_ModEnd> <S2SV_ModStart> out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> 
877,<S2SV_StartBug> uint8_t buf [ 64 ] ; <S2SV_EndBug> ,"<S2SV_ModStart> msg_read_tiny ( msg , len <S2SV_ModEnd> "
878,<S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ; 
879,<S2SV_StartBug> return key ; <S2SV_EndBug> ,"<S2SV_ModStart> rb_ivar_set ( self , id_key_set , Qtrue ) ; "
880,<S2SV_StartBug> if ( NAPI_GRO_CB ( skb ) -> udp_mark || <S2SV_EndBug> <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> encap_mark <S2SV_ModEnd> <S2SV_ModStart> encap_mark <S2SV_ModEnd> 
881,<S2SV_StartBug> if ( ! bitstream_read_bit ( bc ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( "
882,<S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING 
883,<S2SV_StartBug> unsigned int h = 0 ; <S2SV_EndBug> <S2SV_StartBug> const char * data = ( const char * ) k ; <S2SV_EndBug> ,"<S2SV_ModStart> static volatile int random_seed = - 1 ; if ( random_seed == - 1 ) { int seed ; while ( ( seed = json_c_get_random_seed ( ) ) == - 1 ) ; # if defined __GNUC__ __sync_val_compare_and_swap ( & random_seed , - 1 , seed ) ; # elif defined _MSC_VER InterlockedCompareExchange ( & random_seed , seed , - 1 ) ; # else # warning ""racy<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>initializtion<S2SV_blank>if<S2SV_blank>used<S2SV_blank>by<S2SV_blank>multiple<S2SV_blank>threads"" random_seed = seed ; # endif } return hashlittle ( <S2SV_ModEnd> <S2SV_ModStart> , strlen ( ( const char * ) k ) , random_seed ) <S2SV_ModEnd> "
884,"<S2SV_StartBug> uid_t uid = getuid ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chown ( ""/tmp/"" , uid , gid ) < 0 ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 , 0 <S2SV_ModEnd> "
885,<S2SV_StartBug> exit_io_context ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> tsk 
886,"<S2SV_StartBug> if ( connect ( sock , ( const struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( send ( sock , & type , 1 , 0 ) != 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( send ( sock , & length , 2 , 0 ) != 2 ) <S2SV_EndBug> <S2SV_StartBug> if ( send ( sock , packet , length , 0 ) != ( ssize_t ) length ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
887,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""Rootname:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> "
888,<S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> <S2SV_ModStart> > vdev -> config_len ) { return ; } <S2SV_ModEnd> 
889,"<S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> _gdImageGifCtx <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
890,"<S2SV_StartBug> rc = fsmVerify ( fpath , fi ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & sb "
891,"<S2SV_StartBug> n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; } "
892,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
893,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = - EIO ; goto out <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
894,<S2SV_StartBug> error = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
895,"<S2SV_StartBug> imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false <S2SV_ModStart> , false "
896,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n"" , extra . type ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif 
897,<S2SV_StartBug> } else if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> <S2SV_StartBug> if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ,<S2SV_ModStart> bad_format_print <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bad_format_print <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
898,"<S2SV_StartBug> umount_tree ( mnt , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else "
899,<S2SV_StartBug> c -> sock = sock ; <S2SV_EndBug> ,"<S2SV_ModStart> struct sockaddr_storage addr ; socklen_t len = sizeof ( addr ) ; getpeername ( sock , ( struct sockaddr * ) & addr , & len ) ; if ( addr . ss_family == AF_INET ) { struct sockaddr_in * s = ( struct sockaddr_in * ) & addr ; inet_ntop ( AF_INET , & s -> sin_addr , c -> remote , sizeof ( c -> remote ) ) ; } else { struct sockaddr_in6 * s = ( struct sockaddr_in6 * ) & addr ; inet_ntop ( AF_INET6 , & s -> sin6_addr , c -> remote , sizeof ( c -> remote ) ) ; } "
900,"<S2SV_StartBug> MB_PREDICTION_MODE * pbest_mode ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE best_mode = - 1 , mode ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , 0 , 2 , TX_16X16 , mode , <S2SV_EndBug> <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride <S2SV_ModEnd> "
901,"<S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( isupper ( * s ) || isdigit ( * s ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( islower ( * s ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) "
902,"<S2SV_StartBug> transhdrlen , mtu , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rt "
903,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
904,"<S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug> ",<S2SV_ModStart> if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ; 
905,<S2SV_StartBug> if ( serial -> port [ 0 ] == usbcons_info . port ) { <S2SV_EndBug> ,<S2SV_ModStart> serial -> port [ 0 ] && 
906,"<S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> <S2SV_StartBug> zval * * tmp ; <S2SV_EndBug> <S2SV_StartBug> efree ( name ) ; <S2SV_EndBug> <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> int skip = 0 ; <S2SV_ModStart> ; skip = 0 <S2SV_ModStart> skip = 1 <S2SV_ModEnd> <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } 
907,"<S2SV_StartBug> char * decoded = url_decode ( url ) ; <S2SV_EndBug> <S2SV_StartBug> int has_nl = ! ! strchr ( decoded , '\\n' ) ; <S2SV_EndBug> <S2SV_StartBug> if ( has_nl ) <S2SV_EndBug> ","<S2SV_ModStart> ; const char * next ; int has_nl ; decoded <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) return - 1 ; if ( count_leading_dotdots ( url , & next ) > 0 && * next == ':' "
908,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int64_t txfm_cache [ ] , <S2SV_EndBug> <S2SV_StartBug> int * rate2 , int64_t * distortion , <S2SV_EndBug> <S2SV_StartBug> int * skippable , <S2SV_EndBug> <S2SV_StartBug> int * rate_uv , int64_t * distortion_uv , <S2SV_EndBug> <S2SV_StartBug> int_mv single_newmv [ MAX_REF_FRAMES ] , <S2SV_EndBug> <S2SV_StartBug> const int64_t ref_best_rd ) { <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> const int num_refs = is_comp_pred ? 2 : 1 ; <S2SV_EndBug> <S2SV_StartBug> int64_t this_rd = 0 ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , tmp_buf , MAX_MB_PLANE * 64 * 64 ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t rd , best_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> int rs = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ 0 ] ] [ 0 ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ 1 ] ] [ 0 ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> single_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> * rate2 += rate_mv ; <S2SV_EndBug> <S2SV_StartBug> frame_mv [ refs [ 0 ] ] . as_int = <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < num_refs ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> * rate2 += cost_mv_ref ( cpi , this_mode , mbmi -> mode_context [ refs [ 0 ] ] ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mask_filter_rd = 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> * best_filter = EIGHTTAP ; <S2SV_EndBug> <S2SV_StartBug> * best_filter = EIGHTTAP ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> mbmi -> interp_filter = i ; <S2SV_EndBug> <S2SV_StartBug> rs = vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = rd ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = <S2SV_EndBug> <S2SV_StartBug> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t dist_sum = 0 ; <S2SV_EndBug> <S2SV_StartBug> model_rd_for_sb ( cpi , bsize , x , xd , & rate_sum , & dist_sum ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = rd ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = <S2SV_EndBug> <S2SV_StartBug> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; <S2SV_EndBug> <S2SV_StartBug> * best_filter = mbmi -> interp_filter ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cm -> interp_filter : * best_filter ; <S2SV_EndBug> <S2SV_StartBug> rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( x ) : 0 ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> int tmp_rate ; <S2SV_EndBug> <S2SV_StartBug> * rate2 += vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! is_comp_pred ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> <S2SV_StartBug> * distortion = 0 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> allow_encode_breakout && x -> encode_breakout ) { <S2SV_EndBug> <S2SV_StartBug> * distortion_uv = ( sse_u + sse_v ) << 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip ) { <S2SV_EndBug> <S2SV_StartBug> return INT64_MAX ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int * rate2 , int64_t * distortion <S2SV_ModEnd> <S2SV_ModStart> skippable <S2SV_ModEnd> <S2SV_ModStart> rate_y , int * rate_uv <S2SV_ModEnd> <S2SV_ModStart> disable_skip <S2SV_ModEnd> <S2SV_ModStart> [ MAX_REF_FRAMES ] , INTERP_FILTER ( * single_filter ) [ MAX_REF_FRAMES ] , int ( * single_skippable ) <S2SV_ModStart> , int64_t * mask_filter , int64_t filter_cache [ ] <S2SV_ModStart> ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> uint16_t , tmp_buf16 [ MAX_MB_PLANE * 64 * 64 ] ) ; uint8_t * tmp_buf ; # else DECLARE_ALIGNED ( 16 , uint8_t , tmp_buf [ <S2SV_ModEnd> <S2SV_ModStart> ] ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> tmp_rd , <S2SV_ModStart> INTERP_FILTER best_filter = SWITCHABLE ; uint8_t skip_txfm [ MAX_MB_PLANE << 2 ] = { 0 } ; int64_t bsse [ MAX_MB_PLANE << 2 ] = { 0 } ; int bsl = mi_width_log2_lookup [ bsize ] ; int pred_filter_search = cpi -> sf . cb_pred_filter_search ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int skip_txfm_sb = 0 ; int64_t skip_sse_sb = INT64_MAX ; int64_t distortion_y = 0 , distortion_uv = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { tmp_buf = CONVERT_TO_BYTEPTR ( tmp_buf16 ) ; } else { tmp_buf = ( uint8_t * ) tmp_buf16 ; } # endif if ( pred_filter_search ) { INTERP_FILTER af = SWITCHABLE , lf = SWITCHABLE ; if ( xd -> up_available ) af = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ; if ( xd -> left_available ) lf = xd -> mi [ - 1 ] -> mbmi . interp_filter ; if ( ( this_mode != NEWMV ) || ( af == lf ) ) best_filter = af ; } <S2SV_ModStart> if ( cpi -> sf . adaptive_mode_search ) { if ( single_filter [ this_mode ] [ refs [ 0 ] ] == single_filter [ this_mode ] [ refs [ 1 ] ] ) best_filter = single_filter [ this_mode ] [ refs [ 0 ] ] ; } <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> frame_mv [ refs [ 0 ] ] . as_int = xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ; single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ; if ( discount_newmv_test ( cpi , this_mode , tmp_mv , mode_mv , refs [ 0 ] ) ) { * rate2 += MAX ( ( rate_mv / NEW_MV_DISCOUNT_FACTOR ) , 1 ) ; } else { <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart> is_comp_pred + 1 <S2SV_ModEnd> <S2SV_ModStart> if ( discount_newmv_test ( cpi , this_mode , frame_mv [ refs [ 0 ] ] , mode_mv , refs [ 0 ] ) ) { * rate2 += MIN ( cost_mv_ref ( cpi , this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) , cost_mv_ref ( cpi , NEARESTMV , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ) ; } else { <S2SV_ModStart> mbmi_ext -> mode_context [ refs [ 0 ] ] ) ; } if ( RDCOST ( x -> rdmult , x -> rddiv , * rate2 , 0 ) > ref_best_rd && mbmi -> mode != NEARESTMV ) return INT64_MAX <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( best_filter == SWITCHABLE ) <S2SV_ModStart> int tmp_skip_sb = 0 ; int64_t tmp_skip_sse = INT64_MAX ; <S2SV_ModStart> cpi , xd <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> * mask_filter <S2SV_ModEnd> <S2SV_ModStart> * mask_filter <S2SV_ModEnd> <S2SV_ModStart> if ( i > 0 && cpi -> sf . adaptive_interp_filter_search && ( cpi -> sf . interp_filter_search_mask & ( 1 << i ) ) ) { rate_sum = INT_MAX ; dist_sum = INT64_MAX ; continue ; } <S2SV_ModStart> , & tmp_skip_sb , & tmp_skip_sse <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> * mask_filter <S2SV_ModEnd> <S2SV_ModStart> * mask_filter <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp_rd = best_rd ; skip_txfm_sb = tmp_skip_sb ; skip_sse_sb = tmp_skip_sse ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi , xd <S2SV_ModEnd> <S2SV_ModStart> rd = tmp_rd + RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; <S2SV_ModStart> int tmp_rate ; int64_t tmp_dist ; <S2SV_ModStart> model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist , & skip_txfm_sb , & skip_sse_sb ) ; rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; } if ( ! is_comp_pred ) single_filter [ this_mode ] [ refs [ 0 ] ] = mbmi -> interp_filter ; if ( cpi -> sf . adaptive_mode_search ) if ( is_comp_pred ) if ( single_skippable [ this_mode ] [ refs [ 0 ] ] && single_skippable [ this_mode ] [ refs [ 1 ] ] ) memset ( skip_txfm , SKIP_TXFM_AC_DC , sizeof ( skip_txfm ) ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rs ; memcpy ( x -> skip_txfm , skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( x -> bsse , bsse , sizeof ( bsse ) <S2SV_ModEnd> <S2SV_ModStart> skip_txfm_sb ) { int skippable_y , skippable_uv ; int64_t sseuv = INT64_MAX ; int64_t rdcosty = INT64_MAX ; vp9_subtract_plane ( x , bsize , 0 ) ; super_block_yrd ( cpi , x , rate_y , & distortion_y , & skippable_y , psse , bsize , ref_best_rd ) ; if ( * rate_y == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * rate2 += * rate_y ; * distortion += distortion_y ; rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ; <S2SV_ModEnd> <S2SV_ModStart> super_block_uvrd ( cpi , x , rate_uv , & distortion_uv , & skippable_uv , & sseuv , bsize , ref_best_rd - rdcosty ) ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * psse += sseuv ; * rate2 += * rate_uv <S2SV_ModEnd> <S2SV_ModStart> += distortion_uv ; * skippable = skippable_y && skippable_uv ; } else { <S2SV_ModEnd> <S2SV_ModStart> * disable_skip <S2SV_ModEnd> <S2SV_ModStart> distortion = skip_sse_sb ; <S2SV_ModEnd> <S2SV_ModStart> is_comp_pred ) single_skippable [ this_mode ] [ refs [ 0 ] ] = * skippable <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> "
909,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
910,"<S2SV_StartBug> return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , <S2SV_EndBug> ",<S2SV_ModStart> && jas_seq2d_size ( a ) 
911,<S2SV_StartBug> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += ( ssize_t ) level ) <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
912,<S2SV_StartBug> void vp9_entropy_mv_init ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
913,<S2SV_StartBug> if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) <S2SV_EndBug> ,<S2SV_ModStart> lsa -> l2tp_conn_id = 0 ; 
914,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.cmd"" , rootname ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.png"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.ps"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.eps"" , newroot ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.tex"" , newroot ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
915,<S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> ,<S2SV_ModStart> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> <S2SV_ModStart> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> <S2SV_ModStart> free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> 
916,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
917,"<S2SV_StartBug> & r -> client_princ -> name , <S2SV_EndBug> <S2SV_StartBug> & r -> client_princ -> realm , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ? & r -> client_princ -> name : NULL , <S2SV_ModEnd> <S2SV_ModStart> ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> "
918,<S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! iov -> iov_len 
919,<S2SV_StartBug> reordered [ len + 1 ] = Mymr_C_VIRAMA ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len > 0 ) 
920,"<S2SV_StartBug> struct gs_host_config hconf = { <S2SV_EndBug> <S2SV_StartBug> struct gs_device_config dconf ; <S2SV_EndBug> <S2SV_StartBug> & hconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( hconf ) , <S2SV_EndBug> <S2SV_StartBug> if ( rc < 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> & dconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( dconf ) , <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! dev ) <S2SV_EndBug> <S2SV_StartBug> init_usb_anchor ( & dev -> rx_submitted ) ; <S2SV_EndBug> <S2SV_StartBug> dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> * hconf <S2SV_ModEnd> <S2SV_ModStart> * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModStart> kfree ( hconf ) ; <S2SV_ModStart> dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModStart> kfree ( dconf ) ; return rc ; } icount = dconf -> <S2SV_ModEnd> <S2SV_ModStart> kfree ( dconf ) ; <S2SV_ModStart> { kfree ( dconf ) ; <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dconf ) ; kfree ( <S2SV_ModStart> kfree ( dconf ) ; "
921,<S2SV_StartBug> mlock_vma_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> if ( page == check_page ) <S2SV_EndBug> <S2SV_StartBug> ret = SWAP_MLOCK ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { mlock_vma_page ( page ) ; <S2SV_ModStart> } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; } 
922,"<S2SV_StartBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "
923,"<S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> ",<S2SV_ModStart> 1024 <S2SV_ModEnd> <S2SV_ModStart> if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> && strlen ( ext ) <= sizeof ( szExt ) 
924,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
925,"<S2SV_StartBug> l2tp_msgtype_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
926,<S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned char ) 
927,"<S2SV_StartBug> if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
928,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> GTextFieldSaved ( gt ) ; 
929,"<S2SV_StartBug> static struct ip_options * tcp_v4_save_options ( struct sock * sk , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> struct ip_options * dopt = NULL ; <S2SV_EndBug> <S2SV_StartBug> int opt_size = optlength ( opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ip_options_echo ( dopt , skb ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> sizeof ( * dopt ) + opt -> optlen <S2SV_ModEnd> <S2SV_ModStart> & dopt -> opt <S2SV_ModEnd> 
930,"<S2SV_StartBug> env -> used_maps [ env -> used_map_cnt ++ ] = map ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( map , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
931,<S2SV_StartBug> unsigned fat_length ; <S2SV_EndBug> <S2SV_StartBug> fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ; <S2SV_EndBug> <S2SV_StartBug> data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ; <S2SV_EndBug> ,"<S2SV_ModStart> off_t <S2SV_ModEnd> <S2SV_ModStart> if ( ! fat_length ) die ( ""FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; <S2SV_ModStart> ; if ( data_size < fs -> cluster_size ) die ( ""Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters"" ) "
932,"<S2SV_StartBug> if ( ! rta ) <S2SV_EndBug> <S2SV_StartBug> p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> * replay_esn = p ; <S2SV_EndBug> ","<S2SV_ModStart> int klen , ulen ; <S2SV_ModStart> klen = <S2SV_ModEnd> <S2SV_ModStart> ; ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ; p = kzalloc ( klen <S2SV_ModStart> kzalloc ( klen <S2SV_ModEnd> <S2SV_ModStart> memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ; "
933,"<S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_usec = tv_usec ; <S2SV_EndBug> ","<S2SV_ModStart> u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> rem ) <S2SV_ModEnd> <S2SV_ModStart> rem / NSEC_PER_USEC <S2SV_ModEnd> "
934,<S2SV_StartBug> for ( i = 1 ; i <= SYSTEM_ID_LEN ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> sysid_len <S2SV_ModEnd> 
935,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
936,<S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; luaL_checkstack ( L , 3 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map"" ) "
937,<S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> <S2SV_StartBug> opt = sk_inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug> <S2SV_StartBug> hdr_delta = cipso_v4_delopt ( & sk_inet -> opt ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> rcu_dereference_protected ( sk_inet -> inet_opt , 1 ) <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> inet_opt <S2SV_ModEnd> "
938,<S2SV_StartBug> if ( p -> question -> n_keys != 1 ) <S2SV_EndBug> ,<S2SV_ModStart> ! p -> question ) return 0 ; if ( 
939,<S2SV_StartBug> if ( tu -> timeri ) <S2SV_EndBug> <S2SV_StartBug> snd_timer_close ( tu -> timeri ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> ) ; mutex_unlock ( & tu -> ioctl_lock 
940,<S2SV_StartBug> if ( ! ( si -> h | si -> w ) ) <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> VPX_CODEC_CORRUPT_FRAME ; } else { res = <S2SV_ModStart>  <S2SV_ModEnd> 
941,"<S2SV_StartBug> int xmkstemp ( char * * tmpname , char * dir ) <S2SV_EndBug> <S2SV_StartBug> char * tmpenv ; <S2SV_EndBug> <S2SV_StartBug> if ( dir != NULL ) <S2SV_EndBug> <S2SV_StartBug> tmpenv = dir ; <S2SV_EndBug> <S2SV_StartBug> if ( tmpenv ) <S2SV_EndBug> <S2SV_StartBug> program_invocation_short_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> , const char * prefix <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ? dir : <S2SV_ModEnd> <S2SV_ModStart> ! tmpenv ) tmpenv = _PATH_TMP ; <S2SV_ModEnd> <S2SV_ModStart> prefix <S2SV_ModEnd> "
942,<S2SV_StartBug> if ( left > 0 && n > left ) <S2SV_EndBug> ,<S2SV_ModStart> == 0 && extend ) return 0 ; if ( left 
943,<S2SV_StartBug> struct usmStateReference * retval = ( struct usmStateReference * ) <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ,<S2SV_ModStart> ; retval = <S2SV_ModEnd> <S2SV_ModStart> if ( retval ) retval -> refcnt = 1 ; 
944,<S2SV_StartBug> return v % 2 ? m - ( v + 1 ) / 2 : m + v / 2 ; <S2SV_EndBug> ,<S2SV_ModStart> ( v & 1 ) <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> >> 1 ) <S2SV_ModEnd> <S2SV_ModStart> ( v >> 1 ) <S2SV_ModEnd> 
945,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> 
946,"<S2SV_StartBug> decorator_list , expr_ty returns , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> v . FunctionDef . returns = returns ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , <S2SV_ModStart> ; p -> v . FunctionDef . type_comment = type_comment "
947,"<S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
948,<S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ; "
949,"<S2SV_StartBug> vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> ref_frame [ 0 ] = ( MV_REFERENCE_FRAME ) vp9_get_segdata ( & cm -> seg , segment_id , <S2SV_EndBug> <S2SV_StartBug> const int bit = vp9_read ( r , fc -> comp_ref_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> const int bit0 = vp9_read ( r , fc -> single_ref_prob [ ctx0 ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> const int bit1 = vp9_read ( r , fc -> single_ref_prob [ ctx1 ] [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> cm -> fc ; FRAME_COUNTS * counts = xd -> counts ; if ( segfeature_active ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_segdata <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> counts <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> counts <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> counts <S2SV_ModEnd> 
950,"<S2SV_StartBug> if ( ( error_code >> 16 ) != 0x8009 ) <S2SV_EndBug> <S2SV_StartBug> return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; <S2SV_EndBug> ","<S2SV_ModStart> ( <S2SV_ModStart> && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> ; case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ; case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ; case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."" "
951,"<S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> ",<S2SV_ModStart> KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> KEY_ALLOC_UID_KEYRING | 
952,<S2SV_StartBug> if ( namelen > 32 ) <S2SV_EndBug> ,<S2SV_ModStart> len <S2SV_ModEnd> 
953,<S2SV_StartBug> if ( bytecnt ) { <S2SV_EndBug> <S2SV_StartBug> bytecnt -- ; <S2SV_EndBug> ,<S2SV_ModStart> >= 2 <S2SV_ModStart> if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ; 
954,"<S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( isupper ( * s ) || isdigit ( * s ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( islower ( * s ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) "
955,"<S2SV_StartBug> uint16 nstrips = 0 , ntiles = 0 , planar = 0 ; <S2SV_EndBug> <S2SV_StartBug> read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> <S2SV_ModStart> { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } <S2SV_ModStart> } <S2SV_ModStart> if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } "
956,"<S2SV_StartBug> if ( using_compacted_format ( ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; } "
957,<S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( r -> iov . iov_base ) { <S2SV_ModStart> } 
958,"<S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR0 , hashTable [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR2 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR3 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR0<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_MAHTR0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_MAHTR1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_MAHTR2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_MAHTR3 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> KSZ8851_MAHTR0 , hashTable [ 0 ] ) ; ksz8851WriteReg ( interface , KSZ8851_MAHTR1 <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MAHTR2 <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MAHTR3 <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MAHTR0 <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MAHTR1 <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MAHTR2 <S2SV_ModEnd> <S2SV_ModStart> KSZ8851_MAHTR3 <S2SV_ModEnd> "
959,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
960,"<S2SV_StartBug> if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } <S2SV_EndBug> <S2SV_StartBug> c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < g -> values ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> m -> coupling_steps = get_bits ( f , 8 ) + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; <S2SV_ModStart> ( uint32 ) values <S2SV_ModEnd> <S2SV_ModStart> - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup ) "
961,<S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> <S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> <S2SV_ModStart> sas_eh_finish_cmd <S2SV_ModEnd> 
962,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> 
963,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_ref_frame_t * const data = va_arg ( args , vpx_ref_frame_t * ) ; <S2SV_EndBug> <S2SV_StartBug> image2yuvconfig ( & frame -> img , & sd ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_set_reference_dec ( & ctx -> pbi -> common , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } <S2SV_ModStart> VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> "
964,"<S2SV_StartBug> Stream_Read_UINT32 ( irp -> input , Length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( printer_dev -> printer ) <S2SV_EndBug> <S2SV_StartBug> error = printjob -> Write ( printjob , Stream_Pointer ( irp -> input ) , Length ) ; <S2SV_EndBug> ","<S2SV_ModStart> void * ptr ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ptr <S2SV_ModEnd> "
965,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) { <S2SV_EndBug> <S2SV_StartBug> } while ( ret == WC_PENDING_E ) ; <S2SV_EndBug> ","<S2SV_ModStart> return wc_SignatureGenerateHash_ex ( hash_type , sig_type , hash_data , hash_len , sig , sig_len <S2SV_ModEnd> <S2SV_ModStart> , rng , 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
966,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct frag_hdr fhdr ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> append : <S2SV_ModEnd> "
967,<S2SV_StartBug> key_user_put ( key -> user ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
968,"<S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ","<S2SV_ModStart> mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> <S2SV_ModStart> { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> "
969,<S2SV_StartBug> int rv ; <S2SV_EndBug> ,"<S2SV_ModStart> ; clear_bit ( WDM_OVERFLOW , & desc -> flags ) "
970,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
971,"<S2SV_StartBug> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; "
972,<S2SV_StartBug> mnt_flags |= MNT_NODEV ; <S2SV_EndBug> ,<S2SV_ModStart> | MNT_LOCK_NODEV 
973,<S2SV_StartBug> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
974,"<S2SV_StartBug> } else if ( strstr ( url , ""/"" ) != url ) { <S2SV_EndBug> ",<S2SV_ModStart> ( uri . hostname == NULL ) && ( <S2SV_ModStart> ) 
975,"<S2SV_StartBug> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> __copy_from_user <S2SV_ModEnd> 
976,<S2SV_StartBug> mutex_lock ( & owner -> perf_event_mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock_nested <S2SV_ModEnd> <S2SV_ModStart> , SINGLE_DEPTH_NESTING "
977,"<S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ",<S2SV_ModStart> pr_debug <S2SV_ModEnd> 
978,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
979,<S2SV_StartBug> bpm -> family = AF_BRIDGE ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( bpm , 0 , sizeof ( * bpm ) ) ; "
980,<S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug> ,"<S2SV_ModStart> ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ; "
981,<S2SV_StartBug> return result ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; 
982,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . mr_encoder_id ) <S2SV_EndBug> <S2SV_StartBug> = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) <S2SV_EndBug> <S2SV_StartBug> cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ ALTREF_FRAME ] <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> current_layer == 0 ) <S2SV_EndBug> <S2SV_StartBug> scale_and_extend_source ( cpi -> un_scaled_source , cpi ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_de_noise ( cm , cpi -> Source , cpi -> Source , l , 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_de_noise ( cm , cpi -> Source , cpi -> Source , l , 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_write_yuv_frame ( cpi -> Source ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_set_quantizer ( cpi , Q ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cm -> lfc , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_encode_frame ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp -> mbmi . mode == ZEROMV ) <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTITHREAD <S2SV_EndBug> <S2SV_StartBug> sem_post ( & cpi -> h_event_start_lpf ) ; <S2SV_EndBug> <S2SV_StartBug> update_reference_frames ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity == 4 ) { vp8_denoiser_set_parameters ( & cpi -> denoiser , kDenoiserOnYUV ) ; } # endif } # if <S2SV_ModEnd> <S2SV_ModStart> mr_total_resolutions > 1 ) <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . mr_encoder_id ) { <S2SV_ModStart> } } if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> oxcf . mr_encoder_id ) { if ( cpi -> common . current_video_frame == 0 && cpi -> buffer_level == 0 ) { unsigned int i ; cpi -> bits_off_target = cpi -> oxcf . starting_buffer_level ; cpi -> buffer_level = cpi -> oxcf . starting_buffer_level ; for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> bits_off_target = lc -> starting_buffer_level ; lc -> buffer_level = lc -> starting_buffer_level ; } } cpi -> common . current_video_frame = low_res_frame_info -> key_frame_counter_value ; } else { low_res_frame_info -> key_frame_counter_value = cpi -> common . current_video_frame ; } } } # endif cpi -> closest_reference_frame = LAST_FRAME ; if ( cm -> frame_type != KEY_FRAME ) { int i ; MV_REFERENCE_FRAME closest_ref = INTRA_FRAME ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { closest_ref = LAST_FRAME ; } else if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) { closest_ref = GOLDEN_FRAME ; } else <S2SV_ModStart> { closest_ref = ALTREF_FRAME ; } for ( i = 1 ; i <= 3 ; i ++ ) { vpx_ref_frame_type_t ref_frame_type = ( vpx_ref_frame_type_t ) ( ( i == 3 ) ? 4 : i ) ; if ( cpi -> ref_frame_flags & ref_frame_type ) { if ( ( cm -> current_video_frame - <S2SV_ModEnd> <S2SV_ModStart> i ] ) < ( cm -> current_video_frame - cpi -> current_ref_frames [ closest_ref ] ) ) { closest_ref = i ; } } } cpi -> closest_reference_frame = closest_ref ; } <S2SV_ModEnd> <S2SV_ModStart> memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> int disable_cr_gf = ( cpi -> oxcf . screen_content_mode == 2 && cm -> refresh_golden_frame ) ; <S2SV_ModStart> && cpi -> force_maxqp == 0 && ! disable_cr_gf <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING && CONFIG_POSTPROC if ( cpi -> oxcf . noise_sensitivity >= 3 ) { if ( cpi -> denoiser . denoise_pars . spatial_blur != 0 ) { vp8_de_noise ( cm , cpi -> Source , cpi -> Source , cpi -> denoiser . denoise_pars . spatial_blur , 1 , 0 , 0 ) ; } } # endif <S2SV_ModStart> , 1 <S2SV_ModStart> , 1 <S2SV_ModStart> yuv_file , <S2SV_ModStart> memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . screen_content_mode == 2 ) { if ( vp8_drop_encodedframe_overshoot ( cpi , Q ) ) return ; } <S2SV_ModStart> && tmp -> mbmi . ref_frame == LAST_FRAME <S2SV_ModStart> CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && cpi -> oxcf . noise_sensitivity < 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { cpi -> mse_source_denoised = measure_square_diff_partial ( <S2SV_ModEnd> <S2SV_ModStart> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi -> Source , cpi ) ; } if ( cpi -> oxcf . noise_sensitivity == 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { process_denoiser_mode_change ( cpi ) ; } # endif # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) { sem_post ( & cpi -> h_event_start_lpf ) ; cpi -> b_lpf_running = 1 ; } else # endif <S2SV_ModEnd> <S2SV_ModStart> # ifdef OUTPUT_YUV_DENOISED vp8_write_yuv_frame ( yuv_denoised_file , & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] ) ; # endif <S2SV_ModStart> cpi -> oxcf . maximum_buffer_size ; if ( cpi -> drop_frames_allowed == 0 && cpi -> oxcf . screen_content_mode && cpi -> bits_off_target < - cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = - "
983,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
984,"<S2SV_StartBug> ! strcmp ( & s -> name [ strlen ( s -> name ) - 5 ] , ""plain"" ) ) && s -> enabled ) <S2SV_EndBug> ",<S2SV_ModStart> strstr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
985,<S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> && ! p -> skip_release_on_error 
986,"<S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> ",<S2SV_ModStart> ; ( void ) bothclamp 
987,"<S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_clear_pd ( oldsk ) ; <S2SV_EndBug> ","<S2SV_ModStart> sctp_sock_rfree_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_skb_set_owner_r_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_sock_rfree_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_skb_set_owner_r_frag <S2SV_ModEnd> <S2SV_ModStart> ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk "
988,<S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug> ,"<S2SV_ModStart> ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ; "
989,<S2SV_StartBug> p = find_eoq ( cmd + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> cmd [ 0 ] ? <S2SV_ModStart> : NULL 
990,"<S2SV_StartBug> int insn_idx , int prev_insn_idx ) <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> ","<S2SV_ModStart> , bool speculative <S2SV_ModStart> ; elem -> st . speculative |= speculative "
991,"<S2SV_StartBug> copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> <S2SV_StartBug> IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ; <S2SV_EndBug> <S2SV_StartBug> copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> <S2SV_StartBug> IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ; <S2SV_EndBug> <S2SV_StartBug> copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> <S2SV_StartBug> IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dump_fd_info ( dest_filename , source_filename , source_base_ofs ) ) <S2SV_EndBug> <S2SV_StartBug> IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> copy_file_ext <S2SV_ModEnd> <S2SV_ModStart> 0640 <S2SV_ModEnd> <S2SV_ModStart> , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> <S2SV_ModStart> copy_file_ext <S2SV_ModEnd> <S2SV_ModStart> 0640 <S2SV_ModEnd> <S2SV_ModStart> , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> <S2SV_ModStart> copy_file_ext <S2SV_ModEnd> <S2SV_ModStart> 0640 <S2SV_ModEnd> <S2SV_ModStart> , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
992,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
993,"<S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> if ( cidx == NULL ) { goto fail1 ; } "
994,<S2SV_StartBug> if ( result == L2CAP_CONF_SUCCESS ) { <S2SV_EndBug> <S2SV_StartBug> if ( rfc . mode == L2CAP_MODE_BASIC ) { <S2SV_EndBug> <S2SV_StartBug> if ( mtu < pi -> omtu ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> pi -> num_conf_rsp || pi -> num_conf_req ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) return - ECONNREFUSED ; break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : if ( pi -> mode != rfc . mode ) { result = L2CAP_CONF_UNACCEPT ; rfc . mode = pi -> mode ; if ( pi -> num_conf_rsp == 1 ) return - ECONNREFUSED ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; } if ( <S2SV_ModStart> mtu < L2CAP_DEFAULT_MIN_MTU ) result = L2CAP_CONF_UNACCEPT ; else { <S2SV_ModEnd> <S2SV_ModStart> = mtu ; pi -> conf_state |= L2CAP_CONF_MTU_DONE ; } l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> omtu ) ; switch ( rfc . mode ) { case L2CAP_MODE_BASIC : pi -> fcs = L2CAP_FCS_NONE ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; case L2CAP_MODE_ERTM : pi -> remote_tx_win = rfc . txwin_size ; pi -> remote_max_tx = rfc . max_transmit ; pi -> max_pdu_size = rfc . max_pdu_size ; rfc . retrans_timeout = L2CAP_DEFAULT_RETRANS_TO ; rfc . monitor_timeout = L2CAP_DEFAULT_MONITOR_TO ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; case L2CAP_MODE_STREAMING : pi -> remote_tx_win = rfc . txwin_size ; pi -> max_pdu_size = rfc . max_pdu_size ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; default : <S2SV_ModEnd> <S2SV_ModStart> memset ( & rfc , 0 , sizeof ( rfc ) ) ; rfc . mode = pi -> mode ; } l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; if ( result == L2CAP_CONF_SUCCESS ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
995,"<S2SV_StartBug> static int inv_map_table [ MAX_PROB - 1 ] = { <S2SV_EndBug> <S2SV_StartBug> 6 , 19 , 32 , 45 , 58 , 71 , 84 , 97 , 110 , 123 , 136 , 149 , 162 , 175 , 188 , <S2SV_EndBug> <S2SV_StartBug> return 1 + inv_recenter_nonneg ( v + 1 , m ) ; <S2SV_EndBug> <S2SV_StartBug> return MAX_PROB - inv_recenter_nonneg ( v + 1 , MAX_PROB - 1 - m ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 7 , 20 , 33 , 46 , 59 , 72 , 85 , 98 , 111 , 124 , 137 , 150 , 163 , 176 , 189 , 202 , 215 , 228 , 241 , 254 , 1 , 2 , 3 , 4 , 5 , 6 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 253 } ; assert ( v < ( int ) ( sizeof ( inv_map_table ) / sizeof ( inv_map_table [ 0 ] ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
996,"<S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> th -> fin ) goto discard ; if ( 
997,"<S2SV_StartBug> ret = key_validate ( key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( key -> type -> read ) { <S2SV_EndBug> <S2SV_StartBug> ret = key -> type -> read ( key , buffer , buflen ) ; <S2SV_EndBug> ","<S2SV_ModStart> - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> ( key , buffer , buflen ) ; up_read <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
998,<S2SV_StartBug> long timeo ; <S2SV_EndBug> ,<S2SV_ModStart> ; msg -> msg_namelen = 0 
999,"<S2SV_StartBug> int count , i ; <S2SV_EndBug> ",<S2SV_ModStart> unsigned 
1000,"<S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER && CONFIG_POSTPROC <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( void ) ctx ; ( void ) args ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1001,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( bi == NULL ) return NULL <S2SV_ModEnd> 
1002,"<S2SV_StartBug> ar2 -> intf [ 0 ] = interface ; <S2SV_EndBug> <S2SV_StartBug> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; <S2SV_EndBug> <S2SV_StartBug> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> <S2SV_StartBug> fail3 : <S2SV_EndBug> <S2SV_StartBug> ati_remote2_urb_cleanup ( ar2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n"" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail3 <S2SV_ModEnd> <S2SV_ModStart> fail4 <S2SV_ModEnd> <S2SV_ModStart> fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1003,"<S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
1004,"<S2SV_StartBug> struct usbdevfs_connectinfo ci = { <S2SV_EndBug> <S2SV_StartBug> . devnum = ps -> dev -> devnum , <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ","<S2SV_ModStart> ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci <S2SV_ModEnd> <S2SV_ModStart> ; ci <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1005,"<S2SV_StartBug> save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 
1006,<S2SV_StartBug> if ( ( url [ x ] = url [ y ] ) == '+' ) <S2SV_EndBug> <S2SV_StartBug> else if ( url [ x ] == '%' ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( url [ x + 1 ] && url [ x + 2 ] ) ) <S2SV_EndBug> <S2SV_StartBug> url [ x ] = x2c ( url + y + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> y += 2 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> y <S2SV_ModEnd> <S2SV_ModStart> url [ y <S2SV_ModEnd> <S2SV_ModStart> || ! url [ y <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> _x2c <S2SV_ModEnd> <S2SV_ModStart> ; } else { url [ x ] = url [ y ] 
1007,"<S2SV_StartBug> & r -> client_princ -> name , <S2SV_EndBug> <S2SV_StartBug> & r -> client_princ -> realm , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ? & r -> client_princ -> name : NULL , <S2SV_ModEnd> <S2SV_ModStart> ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> "
1008,<S2SV_StartBug> usb_kill_urb ( mixer -> urb ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( mixer -> disconnected ) return ; if ( mixer -> urb ) <S2SV_ModStart> if ( mixer -> rc_urb ) <S2SV_ModStart> mixer -> disconnected = true ; 
1009,"<S2SV_StartBug> call = ast_for_call ( c , CHILD ( n , 3 ) , dummy ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
1010,<S2SV_StartBug> struct iovec iov ; <S2SV_EndBug> <S2SV_StartBug> if ( ret < local_nr_pages ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nr_pages ; j ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; struct bio_vec * bvec <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> <S2SV_ModStart> bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> "
1011,<S2SV_StartBug> while ( ret < nr ) { <S2SV_EndBug> ,<S2SV_ModStart> head %= ctx -> nr_events ; tail %= ctx -> nr_events ; 
1012,"<S2SV_StartBug> strcpy ( algo -> alg_name , auth -> alg_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( algo -> alg_name ) "
1013,<S2SV_StartBug> BT_HDR * p_buf = GKI_getbuf ( ( UINT16 ) ( len + BTA_HH_MIN_OFFSET + sizeof ( BT_HDR ) ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> UINT16 buflen = <S2SV_ModEnd> <S2SV_ModStart> ; if ( buflen < len ) { android_errorWriteWithInfoLog ( 0x534e4554 , ""28672558"" , - 1 , NULL , 0 ) ; return NULL ; } BT_HDR * p_buf = GKI_getbuf ( buflen "
1014,<S2SV_StartBug> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1015,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1016,<S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING 
1017,"<S2SV_StartBug> if ( poll ( & pfd , 1 , 0 ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1018,<S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug> ,<S2SV_ModStart> ! code <S2SV_ModEnd> <S2SV_ModStart> || code == KRB5KDC_ERR_KEY_EXP 
1019,"<S2SV_StartBug> char * driver_override , * old = pdev -> driver_override , * cp ; <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( driver_override ) ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( old ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> device_unlock ( dev ) ; 
1020,<S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug> ,<S2SV_ModStart> && kvm_x86_ops -> get_cpl ( vcpu ) == 0 
1021,"<S2SV_StartBug> int res , bytes , i , indexes , index_bytes , ids ; <S2SV_EndBug> <S2SV_StartBug> if ( flag ) { <S2SV_EndBug> <S2SV_StartBug> return id_table . xattr_ids ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) , <S2SV_EndBug> <S2SV_StartBug> bytes = SQUASHFS_XATTR_BYTES ( ids ) ; <S2SV_EndBug> <S2SV_StartBug> ( i * SQUASHFS_METADATA_SIZE ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> <S2SV_ModStart> ids = id_table . xattr_ids ; xattr_table_start <S2SV_ModEnd> <S2SV_ModStart> index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ) { ERROR ( ""read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModStart> ( long long ) <S2SV_ModStart> ( long long ) "
1022,<S2SV_StartBug> while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> dest = ( rose_address * ) ( skb -> data + 4 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> 
1023,<S2SV_StartBug> if ( * p != IAC ) <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK ( * p ) ; 
1024,"<S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) len = sizeof <S2SV_ModEnd> <S2SV_ModStart> ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , ""%.*s<S2SV_blank>bc<S2SV_blank>"" , len , & vpd_data [ j ] <S2SV_ModEnd> "
1025,<S2SV_StartBug> int err ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL 
1026,"<S2SV_StartBug> static struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1027,"<S2SV_StartBug> static void ip6_append_data_mtu ( int * mtu , <S2SV_EndBug> <S2SV_StartBug> struct rt6_info * rt ) <S2SV_EndBug> <S2SV_StartBug> * mtu = dst_mtu ( rt -> dst . path ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned <S2SV_ModStart> , bool pmtuprobe <S2SV_ModStart> min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : <S2SV_ModStart> ) "
1028,"<S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1029,<S2SV_StartBug> bitlen = slen * 4 ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> } "
1030,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
1031,"
","
"
1032,<S2SV_StartBug> static int udp_push_pending_frames ( struct sock * sk ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1033,"<S2SV_StartBug> if ( mount ( ""none"" , path , ""tmpfs"" , 0 , ""size=100000,mode=755"" ) ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , rootfs -> path ? rootfs -> mount : NULL "
1034,"<S2SV_StartBug> # line 495 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 860 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 557 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 854 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 606 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 707 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 784 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 698 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 818 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 677 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 860 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 642 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 916 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 609 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 970 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 599 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1068 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 584 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1142 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 557 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1196 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 550 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1211 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 543 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1221 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 520 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1267 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 499 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1311 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 862 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> ",<S2SV_ModStart> 496 <S2SV_ModEnd> <S2SV_ModStart> 861 <S2SV_ModEnd> <S2SV_ModStart> 558 <S2SV_ModEnd> <S2SV_ModStart> 855 <S2SV_ModEnd> <S2SV_ModStart> 607 <S2SV_ModEnd> <S2SV_ModStart> 708 <S2SV_ModEnd> <S2SV_ModStart> 785 <S2SV_ModEnd> <S2SV_ModStart> 699 <S2SV_ModEnd> <S2SV_ModStart> 819 <S2SV_ModEnd> <S2SV_ModStart> 678 <S2SV_ModEnd> <S2SV_ModStart> 861 <S2SV_ModEnd> <S2SV_ModStart> 643 <S2SV_ModEnd> <S2SV_ModStart> 917 <S2SV_ModEnd> <S2SV_ModStart> 610 <S2SV_ModEnd> <S2SV_ModStart> 971 <S2SV_ModEnd> <S2SV_ModStart> 600 <S2SV_ModEnd> <S2SV_ModStart> 1069 <S2SV_ModEnd> <S2SV_ModStart> 585 <S2SV_ModEnd> <S2SV_ModStart> 1143 <S2SV_ModEnd> <S2SV_ModStart> 558 <S2SV_ModEnd> <S2SV_ModStart> 1197 <S2SV_ModEnd> <S2SV_ModStart> 551 <S2SV_ModEnd> <S2SV_ModStart> 1212 <S2SV_ModEnd> <S2SV_ModStart> 544 <S2SV_ModEnd> <S2SV_ModStart> 1222 <S2SV_ModEnd> <S2SV_ModStart> 521 <S2SV_ModEnd> <S2SV_ModStart> 1268 <S2SV_ModEnd> <S2SV_ModStart> 500 <S2SV_ModEnd> <S2SV_ModStart> 1312 <S2SV_ModEnd> <S2SV_ModStart> 863 <S2SV_ModEnd> 
1035,<S2SV_StartBug> put_io_context ( p -> io_context ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> ) exit_io_context ( p 
1036,"<S2SV_StartBug> void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . apic -> vapic_addr = vapic_addr ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( vapic_addr ) { if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & <S2SV_ModStart> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ; <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> vcpu -> arch . apic -> vapic_addr = vapic_addr ; return 0 ; } "
1037,"<S2SV_StartBug> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
1038,<S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug> ,<S2SV_ModStart> skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> ; skb -> destructor = sock_efree 
1039,<S2SV_StartBug> return res ; <S2SV_EndBug> <S2SV_StartBug> return res ; <S2SV_EndBug> ,<S2SV_ModStart> goto err_add_port <S2SV_ModEnd> <S2SV_ModStart> err_add_port : hsr_del_node ( & hsr -> self_node_db ) ; 
1040,"<S2SV_StartBug> vpx_memset ( cm -> above_context , 0 , <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
1041,<S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
1042,"<S2SV_StartBug> int insn_idx , int prev_insn_idx ) <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> ","<S2SV_ModStart> , bool speculative <S2SV_ModStart> ; elem -> st . speculative |= speculative "
1043,"<S2SV_StartBug> vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
1044,"<S2SV_StartBug> SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\n"" , port -> id , <S2SV_EndBug> ",<S2SV_ModStart> sas_probe_devices ( port ) ; 
1045,<S2SV_StartBug> if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) 
1046,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( ""Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n"" ) ; side_closed ( side ) ; break ; } "
1047,<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ext2_mb_cache , <S2SV_ModStart> ext2_mb_cache , "
1048,"<S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ","<S2SV_ModStart> 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> <S2SV_ModStart> - 1 "
1049,<S2SV_StartBug> pid_t my_pid = getpid ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( g_settings_privatereports ) { if ( world_readable_dump ) log ( ""Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on"" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; } "
1050,"<S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , ""w"" ) ; <S2SV_EndBug> <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> ","<S2SV_ModStart> = fopen_safe <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> "
1051,<S2SV_StartBug> if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) { <S2SV_EndBug> ,<S2SV_ModStart> vstart + vdaux < vstart <S2SV_ModEnd> 
1052,"<S2SV_StartBug> ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> pptr += BGP_VPN_RD_LEN ; <S2SV_EndBug> ",<S2SV_ModStart> + 4 <S2SV_ModStart> + 4 
1053,<S2SV_StartBug> prefix = report [ i ] ; <S2SV_EndBug> <S2SV_StartBug> case 3 : <S2SV_EndBug> ,"<S2SV_ModStart> ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , ""Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\n"" , i + size , length ) ; break ; } <S2SV_ModEnd> <S2SV_ModStart> 4 : <S2SV_ModEnd> "
1054,<S2SV_StartBug> const char * bufptr ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write"" ) ; } "
1055,<S2SV_StartBug> if ( ALWAYS ( p -> pEList ) ) { <S2SV_EndBug> ,<S2SV_ModStart> p -> selFlags & SF_View ) return WRC_Prune ; if ( 
1056,"<S2SV_StartBug> ssize_t ret = write ( fd , ev , sizeof ( * ev ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1057,"<S2SV_StartBug> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { <S2SV_EndBug> ",<S2SV_ModStart> || ! expr -> action . args 
1058,"<S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> ","<S2SV_ModStart> UTF16_HOST_ENDIAN , <S2SV_ModStart> , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> UTF16_HOST_ENDIAN , <S2SV_ModStart> , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2 "
1059,"<S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , XEN_NETIF_RSP_OKAY "
1060,<S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1061,"<S2SV_StartBug> struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; <S2SV_EndBug> <S2SV_StartBug> env -> insn_aux_data = new_data ; <S2SV_EndBug> ",<S2SV_ModStart> ; int i <S2SV_ModStart> for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ; 
1062,"<S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> 
1063,"<S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" , <S2SV_EndBug> ","<S2SV_ModStart> ""crypto-%s"" <S2SV_ModEnd> "
1064,"<S2SV_StartBug> SET_NETDEV_DEV ( dev , dmdev ) ; <S2SV_EndBug> ",<S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; 
1065,"<S2SV_StartBug> int var_index ; <S2SV_EndBug> <S2SV_StartBug> # line 2619 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 63 : <S2SV_EndBug> <S2SV_StartBug> # line 2658 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 64 : <S2SV_EndBug> <S2SV_StartBug> # line 2741 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 65 : <S2SV_EndBug> <S2SV_StartBug> # line 2775 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 66 : <S2SV_EndBug> <S2SV_StartBug> # line 2828 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1248 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> # line 2848 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1254 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2878 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 70 : <S2SV_EndBug> <S2SV_StartBug> # line 2918 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 71 : <S2SV_EndBug> <S2SV_StartBug> # line 2947 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 72 : <S2SV_EndBug> <S2SV_StartBug> # line 2987 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 73 : <S2SV_EndBug> <S2SV_StartBug> # line 3000 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 74 : <S2SV_EndBug> <S2SV_StartBug> # line 3013 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 75 : <S2SV_EndBug> <S2SV_StartBug> # line 3026 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 76 : <S2SV_EndBug> <S2SV_StartBug> # line 3039 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 77 : <S2SV_EndBug> <S2SV_StartBug> # line 3052 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 78 : <S2SV_EndBug> <S2SV_StartBug> # line 3065 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1435 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3081 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1443 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> { ( yyval . integer ) = INTEGER_SET_RANGE ; } <S2SV_EndBug> <S2SV_StartBug> # line 1449 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3115 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 84 : <S2SV_EndBug> <S2SV_StartBug> # line 3131 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 85 : <S2SV_EndBug> <S2SV_StartBug> # line 3146 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 88 : <S2SV_EndBug> <S2SV_StartBug> # line 3166 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 91 : <S2SV_EndBug> <S2SV_StartBug> # line 3177 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 92 : <S2SV_EndBug> <S2SV_StartBug> # line 3188 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1544 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1552 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3212 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 97 : <S2SV_EndBug> <S2SV_StartBug> # line 3226 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 98 : <S2SV_EndBug> <S2SV_StartBug> # line 3244 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 99 : <S2SV_EndBug> <S2SV_StartBug> # line 3264 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 100 : <S2SV_EndBug> <S2SV_StartBug> # line 3278 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 101 : <S2SV_EndBug> <S2SV_StartBug> # line 3291 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 102 : <S2SV_EndBug> <S2SV_StartBug> # line 3320 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 103 : <S2SV_EndBug> <S2SV_StartBug> # line 3336 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 104 : <S2SV_EndBug> <S2SV_StartBug> # line 3352 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 105 : <S2SV_EndBug> <S2SV_StartBug> # line 3372 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 106 : <S2SV_EndBug> <S2SV_StartBug> # line 3388 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 107 : <S2SV_EndBug> <S2SV_StartBug> # line 3408 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 108 : <S2SV_EndBug> <S2SV_StartBug> # line 3457 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 109 : <S2SV_EndBug> <S2SV_StartBug> # line 3480 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 110 : <S2SV_EndBug> <S2SV_StartBug> # line 3502 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 111 : <S2SV_EndBug> <S2SV_StartBug> # line 3524 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 112 : <S2SV_EndBug> <S2SV_StartBug> # line 3546 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 113 : <S2SV_EndBug> <S2SV_StartBug> # line 3576 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 114 : <S2SV_EndBug> <S2SV_StartBug> # line 3598 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 115 : <S2SV_EndBug> <S2SV_StartBug> # line 3612 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 116 : <S2SV_EndBug> <S2SV_StartBug> # line 3626 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 117 : <S2SV_EndBug> <S2SV_StartBug> # line 3640 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 118 : <S2SV_EndBug> <S2SV_StartBug> # line 3654 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 119 : <S2SV_EndBug> <S2SV_StartBug> # line 3668 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 120 : <S2SV_EndBug> <S2SV_StartBug> # line 3682 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> case 121 : <S2SV_EndBug> <S2SV_StartBug> # line 3690 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 3694 ""grammar.c"" <S2SV_EndBug> ","<S2SV_ModStart> compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } # line 2594 ""grammar.c"" break ; case 63 : # line 1024 ""grammar.y"" { <S2SV_ModStart> 2628 <S2SV_ModEnd> <S2SV_ModStart> 64 : # line 1054 <S2SV_ModEnd> <S2SV_ModStart> 2667 <S2SV_ModEnd> <S2SV_ModStart> 65 : # line 1089 <S2SV_ModEnd> <S2SV_ModStart> 2750 <S2SV_ModEnd> <S2SV_ModStart> 66 : # line 1168 <S2SV_ModEnd> <S2SV_ModStart> 2784 <S2SV_ModEnd> <S2SV_ModStart> 67 : # line 1198 <S2SV_ModEnd> <S2SV_ModStart> 2837 <S2SV_ModEnd> <S2SV_ModStart> 1247 <S2SV_ModEnd> <S2SV_ModStart> OP_OF <S2SV_ModEnd> <S2SV_ModStart> 2847 <S2SV_ModEnd> <S2SV_ModStart> 1253 ""grammar.y"" { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2857 ""grammar.c"" break ; case 70 : # line 1259 <S2SV_ModEnd> <S2SV_ModStart> 2887 <S2SV_ModEnd> <S2SV_ModStart> 71 : # line 1285 <S2SV_ModEnd> <S2SV_ModStart> 2927 <S2SV_ModEnd> <S2SV_ModStart> 72 : # line 1321 <S2SV_ModEnd> <S2SV_ModStart> 2956 <S2SV_ModEnd> <S2SV_ModStart> 73 : # line 1346 <S2SV_ModEnd> <S2SV_ModStart> 2996 <S2SV_ModEnd> <S2SV_ModStart> 74 : # line 1382 <S2SV_ModEnd> <S2SV_ModStart> 3009 <S2SV_ModEnd> <S2SV_ModStart> 75 : # line 1391 <S2SV_ModEnd> <S2SV_ModStart> 3022 <S2SV_ModEnd> <S2SV_ModStart> 76 : # line 1400 <S2SV_ModEnd> <S2SV_ModStart> 3035 <S2SV_ModEnd> <S2SV_ModStart> 77 : # line 1409 <S2SV_ModEnd> <S2SV_ModStart> 3048 <S2SV_ModEnd> <S2SV_ModStart> 78 : # line 1418 <S2SV_ModEnd> <S2SV_ModStart> 3061 <S2SV_ModEnd> <S2SV_ModStart> 79 : # line 1427 <S2SV_ModEnd> <S2SV_ModStart> 3074 <S2SV_ModEnd> <S2SV_ModStart> 1436 ""grammar.y"" { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } # line 3082 ""grammar.c"" break ; case 81 : # line 1440 <S2SV_ModEnd> <S2SV_ModStart> 3090 <S2SV_ModEnd> <S2SV_ModStart> 1447 <S2SV_ModEnd> <S2SV_ModStart> INTEGER_SET_ENUMERATION ; } # line 3096 <S2SV_ModEnd> <S2SV_ModStart> 1448 ""grammar.y"" { ( yyval . integer ) = INTEGER_SET_RANGE ; } # line 3102 ""grammar.c"" break ; case 84 : # line 1454 <S2SV_ModEnd> <S2SV_ModStart> 3124 <S2SV_ModEnd> <S2SV_ModStart> 85 : # line 1476 <S2SV_ModEnd> <S2SV_ModStart> 3140 <S2SV_ModEnd> <S2SV_ModStart> 86 : # line 1488 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 87 : # line 1503 ""grammar.y"" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } # line 3164 ""grammar.c"" break ; case 89 : # line 1509 <S2SV_ModEnd> <S2SV_ModStart> 3175 <S2SV_ModEnd> <S2SV_ModStart> 92 : # line 1526 <S2SV_ModEnd> <S2SV_ModStart> 3186 <S2SV_ModEnd> <S2SV_ModStart> 93 : # line 1533 <S2SV_ModEnd> <S2SV_ModStart> 3197 <S2SV_ModEnd> <S2SV_ModStart> 1545 <S2SV_ModEnd> <S2SV_ModStart> UNDEFINED , NULL , NULL ) ; } # line 3205 <S2SV_ModEnd> <S2SV_ModStart> 1549 ""grammar.y"" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } # line 3213 ""grammar.c"" break ; case 97 : # line 1557 <S2SV_ModEnd> <S2SV_ModStart> 3221 <S2SV_ModEnd> <S2SV_ModStart> 98 : # line 1561 <S2SV_ModEnd> <S2SV_ModStart> 3235 <S2SV_ModEnd> <S2SV_ModStart> 99 : # line 1571 <S2SV_ModEnd> <S2SV_ModStart> 3253 <S2SV_ModEnd> <S2SV_ModStart> 100 : # line 1585 <S2SV_ModEnd> <S2SV_ModStart> 3273 <S2SV_ModEnd> <S2SV_ModStart> 101 : # line 1601 <S2SV_ModEnd> <S2SV_ModStart> 3287 <S2SV_ModEnd> <S2SV_ModStart> 102 : # line 1611 <S2SV_ModEnd> <S2SV_ModStart> 3300 <S2SV_ModEnd> <S2SV_ModStart> 103 : # line 1620 <S2SV_ModEnd> <S2SV_ModStart> 3329 <S2SV_ModEnd> <S2SV_ModStart> 104 : # line 1645 <S2SV_ModEnd> <S2SV_ModStart> 3345 <S2SV_ModEnd> <S2SV_ModStart> 105 : # line 1657 <S2SV_ModEnd> <S2SV_ModStart> 3361 <S2SV_ModEnd> <S2SV_ModStart> 106 : # line 1669 <S2SV_ModEnd> <S2SV_ModStart> 3381 <S2SV_ModEnd> <S2SV_ModStart> 107 : # line 1685 <S2SV_ModEnd> <S2SV_ModStart> 3397 <S2SV_ModEnd> <S2SV_ModStart> 108 : # line 1697 <S2SV_ModEnd> <S2SV_ModStart> 3417 <S2SV_ModEnd> <S2SV_ModStart> 109 : # line 1713 <S2SV_ModEnd> <S2SV_ModStart> 3466 <S2SV_ModEnd> <S2SV_ModStart> 110 : # line 1758 <S2SV_ModEnd> <S2SV_ModStart> 3489 <S2SV_ModEnd> <S2SV_ModStart> 111 : # line 1777 <S2SV_ModEnd> <S2SV_ModStart> 3511 <S2SV_ModEnd> <S2SV_ModStart> 112 : # line 1795 <S2SV_ModEnd> <S2SV_ModStart> 3533 <S2SV_ModEnd> <S2SV_ModStart> 113 : # line 1813 <S2SV_ModEnd> <S2SV_ModStart> 3555 <S2SV_ModEnd> <S2SV_ModStart> 114 : # line 1831 <S2SV_ModEnd> <S2SV_ModStart> 3585 <S2SV_ModEnd> <S2SV_ModStart> 115 : # line 1857 <S2SV_ModEnd> <S2SV_ModStart> 3607 <S2SV_ModEnd> <S2SV_ModStart> 116 : # line 1875 <S2SV_ModEnd> <S2SV_ModStart> 3621 <S2SV_ModEnd> <S2SV_ModStart> 117 : # line 1885 <S2SV_ModEnd> <S2SV_ModStart> 3635 <S2SV_ModEnd> <S2SV_ModStart> 118 : # line 1895 <S2SV_ModEnd> <S2SV_ModStart> 3649 <S2SV_ModEnd> <S2SV_ModStart> 119 : # line 1905 <S2SV_ModEnd> <S2SV_ModStart> 3663 <S2SV_ModEnd> <S2SV_ModStart> 120 : # line 1915 <S2SV_ModEnd> <S2SV_ModStart> 3677 <S2SV_ModEnd> <S2SV_ModStart> 121 : # line 1925 <S2SV_ModEnd> <S2SV_ModStart> 3691 <S2SV_ModEnd> <S2SV_ModStart> 122 : # line 1935 <S2SV_ModEnd> <S2SV_ModStart> 3699 <S2SV_ModEnd> <S2SV_ModStart> 3703 <S2SV_ModEnd> "
1066,"<S2SV_StartBug> rpc_delay ( task , 3 * HZ ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ; 
1067,"<S2SV_StartBug> gboolean devel ; <S2SV_EndBug> <S2SV_StartBug> child_setup_data . instance_id_fd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> g_ptr_array_add ( flatpak_argv , g_strdup ( extra_args [ i ] ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; g_autoptr ( GString ) env_string = g_string_new ( """" ) <S2SV_ModStart> = - 1 ; child_setup_data . env_fd <S2SV_ModStart> { if ( g_str_has_prefix ( extra_args [ i ] , ""--env="" ) ) { const char * var_val = extra_args [ i ] + strlen ( ""--env="" ) ; if ( var_val [ 0 ] == '\\0' || var_val [ 0 ] == '=' ) { g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>empty<S2SV_blank>name"" ) ; continue ; } if ( strchr ( var_val , '=' ) == NULL ) { g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value"" ) ; continue ; } g_string_append ( env_string , var_val ) ; g_string_append_c ( env_string , '\\0' ) ; } else { <S2SV_ModStart> ) ) ; } } } if ( env_string -> len > 0 ) { g_auto ( GLnxTmpfile ) env_tmpf = { 0 , } ; if ( ! flatpak_buffer_to_sealed_memfd_or_tmpfile ( & env_tmpf , ""environ"" , env_string -> str , env_string -> len , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } child_setup_data . env_fd = glnx_steal_fd ( & env_tmpf . fd ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--env-fd=%d"" , child_setup_data . env_fd "
1068,"<S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> tty_encode_baud_rate ( tty , baud , baud ) ; <S2SV_EndBug> ","<S2SV_ModStart> { baud = min ( baud , 461550 ) ; <S2SV_ModStart> } "
1069,"<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! dev && capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> int no_module ; <S2SV_ModStart> no_module = ! dev ; if ( no_module <S2SV_ModEnd> <S2SV_ModStart> no_module = request_module ( ""netdev-%s"" , name ) ; if ( no_module && capable ( CAP_SYS_MODULE ) ) { if ( ! <S2SV_ModStart> ) pr_err ( ""Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>"" ""with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>"" ""instead\\n"" , name ) ; } } <S2SV_ModEnd> "
1070,<S2SV_StartBug> InitializeCriticalSection ( & finalizer_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; InitializeCriticalSection ( & reference_queue_mutex 
1071,<S2SV_StartBug> StringValue ( data ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ; "
1072,"<S2SV_StartBug> vpx_memcpy ( & local_next_frame , next_frame , sizeof ( * next_frame ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
1073,"<S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ","<S2SV_ModStart> size_t data_size = 0 ; <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } "
1074,"<S2SV_StartBug> VPX_MEMSET_L ( x , 0 , num * size ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
1075,"<S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> ",<S2SV_ModStart> i < NCH ( n ) && 
1076,<S2SV_StartBug> char * authn_header = oidc_cfg_dir_authn_header ( r ) ; <S2SV_EndBug> ,<S2SV_ModStart> oidc_scrub_headers ( r ) ; 
1077,<S2SV_StartBug> int points ; <S2SV_EndBug> ,<S2SV_ModStart> long <S2SV_ModEnd> 
1078,"<S2SV_StartBug> struct dlist * kl = sync_parseline ( imapd_in ) ; <S2SV_EndBug> <S2SV_StartBug> struct dlist * kl = sync_parseline ( imapd_in ) ; <S2SV_EndBug> <S2SV_StartBug> if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcmp ( cmd . s , ""Syncrestore"" ) ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> ! imapd_userisadmin ) goto badcmd ; if ( <S2SV_ModStart> if ( ! imapd_userisadmin ) goto badcmd ; 
1079,"<S2SV_StartBug> if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> memset ( & u_ent , 0 , sizeof ( u_ent ) ) ; "
1080,<S2SV_StartBug> if ( keyring_key -> type != & key_type_logon ) { <S2SV_EndBug> <S2SV_StartBug> down_read ( & keyring_key -> sem ) ; <S2SV_EndBug> <S2SV_StartBug> ukp = user_key_payload ( keyring_key ) ; <S2SV_EndBug> ,"<S2SV_ModStart> down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> ukp = user_key_payload ( keyring_key ) ; if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n"" , __func__ , master_key -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read <S2SV_ModEnd> <S2SV_ModStart> key_put ( keyring_key ) ; return <S2SV_ModEnd> "
1081,"<S2SV_StartBug> # line 495 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 860 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 557 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 854 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 606 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 707 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 784 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 698 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 818 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 677 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 860 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 642 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 916 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 609 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 970 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 599 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1068 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 584 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1142 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 557 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1196 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 550 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1211 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 543 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1221 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 520 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1267 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 499 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> <S2SV_StartBug> # line 1311 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 862 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> ",<S2SV_ModStart> 496 <S2SV_ModEnd> <S2SV_ModStart> 861 <S2SV_ModEnd> <S2SV_ModStart> 558 <S2SV_ModEnd> <S2SV_ModStart> 855 <S2SV_ModEnd> <S2SV_ModStart> 607 <S2SV_ModEnd> <S2SV_ModStart> 708 <S2SV_ModEnd> <S2SV_ModStart> 785 <S2SV_ModEnd> <S2SV_ModStart> 699 <S2SV_ModEnd> <S2SV_ModStart> 819 <S2SV_ModEnd> <S2SV_ModStart> 678 <S2SV_ModEnd> <S2SV_ModStart> 861 <S2SV_ModEnd> <S2SV_ModStart> 643 <S2SV_ModEnd> <S2SV_ModStart> 917 <S2SV_ModEnd> <S2SV_ModStart> 610 <S2SV_ModEnd> <S2SV_ModStart> 971 <S2SV_ModEnd> <S2SV_ModStart> 600 <S2SV_ModEnd> <S2SV_ModStart> 1069 <S2SV_ModEnd> <S2SV_ModStart> 585 <S2SV_ModEnd> <S2SV_ModStart> 1143 <S2SV_ModEnd> <S2SV_ModStart> 558 <S2SV_ModEnd> <S2SV_ModStart> 1197 <S2SV_ModEnd> <S2SV_ModStart> 551 <S2SV_ModEnd> <S2SV_ModStart> 1212 <S2SV_ModEnd> <S2SV_ModStart> 544 <S2SV_ModEnd> <S2SV_ModStart> 1222 <S2SV_ModEnd> <S2SV_ModStart> 521 <S2SV_ModEnd> <S2SV_ModStart> 1268 <S2SV_ModEnd> <S2SV_ModStart> 500 <S2SV_ModEnd> <S2SV_ModStart> 1312 <S2SV_ModEnd> <S2SV_ModStart> 863 <S2SV_ModEnd> 
1082,<S2SV_StartBug> unsigned fat_length ; <S2SV_EndBug> <S2SV_StartBug> fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ; <S2SV_EndBug> <S2SV_StartBug> data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ; <S2SV_EndBug> ,"<S2SV_ModStart> off_t <S2SV_ModEnd> <S2SV_ModStart> if ( ! fat_length ) die ( ""FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; <S2SV_ModStart> ; if ( data_size < fs -> cluster_size ) die ( ""Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters"" ) "
1083,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> <S2SV_ModStart> ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb ) 
1084,<S2SV_StartBug> while ( lp -> s != NULL ) { <S2SV_EndBug> <S2SV_StartBug> l2info -> bundle = l2info -> cookie [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> l2info -> bundle = l2info -> cookie [ 1 ] ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> ND_TCHECK2 ( p [ 0 ] , 2 ) ; <S2SV_ModStart> ND_TCHECK2 ( p [ 0 ] , 2 ) ; "
1085,<S2SV_StartBug> return ep ; <S2SV_EndBug> ,<S2SV_ModStart> global_ep <S2SV_ModEnd> 
1086,<S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> ,<S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> <S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> <S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> <S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> <S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> <S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> <S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> 
1087,"<S2SV_StartBug> if ( ixheaacd_real_synth_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ptr_hbe_txposer -> <S2SV_ModStart> ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) <S2SV_ModEnd> 
1088,"<S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug> ",<S2SV_ModStart> == 0 || apic -> lapic_timer . period 
1089,"<S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> <S2SV_ModStart> buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> <S2SV_ModStart> curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1090,"<S2SV_StartBug> stream -> bufbase_ = JAS_CAST ( uchar * , buf ) ; <S2SV_EndBug> ",<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
1091,"<S2SV_StartBug> pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * PIPE_DEF_BUFFERS , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> pipe -> buffers = PIPE_DEF_BUFFERS ; <S2SV_EndBug> <S2SV_StartBug> kfree ( pipe ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> pipe_bufs <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> <S2SV_ModStart> free_uid ( user ) ; "
1092,"<S2SV_StartBug> memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> strlcpy <S2SV_ModEnd> <S2SV_ModStart> strlcpy <S2SV_ModEnd> 
1093,<S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cd -> disk ) continue ; 
1094,"<S2SV_StartBug> if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ( len > 12 ) && <S2SV_ModStart> ( len > 9 ) && 
1095,<S2SV_StartBug> if ( <S2SV_EndBug> ,<S2SV_ModStart> p -> replacement_session_keyring = NULL ; 
1096,"<S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> error = dwg_encode_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( klass ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dwg_encode_UNKNOWN_ENT ( dat , obj ) ; else error = <S2SV_ModStart>  <S2SV_ModEnd> "
1097,"<S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! tbuf ) { return NULL ; } 
1098,"<S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , level , offset ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , last_off <S2SV_ModStart> ; last_off = off <S2SV_ModStart> if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ; "
1099,"<S2SV_StartBug> u_char showspi , showdata , showsomedata ; <S2SV_EndBug> <S2SV_StartBug> showdata = 0 ; <S2SV_EndBug> <S2SV_StartBug> showsomedata = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( 3 < ndo -> ndo_vflag ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( showsomedata && cp < ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cp < ep ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
1100,<S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } 
1101,<S2SV_StartBug> # ifndef OPENSSL_NO_COMP <S2SV_EndBug> ,<S2SV_ModStart> if OPENSSL_VERSION_NUMBER >= 0x10101000L print_tmp_key ( c -> ssl ) ; # endif # 
1102,"<S2SV_StartBug> unregister_savevm ( DEVICE ( s ) , ""stellaris_enet"" , s ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1103,<S2SV_StartBug> if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) <S2SV_EndBug> ,<S2SV_ModStart> || replay_esn -> bmp_len != up -> bmp_len 
1104,<S2SV_StartBug> if ( packet -> size + length > MT_PACKET_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart> length > MT_PACKET_LEN - <S2SV_ModStart>  <S2SV_ModEnd> 
1105,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> <S2SV_StartBug> lc -> starting_buffer_level = oxcf -> starting_buffer_level ; <S2SV_EndBug> <S2SV_StartBug> lc -> framerate = cpi -> output_framerate ; <S2SV_EndBug> ,<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> alt_ref_source <S2SV_ModEnd> <S2SV_ModStart> alt_ref_source <S2SV_ModEnd> 
1106,<S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & entry , 0 , sizeof ( entry ) ) "
1107,<S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> ,<S2SV_ModStart> RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case 
1108,<S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> ,<S2SV_ModStart> case L2CAP_MODE_STREAMING : 
1109,"<S2SV_StartBug> if ( vp9_segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> ",<S2SV_ModStart> segfeature_active <S2SV_ModEnd> 
1110,"<S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , <S2SV_EndBug> ","<S2SV_ModStart> slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set"" ) ; <S2SV_ModStart> LDAP_INVALID_CREDENTIALS , NULL , <S2SV_ModEnd> "
1111,<S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 2 ; <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> 
1112,"<S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank>HDRI"" <S2SV_EndBug> <S2SV_StartBug> ; <S2SV_EndBug> ","<S2SV_ModStart> MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" <S2SV_ModEnd> <S2SV_ModStart> # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" <S2SV_ModStart> # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif "
1113,"<S2SV_StartBug> if ( len == 1 ) <S2SV_EndBug> <S2SV_StartBug> return 8 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t dlen = read_u32 ( data , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dlen > 0 ) <S2SV_EndBug> <S2SV_StartBug> return 8 + dlen ; <S2SV_EndBug> ","<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> if ( dlen > ( 1 << 20 ) ) { error_report ( ""vnc:<S2SV_blank>client_cut_text<S2SV_blank>msg<S2SV_blank>payload<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>bytes"" ""<S2SV_blank>which<S2SV_blank>exceeds<S2SV_blank>our<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB."" , dlen ) ; vnc_client_error ( vs ) ; break ; } <S2SV_ModStart> { <S2SV_ModStart> } "
1114,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> case EGRESS_VLAN_NAME : <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; * data && i < length ; i ++ , data ++ ) <S2SV_EndBug> ","<S2SV_ModStart> goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; if ( * data ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; } <S2SV_ModEnd> <S2SV_ModStart> if ( length < 1 ) goto trunc ; <S2SV_ModStart> i < length && * data <S2SV_ModEnd> "
1115,<S2SV_StartBug> if ( ( s -> options & SSL_OP_EPHEMERAL_RSA ) <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> tmp . use_rsa_tmp = 1 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 ; if ( <S2SV_ModEnd> 
1116,"<S2SV_StartBug> int tlen ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK ( * vqp_common_header ) ; <S2SV_EndBug> <S2SV_StartBug> vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( vqp_obj_type ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> case VQP_OBJ_MAC_NULL : <S2SV_EndBug> ",<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> if ( vqp_obj_len > tlen ) goto trunc ; <S2SV_ModStart> if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModStart> if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ; 
1117,"<S2SV_StartBug> TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , <S2SV_EndBug> <S2SV_StartBug> TPM2B_DIGEST tmpResult ; <S2SV_EndBug> <S2SV_StartBug> TPM_RC rval ; <S2SV_EndBug> <S2SV_StartBug> while ( resultKey -> t . size < bytes ) <S2SV_EndBug> <S2SV_StartBug> i_Swizzled = string_bytes_endian_convert_32 ( i ) ; <S2SV_EndBug> <S2SV_StartBug> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; <S2SV_EndBug> <S2SV_StartBug> rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rval != TPM_RC_SUCCESS ) <S2SV_EndBug> <S2SV_StartBug> return TSS2_SYS_RC_BAD_VALUE ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = TPM_RC_SUCCESS <S2SV_ModStart> const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> TPM2B_DIGEST tmpResult ; <S2SV_ModStart> ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> <S2SV_ModStart> TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> <S2SV_ModStart> ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> <S2SV_ModStart> rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> "
1118,<S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,<S2SV_ModStart> k <S2SV_ModEnd> 
1119,<S2SV_StartBug> fid -> udf . generation = inode -> i_generation ; <S2SV_EndBug> ,<S2SV_ModStart> parent_partref = 0 ; fid -> udf . 
1120,"<S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 ) "
1121,<S2SV_StartBug> client -> auth_user = client -> db -> auth_user ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1122,<S2SV_StartBug> if ( ( 1 != ps_dec_state -> u2_decode_header ) && ( ( bytes_remaining > 0 ) || ps_dec_state -> u1_flushfrm ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && ( 1 == ps_dec_state -> u2_header_done ) 
1123,"<S2SV_StartBug> nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode <S2SV_ModEnd> 
1124,"<S2SV_StartBug> static void duplicate_mode_info_in_sb ( VP9_COMMON * const cm , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1125,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1126,<S2SV_StartBug> if ( ctx -> might_cancel ) { <S2SV_EndBug> <S2SV_StartBug> spin_lock ( & cancel_lock ) ; <S2SV_EndBug> <S2SV_StartBug> list_del_rcu ( & ctx -> clist ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & cancel_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> <S2SV_ModStart> __timerfd_remove_cancel ( ctx <S2SV_ModEnd> <S2SV_ModStart> ctx -> <S2SV_ModStart>  <S2SV_ModEnd> 
1127,"<S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * elems <S2SV_ModStart> long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> ; if ( target_offset < size_of_base_struct ) return - EINVAL "
1128,<S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> <S2SV_StartBug> * uaddrlen = sizeof ( sllc ) ; <S2SV_EndBug> ,"<S2SV_ModStart> - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1129,<S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> ,"<S2SV_ModStart> create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ; "
1130,<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> error = security_mmap_addr ( address ) ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> if ( address < mmap_min_addr ) return - EPERM <S2SV_ModEnd> 
1131,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ; 
1132,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> ",<S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
1133,"<S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1134,<S2SV_StartBug> rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ; <S2SV_EndBug> ,<S2SV_ModStart> EXTRACT_16BITS <S2SV_ModEnd> 
1135,"<S2SV_StartBug> void vp9_model_to_full_probs ( const vp9_prob * model , vp9_prob * full ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( full , model , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
1136,"
","
"
1137,<S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1138,<S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> ,<S2SV_ModStart> ( ICANON | EXTPROC ) <S2SV_ModEnd> 
1139,"<S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> <S2SV_StartBug> char * src ; <S2SV_EndBug> <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> <S2SV_StartBug> ret += chars ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> ","<S2SV_ModStart> struct iov_iter * from <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart> = 0 <S2SV_ModEnd> <S2SV_ModStart> = iov_iter_count ( from ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> <S2SV_ModStart> do_wakeup = 1 ; <S2SV_ModStart> ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> <S2SV_ModStart> int copied <S2SV_ModEnd> <S2SV_ModStart> copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> <S2SV_ModStart> copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> <S2SV_ModStart> copied <S2SV_ModEnd> <S2SV_ModStart> copied <S2SV_ModEnd> <S2SV_ModStart> if ( ! iov_iter_count ( from ) <S2SV_ModEnd> "
1140,"<S2SV_StartBug> u32 i , j , page_count = 0 , sg_per_table ; <S2SV_EndBug> <S2SV_StartBug> sg_table = rd_dev -> sg_table_array ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( sg_table ) ; <S2SV_EndBug> ","<S2SV_ModStart> page_count <S2SV_ModEnd> <S2SV_ModStart> page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1141,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> = 1 
1142,<S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> <S2SV_ModStart> { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> <S2SV_ModStart> { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> <S2SV_ModStart> { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> <S2SV_ModStart> { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> <S2SV_ModStart> { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1143,"<S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> 
1144,"<S2SV_StartBug> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""cipher"" , sizeof ( rcipher . type ) <S2SV_ModEnd> "
1145,<S2SV_StartBug> case DH6OPT_RECONF_MSG : <S2SV_EndBug> ,"<S2SV_ModStart> if ( optlen != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } "
1146,<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> read_config_file ( ) ; <S2SV_EndBug> <S2SV_StartBug> umask ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> umask ( 022 ) ; <S2SV_ModStart> global_data -> umask = umask_val ; <S2SV_ModStart>  <S2SV_ModEnd> 
1147,<S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) 
1148,"<S2SV_StartBug> static void encode_unsigned_max ( struct vp9_write_bit_buffer * wb , <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
1149,"<S2SV_StartBug> hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , <S2SV_EndBug> ",<S2SV_ModStart> if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; } 
1150,"<S2SV_StartBug> if ( xmlPushInput ( ctxt , input ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> 
1151,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> it = it -> next ; 
1152,"<S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_MCID_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> tptr = tptr + sizeof ( struct isis_subtlv_spb_mcid ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , stlv_len ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN <S2SV_ModEnd> <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_ModStart> while ( stlv_len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_ModStart> tptr += stlv_len ; len -= stlv_len ; "
1153,"<S2SV_StartBug> int i , protocol ; <S2SV_EndBug> <S2SV_StartBug> switch ( protocol ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! h1 -> bInCollection ) { <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int rest_bytes <S2SV_ModStart> rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>control<S2SV_blank>header\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , ""too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n"" ) ; return - EINVAL ; } if ( <S2SV_ModStart> ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n"" "
1154,<S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ERR_PTR ( - ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> goto couldnt_alloc_key ; <S2SV_EndBug> <S2SV_StartBug> couldnt_alloc_key : <S2SV_EndBug> <S2SV_StartBug> key_put ( dest_keyring ) ; <S2SV_EndBug> ,<S2SV_ModStart> ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> <S2SV_ModStart> error_put_dest_keyring <S2SV_ModEnd> <S2SV_ModStart> error_put_dest_keyring <S2SV_ModEnd> <S2SV_ModStart> error : 
1155,"<S2SV_StartBug> int mi_row , int mi_col , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = xd -> mi ; <S2SV_EndBug> <S2SV_StartBug> const int left_in_image = xd -> left_available && mi_8x8 [ - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * above_sb64_mi_8x8 ; <S2SV_EndBug> <S2SV_StartBug> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE max_size = BLOCK_64X64 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * const prev_mi = <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , prev_mi , & min_size , & max_size ) ; <S2SV_EndBug> <S2SV_StartBug> left_sb64_mi_8x8 = & mi_8x8 [ - MI_BLOCK_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , left_sb64_mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> above_sb64_mi_8x8 = & mi_8x8 [ - xd -> mi_stride * MI_BLOCK_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , above_sb64_mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> min_size = MIN ( min_size , max_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCKD * const xd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; int bs_hist [ BLOCK_SIZES ] = { 0 } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xd <S2SV_ModEnd> <S2SV_ModStart> , bs_hist <S2SV_ModStart> MODE_INFO * * left_sb64_mi = & mi <S2SV_ModEnd> <S2SV_ModStart> xd , left_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> <S2SV_ModStart> MODE_INFO * * above_sb64_mi = & mi <S2SV_ModEnd> <S2SV_ModStart> xd , above_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> <S2SV_ModStart> if ( vp9_active_edge_sb ( cpi , mi_row , mi_col ) ) { min_size = BLOCK_4X4 ; } else { <S2SV_ModStart> cpi -> sf . rd_auto_partition_min_limit , MIN ( min_size , max_size ) ) ; } <S2SV_ModEnd> "
1156,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> install_keyword ( ""umask"" , & umask_handler ) ; "
1157,<S2SV_StartBug> while ( ret < nr ) { <S2SV_EndBug> ,<S2SV_ModStart> head %= ctx -> nr_events ; tail %= ctx -> nr_events ; 
1158,"<S2SV_StartBug> nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode <S2SV_ModEnd> 
1159,"<S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < s ) || ( dataofs + s < dataofs ) || ( dataofs + s > buf_size ) ) { <S2SV_EndBug> ","<S2SV_ModStart> CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; continue ; } <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) <S2SV_ModEnd> <S2SV_ModStart> ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> "
1160,"<S2SV_StartBug> if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) { <S2SV_EndBug> <S2SV_StartBug> tp -> tv_sec = div_long_long_rem ( cpu . sched , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> * tp = ns_to_timespec <S2SV_ModEnd> <S2SV_ModStart> ) ; else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1161,<S2SV_StartBug> mnt_flags |= MNT_NODEV ; <S2SV_EndBug> ,<S2SV_ModStart> | MNT_LOCK_NODEV 
1162,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
1163,"<S2SV_StartBug> void vp9_diff_update_prob ( vp9_reader * r , vp9_prob * p ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_read ( r , DIFF_UPDATE_PROB ) ) { <S2SV_EndBug> <S2SV_StartBug> * p = ( vp9_prob ) inv_remap_prob ( delp , * p ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
1164,"<S2SV_StartBug> struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) <S2SV_EndBug> ",<S2SV_ModStart> fmode_t <S2SV_ModEnd> 
1165,<S2SV_StartBug> if ( ! port -> interrupt_in_urb ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1166,"<S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1167,"<S2SV_StartBug> size_t len , next_len ; <S2SV_EndBug> <S2SV_StartBug> next_len = MIN ( left , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ; left > 0 ; left -= len , out_ptr += len ) { <S2SV_EndBug> <S2SV_StartBug> next_len = MIN ( left , apdu . sw2 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> left -= len ; out_ptr += len ; len <S2SV_ModEnd> 
1168,"<S2SV_StartBug> case FRAME_TYPE_JOIN_ACCEPT : <S2SV_EndBug> <S2SV_StartBug> if ( MAX ( 0 , ( int16_t ) ( ( int16_t ) size - ( int16_t ) LORA_MAC_FRMPAYLOAD_OVERHEAD ) ) > ( int16_t ) phyParam . Value ) <S2SV_EndBug> ",<S2SV_ModStart> if ( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; return ; } <S2SV_ModStart> ( <S2SV_ModStart> LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE <S2SV_ModEnd> <S2SV_ModStart> ) || ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) 
1169,"<S2SV_StartBug> lxc_attach_options_t * options = payload -> options ; <S2SV_EndBug> <S2SV_StartBug> if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) ) { <S2SV_EndBug> <S2SV_StartBug> int proc_mounted ; <S2SV_EndBug> <S2SV_StartBug> proc_mounted = mount_proc_if_needed ( ""/"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = lsm_process_label_set ( init_ctx -> lsm_label , <S2SV_EndBug> <S2SV_StartBug> rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> int procfd = payload -> procfd ; <S2SV_ModStart> && init_ctx -> lsm_label <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( lsm_set_label_at ( procfd , on_exec , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> close ( procfd ) ; "
1170,"<S2SV_StartBug> struct fsnotify_group * group ; <S2SV_EndBug> <S2SV_StartBug> user = get_current_user ( ) ; <S2SV_EndBug> <S2SV_StartBug> group = inotify_new_group ( user , inotify_max_queued_events ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( group ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = PTR_ERR ( group ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret >= 0 ) <S2SV_EndBug> <S2SV_StartBug> fsnotify_put_group ( group ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> < 0 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1171,<S2SV_StartBug> i += 1 ; <S2SV_EndBug> ,<S2SV_ModStart> ++ <S2SV_ModEnd> 
1172,"<S2SV_StartBug> static vpx_codec_err_t vp8e_use_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1173,"<S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> <S2SV_StartBug> for_each_possible_cpu ( i ) <S2SV_EndBug> <S2SV_StartBug> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , <S2SV_EndBug> <S2SV_StartBug> if ( list_lru_init ( & s -> s_dentry_lru ) ) <S2SV_EndBug> <S2SV_StartBug> if ( list_lru_init ( & s -> s_inode_lru ) ) <S2SV_EndBug> ","<S2SV_ModStart> for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 <S2SV_ModEnd> <S2SV_ModStart> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> s_inode_lru <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1174,"<S2SV_StartBug> struct page * pages [ NFS4ACL_MAXPAGES ] ; <S2SV_EndBug> <S2SV_StartBug> struct page * localpage = NULL ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > args . acl_len ) <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > buflen ) <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( buf , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> __free_page ( localpage ) ; <S2SV_EndBug> ","<S2SV_ModStart> = { NULL , } <S2SV_ModStart> int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> <S2SV_ModStart> res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> <S2SV_ModStart> acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + res . acl_data_offset , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> _copy_from_pages <S2SV_ModEnd> <S2SV_ModStart> pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> <S2SV_ModStart> for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> <S2SV_ModStart> pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> "
1175,<S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; } 
1176,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
1177,<S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> "
1178,<S2SV_StartBug> if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <S2SV_EndBug> ,<S2SV_ModStart> is_nmi ( intr_info ) <S2SV_ModEnd> 
1179,<S2SV_StartBug> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> ,<S2SV_ModStart> skb_is_err_queue ( skb ) && 
1180,<S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < self -> mt_allocated ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> size_t 
1181,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_queue_exception ( vcpu , UD_VECTOR ) ; <S2SV_EndBug> <S2SV_StartBug> return EMULATE_FAIL ; <S2SV_EndBug> ",<S2SV_ModStart> int r = EMULATE_DONE ; <S2SV_ModStart> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_ModStart> r = EMULATE_FAIL ; } <S2SV_ModStart> r <S2SV_ModEnd> 
1182,<S2SV_StartBug> unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ; <S2SV_EndBug> <S2SV_StartBug> pos += skb_headlen ( list_skb ) ; <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( ! nfrags ) ; <S2SV_EndBug> <S2SV_StartBug> * nskb_frag = * frag ; <S2SV_EndBug> ,"<S2SV_ModStart> ; struct sk_buff * frag_skb = head_skb <S2SV_ModStart> frag_skb = list_skb ; <S2SV_ModStart> frag_skb = list_skb ; <S2SV_ModStart> if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ; "
1183,<S2SV_StartBug> next_byte : <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> pc - pc_start > 14 ) { goto illegal_op ; } 
1184,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; "
1185,<S2SV_StartBug> if ( i4_continue_decode ) <S2SV_EndBug> ,"<S2SV_ModStart> 1 == ps_dec -> i4_num_cores && 0 == ps_dec -> u2_num_mbs_left ) { i4_continue_decode = 0 ; android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ; } if ( "
1186,"<S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> ","<S2SV_ModStart> lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> "
1187,"<S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> ","<S2SV_ModStart> , u8 status <S2SV_ModStart> status <S2SV_ModEnd> "
1188,<S2SV_StartBug> if ( ! cfg . shell ) <S2SV_EndBug> <S2SV_StartBug> arg [ 0 ] = cfg . shell ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/bin/sh"" <S2SV_ModEnd> "
1189,"<S2SV_StartBug> int64_t vp9_rd_pick_inter_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int * returnrate , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE this_mode ; <S2SV_EndBug> <S2SV_StartBug> int comp_pred , i ; <S2SV_EndBug> <S2SV_StartBug> int_mv single_newmv [ MAX_REF_FRAMES ] = { { 0 } } ; <S2SV_EndBug> <S2SV_StartBug> int64_t best_tx_rd [ TX_MODES ] ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO best_mbmode = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> int mode_index , best_mode_index = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob comp_mode_p ; <S2SV_EndBug> <S2SV_StartBug> int64_t best_inter_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE best_intra_mode = DC_PRED ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE mode_uv [ TX_SIZES ] ; <S2SV_EndBug> <S2SV_StartBug> int64_t mode_distortions [ MB_MODE_COUNT ] = { - 1 } ; <S2SV_EndBug> <S2SV_StartBug> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; <S2SV_EndBug> <S2SV_StartBug> int mode_skip_mask = 0 ; <S2SV_EndBug> <S2SV_StartBug> int mode_skip_start = cpi -> sf . mode_skip_start + 1 ; <S2SV_EndBug> <S2SV_StartBug> const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> const int mode_search_skip_flags = cpi -> sf . mode_search_skip_flags ; <S2SV_EndBug> <S2SV_StartBug> estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp , <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> * returnrate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_buffer_inter ( cpi , x , tile , <S2SV_EndBug> <S2SV_StartBug> static const int ref_frame_mask_all [ ] = { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . reference_masking ) { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= ref_frame_mask_fixedmv [ ref_frame ] ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && <S2SV_EndBug> <S2SV_StartBug> vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> const int altref_zero_mask = <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= ( 1 << THR_NEARA ) ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= ( 1 << THR_NEARESTA ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize > cpi -> sf . max_intra_bsize ) { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= 0xFF30808 ; <S2SV_EndBug> <S2SV_StartBug> int mode_index ; <S2SV_EndBug> <S2SV_StartBug> int64_t tx_cache [ TX_MODES ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mode_index == mode_skip_start ) { <S2SV_EndBug> <S2SV_StartBug> switch ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] ) { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= LAST_FRAME_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= GOLDEN_FRAME_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= ALT_REF_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( mode_skip_mask & ( 1 << mode_index ) ) <S2SV_EndBug> <S2SV_StartBug> if ( best_rd < ( ( int64_t ) rd_threshes [ mode_index ] * <S2SV_EndBug> <S2SV_StartBug> this_mode = vp9_mode_order [ mode_index ] . mode ; <S2SV_EndBug> <S2SV_StartBug> if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && <S2SV_EndBug> <S2SV_StartBug> vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( intra_y_mode_mask & ( 1 << this_mode ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] > INTRA_FRAME ) <S2SV_EndBug> <S2SV_StartBug> if ( x -> in_active_map && <S2SV_EndBug> <S2SV_StartBug> if ( ! check_best_zero_mv ( cpi , mbmi -> mode_context , frame_mv , <S2SV_EndBug> <S2SV_StartBug> x -> skip = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; ++ i ) <S2SV_EndBug> <S2SV_StartBug> intra_super_block_yrd ( cpi , x , & rate_y , & distortion_y , & skippable , NULL , <S2SV_EndBug> <S2SV_StartBug> bsize , tx_cache , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> uv_tx = get_uv_tx_size_impl ( mbmi -> tx_size , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> choose_intra_uv_mode ( cpi , ctx , bsize , uv_tx , <S2SV_EndBug> <S2SV_StartBug> rate2 = rate_y + x -> mbmode_cost [ mbmi -> mode ] + rate_uv_intra [ uv_tx ] ; <S2SV_EndBug> <S2SV_StartBug> this_rd = handle_inter_mode ( cpi , x , tile , bsize , <S2SV_EndBug> <S2SV_StartBug> & rate_y , & distortion_y , <S2SV_EndBug> <S2SV_StartBug> & tmp_best_filter , frame_mv , <S2SV_EndBug> <S2SV_StartBug> single_newmv , & total_sse , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id , <S2SV_EndBug> <S2SV_StartBug> rate_uv = 0 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( mb_skip_allowed && ref_frame != INTRA_FRAME && ! xd -> lossless ) { <S2SV_EndBug> <S2SV_StartBug> rate_y = 0 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( mb_skip_allowed ) { <S2SV_EndBug> <S2SV_StartBug> if ( ref_frame == INTRA_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ; <S2SV_EndBug> <S2SV_StartBug> * returnrate = rate2 ; <S2SV_EndBug> <S2SV_StartBug> * returndistortion = distortion2 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> select_txfm_size ) <S2SV_EndBug> <S2SV_StartBug> swap_block_ptr ( x , ctx , max_plane ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] , <S2SV_EndBug> <S2SV_StartBug> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; <S2SV_EndBug> <S2SV_StartBug> const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int scale = 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ? <S2SV_EndBug> <S2SV_StartBug> else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> adj_rd = cpi -> mask_filter_rd - ref + 10 ; <S2SV_EndBug> <S2SV_StartBug> adj_rd = cpi -> rd_filter_cache [ i ] - ref ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( best_rd >= best_rd_so_far ) <S2SV_EndBug> <S2SV_StartBug> if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> uv_tx_size = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_rd_thresh ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> void <S2SV_ModEnd> <S2SV_ModStart> TileDataEnc * tile_data , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost , <S2SV_ModEnd> <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; RD_OPT * const rd_opt = & cpi -> rd ; SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModStart> ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> , k <S2SV_ModStart> ; INTERP_FILTER single_inter_filter [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; int single_skippable [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; int best_mode_skippable = 0 ; int midx <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> unsigned int best_pred_sse = UINT_MAX ; PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModEnd> <S2SV_ModStart> vp9_get_intra_cost_penalty ( <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth ) <S2SV_ModEnd> <S2SV_ModStart> uint8_t ref_frame_skip_mask [ 2 ] = { 0 } ; uint16_t mode_skip_mask [ MAX_REF_FRAMES ] = { 0 } <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> rd_opt -> threshes <S2SV_ModEnd> <S2SV_ModStart> tile_data -> thresh_freq_fact [ bsize ] ; int64_t mode_threshold [ MAX_MODES ] ; int * mode_map = tile_data -> mode_map <S2SV_ModEnd> <S2SV_ModStart> sf -> mode_search_skip_flags ; int64_t mask_filter = 0 ; int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ; vp9_zero ( best_mbmode ) ; x -> skip_encode = sf -> <S2SV_ModEnd> <S2SV_ModStart> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_cache [ i ] = INT64_MAX ; estimate_ref_frame_costs ( cm , xd <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( i = 0 ; i < MB_MODE_COUNT ; ++ i ) { for ( k = 0 ; k < MAX_REF_FRAMES ; ++ k ) { single_inter_filter [ i ] [ k ] = SWITCHABLE ; single_skippable [ i ] [ k ] = 0 ; } } rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> assert ( get_ref_frame_buffer <S2SV_ModEnd> <S2SV_ModStart> ref_frame ) != NULL ) ; setup_buffer_inter ( cpi , x , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> [ ref_frame ] |= INTER_NEAREST_NEAR_ZERO <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> get_segdata <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; } <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] = ( 1 << LAST_FRAME ) | ( 1 << GOLDEN_FRAME ) ; ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; mode_skip_mask [ ALTREF_FRAME ] = ~ INTER_NEAREST_NEAR_ZERO <S2SV_ModEnd> <S2SV_ModStart> [ ALTREF_FRAME ] <S2SV_ModStart> NEARMV <S2SV_ModEnd> <S2SV_ModStart> [ ALTREF_FRAME ] <S2SV_ModStart> NEARESTMV ) ; } } if ( cpi -> rc . is_src_frame_alt_ref ) { if ( sf -> alt_ref_search_fp ) { mode_skip_mask [ ALTREF_FRAME ] = 0 ; ref_frame_skip_mask [ 0 ] = ~ ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; } } if ( sf -> alt_ref_search_fp ) if ( ! cm -> show_frame && x -> pred_mv_sad [ GOLDEN_FRAME ] < INT_MAX ) if ( x -> pred_mv_sad [ ALTREF_FRAME ] > ( x -> pred_mv_sad [ GOLDEN_FRAME ] << 1 ) ) mode_skip_mask [ ALTREF_FRAME ] |= INTER_ALL ; if ( sf -> adaptive_mode_search ) { if ( cm -> show_frame && ! cpi -> rc . is_src_frame_alt_ref && cpi -> rc . frames_since_golden >= 3 ) if ( x -> pred_mv_sad [ GOLDEN_FRAME ] > ( x -> pred_mv_sad [ LAST_FRAME ] << 1 ) ) mode_skip_mask [ GOLDEN_FRAME ] |= INTER_ALL <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= ( 1 << INTRA_FRAME ) ; ref_frame_skip_mask [ 1 ] |= ( 1 << INTRA_FRAME ) ; } mode_skip_mask [ INTRA_FRAME ] |= ~ ( sf -> intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] ) ; for ( i = 0 ; i <= LAST_NEW_MV_INDEX ; ++ i ) mode_threshold [ i ] = 0 ; for ( i = LAST_NEW_MV_INDEX + 1 ; i < MAX_MODES ; ++ i ) mode_threshold [ i ] = ( ( int64_t ) rd_threshes [ i ] * rd_thresh_freq_fact [ i ] ) >> 5 ; midx = sf -> schedule_mode_search ? mode_skip_start : 0 ; while ( midx > 4 ) { uint8_t end_pos = 0 ; for ( i = 5 ; i < midx ; ++ i ) { if ( mode_threshold [ mode_map [ i - 1 ] ] > mode_threshold [ mode_map [ i ] ] ) { uint8_t tmp = mode_map [ i ] ; mode_map [ i ] = mode_map [ i - 1 ] ; mode_map [ i - 1 ] = tmp ; end_pos = i ; } } midx = end_pos ; } for ( midx = 0 ; midx < MAX_MODES ; ++ midx <S2SV_ModEnd> <S2SV_ModStart> = mode_map [ midx ] ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> this_mode = vp9_mode_order [ mode_index ] . mode ; ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 0 ] ; second_ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 1 ] ; if ( midx == mode_skip_start && best_mode_index >= 0 <S2SV_ModEnd> <S2SV_ModStart> best_mbmode <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= LAST_FRAME_MODE_MASK ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] |= GOLDEN_FRAME_MODE_MASK ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> <S2SV_ModStart> ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> break ; } } if ( ( ref_frame_skip_mask [ 0 ] & ( 1 << ref_frame ) ) && ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) ) ) continue ; <S2SV_ModEnd> <S2SV_ModStart> [ ref_frame ] <S2SV_ModStart> this_mode ) ) continue ; if ( best_mode_skippable && sf -> schedule_mode_search ) mode_threshold [ mode_index ] <<= 1 <S2SV_ModEnd> <S2SV_ModStart> mode_threshold <S2SV_ModEnd> <S2SV_ModStart> ) continue ; if ( sf -> motion_field_mode_search ) { const int mi_width = MIN ( num_8x8_blocks_wide_lookup [ bsize ] , tile_info -> mi_col_end - mi_col ) ; const int mi_height = MIN ( num_8x8_blocks_high_lookup [ bsize ] , tile_info -> mi_row_end - mi_row ) ; const int bsl = mi_width_log2_lookup [ bsize ] ; int cb_partition_search_ctrl = ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; MB_MODE_INFO * ref_mbmi ; int const_motion = 1 ; int skip_ref_frame = ! cb_partition_search_ctrl ; MV_REFERENCE_FRAME rf = NONE ; int_mv ref_mv ; ref_mv . as_int = INVALID_MV ; if ( ( mi_row - 1 ) >= tile_info -> mi_row_start ) { ref_mv = xd -> mi [ - xd -> mi_stride ] -> mbmi . mv [ 0 ] ; rf = xd -> mi [ - xd -> mi_stride ] -> mbmi . ref_frame [ 0 ] ; for ( i = 0 ; i < mi_width ; ++ i ) { ref_mbmi = & xd -> mi [ - xd -> mi_stride + i ] -> mbmi ; const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; } } if ( ( mi_col - 1 ) >= tile_info -> mi_col_start ) { if ( ref_mv . as_int == INVALID_MV ) ref_mv = xd -> mi [ - 1 ] -> mbmi . mv [ 0 ] ; if ( rf == NONE ) rf = xd -> mi [ - 1 ] -> mbmi . ref_frame [ 0 ] ; for ( i = 0 ; i < mi_height ; ++ i ) { ref_mbmi = & xd -> mi [ i * xd -> mi_stride - 1 ] -> mbmi ; const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; } } if ( skip_ref_frame && this_mode != NEARESTMV && this_mode != NEWMV ) if ( rf > INTRA_FRAME ) if ( ref_frame != rf ) continue ; if ( const_motion ) if ( this_mode == NEARMV || this_mode == ZEROMV <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart> ! cpi -> allow_comp_inter_inter ) continue ; if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ; if ( <S2SV_ModStart> best_mode_index >= 0 && best_mbmode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sf -> adaptive_mode_search ) if ( ( x -> source_variance << num_pels_log2_lookup [ bsize ] ) > best_pred_sse <S2SV_ModEnd> <S2SV_ModStart> best_mode_index >= 0 && best_mbmode <S2SV_ModEnd> <S2SV_ModStart> const MV_REFERENCE_FRAME ref_frames [ 2 ] = { ref_frame , second_ref_frame } ; <S2SV_ModEnd> <S2SV_ModStart> mbmi_ext -> mode_context , frame_mv , this_mode , ref_frames ) ) continue ; } mbmi -> mode = this_mode ; mbmi -> uv_mode = DC_PRED <S2SV_ModEnd> <S2SV_ModStart> mbmi -> mv [ 0 ] . as_int = mbmi -> mv [ 1 ] . as_int = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct macroblockd_plane * const pd = & xd -> plane [ 1 ] ; memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; super_block_yrd <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , pd -> subsampling_x , pd -> subsampling_y <S2SV_ModStart> , x <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> bsize <S2SV_ModEnd> <S2SV_ModStart> rate_uv , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , single_inter_filter , single_skippable <S2SV_ModStart> , & mask_filter , filter_cache <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rd_variance_adjustment ( cpi , x , bsize , & this_rd , ref_frame , x -> source_variance ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else { best_pred_sse = x -> pred_sse [ ref_frame ] ; } rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> rd_cost -> dist = distortion2 ; rd_cost -> rdcost = this_rd <S2SV_ModEnd> <S2SV_ModStart> best_mode_skippable = skippable ; <S2SV_ModStart> select_tx_size <S2SV_ModEnd> <S2SV_ModStart> 1 , 0 , 0 , <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { qstep >>= ( xd -> bd - 8 ) ; } # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart> mask_filter <S2SV_ModEnd> <S2SV_ModStart> filter_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> best_mbmode . mode == NEWMV ) { const MV_REFERENCE_FRAME refs [ 2 ] = { best_mbmode . ref_frame [ 0 ] , best_mbmode . ref_frame [ 1 ] } ; int comp_pred_mode = refs [ 1 ] > INTRA_FRAME ; if ( frame_mv [ NEARESTMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && ( ( comp_pred_mode && frame_mv [ NEARESTMV ] [ refs [ 1 ] ] . as_int == best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) best_mbmode . mode = NEARESTMV ; else if ( frame_mv [ NEARMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && ( ( comp_pred_mode && frame_mv [ NEARMV ] [ refs [ 1 ] ] . as_int == best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) best_mbmode . mode = NEARMV ; else if ( best_mbmode . mv [ 0 ] . as_int == 0 && ( ( comp_pred_mode && best_mbmode . mv [ 1 ] . as_int == 0 ) || ! comp_pred_mode ) ) best_mbmode . mode = ZEROMV ; } if ( best_mode_index < 0 || <S2SV_ModStart> { rd_cost -> rate = INT_MAX ; rd_cost -> rdcost = INT64_MAX ; return ; } if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> best_mbmode <S2SV_ModEnd> <S2SV_ModStart> , & xd -> plane [ 1 ] <S2SV_ModStart> ! cpi -> rc . is_src_frame_alt_ref ) vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , sf -> adaptive_rd_thresh , bsize , best_mode_index ) ; <S2SV_ModEnd> <S2SV_ModStart> } else { vp9_zero ( best_filter_diff ) ; } x -> skip |= best_mode_skippable ; if ( ! x -> skip && ! x -> select_tx_size ) { int has_high_freq_coeff = 0 ; int plane ; int max_plane = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ? MAX_MB_PLANE : 1 ; for ( plane = 0 ; plane < max_plane ; ++ plane ) { x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 1 ] ; has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; } for ( plane = max_plane ; plane < MAX_MB_PLANE ; ++ plane ) { x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 2 ] ; has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; } best_mode_skippable |= ! has_high_freq_coeff ; } assert ( best_mode_index >= 0 ) ; store_coding_context ( x , ctx , best_mode_index , best_pred_diff , best_filter_diff , best_mode_skippable ) <S2SV_ModEnd> "
1190,<S2SV_StartBug> g_object_unref ( subdir ) ; <S2SV_EndBug> <S2SV_StartBug> dir = GSF_INFILE_TAR ( subdir ) ; <S2SV_EndBug> ,<S2SV_ModStart> dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ; <S2SV_ModStart>  <S2SV_ModEnd> 
1191,"<S2SV_StartBug> int i , attr_id = 0 , nattr ; <S2SV_EndBug> ",<S2SV_ModStart> ; tagname [ 0 ] = '\\0' 
1192,<S2SV_StartBug> BUG_ON ( task_stack_end_corrupted ( prev ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> ) panic ( ""corrupted<S2SV_blank>stack<S2SV_blank>end<S2SV_blank>detected<S2SV_blank>inside<S2SV_blank>scheduler\\n"" "
1193,"<S2SV_StartBug> if ( containsForbiddenChars ( p , l ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( newserv , 0 , sizeof ( struct service ) ) ; "
1194,"<S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1195,<S2SV_StartBug> if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { <S2SV_EndBug> ,<S2SV_ModStart> && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED 
1196,"<S2SV_StartBug> return PyBytes_DecodeEscape ( s , len , NULL , 0 , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> const char * first_invalid_escape ; PyObject * result = _PyBytes_DecodeEscape <S2SV_ModEnd> <S2SV_ModStart> , & first_invalid_escape ) ; if ( result == NULL ) return NULL ; if ( first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_DECREF ( result ) ; return NULL ; } } return result <S2SV_ModEnd> "
1197,"<S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
1198,<S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1199,<S2SV_StartBug> state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fstrndup <S2SV_ModEnd> <S2SV_ModStart> , len "
1200,<S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> <S2SV_StartBug> return change ; <S2SV_EndBug> ,<S2SV_ModStart> ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; 
1201,"<S2SV_StartBug> stat ( options -> in_file , & filestats ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( filestats . st_size < 8 ) { printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n"" ) ; return - 1 ; } "
1202,"<S2SV_StartBug> unsigned long off ; <S2SV_EndBug> <S2SV_StartBug> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) <S2SV_EndBug> <S2SV_StartBug> off = vma -> vm_pgoff << PAGE_SHIFT ; <S2SV_EndBug> <S2SV_StartBug> if ( fb -> fb_mmap ) { <S2SV_EndBug> <S2SV_StartBug> fb_pgprotect ( file , vma , off ) ; <S2SV_EndBug> ","<S2SV_ModStart> mmio_pgoff <S2SV_ModEnd> <S2SV_ModStart> fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( <S2SV_ModEnd> <S2SV_ModStart> >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; start = info -> fix . mmio_start ; len = info -> fix . mmio_len ; } mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> start ) ; return vm_iomap_memory ( vma , start , len ) <S2SV_ModEnd> "
1203,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case Suite_kind : <S2SV_EndBug> ,"<S2SV_ModStart> value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionType . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case "
1204,<S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; canvas_image = DestroyImage ( canvas_image 
1205,"<S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> <S2SV_StartBug> if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) <S2SV_EndBug> <S2SV_StartBug> if ( addr -> l2tp_family != AF_INET ) <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> <S2SV_ModStart> addr -> l2tp_family != AF_INET <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out "
1206,"<S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> while ( tptr < ( pptr + length ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; 
1207,"<S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> + 10 <S2SV_ModStart> int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> "
1208,<S2SV_StartBug> dst [ dst_byte_offset ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1209,<S2SV_StartBug> nPath ++ ; <S2SV_EndBug> ,<S2SV_ModStart> = ( int ) strlen ( zPath ) <S2SV_ModEnd> 
1210,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1211,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; "
1212,<S2SV_StartBug> guint uint_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> <S2SV_StartBug> gboolean bool_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> ; if ( value_len < 4 ) break ; bool_val 
1213,"<S2SV_StartBug> uint16_t auxsize ; <S2SV_EndBug> <S2SV_StartBug> av_get_packet ( pb , pkt , vsize ) ; <S2SV_EndBug> <S2SV_StartBug> av_get_packet ( pb , pkt , asize ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; int ret <S2SV_ModStart> if ( ( ret = <S2SV_ModStart> ) < 0 ) return ret <S2SV_ModStart> if ( ( ret = <S2SV_ModStart> ) < 0 ) return ret 
1214,"<S2SV_StartBug> op = queue_remove_if ( att -> req_queue , match_op_id , UINT_TO_PTR ( id ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( att -> in_disc ) return bt_att_disc_cancel ( att , id ) ; "
1215,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
1216,"<S2SV_StartBug> unsigned int maxw , maxh , max , i ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> free ( r ) ; free ( g ) ; <S2SV_ModEnd> 
1217,<S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> objlen > 1 && <S2SV_ModStart>  <S2SV_ModEnd> 
1218,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> 
1219,<S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> kern_unmount <S2SV_ModEnd> 
1220,<S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; } "
1221,"<S2SV_StartBug> if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> img ) <S2SV_EndBug> <S2SV_StartBug> stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , <S2SV_EndBug> <S2SV_StartBug> img = stream -> img ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( img ) { if ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) <S2SV_ModEnd> <S2SV_ModStart> img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>inputs\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( <S2SV_ModStart> { <S2SV_ModStart> VPX_IMG_FMT_I42016 , cfg -> g_w , cfg -> g_h , 16 ) ; } I420Scale_16 ( ( uint16 * ) img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] / 2 , img -> d_w , img -> d_h , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] / 2 , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ; img = stream -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n"" ""Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n"" ""To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , stream -> index ) ; # endif } } # endif if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) { fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>8bpp<S2SV_blank>inputs\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( ! stream -> img ) stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 <S2SV_ModEnd> <S2SV_ModStart> # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n"" ""Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n"" ""To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , stream -> index ) ; # endif "
1222,<S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> ,<S2SV_ModStart> INT_MAX <S2SV_ModEnd> 
1223,<S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
1224,"<S2SV_StartBug> int ret , wo ; <S2SV_EndBug> <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wo ) <S2SV_EndBug> <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( rlen > MAX_XFER_SIZE ) { warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n"" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> st -> data <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen "
1225,"<S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; "
1226,"<S2SV_StartBug> cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>fixed\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * p ) <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( p ) > 8 ) { <S2SV_ModStart> cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>not<S2SV_blank>fixed\\n"" ) ; } } else { "
1227,"<S2SV_StartBug> if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( dst_group || dst_pid ) <S2SV_ModEnd> 
1228,"<S2SV_StartBug> err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( err <S2SV_ModEnd> "
1229,"<S2SV_StartBug> * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , <S2SV_EndBug> ","<S2SV_ModStart> if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , ""63662938"" ) ; return - EINVAL ; } "
1230,"<S2SV_StartBug> static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE * mode_uv ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1231,"<S2SV_StartBug> void nfs4_close_state ( struct path * path , struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> <S2SV_StartBug> __nfs4_close ( path , state , mode , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
1232,"<S2SV_StartBug> return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct dentry * root = <S2SV_ModEnd> <S2SV_ModStart> if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ; 
1233,"<S2SV_StartBug> uint32 rows , uint32 cols , int outskew , int inskew ) <S2SV_EndBug> ",<S2SV_ModStart> int64 <S2SV_ModEnd> 
1234,"<S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> "
1235,<S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> ,<S2SV_ModStart> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
1236,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1237,<S2SV_StartBug> o4 = o * sizeof ( uint32_t ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( q + o >= e ) goto out ; 
1238,<S2SV_StartBug> for ( plane = 0 ; plane < 3 ; ++ plane ) { <S2SV_EndBug> <S2SV_StartBug> const int w = ( plane ? ( 1 + yuv_frame -> d_w ) / 2 : yuv_frame -> d_w ) ; <S2SV_EndBug> <S2SV_StartBug> const int h = ( plane ? ( 1 + yuv_frame -> d_h ) / 2 : yuv_frame -> d_h ) ; <S2SV_EndBug> <S2SV_StartBug> size_t needed = w ; <S2SV_EndBug> ,"<S2SV_ModStart> const int bytespp = ( yuv_frame -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> vpx_img_plane_width ( yuv_frame , plane <S2SV_ModEnd> <S2SV_ModStart> vpx_img_plane_height ( yuv_frame , plane <S2SV_ModEnd> <S2SV_ModStart> * bytespp "
1239,"<S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> unsigned int ret <S2SV_ModEnd> <S2SV_ModStart> md5_transform <S2SV_ModEnd> <S2SV_ModStart> random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> 
1240,"<S2SV_StartBug> CallInfo * ci = next_ci ( L ) ; <S2SV_EndBug> <S2SV_StartBug> ci -> func = func ; <S2SV_EndBug> <S2SV_StartBug> CallInfo * ci = next_ci ( L ) ; <S2SV_EndBug> <S2SV_StartBug> checkstackp ( L , fsize , func ) ; <S2SV_EndBug> <S2SV_StartBug> checkstackp ( L , 1 , func ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; checkstackGCp ( L , LUA_MINSTACK , func ) ; L -> ci = ci <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> checkstackGCp <S2SV_ModEnd> <S2SV_ModStart> ) ; L -> ci = ci = next_ci ( L <S2SV_ModStart> checkstackGCp <S2SV_ModEnd> "
1241,"<S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = ns_to_timespec ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = ns_to_timespec ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1242,<S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1243,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , icmp6_tstr <S2SV_ModEnd> "
1244,"<S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
1245,<S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1246,<S2SV_StartBug> if ( server . vm_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( server . vm_enabled ) vmInit ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> ds_enabled <S2SV_ModEnd> <S2SV_ModStart> ds_enabled ) dsInit <S2SV_ModEnd> 
1247,"<S2SV_StartBug> assert_regexp_syntax_error ( "")"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\ta\\0b\\0c\\0"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\ta\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0x\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0b\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""abc"" ) ; <S2SV_ModStart> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" <S2SV_ModEnd> "
1248,<S2SV_StartBug> struct tcp_sock_t * tcp_socket ; <S2SV_EndBug> <S2SV_StartBug> while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL && <S2SV_EndBug> <S2SV_StartBug> g_options . only_desired_port == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> uint16_t real_port = tcp_port_number_get ( tcp_socket ) ; <S2SV_EndBug> <S2SV_StartBug> uint16_t pid ; <S2SV_EndBug> <S2SV_StartBug> args -> tcp = tcp_conn_accept ( tcp_socket ) ; <S2SV_EndBug> <S2SV_StartBug> cleanup_usb : <S2SV_EndBug> ,"<S2SV_ModStart> = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <S2SV_ModEnd> <S2SV_ModStart> ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <S2SV_ModEnd> <S2SV_ModStart> ) break ; <S2SV_ModEnd> <S2SV_ModStart> NOTE ( ""Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d"" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <S2SV_ModEnd> <S2SV_ModStart> ; if ( tcp_socket ) real_port <S2SV_ModStart> ) ; else real_port = tcp_port_number_get ( tcp6_socket <S2SV_ModStart> NOTE ( ""Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable"" , real_port , tcp_socket ? """" : ""not<S2SV_blank>"" , tcp6_socket ? """" : ""not<S2SV_blank>"" ) ; <S2SV_ModStart> tcp_conn_select ( tcp_socket , tcp6_socket <S2SV_ModEnd> <S2SV_ModStart> if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ; "
1249,"<S2SV_StartBug> file_sb_list_add ( f , inode -> i_sb ) ; <S2SV_EndBug> <S2SV_StartBug> file_sb_list_del ( f ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1250,<S2SV_StartBug> if ( * off >= skb -> len ) { <S2SV_EndBug> ,<S2SV_ModStart> && skb -> len 
1251,<S2SV_StartBug> if ( len < 1 ) <S2SV_EndBug> ,<S2SV_ModStart> 10 <S2SV_ModEnd> 
1252,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_negative ( key <S2SV_ModEnd> 
1253,"<S2SV_StartBug> page -> index , <S2SV_EndBug> ",<S2SV_ModStart> page_index ( page ) <S2SV_ModEnd> 
1254,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> unlink ( RUN_LIB_FILE ) ; 
1255,<S2SV_StartBug> if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) <S2SV_EndBug> ,<S2SV_ModStart> 1 ) return - EINVAL ; if ( current -> fs -> users != 
1256,<S2SV_StartBug> if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ) 
1257,"<S2SV_StartBug> mpz_t numer , denom , lambda ; <S2SV_EndBug> ",<S2SV_ModStart> if ( pointZZ_pIsIdentityElement ( op ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } 
1258,"<S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
1259,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> <S2SV_StartBug> numBytes += size ; <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> * num <S2SV_ModStart> * num "
1260,<S2SV_StartBug> bufp += bytes_read ; <S2SV_EndBug> ,<S2SV_ModStart> stripsize <S2SV_ModEnd> 
1261,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
1262,<S2SV_StartBug> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ,"<S2SV_ModStart> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> "
1263,<S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> <S2SV_ModStart> , 4 "
1264,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
1265,<S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug> ,<S2SV_ModStart> tu -> qhead = tu -> qtail = tu -> qused = 0 ; 
1266,"<S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ext_size = 0 ; <S2SV_ModStart> ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; "
1267,"<S2SV_StartBug> if ( ret ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! prph_info ) <S2SV_EndBug> <S2SV_StartBug> ctxt_info_gen3 = dma_alloc_coherent ( trans -> dev , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> goto err_free_prph_scratch ; <S2SV_ModEnd> <S2SV_ModStart> ) { ret = - ENOMEM ; goto err_free_prph_scratch ; } ctxt_info_gen3 = dma_alloc_coherent ( trans -> dev , sizeof ( * ctxt_info_gen3 ) , & trans_pcie -> ctxt_info_dma_addr , GFP_KERNEL ) ; if ( ! ctxt_info_gen3 ) { ret = - ENOMEM ; goto err_free_prph_info ; } ctxt_info_gen3 -> prph_info_base_addr = cpu_to_le64 ( trans_pcie -> prph_info_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_base_addr = cpu_to_le64 ( trans_pcie -> prph_scratch_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_size = cpu_to_le32 ( sizeof ( * prph_scratch ) ) ; ctxt_info_gen3 -> cr_head_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> rb_stts_dma ) ; ctxt_info_gen3 -> tr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> tr_tail_dma ) ; ctxt_info_gen3 -> cr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> cr_tail_dma ) ; ctxt_info_gen3 -> cr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_COMPLETION_RINGS ) ; ctxt_info_gen3 -> tr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_TRANSFER_RINGS ) ; ctxt_info_gen3 -> mtr_base_addr = cpu_to_le64 ( trans_pcie -> txq [ trans_pcie -> cmd_queue ] -> dma_addr ) ; ctxt_info_gen3 -> mcr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> used_bd_dma ) ; ctxt_info_gen3 -> mtr_size = cpu_to_le16 ( TFD_QUEUE_CB_SIZE ( cmdq_size ) ) ; ctxt_info_gen3 -> mcr_size = cpu_to_le16 ( RX_QUEUE_CB_SIZE ( MQ_RX_TABLE_SIZE ) ) ; trans_pcie -> ctxt_info_gen3 = ctxt_info_gen3 ; trans_pcie -> prph_info = prph_info ; trans_pcie -> prph_scratch = prph_scratch ; iml_img = dma_alloc_coherent ( trans -> dev , trans -> iml_len , & trans_pcie -> iml_dma_addr , GFP_KERNEL ) ; if ( ! iml_img <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err_free_prph_info : dma_free_coherent ( trans -> dev , sizeof ( * prph_info ) , prph_info , trans_pcie -> prph_info_dma_addr ) ; err_free_prph_scratch : dma_free_coherent ( trans -> dev , sizeof ( * prph_scratch ) , prph_scratch , trans_pcie -> prph_scratch_dma_addr ) ; return ret ; "
1268,<S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug> ,<S2SV_ModStart> s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 
1269,"<S2SV_StartBug> & msg -> addrto , & msg -> ifindex ) ; <S2SV_EndBug> <S2SV_StartBug> dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & msg -> hoplimit <S2SV_ModStart> ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , ""ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)"" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> "
1270,<S2SV_StartBug> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { <S2SV_EndBug> ,<S2SV_ModStart> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo -> 
1271,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> goto done ; <S2SV_ModStart> ; goto done 
1272,"<S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> 
1273,"<S2SV_StartBug> xmlNode * op_msg = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( sync_timer == NULL ) { <S2SV_EndBug> <S2SV_StartBug> crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cib -> call_timeout > 0 ) { <S2SV_EndBug> <S2SV_StartBug> op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int disconnected = 0 ; int remaining_time = 0 ; time_t start_time ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( call_options & cib_sync_call ) ) { <S2SV_ModStart> callback . session , op_msg , private -> command . encrypted ) ; } else { crm_send_remote_msg ( private -> command . <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> start_time = time ( NULL ) ; remaining_time = <S2SV_ModEnd> <S2SV_ModStart> ? cib -> call_timeout : 60 ; while ( remaining_time > 0 && ! disconnected <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModStart> recv_buf , private -> command . encrypted , remaining_time * 1000 , & disconnected ) ; op_reply = crm_parse_remote_buffer ( & private -> command . recv_buf ) ; if ( ! op_reply <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> remaining_time = time ( NULL ) - start_time ; } if ( disconnected ) { crm_err ( ""Disconnected<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>reply."" ) ; return - ENOTCONN ; } else <S2SV_ModEnd> "
1274,"<S2SV_StartBug> pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_EndBug> <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug> ","<S2SV_ModStart> ; msg -> msg_namelen = 0 <S2SV_ModStart> memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; "
1275,"<S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! ctx -> gf128 ) return - ENOKEY ; 
1276,"<S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> ",<S2SV_ModStart> = NULL ; LPSTR tmp2 <S2SV_ModStart> { tmp2 <S2SV_ModEnd> <S2SV_ModStart> if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if ( 
1277,"<S2SV_StartBug> int number_bidders , i , bid , best_bid ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , n <S2SV_ModStart> n = 0 ; n < 25 ; ++ n <S2SV_ModEnd> <S2SV_ModStart> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding"" ) ; return ( ARCHIVE_FATAL ) ; "
1278,<S2SV_StartBug> if ( newlen < SDS_MAX_PREALLOC ) <S2SV_EndBug> <S2SV_StartBug> hdrlen = sdsHdrSize ( type ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( newlen > len ) ; <S2SV_ModStart> ) ; assert ( hdrlen + newlen + 1 > len 
1279,"<S2SV_StartBug> if ( ip_options_echo ( & icmp_param -> replyopts , skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( icmp_param -> replyopts . optlen ) { <S2SV_EndBug> <S2SV_StartBug> ipc . opt = & icmp_param -> replyopts ; <S2SV_EndBug> <S2SV_StartBug> daddr = icmp_param -> replyopts . faddr ; <S2SV_EndBug> ",<S2SV_ModStart> . opt . opt <S2SV_ModStart> opt . opt . <S2SV_ModStart> . opt ; if ( ipc . opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> . opt . opt 
1280,<S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ( MagickSizeType ) <S2SV_ModStart> offset = ( MagickOffsetType ) <S2SV_ModEnd> <S2SV_ModStart> ; if ( offset <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> <S2SV_ModStart> * magick = '\\0' ; <S2SV_ModEnd> "
1281,"<S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len ) { u_int pdu_len = <S2SV_ModEnd> <S2SV_ModStart> pptr , len , 1 <S2SV_ModEnd> <S2SV_ModStart> ; len <S2SV_ModEnd> <S2SV_ModStart> pptr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1282,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( subl == 0 ) break ; <S2SV_ModStart>  <S2SV_ModEnd> 
1283,<S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> ,<S2SV_ModStart> 0 <S2SV_ModEnd> 
1284,"<S2SV_StartBug> CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ; CU_add_test ( parserTestSuite , "
1285,<S2SV_StartBug> bprm -> interp = iname ; <S2SV_EndBug> ,"<S2SV_ModStart> retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> "
1286,"<S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> <S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> <S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> "
1287,"<S2SV_StartBug> unsigned int sse = INT_MAX , best_rd_sse = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> <S2SV_StartBug> int parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail ; <S2SV_EndBug> <S2SV_StartBug> parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> mode_mv = mode_mv_sb [ sign_bias ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mbmode , 0 , sizeof ( best_mbmode ) ) ; <S2SV_EndBug> <S2SV_StartBug> get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> calculate_zeromv_rd_adjustment ( cpi , x , & rd_adjustment ) ; <S2SV_EndBug> <S2SV_StartBug> distortion2 = vp8_variance16x16 ( <S2SV_EndBug> <S2SV_StartBug> distortion2 = vp8_variance16x16 <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . mr_encoder_id && ! parent_ref_valid ) <S2SV_EndBug> <S2SV_StartBug> if ( parent_ref_valid && parent_ref_frame ) <S2SV_EndBug> <S2SV_StartBug> if ( parent_ref_valid && parent_ref_frame && dissim <= 2 && <S2SV_EndBug> <S2SV_StartBug> if ( ! parent_ref_valid ) <S2SV_EndBug> <S2SV_StartBug> rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( this_mode == ZEROMV && sse < zero_mv_sse ) <S2SV_EndBug> <S2SV_StartBug> sse < best_sse ) <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <S2SV_EndBug> <S2SV_StartBug> if ( x -> best_sse_inter_mode == DC_PRED ) <S2SV_EndBug> <S2SV_StartBug> vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , <S2SV_EndBug> <S2SV_StartBug> recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_mbmode . ref_frame == INTRA_FRAME && <S2SV_EndBug> <S2SV_StartBug> rate2 = x -> ref_frame_cost [ this_ref_frame ] + <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , <S2SV_EndBug> ","<S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> UINT_MAX <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_MULTI_RES_ENCODING int dissim = INT_MAX ; int parent_ref_frame = 0 ; int_mv parent_ref_mv ; MB_PREDICTION_MODE parent_mode = 0 ; int parent_ref_valid = 0 ; # endif <S2SV_ModStart> int dot_artifact_candidate = 0 ; get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { unsigned char * target_y = x -> src . y_buffer ; unsigned char * target_u = x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src ; unsigned char * target_v = x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src ; int stride = x -> src . y_stride ; int stride_uv = x -> block [ 16 ] . src_stride ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { const int uv_denoise = ( cpi -> oxcf . noise_sensitivity >= 2 ) ? 1 : 0 ; target_y = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_buffer + recon_yoffset ; stride = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_stride ; if ( uv_denoise ) { target_u = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . u_buffer + recon_uvoffset ; target_v = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . v_buffer + recon_uvoffset ; stride_uv = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . uv_stride ; } } # endif dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_y , stride , plane [ LAST_FRAME ] [ 0 ] , mb_row , mb_col , 0 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_u , stride_uv , plane [ LAST_FRAME ] [ 1 ] , mb_row , mb_col , 1 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_v , stride_uv , plane [ LAST_FRAME ] [ 2 ] , mb_row , mb_col , 2 ) ; } } } # if CONFIG_MULTI_RES_ENCODING <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( dot_artifact_candidate ) parent_ref_valid = 0 ; <S2SV_ModStart> { const int y = x -> src . y_buffer [ 7 * x -> src . y_stride + 7 ] ; const int cb = x -> src . u_buffer [ 3 * x -> src . uv_stride + 3 ] ; const int cr = x -> src . v_buffer [ 3 * x -> src . uv_stride + 3 ] ; x -> is_skin = 0 ; if ( ! cpi -> oxcf . screen_content_mode ) x -> is_skin = is_skin_color ( y , cb , cr ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { } # endif <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> Speed < 12 ) { <S2SV_ModStart> } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { rd_adjustment = ( int ) ( rd_adjustment * cpi -> denoiser . denoise_pars . pickmode_mv_bias / 100 ) ; } # endif if ( dot_artifact_candidate ) { rd_adjustment = 150 ; } <S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> <S2SV_ModStart> ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> <S2SV_ModStart> || ( parent_ref_frame != this_ref_frame ) <S2SV_ModStart> vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; <S2SV_ModStart> int skip_old_reference = ( ( this_ref_frame != LAST_FRAME ) && ( cpi -> common . current_video_frame - cpi -> current_ref_frames [ this_ref_frame ] > MAX_GF_ARF_DENOISE_RANGE ) ) ? 1 : 0 ; <S2SV_ModStart> && ! skip_old_reference <S2SV_ModStart> && ! skip_old_reference <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> int block_index = mb_row * cpi -> common . mb_cols + mb_col ; int reevaluate = 0 ; int is_noisy = 0 ; <S2SV_ModStart> if ( cpi -> oxcf . noise_sensitivity == 4 ) { if ( cpi -> denoiser . nmse_source_diff > 70 * cpi -> denoiser . threshold_aggressive_mode / 100 ) is_noisy = 1 ; } else { if ( cpi -> mse_source_denoised > 1000 ) is_noisy = 1 ; } x -> increase_denoising = 0 ; if ( ! x -> is_skin && x -> best_sse_inter_mode == ZEROMV && ( x -> best_reference_frame == LAST_FRAME || x -> best_reference_frame == cpi -> closest_reference_frame ) && cpi -> consec_zero_last [ block_index ] >= 20 && is_noisy ) { x -> increase_denoising = 1 ; } x -> denoise_zeromv = 0 ; <S2SV_ModStart> , & cpi -> common . lf_info , mb_row , mb_col , block_index ) ; reevaluate = <S2SV_ModEnd> <S2SV_ModStart> ) || ( best_mbmode . mode != ZEROMV && x -> denoise_zeromv && cpi -> mse_source_denoised > 2000 ) ; if ( ! dot_artifact_candidate && reevaluate <S2SV_ModStart> rd_adjustment = 100 ; <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
1288,<S2SV_StartBug> if ( err ) <S2SV_EndBug> ,<S2SV_ModStart> < 0 
1289,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> 
1290,"<S2SV_StartBug> int this_frame_target , <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> int recode_tolerance = <S2SV_EndBug> <S2SV_StartBug> ( cpi -> sf . recode_tolerance * this_frame_target ) / 100 ; <S2SV_EndBug> <S2SV_StartBug> * frame_over_shoot_limit = this_frame_target + recode_tolerance ; <S2SV_EndBug> <S2SV_StartBug> * frame_over_shoot_limit += 200 ; <S2SV_EndBug> <S2SV_StartBug> if ( * frame_over_shoot_limit > cpi -> rc . max_frame_bandwidth ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> frame_target <S2SV_ModEnd> <S2SV_ModStart> rc_mode == VPX_Q <S2SV_ModEnd> <S2SV_ModStart> const int tolerance <S2SV_ModEnd> <S2SV_ModStart> frame_target <S2SV_ModEnd> <S2SV_ModStart> frame_under_shoot_limit = MAX ( frame_target - tolerance - 200 , 0 ) <S2SV_ModEnd> <S2SV_ModStart> = MIN ( frame_target + tolerance + 200 , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1291,<S2SV_StartBug> if ( asn1_com_prkey_attr -> flags & SC_ASN1_PRESENT && <S2SV_EndBug> ,<S2SV_ModStart> free ( info . subject . value ) ; <S2SV_ModEnd> 
1292,<S2SV_StartBug> down_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( id . index > UINT_MAX - kcontrol -> count ) goto error ; 
1293,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
1294,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
1295,"<S2SV_StartBug> ret = arg ( name , annotation , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> NULL , "
1296,"<S2SV_StartBug> else if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 ) <S2SV_EndBug> ",<S2SV_ModStart> g_str_has_prefix <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1297,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> <S2SV_StartBug> lrc -> min_frame_bandwidth = ( int ) ( lrc -> av_per_frame_bandwidth * <S2SV_EndBug> <S2SV_StartBug> lrc -> max_frame_bandwidth = ( int ) ( ( ( int64_t ) lrc -> av_per_frame_bandwidth * <S2SV_EndBug> <S2SV_StartBug> lrc -> max_gf_interval = 16 ; <S2SV_EndBug> ,"<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> vp9_rc_set_gf_interval_range ( cpi , lrc ) <S2SV_ModEnd> "
1298,"<S2SV_StartBug> register int i ; <S2SV_EndBug> <S2SV_StartBug> raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types?"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( windowprocs . win_raw_print == def_raw_print <S2SV_EndBug> ","<S2SV_ModStart> int i ; char * tmps = 0 <S2SV_ModEnd> <S2SV_ModStart> ""No<S2SV_blank>window<S2SV_blank>types<S2SV_blank>supported?"" <S2SV_ModEnd> <S2SV_ModStart> # define WINDOW_TYPE_MAXLEN 50 if ( strlen ( s ) >= WINDOW_TYPE_MAXLEN ) { tmps = ( char * ) alloc ( WINDOW_TYPE_MAXLEN ) ; ( void ) strncpy ( tmps , s , WINDOW_TYPE_MAXLEN - 1 ) ; tmps [ WINDOW_TYPE_MAXLEN - 1 ] = '\\0' ; s = tmps ; } # undef WINDOW_TYPE_MAXLEN <S2SV_ModStart> tmps ) free ( ( genericptr_t ) tmps ) ; if ( "
1299,"<S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> <S2SV_StartBug> ( const UWORD8 * ) & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 0 == end_of_pic ) <S2SV_EndBug> ",<S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ret = <S2SV_ModStart> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ps_codec -> i4_slice_error = 0 ; 
1300,"<S2SV_StartBug> if ( NGX_DECLINED == ngx_http_auth_spnego_basic ( r , ctx , alcf ) ) { <S2SV_EndBug> ",<S2SV_ModStart> NGX_OK != <S2SV_ModEnd> 
1301,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ; 
1302,<S2SV_StartBug> return sizeof ( vpx_codec_alg_priv_t ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( void ) flags ; 
1303,"<S2SV_StartBug> dtls1_record_bitmap_update ( s , & ( s -> d1 -> bitmap ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1304,"<S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> ",<S2SV_ModStart> 257UL <S2SV_ModEnd> 
1305,<S2SV_StartBug> struct pipe_buffer * buf ; <S2SV_EndBug> <S2SV_StartBug> orig_sz = size ; <S2SV_EndBug> <S2SV_StartBug> if ( off ) <S2SV_EndBug> <S2SV_StartBug> size += off - pipe -> bufs [ idx ] . offset ; <S2SV_EndBug> <S2SV_StartBug> if ( size <= buf -> len ) <S2SV_EndBug> <S2SV_StartBug> size -= buf -> len ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = size ; <S2SV_EndBug> <S2SV_StartBug> off = i -> iov_offset = buf -> offset + size ; <S2SV_EndBug> <S2SV_StartBug> i -> count -= orig_sz ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart> left <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> left ; <S2SV_ModEnd> <S2SV_ModStart> size ; pipe_truncate ( i ) <S2SV_ModEnd> "
1306,<S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
1307,"<S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> ","<S2SV_ModStart> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> - slot -> base_gfn "
1308,"<S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ","<S2SV_ModStart> uid_keyring <S2SV_ModEnd> <S2SV_ModStart> uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> <S2SV_ModStart> } "
1309,<S2SV_StartBug> char * identifier ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug> ,"<S2SV_ModStart> YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> assert ( sp == 0 ) ; <S2SV_ModStart> result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> <S2SV_ModStart> obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ; "
1310,"<S2SV_StartBug> res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ; <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
1311,<S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! context ) return FALSE <S2SV_ModStart> if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> BYTE * <S2SV_ModStart> BYTE * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> return TRUE ; 
1312,"<S2SV_StartBug> ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) <S2SV_EndBug> <S2SV_StartBug> ngx_table_elt_t * header ; <S2SV_EndBug> <S2SV_StartBug> ngx_uint_t i ; <S2SV_EndBug> <S2SV_StartBug> dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> <S2SV_StartBug> if ( part -> next == NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> ","<S2SV_ModStart> pr , int pr_not_chunked <S2SV_ModEnd> <S2SV_ModStart> clh , * <S2SV_ModStart> ; u_char * p ; off_t len ; dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) pr -> headers_in . headers . part . nelts ) <S2SV_ModStart> if ( sr -> request_body && ! pr_not_chunked ) { len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ; clh = ngx_list_push ( & sr <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( clh <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> clh -> hash = ngx_http_lua_content_length_hash ; clh -> key = ngx_http_lua_content_length_header_key ; clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ; if ( clh -> lowcase_key == NULL ) { return NGX_ERROR ; } ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ; p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ; if ( p == NULL ) { return NGX_ERROR ; } clh -> value . data = p ; clh -> value . len = ngx_sprintf ( clh -> value . data , ""%O"" , len ) - clh -> value . data ; sr -> headers_in . content_length = clh ; sr -> headers_in . content_length_n = len ; dd ( ""sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s"" , ( int ) sr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ; } part = & pr -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( ""Content-Length"" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) ""Content-Length"" , sizeof ( ""Content-Length"" ) - 1 ) == 0 ) { continue ; } dd ( ""sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( <S2SV_ModEnd> <S2SV_ModStart> pr <S2SV_ModEnd> "
1313,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> int step_param = cpi -> sf . reduce_first_step_size + <S2SV_EndBug> <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , & v_fn_ptr , 0 , <S2SV_EndBug> <S2SV_StartBug> & v_fn_ptr , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , <S2SV_EndBug> <S2SV_StartBug> & sse ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , <S2SV_EndBug> ","<S2SV_ModStart> td . <S2SV_ModStart> const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; const <S2SV_ModStart> cost_list [ 5 ] ; int step_param = mv_sf -> reduce_first_step_size <S2SV_ModEnd> <S2SV_ModStart> MAX_MVSEARCH_STEPS - 2 <S2SV_ModEnd> <S2SV_ModStart> cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , <S2SV_ModEnd> <S2SV_ModStart> , NULL , 0 , 0 <S2SV_ModStart> vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1314,"<S2SV_StartBug> int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) <S2SV_EndBug> <S2SV_StartBug> at91_aes_key_size_t key_size ; <S2SV_EndBug> <S2SV_StartBug> init_keys ( & key_size , cipher_key , cmac_key , iv ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if defined ( CONFIG_AES_KEY_SIZE_128 ) key_size = AT91_AES_KEY_SIZE_128 ; # elif defined ( CONFIG_AES_KEY_SIZE_192 ) key_size = AT91_AES_KEY_SIZE_192 ; # elif defined ( CONFIG_AES_KEY_SIZE_256 ) key_size = AT91_AES_KEY_SIZE_256 ; # else # error ""bad<S2SV_blank>AES<S2SV_blank>key<S2SV_blank>size"" # endif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1315,"<S2SV_StartBug> o = 2 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nelements ; j ++ , i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } <S2SV_ModStart> && i < sh . sh_properties ; <S2SV_ModEnd> "
1316,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; return <S2SV_ModEnd> "
1317,<S2SV_StartBug> if ( image_info -> ping != MagickFalse ) <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
1318,<S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> <S2SV_StartBug> tx = adis -> buffer + burst_length ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> } 
1319,<S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; "
1320,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
1321,<S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1322,"<S2SV_StartBug> static void update_mv_probs ( vp9_prob * p , int n , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_read ( r , MV_UPDATE_PROB ) ) <S2SV_EndBug> <S2SV_StartBug> p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> 
1323,"<S2SV_StartBug> if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> validate_core_offset ( reg ) ) return - EINVAL ; if ( 
1324,<S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> } else { close ( sr -> fd_file ) ; } 
1325,<S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( i < to_read ) && <S2SV_ModStart>  <S2SV_ModEnd> 
1326,"<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else "
1327,"<S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
1328,<S2SV_StartBug> hndl = sock_diag_lock_handler ( req -> sdiag_family ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ; 
1329,<S2SV_StartBug> goto end ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1330,"<S2SV_StartBug> l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
1331,"<S2SV_StartBug> # line 94 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 95 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 96 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 97 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 100 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 99 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 98 ""hex_grammar.y"" <S2SV_EndBug> ","<S2SV_ModStart> 101 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> <S2SV_ModStart> 102 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> <S2SV_ModStart> 103 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> <S2SV_ModStart> 104 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> <S2SV_ModStart> 107 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> <S2SV_ModStart> 106 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> <S2SV_ModStart> 105 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> "
1332,"<S2SV_StartBug> if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { <S2SV_EndBug> ",<S2SV_ModStart> assoc_array_ptr_is_leaf ( ptr ) && 
1333,"<S2SV_StartBug> if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . content = fi ; <S2SV_EndBug> <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . control = fi ; <S2SV_EndBug> <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . spaninfo = fi ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> name_len == 40 && memcmp ( name , content_name , 40 <S2SV_ModEnd> <S2SV_ModStart> chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> <S2SV_ModStart> control <S2SV_ModEnd> <S2SV_ModStart> name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> <S2SV_ModStart> spaninfo <S2SV_ModEnd> <S2SV_ModStart> name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1334,"<S2SV_StartBug> const char * args [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> args [ i ++ ] = ""--"" ; <S2SV_EndBug> <S2SV_StartBug> execvp ( EXECUTABLE , ( char * * ) args ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ; log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> <S2SV_ModStart> ""--tmpdir"" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <S2SV_ModStart> pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ; if ( pid == 0 ) { <S2SV_ModStart> int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ; error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ; } "
1335,<S2SV_StartBug> newinet -> opt = ireq -> opt ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
1336,"<S2SV_StartBug> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart>  <S2SV_ModEnd> "
1337,<S2SV_StartBug> return 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> # if OPENSSL_VERSION_NUMBER > 0x10002000L lua_pushliteral ( L , ""check_flag"" ) ; lua_newtable ( L ) ; auxiliar_enumerate ( L , - 1 , check_flags_const ) ; lua_settable ( L , - 3 ) ; # endif "
1338,<S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,"<S2SV_ModStart> ; ctx = perf_event_ctx_lock <S2SV_ModEnd> <S2SV_ModStart> _perf_event_enable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> "
1339,"<S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct pmu * pmu , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> armpmu = to_arm_pmu ( event -> pmu ) ; "
1340,<S2SV_StartBug> BOOL ret = FALSE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> data = NULL ; <S2SV_EndBug> <S2SV_StartBug> ret = TRUE ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> err <S2SV_ModEnd> <S2SV_ModStart> return TRUE ; err : sud -> directory <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> FALSE <S2SV_ModEnd> 
1341,<S2SV_StartBug> u8 opcode = BPF_OP ( insn -> code ) ; <S2SV_EndBug> <S2SV_StartBug> if ( known && ( ptr_reg -> off + smin_val == <S2SV_EndBug> <S2SV_StartBug> if ( dst_reg == off_reg ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; int ret <S2SV_ModStart> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } <S2SV_ModStart> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } "
1342,"<S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <S2SV_EndBug> <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> <S2SV_StartBug> le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry <S2SV_ModEnd> <S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> "
1343,"
","
"
1344,"<S2SV_StartBug> struct in6_addr * addr , uint32_t * ifindex ) <S2SV_EndBug> <S2SV_StartBug> unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 && <S2SV_EndBug> <S2SV_StartBug> cmsghdr -> cmsg_type == IPV6_PKTINFO && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , int * hoplimit <S2SV_ModStart> 2 * <S2SV_ModStart> != IPPROTO_IPV6 ) continue ; switch ( <S2SV_ModEnd> <S2SV_ModStart> ) { case IPV6_PKTINFO : if ( <S2SV_ModEnd> <S2SV_ModStart> break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; } "
1345,<S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> != MODE_INVALID <S2SV_ModEnd> 
1346,"<S2SV_StartBug> struct address_space * mapping = inode -> i_mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { <S2SV_EndBug> <S2SV_StartBug> truncate_pagecache_range ( inode , start , end - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> flags , mode ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem 
1347,"<S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( len >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) len = sizeof <S2SV_ModEnd> <S2SV_ModStart> ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , ""%.*s<S2SV_blank>bc<S2SV_blank>"" , len , & vpd_data [ j ] <S2SV_ModEnd> "
1348,<S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mntget ( path -> mnt ) ; 
1349,<S2SV_StartBug> i ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; } "
1350,"<S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ; <S2SV_EndBug> <S2SV_StartBug> data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_MIREGADR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MICMD , ENC28J60_MICMD_MIIRD <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MICMD <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MIRDL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_MIRDH <S2SV_ModEnd> "
1351,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ; 
1352,"<S2SV_StartBug> mptctl_readtest ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1353,"<S2SV_StartBug> static void choose_partitioning ( VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> int mi_row , int mi_col ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> int i , j , k ; <S2SV_EndBug> <S2SV_StartBug> v64x64 vt ; <S2SV_EndBug> <S2SV_StartBug> int_mv nearest_mv , near_mv ; <S2SV_EndBug> <S2SV_StartBug> const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ; <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_right_edge < 0 ) <S2SV_EndBug> <S2SV_StartBug> vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ; <S2SV_EndBug> <S2SV_StartBug> dp = xd -> plane [ 0 ] . dst . stride ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < 4 ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( k = 0 ; k < 4 ; k ++ ) { <S2SV_EndBug> <S2SV_StartBug> int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ; <S2SV_EndBug> <S2SV_StartBug> int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned int sse = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < 4 ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; <S2SV_EndBug> <S2SV_StartBug> fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ; <S2SV_EndBug> <S2SV_StartBug> fill_variance_tree ( & vt , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> mi_row , mi_col , 8 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 , <S2SV_EndBug> <S2SV_StartBug> ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) { <S2SV_EndBug> <S2SV_StartBug> # define DISABLE_8X8_VAR_BASED_PARTITION <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows && <S2SV_EndBug> <S2SV_StartBug> mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , <S2SV_EndBug> <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile , <S2SV_EndBug> <S2SV_StartBug> ( mi_row + y32_idx + y16_idx ) , <S2SV_EndBug> <S2SV_StartBug> ( mi_col + x32_idx + x16_idx ) , 2 ) ) { <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , int mi_row , int mi_col ) { VP9_COMMON * const cm = & cpi -> common <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> , m <S2SV_ModStart> ; v16x16 vt2 [ 16 ] ; int force_split [ 21 ] <S2SV_ModStart> int64_t thresholds [ 4 ] = { cpi -> vbp_thresholds [ 0 ] , cpi -> vbp_thresholds [ 1 ] , cpi -> vbp_thresholds [ 2 ] , cpi -> vbp_thresholds [ 3 ] } ; const int is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; const int use_4x4_partition = is_key_frame ; const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ; int variance4x4downsample [ 16 ] ; int segment_id = CR_SEGMENT_ID_BASE ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; if ( cyclic_refresh_segment_id_boosted ( segment_id ) ) { int q = vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) ; set_vbp_thresholds ( cpi , thresholds , q ) ; } } set_offsets ( cpi , tile , x , mi_row , mi_col , BLOCK_64X64 ) ; if ( xd -> mb_to_right_edge < 0 ) pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( ! is_key_frame && ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ) ) { MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; unsigned int uv_sad <S2SV_ModEnd> <S2SV_ModStart> YV12_BUFFER_CONFIG * yv12_g = NULL ; unsigned int y_sad , y_sad_g ; const BLOCK_SIZE bsize = BLOCK_32X32 + ( mi_col + 4 < cm -> mi_cols ) * 2 + ( mi_row + 4 < cm -> mi_rows ) ; assert ( yv12 != NULL ) ; if ( ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . spatial_layer_id ) ) { yv12_g = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } if ( yv12_g && yv12_g != yv12 && ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; y_sad_g = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ) ; } else { y_sad_g = UINT_MAX ; } vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , <S2SV_ModEnd> <S2SV_ModStart> ) ; mbmi -> ref_frame [ 0 ] = LAST_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> sb_type = BLOCK_64X64 ; mbmi -> mv [ 0 ] . as_int = 0 ; mbmi -> interp_filter = BILINEAR ; y_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( y_sad_g < y_sad ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; mbmi -> ref_frame [ 0 ] = GOLDEN_FRAME ; mbmi -> mv [ 0 ] . as_int = 0 ; y_sad = y_sad_g ; } else { x -> pred_mv [ LAST_FRAME ] = mbmi -> mv [ 0 ] . as_mv ; } vp9_build_inter_predictors_sb ( xd , mi_row , mi_col <S2SV_ModStart> for ( i = 1 ; i <= 2 ; ++ i ) { struct macroblock_plane * p = & x -> plane [ i ] ; struct macroblockd_plane * pd = & xd -> plane [ i ] ; const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; if ( bs == BLOCK_INVALID ) uv_sad = UINT_MAX ; else uv_sad = cpi -> fn_ptr [ bs ] . sdf ( p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ; x -> color_sensitivity [ i - 1 ] = uv_sad > ( y_sad >> 2 ) ; } d = xd -> plane [ 0 ] . dst . buf ; dp = xd -> plane [ 0 ] . dst . stride ; if ( segment_id == CR_SEGMENT_ID_BASE && y_sad < cpi -> vbp_threshold_sad ) { const int block_width = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ; const int block_height = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ; if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows ) { set_block_size ( cpi , x , xd <S2SV_ModEnd> <S2SV_ModStart> BLOCK_64X64 ) ; return 0 ; } } } else { d = VP9_VAR_OFFS <S2SV_ModEnd> <S2SV_ModStart> 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( xd -> bd ) { case 10 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_10 ) ; break ; case 12 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_12 ) ; break ; case 8 : default : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_8 ) ; break ; } } # endif } force_split [ 0 ] = 0 ; <S2SV_ModEnd> <S2SV_ModStart> const int i2 = i << 2 ; force_split [ i + 1 ] = 0 ; <S2SV_ModStart> ; const int split_index = 5 + i2 + j <S2SV_ModStart> force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 0 ; if ( ! is_key_frame ) { fill_variance_8x8avg ( s , sp , d , dp , x16_idx , y16_idx , vst , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; get_variance ( & vt . split [ i ] . split [ j ] . part_variances . none ) ; if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 2 ] ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } else if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 1 ] && ! cyclic_refresh_segment_id_boosted ( segment_id ) ) { int minmax = compute_minmax_8x8 ( s , sp , d , dp , x16_idx , y16_idx , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high ) ; if ( minmax > cpi -> vbp_threshold_minmax ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( is_key_frame || ( low_res && ! cpi -> use_svc && vt . split [ i ] . split [ j ] . part_variances . none . variance > ( thresholds [ 1 ] << 1 ) ) ) { force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 1 ; <S2SV_ModStart> x8_idx <S2SV_ModEnd> <S2SV_ModStart> y8_idx <S2SV_ModEnd> <S2SV_ModStart> v8x8 * vst2 = is_key_frame ? & vst -> split [ k ] : & vt2 [ i2 + j ] . split [ k ] ; fill_variance_4x4avg ( s , sp , d , dp , x8_idx , y8_idx , vst2 , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; } <S2SV_ModEnd> <S2SV_ModStart> const int i2 = i << 2 ; <S2SV_ModStart> if ( variance4x4downsample [ i2 + j ] == 1 ) { v16x16 * vtemp = ( ! is_key_frame ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; for ( m = 0 ; m < 4 ; m ++ ) <S2SV_ModStart> vtemp -> split [ m ] , BLOCK_8X8 ) ; fill_variance_tree ( vtemp , BLOCK_16X16 ) ; } } fill_variance_tree ( & <S2SV_ModStart> , BLOCK_32X32 ) ; if ( ! force_split [ i + 1 ] ) { get_variance ( & vt <S2SV_ModStart> i ] . part_variances . none ) ; if ( vt . split [ i ] . part_variances . none . variance > thresholds [ 1 ] ) { force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( ! force_split [ 0 ] ) { <S2SV_ModEnd> <S2SV_ModStart> , BLOCK_64X64 ) ; get_variance <S2SV_ModEnd> <S2SV_ModStart> . part_variances . none ) ; } if ( mi_col + 8 > cm -> mi_cols || mi_row + 8 > cm -> mi_rows || <S2SV_ModEnd> <S2SV_ModStart> x , xd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> thresholds [ 0 ] , BLOCK_16X16 , force_split [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> const int i2 = i << 2 ; <S2SV_ModStart> x , xd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> thresholds [ 1 ] , BLOCK_16X16 , force_split [ i + 1 ] <S2SV_ModEnd> <S2SV_ModStart> v16x16 * vtemp = ( ! is_key_frame && variance4x4downsample [ i2 + j ] == 1 ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; if ( ! set_vt_partitioning ( cpi , x , xd , vtemp , BLOCK_16X16 , <S2SV_ModEnd> <S2SV_ModStart> , mi_col <S2SV_ModEnd> <S2SV_ModStart> , thresholds [ 2 ] , cpi -> vbp_bsize_min , force_split [ 5 + i2 + j ] ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( use_4x4_partition ) { <S2SV_ModEnd> <S2SV_ModStart> x , xd , & vtemp -> split [ k ] , BLOCK_8X8 , <S2SV_ModEnd> <S2SV_ModStart> + y8_idx , <S2SV_ModEnd> <S2SV_ModStart> + x8_idx , thresholds [ 3 ] , BLOCK_8X8 , 0 ) ) { set_block_size ( cpi , x , xd , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_4X4 ) ; } } else { <S2SV_ModEnd> <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> } } } } } return 0 ; <S2SV_ModEnd> "
1354,"<S2SV_StartBug> struct inode * inode , int regard_xa ) <S2SV_EndBug> <S2SV_StartBug> int cnt , sig ; <S2SV_EndBug> <S2SV_StartBug> if ( regard_xa ) { <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent = <S2SV_EndBug> <S2SV_StartBug> isofs_iget ( inode -> i_sb , <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent , <S2SV_EndBug> ","<S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> ; unsigned int reloc_block <S2SV_ModStart> flags & RR_REGARD_XA <S2SV_ModEnd> <S2SV_ModStart> if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> <S2SV_ModStart> isofs_iget_reloc <S2SV_ModEnd> <S2SV_ModStart> reloc_block , <S2SV_ModEnd> "
1355,"<S2SV_StartBug> if ( perf_event_overflow ( event , 0 , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1356,<S2SV_StartBug> struct pstore * ps = get_info ( store ) ; <S2SV_EndBug> <S2SV_StartBug> stride = ( ps -> exceptions_per_area + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ps -> next_free ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; skip_metadata ( ps ) 
1357,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> ,<S2SV_ModStart> kfree_skb ( skb ) ; 
1358,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1359,"<S2SV_StartBug> * decorator_list , expr_ty returns , int lineno , int col_offset , <S2SV_EndBug> <S2SV_StartBug> p -> v . AsyncFunctionDef . returns = returns ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , int <S2SV_ModEnd> <S2SV_ModStart> ; p -> v . AsyncFunctionDef . type_comment = type_comment "
1360,<S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> ,<S2SV_ModStart> rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> 
1361,<S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> objlen > 1 && <S2SV_ModStart>  <S2SV_ModEnd> 
1362,"<S2SV_StartBug> err |= get_user ( length , & up -> length ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( err ) return - EFAULT 
1363,<S2SV_StartBug> if ( map_data ) <S2SV_EndBug> <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> fail : 
1364,"<S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt = ipv6_renew_options ( sk , np -> opt , optname , <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> tot_len = sizeof ( * opt ) + optlen ; <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; opt = <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> <S2SV_ModStart> atomic_set ( & opt -> refcnt , 1 ) ; <S2SV_ModStart> { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> "
1365,"<S2SV_StartBug> uint16_t auxsize ; <S2SV_EndBug> <S2SV_StartBug> av_get_packet ( pb , pkt , vsize ) ; <S2SV_EndBug> <S2SV_StartBug> av_get_packet ( pb , pkt , asize ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; int ret <S2SV_ModStart> if ( ( ret = <S2SV_ModStart> ) < 0 ) return ret <S2SV_ModStart> if ( ( ret = <S2SV_ModStart> ) < 0 ) return ret 
1366,<S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> - <S2SV_ModEnd> 
1367,<S2SV_StartBug> if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1368,"<S2SV_StartBug> const int v = ( int ) ( .5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> gaussian <S2SV_ModEnd> 
1369,"<S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> <S2SV_ModStart> return ; <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> stripbytes ? offset : 0 <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> "
1370,<S2SV_StartBug> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1371,"<S2SV_StartBug> int result ; <S2SV_EndBug> <S2SV_StartBug> Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! result ) <S2SV_EndBug> <S2SV_StartBug> Safefree ( imp_dbh -> pmysql ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int fresh = 0 <S2SV_ModStart> fresh = 1 ; <S2SV_ModStart> fresh && <S2SV_ModStart> { do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; <S2SV_ModStart> imp_dbh -> pmysql = NULL ; } "
1372,"<S2SV_StartBug> strcpy ( cat_enum . szPath , fileName ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad1 , fileName ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad1 , sep + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> sep = strchr ( cat_enum . szRad1 , '*' ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad2 , sep + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> sep = strchr ( cat_enum . szRad2 , '%' ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sep ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> if ( strlen ( <S2SV_ModEnd> <S2SV_ModStart> >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> } <S2SV_ModStart> szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> <S2SV_ModStart> if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n"" , sep ) ) ; return GF_NOT_SUPPORTED ; } "
1373,"<S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ","<S2SV_ModStart> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> "
1374,<S2SV_StartBug> int n ; <S2SV_EndBug> ,<S2SV_ModStart> ssize_t <S2SV_ModEnd> 
1375,"<S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> ; if ( components < 0 ) break 
1376,<S2SV_StartBug> if ( fuji_width ) <S2SV_EndBug> ,<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( fuji_width && ! dng_version && ! ( imgdata . process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED ) ) fuji_width = 0 ; # endif 
1377,<S2SV_StartBug> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ret = - ENOTCONN ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> lock_sock ( sk ) ; <S2SV_ModStart> release_sock ( sk ) ; <S2SV_ModStart> release_sock ( sk ) ; 
1378,<S2SV_StartBug> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ; 
1379,"<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> else ( void ) mb_idx ; # <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
1380,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> <S2SV_StartBug> if ( bitmap_pos < 0 ) { <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1381,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
1382,"<S2SV_StartBug> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1383,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> ,<S2SV_ModStart> ctx -> terminated || 
1384,<S2SV_StartBug> slave -> master = master ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & master -> timer -> lock ) ; <S2SV_ModStart> spin_unlock ( & master -> timer -> lock ) ; 
1385,<S2SV_StartBug> static char * print_number ( cJSON * item ) <S2SV_EndBug> <S2SV_StartBug> f = item -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX ) <S2SV_EndBug> ,"<S2SV_ModStart> , printbuffer * p ) { char * str = 0 ; double d <S2SV_ModEnd> <S2SV_ModStart> valuedouble ; if ( d == 0 ) { if ( p ) str = ensure ( p , 2 ) ; else str = ( char * ) cJSON_malloc ( 2 ) ; if ( str ) strcpy ( str , ""0"" ) ; } else if ( fabs ( ( ( double ) <S2SV_ModEnd> <S2SV_ModStart> ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) sprintf ( str , ""%lld"" , ( long long ) <S2SV_ModEnd> <S2SV_ModStart> ) ; } else { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , ""null"" ) ; else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , ""%.0f"" , d ) ; else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , ""%e"" , d ) ; else sprintf ( str , ""%f"" , d ) ; } <S2SV_ModEnd> "
1386,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; <S2SV_EndBug> ","<S2SV_ModStart> SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> r -> buflen <S2SV_ModEnd> "
1387,<S2SV_StartBug> return headcount ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; } 
1388,<S2SV_StartBug> ps_cur_slice -> u1_field_pic_flag = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1389,"<S2SV_StartBug> memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ; <S2SV_EndBug> <S2SV_StartBug> rc = - ENOMEM ; <S2SV_EndBug> ",<S2SV_ModStart> priv -> ctrl . fname = NULL ; <S2SV_ModStart> return <S2SV_ModEnd> 
1390,"<S2SV_StartBug> if ( c == 0 ) { <S2SV_EndBug> <S2SV_StartBug> xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , ""unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"" "
1391,<S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) * GetPSDPacketSize ( image ) 
1392,"<S2SV_StartBug> p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( p ) 
1393,"<S2SV_StartBug> bit_set_position ( dat , restartpos ) ; <S2SV_EndBug> <S2SV_StartBug> obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> if ( err >= DWG_ERR_CRITICAL ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> is_entity ) error |= dwg_decode_UNKNOWN_ENT ( dat , obj ) ; else error |= dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1394,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> ; value |= <S2SV_ModEnd> <S2SV_ModStart> buffer [ 1 ] ; return <S2SV_ModStart>  <S2SV_ModEnd> 
1395,<S2SV_StartBug> libettercap_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( write_output ( ) != E_SUCCESS ) <S2SV_EndBug> ,"<S2SV_ModStart> int ret_value = 0 ; <S2SV_ModStart> ret_value = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled."" , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>"" <S2SV_ModEnd> "
1396,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> skip_mm : 
1397,"<S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> ",<S2SV_ModStart> resv_map_put ( vma <S2SV_ModEnd> 
1398,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt != NULL && inet -> opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt == NULL || ! inet -> opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt != NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct ip_options_rcu * inet_opt <S2SV_ModStart> inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> "
1399,<S2SV_StartBug> ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) { return IMPEG2D_UNKNOWN_ERROR ; } 
1400,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1401,"<S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; "
1402,<S2SV_StartBug> sin -> sin_family = AF_INET ; <S2SV_EndBug> <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> <S2SV_StartBug> sin6 -> sin6_family = AF_INET6 ; <S2SV_EndBug> <S2SV_StartBug> * addr_len = sizeof ( * sin6 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sin ) { <S2SV_ModStart> } <S2SV_ModStart> if ( sin6 ) { <S2SV_ModStart> } 
1403,<S2SV_StartBug> pvc . sap_family = AF_ATMPVC ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & pvc , 0 , sizeof ( pvc ) ) ; "
1404,<S2SV_StartBug> char * bufptr ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ; } "
1405,<S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> ,"<S2SV_ModStart> r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> "
1406,<S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; } "
1407,"<S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ss = <S2SV_ModEnd> <S2SV_ModStart> ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n"" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> pos <S2SV_ModEnd> "
1408,"<S2SV_StartBug> l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
1409,"<S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> <S2SV_StartBug> if ( optlen ) <S2SV_EndBug> <S2SV_StartBug> & ret , sock -> host_fd , level , optname , optval , optlen_in , optlen ) != <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ",<S2SV_ModStart> oe_socklen_t optlen_out = 0 ; <S2SV_ModStart> || ! optval || ! optlen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & optlen_out <S2SV_ModEnd> <S2SV_ModStart> if ( optlen_out > optlen_in ) optlen_out = optlen_in ; * optlen = optlen_out ; 
1410,"<S2SV_StartBug> return crypto_skcipher_setkey ( private , key , keylen ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher <S2SV_ModEnd> <S2SV_ModStart> tfm -> has_key = ! err ; return err ; 
1411,"<S2SV_StartBug> if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ","<S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , "
1412,<S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> ,"<S2SV_ModStart> < * object || * object + size <S2SV_ModStart> * object + size < * object || <S2SV_ModStart> < * object || * object + size * 2 <S2SV_ModStart> < * object || * object + size <S2SV_ModStart> < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> "
1413,"<S2SV_StartBug> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <S2SV_EndBug> <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_release ; <S2SV_EndBug> <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , dpacl , <S2SV_EndBug> <S2SV_StartBug> out_release : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock <S2SV_ModEnd> <S2SV_ModStart> set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> "
1414,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> ","<S2SV_ModStart> ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> intptr_t <S2SV_ModEnd> <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) "
1415,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIWR , data ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> uint16_t status ; <S2SV_ModStart> ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MIWR <S2SV_ModEnd> <S2SV_ModStart> do { status = <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> "
1416,<S2SV_StartBug> wStream * s ; <S2SV_EndBug> <S2SV_StartBug> UINT32 flags ; <S2SV_EndBug> <S2SV_StartBug> NTLM_AV_PAIR * AvFlags ; <S2SV_EndBug> <S2SV_StartBug> flags = 0 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return SEC_E_INTERNAL_ERROR ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> SECURITY_STATUS status = SEC_E_INVALID_TOKEN ; <S2SV_ModStart> = 0 <S2SV_ModStart> = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; if ( Stream_GetRemainingLength ( s ) < 4 ) goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) goto fail ; } PayloadBufferOffset = Stream_GetPosition ( s ) ; status = SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) goto fail ; if ( message -> NtChallengeResponse . Len > 0 ) { int rc ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; status = SEC_E_INVALID_TOKEN ; rc = ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) ; Stream_Free ( snt <S2SV_ModEnd> <S2SV_ModStart> if ( rc < 0 ) goto fail ; status = SEC_E_INTERNAL_ERROR <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; CopyMemory ( context -> AuthenticateMessage . pvBuffer , Stream_Buffer ( s ) , length ) ; buffer -> cbBuffer = length ; Stream_SetPosition ( s , PayloadBufferOffset ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { context -> MessageIntegrityCheckOffset = ( UINT32 ) Stream_GetPosition ( s ) ; status = SEC_E_INVALID_TOKEN ; if ( Stream_GetRemainingLength ( s ) < 16 ) goto fail ; Stream_Read ( s , message -> MessageIntegrityCheck , 16 ) ; } status = SEC_E_INTERNAL_ERROR ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> goto fail ; <S2SV_ModEnd> <S2SV_ModStart> fail : Stream_Free ( s , FALSE ) ; return status ; "
1417,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\n"" ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> child = ( pid_t ) - 1 ; <S2SV_ModStart> && child != ( pid_t ) - 1 <S2SV_ModStart> if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> } 
1418,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
1419,"<S2SV_StartBug> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; <S2SV_EndBug> <S2SV_StartBug> pag = xfs_perag_get ( btp -> bt_mount , <S2SV_EndBug> ","<S2SV_ModStart> ; xfs_daddr_t eofs <S2SV_ModStart> eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ; return NULL ; } "
1420,"<S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ; <S2SV_EndBug> <S2SV_StartBug> DSA_SIG_free ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> p <S2SV_ModEnd> <S2SV_ModStart> goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } "
1421,<S2SV_StartBug> while ( res == 0 && dev ) { <S2SV_EndBug> <S2SV_StartBug> dev = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1422,<S2SV_StartBug> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1423,<S2SV_StartBug> goto next_desc ; <S2SV_EndBug> ,"<S2SV_ModStart> ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n"" ) ; break "
1424,"<S2SV_StartBug> f = fopen ( filepath , ""rb"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""r"" <S2SV_ModEnd> "
1425,<S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ,<S2SV_ModStart> ! ( flag & <S2SV_ModEnd> <S2SV_ModStart> ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> 
1426,<S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1427,"<S2SV_StartBug> struct btrfs_dir_item * di ; <S2SV_EndBug> <S2SV_StartBug> if ( flags & XATTR_REPLACE ) { <S2SV_EndBug> <S2SV_StartBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , <S2SV_EndBug> <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> <S2SV_StartBug> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; <S2SV_EndBug> <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( flags & XATTR_CREATE ) <S2SV_EndBug> <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> <S2SV_StartBug> if ( value ) { <S2SV_EndBug> ","<S2SV_ModStart> = NULL <S2SV_ModStart> path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> <S2SV_ModStart> ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> <S2SV_ModStart> btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> <S2SV_ModStart> } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> <S2SV_ModStart> if ( di && <S2SV_ModEnd> <S2SV_ModStart> ) { ret = - EEXIST ; <S2SV_ModStart> } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> <S2SV_ModStart> } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> "
1428,<S2SV_StartBug> newlen = x -> length * 6 / 5 ; <S2SV_EndBug> <S2SV_StartBug> if ( newlen == x -> length ) <S2SV_EndBug> ,<S2SV_ModStart> area_size <S2SV_ModEnd> <S2SV_ModStart> area_size <S2SV_ModEnd> 
1429,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
1430,<S2SV_StartBug> if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( alloc > 2 ) && 
1431,"<S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) 
1432,<S2SV_StartBug> skb_dst_drop ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else 
1433,<S2SV_StartBug> if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ctxt -> error ) return ; if ( 
1434,<S2SV_StartBug> u32 offset ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1435,"<S2SV_StartBug> if ( ( r = ssh_packet_get_compress_state ( m , ssh ) ) != 0 || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1436,<S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> } 
1437,<S2SV_StartBug> sas_port_delete ( phy -> port ) ; <S2SV_EndBug> ,"<S2SV_ModStart> list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> "
1438,"<S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> <S2SV_ModStart> siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> "
1439,"<S2SV_StartBug> if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) ) <S2SV_EndBug> <S2SV_StartBug> iovec -> iov_len = kiocb -> ki_nbytes ; <S2SV_EndBug> ",<S2SV_ModStart> size_t len = kiocb -> ki_nbytes ; if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> 
1440,"<S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 
1441,"<S2SV_StartBug> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
1442,"<S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1443,"<S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> || numChannels > 256 <S2SV_ModStart> if ( ! config -> num_channels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
1444,<S2SV_StartBug> return PTR_ERR ( tty ) ; <S2SV_EndBug> ,<S2SV_ModStart> tty_driver_kref_put ( driver ) ; 
1445,"<S2SV_StartBug> ( sctp_paramhdr_t * ) addip_hdr -> params , <S2SV_EndBug> ","<S2SV_ModStart> asconf_ack , false , <S2SV_ModEnd> "
1446,"<S2SV_StartBug> memory_length += extra_length - available_length + BLOCK_QUEUE ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cp , qp -> d_memory , memory_length ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t original_length = memory_length ; <S2SV_ModStart> original_length <S2SV_ModEnd> 
1447,<S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1448,"<S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
1449,"<S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> ","<S2SV_ModStart> current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart>  <S2SV_ModEnd> "
1450,<S2SV_StartBug> __be32 * pdata = ( __be32 * ) data ; <S2SV_EndBug> ,<S2SV_ModStart> pdata ; if ( datalen != 4 ) return - EINVAL ; 
1451,<S2SV_StartBug> if ( unlikely ( len > ring -> rx_buffersize ) ) { <S2SV_EndBug> ,<S2SV_ModStart> + ring -> frameoffset 
1452,"<S2SV_StartBug> set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ; "
1453,<S2SV_StartBug> WARN_ON_ONCE ( ctx -> parent_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & ctx -> mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> lockdep_assert_held <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1454,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
1455,"<S2SV_StartBug> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> "
1456,"<S2SV_StartBug> struct sshbuf * b ; <S2SV_EndBug> <S2SV_StartBug> char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; <S2SV_EndBug> <S2SV_StartBug> u_char * pkblob , * sig , have_sig ; <S2SV_EndBug> <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> <S2SV_StartBug> __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> <S2SV_StartBug> free ( sig ) ; <S2SV_EndBug> <S2SV_StartBug> fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> <S2SV_StartBug> return authenticated ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart> = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } <S2SV_ModStart> free ( sig ) ; "
1457,<S2SV_StartBug> NameContext sNC ; <S2SV_EndBug> <S2SV_StartBug> sNC . pParse = & sParse ; <S2SV_EndBug> ,<S2SV_ModStart> Select * pSelect = pTab -> pSelect ; <S2SV_ModStart> ; assert ( pSelect -> selFlags & SF_View ) ; pSelect -> selFlags &= ~ SF_View 
1458,<S2SV_StartBug> args -> rmtblkno = 0 ; <S2SV_EndBug> <S2SV_StartBug> args -> rmtblkcnt = 0 ; <S2SV_EndBug> <S2SV_StartBug> args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen2 = args -> rmtvaluelen ; args -> <S2SV_ModStart> = 0 ; args -> rmtvaluelen <S2SV_ModStart> ; args -> rmtvaluelen = args -> rmtvaluelen2 
1459,"<S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug> ","<S2SV_ModStart> , remaining <S2SV_ModStart> remaining <S2SV_ModEnd> <S2SV_ModStart> int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> <S2SV_ModStart> remaining -= 10 ; <S2SV_ModStart> int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> <S2SV_ModStart> remaining -= 12 ; <S2SV_ModStart> if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> <S2SV_ModStart> remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> <S2SV_ModStart> ! remaining ) return 0 ; if ( <S2SV_ModStart> { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> } <S2SV_ModStart> ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9' "
1460,<S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> ,<S2SV_ModStart> { BOOL rc ; <S2SV_ModStart> rc = <S2SV_ModStart> if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> rc = <S2SV_ModStart> if ( ! rc ) return FALSE ; } 
1461,"<S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
1462,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1463,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> title , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> style_block , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> script , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> object , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> textarea , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> option , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> math , s ) ; <S2SV_EndBug> <S2SV_StartBug> # ifdef USE_PRETTYSRC <S2SV_EndBug> ","<S2SV_ModStart> HTChunk * target = NULL ; <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n"" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } } "
1464,<S2SV_StartBug> return error ; <S2SV_EndBug> ,<S2SV_ModStart> < 0 ? error : 0 
1465,<S2SV_StartBug> kiocb -> ki_nr_segs = kiocb -> ki_nbytes ; <S2SV_EndBug> ,"<S2SV_ModStart> ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ; "
1466,"<S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1467,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> pdo_row_ce -> unserialize = zend_class_unserialize_deny ; 
1468,<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ext2_mb_cache , "
1469,<S2SV_StartBug> if ( client -> type == USER_CLIENT ) <S2SV_EndBug> ,<S2SV_ModStart> && client -> data . user . fifo 
1470,<S2SV_StartBug> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1471,"<S2SV_StartBug> file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
1472,"<S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
1473,<S2SV_StartBug> return err ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> 
1474,<S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> ,<S2SV_ModStart> = - nr <S2SV_ModStart> else { delta_munlocked ++ ; } <S2SV_ModStart>  <S2SV_ModEnd> 
1475,<S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> <S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> ,<S2SV_ModStart> ( int64_t ) <S2SV_ModStart> ( int64_t ) 
1476,<S2SV_StartBug> int val = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ssocket == NULL ) return - ENOTSOCK 
1477,"<S2SV_StartBug> const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width , <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> <S2SV_StartBug> src -> y_width , src -> y_height , <S2SV_EndBug> <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> ","<S2SV_ModStart> er_y = MAX ( src -> y_width + 16 , ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) ) - src -> y_crop_width ; const int <S2SV_ModStart> src -> y_height + 16 , <S2SV_ModStart> y_height <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> y_crop_height <S2SV_ModEnd> <S2SV_ModStart> CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) { highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ; highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart> y_crop_width , src -> y_crop_height <S2SV_ModEnd> <S2SV_ModStart> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> <S2SV_ModStart> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> "
1478,<S2SV_StartBug> void * base = dlmalloc ( bytes + sizeof ( AllocationEntry ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> size_t size = bytes + sizeof ( AllocationEntry ) ; if ( size < bytes ) { return NULL ; } <S2SV_ModStart> size <S2SV_ModEnd> 
1479,<S2SV_StartBug> ps_dec -> u1_mb_idx = 0 ; <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> ,<S2SV_ModStart> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; 
1480,"<S2SV_StartBug> ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> type , length ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> EXTRACT_64BITS ( tptr + 3 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , tptr + 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length - 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart> tlen = len ; while ( tlen >= 3 ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( length < 8 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1481,"<S2SV_StartBug> # line 106 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1330 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 115 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1338 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 119 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1351 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 128 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1413 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 190 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1421 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 194 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1434 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 207 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1442 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 211 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1451 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 220 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1468 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 233 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1476 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 237 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1485 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 246 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1512 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 269 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1548 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 301 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1574 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 323 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1594 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 343 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1602 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 347 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1617 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 361 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1629 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 369 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1653 ""hex_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1657 ""hex_grammar.c"" <S2SV_EndBug> ","<S2SV_ModStart> 113 <S2SV_ModEnd> <S2SV_ModStart> 1337 <S2SV_ModEnd> <S2SV_ModStart> 122 <S2SV_ModEnd> <S2SV_ModStart> 1345 <S2SV_ModEnd> <S2SV_ModStart> 126 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1360 <S2SV_ModEnd> <S2SV_ModStart> 137 <S2SV_ModEnd> <S2SV_ModStart> ) ; incr_ast_levels ( <S2SV_ModStart> 1424 <S2SV_ModEnd> <S2SV_ModStart> 201 <S2SV_ModEnd> <S2SV_ModStart> 1432 <S2SV_ModEnd> <S2SV_ModStart> 205 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1447 <S2SV_ModEnd> <S2SV_ModStart> 220 <S2SV_ModEnd> <S2SV_ModStart> 1455 <S2SV_ModEnd> <S2SV_ModStart> 224 <S2SV_ModEnd> <S2SV_ModStart> 1464 <S2SV_ModEnd> <S2SV_ModStart> 233 <S2SV_ModEnd> <S2SV_ModStart> 1481 <S2SV_ModEnd> <S2SV_ModStart> 246 <S2SV_ModEnd> <S2SV_ModStart> 1489 <S2SV_ModEnd> <S2SV_ModStart> 250 <S2SV_ModEnd> <S2SV_ModStart> 1498 <S2SV_ModEnd> <S2SV_ModStart> 259 <S2SV_ModEnd> <S2SV_ModStart> 1525 <S2SV_ModEnd> <S2SV_ModStart> 282 <S2SV_ModEnd> <S2SV_ModStart> 1561 <S2SV_ModEnd> <S2SV_ModStart> 314 <S2SV_ModEnd> <S2SV_ModStart> 1587 <S2SV_ModEnd> <S2SV_ModStart> 336 <S2SV_ModEnd> <S2SV_ModStart> 1607 <S2SV_ModEnd> <S2SV_ModStart> 356 <S2SV_ModEnd> <S2SV_ModStart> 1615 <S2SV_ModEnd> <S2SV_ModStart> 360 <S2SV_ModEnd> <S2SV_ModStart> incr_ast_levels ( ) ; <S2SV_ModStart> 1631 <S2SV_ModEnd> <S2SV_ModStart> 375 <S2SV_ModEnd> <S2SV_ModStart> 1643 <S2SV_ModEnd> <S2SV_ModStart> 383 <S2SV_ModEnd> <S2SV_ModStart> 1667 <S2SV_ModEnd> <S2SV_ModStart> 1671 <S2SV_ModEnd> "
1482,"<S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\n]"" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> = """" <S2SV_ModStart> ""%1023s<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>%c<S2SV_blank>%8191[^\\n]"" <S2SV_ModEnd> <S2SV_ModStart> { mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n"" , line ) ; <S2SV_ModStart> } "
1483,<S2SV_StartBug> pStorage -> picSizeInMbs = <S2SV_EndBug> <S2SV_StartBug> pStorage -> activeSps -> picHeightInMbs ; <S2SV_EndBug> ,<S2SV_ModStart> if ( pStorage -> activeSps -> picWidthInMbs == 0 ) { pStorage -> picSizeInMbs = 0 ; } else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) { return ( MEMORY_ALLOCATION_ERROR ) ; } else { <S2SV_ModStart> } 
1484,<S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> u64 insn_bitness = <S2SV_ModEnd> <S2SV_ModStart> == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> <S2SV_ModStart> >= insn_bitness <S2SV_ModEnd> <S2SV_ModStart> >= insn_bitness <S2SV_ModEnd> <S2SV_ModStart> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } "
1485,<S2SV_StartBug> int iskew = imagew - tilew ; <S2SV_EndBug> <S2SV_StartBug> if ( colb + tilew > imagew ) { <S2SV_EndBug> ,<S2SV_ModStart> int64 iskew = ( int64 ) imagew - ( int64 ) <S2SV_ModEnd> <S2SV_ModStart> > iskew <S2SV_ModEnd> 
1486,<S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ) { kfree_skb ( skb ) ; <S2SV_ModStart> } 
1487,"<S2SV_StartBug> else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> anope_flags_compat && <S2SV_ModStart> anope_flags_compat && <S2SV_ModStart> anope_flags_compat && 
1488,<S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ERR_PTR ( - ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> goto couldnt_alloc_key ; <S2SV_EndBug> <S2SV_StartBug> couldnt_alloc_key : <S2SV_EndBug> <S2SV_StartBug> key_put ( dest_keyring ) ; <S2SV_EndBug> ,<S2SV_ModStart> ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> <S2SV_ModStart> error_put_dest_keyring <S2SV_ModEnd> <S2SV_ModStart> error_put_dest_keyring <S2SV_ModEnd> <S2SV_ModStart> error : 
1489,"<S2SV_StartBug> if ( s -> chunksize >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> s -> chunksize = strtoll ( line , NULL , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\'\\n"" , <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int64_t target = h -> is_streamed ? 0 : s -> off ; <S2SV_EndBug> <S2SV_StartBug> av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\n"" , s -> off , av_err2str ( read_ret ) ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\n"" , target ) ; <S2SV_EndBug> ","<S2SV_ModStart> != UINT64_MAX <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> h <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\n"" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> "
1490,<S2SV_StartBug> long tmp = * old ; <S2SV_EndBug> <S2SV_StartBug> return * old == tmp ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <S2SV_ModEnd> 
1491,"<S2SV_StartBug> static void write_sync_code ( struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> 
1492,"<S2SV_StartBug> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> return TRUE ; 
1493,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> case RMT_NONE : break ; 
1494,"<S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
1495,"<S2SV_StartBug> if ( fseek ( stats -> file , 0 , SEEK_END ) ) <S2SV_EndBug> ","<S2SV_ModStart> stats -> file == NULL ) fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!"" ) ; if ( "
1496,"<S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> ",<S2SV_ModStart> != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name 
1497,"<S2SV_StartBug> static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) <S2SV_EndBug> <S2SV_StartBug> assert ( bufsize >= 0 ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""mem_resize(%p,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> <S2SV_ModStart> if ( ! bufsize ) { jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n"" ""This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n"" ) ; } "
1498,<S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ,<S2SV_ModStart> ; cmap -> ents = 0 
1499,"<S2SV_StartBug> BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; 
1500,<S2SV_StartBug> ut8 opcode = * ( p4 ++ ) & 0xff ; <S2SV_EndBug> ,<S2SV_ModStart> if ( p4 <= 0 ) { return ; } 
1501,"<S2SV_StartBug> h = __archive_read_ahead ( a , <S2SV_EndBug> ","<S2SV_ModStart> if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) { archive_set_error ( & a -> archive , ENOMEM , ""Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte"" ) ; return ( ARCHIVE_FATAL ) ; } "
1502,"<S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> 
1503,"<S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug> ",<S2SV_ModStart> + 8 <S2SV_ModStart> const <S2SV_ModStart> ; const int <S2SV_ModEnd> 
1504,"<S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> ",<S2SV_ModStart> uint32 <S2SV_ModEnd> 
1505,"<S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> ",<S2SV_ModStart> int remaining ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> 
1506,"<S2SV_StartBug> first_block_offset = round_up ( offset , sb -> s_blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( last_block_offset > first_block_offset ) <S2SV_EndBug> <S2SV_StartBug> ext4_inode_resume_unlocked_dio ( inode ) ; <S2SV_EndBug> ",<S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; 
1507,"<S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , <S2SV_EndBug> ",<S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
1508,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug> ","<S2SV_ModStart> > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1509,"<S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> ","<S2SV_ModStart> , size << 3 "
1510,"<S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
1511,<S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
1512,"<S2SV_StartBug> assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) , <S2SV_EndBug> ","<S2SV_ModStart> size_t ss = <S2SV_ModEnd> <S2SV_ModStart> ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> pos , <S2SV_ModEnd> "
1513,"<S2SV_StartBug> int client_socket = accept ( listen_socket_ , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> send ( client_socket_ , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1514,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
1515,<S2SV_StartBug> struct buffer_head * page_bufs ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,"<S2SV_ModStart> = NULL <S2SV_ModStart> if ( page_bufs && buffer_uninit ( page_bufs ) ) { ext4_set_bh_endio ( page_bufs , inode ) ; ret = block_write_full_page_endio ( page , noalloc_get_block_write , wbc , ext4_end_io_buffer_write ) ; } else "
1516,<S2SV_StartBug> for ( i = 0 ; i < height ; ++ i ) <S2SV_EndBug> ,<S2SV_ModStart> assert ( width > 0 ) ; assert ( height > 0 ) ; assert ( width2 > 0 ) ; assert ( height2 > 0 ) ; 
1517,<S2SV_StartBug> schedule_work ( & sunkbd -> tq ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sunkbd -> enabled ) 
1518,"<S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> if ( k < 0 ) continue <S2SV_ModEnd> 
1519,"<S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> UMOUNT_CONNECTED <S2SV_ModEnd> 
1520,<S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
1521,"<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , * buf2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; <S2SV_ModEnd> <S2SV_ModStart> buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> "
1522,"<S2SV_StartBug> int q ) { <S2SV_EndBug> <S2SV_StartBug> const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low , <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth <S2SV_ModStart> , bit_depth ) * 0.01 <S2SV_ModEnd> "
1523,<S2SV_StartBug> tcp_init_send_head ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ; 
1524,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> 
1525,<S2SV_StartBug> parse_input ( conn ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( <S2SV_ModStart> != 0 ) return 
1526,<S2SV_StartBug> MATLAB_KO : <S2SV_EndBug> ,<S2SV_ModStart> if ( clone_info != ( ImageInfo * ) NULL ) 
1527,"<S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
1528,<S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> 
1529,<S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ,<S2SV_ModStart> plen <S2SV_ModEnd> 
1530,"<S2SV_StartBug> sf -> RD = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ; <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . quantize_b = vp8_fast_quantize_b ; <S2SV_EndBug> ",<S2SV_ModStart> cpi -> mb . mbs_zero_last_dot_suppress = 0 ; <S2SV_ModStart> if ( ( cpi -> Speed <= 6 ) && ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) && ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ) { if ( cpi -> closest_reference_frame == GOLDEN_FRAME ) { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 3 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 3 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 3 ; } else { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 1 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 1 ; } } <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1531,<S2SV_StartBug> char * bufptr ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ; } "
1532,"<S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> ",<S2SV_ModStart> = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> bin <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! bin -> b || 
1533,"<S2SV_StartBug> img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ; <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
1534,<S2SV_StartBug> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; <S2SV_EndBug> ,<S2SV_ModStart> ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8 
1535,"<S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> <S2SV_ModStart> net -> ipv4 . ip_id_key <S2SV_ModEnd> <S2SV_ModStart> siphash_3u32 <S2SV_ModEnd> <S2SV_ModStart> , & net -> ipv4 . ip_id_key <S2SV_ModEnd> "
1536,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1537,"<S2SV_StartBug> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
1538,<S2SV_StartBug> skb_dst_force ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> skb_set_err_queue ( skb ) ; 
1539,"<S2SV_StartBug> lua_authz_provider_spec * spec ; <S2SV_EndBug> <S2SV_StartBug> if ( require_line && * require_line ) { <S2SV_EndBug> <S2SV_StartBug> spec -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ; <S2SV_EndBug> <S2SV_StartBug> APR_ARRAY_PUSH ( spec -> args , const char * ) = arg ; <S2SV_EndBug> <S2SV_StartBug> * parsed_require_line = spec ; <S2SV_EndBug> ","<S2SV_ModStart> ; lua_authz_provider_func * func = apr_pcalloc ( cmd -> pool , sizeof ( lua_authz_provider_func ) ) <S2SV_ModStart> func -> spec = spec ; <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> "
1540,<S2SV_StartBug> len -= cut ; <S2SV_EndBug> ,<S2SV_ModStart> + 1 
1541,"<S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ",<S2SV_ModStart> | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; } 
1542,"<S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
1543,"<S2SV_StartBug> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1544,<S2SV_StartBug> ASSERT ( redir_index < IOAPIC_NUM_PINS ) ; <S2SV_EndBug> <S2SV_StartBug> redir_content = ioapic -> redirtbl [ redir_index ] . bits ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; else redir_content = ~ 0ULL 
1545,"<S2SV_StartBug> void <S2SV_EndBug> <S2SV_StartBug> if ( encrypted ) { <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> <S2SV_StartBug> cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int rc = - 1 ; char * xml_text = NULL ; int len = 0 ; xml_text = dump_xml_unformatted ( <S2SV_ModEnd> <S2SV_ModStart> if ( xml_text ) { len = strlen ( xml_text ) ; <S2SV_ModEnd> <S2SV_ModStart> crm_err ( ""Invalid<S2SV_blank>XML,<S2SV_blank>can<S2SV_blank>not<S2SV_blank>send<S2SV_blank>msg"" ) ; return - 1 ; } rc = crm_send_remote_msg_raw ( session , xml_text , len , encrypted ) ; if ( rc < 0 ) { goto done ; } rc = crm_send_remote_msg_raw ( session , REMOTE_MSG_TERMINATOR , strlen ( REMOTE_MSG_TERMINATOR ) , encrypted ) ; done : if ( rc < 0 ) { crm_err ( ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>remote<S2SV_blank>msg,<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>%d"" , rc <S2SV_ModEnd> <S2SV_ModStart> free ( xml_text ) ; return rc ; "
1546,<S2SV_StartBug> ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; <S2SV_EndBug> ,"<S2SV_ModStart> { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } "
1547,<S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> pmc_overflow ( val ) <S2SV_ModEnd> 
1548,<S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> ,<S2SV_ModStart> ses -> server -> vals = & smb21_values ; <S2SV_ModStart> { <S2SV_ModStart> ses -> server -> vals = & smb311_values ; } 
1549,"<S2SV_StartBug> err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( err <S2SV_ModEnd> "
1550,<S2SV_StartBug> if ( report -> id == REPORT_KEY_STATE ) { <S2SV_EndBug> ,"<S2SV_ModStart> size > 64 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n"" , size ) ; return 0 ; } if ( "
1551,<S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst 
1552,<S2SV_StartBug> done : <S2SV_EndBug> <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> done : 
1553,"<S2SV_StartBug> json_t * object , * foo , * bar , * baz ; <S2SV_EndBug> <S2SV_StartBug> void * iter ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( json_object_iter_key ( iter ) , ""a"" ) ) <S2SV_EndBug> <S2SV_StartBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; <S2SV_EndBug> <S2SV_StartBug> iter = json_object_iter_next ( object , iter ) ; <S2SV_EndBug> <S2SV_StartBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( json_object_iter_value ( iter ) != bar ) <S2SV_EndBug> <S2SV_StartBug> if ( json_object_iter_value ( iter ) != baz ) <S2SV_EndBug> ","<S2SV_ModStart> int i ; <S2SV_ModStart> const char * iter_keys [ 3 ] ; int have_key [ 3 ] = { 0 , 0 , 0 } ; json_t * iter_values [ 3 ] ; <S2SV_ModStart> iter_keys [ 0 ] = json_object_iter_key ( iter ) ; iter_values [ 0 ] = json_object_iter_value ( iter ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; iter_keys [ 1 ] = json_object_iter_key ( iter ) ; iter_values [ 1 ] = json_object_iter_value ( iter ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; iter_keys [ 2 ] = json_object_iter_key ( iter ) ; iter_values [ 2 ] = json_object_iter_value ( iter ) ; if ( json_object_iter_next ( object , iter ) != NULL ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end"" ) ; for ( i = 0 ; i < 3 ; i ++ ) { <S2SV_ModStart> iter_keys [ i ] <S2SV_ModEnd> <S2SV_ModStart> == 0 ) { if ( iter_values [ i ] <S2SV_ModEnd> <S2SV_ModStart> ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>a"" ) ; else have_key [ 0 ] = 1 ; } else if ( strcmp ( iter_keys [ i ] , ""b"" ) == 0 ) { if ( iter_values [ i ] != bar ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>b"" ) ; else have_key [ 1 ] = 1 ; } else if ( strcmp ( iter_keys [ i ] , ""c"" ) == 0 ) { if ( iter_values [ i ] != baz ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>c"" ) ; else have_key [ 2 ] = 1 ; } } for ( i = 0 ; i < 3 ; i ++ ) { if ( ! have_key [ i ] ) fail ( ""a<S2SV_blank>key<S2SV_blank>wasn\'t<S2SV_blank>iterated<S2SV_blank>over"" ) ; } if ( json_object_iter_at ( object , ""foo"" ) ) fail ( ""json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key"" ) ; iter = json_object_iter_at ( object , ""b"" ) ; if ( ! iter ) fail ( ""json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( <S2SV_ModStart> if ( json_object_iter_set ( object , iter , baz ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>value<S2SV_blank>at<S2SV_blank>iterator"" <S2SV_ModEnd> <S2SV_ModStart> ""json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" <S2SV_ModEnd> <S2SV_ModStart> baz ) fail ( ""json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_get ( object , ""b"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1554,"<S2SV_StartBug> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> serial -> len <S2SV_ModEnd> 
1555,<S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && out -> linesize [ i ] 
1556,<S2SV_StartBug> if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <S2SV_EndBug> ,<S2SV_ModStart> is_nmi ( intr_info ) <S2SV_ModEnd> 
1557,<S2SV_StartBug> unsigned char * data ; <S2SV_EndBug> <S2SV_StartBug> data32 = ( uint32_t * ) data ; <S2SV_EndBug> <S2SV_StartBug> data32 [ i ] ^= wsctx -> header . mask . u ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> uint32_t tmp ; memcpy ( & tmp , data + i * sizeof ( tmp ) , sizeof ( tmp ) ) ; tmp <S2SV_ModEnd> <S2SV_ModStart> ; memcpy ( data + i * sizeof ( tmp ) , & tmp , sizeof ( tmp ) ) "
1558,"<S2SV_StartBug> return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct dentry * root = <S2SV_ModEnd> <S2SV_ModStart> if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ; 
1559,<S2SV_StartBug> * dptr ++ = 0xAA ; <S2SV_EndBug> ,<S2SV_ModStart> ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> 
1560,<S2SV_StartBug> xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <S2SV_ModStart> ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 
1561,"<S2SV_StartBug> vmcs_write32 ( TPR_THRESHOLD , vmcs12 -> tpr_threshold ) ; <S2SV_EndBug> ",<S2SV_ModStart> } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif 
1562,"<S2SV_StartBug> ! ( e -> ip . flags & IPT_F_GOTO ) ) <S2SV_EndBug> <S2SV_StartBug> e = get_entry ( table_base , v ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } <S2SV_ModStart> } 
1563,<S2SV_StartBug> int nNew = pSorter -> nMemory * 2 ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 nNew = 2 * ( sqlite3_int64 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1564,<S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> switch ( EXTRACT_16BITS ( bp ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } return ; <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( bp ) ; 
1565,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1566,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t req_size = 0 ; <S2SV_ModStart> if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ; "
1567,"<S2SV_StartBug> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <S2SV_EndBug> ",<S2SV_ModStart> proc_dointvec_minmax <S2SV_ModEnd> 
1568,<S2SV_StartBug> return ret <= 0 ? ret : - EIO ; <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
1569,<S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! scontext_len ) return - EINVAL 
1570,<S2SV_StartBug> char * identifier ; <S2SV_EndBug> <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug> ,"<S2SV_ModStart> YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> assert ( sp == 0 ) ; <S2SV_ModStart> result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> <S2SV_ModStart> obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ; "
1571,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> ds = salg -> digestsize ; <S2SV_EndBug> <S2SV_StartBug> ss = salg -> statesize ; <S2SV_EndBug> ,<S2SV_ModStart> alg = & salg -> base ; <S2SV_ModStart> if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart>  <S2SV_ModEnd> 
1572,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1573,"<S2SV_StartBug> _pam_log ( LOG_DEBUG , ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'%s\'<S2SV_blank>}"" , n , tac_ntop ( tac_srv [ n ] . addr -> ai_addr ) , <S2SV_EndBug> ","<S2SV_ModStart> ""server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'********\'<S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1574,"<S2SV_StartBug> vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
1575,<S2SV_StartBug> client -> connectTimeout = DEFAULT_CONNECT_TIMEOUT ; <S2SV_EndBug> ,<S2SV_ModStart> ; client -> readTimeout = DEFAULT_READ_TIMEOUT 
1576,<S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && inpic -> data [ plane ] && inpic -> linesize [ plane ] 
1577,"<S2SV_StartBug> map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
1578,<S2SV_StartBug> sock -> sk -> sk_uid = iattr -> ia_uid ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( sock -> sk ) <S2SV_ModStart> else err = - ENOENT ; 
1579,<S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> <S2SV_StartBug> ipc . opt = inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( ipc . opt && ipc . opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> faddr = ipc . opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> ( ipc . opt && ipc . opt -> is_strictroute ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; struct ip_options_data opt_copy <S2SV_ModStart> { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . "
1580,<S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> ,<S2SV_ModStart> VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ; 
1581,"<S2SV_StartBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <S2SV_EndBug> ","<S2SV_ModStart> map , "
1582,"<S2SV_StartBug> if ( mi < 0 ) <S2SV_EndBug> <S2SV_StartBug> idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT , <S2SV_EndBug> ",<S2SV_ModStart> struct uio_mem * mem ; <S2SV_ModStart> ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> mem -> <S2SV_ModEnd> 
1583,"<S2SV_StartBug> mpz_t xdiff , ydiff , lambda ; <S2SV_EndBug> <S2SV_StartBug> mpz_clears ( xdiff , ydiff , lambda , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( pointZZ_pIsIdentityElement ( op1 ) && pointZZ_pIsIdentityElement ( op2 ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } else if ( pointZZ_pIsIdentityElement ( op1 ) ) { mpz_set ( rop -> x , op2 -> x ) ; mpz_set ( rop -> y , op2 -> y ) ; return ; } else if ( pointZZ_pIsIdentityElement ( op2 ) ) { mpz_set ( rop -> x , op1 -> x ) ; mpz_set ( rop -> y , op1 -> y ) ; return ; } if ( pointZZ_pEqual ( op1 , op2 ) ) { pointZZ_pDouble ( rop , op1 , curve ) ; return ; } mpz_t negy ; mpz_init ( negy ) ; mpz_sub ( negy , curve -> p , op2 -> y ) ; if ( mpz_cmp ( op1 -> x , op2 -> x ) == 0 && mpz_cmp ( op1 -> y , negy ) == 0 ) { mpz_clear ( negy ) ; return pointZZ_pSetToIdentityElement ( rop ) ; } mpz_t <S2SV_ModEnd> <S2SV_ModStart> negy , "
1584,"<S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> ",<S2SV_ModStart> 1024 <S2SV_ModEnd> <S2SV_ModStart> if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> && strlen ( ext ) <= sizeof ( szExt ) 
1585,"<S2SV_StartBug> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> kcalloc ( nvec , <S2SV_ModEnd> "
1586,<S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> <S2SV_StartBug> * uaddrlen = sizeof ( sllc ) ; <S2SV_EndBug> ,"<S2SV_ModStart> - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1587,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; } "
1588,<S2SV_StartBug> if ( atomic_dec_and_test ( & ucounts -> count ) ) { <S2SV_EndBug> <S2SV_StartBug> hlist_del_init ( & ucounts -> node ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ucounts -> count -= 1 ; if ( ! ucounts -> count ) <S2SV_ModStart> ; else ucounts = NULL <S2SV_ModStart>  <S2SV_ModEnd> 
1589,<S2SV_StartBug> data = img -> img_data ; <S2SV_EndBug> <S2SV_StartBug> data + x + y * img -> stride [ VPX_PLANE_ALPHA ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_U ] = data <S2SV_EndBug> <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_V ] = data <S2SV_EndBug> <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_V ] = data <S2SV_EndBug> <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; <S2SV_EndBug> <S2SV_StartBug> img -> planes [ VPX_PLANE_U ] = data <S2SV_EndBug> <S2SV_StartBug> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; <S2SV_EndBug> ,<S2SV_ModStart> const int bytes_per_sample = ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> * bytes_per_sample <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample + <S2SV_ModEnd> 
1590,"<S2SV_StartBug> JAS_DBGLOG ( 101 , ( ""jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n"" , ptr , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""jas_realloc(%x,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> "
1591,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1592,"<S2SV_StartBug> vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
1593,<S2SV_StartBug> int mapping_address = address - mb_mapping -> start_bits ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) { <S2SV_EndBug> <S2SV_StartBug> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) { <S2SV_EndBug> ,<S2SV_ModStart> nb_bits = req [ offset + 5 ] ; int <S2SV_ModStart> || nb_bits * 8 < nb <S2SV_ModStart> ] ; int nb_bytes = req [ offset + 5 <S2SV_ModStart> < nb || nb_bytes * 8 
1594,"<S2SV_StartBug> int ret = 0 , found = 0 ; <S2SV_EndBug> <S2SV_StartBug> repo_config = perf_pathdup ( ""config"" ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1595,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff32"" , ""%s"" , ""(cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
1596,"<S2SV_StartBug> bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1597,<S2SV_StartBug> if ( A > skb -> len - sizeof ( struct nlattr ) ) <S2SV_EndBug> <S2SV_StartBug> if ( nla -> nla_len > A - skb -> len ) <S2SV_EndBug> ,<S2SV_ModStart> skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - A 
1598,<S2SV_StartBug> total = le32_to_cpu ( raw_super -> segment_count ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( f2fs_cp_error ( sbi ) ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int main_segs , blocks_per_seg ; int i ; <S2SV_ModStart> main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } "
1599,"<S2SV_StartBug> REQ ( n , suite ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( TYPE ( n ) != func_body_suite ) { <S2SV_ModStart> } <S2SV_ModStart> i = 2 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) { i += 2 ; REQ ( CHILD ( n , 2 ) , NEWLINE ) ; } for ( <S2SV_ModEnd> "
1600,"<S2SV_StartBug> int status = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ; <S2SV_EndBug> <S2SV_StartBug> pthread_mutex_lock ( & vol_listner_init_lock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( memcmp ( & ( context -> desc -> uuid ) , & ( recv_contex -> desc -> uuid ) , sizeof ( effect_uuid_t ) ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> && ( context -> session_id == recv_contex -> session_id ) <S2SV_EndBug> <S2SV_StartBug> && ( context -> stream_type == recv_contex -> stream_type ) ) { <S2SV_EndBug> <S2SV_StartBug> list_remove ( & context -> effect_list_node ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> EINVAL <S2SV_ModEnd> <S2SV_ModStart> uint32_t session_id ; uint32_t stream_type ; effect_uuid_t uuid ; <S2SV_ModStart> if ( recv_contex == NULL ) { return status ; } <S2SV_ModStart> ; session_id = recv_contex -> session_id ; stream_type = recv_contex -> stream_type ; uuid = recv_contex -> desc -> uuid <S2SV_ModStart> uuid <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> node <S2SV_ModEnd> <S2SV_ModStart> pthread_mutex_unlock ( & vol_listner_init_lock ) ; return status ; 
1601,<S2SV_StartBug> w -> linebreak = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( w -> linebreak || w == text_info -> glyphs ) text_info -> n_lines -- ; if ( w != text_info -> glyphs ) 
1602,<S2SV_StartBug> if ( state -> expr_list . size == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( seq -> size == 1 ) <S2SV_EndBug> ,<S2SV_ModStart> ! state -> fmode ) { assert ( ! <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1603,<S2SV_StartBug> if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) { <S2SV_EndBug> ,<S2SV_ModStart> new_len > old_len ) { unsigned long pgoff ; if ( <S2SV_ModStart> goto Efault ; pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ; pgoff += vma -> vm_pgoff ; if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval <S2SV_ModEnd> 
1604,<S2SV_StartBug> kvm_async_pf_hash_reset ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart> vcpu -> arch . pv_time_enabled = false ; 
1605,<S2SV_StartBug> tfrc . tfrctx_x = hc -> tx_x ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & tfrc , 0 , sizeof ( tfrc ) ) ; "
1606,<S2SV_StartBug> if ( ! is_exception ( intr_info ) ) <S2SV_EndBug> ,<S2SV_ModStart> is_nmi <S2SV_ModEnd> 
1607,<S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> n ++ ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> if ( n == nitems ( p ) ) { free ( copy ) ; return ; } } 
1608,<S2SV_StartBug> void ext4_xattr_destroy_cache ( struct mb_cache * cache ) <S2SV_EndBug> <S2SV_StartBug> mb_cache_destroy ( cache ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_destroy <S2SV_ModEnd> 
1609,"<S2SV_StartBug> static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs ) <S2SV_EndBug> <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> ","<S2SV_ModStart> , uid_t uid , gid_t gid <S2SV_ModStart> const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( ""Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu"" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; } "
1610,<S2SV_StartBug> u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; } 
1611,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1612,"<S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> <S2SV_StartBug> zval * * tmp ; <S2SV_EndBug> <S2SV_StartBug> efree ( name ) ; <S2SV_EndBug> <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> int skip = 0 ; <S2SV_ModStart> ; skip = 0 <S2SV_ModStart> skip = 1 <S2SV_ModEnd> <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } 
1613,<S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> != MODE_INVALID <S2SV_ModEnd> 
1614,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> 
1615,"<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> ","<S2SV_ModStart> int format_chunk = 0 ; <S2SV_ModStart> if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
1616,<S2SV_StartBug> static int get_max_filter_level ( VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> const <S2SV_ModStart> ) { if ( cpi -> oxcf . pass == 2 <S2SV_ModStart> else { return MAX_LOOP_FILTER ; } } 
1617,<S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> no_promotions : 
1618,<S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> sysctl_head_finish ( head ) ; <S2SV_EndBug> ,<S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> out : 
1619,<S2SV_StartBug> char * tmp_str ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ i ] ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> int j = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ j ] ) <S2SV_EndBug> <S2SV_StartBug> if ( j ) { <S2SV_EndBug> <S2SV_StartBug> int j = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ j ] ) <S2SV_EndBug> <S2SV_StartBug> if ( j ) { <S2SV_EndBug> <S2SV_StartBug> while ( tmp_strsize ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ i ] ) <S2SV_EndBug> <S2SV_StartBug> if ( i ) { <S2SV_EndBug> <S2SV_StartBug> while ( tmp_strsize ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp_str [ i ] ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ; Bool zfound = GF_FALSE <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! zfound ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> ; zfound = GF_FALSE <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> ; zfound = GF_FALSE <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> zfound = GF_FALSE ; <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> zfound = GF_FALSE ; <S2SV_ModStart> { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! zfound ) return GF_ISOM_INVALID_FILE ; 
1620,<S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> 
1621,<S2SV_StartBug> for ( s = 0 ; s < ns ; s ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && row < imagelength 
1622,<S2SV_StartBug> if ( len < 0 || addr . nl_pid ) { <S2SV_EndBug> <S2SV_StartBug> incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( addr . nl_pid ) { syslog ( LOG_WARNING , ""Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u"" , addr . nl_pid ) ; continue ; } "
1623,"<S2SV_StartBug> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> ",<S2SV_ModStart> static 
1624,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> ,<S2SV_ModStart> MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> s -> studio_profile <S2SV_ModEnd> 
1625,"<S2SV_StartBug> struct in6_addr * saddr = NULL , * final_p , final ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <S2SV_EndBug> <S2SV_StartBug> np -> opt -> opt_nflen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> opt <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1626,"<S2SV_StartBug> cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; <S2SV_EndBug> <S2SV_StartBug> cpi -> temporal_pattern_counter = 0 ; <S2SV_EndBug> <S2SV_StartBug> cm -> Width = cpi -> oxcf . Width ; <S2SV_EndBug> <S2SV_StartBug> cm -> Height = cpi -> oxcf . Height ; <S2SV_EndBug> <S2SV_StartBug> vp8_denoiser_allocate ( & cpi -> denoiser , width , height ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> temporal_layer_id > 0 ) { cpi -> temporal_layer_id = 0 ; } <S2SV_ModStart> if ( ! cpi -> initial_width ) { cpi -> initial_width = cpi -> oxcf . Width ; cpi -> initial_height = cpi -> oxcf . Height ; } cm -> Width = cpi -> oxcf . Width <S2SV_ModEnd> <S2SV_ModStart> ; assert ( cm -> Width <= cpi -> initial_width ) ; assert ( cm -> Height <= cpi -> initial_height ) <S2SV_ModStart> , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity "
1627,<S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { <S2SV_EndBug> <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 2 ) ; } return OPJ_FALSE ; } "
1628,<S2SV_StartBug> if ( sum_calculated != headersum ) { <S2SV_EndBug> ,<S2SV_ModStart> lha -> compsize < 0 ) goto invalid ; if ( 
1629,<S2SV_StartBug> ( * size ) ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! allocate_field ( stream , field -> pField , field -> data_size , ( size_t ) ( * size + 1 ) ) ) return false ; field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
1630,<S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; msg -> msg_namelen = 0 
1631,"<S2SV_StartBug> static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1632,"<S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) "
1633,"<S2SV_StartBug> FILE * file = fopen ( dump_file , ""w"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
1634,<S2SV_StartBug> if ( d_mountpoint ( dentry ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) <S2SV_EndBug> <S2SV_StartBug> return d_inode ( dentry ) != NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ! d_inode <S2SV_ModEnd> <S2SV_ModStart> ) return 0 ; if ( exp -> ex_flags & NFSEXP_V4ROOT <S2SV_ModStart> d_mountpoint ( dentry ) ) return 2 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1635,<S2SV_StartBug> StringValue ( data ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ; "
1636,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
1637,"<S2SV_StartBug> int pkt_len , pktnum , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ; <S2SV_EndBug> <S2SV_StartBug> phdr -> rec_type = REC_TYPE_PACKET ; <S2SV_EndBug> <S2SV_StartBug> ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ; <S2SV_EndBug> ","<S2SV_ModStart> guint pkt_len ; int <S2SV_ModEnd> <S2SV_ModStart> ""LEN=%9u"" <S2SV_ModEnd> <S2SV_ModStart> if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( ""toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u"" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } <S2SV_ModStart> pkt_len <S2SV_ModEnd> "
1638,<S2SV_StartBug> long timeo ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1639,"<S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> 2 * ( sqlite3_int64 ) <S2SV_ModStart>  <S2SV_ModEnd> 
1640,"<S2SV_StartBug> void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> 
1641,"<S2SV_StartBug> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; <S2SV_EndBug> <S2SV_StartBug> pag = xfs_perag_get ( btp -> bt_mount , <S2SV_EndBug> ","<S2SV_ModStart> ; xfs_daddr_t eofs <S2SV_ModStart> eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ; return NULL ; } "
1642,<S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
1643,"<S2SV_StartBug> ret = poll ( pfds , 1 , 50 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1644,<S2SV_StartBug> struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> fl6 ; int err = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
1645,"<S2SV_StartBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> i ++ , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1646,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
1647,<S2SV_StartBug> upperdentry = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( upperdentry ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> err = ovl_copy_up ( dentry ) ; if ( ! err ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1648,<S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL 
1649,<S2SV_StartBug> if ( rc == - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> mutt_socket_empty ( adata -> conn ) ; 
1650,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = - EIO ; goto out <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%d\\n"" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
1651,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> fdc = FDC ( drive ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fdc != 1 && fdc != 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> unsigned int new_fdc = fdc ; <S2SV_ModStart> new_fdc <S2SV_ModEnd> <S2SV_ModStart> new_fdc >= N_FDC <S2SV_ModEnd> <S2SV_ModStart> fdc = new_fdc ; 
1652,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
1653,<S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( dst , src , 16 ) ; <S2SV_ModEnd> "
1654,"<S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> ","<S2SV_ModStart> int length = urb -> actual_length ; <S2SV_ModStart> if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> <S2SV_ModStart> length ) ; desc -> length += length ; <S2SV_ModStart> = length ; } } <S2SV_ModEnd> "
1655,"<S2SV_StartBug> timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1656,"<S2SV_StartBug> av_log ( avctx , AV_LOG_DEBUG , <S2SV_EndBug> ","<S2SV_ModStart> if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , ""Block<S2SV_blank>parameters<S2SV_blank>invalid\\n"" ) ; return AVERROR_INVALIDDATA ; } "
1657,<S2SV_StartBug> struct sshcomp * comp ; <S2SV_EndBug> <S2SV_StartBug> for ( mode = 0 ; mode < MODE_MAX ; mode ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( r = ssh_packet_init_compression ( ssh ) ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int r <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> ssh_packet_enable_delayed_compress <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1658,"<S2SV_StartBug> logger ( Protocol , Debug , ""rdpdr_process()"" ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint32_le ( s , g_client_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> if ( ! s_check ( s ) ) { rdp_protocol_error ( ""rdpdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>g_client_id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>did<S2SV_blank>overrun"" , & packet ) ; } "
1659,"<S2SV_StartBug> static void filter_selectively_vert_row2 ( PLANE_TYPE plane_type , <S2SV_EndBug> <S2SV_StartBug> const int mask_shift = plane_type ? 4 : 8 ; <S2SV_EndBug> <S2SV_StartBug> const int mask_cutoff = plane_type ? 0xf : 0xff ; <S2SV_EndBug> <S2SV_StartBug> const int lfl_forward = plane_type ? 4 : 8 ; <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_16_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_16 ( s + 8 * pitch , pitch , lfi1 -> mblim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_8 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4_dual ( s , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi0 -> mblim , lfi0 -> lim , lfi0 -> hev_thr , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s + 8 * pitch , pitch , lfi1 -> mblim , lfi1 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4_dual ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s + 4 , pitch , lfi0 -> mblim , lfi0 -> lim , <S2SV_EndBug> <S2SV_StartBug> vp9_lpf_vertical_4 ( s + 8 * pitch + 4 , pitch , lfi1 -> mblim , lfi1 -> lim , <S2SV_EndBug> ",<S2SV_ModStart> int subsampling_factor <S2SV_ModEnd> <S2SV_ModStart> subsampling_factor <S2SV_ModEnd> <S2SV_ModStart> subsampling_factor <S2SV_ModEnd> <S2SV_ModStart> subsampling_factor <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_16_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_16 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_16 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_8_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_8 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_8 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4_dual <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 <S2SV_ModEnd> <S2SV_ModStart> vpx_lpf_vertical_4 <S2SV_ModEnd> 
1660,"<S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug> ",<S2SV_ModStart> mii_ioctl_data <S2SV_ModEnd> <S2SV_ModStart> if_mii ( rq ) <S2SV_ModEnd> <S2SV_ModStart> SIOCGMIIPHY : miidata -> phy_id = phy_addr ; <S2SV_ModEnd> <S2SV_ModStart> SIOCGMIIREG <S2SV_ModEnd> <S2SV_ModStart> val_out <S2SV_ModEnd> <S2SV_ModStart> SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> <S2SV_ModStart> val_in <S2SV_ModEnd> 
1661,"<S2SV_StartBug> if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""FHDB"" , 4 ) ) { <S2SV_EndBug> <S2SV_StartBug> log ( ""%08"" PRIX64 ""<S2SV_blank>%.4s\\n"" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; <S2SV_EndBug> <S2SV_StartBug> return MYSOFA_OK ; <S2SV_EndBug> ","<S2SV_ModStart> reader -> recursive_counter >= 10 ) return MYSOFA_INVALID_FORMAT ; else reader -> recursive_counter ++ ; if ( <S2SV_ModStart> ""<S2SV_blank>%.4s<S2SV_blank>stack<S2SV_blank>%d\\n"" <S2SV_ModEnd> <S2SV_ModStart> , reader -> recursive_counter <S2SV_ModStart> reader -> recursive_counter -- ; "
1662,<S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( desc == NULL ) desc = """" ; "
1663,"<S2SV_StartBug> _PyMemoTable_ResizeTable ( PyMemoTable * self , Py_ssize_t min_size ) <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t new_size = MT_MINSIZE ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t to_process ; <S2SV_EndBug> <S2SV_StartBug> while ( new_size < min_size && new_size > 0 ) <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> if ( min_size > PY_SSIZE_T_MAX ) { PyErr_NoMemory ( ) ; return - 1 ; } <S2SV_ModStart> ) { new_size <<= <S2SV_ModEnd> 
1664,"<S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> pr_fs_clear_cache ( ) ; <S2SV_EndBug> <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> <S2SV_ModStart> if ( errno == EPERM ) { <S2SV_ModEnd> <S2SV_ModStart> ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ; } <S2SV_ModEnd> "
1665,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ; 
1666,"<S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! _gdImageWBMPCtx <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> } else { rv = NULL ; } 
1667,<S2SV_StartBug> parameters -> res_spec = parameters -> numresolution - 1 ; <S2SV_EndBug> <S2SV_StartBug> parameters -> prch_init [ i ] = 256 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> } 
1668,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> ",<S2SV_ModStart> ; msg -> msg_namelen = 0 
1669,"<S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> ","<S2SV_ModStart> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> release_write_pending <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1670,"<S2SV_StartBug> struct usmStateReference * old_ref = ( struct usmStateReference * ) old ; <S2SV_EndBug> <S2SV_StartBug> if ( old_ref ) { <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_engine_id_length ) <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_auth_protocol_length ) <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_priv_protocol_length ) <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_auth_key_length && old_ref -> usr_auth_key ) { <S2SV_EndBug> <S2SV_StartBug> SNMP_ZERO ( old_ref -> usr_auth_key , old_ref -> usr_auth_key_length ) ; <S2SV_EndBug> <S2SV_StartBug> SNMP_FREE ( old_ref -> usr_auth_key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( old_ref -> usr_priv_key_length && old_ref -> usr_priv_key ) { <S2SV_EndBug> <S2SV_StartBug> SNMP_ZERO ( old_ref -> usr_priv_key , old_ref -> usr_priv_key_length ) ; <S2SV_EndBug> <S2SV_StartBug> SNMP_FREE ( old_ref -> usr_priv_key ) ; <S2SV_EndBug> <S2SV_StartBug> SNMP_ZERO ( old_ref , sizeof ( * old_ref ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ref = <S2SV_ModEnd> <S2SV_ModStart> ! ref ) return ; if ( -- ref -> refcnt > 0 ) return ; SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart> SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart> SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart> SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> ref <S2SV_ModEnd> <S2SV_ModStart> SNMP_FREE ( ref <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1671,<S2SV_StartBug> if ( status ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } if ( <S2SV_ModStart> ( <S2SV_ModStart> && ( <S2SV_ModEnd> <S2SV_ModStart> <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1 "
1672,"<S2SV_StartBug> void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1673,<S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ,<S2SV_ModStart> plen <S2SV_ModEnd> 
1674,"<S2SV_StartBug> static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col , <S2SV_EndBug> <S2SV_StartBug> const MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( sa , xd -> above_seg_context + mi_col , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) , <S2SV_EndBug> ",<S2SV_ModStart> MACROBLOCK * const x <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
1675,"<S2SV_StartBug> int blockstodecode ; <S2SV_EndBug> <S2SV_StartBug> if ( ! nblocks || nblocks > INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <S2SV_EndBug> <S2SV_StartBug> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; uint64_t decoded_buffer_size <S2SV_ModStart> / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> decoded_buffer_size <S2SV_ModEnd> "
1676,"<S2SV_StartBug> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_EndBug> <S2SV_StartBug> f -> colorspace = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( f -> version > 0 ) <S2SV_EndBug> <S2SV_StartBug> f -> avctx -> bits_per_raw_sample = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> chroma_planes = get_rac ( c , state ) ; <S2SV_EndBug> <S2SV_StartBug> chroma_h_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chroma_planes != f -> chroma_planes <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , colorspace , bits_per_raw_sample <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bits_per_raw_sample = <S2SV_ModEnd> <S2SV_ModStart> ? get_symbol ( c , state , 0 ) : <S2SV_ModEnd> <S2SV_ModStart> ; chroma_planes = get_rac ( c , state ) ; chroma_h_shift <S2SV_ModStart> chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || <S2SV_ModStart> f -> colorspace = colorspace ; f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ; "
1677,<S2SV_StartBug> frame_end : <S2SV_EndBug> ,<S2SV_ModStart> if ( ! s -> studio_profile ) 
1678,<S2SV_StartBug> sas_port_delete ( port -> port ) ; <S2SV_EndBug> ,<S2SV_ModStart> sas_destruct_devices ( port ) ; 
1679,<S2SV_StartBug> ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ; <S2SV_EndBug> <S2SV_StartBug> ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> 
1680,<S2SV_StartBug> if ( ! vct_iscrlf ( * r ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1681,<S2SV_StartBug> unsigned int random_variable = 0 ; <S2SV_EndBug> <S2SV_StartBug> random_variable = get_random_int ( ) & STACK_RND_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> ( unsigned long ) <S2SV_ModStart> ; random_variable &= <S2SV_ModEnd> 
1682,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1683,"<S2SV_StartBug> spin_lock ( & inode -> i_lock ) ; <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
1684,<S2SV_StartBug> if ( keyring_key -> type != & key_type_logon ) { <S2SV_EndBug> <S2SV_StartBug> down_read ( & keyring_key -> sem ) ; <S2SV_EndBug> <S2SV_StartBug> ukp = user_key_payload ( keyring_key ) ; <S2SV_EndBug> ,"<S2SV_ModStart> down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> ukp = user_key_payload ( keyring_key ) ; if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n"" , __func__ , master_key -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read <S2SV_ModEnd> <S2SV_ModStart> key_put ( keyring_key ) ; return <S2SV_ModEnd> "
1685,"<S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1686,"<S2SV_StartBug> int need_error_free = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( inbuf . data , sendauth_version ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( appl_version && strcmp ( inbuf . data , appl_version ) ) { <S2SV_EndBug> ","<S2SV_ModStart> krb5_data d ; <S2SV_ModStart> d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ; if ( ! data_eq ( inbuf , d <S2SV_ModEnd> <S2SV_ModStart> != NULL && ! problem ) { d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ; if ( ! data_eq ( inbuf , d ) <S2SV_ModEnd> "
1687,<S2SV_StartBug> list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ; "
1688,<S2SV_StartBug> hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <S2SV_EndBug> ,<S2SV_ModStart> + ( hwc -> idx - X86_PMC_IDX_FIXED ) 
1689,<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( qid > NVMET_NR_QUEUES ) return NULL 
1690,"<S2SV_StartBug> if ( msg -> maxsize - msg -> cursize < 4 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bits == 8 ) { <S2SV_EndBug> <S2SV_StartBug> nbits = bits & 7 ; <S2SV_EndBug> <S2SV_StartBug> Huff_offsetTransmit ( & msgHuff . compressor , ( value & 0xff ) , msg -> data , & msg -> bit ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> overflowed ) { <S2SV_ModEnd> <S2SV_ModStart> msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> , msg -> maxsize << 3 <S2SV_ModStart> if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } "
1691,<S2SV_StartBug> && ( NULL != ptr -> line ) <S2SV_EndBug> <S2SV_StartBug> && ( ( '+' != ptr -> line [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> && ( '-' != ptr -> line [ 0 ] ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( NULL == <S2SV_ModEnd> <S2SV_ModStart> || ( ( '+' != ptr -> line [ 0 ] ) && ( '-' <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL != ptr <S2SV_ModEnd> 
1692,"<S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
1693,<S2SV_StartBug> if ( ack -> subh . addip_hdr -> serial == serial ) { <S2SV_EndBug> ,<S2SV_ModStart> sctp_chunk_pending ( ack ) ) continue ; if ( 
1694,<S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1695,"<S2SV_StartBug> mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen ) <S2SV_EndBug> <S2SV_StartBug> MPT_FRAME_HDR * mf ; <S2SV_EndBug> <S2SV_StartBug> if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> iocp -> name , ( int ) fwlen ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> MPT_ADAPTER * iocp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1696,<S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug> ,<S2SV_ModStart> skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> ; skb -> destructor = sock_efree 
1697,"<S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_CORRUPT_FRAME ; <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . number_of_layers > 1 ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> layer = cpi -> oxcf . layer_id [ <S2SV_EndBug> <S2SV_StartBug> cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> int y_samples = orig -> y_height * orig -> y_width ; <S2SV_EndBug> <S2SV_StartBug> int uv_samples = orig -> uv_height * orig -> uv_width ; <S2SV_EndBug> <S2SV_StartBug> double sq_error , sq_error2 ; <S2SV_EndBug> <S2SV_StartBug> recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ; <S2SV_EndBug> <S2SV_StartBug> ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , <S2SV_EndBug> <S2SV_StartBug> recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; <S2SV_EndBug> <S2SV_StartBug> double frame_psnr2 , frame_ssim2 = 0 ; <S2SV_EndBug> <S2SV_StartBug> pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ; <S2SV_EndBug> <S2SV_StartBug> ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , <S2SV_EndBug> <S2SV_StartBug> pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; <S2SV_EndBug> <S2SV_StartBug> frame_ssim2 = vp8_calc_ssim ( cpi -> Source , <S2SV_EndBug> <S2SV_StartBug> & cm -> post_proc_buffer , 1 , & weight ) ; <S2SV_EndBug> <S2SV_StartBug> frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show , <S2SV_EndBug> <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vp8_clear_system_state ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 ) { LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { cpi -> ref_framerate = low_res_frame_info -> low_res_framerate ; } else { low_res_frame_info -> low_res_framerate = cpi -> ref_framerate ; } } # endif <S2SV_ModStart> && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> temporal_layer_id >= 0 ) { layer = cpi -> temporal_layer_id ; } else { <S2SV_ModStart> } <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> unsigned int y_width = cpi -> common . Width ; unsigned int y_height = cpi -> common . Height ; unsigned int uv_width = ( y_width + 1 ) / 2 ; unsigned int uv_height = ( y_height + 1 ) / 2 ; <S2SV_ModStart> y_height * <S2SV_ModEnd> <S2SV_ModStart> uv_height * <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> y_width , y_height ) ; ue = calc_plane_error ( orig -> u_buffer <S2SV_ModEnd> <S2SV_ModStart> uv_stride , recon -> u_buffer , recon -> uv_stride , uv_width , uv_height ) ; ve <S2SV_ModEnd> <S2SV_ModStart> v_buffer <S2SV_ModEnd> <S2SV_ModStart> v_buffer <S2SV_ModEnd> <S2SV_ModStart> uv_width , <S2SV_ModEnd> <S2SV_ModStart> sq_error2 ; double <S2SV_ModStart> y_width , y_height ) ; ue = calc_plane_error ( orig -> u_buffer <S2SV_ModEnd> <S2SV_ModStart> uv_stride , pp -> u_buffer , pp -> uv_stride , uv_width , uv_height ) ; ve <S2SV_ModEnd> <S2SV_ModStart> v_buffer <S2SV_ModEnd> <S2SV_ModStart> v_buffer <S2SV_ModEnd> <S2SV_ModStart> uv_width , <S2SV_ModEnd> <S2SV_ModStart> vpx_calc_ssim <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_calc_ssimg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1698,"<S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; page_geometry = DestroyString ( page_geometry 
1699,"<S2SV_StartBug> if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! memcmp ( data -> schemadata + data -> schemata [ cid ] , schema , len * sizeof ( Id ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && <S2SV_ModStart> ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && 
1700,<S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( - 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1701,"<S2SV_StartBug> struct efx_nic * efx = netdev_priv ( net_dev ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ring -> rx_pending < EFX_MIN_RING_SIZE || <S2SV_EndBug> <S2SV_StartBug> ""TX<S2SV_blank>and<S2SV_blank>RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%ld\\n"" , <S2SV_EndBug> <S2SV_StartBug> return efx_realloc_channels ( efx , ring -> rx_pending , ring -> tx_pending ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; u32 txq_entries <S2SV_ModStart> EFX_RXQ_MIN_ENT <S2SV_ModEnd> <S2SV_ModStart> ""RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%u\\n"" , EFX_RXQ_MIN_ENT <S2SV_ModEnd> <S2SV_ModStart> txq_entries = max ( ring -> tx_pending , EFX_TXQ_MIN_ENT ( efx ) ) ; if ( txq_entries != ring -> tx_pending ) netif_warn ( efx , drv , efx -> net_dev , ""increasing<S2SV_blank>TX<S2SV_blank>queue<S2SV_blank>size<S2SV_blank>to<S2SV_blank>minimum<S2SV_blank>of<S2SV_blank>%u\\n"" , txq_entries ) ; <S2SV_ModStart> txq_entries <S2SV_ModEnd> "
1702,"<S2SV_StartBug> bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <S2SV_EndBug> ",<S2SV_ModStart> KVM_MAX_VCPU_ID <S2SV_ModEnd> 
1703,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || shdr -> sh_size > SIZE_MAX 
1704,<S2SV_StartBug> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart> || header_len < RAW_DATA_LEN ( header ) 
1705,<S2SV_StartBug> image -> columns = image -> rows = 0 ; <S2SV_EndBug> <S2SV_StartBug> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ; <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
