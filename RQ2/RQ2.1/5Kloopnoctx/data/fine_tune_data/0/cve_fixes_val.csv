,source,target
0,<S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> ,"<S2SV_ModStart> unix_dgram_peer_wake_disconnect ( sk , skpair ) ; "
1,"<S2SV_StartBug> int_mv * ref_mv , <S2SV_EndBug> <S2SV_StartBug> int64_t tx_size_diff [ TX_MODES ] , <S2SV_EndBug> <S2SV_StartBug> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> best_mode_index = mode_index ; <S2SV_EndBug> <S2SV_StartBug> ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , int skippable <S2SV_ModStart> skippable = skippable ; ctx -> <S2SV_ModStart> mbmi_ext = * x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
2,<S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> "
3,"<S2SV_StartBug> cm -> allow_comp_inter_inter = 0 ; <S2SV_EndBug> <S2SV_StartBug> cm -> allow_comp_inter_inter = 1 ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter ) <S2SV_EndBug> <S2SV_StartBug> else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] && <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ COMPOUND_REFERENCE ] > <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ REFERENCE_MODE_SELECT ] && <S2SV_EndBug> <S2SV_StartBug> else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] ) <S2SV_EndBug> <S2SV_StartBug> if ( cm -> interp_filter == SWITCHABLE ) { <S2SV_EndBug> <S2SV_StartBug> cm -> interp_filter = EIGHTTAP_SMOOTH ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_8X8 ) ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_4X4 ) ; <S2SV_EndBug> <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_16X16 ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> interp_filter = SWITCHABLE ; <S2SV_EndBug> ","<S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> ; RD_OPT * const rd_opt = & cpi -> rd ; FRAME_COUNTS * counts = cpi -> td . counts ; RD_COUNTS * const rdc = & cpi -> td . rd_counts <S2SV_ModStart> int64_t * const mode_thrs = rd_opt -> prediction_type_threshes <S2SV_ModEnd> <S2SV_ModStart> int64_t * const filter_thrs = rd_opt -> filter_threshes <S2SV_ModEnd> <S2SV_ModStart> const int is_alt_ref = <S2SV_ModEnd> <S2SV_ModStart> ; if ( is_alt_ref || ! cpi <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart> mode_thrs <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_interp_filter ( filter_thrs , is_alt_ref ) ; <S2SV_ModEnd> <S2SV_ModStart> mode_thrs [ i ] = ( mode_thrs [ i ] + rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> / 2 ; <S2SV_ModEnd> <S2SV_ModStart> ++ i ) filter_thrs [ i ] = ( filter_thrs [ i ] + rdc -> filter_diff <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> reset_skip_tx_size <S2SV_ModEnd> <S2SV_ModStart> reset_skip_tx_size <S2SV_ModEnd> <S2SV_ModStart> reset_skip_tx_size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
4,"<S2SV_StartBug> if ( test_bit ( EV_KEY , dev -> evbit ) && <S2SV_EndBug> ","<S2SV_ModStart> if ( old_keycode > KEY_MAX ) { dev_warn ( dev -> dev . parent ? : & dev -> dev , ""%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\n"" , __func__ , old_keycode ) ; } else "
5,"<S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> 
6,<S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
7,"<S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> ",<S2SV_ModStart> | O_NOFOLLOW 
8,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
9,"<S2SV_StartBug> FILE * fp = fopen ( dest_filename , ""w"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""wx"" <S2SV_ModEnd> "
10,"<S2SV_StartBug> * low = p - reg -> dmax ; <S2SV_EndBug> <S2SV_StartBug> ( pprev ? pprev : str ) , * low ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> } "
11,<S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> mutex_unlock ( & pit -> pit_state . lock ) ; 
12,<S2SV_StartBug> vpx_roi_map_t roi = { 0 } ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & roi , 0 , sizeof ( roi ) ) <S2SV_ModEnd> "
13,"<S2SV_StartBug> static const char * parse_object ( cJSON * item , const char * value ) <S2SV_EndBug> <S2SV_StartBug> ep = value ; <S2SV_EndBug> <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> ep = value ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> ep = value ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * * ep <S2SV_ModStart> * ep = value ; return 0 ; <S2SV_ModEnd> <S2SV_ModStart> return value + 1 ; <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> * ep = value ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> child = new_item ; <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> * ep = value ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> return value + 1 ; * ep = value ; <S2SV_ModEnd> "
14,<S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return AVERROR_PATCHWELCOME ; } "
15,"<S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> pParse <S2SV_ModEnd> 
16,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> av_freep ( & x -> buf ) ; x -> buf_size = 0 ; 
17,<S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
18,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; 
19,"<S2SV_StartBug> strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
20,"<S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> ","<S2SV_ModStart> , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> "
21,<S2SV_StartBug> int r ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> ,"<S2SV_ModStart> , dontmax = 0 <S2SV_ModStart> if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ; "
22,<S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> ,<S2SV_ModStart> INT_MAX <S2SV_ModEnd> 
23,"<S2SV_StartBug> memcpy ( output , input , sizeof ( uint8_t ) * length ) ; <S2SV_EndBug> ",<S2SV_ModStart> output [ 0 ] <S2SV_ModEnd> 
24,<S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pv_time_enabled = false ; } <S2SV_ModEnd> 
25,"<S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ","<S2SV_ModStart> mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> <S2SV_ModStart> { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> "
26,<S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart>  <S2SV_ModEnd> "
27,"<S2SV_StartBug> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <S2SV_EndBug> ",<S2SV_ModStart> i + 
28,<S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> <S2SV_StartBug> return len ; <S2SV_EndBug> ,"<S2SV_ModStart> { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModStart> } "
29,<S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; 
30,<S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> 
31,"<S2SV_StartBug> void fdct16_8col ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ; <S2SV_EndBug> <S2SV_StartBug> v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ; <S2SV_EndBug> <S2SV_StartBug> v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_EndBug> <S2SV_StartBug> u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; <S2SV_EndBug> <S2SV_StartBug> s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) <S2SV_ModStart> k__cospi_p08_m24 <S2SV_ModEnd> <S2SV_ModStart> cospi_8_64 , - cospi_24_64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 3 ] = _mm_madd_epi16 ( u [ 3 <S2SV_ModEnd> <S2SV_ModStart> v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_ModStart> _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; s [ 3 ] = <S2SV_ModStart> 4 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
32,<S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> avio_feof ( pb ) ) { return AVERROR_EOF ; } if ( 
33,<S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> 
34,<S2SV_StartBug> long elements ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( * p >= max - 2 ) { zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ; return - 1 ; } <S2SV_ModStart> - 1 <S2SV_ModEnd> "
35,<S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug> ,<S2SV_ModStart> && kvm_x86_ops -> get_cpl ( vcpu ) == 0 
36,<S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } "
37,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
38,"<S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( out2 ) <S2SV_ModStart> , sizeof ( out2 ) "
39,"<S2SV_StartBug> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; <S2SV_EndBug> <S2SV_StartBug> RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] ) <S2SV_EndBug> ","<S2SV_ModStart> 1000000000 <S2SV_ModEnd> <S2SV_ModStart> ) ; RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 <S2SV_ModStart> && cfg -> rc_target_bitrate > 0 "
40,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
41,"<S2SV_StartBug> long mtemp , save_adjust , rem ; <S2SV_EndBug> <S2SV_StartBug> time_offset = div_long_long_rem_signed ( time_offset , <S2SV_EndBug> <S2SV_StartBug> NTP_INTERVAL_FREQ , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> div_s64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
42,<S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_32BITS ( bp ) ; 
43,<S2SV_StartBug> if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( alloc > 2 ) && 
44,<S2SV_StartBug> size_t length ; <S2SV_EndBug> <S2SV_StartBug> if ( segment -> dataOffset < 5 ) <S2SV_EndBug> <S2SV_StartBug> length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ; <S2SV_EndBug> <S2SV_StartBug> if ( option -> kind == TCP_OPTION_NOP ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i + 1 ) >= length || ( i + option -> length ) > length ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> i ; size_t length <S2SV_ModEnd> <S2SV_ModStart> >= ( sizeof ( TcpHeader ) / 4 ) ) { length = ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> TCP_OPTION_END ) { break ; } else if ( option -> kind == <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> ) break ; if ( option -> length < sizeof ( TcpOption ) <S2SV_ModStart> } } 
45,"<S2SV_StartBug> double vp9_convert_qindex_to_q ( int qindex ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_ac_quant ( qindex , 0 ) / 4.0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> <S2SV_ModStart> , bit_depth <S2SV_ModStart> case VPX_BITS_10 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 16.0 ; case VPX_BITS_12 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 64.0 ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1.0 ; } # else return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ; # endif "
46,<S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> ,<S2SV_ModStart> && i > 0 
47,<S2SV_StartBug> if ( buf -> pts == AV_NOPTS_VALUE ) { <S2SV_EndBug> ,<S2SV_ModStart> || av_fifo_size ( s -> fifo ) <= 0 
48,<S2SV_StartBug> parameters -> res_spec = parameters -> numresolution - 1 ; <S2SV_EndBug> <S2SV_StartBug> parameters -> prch_init [ i ] = 256 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> } 
49,<S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> ,<S2SV_ModStart> ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> 
50,<S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> ,<S2SV_ModStart> n2size < 1 ) <S2SV_ModEnd> 
51,<S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
52,<S2SV_StartBug> # undef _ <S2SV_EndBug> ,<S2SV_ModStart> _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ; 
53,"<S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> - EINVAL <S2SV_ModEnd> 
54,<S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> ,<S2SV_ModStart> SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> 
55,<S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
56,"<S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS ) <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EGPWRPT <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ETXST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ETXLEN <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS <S2SV_ModEnd> "
57,<S2SV_StartBug> native_handle_t * h = malloc ( <S2SV_EndBug> <S2SV_StartBug> sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) { return NULL ; } size_t mallocSize = <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> ) ; native_handle_t * h = malloc ( mallocSize 
58,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
59,<S2SV_StartBug> ptr = p + 2 ; <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> 
60,<S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> ,<S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> 
61,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> ",<S2SV_ModStart> && ps_stream -> u4_offset < ps_stream -> u4_max_offset 
62,"<S2SV_StartBug> res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( vpx_codec_alg_priv_t * ) <S2SV_ModStart>  <S2SV_ModEnd> 
63,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
64,<S2SV_StartBug> * p == SSL3_MT_CLIENT_HELLO ) && <S2SV_EndBug> ,<S2SV_ModStart> s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> 
65,"<S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
66,<S2SV_StartBug> ue -> info = * info ; <S2SV_EndBug> ,<S2SV_ModStart> card = card ; ue -> 
67,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return num ; <S2SV_EndBug> ,<S2SV_ModStart> fpl -> user = NULL ; <S2SV_ModStart> if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ; 
68,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
69,"<S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> packet_len ) <S2SV_ModEnd> "
70,"<S2SV_StartBug> READ ( data , msg . f . length ) <S2SV_EndBug> <S2SV_StartBug> if ( msg . f . length > sizeof ( data ) ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> HandleFence ( cl , flags , msg . f . length , data ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> SKIP ( msg . f . length ) } else { READ ( data , msg . f . length ) <S2SV_ModEnd> <S2SV_ModStart> } "
71,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; 
72,<S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & tu -> ioctl_lock ) ; 
73,<S2SV_StartBug> avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ; 
74,"<S2SV_StartBug> int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) { <S2SV_EndBug> <S2SV_StartBug> int sent = send ( conn -> sock , cbuf , len , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> 
75,"<S2SV_StartBug> uint32_t qttag , qtsize32 , len ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; size_t <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> LongSeek ( mp4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
76,"<S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> ",<S2SV_ModStart> ; int err <S2SV_ModStart> err = <S2SV_ModEnd> <S2SV_ModStart> ; if ( err <S2SV_ModStart> ERR_PTR ( err ) <S2SV_ModEnd> 
77,"<S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( obuf ) "
78,<S2SV_StartBug> if ( ! ps_seq -> u1_frame_mbs_only_flag ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> ,"<S2SV_ModStart> ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! <S2SV_ModStart> if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } <S2SV_ModStart>  <S2SV_ModEnd> "
79,<S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> <S2SV_ModStart> ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock "
80,"<S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> <S2SV_StartBug> end = strxmov ( query , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`"" , db , ""`"" , NullS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> ","<S2SV_ModStart> NAME_LEN + 100 ] ; int len <S2SV_ModEnd> <S2SV_ModStart> len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`"" , db <S2SV_ModEnd> <S2SV_ModStart> && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> "
81,<S2SV_StartBug> bestmv -> as_mv . row <<= 3 ; <S2SV_EndBug> <S2SV_StartBug> bestmv -> as_mv . col <<= 3 ; <S2SV_EndBug> ,<S2SV_ModStart> *= 8 <S2SV_ModEnd> <S2SV_ModStart> *= 8 <S2SV_ModEnd> 
82,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
83,"<S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ","<S2SV_ModStart> scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error = "
84,"<S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> ","<S2SV_ModStart> char * p ; int len ; <S2SV_ModStart> len = <S2SV_ModEnd> <S2SV_ModStart> ; if ( retnamlen + len <S2SV_ModEnd> <S2SV_ModStart> p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> "
85,"<S2SV_StartBug> VpxVideoWriter * writer = NULL ; <S2SV_EndBug> <S2SV_StartBug> vpx_fixed_buf_t stats = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> const VpxInterface * encoder = NULL ; <S2SV_EndBug> <S2SV_StartBug> info . codec_fourcc = encoder -> fourcc ; <S2SV_EndBug> <S2SV_StartBug> info . frame_height = strtol ( height_arg , NULL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( info . frame_width <= 0 || <S2SV_EndBug> <S2SV_StartBug> info . frame_height <= 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_width % 2 ) != 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_height % 2 ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> die ( ""Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d"" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , <S2SV_EndBug> <S2SV_StartBug> info . frame_height , 1 ) ) { <S2SV_EndBug> <S2SV_StartBug> die ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image"" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> <S2SV_StartBug> while ( vpx_img_read ( & raw , infile ) ) { <S2SV_EndBug> <S2SV_StartBug> fclose ( infile ) ; <S2SV_EndBug> ","<S2SV_ModStart> int w , h <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> w <S2SV_ModEnd> <S2SV_ModStart> h <S2SV_ModEnd> <S2SV_ModStart> w <S2SV_ModEnd> <S2SV_ModStart> h <S2SV_ModEnd> <S2SV_ModStart> ( w <S2SV_ModEnd> <S2SV_ModStart> ( h <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> w , h ) ; <S2SV_ModEnd> <S2SV_ModStart> w , h <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> w , h ) ; printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config."" ) ; cfg . g_w = w ; cfg . g_h = h ; cfg . g_timebase . num = 1 ; cfg . g_timebase . den = fps ; cfg . rc_target_bitrate = bitrate ; if ( ! ( infile = fopen ( infile_arg , ""rb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading"" , infile_arg ) ; cfg . g_pass = VPX_RC_FIRST_PASS ; stats = pass0 ( & raw , infile , encoder , & cfg ) ; rewind ( infile ) ; cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; pass1 ( & raw , infile , outfile_arg , encoder , & cfg ) ; free ( stats . buf ) ; vpx_img_free <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
86,<S2SV_StartBug> if ( c -> string ) <S2SV_EndBug> ,<S2SV_ModStart> ! ( c -> type & cJSON_StringIsConst ) && 
87,<S2SV_StartBug> void vp9_inc_frame_in_layer ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> VP9_COMP * const cpi <S2SV_ModEnd> <S2SV_ModStart> & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers <S2SV_ModEnd> <S2SV_ModStart> ++ lc -> frames_from_key_frame ; 
88,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
89,"<S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
90,<S2SV_StartBug> tunnel_type = * ( tptr + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
91,<S2SV_StartBug> ExitLoop : <S2SV_EndBug> ,<S2SV_ModStart> quantum_info = DestroyQuantumInfo ( quantum_info ) ; 
92,<S2SV_StartBug> while ( peek ( s ) != '>' && ! eol ( s ) ) <S2SV_EndBug> ,<S2SV_ModStart> && ! eof ( s ) 
93,"<S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ; <S2SV_EndBug> <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 ) <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_EUDAST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EUDAST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EUDAST <S2SV_ModEnd> "
94,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
95,<S2SV_StartBug> size_t e ; <S2SV_EndBug> <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ; mrb_value nil <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ; 
96,<S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> && client -> session == NULL 
97,"<S2SV_StartBug> sk_wait_data ( sk , & timeo , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ; 
98,"<S2SV_StartBug> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;"" <S2SV_EndBug> <S2SV_StartBug> return APR_ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> if ( rv != APR_SUCCESS ) { <S2SV_EndBug> <S2SV_StartBug> case BODY_CHUNK_END : { <S2SV_EndBug> <S2SV_StartBug> int merge_trailers = <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> ""Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>"" ""using<S2SV_blank>read-until-close"" <S2SV_ModEnd> <S2SV_ModStart> APR_EINVAL <S2SV_ModEnd> <S2SV_ModStart> apr_brigade_cleanup ( bb ) ; <S2SV_ModStart> BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> <S2SV_ModStart> return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> <S2SV_ModStart> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) ""Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)"" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> "
99,"<S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
100,<S2SV_StartBug> struct ipv6_txoptions * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! opt ) <S2SV_EndBug> <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> ,<S2SV_ModStart> = NULL ; struct ipv6_txoptions * opt_to_free <S2SV_ModStart> { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; txopt_put ( opt_to_free 
101,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; ret = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> "
102,"<S2SV_StartBug> NUMA * na ; <S2SV_EndBug> <S2SV_StartBug> pixt = pixCopy ( NULL , pix ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = goodcol - 1 ; j >= 0 ; j -- ) { <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j + 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j - 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pix <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pix <S2SV_ModEnd> <S2SV_ModStart> } } <S2SV_ModEnd> 
103,<S2SV_StartBug> u16 source_node_id ; <S2SV_EndBug> <S2SV_StartBug> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 <S2SV_EndBug> <S2SV_StartBug> ( ver == RFC2734_SW_VERSION <S2SV_EndBug> <S2SV_StartBug> || ver == RFC3146_SW_VERSION <S2SV_EndBug> <S2SV_StartBug> ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> gasp_version ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> gasp_version ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart> fwnet_incoming_packet ( dev , buf_ptr + 2 , length - IEEE1394_GASP_HDR_SIZE , gasp_source_id ( buf_ptr ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
104,<S2SV_StartBug> sin -> sin_family = AF_INET ; <S2SV_EndBug> <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> <S2SV_StartBug> sin6 -> sin6_family = AF_INET6 ; <S2SV_EndBug> <S2SV_StartBug> * addr_len = sizeof ( * sin6 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sin ) { <S2SV_ModStart> } <S2SV_ModStart> if ( sin6 ) { <S2SV_ModStart> } 
105,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> skip_mm : 
106,<S2SV_StartBug> guint uint_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> <S2SV_StartBug> gboolean bool_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> ; if ( value_len < 4 ) break ; bool_val 
107,<S2SV_StartBug> kk = malloc ( xsize * kmax * sizeof ( float ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! kk ) <S2SV_EndBug> ,<S2SV_ModStart> if ( kmax > 0 && xsize > SIZE_MAX / kmax ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize * kmax > SIZE_MAX / sizeof ( float ) ) return ( Imaging ) ImagingError_MemoryError ( ) ; <S2SV_ModStart> ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize > SIZE_MAX / ( 2 * sizeof ( int ) ) 
108,<S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> ,<S2SV_ModStart> tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ; 
109,"<S2SV_StartBug> struct timespec ts ; <S2SV_EndBug> <S2SV_StartBug> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( nsec < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; s32 rem <S2SV_ModStart> div_s64_rem <S2SV_ModEnd> <S2SV_ModStart> rem <S2SV_ModEnd> <S2SV_ModStart> rem <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> -- ; rem += NSEC_PER_SEC ; } <S2SV_ModEnd> <S2SV_ModStart> = rem <S2SV_ModEnd> 
110,<S2SV_StartBug> buffer = malloc ( msg . tc . length + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( msg . tc . length > MAX_TEXTCHAT_SIZE ) return FALSE ; 
111,"<S2SV_StartBug> rb_define_singleton_method ( klass , ""read_memory"" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , ""from_document"" , from_document , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> - <S2SV_ModStart> - 
112,<S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! context ) return FALSE <S2SV_ModStart> if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> BYTE * <S2SV_ModStart> BYTE * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> const INT8 * <S2SV_ModStart> return TRUE ; 
113,<S2SV_StartBug> int iSrc ; <S2SV_EndBug> <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . 
114,<S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> mutex_unlock ( & pit -> pit_state . lock ) ; 
115,"<S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , STRLEN , ""%lu%d%lu"" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( file , ""%s"" , Run . id ) ; <S2SV_EndBug> ",<S2SV_ModStart> ASSERT ( idfile ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> Util_getToken ( Run . id ) <S2SV_ModEnd> 
116,<S2SV_StartBug> aptr += RRFIXEDSZ ; <S2SV_EndBug> ,<S2SV_ModStart> if ( aptr + rr_len > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; } 
117,"<S2SV_StartBug> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> hdr . w1 = ntohl ( buf [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> if ( fg_off + len > dg_size ) return 0 ; 
118,<S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } } 
119,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ",<S2SV_ModStart> int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> rc = <S2SV_ModStart> rc <S2SV_ModEnd> 
120,<S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if ( 
121,"<S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> s && ( <S2SV_ModStart> ) 
122,"<S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> psf_allocate ( <S2SV_ModEnd> 
123,"<S2SV_StartBug> box -> len = len ; <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; JAS_DBGLOG ( 10 , ( ""preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) <S2SV_ModStart> box -> ops = & jp2_boxinfo_unk . ops ; "
124,"<S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> ",<S2SV_ModStart> 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> <S2SV_ModStart> while ( count <= index ) count *= 2 ; 
125,<S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug> ,<S2SV_ModStart> tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && <S2SV_ModStart> tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && 
126,"<S2SV_StartBug> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
127,"<S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug> ",<S2SV_ModStart> if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
128,"<S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } } 
129,"<S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ","<S2SV_ModStart> = 0 ; size_t data_size <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } "
130,<S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; } 
131,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ; 
132,<S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0 
133,<S2SV_StartBug> if ( ! ( info = bmp_getinfo ( in ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ; "
134,"<S2SV_StartBug> ip_printts ( ndo , cp , option_len ) ; <S2SV_EndBug> <S2SV_StartBug> case IPOPT_RA : <S2SV_EndBug> ","<S2SV_ModStart> if ( ip_printts <S2SV_ModEnd> <S2SV_ModStart> IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case "
135,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } "
136,"<S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> iph -> protocol , <S2SV_EndBug> ","<S2SV_ModStart> static u32 ip_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> ) ) ; net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra <S2SV_ModStart> ^ ip_idents_hashrnd_extra "
137,"<S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strlcpy <S2SV_ModEnd> <S2SV_ModStart> sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> <S2SV_ModStart> sizeof ( extra_response -> value ) <S2SV_ModEnd> 
138,"<S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> <S2SV_StartBug> unsigned v ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; size_t copy <S2SV_ModStart> copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> <S2SV_ModStart> copy <S2SV_ModEnd> <S2SV_ModStart> copy + 1 <S2SV_ModEnd> "
139,<S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> ,<S2SV_ModStart> || stringset == ETH_SS_PRIV_FLAGS 
140,"<S2SV_StartBug> struct rdcost_block_args args = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> args . use_fast_coef_costing = use_fast_coef_casting ; <S2SV_EndBug> <S2SV_StartBug> if ( args . skip ) { <S2SV_EndBug> <S2SV_StartBug> * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; vp9_zero ( args ) <S2SV_ModEnd> <S2SV_ModStart> ; args . skippable = 1 <S2SV_ModStart> exit_early <S2SV_ModEnd> <S2SV_ModStart> args . skippable <S2SV_ModEnd> 
141,"<S2SV_StartBug> len = strlen ( ""/lock/lxc/"" ) + strlen ( n ) + strlen ( p ) + 3 ; <S2SV_EndBug> <S2SV_StartBug> ret = snprintf ( dest , len , ""%s/lock/lxc/%s"" , rundir , p ) ; <S2SV_EndBug> <S2SV_StartBug> int l2 = 22 + strlen ( n ) + strlen ( p ) ; <S2SV_EndBug> <S2SV_StartBug> free ( rundir ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""/lxc/lock/"" <S2SV_ModEnd> <S2SV_ModStart> ""%s/lxc/lock/%s"" <S2SV_ModEnd> <S2SV_ModStart> free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , ""%s/lxc/lock/%s/.%s"" , rundir , p , n ) ; free ( rundir <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
142,<S2SV_StartBug> struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> fl6 ; int err = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
143,<S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n"" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> err = - EINVAL ; "
144,"<S2SV_StartBug> GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ; <S2SV_EndBug> <S2SV_StartBug> gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; <S2SV_EndBug> ",<S2SV_ModStart> extern Bool use_dump_mode ; <S2SV_ModStart> if ( ! use_dump_mode ) 
145,<S2SV_StartBug> if ( * pStackPtr >= CDL_STACK_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return EAS_ERROR_FILE_FORMAT ; <S2SV_EndBug> ,"<S2SV_ModStart> ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( ""b/34031018,<S2SV_blank>stackPtr(%d)"" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , ""34031018"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } "
146,"<S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , XEN_NETIF_RSP_OKAY "
147,"<S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , ""Content-Length"" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> ","<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , ""WWW-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Authentication-Info"" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Proxy-Authenticate"" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , ""Connection"" ) ) { if ( ! strcmp ( p , ""close"" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , ""Server"" ) ) { if ( ! av_strcasecmp ( p , ""AkamaiGHost"" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , ""MediaGateway"" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , ""Content-Type"" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , ""Set-Cookie"" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strtoull <S2SV_ModEnd> "
148,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mutt_socket_empty ( conn ) ; 
149,"<S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>s"" ) ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>h<S2SV_blank>f"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> send ( <S2SV_ModEnd> <S2SV_ModStart> send ( <S2SV_ModEnd> <S2SV_ModStart> send ( <S2SV_ModEnd> 
150,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } "
151,<S2SV_StartBug> char added ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
152,"<S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev , ""%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> devname = kstrdup ( dev_name ( & <S2SV_ModEnd> <S2SV_ModStart> ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> pr_info ( ""%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n"" <S2SV_ModEnd> <S2SV_ModStart> drvname , devname ) ; kfree ( devname <S2SV_ModEnd> "
153,"<S2SV_StartBug> list_del ( & key -> graveyard_link ) ; <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> short state = key -> state ; <S2SV_ModStart> state == KEY_IS_POSITIVE && <S2SV_ModEnd> <S2SV_ModStart> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
154,"<S2SV_StartBug> REQ ( n , for_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == 9 ) { <S2SV_EndBug> <S2SV_StartBug> seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ; <S2SV_EndBug> <S2SV_StartBug> suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFor ( target , expression , suite_seq , seq , <S2SV_EndBug> <S2SV_StartBug> return For ( target , expression , suite_seq , seq , <S2SV_EndBug> ","<S2SV_ModStart> int has_type_comment ; string type_comment ; <S2SV_ModStart> ; has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT <S2SV_ModStart> + has_type_comment <S2SV_ModStart> + has_type_comment <S2SV_ModStart> + has_type_comment <S2SV_ModStart> has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> type_comment , <S2SV_ModStart> , type_comment "
155,"<S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> current_euid <S2SV_ModEnd> <S2SV_ModStart> in_egroup_p ( root_gid <S2SV_ModEnd> 
156,<S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; "
157,<S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; } "
158,<S2SV_StartBug> if ( bytecnt ) { <S2SV_EndBug> <S2SV_StartBug> bytecnt -- ; <S2SV_EndBug> ,<S2SV_ModStart> >= 2 <S2SV_ModStart> if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ; 
159,"<S2SV_StartBug> if ( ( keylen ) > nodesize ) { <S2SV_EndBug> <S2SV_StartBug> PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; <S2SV_EndBug> ",<S2SV_ModStart> keylen >= nodesize - rec_off <S2SV_ModEnd> <S2SV_ModStart> ( nodesize - rec_off ) <S2SV_ModEnd> 
160,"<S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug> ","<S2SV_ModStart> __sock_release ( sock , NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
161,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
162,"<S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = ns_to_timespec ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = ns_to_timespec ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
163,"<S2SV_StartBug> fprintf ( stderr , ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD"" , inName ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\\n"" <S2SV_ModEnd> "
164,<S2SV_StartBug> test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> jitter = j_jitter -> valuefloat ; <S2SV_EndBug> ,<S2SV_ModStart> valuedouble <S2SV_ModEnd> <S2SV_ModStart> valuedouble <S2SV_ModEnd> <S2SV_ModStart> valuedouble <S2SV_ModEnd> <S2SV_ModStart> valuedouble <S2SV_ModEnd> 
165,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> ",<S2SV_ModStart> m -> msg_namelen = 0 ; 
166,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
167,"<S2SV_StartBug> uzbl . net . useragent = ""Test<S2SV_blank>useragent"" ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
168,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> "
169,<S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! F_SECT_PER_TRACK ) return ; 
170,<S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
171,<S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> ,<S2SV_ModStart> case EXIT_REASON_INVVPID : 
172,<S2SV_StartBug> struct pmu * leader_pmu = event -> group_leader -> pmu ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( is_software_event ( event ) ) return 1 
173,<S2SV_StartBug> int n = 0 ; <S2SV_EndBug> <S2SV_StartBug> sock = ap_get_conn_socket ( r -> connection ) ; <S2SV_EndBug> <S2SV_StartBug> lua_websocket_read ( L ) ; <S2SV_EndBug> ,<S2SV_ModStart> do_read = 1 ; int <S2SV_ModStart> ; while ( do_read ) { do_read = 0 <S2SV_ModStart> do_read = 1 ; } <S2SV_ModEnd> 
174,<S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> ,<S2SV_ModStart> | CL_UNPRIVILEGED 
175,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( rc -> uwbd . task ) 
176,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
177,"<S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
178,"<S2SV_StartBug> const void * data ; <S2SV_EndBug> <S2SV_StartBug> int noffset = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * err_msg = """" ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , <S2SV_EndBug> <S2SV_StartBug> err_msg , fit_get_name ( fit , noffset , NULL ) , <S2SV_EndBug> <S2SV_StartBug> return fit_image_verify_with_data ( fit , image_noffset , data , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * name = fit_get_name ( fit , image_noffset , NULL ) ; const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( strchr ( name , '@' ) ) { err_msg = ""Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@"" ; goto err ; } <S2SV_ModStart> goto err ; } return fit_image_verify_with_data <S2SV_ModEnd> <S2SV_ModStart> image_noffset , data , size ) ; err : printf ( ""error!\\n%s<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n"" , err_msg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
179,<S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dp [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> dp [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> dp [ 3 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dp [ 1 ] <S2SV_ModEnd> 
180,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ; <S2SV_EndBug> <S2SV_StartBug> hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> return wc_SignatureGenerate_ex ( hash_type , sig_type <S2SV_ModEnd> <S2SV_ModStart> sig , <S2SV_ModEnd> <S2SV_ModStart> , 1 <S2SV_ModStart>  <S2SV_ModEnd> "
181,<S2SV_StartBug> if ( copy_in ) { <S2SV_EndBug> <S2SV_StartBug> * bounce_buf_ret = bounce_buf ; <S2SV_EndBug> ,<S2SV_ModStart> * bounce_buf_ret = bounce_buf ; <S2SV_ModStart>  <S2SV_ModEnd> 
182,<S2SV_StartBug> const FIRSTPASS_STATS * this_frame ) { <S2SV_EndBug> <S2SV_StartBug> const struct twopass_rc * twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> av_err = stats -> ssim_weighted_pred_err / stats -> count ; <S2SV_EndBug> <S2SV_StartBug> modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err / <S2SV_EndBug> <S2SV_StartBug> cpi -> oxcf . two_pass_vbrbias / 100.0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> TWO_PASS * twopass , const VP9EncoderConfig * oxcf , const <S2SV_ModStart> FIRSTPASS_STATS * const <S2SV_ModEnd> <S2SV_ModStart> const double av_weight <S2SV_ModEnd> <S2SV_ModStart> weight <S2SV_ModEnd> <S2SV_ModStart> const double av_err = ( stats -> coded_error * av_weight ) / stats -> count ; double <S2SV_ModStart> coded_error * this_frame -> weight <S2SV_ModEnd> <S2SV_ModStart> oxcf -> <S2SV_ModEnd> <S2SV_ModStart> ) ; modified_error *= pow ( calculate_active_area ( cpi , this_frame ) , ACT_AREA_CORRECTION "
183,<S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! iov -> iov_len 
184,<S2SV_StartBug> return FALSE ; <S2SV_EndBug> ,<S2SV_ModStart> transport -> credssp = NULL ; 
185,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> ( * field_rtrn != NULL ) <S2SV_ModEnd> 
186,<S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> ( sqlite3_int64 ) <S2SV_ModStart> sqlite3_int64 nStr = <S2SV_ModEnd> <S2SV_ModStart> sqlite3_malloc64 <S2SV_ModEnd> 
187,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
188,<S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> ,<S2SV_ModStart> SSL_SET_OPTIONS ( & mysql_connection ) ; <S2SV_ModEnd> 
189,"<S2SV_StartBug> memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> strlcpy <S2SV_ModEnd> <S2SV_ModStart> strlcpy <S2SV_ModEnd> 
190,"<S2SV_StartBug> void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> "
191,"<S2SV_StartBug> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> case DW_FORM_data2 : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> # if 0 <S2SV_ModStart> # endif <S2SV_ModStart> if ( value -> encoding . block . data ) { <S2SV_ModStart> } <S2SV_ModStart> if ( value -> encoding . block . data ) { <S2SV_ModStart> } 
192,<S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ,<S2SV_ModStart> mb2_cache <S2SV_ModEnd> 
193,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> title , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> style_block , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> script , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> object , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> textarea , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> option , s ) ; <S2SV_EndBug> <S2SV_StartBug> HTChunkPuts ( & me -> math , s ) ; <S2SV_EndBug> <S2SV_StartBug> # ifdef USE_PRETTYSRC <S2SV_EndBug> ","<S2SV_ModStart> HTChunk * target = NULL ; <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n"" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } } "
194,"<S2SV_StartBug> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
195,<S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> ,<S2SV_ModStart> & <S2SV_ModStart> & <S2SV_ModStart> & 
196,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; 
197,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> ","<S2SV_ModStart> ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> intptr_t <S2SV_ModEnd> <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) "
198,<S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ,<S2SV_ModStart> ! ( flag & <S2SV_ModEnd> <S2SV_ModStart> ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> 
199,<S2SV_StartBug> mptctl_replace_fw ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
200,"<S2SV_StartBug> if ( ( addr_fd = open ( val , O_RDONLY ) ) != - 1 ) <S2SV_EndBug> <S2SV_StartBug> read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
201,<S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> ,<S2SV_ModStart> if ( reg_index < 2 ) { <S2SV_ModStart> } <S2SV_ModStart> if ( reg_index < 2 ) { <S2SV_ModStart> } 
202,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; "
203,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> ,<S2SV_ModStart> ctx -> terminated || 
204,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_context_expr ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & context_expr , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""context_expr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & context_expr , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_optional_vars , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; optional_vars = NULL ; } else { int res ; <S2SV_ModStart> optional_vars <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
205,"<S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
206,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
207,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
208,"<S2SV_StartBug> enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_NO_FLAGS ) ; <S2SV_EndBug> ",<S2SV_ModStart> IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn <S2SV_ModEnd> 
209,"<S2SV_StartBug> log_file = fopen ( file_name , ""a"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
210,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , false "
211,"<S2SV_StartBug> int frame_avail , got_data ; <S2SV_EndBug> <S2SV_StartBug> struct VpxInputContext input = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> exec_name = argv_ [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> input . use_i420 = 1 ; <S2SV_EndBug> <S2SV_StartBug> input . only_i420 = 1 ; <S2SV_EndBug> <S2SV_StartBug> parse_global_config ( & global , argv ) ; <S2SV_EndBug> <S2SV_StartBug> off_t lagged_count = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! input . width || ! input . height ) <S2SV_EndBug> <S2SV_StartBug> } ) ; <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)"" ) ; <S2SV_EndBug> <S2SV_StartBug> input . use_i420 ? VPX_IMG_FMT_I420 <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( open_output_file ( stream , & global ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""\\033[K"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( frames_in > global . skip_frames ) { <S2SV_EndBug> <S2SV_StartBug> vpx_usec_timer_mark ( & timer ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! got_data && input . length && ! streams -> frames_out ) { <S2SV_EndBug> <S2SV_StartBug> off_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ; <S2SV_EndBug> <S2SV_StartBug> off_t input_pos = ftello ( input . file ) ; <S2SV_EndBug> <S2SV_StartBug> off_t input_pos_lagged = input_pos - lagged_count ; <S2SV_EndBug> <S2SV_StartBug> int64_t limit = input . length ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! global . quiet ) <S2SV_EndBug> <S2SV_StartBug> ""\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7"" PRId64 ""B<S2SV_blank>%7lub/f<S2SV_blank>%7"" PRId64 ""b/s"" <S2SV_EndBug> <S2SV_StartBug> seen_frames ? ( unsigned long ) ( stream -> nbytes * 8 / seen_frames ) : 0 , <S2SV_EndBug> <S2SV_StartBug> usec_to_fps ( stream -> cx_time , seen_frames ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( show_psnr ( stream ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> } ) ; <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t raw_shift ; int allocated_raw_shift = 0 ; int use_16bit_internal = 0 ; int input_shift = 0 ; # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset ( & input , 0 , sizeof ( input ) ) ; <S2SV_ModStart> only_i420 <S2SV_ModEnd> <S2SV_ModStart> bit_depth = 0 <S2SV_ModEnd> <S2SV_ModStart> switch ( global . color_type ) { case I420 : input . fmt = VPX_IMG_FMT_I420 ; break ; case I422 : input . fmt = VPX_IMG_FMT_I422 ; break ; case I444 : input . fmt = VPX_IMG_FMT_I444 ; break ; case I440 : input . fmt = VPX_IMG_FMT_I440 ; break ; case YV12 : input . fmt = VPX_IMG_FMT_YV12 ; break ; } <S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> if ( ! input . bit_depth ) { FOREACH_STREAM ( { if ( stream -> config . cfg . g_input_bit_depth ) input . bit_depth = stream -> config . cfg . g_input_bit_depth ; else input . bit_depth = stream -> config . cfg . g_input_bit_depth = ( int ) stream -> config . cfg . g_bit_depth ; } ) ; if ( input . bit_depth > 8 ) input . fmt |= VPX_IMG_FMT_HIGHBITDEPTH ; } else { FOREACH_STREAM ( { stream -> config . cfg . g_input_bit_depth = input . bit_depth ; } ) ; } <S2SV_ModStart> input . fmt , <S2SV_ModEnd> <S2SV_ModStart> , & input . pixel_aspect_ratio <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global . codec -> name , ""vp9"" ) == 0 || strcmp ( global . codec -> name , ""vp10"" ) == 0 ) { FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) { use_16bit_internal = 1 ; } if ( stream -> config . cfg . g_profile == 0 ) { input_shift = 0 ; } else { input_shift = ( int ) stream -> config . cfg . g_bit_depth - stream -> config . cfg . g_input_bit_depth ; } } ) ; } # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * frame_to_encode ; if ( input_shift || ( use_16bit_internal && input . bit_depth == 8 ) ) { assert ( use_16bit_internal ) ; if ( ! allocated_raw_shift ) { vpx_img_alloc ( & raw_shift , raw . fmt | VPX_IMG_FMT_HIGHBITDEPTH , input . width , input . height , 32 ) ; allocated_raw_shift = 1 ; } vpx_img_upshift ( & raw_shift , & raw , input_shift ) ; frame_to_encode = & raw_shift ; } else { frame_to_encode = & raw ; } vpx_usec_timer_start ( & timer ) ; if ( use_16bit_internal ) { assert ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ; FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ; else assert ( 0 ) ; } ) ; } else { assert ( ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) == 0 ) ; FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ) ; } # else <S2SV_ModStart> # endif <S2SV_ModStart> streams != NULL && <S2SV_ModStart> const int64_t <S2SV_ModEnd> <S2SV_ModStart> const int64_t <S2SV_ModEnd> <S2SV_ModStart> const int64_t <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> if ( ! global . quiet ) fprintf ( stderr , ""\\033[K"" ) ; <S2SV_ModStart> { <S2SV_ModStart> ""B<S2SV_blank>%7"" PRId64 ""b/f<S2SV_blank>%7"" <S2SV_ModEnd> <S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_ModStart> { if ( global . codec -> fourcc == VP9_FOURCC ) { FOREACH_STREAM ( <S2SV_ModEnd> <S2SV_ModStart> , ( 1 << stream -> config . cfg . g_input_bit_depth ) - 1 ) ) ; } else { FOREACH_STREAM ( show_psnr ( stream , 255.0 ) ) ; } } <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS FOREACH_STREAM ( stats_close ( & stream -> fpmb_stats , global . passes - 1 ) ) ; # endif <S2SV_ModStart> ) ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( allocated_raw_shift ) vpx_img_free ( & raw_shift "
212,"<S2SV_StartBug> int opts ; <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> ","<S2SV_ModStart> result ; int <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0 "
213,"<S2SV_StartBug> uint32_t GetPayloadTime ( size_t handle , uint32_t index , float * in , float * out ) <S2SV_EndBug> <S2SV_StartBug> if ( mp4 == NULL ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> * in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> * out = ( float ) ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> GPMF_ERROR_MEMORY <S2SV_ModEnd> <S2SV_ModStart> GPMF_ERROR_MEMORY <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> GPMF_OK <S2SV_ModEnd> 
214,<S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( size_left < 4 ) { LogError ( ""Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } "
215,"<S2SV_StartBug> separator = strchr ( connection -> buffer , ':' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
216,<S2SV_StartBug> if ( option ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( * session_ptr ) -> max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS ; <S2SV_ModStart> if ( ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS ) && option -> max_settings ) { ( * session_ptr ) -> max_settings = option -> max_settings ; } 
217,"<S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> <S2SV_ModStart> ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> "
218,<S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
219,"<S2SV_StartBug> jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> <S2SV_ModStart> return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n"" ) ; return 0 ; } "
220,"<S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
221,"<S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> <S2SV_StartBug> oe_socklen_t addrlen_in = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> <S2SV_StartBug> ( struct oe_sockaddr * ) src_addr , <S2SV_EndBug> <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0 ; oe_socklen_t addrlen_out <S2SV_ModStart> || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( src_addr && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & addrlen_out <S2SV_ModEnd> <S2SV_ModStart> if ( src_addr && addrlen ) { if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
222,<S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <S2SV_EndBug> ,<S2SV_ModStart> { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> i_temp ; } <S2SV_ModEnd> 
223,"<S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . y_mode_prob [ size_group ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> "
224,<S2SV_StartBug> if ( file -> name ) XFREE ( file -> name ) ; <S2SV_EndBug> <S2SV_StartBug> file -> len = a -> values [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( file -> content_id ) XFREE ( file -> content_id ) ; <S2SV_EndBug> ,<S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> assert ( a -> type == szMAPI_STRING ) ; 
225,"<S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> rcu_read_unlock ( ) ; 
226,<S2SV_StartBug> new -> cid_mask = new -> lid_mask = 0xffff ; <S2SV_EndBug> ,<S2SV_ModStart> ( 1 << KVM_X2APIC_CID_BITS ) - 1 ; 
227,<S2SV_StartBug> ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ; "
228,<S2SV_StartBug> return ( mhlen ) ; <S2SV_EndBug> ,<S2SV_ModStart> - 1 <S2SV_ModEnd> 
229,<S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! scontext_len ) return - EINVAL 
230,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> <S2SV_StartBug> l_row -- ; <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> <S2SV_ModStart> LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; 
231,"<S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( w == NULL ) return 0 
232,"<S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; "
233,"<S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> skip_recode ) <S2SV_EndBug> <S2SV_StartBug> vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; <S2SV_EndBug> <S2SV_StartBug> optimize_b ( plane , block , plane_bsize , tx_size , x , a , l ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> <S2SV_StartBug> vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> { if ( x -> quant_fp ) { if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } else { vp9_xform_quant_fp ( x , plane , block , plane_bsize , tx_size ) ; } } else { if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { int txfm_blk_index = ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ; if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_NONE ) { <S2SV_ModStart> } else if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_AC_ONLY ) { vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; } else { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; } } } <S2SV_ModStart> const int ctx = combine_entropy_contexts ( * a , * l ) ; * a = * l = optimize_b ( x , plane , block , tx_size , ctx ) > 0 <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> vp9_highbd_idct32x32_add <S2SV_ModEnd> <S2SV_ModStart> p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> <S2SV_ModStart> vp9_highbd_idct16x16_add <S2SV_ModEnd> <S2SV_ModStart> p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> <S2SV_ModStart> vp9_highbd_idct8x8_add <S2SV_ModEnd> <S2SV_ModStart> p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> <S2SV_ModStart> x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> <S2SV_ModStart> return ; } # endif switch ( tx_size ) { case TX_32X32 : vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_16X16 : vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_8X8 : vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_4X4 : x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; default : assert ( 0 && ""Invalid<S2SV_blank>transform<S2SV_blank>size"" ) ; break ; } "
234,<S2SV_StartBug> iris_info . dimension = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" "
235,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> 
236,<S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> no_promotions : 
237,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
238,<S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> <S2SV_ModStart> return false <S2SV_ModEnd> 
239,"<S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> ","<S2SV_ModStart> , u8 status <S2SV_ModStart> status <S2SV_ModEnd> "
240,"<S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> ","<S2SV_ModStart> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> release_write_pending <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
241,"<S2SV_StartBug> ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> "
242,"<S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> ",<S2SV_ModStart> inode_dio_wait ( inode ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
243,"<S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> ",<S2SV_ModStart> 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> <S2SV_ModStart> while ( count <= index ) count *= 2 ; 
244,<S2SV_StartBug> if ( len > count ) <S2SV_EndBug> ,<S2SV_ModStart> ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> 
245,<S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } } 
246,"<S2SV_StartBug> int rose_parse_facilities ( unsigned char * p , <S2SV_EndBug> <S2SV_StartBug> if ( facilities_len == 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( facilities_len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned packet_len <S2SV_ModStart> || ( unsigned ) facilities_len > packet_len <S2SV_ModStart> >= 3 && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> break ; default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * p ) ; len = 1 ; break ; } <S2SV_ModStart> ) return 0 ; if ( WARN_ON ( len >= facilities_len ) <S2SV_ModStart> } return facilities_len == 0 <S2SV_ModEnd> "
247,<S2SV_StartBug> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ,"<S2SV_ModStart> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> "
248,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
249,"<S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> ","<S2SV_ModStart> memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> memset ( & link , 0 , sizeof ( link ) ) ; "
250,<S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ; if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) { rc = - EINVAL ; goto fail3 ; } 
251,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
252,"<S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> <S2SV_ModStart> ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> 
253,<S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
254,<S2SV_StartBug> bh -> b_size = map . m_len << inode -> i_blkbits ; <S2SV_EndBug> ,<S2SV_ModStart> ( u64 ) 
255,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && frame -> linesize [ plane ] 
256,"<S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( l > ll ) l = ll ; 
257,<S2SV_StartBug> addr -> sap_family = AF_ATMPVC ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( addr , 0 , sizeof ( * addr ) ) ; "
258,<S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
259,<S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && out -> linesize [ i ] 
260,<S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> ,<S2SV_ModStart> ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> 
261,"<S2SV_StartBug> image = 0 ; <S2SV_EndBug> <S2SV_StartBug> jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> bmp_dec_importopts_t opts ; size_t num_samples ; image = 0 ; info = 0 ; if ( bmp_dec_parseopts ( optstr , & opts ) ) { goto error <S2SV_ModEnd> <S2SV_ModStart> ) ; goto error ; } if ( ! jas_safe_size_mul3 ( info -> width , info -> height , info -> numplanes , & num_samples ) ) { jas_eprintf ( ""image<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\n"" ) ; goto error ; } if ( opts . max_samples > 0 && num_samples > opts . max_samples ) { jas_eprintf ( ""maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>pixels<S2SV_blank>exceeded<S2SV_blank>(%zu)\\n"" , opts . max_samples "
262,"<S2SV_StartBug> q = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> <S2SV_StartBug> q = strchr ( uri , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
263,<S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> unlock : 
264,"<S2SV_StartBug> char query [ 255 ] ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( query , ""SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`"" , trow [ 0 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> NAME_LEN + 100 <S2SV_ModEnd> <S2SV_ModStart> my_snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( query ) , "
265,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - ENOMEM ; } return <S2SV_ModEnd> 
266,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> ",<S2SV_ModStart> m -> msg_namelen = 0 ; 
267,<S2SV_StartBug> tok -> err = json_tokener_success ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; } 
268,<S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
269,<S2SV_StartBug> prepenv ( const struct rule * rule ) <S2SV_EndBug> <S2SV_StartBug> env = createenv ( rule ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , const struct passwd * mypw , const struct passwd * targpw ) { <S2SV_ModEnd> <S2SV_ModStart> , mypw , targpw <S2SV_ModEnd> "
270,<S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> <S2SV_StartBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> while ( queue ) { <S2SV_EndBug> <S2SV_StartBug> ( * free_func ) ( queue ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> <S2SV_StartBug> # ifdef CONFIG_LOCKDEP <S2SV_EndBug> ,"<S2SV_ModStart> spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> <S2SV_ModStart> while ( 1 ) { <S2SV_ModStart> if ( ! queue ) break ; <S2SV_ModEnd> <S2SV_ModStart> { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
271,<S2SV_StartBug> section -> spatial_layer_id = frame -> spatial_layer_id ; <S2SV_EndBug> <S2SV_StartBug> section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ; <S2SV_EndBug> <S2SV_StartBug> section -> pcnt_neutral += frame -> pcnt_neutral ; <S2SV_EndBug> ,<S2SV_ModStart> weight += frame -> weight ; section -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; section -> intra_skip_pct += frame -> intra_skip_pct ; section -> inactive_zone_rows += frame -> inactive_zone_rows ; section -> inactive_zone_cols += frame -> inactive_zone_cols 
272,<S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> loop_index_mutex <S2SV_ModEnd> 
273,"<S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> ","<S2SV_ModStart> caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( ! "
274,<S2SV_StartBug> error = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
275,<S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> ,<S2SV_ModStart> tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ; 
276,"<S2SV_StartBug> unsigned char * buf ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && bufsize 
277,<S2SV_StartBug> if ( val > sysctl_wmem_max ) <S2SV_EndBug> <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_SNDBUF ) <S2SV_EndBug> <S2SV_StartBug> if ( val > sysctl_rmem_max ) <S2SV_EndBug> <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_RCVBUF ) <S2SV_EndBug> ,"<S2SV_ModStart> val = min_t ( u32 , val , sysctl_wmem_max ) <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_sndbuf = max_t ( u32 , <S2SV_ModEnd> <S2SV_ModStart> , SOCK_MIN_SNDBUF ) <S2SV_ModEnd> <S2SV_ModStart> val = min_t ( u32 , val , sysctl_rmem_max ) <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_rcvbuf = max_t ( u32 , <S2SV_ModEnd> <S2SV_ModStart> , SOCK_MIN_RCVBUF ) <S2SV_ModEnd> "
278,"<S2SV_StartBug> GetPixelIndex ( image , q ) , q ) ; <S2SV_EndBug> ","<S2SV_ModStart> ConstrainColormapIndex ( image , <S2SV_ModStart> ) , exception "
279,"<S2SV_StartBug> while ( ( ch = getopt ( ac , av , ""cDdksE:a:t:"" ) ) != - 1 ) { <S2SV_EndBug> <S2SV_StartBug> k_flag ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ac == 0 && ! c_flag && ! s_flag ) { <S2SV_EndBug> <S2SV_StartBug> if ( pledge ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> ""cDdksE:a:P:t:"" <S2SV_ModEnd> <S2SV_ModStart> ; break ; case 'P' : if ( pkcs11_whitelist != NULL ) fatal ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ; pkcs11_whitelist = xstrdup ( optarg ) <S2SV_ModStart> pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; if ( <S2SV_ModStart> ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" <S2SV_ModEnd> "
280,<S2SV_StartBug> int i ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> 
281,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( packet -> payload [ 0 ] == 0x16 && packet -> payload [ 1 ] == 0x80 && packet -> payload [ 4 ] == 0x06 && packet -> payload [ 5 ] == 0x00 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> { if ( ( packet -> payload_packet_len >= 5 ) && <S2SV_ModEnd> <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) 
282,<S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> ,<S2SV_ModStart> ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> 
283,<S2SV_StartBug> path = g_get_tmp_dir ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> g_get_home_dir <S2SV_ModEnd> 
284,<S2SV_StartBug> align = ( 1 << xcs ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! img ) { <S2SV_EndBug> ,"<S2SV_ModStart> w = d_w ; h = d_h ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; if ( ! img ) { img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { uint64_t alloc_size ; <S2SV_ModStart>  <S2SV_ModEnd> "
285,<S2SV_StartBug> INIT_LIST_HEAD ( & f -> f_u . fu_list ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
286,<S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
287,<S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if ( 
288,<S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> ,<S2SV_ModStart> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload <S2SV_ModStart> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload 
289,<S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } 
290,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
291,"<S2SV_StartBug> list_add_tail ( & info -> list , & xen_irq_list_head ) ; <S2SV_EndBug> ",<S2SV_ModStart> INIT_LIST_HEAD ( & info -> eoi_list ) ; 
292,"<S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> rc -> bits_off_target += rc -> av_per_frame_bandwidth - encoded_frame_size ; <S2SV_EndBug> <S2SV_StartBug> rc -> bits_off_target = MIN ( rc -> bits_off_target , oxcf -> maximum_buffer_size ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> is_one_pass_cbr_svc ( cpi ) <S2SV_ModEnd> 
293,"<S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug> ","<S2SV_ModStart> bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> MagickMax ( <S2SV_ModStart> bytes_per_line * sun_info . width ) , <S2SV_ModStart>  <S2SV_ModEnd> "
294,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> skip_metadata ( ps ) ; 
295,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> # if 0 <S2SV_ModStart> # endif 
296,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
297,"<S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> ","<S2SV_ModStart> packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> packet_len ) <S2SV_ModEnd> "
298,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; 
299,"<S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> ","<S2SV_ModStart> = 0 , desc_chunk <S2SV_ModStart> ; desc_chunk = 1 <S2SV_ModStart> desc_chunk || ! "
300,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
301,<S2SV_StartBug> } else { <S2SV_EndBug> ,"<S2SV_ModStart> { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } } "
302,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ca . name [ sizeof ( ca . name ) - 1 ] = 0 ; 
303,<S2SV_StartBug> if ( keyring ) <S2SV_EndBug> ,<S2SV_ModStart> && link_ret == 0 
304,"<S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ; pos -- <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && pos <= ld - size , <S2SV_ModEnd> "
305,<S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> & control -> id ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> & <S2SV_ModEnd> 
306,<S2SV_StartBug> evtchn = info -> evtchn ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VALID_EVTCHN ( evtchn ) ) <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int cpu ; <S2SV_ModStart> || ! list_empty ( & info -> eoi_list ) ) return ; cpu = info -> eoi_cpu ; if ( info -> eoi_time && info -> irq_epoch == per_cpu ( irq_epoch , cpu ) ) { lateeoi_list_add ( info ) ; return ; } info -> eoi_time = 0 <S2SV_ModEnd> "
307,"<S2SV_StartBug> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( void ) ctx ; ( void ) args ; 
308,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
309,<S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ; 
310,"<S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> ",<S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
311,"<S2SV_StartBug> char * buf , * payload ; <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 , result = - 1 ; <S2SV_EndBug> <S2SV_StartBug> int total = 0 ; <S2SV_EndBug> <S2SV_StartBug> } else if ( 0 == ret ) { <S2SV_EndBug> ","<S2SV_ModStart> int result <S2SV_ModEnd> <S2SV_ModStart> ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; rfbLog ( ""%s_enter:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writeTo=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""<S2SV_blank>nReadRaw=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf ) ; switch ( wsctx -> hybiDecodeState ) { case WS_HYBI_STATE_HEADER_PENDING : wsctx -> hybiDecodeState = hybiReadHeader ( cl , & result ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { goto spor ; } if ( wsctx -> hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING ) { wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; } break ; case WS_HYBI_STATE_DATA_AVAILABLE : wsctx -> hybiDecodeState = hybiReturnData ( dst , len , wsctx , & result ) ; break ; case WS_HYBI_STATE_DATA_NEEDED : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; case WS_HYBI_STATE_CLOSE_REASON_PENDING : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>called<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>%d\\n"" , wsctx -> hybiDecodeState ) ; <S2SV_ModEnd> <S2SV_ModStart> errno = EIO ; wsctx -> hybiDecodeState = WS_HYBI_STATE_ERR ; } spor : if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { rfbLog ( ""frame<S2SV_blank>received<S2SV_blank>successfully,<S2SV_blank>cleaning<S2SV_blank>up:<S2SV_blank>read=%d<S2SV_blank>hlen=%d<S2SV_blank>plen=%d\\n"" , wsctx -> header . nRead , wsctx -> header . headerLen , wsctx -> header . payloadLen ) ; hybiDecodeCleanup ( wsctx ) <S2SV_ModEnd> <S2SV_ModStart> wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { hybiDecodeCleanup ( wsctx ) ; } rfbLog ( ""%s_exit:<S2SV_blank>len=%d;<S2SV_blank>"" ""CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>"" ""writePos=%p<S2SV_blank>"" ""state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>"" ""nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>"" ""result=%d\\n"" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf , result ) ; return <S2SV_ModEnd> "
312,<S2SV_StartBug> double motion_pct = next_frame -> pcnt_motion ; <S2SV_EndBug> ,<S2SV_ModStart> ; ( void ) cpi 
313,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
314,<S2SV_StartBug> opt -> optlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> inet_opt ) memcpy ( optbuf , & inet_opt -> opt , sizeof ( struct ip_options ) + inet_opt -> opt . <S2SV_ModEnd> "
315,"<S2SV_StartBug> UINT32 PathLength ; <S2SV_EndBug> <S2SV_StartBug> Stream_Seek ( irp -> input , 28 ) ; <S2SV_EndBug> <S2SV_StartBug> status = ConvertFromUnicode ( CP_UTF8 , 0 , ( WCHAR * ) Stream_Pointer ( irp -> input ) , PathLength / 2 , <S2SV_EndBug> ","<S2SV_ModStart> WCHAR * ptr ; <S2SV_ModStart> if ( ! Stream_SafeSeek <S2SV_ModEnd> <S2SV_ModStart> ) return ERROR_INVALID_DATA ; if ( Stream_GetRemainingLength ( irp -> input ) < 4 ) return ERROR_INVALID_DATA <S2SV_ModStart> ptr = ( WCHAR * ) Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ptr <S2SV_ModEnd> "
316,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
317,<S2SV_StartBug> void * buffer ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL 
318,<S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
319,<S2SV_StartBug> touch_atime ( & path ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! IS_ERR ( raw ) ) 
320,<S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( ""nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n"" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; } "
321,"<S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug> ",<S2SV_ModStart> ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) { if ( <S2SV_ModStart> } 
322,<S2SV_StartBug> e . ifindex = port -> dev -> ifindex ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & e , 0 , sizeof ( e ) ) ; "
323,"<S2SV_StartBug> u_int len , j ; <S2SV_EndBug> ","<S2SV_ModStart> if ( * rdnSeqBuf_offset >= rdnSeqBuf_len ) { # ifdef DEBUG_TLS printf ( ""[TLS]<S2SV_blank>%s()<S2SV_blank>[buffer<S2SV_blank>capacity<S2SV_blank>reached][%u]\\n"" , __FUNCTION__ , rdnSeqBuf_len ) ; # endif return - 1 ; } "
324,<S2SV_StartBug> sec = t % 86400 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( days > 2932896 ) { days = 2932896 ; sec = 86399 ; } 
325,"<S2SV_StartBug> struct rose_sock * rose = rose_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( srose != NULL ) { <S2SV_EndBug> <S2SV_StartBug> memset ( srose , 0 , msg -> msg_namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> <S2SV_ModStart> sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> 
326,"<S2SV_StartBug> if ( ( o + s < o ) || ( o + s < s ) || ( o + s > ds ) || ( o > ds ) ) { <S2SV_EndBug> <S2SV_StartBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , <S2SV_EndBug> ","<S2SV_ModStart> o >= ds <S2SV_ModEnd> <S2SV_ModStart> ""Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)."" , o ) ; return ; } if ( s > ds - o ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Bogus<S2SV_blank>thumbnail<S2SV_blank>size<S2SV_blank>(%u),<S2SV_blank>max<S2SV_blank>would<S2SV_blank>be<S2SV_blank>%u."" , s , ds - o <S2SV_ModEnd> "
327,<S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> || ! SecIsValidHandle ( handle ) 
328,<S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
329,<S2SV_StartBug> if ( len < 20 ) <S2SV_EndBug> ,"<S2SV_ModStart> 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" <S2SV_ModEnd> "
330,<S2SV_StartBug> ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ; <S2SV_EndBug> <S2SV_StartBug> ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModStart> object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> 
331,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
332,<S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModEnd> <S2SV_ModStart> rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; } 
333,"<S2SV_StartBug> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; <S2SV_EndBug> ",<S2SV_ModStart> unlink ( path ) ; <S2SV_ModStart> O_EXCL <S2SV_ModEnd> 
334,"<S2SV_StartBug> krb5_principal client_principal , <S2SV_EndBug> <S2SV_StartBug> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * tgt_realm <S2SV_ModStart> tgt_realm <S2SV_ModEnd> "
335,"<S2SV_StartBug> static void evtchn_fifo_handle_events ( unsigned cpu ) <S2SV_EndBug> <S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> ctrl <S2SV_ModEnd> "
336,<S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
337,<S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> interface = interface ; queueItem -> 
338,"<S2SV_StartBug> static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> <S2SV_StartBug> subsize = * get_sb_partitioning ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> <S2SV_StartBug> encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> , PC_TREE * pc_tree <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart> = bsize <S2SV_ModStart> get_subsize ( bsize , pc_tree -> partitioning <S2SV_ModEnd> <S2SV_ModStart> ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> <S2SV_ModStart> encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> if ( bsize == BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ; } <S2SV_ModEnd> <S2SV_ModStart> 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> "
339,<S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ; 
340,"<S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> { <S2SV_ModStart> } 
341,<S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
342,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! item -> valuestring ) { cJSON_Delete ( item ) ; return 0 ; } } <S2SV_ModEnd> 
343,<S2SV_StartBug> sizeof ( uint16_t ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t 
344,<S2SV_StartBug> return - EEXIST ; <S2SV_EndBug> ,<S2SV_ModStart> 0 <S2SV_ModEnd> 
345,"<S2SV_StartBug> strncpy ( result , ""undefined"" , 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
346,<S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
347,<S2SV_StartBug> out_release_nounlock : <S2SV_EndBug> ,<S2SV_ModStart> if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> 
348,<S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> ,<S2SV_ModStart> rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> 
349,"<S2SV_StartBug> struct range * range ; <S2SV_EndBug> <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> <S2SV_StartBug> content_length += i ; <S2SV_EndBug> <S2SV_StartBug> range ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , ""\\r\\n--%ud--\\r\\n"" , <S2SV_EndBug> <S2SV_StartBug> content_length += i ; <S2SV_EndBug> <S2SV_StartBug> ""byteranges;<S2SV_blank>boundary=%ud"" , boundary ) ; <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> <S2SV_StartBug> goto done ; <S2SV_EndBug> <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> ","<S2SV_ModStart> range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> nranges = parse_ranges ( clt , <S2SV_ModEnd> <S2SV_ModStart> ) ) < 1 <S2SV_ModEnd> <S2SV_ModStart> r -> range_media = media ; <S2SV_ModEnd> <S2SV_ModStart> range = & r -> range [ 0 ] ; <S2SV_ModStart> range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , ""\\r\\n--%llu\\r\\n"" ""Content-Type:<S2SV_blank>%s/%s\\r\\n"" ""Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n"" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> <S2SV_ModStart> ret + <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = snprintf ( NULL , 0 , ""\\r\\n--%llu--\\r\\n"" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> <S2SV_ModStart> ""byteranges;<S2SV_blank>boundary=%llu"" , clt -> clt_boundary <S2SV_ModEnd> <S2SV_ModStart> r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> <S2SV_ModStart> close ( fd ) ; <S2SV_ModStart> clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event"" ; <S2SV_ModEnd> <S2SV_ModStart> } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
350,<S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> io -> io_cleanup = port_cleanup ; 
351,"<S2SV_StartBug> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n"" <S2SV_EndBug> <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n"" <S2SV_ModEnd> <S2SV_ModStart> int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> <S2SV_ModStart> poll_interval <S2SV_ModEnd> "
352,<S2SV_StartBug> exit ( i ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , ""Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n"" , tmp_dir ) ; exit ( 1 ) ; } # endif "
353,"<S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> ",<S2SV_ModStart> tvb_reported_length_remaining <S2SV_ModEnd> 
354,<S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> 1LL <S2SV_ModEnd> 
355,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ plane ] 
356,<S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> return count ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } <S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> 
357,<S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> ,<S2SV_ModStart> pv_time_enabled <S2SV_ModEnd> 
358,"<S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> ) ; mutex_unlock ( & ldata -> output_lock 
359,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
360,<S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
361,"<S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; 
362,"<S2SV_StartBug> static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , <S2SV_EndBug> <S2SV_StartBug> unsigned int var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb , <S2SV_EndBug> ","<S2SV_ModStart> , MACROBLOCK * x <S2SV_ModStart> x -> plane [ 0 ] . src <S2SV_ModEnd> "
363,<S2SV_StartBug> nfca_poll -> nfcid1_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_NFCID1_MAXSIZE ) "
364,"<S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int mb_row = mi_row >> 1 ; <S2SV_EndBug> <S2SV_StartBug> x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> x -> rddiv = cpi -> RDDIV ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult = cpi -> RDMULT ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets ( cm , x <S2SV_ModEnd> <S2SV_ModStart> -> plane <S2SV_ModStart> rd . <S2SV_ModStart> rd . <S2SV_ModStart> get_segment_id <S2SV_ModEnd> <S2SV_ModStart> xd -> tile = * tile ; "
365,<S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if ( "
366,<S2SV_StartBug> ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ; <S2SV_EndBug> ,<S2SV_ModStart> if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) { return IHEVCD_INVALID_PARAMETER ; } 
367,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> 
368,"<S2SV_StartBug> u64 t = ca -> sum_rtt ; <S2SV_EndBug> <S2SV_StartBug> do_div ( t , ca -> cnt_rtt ) ; <S2SV_EndBug> <S2SV_StartBug> info . tcpv_rtt = t ; <S2SV_EndBug> ",<S2SV_ModStart> if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> info . tcpv_rttcnt <S2SV_ModEnd> <S2SV_ModStart> } 
369,<S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
370,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
371,"<S2SV_StartBug> static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! is_compound ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> <S2SV_ModStart> ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else <S2SV_ModStart> == <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> "
372,"<S2SV_StartBug> strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
373,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) { <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , u32 num ) { if ( size > UINT32_MAX / num ) { ALOGE ( ""can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes"" , size , num ) ; android_errorWriteLog ( 0x534e4554 , ""27855419"" ) ; return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> * num "
374,<S2SV_StartBug> hdrlen = sizeof ( * h . h2 ) ; <S2SV_EndBug> ,<S2SV_ModStart> h . h2 -> tp_padding = 0 ; 
375,<S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
376,"<S2SV_StartBug> strcpy ( m , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> , nlen + 1 "
377,"<S2SV_StartBug> nmv_context * fc = & cm -> fc . nmvc ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ; <S2SV_EndBug> ",<S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> vpx_tree_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> <S2SV_ModStart> mode_mv_merge_probs <S2SV_ModEnd> 
378,<S2SV_StartBug> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <S2SV_EndBug> ,<S2SV_ModStart> cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if ( 
379,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> warn ( ""[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\""boundary\\""<S2SV_blank>for<S2SV_blank>\\""multipart/form-data\\""!"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> else <S2SV_ModEnd> <S2SV_ModStart> ""[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data"" ) ; break ; } } if ( lastPart ) { warn ( "
380,<S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug> ,<S2SV_ModStart> if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> 
381,<S2SV_StartBug> variance_node node ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & node , 0 , sizeof ( node ) ) "
382,"<S2SV_StartBug> const vp9_prob * oldp , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> <S2SV_StartBug> vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> <S2SV_StartBug> step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ; <S2SV_EndBug> <S2SV_StartBug> * bestp = bestnewp ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_prob * oldp , vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob upd , int stepsize ) { int <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> if ( * bestp > oldp [ PIVOT_NODE ] ) { step = - stepsize ; for ( newp = * bestp ; newp > <S2SV_ModEnd> <S2SV_ModStart> } else { step = stepsize ; for ( newp = * bestp ; newp < oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } } * bestp = bestnewp <S2SV_ModEnd> "
383,"<S2SV_StartBug> static int target_xcopy_locate_se_dev_e4 ( const unsigned char * dev_wwn , <S2SV_EndBug> <S2SV_StartBug> struct se_device * * found_dev ) <S2SV_EndBug> <S2SV_StartBug> struct xcopy_dev_search_info info ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct se_session * sess , <S2SV_ModStart> _found_dev , struct percpu_ref * * _found_lun_ref <S2SV_ModEnd> <S2SV_ModStart> se_dev_entry * deve ; struct se_node_acl * nacl ; struct se_lun * this_lun = NULL ; struct se_device * found_dev = NULL ; if ( ! sess ) goto err_out ; pr_debug ( ""XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\n"" , XCOPY_NAA_IEEE_REGEX_LEN , dev_wwn ) ; nacl = sess -> se_node_acl ; rcu_read_lock ( ) ; hlist_for_each_entry_rcu ( deve , & nacl -> lun_entry_hlist , link ) { struct se_device * this_dev ; int rc ; this_lun = rcu_dereference ( deve -> se_lun ) ; this_dev = rcu_dereference_raw ( this_lun -> lun_se_dev ) ; rc = target_xcopy_locate_se_dev_e4_iter ( this_dev , dev_wwn ) ; if ( rc ) { if ( percpu_ref_tryget_live ( & this_lun -> lun_ref ) ) found_dev = this_dev ; break ; } } rcu_read_unlock ( ) ; if ( found_dev == NULL ) goto err_out ; pr_debug ( ""lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n"" , found_dev , & found_dev -> dev_group ) ; * _found_dev = found_dev ; * _found_lun_ref = & this_lun -> lun_ref <S2SV_ModEnd> <S2SV_ModStart> err_out : <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
384,<S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( hwname ) ; <S2SV_ModStart> } 
385,<S2SV_StartBug> reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( reasonLen > 1 << 20 ) { rfbClientLog ( ""VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB"" , ( unsigned int ) reasonLen ) ; return ; } <S2SV_ModStart>  <S2SV_ModEnd> "
386,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ; "
387,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 
388,"<S2SV_StartBug> char * dbuf ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return ret ; } return 0 <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
389,<S2SV_StartBug> for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( ch_type == suite && TYPE ( tree ) == funcdef ) { ch_type = func_body_suite ; } 
390,<S2SV_StartBug> bitlen2 = VARBITLEN ( arg2 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) "
391,<S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
392,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc32"" , ""%s"" , ""cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
393,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> 
394,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
395,"<S2SV_StartBug> if ( credit < 0 ) <S2SV_EndBug> <S2SV_StartBug> state = decrease_reservation ( - credit , GFP_BALLOON ) ; <S2SV_EndBug> ","<S2SV_ModStart> { long n_pages ; n_pages = min ( - credit , si_mem_available ( ) ) ; <S2SV_ModStart> n_pages <S2SV_ModEnd> <S2SV_ModStart> if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ; } "
396,<S2SV_StartBug> ps_dec -> u2_disp_height = i4_cropped_ht ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } 
397,"<S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> return try_get_page <S2SV_ModEnd> 
398,<S2SV_StartBug> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , <S2SV_ModEnd> "
399,"<S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> int32_t <S2SV_ModEnd> 
400,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> 
401,<S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
402,<S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
403,"<S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 1 , <S2SV_ModStart> 1 , <S2SV_ModStart> 0 , "
404,"<S2SV_StartBug> const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , <S2SV_EndBug> <S2SV_StartBug> & xd -> block_refs [ ref ] -> sf , width , height , ref , <S2SV_EndBug> <S2SV_StartBug> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_subtract_block ( height , width , <S2SV_EndBug> <S2SV_StartBug> dst , pd -> dst . stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * coeff ; <S2SV_EndBug> <S2SV_StartBug> x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , <S2SV_EndBug> <S2SV_StartBug> vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ; <S2SV_EndBug> <S2SV_StartBug> thissse += ssz ; <S2SV_EndBug> ","<S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> vp9_filter_kernels [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor <S2SV_ModEnd> <S2SV_ModStart> ref , <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> else { vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; } # else vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; # endif } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( height , width , vp9_raster_block_offset_int16 <S2SV_ModEnd> <S2SV_ModStart> dst , pd -> dst . stride , xd -> bd ) ; } else { vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; } # else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset_int16 <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ; } else { <S2SV_ModStart> } # else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; # endif "
405,<S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels 
406,<S2SV_StartBug> const char * old_name ; <S2SV_EndBug> <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> <S2SV_StartBug> fsnotify_oldname_free ( old_name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct name_snapshot <S2SV_ModEnd> <S2SV_ModStart> take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> <S2SV_ModStart> release_dentry_name_snapshot ( & <S2SV_ModEnd> "
407,<S2SV_StartBug> if ( ! offset ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! ht 
408,<S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug> ,<S2SV_ModStart> |= FOLL_COW <S2SV_ModEnd> 
409,"<S2SV_StartBug> sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( op -> buf_asm ) , <S2SV_ModStart> snprintf <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( op -> buf_asm ) <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> "
410,"<S2SV_StartBug> gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; <S2SV_EndBug> <S2SV_StartBug> return GF_OK ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; ptr -> key_info [ 20 ] = 16 ; return GF_NON_COMPLIANT_BITSTREAM ; } <S2SV_ModStart> else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n"" , ( u32 ) iv_size ) ) ; return GF_NON_COMPLIANT_BITSTREAM ; } "
411,<S2SV_StartBug> if ( ret == - EEXIST ) <S2SV_EndBug> ,<S2SV_ModStart> || ret == - EOVERFLOW 
412,<S2SV_StartBug> if ( i4_prev_row != i4_row ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> < <S2SV_ModEnd> <S2SV_ModStart> else if ( i4_prev_row > i4_row ) { android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ; } "
413,"<S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> ",<S2SV_ModStart> hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_get_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> <S2SV_ModStart> spool <S2SV_ModEnd> 
414,"<S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug> ",<S2SV_ModStart> kvm_set_msr <S2SV_ModEnd> 
415,<S2SV_StartBug> uchar * dp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
416,<S2SV_StartBug> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= cctx -> M ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> { if ( len < cctx -> M ) return 0 ; <S2SV_ModStart> } 
417,"<S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> <S2SV_ModStart> } 
418,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
419,<S2SV_StartBug> char * ptr ; <S2SV_EndBug> ,"<S2SV_ModStart> return bad_format_check ( ""^"" SAFE_STRING ""%s"" SAFE_STRING ""%lu"" SAFE_STRING ""%lu"" SAFE_STRING ""$"" , fmt <S2SV_ModEnd> "
420,"<S2SV_StartBug> buf = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> _PyObject_CallNoArg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
421,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
422,"<S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( opt ) ; <S2SV_EndBug> ","<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> "
423,"<S2SV_StartBug> char * curl_env = r_sys_getenv ( ""R2_CURL"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
424,"<S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> } <S2SV_ModStart> if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\n"" , chunksize ) ; return AVERROR_INVALIDDATA ; } "
425,"<S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> ",<S2SV_ModStart> resv_map_put ( vma <S2SV_ModEnd> 
426,"<S2SV_StartBug> int file_is_raw ( struct VpxInputContext * input ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
427,"<S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
428,"<S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) "
429,<S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> || length > mem -> length || iova > <S2SV_ModEnd> <S2SV_ModStart> - length ) return - EFAULT ; return <S2SV_ModEnd> 
430,<S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
431,"<S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> const VP9_COMMON * const <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> 
432,"<S2SV_StartBug> memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ; <S2SV_EndBug> <S2SV_StartBug> number_of_sections = num ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_global_options , 0 <S2SV_ModStart> memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ; "
433,"<S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
434,<S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> ,<S2SV_ModStart> d_flags |= DCACHE_RCUACCESS ; dentry -> 
435,"<S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> ",<S2SV_ModStart> = NULL ; LPSTR tmp2 <S2SV_ModStart> { tmp2 <S2SV_ModEnd> <S2SV_ModStart> if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> tmp2 <S2SV_ModEnd> <S2SV_ModStart> ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if ( 
436,<S2SV_StartBug> uint8_t verify_crls = cred -> x509Credential . x509CrlVerifyMode ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> verify_crls = cred -> x509Credential . x509CrlVerifyMode ; 
437,"<S2SV_StartBug> char * pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"" ; <S2SV_EndBug> ","<S2SV_ModStart> ""/lxc/lock/var/lib/lxc/"" <S2SV_ModEnd> "
438,"<S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> - s 
439,<S2SV_StartBug> if ( err < 0 ) <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( partdata ) ; <S2SV_ModStart> } 
440,<S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> ,<S2SV_ModStart> chunk -> pdiscard ) ) return 0 ; if ( unlikely ( 
441,"<S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> ","<S2SV_ModStart> strbuf_addstr ( base , name ) ; <S2SV_ModStart> -> buf , cb_data <S2SV_ModEnd> "
442,<S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
443,<S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; } "
444,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK ( opt -> rpl_dio_len ) ; <S2SV_ModStart> ""%s"" , rpl_tstr <S2SV_ModEnd> "
445,<S2SV_StartBug> done : <S2SV_EndBug> <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> done : 
446,<S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ; 
447,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) buffer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
448,"<S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> <S2SV_StartBug> new_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> "
449,"<S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug> ","<S2SV_ModStart> int sk_locked ; <S2SV_ModStart> sk_locked = 0 ; <S2SV_ModStart> restart_locked : <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) <S2SV_ModStart> if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> <S2SV_ModStart> sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> <S2SV_ModStart> sk_locked = 1 ; <S2SV_ModStart> if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( sk_locked ) unix_state_unlock ( sk ) ; "
450,<S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
451,<S2SV_StartBug> load_xid_epoch ( & state ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; StaticAssertStmt ( MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP , ""possible<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>txid_current_snapshot()"" "
452,"<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> ",<S2SV_ModStart> int hdrincl ; <S2SV_ModStart> ; hdrincl = inet -> hdrincl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
453,<S2SV_StartBug> case IO_DISCONNECTED : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
454,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
455,<S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> ,<S2SV_ModStart> fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ; 
456,<S2SV_StartBug> if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( i < npages ) { <S2SV_EndBug> ,<S2SV_ModStart> && ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModStart> ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModEnd> 
457,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> die ( ""Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode"" , regs , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> <S2SV_ModStart> & info , 0 <S2SV_ModEnd> "
458,<S2SV_StartBug> status = sBtInterface -> enable ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> false 
459,"<S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> netdissect_options * ndo , <S2SV_ModStart> if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; } "
460,<S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> { dst = skb_dst ( skb ) ; <S2SV_ModStart> dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> 
461,"<S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> <S2SV_ModStart> ( UINT64 ) <S2SV_ModStart> ; if ( offset <S2SV_ModEnd> 
462,"<S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , ""w"" ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
463,"<S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned char * type <S2SV_ModStart> , const void * raw , size_t raw_len <S2SV_ModStart> if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> raw <S2SV_ModEnd> <S2SV_ModStart> ; * type = attr -> attrib_type <S2SV_ModStart> if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; } "
464,<S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
465,"<S2SV_StartBug> strlcpy ( comp1_str , comp1 -> data , comp1 -> length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST || <S2SV_EndBug> <S2SV_StartBug> strlcpy ( temp_buf , comp2 -> data , comp2 -> length + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != NULL ) memcpy ( comp1_str , comp1 -> data , comp1 -> length ) ; if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST || krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_INST || ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_UNKNOWN && kdc_active_realm -> realm_host_based_services != NULL && ( krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , comp1_str ) == TRUE || krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , KRB5_CONF_ASTERISK ) == TRUE ) ) ) && ( kdc_active_realm -> realm_no_host_referral == NULL || ( krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , KRB5_CONF_ASTERISK ) == FALSE && krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , comp1_str ) == FALSE ) ) ) { if ( memchr ( comp2 -> data , '.' , comp2 -> length ) == NULL ) goto cleanup ; temp_buf = calloc ( 1 , comp2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( comp2 -> data != NULL ) memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
466,"<S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> ",<S2SV_ModStart> if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> if ( pixel . blue <= GetQuantumRange ( depth ) ) 
467,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> CDF_SHORT_SEC_SIZE <S2SV_ModEnd> <S2SV_ModStart> CDF_SEC_SIZE ( h ) <S2SV_ModEnd> <S2SV_ModStart> CDF_SEC_SIZE ( h ) <S2SV_ModEnd> 
468,<S2SV_StartBug> ( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( stco -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> ) return GF_ISOM_INVALID_FILE ; if ( co64 -> nb_entries < sampleNumber 
469,"<S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL 
470,"<S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
471,"<S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>map<S2SV_blank>offset.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> > rsrc . rsrc_len ) { psf_log_printf ( psf , ""Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n"" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 "
472,"<S2SV_StartBug> int start = 0 ; <S2SV_EndBug> <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; int i <S2SV_ModStart> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> 
473,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE "
474,<S2SV_StartBug> if ( ( s -> options & SSL_OP_EPHEMERAL_RSA ) <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> tmp . use_rsa_tmp = 1 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 ; if ( <S2SV_ModEnd> 
475,"<S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
476,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
477,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; } 
478,<S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> ,<S2SV_ModStart> * prev = vma ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
479,<S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
480,"<S2SV_StartBug> uint8_t i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Sel:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u"" <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
481,<S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> numrows < 0 || numcols < 0 ) { return 0 ; } if ( 
482,"<S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( buffer ) "
483,<S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> ,<S2SV_ModStart> case L2CAP_MODE_STREAMING : 
484,<S2SV_StartBug> if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) { <S2SV_EndBug> <S2SV_StartBug> pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ; <S2SV_EndBug> ,"<S2SV_ModStart> assert ( pDup == 0 || ! ExprHasProperty ( pDup , EP_MemToken ) ) ; <S2SV_ModStart> ; pDup -> u . zToken = 0 "
485,<S2SV_StartBug> return self ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ; "
486,<S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( desc == NULL ) desc = """" ; "
487,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , tstr <S2SV_ModEnd> "
488,"<S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> <S2SV_ModStart> return ; <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> <S2SV_ModStart> stripbytes ? offset : 0 <S2SV_ModEnd> <S2SV_ModStart> nstrips <S2SV_ModEnd> "
489,<S2SV_StartBug> static ssize_t aio_setup_single_vector ( struct kiocb * kiocb ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ; <S2SV_EndBug> ,"<S2SV_ModStart> int type , struct file * file , <S2SV_ModStart> int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> bytes <S2SV_ModEnd> "
490,<S2SV_StartBug> switch ( c = ( * dis_getc ) ( stream ) ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; } "
491,"<S2SV_StartBug> if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
492,"<S2SV_StartBug> static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> const VP9_COMMON * const cm , const MACROBLOCKD * const <S2SV_ModEnd> <S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_prob * const probs = xd -> partition_probs [ ctx ] <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> "
493,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ; i >= 0 ; i -- ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_free ( ctx ) ; <S2SV_ModEnd> 
494,<S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ,<S2SV_ModStart> static 
495,"<S2SV_StartBug> USB_DT_SECURITY , ( void * * ) & secd ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( * secd ) "
496,"<S2SV_StartBug> vpx_memcpy ( udp , up , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
497,<S2SV_StartBug> regs [ value_regno ] . var_off = <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size ( & <S2SV_ModStart> , size <S2SV_ModEnd> "
498,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> parse_netscreen_packet <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , line "
499,"<S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> ","<S2SV_ModStart> int len <S2SV_ModEnd> <S2SV_ModStart> ( hdr -> filename = fn ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( len = <S2SV_ModStart> ) < 2 <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) if ( ! ( * fn ++ <S2SV_ModEnd> <S2SV_ModStart> if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> <S2SV_ModStart> - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> <S2SV_ModStart> ; fn -- <S2SV_ModStart> ( len = <S2SV_ModStart> ) < 2 <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) if ( ! ( * fn ++ <S2SV_ModEnd> <S2SV_ModStart> if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> <S2SV_ModStart> - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> <S2SV_ModStart> ; fn -- "
500,<S2SV_StartBug> size_t * buf_size_out ) <S2SV_EndBug> <S2SV_StartBug> if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out ) <S2SV_EndBug> <S2SV_StartBug> * buf_size_out = buf_size ; <S2SV_EndBug> <S2SV_StartBug> buf = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> , size_t * data_size_out <S2SV_ModStart> data_size_out ) * data_size_out = 0 ; if ( <S2SV_ModStart> || ! data_size_out <S2SV_ModStart> ; * data_size_out = data_size <S2SV_ModStart> * data_size_out = data_size ; "
501,"<S2SV_StartBug> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n"" ) ; return - 1 ; } if ( "
502,"<S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> <S2SV_StartBug> out_drop_write : <S2SV_EndBug> ","<S2SV_ModStart> error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> "
503,"<S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> <S2SV_StartBug> data + offset , <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> offset , data_size - "
504,"<S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ; 
505,"<S2SV_StartBug> SEPARATE_ZVAL ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double ( * var2 ) ; <S2SV_EndBug> <S2SV_StartBug> matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( Z_TYPE_PP <S2SV_ModEnd> <S2SV_ModStart> != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) <S2SV_ModStart> & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( <S2SV_ModEnd> <S2SV_ModStart> } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , <S2SV_ModEnd> <S2SV_ModStart> div , ( float ) offset ) ; if ( res ) { RETURN_TRUE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
506,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
507,"<S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type != KEY_FRAME ) <S2SV_EndBug> <S2SV_StartBug> cpi -> cyclic_refresh_mode_index = i ; <S2SV_EndBug> ",<S2SV_ModStart> if ( cpi -> oxcf . screen_content_mode ) { int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ; if ( Q >= qp_thresh ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ; } else { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; } memset <S2SV_ModEnd> <S2SV_ModStart> && block_count > 0 <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) { cpi -> cyclic_refresh_q = Q ; lf_adjustment = - 40 ; for ( i = 0 ; i < mbs_in_frame ; ++ i ) { seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ; } } } # endif 
508,<S2SV_StartBug> struct serial_icounter_struct icount ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
509,"<S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
510,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( check_secure ( ) ) return ; 
511,<S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; } "
512,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_FOWNER ) ) <S2SV_EndBug> ","<S2SV_ModStart> struct user_namespace * ns ; <S2SV_ModStart> ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> "
513,<S2SV_StartBug> filename [ filename_size ++ ] = '\\0' ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
514,<S2SV_StartBug> goto error ; <S2SV_EndBug> ,<S2SV_ModStart> usb_free_urb ( urb ) ; 
515,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
516,"<S2SV_StartBug> OPJ_UINT32 * p_data_written , <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOT , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , OPJ_UINT32 <S2SV_ModStart> if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } "
517,"<S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
518,<S2SV_StartBug> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && <S2SV_EndBug> ,<S2SV_ModStart> SSL_WRITE_ETM <S2SV_ModEnd> 
519,"<S2SV_StartBug> const u_char * p , const u_char * ep , <S2SV_EndBug> <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""value="" ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> } if ( ep2 <S2SV_ModEnd> <S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( & p [ 2 ] <S2SV_ModStart> { if ( ! <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } } <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) { <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> trunc : return NULL ; "
520,<S2SV_StartBug> u32 offset ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
521,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( ! i ) return NULL ; 
522,<S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug> ,<S2SV_ModStart> bpp == 1 && <S2SV_ModStart> bpp == 8 && 
523,"<S2SV_StartBug> void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd , <S2SV_EndBug> ","<S2SV_ModStart> YV12_BUFFER_CONFIG * frame , <S2SV_ModStart> frame <S2SV_ModEnd> <S2SV_ModStart> -> plane "
524,<S2SV_StartBug> queueItem -> srcPort = ntohs ( header -> srcPort ) ; <S2SV_EndBug> ,<S2SV_ModStart> interface = interface ; queueItem -> 
525,"<S2SV_StartBug> server . vm_enabled = 0 ; <S2SV_EndBug> <S2SV_StartBug> server . vm_swap_file = zstrdup ( ""/tmp/redis-%p.vm"" ) ; <S2SV_EndBug> <S2SV_StartBug> server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ; <S2SV_EndBug> ","<S2SV_ModStart> ds_enabled = 0 ; server . ds_path <S2SV_ModEnd> <S2SV_ModStart> ""/tmp/redis.ds"" ) ; server . cache_max_memory = 64LL <S2SV_ModEnd> <S2SV_ModStart> ; server . cache_blocked_clients <S2SV_ModEnd> "
526,<S2SV_StartBug> int this_rd ; <S2SV_EndBug> <S2SV_StartBug> if ( this_mode == ZEROMV ) <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> ref_frame_flags & VP8_LAST_FRAME & <S2SV_EndBug> ,<S2SV_ModStart> ; int denoise_aggressive = 0 <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { denoise_aggressive = ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive ) ? 1 : 0 ; } # endif if ( ! cpi -> oxcf . screen_content_mode && <S2SV_ModEnd> <S2SV_ModStart> && x -> e_mbd . mode_info_context -> mbmi . ref_frame == LAST_FRAME && ( denoise_aggressive || ( cpi -> closest_reference_frame == LAST_FRAME ) ) <S2SV_ModStart> x -> is_skin <S2SV_ModEnd> 
527,<S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> <S2SV_StartBug> rx = adis -> buffer ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> } 
528,"<S2SV_StartBug> static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) <S2SV_EndBug> <S2SV_StartBug> assign_eip_near ( ctxt , ctxt -> _eip + rel ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
529,<S2SV_StartBug> option_number += option_ext ; <S2SV_EndBug> <S2SV_StartBug> option_number += 269 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> "
530,"<S2SV_StartBug> if ( io -> status ) { <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> || io -> count == 0 <S2SV_ModStart> io -> count ++ ; <S2SV_ModStart> spin_lock_irqsave ( & io -> lock , flags ) ; io -> count -- ; if ( ! io -> count ) complete ( & io -> complete ) ; spin_unlock_irqrestore ( & io -> lock , flags ) ; "
531,"<S2SV_StartBug> else if ( n <= 15 && ! strchr ( name , '.' ) && type == HOST_TYPE_IPV4 ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! strchr ( name , '.' ) ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
532,"<S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( hlen < 0 ) { err = hlen ; goto fail ; } 
533,"<S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ; msg -> msg_namelen = 0 <S2SV_ModStart> msg -> msg_namelen = sizeof ( * sin ) ; 
534,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> 
535,<S2SV_StartBug> void fadst8_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) 
536,"<S2SV_StartBug> int rc ; <S2SV_EndBug> <S2SV_StartBug> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <S2SV_EndBug> <S2SV_StartBug> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; <S2SV_EndBug> ","<S2SV_ModStart> uid_t check_ruid ; <S2SV_ModStart> , & check_ruid <S2SV_ModStart> if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; } "
537,"<S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> ",<S2SV_ModStart> kvm_get_kvm ( kvm ) ; <S2SV_ModStart> kvm_put_kvm ( kvm ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
538,<S2SV_StartBug> int is_entity ; <S2SV_EndBug> <S2SV_StartBug> if ( obj -> fixedtype == DWG_TYPE_TABLE ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> else if ( obj -> fixedtype == DWG_TYPE_DATATABLE ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> unhandled : <S2SV_ModEnd> <S2SV_ModStart> DWG_TYPE_UNKNOWN_ENT ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> DWG_TYPE_UNKNOWN_OBJ ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
539,<S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = irq ; <S2SV_EndBug> ,"<S2SV_ModStart> WRITE_ONCE ( <S2SV_ModStart> , irq ) <S2SV_ModEnd> "
540,"<S2SV_StartBug> inl = i2d ( data , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; } "
541,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
542,<S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> cursor <S2SV_ModEnd> 
543,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock 
544,<S2SV_StartBug> goto present_leaves_cluster_but_not_new_leaf ; <S2SV_EndBug> <S2SV_StartBug> present_leaves_cluster_but_not_new_leaf : <S2SV_EndBug> ,"<S2SV_ModStart> pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
545,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; msg -> msg_namelen = 0 
546,"<S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug> ",<S2SV_ModStart> user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED 
547,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> INTL_CHECK_LOCALE_LEN ( slocale_len ) ; 
548,<S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; } 
549,<S2SV_StartBug> if ( client -> priv -> protocol_timeout > 0 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
550,<S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
551,"<S2SV_StartBug> void sum_2_variances ( const var * a , const var * b , var * r ) { <S2SV_EndBug> <S2SV_StartBug> a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ; <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> assert ( a -> log2_count == b -> log2_count ) ; <S2SV_ModStart> log2_count + 1 <S2SV_ModEnd> 
552,<S2SV_StartBug> goto next_desc ; <S2SV_EndBug> ,"<S2SV_ModStart> ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n"" ) ; break "
553,<S2SV_StartBug> DevInfo . MaxRDMBufferSize = BUFFER_4K ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ; "
554,"<S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( <S2SV_ModEnd> <S2SV_ModStart> <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart>  <S2SV_ModEnd> "
555,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char fpath [ grub_strlen ( currpath ) + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> * currfound = currnode ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( grub_errno ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_SYMLINK_LOOP , <S2SV_EndBug> <S2SV_StartBug> free_node ( oldnode , c ) ; <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * fpath = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; free ( fpath ) <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> { free ( fpath ) ; <S2SV_ModStart> } <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> ) ; free ( fpath <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> free ( fpath ) ; "
556,"<S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; } 
557,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> match_data -> cmp = asymmetric_key_cmp ; 
558,"<S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> ","<S2SV_ModStart> aio_setup_single_vector ( READ , file , <S2SV_ModEnd> <S2SV_ModStart> aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
559,<S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = safe_calloc ( <S2SV_ModEnd> <S2SV_ModStart> long 
560,<S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
561,<S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
562,<S2SV_StartBug> for ( pass = 0 ; pass < 10 ; pass ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> || image 
563,<S2SV_StartBug> int64_t old_off = s -> off ; <S2SV_EndBug> <S2SV_StartBug> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <S2SV_EndBug> ,<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
564,<S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
565,"<S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> BIO_printf <S2SV_ModEnd> <S2SV_ModStart> ""%s\\n"" , obj_txt <S2SV_ModEnd> "
566,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
567,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <S2SV_EndBug> <S2SV_StartBug> perf_event_for_each_child ( event , perf_event_disable ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx ; <S2SV_ModStart> { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> _perf_event_disable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> "
568,<S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
569,<S2SV_StartBug> return code ; <S2SV_EndBug> ,"<S2SV_ModStart> { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> "
570,"<S2SV_StartBug> arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , <S2SV_ModStart> type_comment = type_comment ; p -> "
571,"<S2SV_StartBug> int hdrlen ; <S2SV_EndBug> <S2SV_StartBug> if ( caplen < 3 ) { <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 10 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 14 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> case 0x00 : <S2SV_EndBug> <S2SV_StartBug> case 0x01 : <S2SV_EndBug> <S2SV_StartBug> case 0x02 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> caplen -= hdrlen ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> + 2 <S2SV_ModStart> caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> if ( ndo -> ndo_vflag ) <S2SV_ModStart> FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> <S2SV_ModStart> FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> <S2SV_ModStart> FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> <S2SV_ModStart> caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> <S2SV_ModStart> caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hdrlen <S2SV_ModEnd> "
572,"<S2SV_StartBug> l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
573,"<S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
574,"<S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
575,<S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> ,"<S2SV_ModStart> 0 , 0 , "
576,<S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug> ,<S2SV_ModStart> ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS 
577,<S2SV_StartBug> then = now ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! cfg -> rc_target_bitrate ) return ; 
578,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } if ( free < 0 ) { err = - ENOMEM ; goto out ; 
579,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
580,<S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> ,<S2SV_ModStart> 0660 <S2SV_ModEnd> 
581,"<S2SV_StartBug> strncpy ( str , ""?["" , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> espruino_snprintf ( str , len , ""?[%d]"" , token <S2SV_ModEnd> "
582,"<S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> minfo . flags = 0 ; 
583,<S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( srose , 0 , msg -> msg_namelen ) ; "
584,"<S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
585,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
586,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
587,"<S2SV_StartBug> static double get_prediction_decay_rate ( const VP9_COMMON * cm , <S2SV_EndBug> <S2SV_StartBug> const double mb_sr_err_diff = ( next_frame -> sr_coded_error - <S2SV_EndBug> <S2SV_StartBug> const double second_ref_decay = mb_sr_err_diff <= 512.0 <S2SV_EndBug> <S2SV_StartBug> ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMP * cpi <S2SV_ModEnd> <S2SV_ModStart> sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) <S2SV_ModEnd> <S2SV_ModStart> zero_motion_factor = ( 0.95 * pow ( ( next_frame -> pcnt_inter - next_frame -> pcnt_motion ) , ZM_POWER_FACTOR ) ) ; return MAX ( zero_motion_factor , ( sr_decay_rate + ( <S2SV_ModEnd> <S2SV_ModStart> sr_decay_rate ) * zero_motion_factor ) ) <S2SV_ModEnd> "
588,"<S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> ",<S2SV_ModStart> [ 0 ] 
589,"<S2SV_StartBug> vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) , <S2SV_EndBug> <S2SV_StartBug> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ; # endif <S2SV_ModStart> codec_interface <S2SV_ModEnd> <S2SV_ModStart> codec_interface <S2SV_ModEnd> 
590,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
591,<S2SV_StartBug> * head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ; return GIT_ERROR <S2SV_ModEnd> "
592,"<S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
593,"<S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset "
594,"<S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> <S2SV_ModStart> ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> "
595,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( void ) _y4m ; ( void ) _dst ; ( void ) _aux ; 
596,"<S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( EXT2_SB ( inode -> i_sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
597,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
598,<S2SV_StartBug> int m ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; } "
599,<S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> ,<S2SV_ModStart> req ) ; kfree ( 
600,"<S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 <S2SV_ModStart> - 1 <S2SV_ModStart>  <S2SV_ModEnd> 
601,"
","
"
602,"<S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0U ; i < ( maxh & ~ ( unsigned int ) 1U ) ; i += 2U ) <S2SV_EndBug> <S2SV_StartBug> ny = y + maxw ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> if ( j < maxw ) <S2SV_EndBug> <S2SV_StartBug> if ( i < maxh ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> <S2SV_ModStart> size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d2 = b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> loopmaxh <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t j ; <S2SV_ModStart> if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> loopmaxh ) { size_t j ; <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> <S2SV_ModStart> dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> <S2SV_ModStart> dy = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
603,<S2SV_StartBug> if ( * p == '#' ) { <S2SV_EndBug> ,"<S2SV_ModStart> len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ; "
604,<S2SV_StartBug> print_bpf_insn ( insn ) ; <S2SV_EndBug> ,"<S2SV_ModStart> env , "
605,"<S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> file -> f_cred -> fsuid <S2SV_ModEnd> <S2SV_ModStart> file -> f_cred -> fsgid <S2SV_ModEnd> 
606,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> 
607,"<S2SV_StartBug> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; } "
608,<S2SV_StartBug> if ( cpi -> pass == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) <S2SV_EndBug> <S2SV_StartBug> if ( q == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> oxcf . <S2SV_ModStart> rc_mode == VPX_CBR <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
609,<S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - packet -> size 
610,"<S2SV_StartBug> while ( * s && * s != \'\\""\' ) <S2SV_EndBug> <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) 
611,"
","
"
612,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
613,<S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> ,<S2SV_ModStart> tlsext_use_etm = 0 <S2SV_ModEnd> <S2SV_ModStart> tlsext_use_etm = 1 <S2SV_ModEnd> 
614,<S2SV_StartBug> int cpu = smp_processor_id ( ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ) ; read_lock ( & evtchn_rwlock <S2SV_ModStart> read_unlock ( & evtchn_rwlock ) ; 
615,"<S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> "
616,<S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug> ,"<S2SV_ModStart> iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> "
617,<S2SV_StartBug> const struct aodv_hello * ah ; <S2SV_EndBug> <S2SV_StartBug> goto trunc ; <S2SV_EndBug> ,"<S2SV_ModStart> ; ND_TCHECK ( * ep ) <S2SV_ModStart> if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , ""\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u"" , ep -> length ) ) ; break ; } "
618,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && frame -> linesize [ plane ] 
619,"<S2SV_StartBug> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { <S2SV_EndBug> <S2SV_StartBug> exit ( EXIT_FAILURE ) ; <S2SV_EndBug> ","<S2SV_ModStart> daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart>  <S2SV_ModEnd> "
620,<S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
621,<S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ,<S2SV_ModStart> if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ; 
622,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
623,"<S2SV_StartBug> if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { <S2SV_EndBug> ","<S2SV_ModStart> CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return - EINVAL ; } } if ( "
624,"<S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> ",<S2SV_ModStart> dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> 
625,"<S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; "
626,<S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
627,<S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! rs -> rs_transport 
628,"<S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> "
629,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
630,"<S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> ",<S2SV_ModStart> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
631,"<S2SV_StartBug> sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> before ) { if ( newspan && <S2SV_ModStart> } 
632,<S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> ,<S2SV_ModStart> = 0 ; int reload_count <S2SV_ModStart> reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ; 
633,<S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; spin_lock_init ( & sta -> ps_lock 
634,<S2SV_StartBug> out_size = in_len + 32 ; <S2SV_EndBug> ,<S2SV_ModStart> int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ; out_size = 10 + 8 + max_input_expansion + in_len <S2SV_ModEnd> 
635,<S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> <S2SV_ModStart> get_tga_ushort <S2SV_ModEnd> 
636,"<S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ","<S2SV_ModStart> count = <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" <S2SV_ModStart> if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
637,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
638,<S2SV_StartBug> if ( retval ) <S2SV_EndBug> ,<S2SV_ModStart> ! retval ) <S2SV_ModEnd> 
639,"<S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
640,"<S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> th -> fin ) goto discard ; if ( 
641,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> ","<S2SV_ModStart> ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } <S2SV_ModStart> ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } "
642,"<S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
643,<S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> ,<S2SV_ModStart> pv_time_enabled <S2SV_ModEnd> 
644,<S2SV_StartBug> default : <S2SV_EndBug> ,<S2SV_ModStart> case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ; 
645,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> ","<S2SV_ModStart> cpl , true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> "
646,"<S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> raw = bpf_prog_inc ( raw <S2SV_ModEnd> <S2SV_ModStart> raw = 
647,"<S2SV_StartBug> signed long personality ; <S2SV_EndBug> <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> ","<S2SV_ModStart> int procfd ; <S2SV_ModStart> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> , . procfd = procfd "
648,"<S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> m -> msg_namelen = 0 ; 
649,<S2SV_StartBug> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <S2SV_EndBug> ,<S2SV_ModStart> 31 <S2SV_ModEnd> 
650,"<S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> >> PAGE_SHIFT <S2SV_ModStart> >> PAGE_SHIFT 
651,<S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr 
652,<S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ; bool checksum_valid = false <S2SV_ModStart> checksum_valid = ! <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! checksum_valid <S2SV_ModStart> checksum_valid || 
653,<S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; } "
654,"<S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug> ",<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
655,<S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
656,<S2SV_StartBug> TfLiteIntArray * ret = <S2SV_EndBug> <S2SV_StartBug> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <S2SV_ModStart> alloc_size ) ; if ( ! ret ) return ret <S2SV_ModEnd> 
657,"<S2SV_StartBug> struct gs_host_config hconf = { <S2SV_EndBug> <S2SV_StartBug> struct gs_device_config dconf ; <S2SV_EndBug> <S2SV_StartBug> & hconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( hconf ) , <S2SV_EndBug> <S2SV_StartBug> if ( rc < 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> & dconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( dconf ) , <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! dev ) <S2SV_EndBug> <S2SV_StartBug> init_usb_anchor ( & dev -> rx_submitted ) ; <S2SV_EndBug> <S2SV_StartBug> dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> * hconf <S2SV_ModEnd> <S2SV_ModStart> * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModStart> kfree ( hconf ) ; <S2SV_ModStart> dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModStart> kfree ( dconf ) ; return rc ; } icount = dconf -> <S2SV_ModEnd> <S2SV_ModStart> kfree ( dconf ) ; <S2SV_ModStart> { kfree ( dconf ) ; <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dconf ) ; kfree ( <S2SV_ModStart> kfree ( dconf ) ; "
658,<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> p += 3 ; <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 2 ) return - 1 ; <S2SV_ModStart> if ( len < 3 ) return - 1 ; <S2SV_ModStart> if ( len < 4 ) return - 1 ; <S2SV_ModStart> if ( len < 2 ) return - 1 ; 
659,"<S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> ","<S2SV_ModStart> res = utee_param_to_param ( utc , <S2SV_ModEnd> <S2SV_ModStart> ; if ( res != TEE_SUCCESS ) return res "
660,<S2SV_StartBug> if ( image -> storage_class == PseudoClass ) <S2SV_EndBug> ,"<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
661,<S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break 
662,<S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
663,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> * objp = NULL ; 
664,<S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> { dst = skb_dst ( skb ) ; <S2SV_ModStart> dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> 
665,"<S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> ","<S2SV_ModStart> , const char * rootfs <S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , rootfs <S2SV_ModStart> < 0 "
666,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
667,"<S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> <S2SV_StartBug> base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModEnd> <S2SV_ModStart> ""/tmp"" ; <S2SV_ModEnd> "
668,"<S2SV_StartBug> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct4x4_c ( input , output , stride ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> outptr [ j * 4 + i ] = temp_out [ j ] ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct4x4_c <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> 
669,"<S2SV_StartBug> static const char * parse_array ( cJSON * item , const char * value ) <S2SV_EndBug> <S2SV_StartBug> ep = value ; <S2SV_EndBug> <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * * ep <S2SV_ModStart> * ep = value ; return 0 ; <S2SV_ModEnd> <S2SV_ModStart> return value + 1 ; <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> child = new_item ; <S2SV_ModEnd> <S2SV_ModStart> , ep ) ) ; if ( ! value ) <S2SV_ModEnd> <S2SV_ModStart> return value + 1 ; * ep = value ; <S2SV_ModEnd> "
670,"<S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> <S2SV_ModStart> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> <S2SV_ModStart> ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE "
671,"<S2SV_StartBug> const char * args [ 11 ] ; <S2SV_EndBug> <S2SV_StartBug> args [ i ++ ] = ""--"" ; <S2SV_EndBug> <S2SV_StartBug> execvp ( EXECUTABLE , ( char * * ) args ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ; log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> <S2SV_ModStart> ""--tmpdir"" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <S2SV_ModStart> pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ; if ( pid == 0 ) { <S2SV_ModStart> int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ; error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ; } "
672,<S2SV_StartBug> kern_msg -> msg_name = kern_address ; <S2SV_EndBug> ,<S2SV_ModStart> if ( kern_msg -> msg_name ) 
673,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> id_key_set = rb_intern_const ( ""key_set"" ) ; "
674,"<S2SV_StartBug> if ( strchr ( page , '/' ) ) <S2SV_EndBug> ",<S2SV_ModStart> ! page_name_is_good ( page <S2SV_ModEnd> 
675,"<S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ","<S2SV_ModStart> , table_length = 0 <S2SV_ModStart> ; CS64Chunk cs64_chunk <S2SV_ModStart> total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> <S2SV_ModStart> + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> ; ds64_chunk . tableLength = table_length <S2SV_ModStart> if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> "
676,<S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ; "
677,"<S2SV_StartBug> cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) { cli_dbgmsg ( ""WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\n"" ) ; return CL_EFORMAT ; } "
678,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || shdr -> sh_size > SIZE_MAX 
679,"<S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <S2SV_EndBug> <S2SV_StartBug> ECDSA_SIG_free ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> p <S2SV_ModEnd> <S2SV_ModStart> goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } "
680,<S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> encap_mark <S2SV_ModEnd> 
681,"
","
"
682,"<S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <S2SV_EndBug> <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> <S2SV_StartBug> le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry <S2SV_ModEnd> <S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> "
683,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
684,<S2SV_StartBug> static void oidc_scrub_headers ( request_rec * r ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
685,"<S2SV_StartBug> readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( self -> packetSize <= bufPos ) goto exit_error ; 
686,<S2SV_StartBug> size_t e ; <S2SV_EndBug> <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ; mrb_value nil <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ; 
687,"<S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_negative ( key <S2SV_ModEnd> 
688,<S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> ,<S2SV_ModStart> { pc -> index = 0 ; <S2SV_ModStart> } <S2SV_ModStart> { pc -> overread_index = pc -> index = 0 ; <S2SV_ModStart> } 
689,"<S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> <S2SV_StartBug> return - 2 ; <S2SV_EndBug> <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> ",<S2SV_ModStart> cdf_directory_t * root_storage <S2SV_ModEnd> <S2SV_ModStart> if ( root_storage ) { <S2SV_ModStart> root_storage -> d_storage_uuid <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> root_storage <S2SV_ModEnd> 
690,<S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> ,<S2SV_ModStart> if ( reg_index < 2 ) { <S2SV_ModStart> } <S2SV_ModStart> if ( reg_index < 2 ) { <S2SV_ModStart> } 
691,"<S2SV_StartBug> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <S2SV_EndBug> <S2SV_StartBug> & pdev -> dev , gpio_dev ) ; <S2SV_EndBug> <S2SV_StartBug> goto out1 ; <S2SV_EndBug> <S2SV_StartBug> out1 : <S2SV_EndBug> ","<S2SV_ModStart> devm_pinctrl_register ( & pdev -> dev , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return ret <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
692,"<S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE ) "
693,<S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ; bool checksum_valid = false <S2SV_ModStart> checksum_valid = ! <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! checksum_valid <S2SV_ModStart> checksum_valid || 
694,"<S2SV_StartBug> int ret , last_pwd ; <S2SV_EndBug> <S2SV_StartBug> ret = decrypt_key_data ( handle -> context , <S2SV_EndBug> <S2SV_StartBug> kdb -> n_key_data , kdb -> key_data , <S2SV_EndBug> ","<S2SV_ModStart> , n_new_keys <S2SV_ModStart> n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <S2SV_ModStart> n_new_keys <S2SV_ModEnd> "
695,"<S2SV_StartBug> int isopen ; <S2SV_EndBug> <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> ","<S2SV_ModStart> base_size ; int <S2SV_ModStart> base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> base_size ; if ( base_size / npts != <S2SV_ModStart> || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> "
696,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
697,<S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
698,"<S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> - s 
699,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModStart> . <S2SV_ModEnd> "
700,<S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
701,<S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> 
702,"<S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> ",<S2SV_ModStart> u16 <S2SV_ModEnd> <S2SV_ModStart> kstrtou16 <S2SV_ModEnd> <S2SV_ModStart> >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> 
703,"<S2SV_StartBug> void headerMergeLegacySigs ( Header h , Header sigh ) <S2SV_EndBug> <S2SV_StartBug> hi = headerInitIterator ( sigh ) ; <S2SV_EndBug> <S2SV_StartBug> td . tag = RPMTAG_SIGSIZE ; <S2SV_EndBug> <S2SV_StartBug> td . tag = RPMTAG_SIGPGP ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! headerIsEntry ( h , td . tag ) ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ; <S2SV_EndBug> ","<S2SV_ModStart> rpmTagVal <S2SV_ModEnd> <S2SV_ModStart> , char * * msg ) { const struct taglate_s * xl <S2SV_ModEnd> <S2SV_ModStart> rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <S2SV_ModEnd> <S2SV_ModStart> xl -> xtag ; if ( td . type != rpmTagGetTagType ( <S2SV_ModEnd> <S2SV_ModStart> ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <S2SV_ModEnd> <S2SV_ModStart> headerPut <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <S2SV_ModEnd> "
704,"<S2SV_StartBug> ""Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n"" , ctxt -> inputNr + 1 , input -> cur ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1 "
705,<S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> ,<S2SV_ModStart> EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> 
706,<S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> "
707,"<S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ; "
708,"<S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
709,"<S2SV_StartBug> struct ext4_ext_path * path ) <S2SV_EndBug> <S2SV_StartBug> struct ext4_extent * ex ; <S2SV_EndBug> <S2SV_StartBug> ext_debug ( ""ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" <S2SV_EndBug> <S2SV_StartBug> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <S2SV_EndBug> ","<S2SV_ModStart> ext4_map_blocks * map , struct <S2SV_ModStart> ; ext4_lblk_t ee_block ; unsigned int ee_len <S2SV_ModStart> ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_ModStart> ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <S2SV_ModEnd> "
710,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ; "
711,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug> ,<S2SV_ModStart> cond_resched ( ) <S2SV_ModEnd> 
712,"<S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> ",<S2SV_ModStart> | O_NOFOLLOW 
713,<S2SV_StartBug> init_thread : <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ; "
714,"<S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_free_nolock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
715,"<S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> UMOUNT_CONNECTED <S2SV_ModEnd> 
716,<S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> ,<S2SV_ModStart> interlaced_dct = 0 ; s -> 
717,"<S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> 
718,"<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
719,"<S2SV_StartBug> static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double this_frame_mv_in_out ) { <S2SV_EndBug> <S2SV_StartBug> if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min ) <S2SV_EndBug> <S2SV_StartBug> frame_boost = ( IIFACTOR * this_frame -> intra_error / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; <S2SV_EndBug> <S2SV_StartBug> return MIN ( frame_boost , GF_RMAX ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> , double max_boost <S2SV_ModStart> const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; <S2SV_ModEnd> <S2SV_ModStart> BASELINE_ERR_PER_MB * num_mbs ) <S2SV_ModEnd> <S2SV_ModStart> ; frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <S2SV_ModEnd> <S2SV_ModStart> max_boost * boost_q_correction <S2SV_ModEnd> "
720,"<S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
721,"<S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive"" ) ; RETURN_FALSE ; } "
722,"<S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , <S2SV_EndBug> <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ofs <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> i , <S2SV_ModEnd> <S2SV_ModStart> offs <S2SV_ModEnd> "
723,"<S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ; <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> "
724,<S2SV_StartBug> struct net_device * dev = vif -> dev ; <S2SV_EndBug> <S2SV_StartBug> if ( netif_carrier_ok ( dev ) ) { <S2SV_EndBug> <S2SV_StartBug> xenvif_down ( vif ) ; <S2SV_EndBug> <S2SV_StartBug> rtnl_unlock ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vif -> <S2SV_ModEnd> <S2SV_ModStart> xenvif_carrier_off <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
725,"<S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> <S2SV_ModStart> siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> "
726,"<S2SV_StartBug> err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."" "
727,<S2SV_StartBug> hlist_del ( & pin -> m_list ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_del ( & pin -> s_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> hlist_del_init <S2SV_ModEnd> <S2SV_ModStart> hlist_del_init <S2SV_ModEnd> 
728,"<S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> int step_param ; <S2SV_EndBug> <S2SV_StartBug> int bestsme = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> speed < 8 ) <S2SV_EndBug> <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> const x = & cpi -> td . <S2SV_ModEnd> <S2SV_ModStart> const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <S2SV_ModStart> ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <S2SV_ModStart> step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <S2SV_ModEnd> "
729,<S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ; 
730,"<S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
731,<S2SV_StartBug> ybf -> uv_width = uv_width ; <S2SV_EndBug> ,<S2SV_ModStart> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf -> 
732,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , true "
733,<S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> ,"<S2SV_ModStart> ( * psig ) = s + <S2SV_ModEnd> <S2SV_ModStart> { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return ""4"" ""invalid<S2SV_blank>Padding<S2SV_blank>String"" ; } <S2SV_ModEnd> "
734,<S2SV_StartBug> if ( ctx -> mb_height > 68 || <S2SV_EndBug> <S2SV_StartBug> ctx -> data_offset = 0x280 ; <S2SV_EndBug> ,"<S2SV_ModStart> ) { av_log ( ctx -> avctx , AV_LOG_ERROR , ""mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n"" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
735,<S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> ,<S2SV_ModStart> serio <S2SV_ModEnd> 
736,"<S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ",<S2SV_ModStart> av_calloc <S2SV_ModEnd> <S2SV_ModStart> av_calloc <S2SV_ModEnd> 
737,<S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> ,<S2SV_ModStart> cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ; 
738,<S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> 
739,<S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> ,"<S2SV_ModStart> int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> "
740,<S2SV_StartBug> if ( calldata -> arg . open_flags == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> fmode <S2SV_ModEnd> 
741,<S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ,<S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> goto discard_fq ; if <S2SV_ModEnd> <S2SV_ModStart> goto discard_fq ; <S2SV_ModEnd> <S2SV_ModStart> discard_fq : fq_kill ( fq ) ; 
742,<S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> ,<S2SV_ModStart> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> <S2SV_ModStart> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> <S2SV_ModStart> free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> 
743,<S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> ,<S2SV_ModStart> strlen ( token ) > 4 && 
744,<S2SV_StartBug> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
745,"<S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
746,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> # line 2369 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 832 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> # line 2405 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 868 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2451 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 914 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2474 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 936 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2487 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 945 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2500 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 954 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2519 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 969 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2535 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 981 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2553 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 995 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2570 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1008 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2585 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1019 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> # line 1027 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2631 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1057 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2670 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1092 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2753 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1171 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2787 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1201 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2840 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1250 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2850 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1256 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2860 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1262 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2890 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1288 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2930 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1324 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2959 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1349 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 2999 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1385 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3012 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1394 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3025 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1403 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3038 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1412 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3051 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1421 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3064 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1430 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3077 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1439 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3085 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1443 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3093 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1450 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3099 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1451 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3105 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1457 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3127 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1479 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3143 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1491 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3158 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1506 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3167 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1512 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3178 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1529 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3189 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1536 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3200 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1548 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3208 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1552 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3216 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1560 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3224 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1564 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3238 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1574 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3256 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1588 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3276 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1604 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3290 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1614 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3303 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1623 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3332 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1648 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3348 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1660 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3364 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1672 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3384 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1688 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3400 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1700 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3420 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1716 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3469 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1761 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3492 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1780 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3514 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1798 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3536 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1816 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3558 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1834 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3588 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1860 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3610 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1878 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3624 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1888 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3638 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1898 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3652 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1908 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3666 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1918 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3680 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1928 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3694 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1938 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3702 ""grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 3706 ""grammar.c"" <S2SV_EndBug> ",<S2SV_ModStart> default : assert ( FALSE ) ; <S2SV_ModStart> 2371 <S2SV_ModEnd> <S2SV_ModStart> 834 <S2SV_ModEnd> <S2SV_ModStart> default : assert ( FALSE ) ; <S2SV_ModStart> 2409 <S2SV_ModEnd> <S2SV_ModStart> 872 <S2SV_ModEnd> <S2SV_ModStart> 2455 <S2SV_ModEnd> <S2SV_ModStart> 918 <S2SV_ModEnd> <S2SV_ModStart> 2478 <S2SV_ModEnd> <S2SV_ModStart> 940 <S2SV_ModEnd> <S2SV_ModStart> 2491 <S2SV_ModEnd> <S2SV_ModStart> 949 <S2SV_ModEnd> <S2SV_ModStart> 2504 <S2SV_ModEnd> <S2SV_ModStart> 958 <S2SV_ModEnd> <S2SV_ModStart> 2523 <S2SV_ModEnd> <S2SV_ModStart> 973 <S2SV_ModEnd> <S2SV_ModStart> 2539 <S2SV_ModEnd> <S2SV_ModStart> 985 <S2SV_ModEnd> <S2SV_ModStart> 2557 <S2SV_ModEnd> <S2SV_ModStart> 999 <S2SV_ModEnd> <S2SV_ModStart> 2574 <S2SV_ModEnd> <S2SV_ModStart> 1012 <S2SV_ModEnd> <S2SV_ModStart> 2589 <S2SV_ModEnd> <S2SV_ModStart> 1023 <S2SV_ModEnd> <S2SV_ModStart> YYERROR ; } # line 2603 <S2SV_ModEnd> <S2SV_ModStart> 1033 <S2SV_ModEnd> <S2SV_ModStart> 2637 <S2SV_ModEnd> <S2SV_ModStart> 1063 <S2SV_ModEnd> <S2SV_ModStart> 2676 <S2SV_ModEnd> <S2SV_ModStart> 1098 <S2SV_ModEnd> <S2SV_ModStart> 2759 <S2SV_ModEnd> <S2SV_ModStart> 1177 <S2SV_ModEnd> <S2SV_ModStart> 2793 <S2SV_ModEnd> <S2SV_ModStart> 1207 <S2SV_ModEnd> <S2SV_ModStart> 2846 <S2SV_ModEnd> <S2SV_ModStart> 1256 <S2SV_ModEnd> <S2SV_ModStart> 2856 <S2SV_ModEnd> <S2SV_ModStart> 1262 <S2SV_ModEnd> <S2SV_ModStart> 2866 <S2SV_ModEnd> <S2SV_ModStart> 1268 <S2SV_ModEnd> <S2SV_ModStart> 2896 <S2SV_ModEnd> <S2SV_ModStart> 1294 <S2SV_ModEnd> <S2SV_ModStart> 2936 <S2SV_ModEnd> <S2SV_ModStart> 1330 <S2SV_ModEnd> <S2SV_ModStart> 2965 <S2SV_ModEnd> <S2SV_ModStart> 1355 <S2SV_ModEnd> <S2SV_ModStart> 3005 <S2SV_ModEnd> <S2SV_ModStart> 1391 <S2SV_ModEnd> <S2SV_ModStart> 3018 <S2SV_ModEnd> <S2SV_ModStart> 1400 <S2SV_ModEnd> <S2SV_ModStart> 3031 <S2SV_ModEnd> <S2SV_ModStart> 1409 <S2SV_ModEnd> <S2SV_ModStart> 3044 <S2SV_ModEnd> <S2SV_ModStart> 1418 <S2SV_ModEnd> <S2SV_ModStart> 3057 <S2SV_ModEnd> <S2SV_ModStart> 1427 <S2SV_ModEnd> <S2SV_ModStart> 3070 <S2SV_ModEnd> <S2SV_ModStart> 1436 <S2SV_ModEnd> <S2SV_ModStart> 3083 <S2SV_ModEnd> <S2SV_ModStart> 1445 <S2SV_ModEnd> <S2SV_ModStart> 3091 <S2SV_ModEnd> <S2SV_ModStart> 1449 <S2SV_ModEnd> <S2SV_ModStart> 3099 <S2SV_ModEnd> <S2SV_ModStart> 1456 <S2SV_ModEnd> <S2SV_ModStart> 3105 <S2SV_ModEnd> <S2SV_ModStart> 1457 <S2SV_ModEnd> <S2SV_ModStart> 3111 <S2SV_ModEnd> <S2SV_ModStart> 1463 <S2SV_ModEnd> <S2SV_ModStart> 3133 <S2SV_ModEnd> <S2SV_ModStart> 1485 <S2SV_ModEnd> <S2SV_ModStart> 3149 <S2SV_ModEnd> <S2SV_ModStart> 1497 <S2SV_ModEnd> <S2SV_ModStart> 3164 <S2SV_ModEnd> <S2SV_ModStart> 1512 <S2SV_ModEnd> <S2SV_ModStart> 3173 <S2SV_ModEnd> <S2SV_ModStart> 1518 <S2SV_ModEnd> <S2SV_ModStart> 3184 <S2SV_ModEnd> <S2SV_ModStart> 1535 <S2SV_ModEnd> <S2SV_ModStart> 3195 <S2SV_ModEnd> <S2SV_ModStart> 1542 <S2SV_ModEnd> <S2SV_ModStart> 3206 <S2SV_ModEnd> <S2SV_ModStart> 1554 <S2SV_ModEnd> <S2SV_ModStart> 3214 <S2SV_ModEnd> <S2SV_ModStart> 1558 <S2SV_ModEnd> <S2SV_ModStart> 3222 <S2SV_ModEnd> <S2SV_ModStart> 1566 <S2SV_ModEnd> <S2SV_ModStart> 3230 <S2SV_ModEnd> <S2SV_ModStart> 1570 <S2SV_ModEnd> <S2SV_ModStart> 3244 <S2SV_ModEnd> <S2SV_ModStart> 1580 <S2SV_ModEnd> <S2SV_ModStart> 3262 <S2SV_ModEnd> <S2SV_ModStart> 1594 <S2SV_ModEnd> <S2SV_ModStart> 3282 <S2SV_ModEnd> <S2SV_ModStart> 1610 <S2SV_ModEnd> <S2SV_ModStart> 3296 <S2SV_ModEnd> <S2SV_ModStart> 1620 <S2SV_ModEnd> <S2SV_ModStart> 3309 <S2SV_ModEnd> <S2SV_ModStart> 1629 <S2SV_ModEnd> <S2SV_ModStart> 3338 <S2SV_ModEnd> <S2SV_ModStart> 1654 <S2SV_ModEnd> <S2SV_ModStart> 3354 <S2SV_ModEnd> <S2SV_ModStart> 1666 <S2SV_ModEnd> <S2SV_ModStart> 3370 <S2SV_ModEnd> <S2SV_ModStart> 1678 <S2SV_ModEnd> <S2SV_ModStart> 3390 <S2SV_ModEnd> <S2SV_ModStart> 1694 <S2SV_ModEnd> <S2SV_ModStart> 3406 <S2SV_ModEnd> <S2SV_ModStart> 1706 <S2SV_ModEnd> <S2SV_ModStart> 3426 <S2SV_ModEnd> <S2SV_ModStart> 1722 <S2SV_ModEnd> <S2SV_ModStart> 3475 <S2SV_ModEnd> <S2SV_ModStart> 1767 <S2SV_ModEnd> <S2SV_ModStart> 3498 <S2SV_ModEnd> <S2SV_ModStart> 1786 <S2SV_ModEnd> <S2SV_ModStart> 3520 <S2SV_ModEnd> <S2SV_ModStart> 1804 <S2SV_ModEnd> <S2SV_ModStart> 3542 <S2SV_ModEnd> <S2SV_ModStart> 1822 <S2SV_ModEnd> <S2SV_ModStart> 3564 <S2SV_ModEnd> <S2SV_ModStart> 1840 <S2SV_ModEnd> <S2SV_ModStart> 3594 <S2SV_ModEnd> <S2SV_ModStart> 1866 <S2SV_ModEnd> <S2SV_ModStart> 3616 <S2SV_ModEnd> <S2SV_ModStart> 1884 <S2SV_ModEnd> <S2SV_ModStart> 3630 <S2SV_ModEnd> <S2SV_ModStart> 1894 <S2SV_ModEnd> <S2SV_ModStart> 3644 <S2SV_ModEnd> <S2SV_ModStart> 1904 <S2SV_ModEnd> <S2SV_ModStart> 3658 <S2SV_ModEnd> <S2SV_ModStart> 1914 <S2SV_ModEnd> <S2SV_ModStart> 3672 <S2SV_ModEnd> <S2SV_ModStart> 1924 <S2SV_ModEnd> <S2SV_ModStart> 3686 <S2SV_ModEnd> <S2SV_ModStart> 1934 <S2SV_ModEnd> <S2SV_ModStart> 3700 <S2SV_ModEnd> <S2SV_ModStart> 1944 <S2SV_ModEnd> <S2SV_ModStart> 3708 <S2SV_ModEnd> <S2SV_ModStart> 3712 <S2SV_ModEnd> 
747,<S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> < 0 ) { jas_eprintf ( ""warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>"" ""(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n"" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
748,"<S2SV_StartBug> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> <S2SV_StartBug> vpx_fixed_buf_t * stats ) { <S2SV_EndBug> <S2SV_StartBug> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
749,"<S2SV_StartBug> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> ( void ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , void * unused ) { <S2SV_ModEnd> <S2SV_ModStart> unused <S2SV_ModEnd> <S2SV_ModStart> lf_data -> planes <S2SV_ModEnd> "
750,"<S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> cp <S2SV_ModEnd> 
751,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
752,<S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> ,<S2SV_ModStart> u64 <S2SV_ModEnd> 
753,<S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> btif_config_devcache_cleanup ( ) ; 
754,<S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart>  <S2SV_ModEnd> 
755,<S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> ,<S2SV_ModStart> ( ( <S2SV_ModStart> ) && ( kk < input -> length ) ) 
756,<S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
757,"<S2SV_StartBug> int rc ; <S2SV_EndBug> <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> smbhash_err : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> crypto_cipher * tfm_des <S2SV_ModEnd> <S2SV_ModStart> crypto_alloc_cipher ( ""des"" <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> <S2SV_ModStart> crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> "
758,<S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( band -> prec ) { <S2SV_ModStart> } 
759,<S2SV_StartBug> if ( ret ) { <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,"<S2SV_ModStart> ret = - EINVAL ; if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) { ret = fdt_check_no_at ( fit , 0 ) ; if ( ret ) <S2SV_ModStart> ret ; } } if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return ret <S2SV_ModEnd> "
760,<S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug> ,<S2SV_ModStart> - <S2SV_ModEnd> 
761,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int table_len ; <S2SV_ModStart> table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> table_len <S2SV_ModEnd> "
762,<S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> ,"<S2SV_ModStart> CHAR_BIT <S2SV_ModEnd> <S2SV_ModStart> CHAR_BIT <S2SV_ModEnd> <S2SV_ModStart> MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> "
763,"<S2SV_StartBug> if ( in ) { <S2SV_EndBug> <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( out ) <S2SV_ModStart>  <S2SV_ModEnd> 
764,<S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> ,<S2SV_ModStart> av_assert0 ( s -> bit_depth > 1 ) ; 
765,"<S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode ) == fmode <S2SV_ModEnd> 
766,"<S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> <S2SV_StartBug> case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> ",<S2SV_ModStart> assert ( len > 28 ) ; <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
767,<S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> || ! SecIsValidHandle ( handle ) 
768,<S2SV_StartBug> sax -> sax25_family = AF_NETROM ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( sax , 0 , sizeof ( sax ) ) ; "
769,"<S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
770,<S2SV_StartBug> return res ; <S2SV_EndBug> ,<S2SV_ModStart> cleanup : <S2SV_ModEnd> 
771,"<S2SV_StartBug> } else if ( cmd == CMD_FREE ) { <S2SV_EndBug> <S2SV_StartBug> if ( section == & service_options || section == & new_service_options ) <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>section<S2SV_blank>defaults"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_NOTICE , <S2SV_EndBug> <S2SV_StartBug> if ( section == & service_options ) <S2SV_EndBug> ","<S2SV_ModStart> if ( section == & service_options ) s_log ( LOG_ERR , ""INTERNAL<S2SV_blank>ERROR:<S2SV_blank>Initializing<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ; else if ( section == & new_service_options ) s_log ( LOG_INFO , ""Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration"" ) ; else s_log ( LOG_INFO , ""Initializing<S2SV_blank>service<S2SV_blank>[%s]"" , section -> servname ) ; <S2SV_ModStart> ) s_log ( LOG_DEBUG , ""Deallocating<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults"" ) ; else if ( <S2SV_ModEnd> <S2SV_ModStart> ""Deallocating<S2SV_blank>temporary<S2SV_blank>section<S2SV_blank>defaults"" <S2SV_ModEnd> <S2SV_ModStart> # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> security_level = - 1 ; break ; case CMD_SET_COPY : section -> security_level = new_service_options . security_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , ""securityLevel"" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return ""Illegal<S2SV_blank>security<S2SV_blank>level"" ; section -> security_level = tmp_int ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>%d"" , ""securityLevel"" , DEFAULT_SECURITY_LEVEL ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , ""%-22s<S2SV_blank>=<S2SV_blank>set<S2SV_blank>the<S2SV_blank>security<S2SV_blank>level"" , ""securityLevel"" ) ; break ; } # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || section == & new_service_options "
772,<S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> __preempt_count_sub <S2SV_ModEnd> "
773,"<S2SV_StartBug> vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; <S2SV_EndBug> <S2SV_StartBug> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( void ) mvcost ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else ( void ) search_param ; # <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
774,"<S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ","<S2SV_ModStart> mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> <S2SV_ModStart> } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ns -> pending_mounts = 0 ; "
775,"<S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> <S2SV_StartBug> printstr ( & pp , ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" ) ; <S2SV_EndBug> <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> <S2SV_StartBug> l += i ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned <S2SV_ModEnd> <S2SV_ModStart> sscanf ( sb , ""%u"" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> <S2SV_ModStart> ""<form<S2SV_blank>method=\\""POST\\""<S2SV_blank>action=\\""/U\\""<S2SV_blank>enctype=\\""application/x-www-form-urlencoded\\""><textarea<S2SV_blank>cols=\\""80\\""<S2SV_blank>rows=\\""30\\""<S2SV_blank>name=\\""conffile\\"">"" <S2SV_ModEnd> <S2SV_ModStart> unsigned <S2SV_ModEnd> <S2SV_ModStart> ! contentlen || <S2SV_ModStart> l < contentlen && <S2SV_ModStart> ( contentlen - l ) > <S2SV_ModStart> ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> <S2SV_ModStart> buf [ i ] = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> "
776,"<S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
777,"<S2SV_StartBug> static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) <S2SV_EndBug> <S2SV_StartBug> if ( nd -> intent . open . flags & FMODE_EXEC ) { <S2SV_EndBug> <S2SV_StartBug> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> , fmode_t fmode <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode & ( FMODE_READ | FMODE_WRITE ) <S2SV_ModEnd> "
778,"<S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> map = 
779,"<S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> <S2SV_ModStart> MagickMin <S2SV_ModEnd> <S2SV_ModStart> MagickMax <S2SV_ModEnd> 
780,"<S2SV_StartBug> int col_offset , end_col_offset ; <S2SV_EndBug> <S2SV_StartBug> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <S2SV_EndBug> <S2SV_StartBug> if ( ( err_ret -> error = <S2SV_EndBug> <S2SV_StartBug> ps -> p_tree = NULL ; <S2SV_EndBug> ","<S2SV_ModStart> growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <S2SV_ModStart> ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <S2SV_ModStart> type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <S2SV_ModStart> ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores ) "
781,"<S2SV_StartBug> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
782,<S2SV_StartBug> cpi -> common . last_frame_type = cpi -> common . frame_type ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi -> rc . rc_2_frame = 0 ; cpi -> rc . rc_1_frame = 0 ; 
783,"<S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_EndBug> <S2SV_StartBug> height ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> ""ImproperImageHeader"" <S2SV_ModEnd> <S2SV_ModStart> else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; } "
784,"<S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct iov_iter iter ; <S2SV_ModStart> ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; size_t written <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> "
785,<S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> <S2SV_ModStart> STF_FAIL + "
786,<S2SV_StartBug> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
787,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
788,"<S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> ","<S2SV_ModStart> current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart>  <S2SV_ModEnd> "
789,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> * tl_data_head = NULL ; 
790,"<S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> ","<S2SV_ModStart> int length = urb -> actual_length ; <S2SV_ModStart> if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> <S2SV_ModStart> length ) ; desc -> length += length ; <S2SV_ModStart> = length ; } } <S2SV_ModEnd> "
791,<S2SV_StartBug> goto no_match ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( det_ctx -> discontinue_matching ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( cd -> flags & ( DETECT_CONTENT_DISTANCE | DETECT_CONTENT_WITHIN ) ) == 0 ) { det_ctx -> discontinue_matching = 1 ; } <S2SV_ModStart> smd -> is_last ) { goto match <S2SV_ModEnd> <S2SV_ModStart> SCLogDebug ( ""no<S2SV_blank>match<S2SV_blank>for<S2SV_blank>\'next<S2SV_blank>sm\'"" ) ; <S2SV_ModStart> { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>said<S2SV_blank>to<S2SV_blank>discontinue<S2SV_blank>this<S2SV_blank>right<S2SV_blank>now"" ) ; goto no_match ; } if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>depend<S2SV_blank>on<S2SV_blank>me,<S2SV_blank>so<S2SV_blank>we<S2SV_blank>can<S2SV_blank>give<S2SV_blank>up"" ) ; det_ctx -> discontinue_matching = 1 ; goto no_match ; } SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>depends<S2SV_blank>on<S2SV_blank>me<S2SV_blank>%p,<S2SV_blank>lets<S2SV_blank>see<S2SV_blank>what<S2SV_blank>we<S2SV_blank>can<S2SV_blank>do<S2SV_blank>(flags<S2SV_blank>%u)"" , cd , cd -> flags ) <S2SV_ModEnd> "
792,<S2SV_StartBug> usleep ( 10000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
793,<S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> ,"<S2SV_ModStart> p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart>  <S2SV_ModEnd> "
794,"<S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart> return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE "
795,<S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
796,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
797,<S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> int name_len ; <S2SV_EndBug> ,"<S2SV_ModStart> avio_skip ( pb , name_len <S2SV_ModEnd> <S2SV_ModStart> ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA "
798,"<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , NULL , TRUE ) <S2SV_ModEnd> "
799,<S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> ,<S2SV_ModStart> || base_gfn != old . base_gfn 
800,<S2SV_StartBug> return FALSE ; <S2SV_EndBug> ,<S2SV_ModStart> transport -> credssp = NULL ; 
801,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
802,"<S2SV_StartBug> sParse . rc = SQLITE_OK ; <S2SV_EndBug> <S2SV_StartBug> sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> pSelect -> selFlags &= ~ SF_View ; <S2SV_ModStart>  <S2SV_ModEnd> 
803,<S2SV_StartBug> pthread_mutex_lock ( & lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> btif_config_write ( <S2SV_ModEnd> 
804,<S2SV_StartBug> gctx = group_leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> <S2SV_ModStart> perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> "
805,<S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; } "
806,"<S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank>HDRI"" <S2SV_EndBug> <S2SV_StartBug> ; <S2SV_EndBug> ","<S2SV_ModStart> MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" <S2SV_ModEnd> <S2SV_ModStart> # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" <S2SV_ModStart> # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif "
807,"<S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long cr4 ; <S2SV_ModStart> HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> "
808,"<S2SV_StartBug> int64_t * time_stamp , int64_t * time_end_stamp , <S2SV_EndBug> <S2SV_StartBug> vp9_ppflags_t * flags ) { <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( pbi -> common . show_frame == 0 ) <S2SV_EndBug> <S2SV_StartBug> * time_stamp = pbi -> last_time_stamp ; <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_VP9_POSTPROC <S2SV_EndBug> <S2SV_StartBug> ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ; <S2SV_EndBug> <S2SV_StartBug> * sd = * pbi -> common . frame_to_show ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> VP9_COMMON * const cm = & pbi -> common ; <S2SV_ModStart> # if ! CONFIG_VP9_POSTPROC ( void ) * flags ; # endif <S2SV_ModStart> pbi -> ready_for_new_data = 1 ; if ( ! cm -> show_frame <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! cm -> show_existing_frame ) { <S2SV_ModStart> cm <S2SV_ModEnd> <S2SV_ModStart> } else { * sd = * cm -> frame_to_show ; ret = 0 ; } <S2SV_ModStart> cm -> frame_to_show <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> 
809,"<S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ; "
810,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
811,"<S2SV_StartBug> DPRINTF ( ""Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> 
812,<S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> <S2SV_StartBug> target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> rc -> frames_till_gf_update_due = INT_MAX ; <S2SV_EndBug> ,<S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <S2SV_ModEnd> 
813,"<S2SV_StartBug> u8 * data , * output ; <S2SV_EndBug> <S2SV_StartBug> u32 pck_size , prev_pck_size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> = NULL <S2SV_ModStart> = 0 <S2SV_ModStart> else { <S2SV_ModStart> } 
814,<S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ,<S2SV_ModStart> max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> + sizeof ( uint32_t ) 
815,"<S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> ) ; rcu_read_unlock ( 
816,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_cosine_packet <S2SV_ModEnd> <S2SV_ModStart> buf , line <S2SV_ModEnd> "
817,<S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> env -> insn_aux_data [ insn_idx ] . seen = true ; 
818,<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> int rowstep ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> <S2SV_ModStart> jas_matind_t <S2SV_ModEnd> 
819,"<S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> ","<S2SV_ModStart> , size << 3 "
820,"<S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> ",<S2SV_ModStart> TIFFGetFieldDefaulted <S2SV_ModEnd> 
821,"<S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length > <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
822,"<S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , <S2SV_ModStart> v . Assign . type_comment = type_comment ; p -> "
823,<S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; } 
824,"<S2SV_StartBug> u64 nr , int nmi , <S2SV_EndBug> <S2SV_StartBug> perf_swevent_event ( event , nr , nmi , data , regs ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
825,"<S2SV_StartBug> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <S2SV_EndBug> <S2SV_StartBug> if ( event_data [ 0 ] >= 0x80 ) { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> <S2SV_StartBug> midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x20 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_setup_portprefix ( mdi , event_data [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _WM_midi_setup_endoftrack ( mdi ) ; <S2SV_EndBug> <S2SV_StartBug> _WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x54 ) && ( event_data [ 1 ] == 0x05 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! sysex_len ) break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> uint32_t siz , <S2SV_ModStart> ! siz ) goto shortbuf ; if ( <S2SV_ModStart> ; if ( -- siz == 0 ) goto shortbuf <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 5 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 7 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 6 ) goto shortbuf ; <S2SV_ModStart> if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> -- siz && <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> if ( -- siz < tmp_length ) goto shortbuf ; <S2SV_ModStart> if ( ! siz ) break ; <S2SV_ModStart> siz -- ; <S2SV_ModStart> if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(input<S2SV_blank>too<S2SV_blank>short)"" , 0 ) ; return 0 ; "
826,"<S2SV_StartBug> sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ; <S2SV_EndBug> ","<S2SV_ModStart> int num = snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( outfilename ) , <S2SV_ModStart> if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n"" ) ; return 1 ; } "
827,"<S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
828,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ifs\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> <S2SV_ModStart> { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""is_async\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
829,"<S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( hlen < 0 ) { err = hlen ; goto fail ; } 
830,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <S2SV_EndBug> <S2SV_StartBug> int further_steps , step_param ; <S2SV_EndBug> <S2SV_StartBug> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> int tmp_row_max = x -> mv_row_max ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { <S2SV_EndBug> <S2SV_StartBug> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + <S2SV_EndBug> <S2SV_StartBug> cpi -> mv_step_param ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && <S2SV_EndBug> <S2SV_StartBug> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , <S2SV_EndBug> <S2SV_StartBug> int bhl = b_height_log2_lookup [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == FAST_HEX ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == HEX ) { <S2SV_EndBug> <S2SV_StartBug> & dis , & x -> pred_sse [ ref ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> ; int cost_list [ 5 ] <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . auto_mv_step_size && cm -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> / 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ BLOCK_64X64 ] <S2SV_ModEnd> <S2SV_ModStart> b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> cm -> <S2SV_ModEnd> <S2SV_ModStart> row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> <S2SV_ModStart> ++ i <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <S2SV_ModEnd> <S2SV_ModStart> { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> <S2SV_ModStart> cm -> allow_high_precision_mv , x -> errorperbit , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . subpel_force_stop , <S2SV_ModEnd> <S2SV_ModStart> mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <S2SV_ModEnd> <S2SV_ModStart> , NULL , 0 , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> as_mv <S2SV_ModEnd> "
831,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int <S2SV_ModEnd> <S2SV_ModStart> unsigned int len ; <S2SV_ModStart> len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> 
832,"<S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""larval"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strncpy ( <S2SV_ModEnd> <S2SV_ModStart> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""larval"" , sizeof ( rl . type ) <S2SV_ModEnd> "
833,"<S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> ","<S2SV_ModStart> is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , ""Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device"" ) ; goto error ; } if ( "
834,"<S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
835,"<S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ","<S2SV_ModStart> , struct desc_struct * desc <S2SV_ModStart> if ( desc ) * desc = seg_desc ; "
836,"<S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> * <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> resp -> id = id ; resp -> operation = op ; resp -> status = st ; 
837,"<S2SV_StartBug> fprintf ( dump , ""%s"" , sdp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( sdp && size ) 
838,<S2SV_StartBug> if ( read != entry . uncompressed_filesize ) { <S2SV_EndBug> ,<S2SV_ModStart> || read <= 8 
839,<S2SV_StartBug> r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & r1 , 0 , sizeof ( r1 ) ) ; "
840,"<S2SV_StartBug> ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , <S2SV_EndBug> <S2SV_StartBug> ext4_get_block ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ext4_should_dioread_nolock ( inode ) ) <S2SV_ModStart> ext4_get_block_write ) ; else ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , "
841,"<S2SV_StartBug> int16_t vp9_ac_quant ( int qindex , int delta ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> <S2SV_ModStart> case VPX_BITS_10 : return ac_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return ac_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1 ; } # else ( void ) bit_depth ; return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif "
842,"<S2SV_StartBug> add_mibfile ( const char * tmpstr , const char * d_name , FILE * ip ) <S2SV_EndBug> <S2SV_StartBug> if ( ip ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
843,<S2SV_StartBug> if ( wp -> listening_socket != STDIN_FILENO ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
844,"<S2SV_StartBug> int i , retval ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ",<S2SV_ModStart> test_parser_param ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
845,<S2SV_StartBug> assert ( c != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( c -> rbytes >= c -> rsize ) { <S2SV_EndBug> ,<S2SV_ModStart> int num_allocs = 0 ; <S2SV_ModStart> if ( num_allocs == 4 ) { return gotdata ; } ++ num_allocs ; 
846,"<S2SV_StartBug> Rd_WP_DWORD ( image , & Rec . RecordLength ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" "
847,"<S2SV_StartBug> int len , err = - ENOBUFS ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( nlk -> cb_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> module_put ( cb -> module ) ; <S2SV_EndBug> <S2SV_StartBug> consume_skb ( cb -> skb ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct module * module ; <S2SV_ModStart> module = cb -> module ; skb = cb -> skb ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
848,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
849,<S2SV_StartBug> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { <S2SV_EndBug> ,<S2SV_ModStart> h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if ( 
850,"<S2SV_StartBug> if ( * p ) { <S2SV_EndBug> <S2SV_StartBug> * q = 0 ; <S2SV_EndBug> <S2SV_StartBug> cmd = p + 1 ; <S2SV_EndBug> <S2SV_StartBug> * p = \'""\' ; <S2SV_EndBug> ",<S2SV_ModStart> char op0 = 0 ; <S2SV_ModStart> op0 = * q ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> op0 <S2SV_ModEnd> 
851,<S2SV_StartBug> return AUTH_FOUND ; <S2SV_EndBug> ,<S2SV_ModStart> fclose ( opwfile ) ; 
852,<S2SV_StartBug> return parser_flags ; <S2SV_EndBug> ,<S2SV_ModStart> if ( flags -> cf_flags & PyCF_TYPE_COMMENTS ) parser_flags |= PyPARSE_TYPE_COMMENTS ; 
