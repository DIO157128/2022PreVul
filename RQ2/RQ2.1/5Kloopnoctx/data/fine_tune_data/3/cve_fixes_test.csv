,source,target
0,"<S2SV_StartBug> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) <S2SV_EndBug> <S2SV_StartBug> __wait_discard_cmd ( sbi , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> , bool umount <S2SV_ModStart> ! umount <S2SV_ModEnd> "
1,"<S2SV_StartBug> dprintk ( ""%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n"" , bd -> name , count ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL "
2,"<S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if ( 
3,<S2SV_StartBug> if ( ! mm ) <S2SV_EndBug> ,<S2SV_ModStart> || ! mm -> env_end 
4,"<S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> return true ; 
5,<S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_protocol <S2SV_ModEnd> <S2SV_ModStart> sk -> sk_protocol <S2SV_ModEnd> <S2SV_ModStart> skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! skb <S2SV_ModEnd> 
6,<S2SV_StartBug> INST_HANDLER ( sts ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 4 ) { return ; } 
7,<S2SV_StartBug> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) <S2SV_EndBug> ,"<S2SV_ModStart> EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( "
8,"<S2SV_StartBug> return kvm_x86_ops -> set_msr ( vcpu , msr ) ; <S2SV_EndBug> ",<S2SV_ModStart> switch ( msr -> index ) { case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ; break ; case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ; } 
9,"<S2SV_StartBug> char file [ PATH_MAX ] ; <S2SV_EndBug> <S2SV_StartBug> while ( fscanf ( maps , ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%s<S2SV_blank>%ld<S2SV_blank>%s\\n"" , & offset , device , & inode , <S2SV_EndBug> ","<S2SV_ModStart> 1024 <S2SV_ModEnd> <S2SV_ModStart> ""%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%5s<S2SV_blank>%ld<S2SV_blank>%1023s\\n"" <S2SV_ModEnd> "
10,"<S2SV_StartBug> int is_pdf ; <S2SV_EndBug> <S2SV_StartBug> header = get_header ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( header && strstr ( header , ""%PDF-"" ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( <S2SV_ModStart> ) ) return 0 ; const char * c = <S2SV_ModEnd> <S2SV_ModStart> ; const int is_pdf = c && ( ( c - header + strlen ( ""%PDF-M.m"" ) ) < 1024 ) <S2SV_ModEnd> "
11,"<S2SV_StartBug> uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> xfs_attr3_rmt_blocks <S2SV_ModEnd> 
12,"<S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , ""archive_write_data"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> const size_t max_write = INT_MAX ; <S2SV_ModStart> ; if ( s > max_write ) s = max_write 
13,<S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> ,<S2SV_ModStart> RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case 
14,"<S2SV_StartBug> if ( PyArena_AddPyObject ( c -> c_arena , str ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> ! str ) return NULL ; if ( 
15,"<S2SV_StartBug> if ( ( error_code >> 16 ) != 0x8009 ) <S2SV_EndBug> <S2SV_StartBug> return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; <S2SV_EndBug> ","<S2SV_ModStart> ( <S2SV_ModStart> && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> ; case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ; case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ; case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."" "
16,"<S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
17,<S2SV_StartBug> int_fb_list -> int_fb [ i ] . size = min_size ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ; "
18,<S2SV_StartBug> box -> info = boxinfo ; <S2SV_EndBug> <S2SV_StartBug> box -> ops = & jp2_boxinfo_unk . ops ; <S2SV_EndBug> <S2SV_StartBug> jas_stream_rewind ( tmpstream ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; box -> ops = & boxinfo -> ops 
19,"<S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , true ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
20,"<S2SV_StartBug> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <S2SV_EndBug> ",<S2SV_ModStart> ASN1_F_ASN1_ITEM_VERIFY <S2SV_ModEnd> 
21,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ",<S2SV_ModStart> 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> } 
22,"<S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
23,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> <S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
24,"<S2SV_StartBug> const int sb_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ; <S2SV_EndBug> <S2SV_StartBug> int min_log2 = 0 , max_log2 = 0 ; <S2SV_EndBug> <S2SV_StartBug> * min_log2_tile_cols = min_log2 ; <S2SV_EndBug> <S2SV_StartBug> * max_log2_tile_cols = max_log2 ; <S2SV_EndBug> ",<S2SV_ModStart> sb64_cols <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_min_log2_tile_cols ( sb64_cols ) <S2SV_ModEnd> <S2SV_ModStart> get_max_log2_tile_cols ( sb64_cols ) ; assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) <S2SV_ModEnd> 
25,"<S2SV_StartBug> if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> get_segdata <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
26,"<S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ; "
27,"<S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long eip <S2SV_ModEnd> <S2SV_ModStart> eip <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , eip "
28,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
29,<S2SV_StartBug> size = INT_MAX ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT "
30,<S2SV_StartBug> if ( attr >= 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS "
31,"<S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
32,"<S2SV_StartBug> src_devid , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true <S2SV_ModStart> , true "
33,<S2SV_StartBug> if ( ( rsa = RSA_new ( ) ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if ( "
34,<S2SV_StartBug> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart> || header_len < RAW_DATA_LEN ( header ) 
35,<S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> ,<S2SV_ModStart> struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> 
36,"<S2SV_StartBug> static void restore_context ( VP9_COMP * cpi , int mi_row , int mi_col , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( xd -> above_seg_context + mi_col , sa , <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl , <S2SV_EndBug> ",<S2SV_ModStart> MACROBLOCK * const x <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
37,<S2SV_StartBug> ND_TCHECK ( dp [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> dp += 3 ; <S2SV_EndBug> ,"<S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> "
38,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
39,<S2SV_StartBug> if ( name == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> ctxt -> instate == XML_PARSER_EOF ) return ; if ( 
40,"<S2SV_StartBug> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> ",<S2SV_ModStart> hdr -> sadb_msg_reserved = 0 ; 
41,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
42,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t ) ( <S2SV_ModStart> 1U <S2SV_ModEnd> 
43,<S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> "
44,"<S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; geometry = DestroyString ( geometry 
45,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""tell<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""at<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""who-has<S2SV_blank>"" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""at<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""for<S2SV_blank>"" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> "
46,<S2SV_StartBug> if ( ! ext_dp -> icmp_length ) { <S2SV_EndBug> <S2SV_StartBug> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; <S2SV_EndBug> <S2SV_StartBug> hlen -= 4 ; <S2SV_EndBug> ,"<S2SV_ModStart> && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { <S2SV_ModStart> } "
47,"<S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name ) { const <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
48,<S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
49,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct frag_hdr fhdr ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> append : <S2SV_ModEnd> "
50,<S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) <S2SV_EndBug> <S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> if ( dp -> icmp6_data16 [ 1 ] & 0x40 ) <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & "
51,<S2SV_StartBug> PureFileInfo * r ; <S2SV_EndBug> <S2SV_StartBug> while ( opt_R && r != s ) { <S2SV_EndBug> <S2SV_StartBug> char * alloca_subdir ; <S2SV_EndBug> <S2SV_StartBug> ALLOCA_FREE ( alloca_subdir ) ; <S2SV_EndBug> <S2SV_StartBug> free ( names ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; char * alloca_subdir ; size_t sizeof_subdir <S2SV_ModStart> sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ALLOCA_FREE ( alloca_subdir ) ; 
52,"<S2SV_StartBug> if ( getenv_int ( ""STRIP"" ) ) { <S2SV_EndBug> ","<S2SV_ModStart> getenv ( ""HASHSEED"" ) ) json_object_seed ( getenv_int ( ""HASHSEED"" ) ) ; if ( "
53,"<S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> <S2SV_StartBug> if ( addrlen ) <S2SV_EndBug> <S2SV_StartBug> ( struct oe_sockaddr * ) addr , <S2SV_EndBug> <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ",<S2SV_ModStart> oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> || ! addr || ! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ; addrlen_in = * addrlen ; if ( addrlen_in < 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & addrlen_out <S2SV_ModEnd> <S2SV_ModStart> if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ; 
54,<S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> ,<S2SV_ModStart> u64 <S2SV_ModEnd> <S2SV_ModStart> u64 <S2SV_ModEnd> <S2SV_ModStart> if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; 
55,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart> goto out_controller_put <S2SV_ModEnd> 
56,<S2SV_StartBug> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_sock_count ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
57,<S2SV_StartBug> register const u_char * ep ; <S2SV_EndBug> <S2SV_StartBug> ep = ( const u_char * ) ndo -> ndo_snapend ; <S2SV_EndBug> <S2SV_StartBug> if ( ndo -> ndo_vflag ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if ( len < 8 ) goto trunc ; <S2SV_ModStart> } 
58,"<S2SV_StartBug> if ( offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> csum_partial ( skb_transport_header ( skb ) + tlen , <S2SV_EndBug> <S2SV_StartBug> offset , 0 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> skb_checksum ( skb , tend_off , <S2SV_ModEnd> <S2SV_ModStart> } "
59,"<S2SV_StartBug> size_t input_size , <S2SV_EndBug> <S2SV_StartBug> int max_bytes_matched = input_size ; <S2SV_EndBug> ","<S2SV_ModStart> input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> "
60,"<S2SV_StartBug> set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ; "
61,"<S2SV_StartBug> file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
62,"<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> char * crypt_password ; <S2SV_ModStart> crypt_password = crypt ( password , user_password ) ; if ( crypt_password == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , ""Authentication<S2SV_blank>failed"" ) ; return - 1 ; } <S2SV_ModStart> crypt_password <S2SV_ModEnd> "
63,<S2SV_StartBug> if ( atomic_dec_and_test ( & ucounts -> count ) ) { <S2SV_EndBug> <S2SV_StartBug> hlist_del_init ( & ucounts -> node ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ucounts -> count -= 1 ; if ( ! ucounts -> count ) <S2SV_ModStart> ; else ucounts = NULL <S2SV_ModStart>  <S2SV_ModEnd> 
64,<S2SV_StartBug> length += len ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ; 
65,<S2SV_StartBug> if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ; "
66,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( pid == INT_MIN ) return - ESRCH ; 
67,<S2SV_StartBug> free ( mem ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( mem ) { <S2SV_ModStart> mem = NULL ; } return ; 
68,"<S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; luaL_argcheck ( L , pos > 0 , 3 , ""offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater"" ) ; pos -- <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && pos <= ld - size , <S2SV_ModEnd> "
69,"<S2SV_StartBug> if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
70,<S2SV_StartBug> bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> free ( bin -> dyld_info ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> calloc ( 1 , <S2SV_ModEnd> <S2SV_ModStart> bin -> dyld_info ) { if ( <S2SV_ModStart> R_FREE <S2SV_ModEnd> <S2SV_ModStart> } "
71,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
72,"<S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
73,"<S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug> ","<S2SV_ModStart> unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ; "
74,"<S2SV_StartBug> void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) { <S2SV_EndBug> <S2SV_StartBug> while ( node && node -> symbol == INTERNAL_NODE ) { <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; } "
75,<S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> ,<S2SV_ModStart> ctx -> terminated || 
76,<S2SV_StartBug> if ( enable_apicv ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
77,"<S2SV_StartBug> state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> <S2SV_StartBug> verbose ( env , ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> speculative = false ; state -> <S2SV_ModStart> ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:<S2SV_blank>safe\\n"" <S2SV_ModEnd> <S2SV_ModStart> , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """" <S2SV_ModStart> ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:"" <S2SV_ModEnd> <S2SV_ModStart> , env -> cur_state -> speculative ? ""<S2SV_blank>(speculative<S2SV_blank>execution)"" : """" "
78,"<S2SV_StartBug> if ( in ) { <S2SV_EndBug> <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( out ) <S2SV_ModStart>  <S2SV_ModEnd> 
79,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
80,<S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> ,<S2SV_ModStart> VM_NO_THP <S2SV_ModEnd> <S2SV_ModStart> VM_NO_THP <S2SV_ModEnd> 
81,<S2SV_StartBug> ops -> destroy ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
82,"<S2SV_StartBug> if ( ! flatpak_bwrap_bundle_args ( bwrap , 1 , - 1 , FALSE , error ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! g_spawn_async ( NULL , <S2SV_EndBug> <S2SV_StartBug> if ( execvpe ( flatpak_get_bwrap ( ) , ( char * * ) bwrap -> argv -> pdata , bwrap -> envp ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> flatpak_bwrap_envp_to_args ( bwrap ) ; <S2SV_ModStart> g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ; <S2SV_ModStart> g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ; 
83,"<S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
84,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
85,<S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> ,<S2SV_ModStart> { pc -> index = 0 ; <S2SV_ModStart> } <S2SV_ModStart> { pc -> overread_index = pc -> index = 0 ; <S2SV_ModStart> } 
86,"<S2SV_StartBug> struct fsnotify_group * group ; <S2SV_EndBug> <S2SV_StartBug> user = get_current_user ( ) ; <S2SV_EndBug> <S2SV_StartBug> group = inotify_new_group ( user , inotify_max_queued_events ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( group ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = PTR_ERR ( group ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret >= 0 ) <S2SV_EndBug> <S2SV_StartBug> fsnotify_put_group ( group ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> < 0 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
87,"<S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> set_mi_row_col ( xd , tile , <S2SV_EndBug> <S2SV_StartBug> write_mb_modes_kf ( cpi , xd -> mi , w ) ; <S2SV_EndBug> <S2SV_StartBug> pack_mb_tokens ( w , tok , tok_end ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> const TOKENEXTRA * const <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> td . <S2SV_ModStart> cpi -> td . mb . mbmi_ext = cpi -> td . mb . mbmi_ext_base + ( mi_row * cm -> mi_cols + mi_col ) ; <S2SV_ModStart> cm , xd <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth "
88,"<S2SV_StartBug> mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( free < 0 ) { err = - ENOMEM ; goto out ; } 
89,<S2SV_StartBug> aof_fsync ( server . appendfd ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
90,"<S2SV_StartBug> byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> offset . QuadPart = 0 ; <S2SV_EndBug> <S2SV_StartBug> sizeof ( readBuffer ) , <S2SV_EndBug> <S2SV_StartBug> if ( NT_SUCCESS ( ntStatus ) ) <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Status = ntStatus ; <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Information = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> size_t devicePathLen = 0 <S2SV_ModEnd> <S2SV_ModStart> if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L""\\\\Device\\\\Harddisk"" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L""\\\\Partition0"" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> <S2SV_ModStart> ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> ; } TCfree ( readBuffer ) "
91,<S2SV_StartBug> fh32 [ 2 ] = inode -> i_generation ; <S2SV_EndBug> ,<S2SV_ModStart> fh16 [ 3 ] = 0 ; 
92,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> daddr = inet -> inet_daddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> ,<S2SV_ModStart> struct ip_options_rcu * inet_opt ; <S2SV_ModStart> rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rcu_read_unlock ( ) <S2SV_ModEnd> 
93,"<S2SV_StartBug> static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type , <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> false ; * type |= <S2SV_ModEnd> <S2SV_ModStart> ; * mask |= algt -> mask & <S2SV_ModEnd> <S2SV_ModStart> * type & * <S2SV_ModEnd> <S2SV_ModStart> return true ; else return false <S2SV_ModEnd> 
94,"<S2SV_StartBug> priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , ""required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n"" ) ; return - ENODEV ; } "
95,"<S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> <S2SV_StartBug> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" , <S2SV_EndBug> <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> <S2SV_ModStart> ""%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]"" <S2SV_ModEnd> <S2SV_ModStart> ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" ) ; return FALSE "
96,<S2SV_StartBug> ND_TCHECK ( dp -> ip6f_offlg ) ; <S2SV_EndBug> ,<S2SV_ModStart> * dp <S2SV_ModEnd> 
97,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , ""[|mlppp]"" ) ) ; return ; } "
98,"<S2SV_StartBug> return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_get4x4sse_cs <S2SV_ModEnd> 
99,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> <S2SV_ModStart> ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) 
100,<S2SV_StartBug> if ( keyring ) <S2SV_EndBug> ,<S2SV_ModStart> && link_ret == 0 
101,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ; 
102,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } "
103,"<S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> <S2SV_StartBug> err = ext4_split_extent_at ( handle , inode , path , <S2SV_EndBug> <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ; <S2SV_ModStart> ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) <S2SV_ModEnd> 
104,<S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ; 
105,"<S2SV_StartBug> BIO * cmsbio = NULL , * tmpin = NULL ; <S2SV_EndBug> <S2SV_StartBug> cmsbio = CMS_dataInit ( cms , tmpin ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( dcont && ( tmpin == dcont ) ) <S2SV_EndBug> <S2SV_StartBug> if ( cms_certs ) <S2SV_EndBug> ","<S2SV_ModStart> = NULL , * tmpout <S2SV_ModStart> if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> } <S2SV_ModStart> ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ; "
106,"<S2SV_StartBug> __ip_vs_get_timeouts ( net , & t ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & t , 0 , sizeof ( t ) ) ; "
107,"<S2SV_StartBug> if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization"" ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int force_key = 0 ; if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) { if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS <S2SV_ModEnd> <S2SV_ModStart> if ( ! valid_ref_frame_size ( ctx -> cfg . g_w , ctx -> cfg . g_h , cfg -> g_w , cfg -> g_h ) || ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) force_key = 1 ; } <S2SV_ModStart> force_key |= ctx -> cpi -> common . profile != ctx -> oxcf . profile ; <S2SV_ModStart> if ( force_key ) ctx -> next_frame_flags |= VPX_EFLAG_FORCE_KF ; "
108,<S2SV_StartBug> fp -> protocol = altsd -> bInterfaceProtocol ; <S2SV_EndBug> ,<S2SV_ModStart> if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } 
109,<S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
110,"<S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> ",<S2SV_ModStart> unsigned int count ; <S2SV_ModStart> count = kcontrol -> count ; <S2SV_ModStart>  <S2SV_ModEnd> 
111,<S2SV_StartBug> while ( c ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> i ++ , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
112,<S2SV_StartBug> time_t then ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( strlen ( stamp ) != 2 ) return SRS_ETIMESTAMPOUTOFDATE 
113,"<S2SV_StartBug> xmlNode * <S2SV_EndBug> <S2SV_StartBug> crm_recv_remote_msg ( void * session , gboolean encrypted ) <S2SV_EndBug> <S2SV_StartBug> xmlNode * xml = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( encrypted ) { <S2SV_EndBug> ","<S2SV_ModStart> gboolean <S2SV_ModEnd> <S2SV_ModStart> , char * * recv_buf <S2SV_ModStart> , int total_timeout , int * disconnected ) { int ret ; size_t request_len = 0 ; time_t start = time ( NULL ) ; char * raw_request <S2SV_ModEnd> <S2SV_ModStart> int remaining_timeout = 0 ; if ( total_timeout == 0 ) { total_timeout = 10000 ; } else if ( total_timeout < 0 ) { total_timeout = 60000 ; } * disconnected = 0 ; remaining_timeout = total_timeout ; while ( ( remaining_timeout > 0 ) && ! ( * disconnected ) ) { crm_trace ( ""waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>remote<S2SV_blank>msg,<S2SV_blank>starting<S2SV_blank>timeout<S2SV_blank>%d,<S2SV_blank>remaining_timeout<S2SV_blank>%d"" , total_timeout , remaining_timeout ) ; ret = crm_recv_remote_ready ( session , encrypted , remaining_timeout ) ; raw_request <S2SV_ModEnd> <S2SV_ModStart> ret == 0 ) { crm_err ( ""poll<S2SV_blank>timed<S2SV_blank>out<S2SV_blank>(%d<S2SV_blank>ms)<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>msg"" , remaining_timeout ) ; return FALSE ; } else if ( ret < 0 ) { if ( errno != EINTR ) { crm_debug ( ""poll<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>msg,<S2SV_blank>rc:<S2SV_blank>%d,<S2SV_blank>errno:<S2SV_blank>%d"" , ret , errno ) ; * disconnected = 1 ; return FALSE ; } crm_debug ( ""poll<S2SV_blank>EINTR<S2SV_blank>encountered<S2SV_blank>during<S2SV_blank>poll,<S2SV_blank>retrying"" ) ; } else { raw_request = crm_recv_remote_raw ( session , encrypted , 0 , & request_len , disconnected ) ; } remaining_timeout = remaining_timeout - ( ( time ( NULL ) - start ) * 1000 ) ; if ( ! raw_request ) { crm_debug ( ""Empty<S2SV_blank>msg<S2SV_blank>received<S2SV_blank>after<S2SV_blank>poll"" ) ; continue ; } if ( * recv_buf ) { int old_len = strlen ( * recv_buf ) ; crm_trace ( ""Expanding<S2SV_blank>recv<S2SV_blank>buffer<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d"" , old_len , old_len + request_len ) ; * recv_buf = realloc ( * recv_buf , old_len + request_len + 1 ) ; memcpy ( * recv_buf + old_len , raw_request , request_len ) ; * ( * recv_buf + old_len + request_len ) = '\\0' ; free ( raw_request ) ; } else { * recv_buf = raw_request ; } if ( strstr ( * recv_buf , REMOTE_MSG_TERMINATOR ) ) { return TRUE ; } } return FALSE <S2SV_ModEnd> "
114,"<S2SV_StartBug> int r , len , group = 0 ; <S2SV_EndBug> <S2SV_StartBug> Node * * tp ; <S2SV_EndBug> <S2SV_StartBug> goto end_of_token ; <S2SV_EndBug> <S2SV_StartBug> qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> ; parse_depth = env -> parse_depth <S2SV_ModStart> parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ; 
115,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> ","<S2SV_ModStart> TPA <S2SV_ModEnd> <S2SV_ModStart> ""who-has<S2SV_blank>"" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> "
116,<S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; "
117,<S2SV_StartBug> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS ) 
118,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
119,"<S2SV_StartBug> if ( ! proc_parse_options ( options , ns ) ) { <S2SV_EndBug> ",<S2SV_ModStart> sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ; 
120,<S2SV_StartBug> SSL_USE_ETM ( s ) ) ) { <S2SV_EndBug> ,<S2SV_ModStart> s -> tlsext_use_etm <S2SV_ModEnd> 
121,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
122,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> msg -> msg_namelen = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> 
123,"<S2SV_StartBug> static bool tailmatch ( const char * little , const char * bigone ) <S2SV_EndBug> <S2SV_StartBug> size_t littlelen = strlen ( little ) ; <S2SV_EndBug> <S2SV_StartBug> size_t biglen = strlen ( bigone ) ; <S2SV_EndBug> <S2SV_StartBug> if ( littlelen > biglen ) <S2SV_EndBug> <S2SV_StartBug> return Curl_raw_equal ( little , bigone + biglen - littlelen ) ? TRUE : FALSE ; <S2SV_EndBug> ","<S2SV_ModStart> cooke_domain <S2SV_ModEnd> <S2SV_ModStart> hostname <S2SV_ModEnd> <S2SV_ModStart> cookie_domain_len <S2SV_ModEnd> <S2SV_ModStart> cooke_domain <S2SV_ModEnd> <S2SV_ModStart> hostname_len <S2SV_ModEnd> <S2SV_ModStart> hostname <S2SV_ModEnd> <S2SV_ModStart> hostname_len < cookie_domain_len <S2SV_ModEnd> <S2SV_ModStart> if ( ! Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> "
124,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> seg -> update_map = 0 ; seg -> update_data = 0 ; 
125,<S2SV_StartBug> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { <S2SV_EndBug> <S2SV_StartBug> if ( unix_sock_count ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
126,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
127,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> source -> id = 0 ; 
128,<S2SV_StartBug> if ( user -> uid_keyring ) { <S2SV_EndBug> ,<S2SV_ModStart> && user -> session_keyring 
129,<S2SV_StartBug> for ( i = 0 ; mechbuf [ i ] ; i ++ ) mechbuf [ i ] = tolower ( mechbuf [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; log_debug ( ZONE , ""sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)"" , mechbuf "
130,"<S2SV_StartBug> static void __evtchn_fifo_handle_events ( unsigned cpu , bool drop ) <S2SV_EndBug> <S2SV_StartBug> consume_one_event ( cpu , control_block , q , & ready , drop ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct evtchn_loop_ctrl * ctrl <S2SV_ModEnd> <S2SV_ModStart> ctrl , <S2SV_ModStart>  <S2SV_ModEnd> "
131,"<S2SV_StartBug> if ( spwd && spwd -> sp_expire > 0 && <S2SV_EndBug> <S2SV_StartBug> ( request -> timestamp / 86400 ) > spwd -> sp_expire ) { <S2SV_EndBug> <S2SV_StartBug> radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> sp_lstchg > 0 && spwd -> sp_max >= <S2SV_ModEnd> <S2SV_ModStart> ( spwd -> sp_lstchg + spwd -> sp_max ) ) { radlog_request ( L_AUTH , 0 , request , ""[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired"" , name ) ; return RLM_MODULE_REJECT ; } if ( spwd && <S2SV_ModStart> > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire <S2SV_ModStart> ""[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired"" <S2SV_ModEnd> "
132,<S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> ,<S2SV_ModStart> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> 
133,"<S2SV_StartBug> case 'l' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case 'i' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ; break ; <S2SV_EndBug> ",<S2SV_ModStart> { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> } <S2SV_ModStart> { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> } 
134,"<S2SV_StartBug> uint8_t i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Sel:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u"" <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
135,"<S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } "
136,<S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> ,<S2SV_ModStart> unconditional ( e <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
137,"<S2SV_StartBug> struct { <S2SV_EndBug> <S2SV_StartBug> if ( ip_options_echo ( & replyopts . opt , skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( replyopts . opt . optlen ) { <S2SV_EndBug> <S2SV_StartBug> if ( ipc . opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> daddr = replyopts . opt . faddr ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_data <S2SV_ModEnd> <S2SV_ModStart> . opt <S2SV_ModStart> opt . <S2SV_ModStart> replyopts . opt . opt . <S2SV_ModEnd> <S2SV_ModStart> . opt 
138,<S2SV_StartBug> struct svc_rqst * rqstp = vrqstp ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; struct net * net = & init_net ; struct lockd_net * ln = net_generic ( net , lockd_net_id ) <S2SV_ModStart> cancel_delayed_work_sync ( & ln -> grace_period_end ) ; locks_end_grace ( & ln -> lockd_manager ) ; "
139,"<S2SV_StartBug> ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> if ( cp == NULL ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } "
140,"<S2SV_StartBug> # line 94 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 95 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 96 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 97 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 100 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 99 ""hex_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 98 ""hex_grammar.y"" <S2SV_EndBug> ","<S2SV_ModStart> 101 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> <S2SV_ModStart> 102 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> <S2SV_ModStart> 103 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> <S2SV_ModStart> 104 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> <S2SV_ModStart> 107 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> <S2SV_ModStart> 106 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> <S2SV_ModStart> 105 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> "
141,<S2SV_StartBug> pch -> chan_net = net ; <S2SV_EndBug> ,<S2SV_ModStart> get_net ( net ) <S2SV_ModEnd> 
142,<S2SV_StartBug> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + <S2SV_EndBug> <S2SV_StartBug> image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> ,<S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor <S2SV_ModStart> floor 
143,<S2SV_StartBug> offset = saio -> offsets [ 0 ] + moof_offset ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( saio -> offsets && saio -> entry_count ) { <S2SV_ModStart> saio = NULL ; } <S2SV_ModStart> saiz = NULL ; 
144,<S2SV_StartBug> int target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> <S2SV_StartBug> cpi -> key_frame_frequency == 0 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> pass == 0 && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> ,"<S2SV_ModStart> avg_frame_bandwidth ; const int layer = LAYER_IDS_TO_IDX ( cpi -> svc . spatial_layer_id , cpi -> svc . temporal_layer_id , cpi -> svc . number_temporal_layers ) <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> oxcf . key_freq <S2SV_ModEnd> <S2SV_ModStart> is_two_pass_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; reset_temporal_layer_to_zero ( cpi ) ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } } else { cm -> frame_type = INTER_FRAME ; if ( is_two_pass_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } cpi -> ref_frame_flags &= ( ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; } target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; } } if ( <S2SV_ModEnd> <S2SV_ModStart> aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; <S2SV_ModEnd> "
145,"<S2SV_StartBug> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <S2SV_EndBug> <S2SV_StartBug> ! memcmp ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> <S2SV_StartBug> memcpy ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> ",<S2SV_ModStart> msg_sys -> msg_name && <S2SV_ModStart> msg_sys <S2SV_ModEnd> <S2SV_ModStart> if ( msg_sys -> msg_name ) <S2SV_ModStart> msg_sys <S2SV_ModEnd> 
146,"<S2SV_StartBug> static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> 
147,"<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num , state . sumlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ; "
148,"<S2SV_StartBug> send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
149,<S2SV_StartBug> * ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> _x2c <S2SV_ModEnd> 
150,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> case RMT_NONE : break ; 
151,"<S2SV_StartBug> static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int mi_col , BLOCK_SIZE bsize , int * rate , <S2SV_EndBug> <S2SV_StartBug> int64_t * dist , int do_recon , int64_t best_rd ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize >= cpi -> sf . min_partition_size ) ; <S2SV_EndBug> <S2SV_StartBug> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize > cpi -> sf . min_partition_size ) || <S2SV_EndBug> <S2SV_StartBug> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> bsize > cpi -> sf . min_partition_size ) || <S2SV_EndBug> <S2SV_StartBug> do_split &= bsize > cpi -> sf . min_partition_size ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( this_rate != INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t stop_thresh = 4096 ; <S2SV_EndBug> <S2SV_StartBug> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> <S2SV_StartBug> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , <S2SV_EndBug> <S2SV_StartBug> subsize , & this_rate , & this_dist , 0 , <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . less_rectangular_check ) <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( this_rate == INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( this_rate == INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rate == INT_MAX ) <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> <S2SV_StartBug> best_rate ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_64X64 ) { <S2SV_EndBug> <S2SV_StartBug> assert ( best_rate < INT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_dist < INT64_MAX ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost , <S2SV_ModEnd> <S2SV_ModStart> , PC_TREE * pc_tree ) { const SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModEnd> <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> & pc_tree -> none <S2SV_ModEnd> <S2SV_ModStart> = bsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> <S2SV_ModEnd> <S2SV_ModStart> x -> min_partition_size ; } if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> ctx -> pred_pixel_ready = ! ( partition_vert_allowed || partition_horz_allowed || do_split ) <S2SV_ModEnd> <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , bsize , ctx ) ; ctx <S2SV_ModEnd> <S2SV_ModStart> ctx -> mbmi_ext = * x -> mbmi_ext ; ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; ctx -> skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate , this_rdc . dist ) ; if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> dist_breakout_thr = sf -> partition_search_breakout_dist_thr ; int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ; dist_breakout_thr <S2SV_ModEnd> <S2SV_ModStart> rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; best_rdc = this_rdc ; if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate < rate_breakout_thr && this_rdc . dist < dist_breakout_thr <S2SV_ModEnd> <S2SV_ModStart> } store_pred_mv ( x , ctx ) ; if ( do_split <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> ; sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) <S2SV_ModStart> sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td , tile_data <S2SV_ModEnd> <S2SV_ModStart> this_rdc , 0 , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> <S2SV_ModStart> sf -> <S2SV_ModEnd> <S2SV_ModStart> if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ; <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) <S2SV_ModEnd> <S2SV_ModStart> if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ; <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) ; } } * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> { vp9_rd_cost_reset ( rd_cost ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart> pc_tree ) ; if ( best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> best_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> encode_sb_rt ( cpi , td , tile_info , tp <S2SV_ModEnd> <S2SV_ModStart> bsize , pc_tree <S2SV_ModEnd> <S2SV_ModStart> && do_recon <S2SV_ModStart> best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> best_rdc . dist <S2SV_ModEnd> "
152,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * tptr , 1 ) ) <S2SV_EndBug> ",<S2SV_ModStart> 2 <S2SV_ModEnd> 
153,"<S2SV_StartBug> static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf ) <S2SV_EndBug> ","<S2SV_ModStart> ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; <S2SV_ModEnd> <S2SV_ModStart> ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> "
154,<S2SV_StartBug> __enable_irq ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> FLASH -> CR |= FLASH_CR_OBL_LAUNCH ; while ( true <S2SV_ModEnd> 
155,<S2SV_StartBug> size_t val_len ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 
156,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> 
157,<S2SV_StartBug> addr -> sap_family = AF_ATMPVC ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( addr , 0 , sizeof ( * addr ) ) ; "
158,<S2SV_StartBug> else <S2SV_EndBug> ,"<S2SV_ModStart> else if ( strcmp ( filetype [ i ] . ext , "".SVG"" ) == 0 ) { rsprintf ( ""Content-Type:<S2SV_blank>%s\\r\\n"" , filetype [ i ] . type ) ; if ( strrchr ( file_name , '/' ) ) strlcpy ( str , strrchr ( file_name , '/' ) + 1 , sizeof ( str ) ) ; else strlcpy ( str , file_name , sizeof ( str ) ) ; if ( str [ 6 ] == '_' && str [ 13 ] == '_' ) rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , str + 14 ) ; else rsprintf ( ""Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\""%s\\""\\r\\n"" , str ) ; } "
159,<S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ; "
160,<S2SV_StartBug> long elements ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( * p >= max - 2 ) { zend_error ( E_WARNING , ""Bad<S2SV_blank>unserialize<S2SV_blank>data"" ) ; return - 1 ; } <S2SV_ModStart> - 1 <S2SV_ModEnd> "
161,<S2SV_StartBug> token ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false "
162,<S2SV_StartBug> void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) <S2SV_EndBug> <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> WORD32 <S2SV_ModEnd> <S2SV_ModStart> if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> return 0 ; 
163,<S2SV_StartBug> int row8x8_remaining = tile -> mi_row_end - mi_row ; <S2SV_EndBug> <S2SV_StartBug> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_EndBug> <S2SV_StartBug> for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) { <S2SV_EndBug> ,"<S2SV_ModStart> const <S2SV_ModStart> const <S2SV_ModStart> set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , bsize , mi_8x8 ) ; <S2SV_ModEnd> "
164,<S2SV_StartBug> if ( info . si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> ,<S2SV_ModStart> != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> <S2SV_ModStart> } 
165,<S2SV_StartBug> else if ( verify & GNUTLS_CERT_INVALID ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } if ( error == NULL ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
166,"<S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
167,"<S2SV_StartBug> if ( ( opt_len != mp_dss_len ( mdss , 1 ) && <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_A ) { <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_a ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_m ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len == mp_dss_len ( mdss , 1 ) ) <S2SV_EndBug> ","<S2SV_ModStart> opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> <S2SV_ModStart> opt_len -= 4 ; <S2SV_ModStart> if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt_len -= 8 ; <S2SV_ModStart> if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> opt_len -= 4 ; <S2SV_ModStart> if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt_len -= 8 ; <S2SV_ModStart> if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> <S2SV_ModStart> opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> "
168,"<S2SV_StartBug> fprintf ( fpfile , ""%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f"" <S2SV_EndBug> <S2SV_StartBug> stats -> intra_error , <S2SV_EndBug> <S2SV_StartBug> stats -> ssim_weighted_pred_err , <S2SV_EndBug> <S2SV_StartBug> stats -> pcnt_neutral , <S2SV_EndBug> ","<S2SV_ModStart> ""%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf"" ""%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf\\n"" <S2SV_ModEnd> <S2SV_ModStart> weight , stats -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , stats -> intra_skip_pct , stats -> inactive_zone_rows , stats -> inactive_zone_cols "
169,<S2SV_StartBug> int_fb -> in_use = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( int_fb ) 
170,<S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> ,"<S2SV_ModStart> uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ; return 0 ; } "
171,<S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> "
172,<S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> ds = salg -> digestsize ; <S2SV_EndBug> <S2SV_StartBug> ss = salg -> statesize ; <S2SV_EndBug> ,<S2SV_ModStart> alg = & salg -> base ; <S2SV_ModStart> if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart>  <S2SV_ModEnd> 
173,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc32 ( tif , cp0 , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
174,<S2SV_StartBug> if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { <S2SV_EndBug> ,<S2SV_ModStart> ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if ( 
175,<S2SV_StartBug> struct cred * cred ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cred ) <S2SV_EndBug> <S2SV_StartBug> return create_user_ns ( cred ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; int err = - ENOMEM <S2SV_ModStart> cred ) { err = create_user_ns ( cred ) ; if ( err ) put_cred ( cred ) ; else <S2SV_ModEnd> <S2SV_ModStart> } return err <S2SV_ModEnd> 
176,<S2SV_StartBug> if ( peer ) { <S2SV_EndBug> ,<S2SV_ModStart> lsa -> l2tp_unused = 0 ; 
177,<S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug> ,<S2SV_ModStart> 62 <S2SV_ModEnd> 
178,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( ! inet -> opt || ! inet -> opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct ip_options_rcu * inet_opt <S2SV_ModStart> inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt || ! inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> "
179,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
180,<S2SV_StartBug> if ( test_tsk_need_resched ( rq -> curr ) ) <S2SV_EndBug> ,<S2SV_ModStart> rq -> curr -> se . on_rq && 
181,<S2SV_StartBug> dh_clnt = EVP_PKEY_get0_DH ( ckey ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } "
182,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
183,"<S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
184,"<S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) <S2SV_EndBug> <S2SV_StartBug> if ( count < sysex . len ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sysex , addr , hdr_size <S2SV_ModEnd> <S2SV_ModStart> ( unsigned ) count < ( unsigned ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
185,<S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> } else { close ( sr -> fd_file ) ; } 
186,<S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> rdev -> ena_pin = NULL ; return ; 
187,<S2SV_StartBug> int chars_processed ; <S2SV_EndBug> <S2SV_StartBug> int data_size = ndo -> ndo_snapend - bp ; <S2SV_EndBug> <S2SV_StartBug> chars_processed = 1 ; <S2SV_EndBug> <S2SV_StartBug> cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; <S2SV_EndBug> <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> <S2SV_StartBug> chars_processed += l ; <S2SV_EndBug> <S2SV_StartBug> chars_processed ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < <S2SV_ModEnd> <S2SV_ModStart> ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> <S2SV_ModStart> offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , ""<BAD<S2SV_blank>PTR>"" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
188,<S2SV_StartBug> if ( ! valid_localpart ( maddr -> user ) || <S2SV_EndBug> <S2SV_StartBug> ! valid_domainpart ( maddr -> domain ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> mailfrom && maddr -> user [ 0 ] == '\\0' && maddr -> domain [ 0 ] == '\\0' ) return ( 1 ) ; if ( maddr -> user [ 0 ] == '\\0' || <S2SV_ModStart> ) return ( 0 ) ; if ( maddr -> domain [ 0 ] == '\\0' ) { ( void ) strlcpy ( maddr -> domain , domain , sizeof ( maddr -> domain ) ) ; } if ( <S2SV_ModEnd> <S2SV_ModStart> return ( 0 ) ; <S2SV_ModEnd> "
189,"<S2SV_StartBug> return send ( socket -> fd , buf , count , MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
190,"<S2SV_StartBug> static int input_stats ( struct twopass_rc * p , FIRSTPASS_STATS * fps ) { <S2SV_EndBug> ",<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> 
191,<S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> ,<S2SV_ModStart> * prev = vma ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
192,<S2SV_StartBug> if ( image -> debug != MagickFalse ) <S2SV_EndBug> ,"<S2SV_ModStart> EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ; } if ( "
193,<S2SV_StartBug> struct static_key * done_key ) <S2SV_EndBug> <S2SV_StartBug> __net_random_once_disable_jump ( done_key ) ; <S2SV_EndBug> ,<S2SV_ModStart> once_key <S2SV_ModEnd> <S2SV_ModStart> once_key <S2SV_ModEnd> 
194,"
","
"
195,"<S2SV_StartBug> unsigned int var = block_variance ( cpi , x , bs ) ; <S2SV_EndBug> ",<S2SV_ModStart> double energy_midpoint ; vpx_clear_system_state ( ) ; energy_midpoint = ( cpi -> oxcf . pass == 2 ) ? cpi -> twopass . mb_av_energy : DEFAULT_E_MIDPOINT ; energy = vp9_log_block_var <S2SV_ModEnd> <S2SV_ModStart> - energy_midpoint <S2SV_ModEnd> 
196,"<S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
197,<S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( srose , 0 , msg -> msg_namelen ) ; "
198,"<S2SV_StartBug> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <S2SV_EndBug> <S2SV_StartBug> if ( ! options ) { <S2SV_EndBug> <S2SV_StartBug> case ecryptfs_opt_err : <S2SV_EndBug> ","<S2SV_ModStart> , uid_t * check_ruid <S2SV_ModStart> * check_ruid = 0 ; <S2SV_ModStart> ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case "
199,"<S2SV_StartBug> cJSON_AddFloatToObject ( j , ""cpu_util_total"" , test -> cpu_util [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddFloatToObject ( j , ""cpu_util_user"" , test -> cpu_util [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddFloatToObject ( j , ""cpu_util_system"" , test -> cpu_util [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j , ""sender_has_retransmits"" , sender_has_retransmits ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""id"" , sp -> id ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""bytes"" , bytes_transferred ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""retransmits"" , retransmits ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddFloatToObject ( j_stream , ""jitter"" , sp -> jitter ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""errors"" , sp -> cnt_error ) ; <S2SV_EndBug> <S2SV_StartBug> cJSON_AddIntToObject ( j_stream , ""packets"" , sp -> packet_count ) ; <S2SV_EndBug> ",<S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> <S2SV_ModStart> cJSON_AddNumberToObject <S2SV_ModEnd> 
200,"<S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
201,<S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> ,<S2SV_ModStart> u64 <S2SV_ModEnd> <S2SV_ModStart> u64 <S2SV_ModEnd> <S2SV_ModStart> if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; 
202,"<S2SV_StartBug> int64_t tx_cache [ TX_MODES ] , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion , <S2SV_EndBug> <S2SV_StartBug> & s , NULL , bsize , local_tx_cache , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> * bmode_costs ; const MODE_INFO * above_mi = xd -> above_mi ; const MODE_INFO * left_mi = xd -> left_mi ; const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ; const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ; bmode_costs = cpi <S2SV_ModEnd> <S2SV_ModStart> memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { if ( cpi -> sf . use_nonrd_pick_mode ) { if ( conditional_skipintra ( mode , mode_selected ) ) continue ; if ( * skippable ) break ; <S2SV_ModStart> super_block_yrd <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
203,<S2SV_StartBug> CurrentColorSpace = ColorSpaceOut ; <S2SV_EndBug> <S2SV_StartBug> cmsPipelineFree ( Lut ) ; <S2SV_EndBug> ,<S2SV_ModStart> Lut = NULL ; <S2SV_ModStart> if ( Lut != NULL ) 
204,"<S2SV_StartBug> len = curl_msnprintf ( fptr , left , ""%ld"" , width ) ; <S2SV_EndBug> <S2SV_StartBug> len = curl_msnprintf ( fptr , left , "".%ld"" , prec ) ; <S2SV_EndBug> <S2SV_StartBug> for ( fptr = work ; * fptr ; fptr ++ ) <S2SV_EndBug> ",<S2SV_ModStart> if ( width >= ( long ) sizeof ( work ) ) width = sizeof ( work ) - 1 ; <S2SV_ModStart> size_t maxprec = sizeof ( work ) - 2 ; double val = p -> data . dnum ; while ( val >= 10.0 ) { val /= 10 ; maxprec -- ; } if ( prec > ( long ) maxprec ) prec = maxprec - 1 ; <S2SV_ModStart> # ifdef CURLDEBUG assert ( strlen ( work ) <= sizeof ( work ) ) ; # endif 
205,<S2SV_StartBug> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <S2SV_EndBug> ,<S2SV_ModStart> ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH ) 
206,<S2SV_StartBug> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> return 0 ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
207,<S2SV_StartBug> CollSeq * p4 ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( pParse -> nErr ) return 0 
208,"<S2SV_StartBug> mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
209,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> memset ( p , 0 , sizeof ( * p ) ) ; "
210,<S2SV_StartBug> continue ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( len >= FPM_LOG_BUFFER ) { zlog ( ZLOG_NOTICE , ""the<S2SV_blank>log<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>full<S2SV_blank>(%d).<S2SV_blank>The<S2SV_blank>access<S2SV_blank>log<S2SV_blank>request<S2SV_blank>has<S2SV_blank>been<S2SV_blank>truncated."" , FPM_LOG_BUFFER ) ; len = FPM_LOG_BUFFER ; break ; } "
211,"<S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) { <S2SV_EndBug> ","<S2SV_ModStart> caller_may_see_dir ( fc -> pid , controller , path1 ) ) { ret = - ENOENT ; goto out ; } if ( ! "
212,"<S2SV_StartBug> CYCLIC_REFRESH * vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> return cr ; <S2SV_EndBug> ","<S2SV_ModStart> size_t last_coded_q_map_size ; <S2SV_ModStart> last_coded_q_map_size = mi_rows * mi_cols * sizeof ( * cr -> last_coded_q_map ) ; cr -> last_coded_q_map = vpx_malloc ( last_coded_q_map_size ) ; if ( cr -> last_coded_q_map == NULL ) { vpx_free ( cr ) ; return NULL ; } assert ( MAXQ <= 255 ) ; memset ( cr -> last_coded_q_map , MAXQ , last_coded_q_map_size ) ; "
213,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_MWCMDX , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> DM9000_INDEX_REG = DM9000_REG_MWCMD ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_TXPLL , LSB ( length ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_TXPLH , MSB ( length ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_MWCMDX <S2SV_ModEnd> <S2SV_ModStart> DM9000_MWCMD <S2SV_ModEnd> <S2SV_ModStart> DM9000_TXPLL <S2SV_ModEnd> <S2SV_ModStart> DM9000_TXPLH <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR , DM9000_ISR_PT ) ; dm9000WriteReg ( DM9000_TCR , DM9000_TCR_TXREQ <S2SV_ModEnd> "
214,<S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> ,"<S2SV_ModStart> uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpContig2SeparateByRow"" ) ; return 0 ; } "
215,<S2SV_StartBug> if ( ! SSL_USE_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL ) <S2SV_EndBug> ,<S2SV_ModStart> SSL_READ_ETM <S2SV_ModEnd> 
216,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; } "
217,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> ) ; rcu_read_unlock ( <S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , <S2SV_ModEnd> <S2SV_ModStart> ) ; rcu_read_unlock ( "
218,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 
219,"<S2SV_StartBug> pynum = parsenumber ( c , s ) ; <S2SV_EndBug> ",<S2SV_ModStart> STR ( ch ) <S2SV_ModEnd> 
220,"<S2SV_StartBug> udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; <S2SV_EndBug> <S2SV_StartBug> brelse ( bh ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = <S2SV_ModStart> , PAGE_SIZE <S2SV_ModStart> ; if ( err ) goto out_unlock_inode "
221,<S2SV_StartBug> const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ; <S2SV_EndBug> ,<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> 
222,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
223,"<S2SV_StartBug> env = g_environ_setenv ( env , var , val , TRUE ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( var [ 0 ] == '\\0' ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>empty<S2SV_blank>name"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( strchr ( var , '=' ) != NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Environment<S2SV_blank>variable<S2SV_blank>name<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\'=\'"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_string_append ( env_string , var ) ; g_string_append_c ( env_string , '=' ) ; g_string_append ( env_string , val ) ; g_string_append_c ( env_string , '\\0' <S2SV_ModEnd> "
224,<S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> ,<S2SV_ModStart> errout_free <S2SV_ModEnd> <S2SV_ModStart> errout_free : 
225,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%(2*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
226,"<S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & kctl -> id ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart>  <S2SV_ModEnd> 
227,"<S2SV_StartBug> ""InvalidGeometry"" , ""`%s\'"" , option ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; geometry = DestroyString ( geometry 
228,"<S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> arpt_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
229,<S2SV_StartBug> if ( user_alloc && ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size "
230,"<S2SV_StartBug> size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tail = <S2SV_ModEnd> <S2SV_ModStart> ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail "
231,<S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> <S2SV_StartBug> ipc . opt = inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( ipc . opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> daddr = ipc . opt -> faddr ; <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_data opt_copy ; <S2SV_ModStart> { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . "
232,<S2SV_StartBug> img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ,<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
233,<S2SV_StartBug> static void follow_dotdot ( struct nameidata * nd ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <S2SV_ModStart> return 0 ; 
234,<S2SV_StartBug> else if ( rc == - ENODATA ) <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> ,<S2SV_ModStart> && inode -> i_op -> removexattr ) { <S2SV_ModEnd> <S2SV_ModStart> } 
235,<S2SV_StartBug> MP4_READBOX_ENTER ( MP4_Box_data_string_t ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( p_box -> i_size < 8 || p_box -> i_size > SIZE_MAX ) MP4_READBOX_EXIT ( 0 
236,"<S2SV_StartBug> u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> switch ( num ) { <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 3 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x10 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x08 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , <S2SV_EndBug> <S2SV_StartBug> ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x09 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 3 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , <S2SV_EndBug> <S2SV_StartBug> ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & d -> i2c_mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dw2102_state * state <S2SV_ModEnd> <S2SV_ModStart> state = d -> priv ; <S2SV_ModStart> if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> data_mutex ) ; mutex_unlock ( & d -> "
237,"<S2SV_StartBug> if ( yych != ':' ) goto yy18 ; <S2SV_EndBug> <S2SV_StartBug> # line 804 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 836 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 881 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 936 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 989 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1086 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1161 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1214 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1228 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1237 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1285 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1334 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> ",<S2SV_ModStart> <= '/' ) goto yy18 ; if ( yych >= ';' <S2SV_ModEnd> <S2SV_ModStart> 805 <S2SV_ModEnd> <S2SV_ModStart> 837 <S2SV_ModEnd> <S2SV_ModStart> 882 <S2SV_ModEnd> <S2SV_ModStart> 937 <S2SV_ModEnd> <S2SV_ModStart> 990 <S2SV_ModEnd> <S2SV_ModStart> 1087 <S2SV_ModEnd> <S2SV_ModStart> 1162 <S2SV_ModEnd> <S2SV_ModStart> 1215 <S2SV_ModEnd> <S2SV_ModStart> 1229 <S2SV_ModEnd> <S2SV_ModStart> 1238 <S2SV_ModEnd> <S2SV_ModStart> 1286 <S2SV_ModEnd> <S2SV_ModStart> 1335 <S2SV_ModEnd> 
238,"<S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & timeri -> timer -> lock ) ; } 
239,<S2SV_StartBug> int n = * pnEntry ; <S2SV_EndBug> <S2SV_StartBug> int sz = ( n == 0 ) ? 1 : 2 * n ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> 
240,<S2SV_StartBug> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) <S2SV_EndBug> ,<S2SV_ModStart> fp && 
241,<S2SV_StartBug> sbi -> s_mb_cache = ext4_xattr_create_cache ( sb -> s_id ) ; <S2SV_EndBug> <S2SV_StartBug> failed_mount_wq : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } 
242,"<S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> ? ( plane == 0 ? mi -> bmi [ block ] . as_mv [ ref ] . as_mv <S2SV_EndBug> <S2SV_StartBug> if ( vp9_is_scaled ( sf ) ) { <S2SV_EndBug> <S2SV_StartBug> inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , <S2SV_EndBug> <S2SV_StartBug> subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ; <S2SV_EndBug> ","<S2SV_ModStart> vp9_filter_kernels [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModEnd> <S2SV_ModStart> average_split_mvs ( pd , mi , ref , block <S2SV_ModEnd> <S2SV_ModStart> const int is_scaled = vp9_is_scaled ( sf ) ; if ( is_scaled <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { high_inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys , xd -> bd ) ; } else { <S2SV_ModStart> } # else inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ; # endif "
243,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ; <S2SV_ModStart> i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ; "
244,<S2SV_StartBug> assert ( caplen > 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
245,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * s , 1 ) ; "
246,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ; 
247,<S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
248,<S2SV_StartBug> mutex_unlock ( & file -> mut ) ; <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ; "
249,"<S2SV_StartBug> timeri = list_entry ( timer -> open_list_head . next , <S2SV_EndBug> <S2SV_StartBug> if ( timeri -> flags & SNDRV_TIMER_IFLG_EXCLUSIVE ) { <S2SV_EndBug> <S2SV_StartBug> err = - EBUSY ; <S2SV_EndBug> ",<S2SV_ModStart> struct snd_timer_instance * t = <S2SV_ModEnd> <S2SV_ModStart> t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
250,<S2SV_StartBug> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
251,"<S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> return true ; 
252,"<S2SV_StartBug> int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; <S2SV_EndBug> <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 , format_chunk <S2SV_ModStart> if ( format_chunk ++ ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
253,<S2SV_StartBug> l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ; 
254,"<S2SV_StartBug> if ( JAS_CAST ( uint , jas_stream_read ( in , ppm -> data , ppm -> len ) ) != ppm -> len ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_uint <S2SV_ModEnd> 
255,"<S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> 
256,<S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> <S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
257,<S2SV_StartBug> if ( key -> type -> destroy ) <S2SV_EndBug> ,"<S2SV_ModStart> test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && "
258,"<S2SV_StartBug> int mi_row ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ; <S2SV_EndBug> <S2SV_StartBug> log_frame_info ( cm , descriptor , file ) ; <S2SV_EndBug> <S2SV_StartBug> * ( ( int * ) ( ( char * ) ( & mi_8x8 [ mi_index ] -> mbmi ) + <S2SV_EndBug> <S2SV_StartBug> mi_index ++ ; <S2SV_EndBug> <S2SV_StartBug> mi_index += 8 ; <S2SV_EndBug> ","<S2SV_ModStart> , mi_col <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi [ 0 <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> "
259,"<S2SV_StartBug> FIRSTPASS_STATS this_frame ; <S2SV_EndBug> <S2SV_StartBug> if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF ) <S2SV_EndBug> <S2SV_StartBug> accumulate_frame_motion_stats ( & this_frame , <S2SV_EndBug> <S2SV_StartBug> decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * <S2SV_EndBug> <S2SV_StartBug> calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( read_frame_stats ( twopass , & this_frame , ( i + offset ) ) == EOF ) <S2SV_EndBug> <S2SV_StartBug> accumulate_frame_motion_stats ( & this_frame , <S2SV_EndBug> <S2SV_StartBug> decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , & this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * <S2SV_EndBug> <S2SV_StartBug> calc_frame_boost ( cpi , & this_frame , this_frame_mv_in_out ) ) ; <S2SV_EndBug> <S2SV_StartBug> arf_boost = ( ( b_frames + f_frames ) * 20 ) ; <S2SV_EndBug> ","<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ; if ( this_frame == NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi , <S2SV_ModEnd> <S2SV_ModStart> decay_accumulator * <S2SV_ModEnd> <S2SV_ModStart> this_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> <S2SV_ModStart> const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ; if ( this_frame == NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi , <S2SV_ModEnd> <S2SV_ModStart> decay_accumulator * <S2SV_ModEnd> <S2SV_ModStart> this_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> <S2SV_ModStart> ) ; arf_boost = MAX ( arf_boost , MIN_ARF_GF_BOOST "
260,"<S2SV_StartBug> emsg ( _ ( ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>and<S2SV_blank>some<S2SV_blank>functionality<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" <S2SV_ModEnd> "
261,<S2SV_StartBug> goto read_error ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
262,"<S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . hev_thr , ( lvl >> 4 ) , SIMD_WIDTH ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
263,"<S2SV_StartBug> static void print_bpf_insn ( struct bpf_insn * insn ) <S2SV_EndBug> <S2SV_StartBug> } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) { <S2SV_EndBug> <S2SV_StartBug> insn -> code , insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> ","<S2SV_ModStart> const struct bpf_verifier_env * env , const <S2SV_ModStart> && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( ""(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n"" , insn -> code , <S2SV_ModEnd> <S2SV_ModStart> ( unsigned long long ) <S2SV_ModEnd> "
264,"<S2SV_StartBug> static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref , <S2SV_EndBug> <S2SV_StartBug> ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_tree <S2SV_ModEnd> 
265,"<S2SV_StartBug> virCheckDomainReturn ( dom , - 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error "
266,<S2SV_StartBug> if ( ! data ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> || len < 2 ) { <S2SV_ModEnd> <S2SV_ModStart> } 
267,"<S2SV_StartBug> const char * value = NULL ; <S2SV_EndBug> <S2SV_StartBug> cib_client_t * client = data ; <S2SV_EndBug> <S2SV_StartBug> command = crm_recv_remote_msg ( client -> session , client -> encrypted ) ; <S2SV_EndBug> <S2SV_StartBug> value = crm_element_name ( command ) ; <S2SV_EndBug> <S2SV_StartBug> crm_xml_add ( command , F_CIB_USER , client -> user ) ; <S2SV_EndBug> <S2SV_StartBug> crm_xml_add ( command , F_CIB_CALLID , call_uuid ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; int disconnected = 0 ; int timeout = client -> remote_auth ? - 1 : 1000 <S2SV_ModStart> # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> encrypted && ( client -> handshake_complete == FALSE ) ) { int rc = 0 ; do { rc = gnutls_handshake ( * <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc < 0 && rc != GNUTLS_E_AGAIN ) { crm_err ( ""Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>failed"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } while ( rc == GNUTLS_E_INTERRUPTED ) ; if ( rc == 0 ) { crm_debug ( ""Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>completed"" ) ; client -> handshake_complete = TRUE ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , client ) ; } return 0 ; } # endif crm_recv_remote_msg ( client -> session , & client -> recv_buf , client -> encrypted , timeout , & disconnected ) ; if ( client -> remote_auth == FALSE ) { xmlNode * reg <S2SV_ModEnd> <S2SV_ModStart> const char * user = NULL ; # endif command = crm_parse_remote_buffer ( & client -> recv_buf ) ; if ( cib_remote_auth ( command ) == FALSE ) { free_xml ( command ) ; return - 1 ; } crm_debug ( ""remote<S2SV_blank>connection<S2SV_blank>authenticated<S2SV_blank>successfully"" ) ; client -> remote_auth = TRUE ; g_source_remove ( client -> remote_auth_timeout ) ; client -> remote_auth_timeout = 0 ; client -> name = crm_element_value_copy ( command , ""name"" ) ; # if ENABLE_ACL user = crm_element_value ( command , ""user"" ) ; if ( user ) { new_client -> user = strdup ( user ) ; } # endif reg = create_xml_node ( NULL , ""cib_result"" <S2SV_ModEnd> <S2SV_ModStart> reg , F_CIB_OPERATION , CRM_OP_REGISTER ) ; crm_xml_add ( reg , F_CIB_CLIENTID , client -> id ) ; crm_send_remote_msg ( client -> session , reg , client -> encrypted ) ; free_xml ( reg ) ; free_xml ( command ) ; } command = crm_parse_remote_buffer ( & client -> recv_buf ) ; while ( command ) { crm_trace ( ""command<S2SV_blank>received"" ) ; cib_handle_remote_msg ( client , command ) ; free_xml ( command ) ; command = crm_parse_remote_buffer ( & client -> recv_buf ) ; } if ( disconnected ) { crm_trace ( ""disconnected<S2SV_blank>while<S2SV_blank>receiving<S2SV_blank>remote<S2SV_blank>cib<S2SV_blank>msg."" ) ; return - 1 ; } return <S2SV_ModEnd> "
268,"<S2SV_StartBug> if ( ! ( self -> mt_used * 3 >= ( self -> mt_mask + 1 ) * 2 ) ) <S2SV_EndBug> <S2SV_StartBug> return _PyMemoTable_ResizeTable ( self , <S2SV_EndBug> <S2SV_StartBug> ( self -> mt_used > 50000 ? 2 : 4 ) * self -> mt_used ) ; <S2SV_EndBug> ","<S2SV_ModStart> SIZE_MAX / 3 >= self -> mt_used && <S2SV_ModEnd> <S2SV_ModStart> < self -> mt_allocated <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> } size_t desired_size = <S2SV_ModEnd> <S2SV_ModStart> ; return _PyMemoTable_ResizeTable ( self , desired_size "
269,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
270,"<S2SV_StartBug> vpx_memset ( segment_counts , 0 , sizeof ( segment_counts ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
271,"<S2SV_StartBug> const char command5 [ ] = { 0x05 , 0x00 } ; <S2SV_EndBug> <S2SV_StartBug> close ( s ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <S2SV_ModStart> if ( n == 0 ) { <S2SV_ModStart> s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ; "
272,<S2SV_StartBug> return self ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ; "
273,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && frame -> linesize [ plane ] 
274,"<S2SV_StartBug> struct flowi4 fl4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! IS_ERR ( rt ) ) <S2SV_EndBug> <S2SV_StartBug> __sk_dst_set ( sk , & rt -> dst ) ; <S2SV_EndBug> ","<S2SV_ModStart> dst_entry * dst ; struct <S2SV_ModStart> rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <S2SV_ModStart> dst || ! dst -> obsolete || dst -> ops -> check ( dst <S2SV_ModEnd> <S2SV_ModStart> { rcu_read_unlock ( ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart> dst = <S2SV_ModEnd> <S2SV_ModStart> ? <S2SV_ModEnd> <S2SV_ModStart> dst : NULL ; sk_dst_set ( sk , "
275,"<S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 15 <S2SV_ModEnd> <S2SV_ModStart> * 3 ; aligned_height = <S2SV_ModEnd> <S2SV_ModStart> + 15 <S2SV_ModEnd> 
276,"<S2SV_StartBug> bool tsonly ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug> ","<S2SV_ModStart> , opt_stats = false <S2SV_ModStart> { <S2SV_ModStart> opt_stats = true ; } <S2SV_ModStart> , opt_stats "
277,<S2SV_StartBug> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <S2SV_EndBug> ,<S2SV_ModStart> 112 <S2SV_ModEnd> 
278,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
279,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } <S2SV_ModEnd> "
280,"<S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <S2SV_EndBug> ",<S2SV_ModStart> CDF_SHORT_SEC_SIZE <S2SV_ModEnd> 
281,"<S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
282,"<S2SV_StartBug> a = 1.0f / MaxF ( w . x , MaxF ( w . y , w . z ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMax ( w . x , MagickMax <S2SV_ModEnd> "
283,"<S2SV_StartBug> static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val ) <S2SV_EndBug> <S2SV_StartBug> ulonglong v ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> <S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
284,<S2SV_StartBug> int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! body -> unit_size ) break ; n 
285,<S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
286,"<S2SV_StartBug> memccpy ( result , ptr , 0 , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
287,"<S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
288,<S2SV_StartBug> ifd ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( len > 2560000 || ! ( cbuf = ( char * ) malloc ( len ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( ifd >= sizeof tiff_ifd / sizeof tiff_ifd [ 0 ] ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif <S2SV_ModStart> < 1 || len 
289,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_queue_exception ( vcpu , UD_VECTOR ) ; <S2SV_EndBug> <S2SV_StartBug> return EMULATE_FAIL ; <S2SV_EndBug> ",<S2SV_ModStart> int r = EMULATE_DONE ; <S2SV_ModStart> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_ModStart> r = EMULATE_FAIL ; } <S2SV_ModStart> r <S2SV_ModEnd> 
290,"<S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } "
291,<S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> 
292,"<S2SV_StartBug> pixs = pixRead ( ""cat.035.jpg"" ) ; <S2SV_EndBug> <S2SV_StartBug> lept_stderr ( ""pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lept_rmdir ( ""lept/dewmod"" ) ; lept_mkdir ( ""lept/dewmod"" ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
293,<S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , ""interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n"" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> err = - EINVAL ; "
294,<S2SV_StartBug> long newpos ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
295,"<S2SV_StartBug> set_header ( res , ""Content-Type"" , mime ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , "
296,"<S2SV_StartBug> int net ; <S2SV_EndBug> <S2SV_StartBug> CLIENT * client ; <S2SV_EndBug> <S2SV_StartBug> if ( ( net = accept ( sock , ( struct sockaddr * ) & addrin , & addrinlen ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> client = negotiate ( net , NULL , servers , NEG_INIT | NEG_MODERN ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> <S2SV_ModStart> serve -> socket <S2SV_ModEnd> <S2SV_ModStart> handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> "
297,<S2SV_StartBug> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> drefs_count = 0 ; sc -> 
298,"<S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 6 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 6 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> bp += 8 ; <S2SV_EndBug> <S2SV_StartBug> len -= 8 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , sizeof ( struct in_addr ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 4 ] , sizeof ( struct in_addr ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( EXTRACT_32BITS ( & bp [ 4 ] ) != 0xffffffff ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""/%s"" , ipaddr_string ( ndo , & bp [ 4 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 8 ] , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> njoin = EXTRACT_16BITS ( & bp [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> nprune = EXTRACT_16BITS ( & bp [ 10 ] ) ; <S2SV_EndBug> <S2SV_StartBug> bp += 12 ; <S2SV_EndBug> <S2SV_StartBug> len -= 12 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( bp [ 0 ] , 6 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len < sizeof ( struct in_addr ) ) goto trunc ; <S2SV_ModStart> bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 ; if ( len < 4 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> if ( len < 4 ) goto trunc ; <S2SV_ModStart> bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 ] ) ) ) ; bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> 4 <S2SV_ModEnd> <S2SV_ModStart> if ( len < 6 ) goto trunc ; 
299,"<S2SV_StartBug> static void sas_destruct_devices ( struct work_struct * work ) <S2SV_EndBug> <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> asd_sas_port * port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
300,"<S2SV_StartBug> int number_bidders , i , bid , best_bid ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , n <S2SV_ModStart> n = 0 ; n < 25 ; ++ n <S2SV_ModEnd> <S2SV_ModStart> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding"" ) ; return ( ARCHIVE_FATAL ) ; "
301,"<S2SV_StartBug> flush_dcache_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> iov_iter_advance ( ii , tmp ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; iov_iter_advance ( ii , tmp <S2SV_ModStart>  <S2SV_ModEnd> "
302,<S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( numSamples <= 0 ) { ALOGE ( ""b/26366256"" ) ; return ; } "
303,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n"" , <S2SV_EndBug> <S2SV_StartBug> txp -> offset , txp -> size ) ; <S2SV_EndBug> ","<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err ( vif -> dev , ""Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif "
304,<S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( r -> iov . iov_base ) { <S2SV_ModStart> } 
305,<S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ) { kfree_skb ( skb ) ; <S2SV_ModStart> } 
306,"<S2SV_StartBug> int ret , n ; <S2SV_EndBug> <S2SV_StartBug> hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; <S2SV_EndBug> <S2SV_StartBug> hid -> country = hdesc -> bCountryCode ; <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) <S2SV_EndBug> ","<S2SV_ModStart> ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> num_descriptors <S2SV_ModEnd> "
307,"<S2SV_StartBug> void vp9_iht16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> <S2SV_StartBug> int16_t out [ 16 * 16 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = out ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 16 ] , temp_out [ 16 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < 16 ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) <S2SV_EndBug> <S2SV_StartBug> + dest [ j * stride + i ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> clip_pixel_add ( <S2SV_ModEnd> <S2SV_ModStart> , ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) ) ; } <S2SV_ModEnd> "
308,"<S2SV_StartBug> memset ( sax , 0 , sizeof ( sax ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> * 
309,<S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> ,<S2SV_ModStart> && i < n <S2SV_ModStart> && i < n 
310,<S2SV_StartBug> zip_object_handlers . get_properties = php_zip_get_properties ; <S2SV_EndBug> ,<S2SV_ModStart> get_gc = php_zip_get_gc ; zip_object_handlers . 
311,"<S2SV_StartBug> ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> pptr += BGP_VPN_RD_LEN ; <S2SV_EndBug> ",<S2SV_ModStart> + 4 <S2SV_ModStart> + 4 
312,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ; "
313,<S2SV_StartBug> if ( ent != NULL ) { <S2SV_EndBug> <S2SV_StartBug> cleanup : <S2SV_EndBug> ,"<S2SV_ModStart> == NULL ) { st = KRB5_KDB_NOENTRY ; <S2SV_ModEnd> <S2SV_ModStart> st = populate_policy ( context , ld , ent , pol_name , * policy ) ; "
314,"<S2SV_StartBug> static void sas_probe_devices ( struct work_struct * work ) <S2SV_EndBug> <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> ",<S2SV_ModStart> asd_sas_port * port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
315,<S2SV_StartBug> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> <S2SV_StartBug> pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
316,"<S2SV_StartBug> char * ext_name = NULL ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ( r = sshbuf_get_cstring ( m , & ext_name , NULL ) ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> parse_key_constraint_extension ( m , sk_providerp ) ) != 0 ) goto out ; break ; default : error_f ( <S2SV_ModEnd> <S2SV_ModStart> r = SSH_ERR_FEATURE_UNSUPPORTED ; goto out ; } } r = 0 ; out : return r <S2SV_ModEnd> "
317,"<S2SV_StartBug> sprintf ( url_address , ""%.*s"" , url_len , url_begin ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , ""%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\'%.*s\'"" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; } "
318,"<S2SV_StartBug> vp8_decrypt_cb * decrypt_cb , <S2SV_EndBug> <S2SV_StartBug> int n = data_sz > 10 ? 10 : data_sz ; <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_decrypt_cb <S2SV_ModEnd> <S2SV_ModStart> MIN ( sizeof ( clear_buffer ) , data_sz ) <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> "
319,<S2SV_StartBug> addr . sun_family = AF_UNIX ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( strlen ( sockFile ) + 1 > sizeof ( addr . sun_path ) ) { rfbClientErr ( ""ConnectToUnixSock:<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long\\n"" ) ; return - 1 ; } "
320,<S2SV_StartBug> prev = NULL ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> skip_mm : 
321,<S2SV_StartBug> return IMPEG2D_MB_TEX_DECODE_ERR ; <S2SV_EndBug> ,<S2SV_ModStart> if ( 0 >= ps_dec -> u2_num_mbs_left ) { break ; } 
322,"<S2SV_StartBug> vpx_memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
323,"<S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
324,<S2SV_StartBug> ENSURE_BITS ( 16 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( bits_left == 0 ) <S2SV_ModStart>  <S2SV_ModEnd> 
325,"<S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> if ( ! context ) return FALSE ; <S2SV_ModStart> { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> } <S2SV_ModStart> { if ( ! <S2SV_ModStart> context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> return TRUE ; "
326,<S2SV_StartBug> local_bh_disable ( ) ; <S2SV_EndBug> <S2SV_StartBug> local_bh_enable ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> 
327,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> <S2SV_ModStart> q += GetPixelChannels ( image ) ; p ++ <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> 
328,"<S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( newnp -> opt ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference <S2SV_ModEnd> <S2SV_ModStart> ; if ( opt ) { <S2SV_ModEnd> <S2SV_ModStart> opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
329,"<S2SV_StartBug> static int cost_mv_ref ( const VP9_COMP * cpi , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> int mode_context ) { <S2SV_EndBug> <S2SV_StartBug> return x -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ",<S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
330,"<S2SV_StartBug> register u_int amt ; <S2SV_EndBug> <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> <S2SV_ModStart> length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> <S2SV_ModStart> ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( * ni ) ; <S2SV_ModStart> if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> <S2SV_ModStart> length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> length_left <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( * ni ) ; <S2SV_ModStart> length_left != 0 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; return ; "
331,<S2SV_StartBug> if ( ! alt ) <S2SV_EndBug> ,<S2SV_ModStart> ) return - ENODEV ; if ( alt -> desc . bNumEndpoints < 1 
332,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> ,<S2SV_ModStart> < p || q 
333,<S2SV_StartBug> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) <S2SV_EndBug> ,<S2SV_ModStart> EOFBlob ( image ) ) break ; if ( 
334,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( size_t ) len >= sizeof ( icon_buf ) ) { logger ( Protocol , Warning , ""seamless_process_line(),<S2SV_blank>icon<S2SV_blank>data<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>icon_buf"" ) ; break ; } "
335,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; 
336,<S2SV_StartBug> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart> ; } else memset ( & ifr , 0 , sizeof ( ifr ) ) "
337,"<S2SV_StartBug> char src [ PATH_MAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( src , dir , dir_len ) ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( dir_len > PATH_MAX ) { uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n"" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> <S2SV_ModStart> , """" , 0 ) <S2SV_ModEnd> <S2SV_ModStart> free ( src ) ; <S2SV_ModStart> free ( src ) ; "
338,"<S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> ",<S2SV_ModStart> * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) 
339,<S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
340,"<S2SV_StartBug> vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
341,<S2SV_StartBug> OVS_NOT_REACHED ( ) ; <S2SV_EndBug> <S2SV_StartBug> OVS_NOT_REACHED ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> return OFPERR_OFPGMFC_BAD_TYPE <S2SV_ModEnd> <S2SV_ModStart> return OFPERR_OFPGMFC_BAD_COMMAND <S2SV_ModEnd> 
342,<S2SV_StartBug> if ( ack -> subh . addip_hdr -> serial == serial ) { <S2SV_EndBug> ,<S2SV_ModStart> sctp_chunk_pending ( ack ) ) continue ; if ( 
343,"<S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext2_xattr_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> inode -> i_ino , ( unsigned long ) ce -> e_block ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> ","<S2SV_ModStart> mb2_cache_entry * ce ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_find_first ( ext2_mb_cache , hash ) ; while ( ce ) { struct buffer_head * bh ; bh = sb_bread ( <S2SV_ModEnd> <S2SV_ModStart> , ce -> e_block ) ; if ( ! bh ) { ext2_error ( inode -> i_sb , ""ext2_xattr_cache_find"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank>read<S2SV_blank>error"" , inode -> i_ino , ( unsigned long ) ce -> e_block ) ; } else { lock_buffer ( bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { mb2_cache_entry_put ( ext2_mb_cache , ce ) ; unlock_buffer ( bh ) ; brelse ( bh ) ; <S2SV_ModEnd> <S2SV_ModStart> } else if ( le32_to_cpu ( HDR ( bh ) -> h_refcount ) > EXT2_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , ""block<S2SV_blank>%ld<S2SV_blank>refcount<S2SV_blank>%d>%d"" , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_touch ( ext2_mb_cache , ce ) ; mb2_cache_entry_put ( ext2_mb_cache , <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_entry_find_next ( ext2_mb_cache , ce <S2SV_ModEnd> "
344,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> 
345,<S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) { <S2SV_EndBug> <S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) : mbmi -> tx_size ; <S2SV_EndBug> ,"<S2SV_ModStart> mbmi -> skip = 1 ; if ( x -> skip ) return ; <S2SV_ModStart> , pd "
346,"<S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> ",<S2SV_ModStart> const int qslen = blen - qs ; <S2SV_ModStart> ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> <S2SV_ModStart> qslen <S2SV_ModEnd> 
347,<S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> || sec_attr_len 
348,<S2SV_StartBug> U2FHID_INIT_RESP initresp ; <S2SV_EndBug> <S2SV_StartBug> if ( resplen > sizeof ( initresp ) ) <S2SV_EndBug> <S2SV_StartBug> dev -> cid = initresp . cid ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionInterface = initresp . versionInterface ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMajor = initresp . versionMajor ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMinor = initresp . versionMinor ; <S2SV_EndBug> <S2SV_StartBug> dev -> capFlags = initresp . capFlags ; <S2SV_EndBug> ,"<S2SV_ModStart> int offs = sizeof ( nonce ) <S2SV_ModEnd> <S2SV_ModStart> < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] <S2SV_ModEnd> <S2SV_ModStart> resp [ offs ++ ] <S2SV_ModEnd> "
349,<S2SV_StartBug> while ( f != upto ) ; <S2SV_EndBug> ,<S2SV_ModStart> && f 
350,<S2SV_StartBug> hash_param . data = 0 ; <S2SV_EndBug> <S2SV_StartBug> hash_param . len = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> instance -> private_key <S2SV_ModEnd> <S2SV_ModStart> instance -> private_key_len <S2SV_ModEnd> 
351,<S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> ,"<S2SV_ModStart> int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> "
352,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
353,<S2SV_StartBug> key_user_put ( key -> user ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
354,"<S2SV_StartBug> static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int nodigest , int nocontent ) <S2SV_EndBug> <S2SV_StartBug> wfd = Fopen ( dest , ""w.ufdio"" ) ; <S2SV_EndBug> <S2SV_StartBug> umask ( old_umask ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int exclusive <S2SV_ModStart> exclusive ? ""wx.ufdio"" : ""a.ufdio"" <S2SV_ModEnd> <S2SV_ModStart> if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; } "
355,"<S2SV_StartBug> int rose_parse_facilities ( unsigned char * p , <S2SV_EndBug> <S2SV_StartBug> if ( facilities_len == 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( facilities_len > 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned packet_len <S2SV_ModStart> || ( unsigned ) facilities_len > packet_len <S2SV_ModStart> >= 3 && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> break ; default : printk ( KERN_DEBUG ""ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n"" , * p ) ; len = 1 ; break ; } <S2SV_ModStart> ) return 0 ; if ( WARN_ON ( len >= facilities_len ) <S2SV_ModStart> } return facilities_len == 0 <S2SV_ModEnd> "
356,"<S2SV_StartBug> tcpSendSegment ( socket , TCP_FLAG_ACK , socket -> sndNxt , socket -> rcvNxt , 0 , FALSE ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> } 
357,"<S2SV_StartBug> vpx_img_fmt_t fmt ) { <S2SV_EndBug> <S2SV_StartBug> const char * const color = fmt == VPX_IMG_FMT_444A ? ""C444alpha\\n"" : <S2SV_EndBug> <S2SV_StartBug> ""C420jpeg\\n"" ; <S2SV_EndBug> ","<S2SV_ModStart> , unsigned int bit_depth <S2SV_ModStart> color ; switch ( bit_depth ) { case 8 : <S2SV_ModEnd> <S2SV_ModStart> break ; case 9 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p9<S2SV_blank>XYSCSS=444P9\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p9<S2SV_blank>XYSCSS=422P9\\n"" : ""C420p9<S2SV_blank>XYSCSS=420P9\\n"" ; break ; case 10 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p10<S2SV_blank>XYSCSS=444P10\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p10<S2SV_blank>XYSCSS=422P10\\n"" : ""C420p10<S2SV_blank>XYSCSS=420P10\\n"" ; break ; case 12 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p12<S2SV_blank>XYSCSS=444P12\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p12<S2SV_blank>XYSCSS=422P12\\n"" : ""C420p12<S2SV_blank>XYSCSS=420P12\\n"" ; break ; case 14 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p14<S2SV_blank>XYSCSS=444P14\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p14<S2SV_blank>XYSCSS=422P14\\n"" : ""C420p14<S2SV_blank>XYSCSS=420P14\\n"" ; break ; case 16 : color = fmt == VPX_IMG_FMT_I44416 ? ""C444p16<S2SV_blank>XYSCSS=444P16\\n"" : fmt == VPX_IMG_FMT_I42216 ? ""C422p16<S2SV_blank>XYSCSS=422P16\\n"" : ""C420p16<S2SV_blank>XYSCSS=420P16\\n"" ; break ; default : color = NULL ; assert ( 0 ) ; } "
358,<S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> const int max_rate = rc -> av_per_frame_bandwidth * <S2SV_EndBug> ,<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> 
359,"<S2SV_StartBug> if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS "
360,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
361,<S2SV_StartBug> static SvcInternal * get_svc_internal ( SvcContext * svc_ctx ) { <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> ,<S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> 
362,"<S2SV_StartBug> baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ; 
363,"<S2SV_StartBug> jsWarn ( ""vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> <S2SV_ModStart> return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , ""height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n"" ) ; return 0 ; } "
364,"<S2SV_StartBug> vp9_prob oldp , vp9_prob * bestp , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp , bestnewp = oldp ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_prob oldp , vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> "
365,<S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> ,<S2SV_ModStart> 1U << ( unsigned int ) <S2SV_ModEnd> 
366,"<S2SV_StartBug> if ( secure_decrypt ( data , sizeof ( * header ) , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return secure_decrypt ( file , header -> file_size , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int ret = - 1 ; <S2SV_ModStart> goto secure_wipe_keys <S2SV_ModEnd> <S2SV_ModStart> goto secure_wipe_keys <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> secure_wipe_keys : wipe_keys ( ) ; return ret ; 
367,<S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> out_put_key : <S2SV_EndBug> ,<S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
368,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> } return - EINVAL <S2SV_ModEnd> 
369,"<S2SV_StartBug> mm_segment_t old_fs ; <S2SV_EndBug> <S2SV_StartBug> ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ; <S2SV_EndBug> <S2SV_StartBug> err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned int status = 0 ; <S2SV_ModStart> ( unsigned int __user * ) & status <S2SV_ModEnd> <S2SV_ModStart> put_user ( status , ustatus ) ; err |= "
370,"<S2SV_StartBug> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , <S2SV_EndBug> <S2SV_StartBug> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> calloc ( min_size , sizeof ( uint8_t ) <S2SV_ModEnd> "
371,"<S2SV_StartBug> SkipRGBMipmaps ( image , dds_info , 4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> return ( <S2SV_ModStart> , exception ) ) <S2SV_ModEnd> "
372,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
373,<S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> ,<S2SV_ModStart> dec_tables . T <S2SV_ModEnd> <S2SV_ModStart> dec_tables . T <S2SV_ModEnd> 
374,<S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> && ! p -> skip_release_on_error 
375,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
376,<S2SV_StartBug> if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) { <S2SV_EndBug> ,<S2SV_ModStart> skb == NULL || 
377,"<S2SV_StartBug> height , <S2SV_EndBug> <S2SV_StartBug> if ( bytes_per_line == 0 ) <S2SV_EndBug> <S2SV_StartBug> bytes_per_line = image -> columns ; <S2SV_EndBug> <S2SV_StartBug> length = image -> rows * ( image -> columns + image -> columns % 2 ) ; <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , * p ++ , q ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( image -> columns % 2 ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> <S2SV_ModStart> , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> <S2SV_ModStart> if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
378,<S2SV_StartBug> if ( L_ICANON ( tty ) ) <S2SV_EndBug> ,<S2SV_ModStart> && ! L_EXTPROC ( tty ) 
379,"<S2SV_StartBug> slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>required<S2SV_blank>attribute<S2SV_blank>has<S2SV_blank>been<S2SV_blank>moved<S2SV_blank>to<S2SV_blank>the<S2SV_blank>BDB<S2SV_blank>scecific<S2SV_blank>configuration<S2SV_blank>entry"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> SLAPI_RESULT_TEXT <S2SV_ModEnd> 
380,<S2SV_StartBug> ipc_lock_object ( & shp -> shm_perm ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( shp -> shm_file == NULL ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } 
381,"<S2SV_StartBug> af -> from_addr_param ( & addr , addr_param , <S2SV_EndBug> ",<S2SV_ModStart> if ( af == NULL ) break ; 
382,"<S2SV_StartBug> ih264d_create_op_t * ps_create_op ; <S2SV_EndBug> <S2SV_StartBug> WORD32 ret ; <S2SV_EndBug> <S2SV_StartBug> ret = ih264d_allocate_static_bufs ( & dec_hdl , pv_api_ip , pv_api_op ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( IV_FAIL == ret ) && ( NULL != dec_hdl ) ) <S2SV_EndBug> <S2SV_StartBug> ih264d_free_static_bufs ( dec_hdl ) ; <S2SV_EndBug> ","<S2SV_ModStart> ih264d_create_ip_t * ps_create_ip ; <S2SV_ModStart> ; ps_create_ip = ( ih264d_create_ip_t * ) pv_api_ip <S2SV_ModStart> dec_hdl = NULL ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if ( dec_hdl ) { if ( dec_hdl -> pv_codec_handle <S2SV_ModEnd> <S2SV_ModStart> } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , dec_hdl ) ; } } "
383,<S2SV_StartBug> ip6_rt_put ( rt ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! ( arg -> flags & FIB_LOOKUP_NOREF ) ) 
384,<S2SV_StartBug> if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { <S2SV_EndBug> <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> <S2SV_StartBug> return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> <S2SV_ModStart> out : return ret <S2SV_ModEnd> "
385,<S2SV_StartBug> arg_allow_debuggers = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> struct utsname u ; int rv = uname ( & u ) ; if ( rv != 0 ) errExit ( ""uname"" ) ; int major ; int minor ; if ( 2 != sscanf ( u . release , ""%d.%d"" , & major , & minor ) ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>extract<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version:<S2SV_blank>%s\\n"" , u . version ) ; exit ( 1 ) ; } if ( major < 4 || ( major == 4 && minor < 8 ) ) { fprintf ( stderr , ""Error:<S2SV_blank>--allow-debuggers<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>Linux<S2SV_blank>kernels<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>4.8.<S2SV_blank>"" ""A<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>ptrace<S2SV_blank>call<S2SV_blank>allows<S2SV_blank>a<S2SV_blank>full<S2SV_blank>bypass<S2SV_blank>of<S2SV_blank>the<S2SV_blank>seccomp<S2SV_blank>filter.<S2SV_blank>"" ""Your<S2SV_blank>current<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d.\\n"" , major , minor ) ; exit ( 1 ) ; } "
386,<S2SV_StartBug> } else <S2SV_EndBug> ,"<S2SV_ModStart> else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ; "
387,<S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if ( "
388,<S2SV_StartBug> long newpos ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
389,"<S2SV_StartBug> uint16_t hmi_bpm = 0 ; <S2SV_EndBug> <S2SV_StartBug> } * note ; <S2SV_EndBug> <S2SV_StartBug> if ( hmi_data [ 0 ] == 0xfe ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( hmi_data [ 1 ] == 0x15 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , hmi_running_event [ i ] ) ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> note [ hmi_tmp ] . length = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( * hmi_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmi_data > 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_track_offset [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> hmi_data ++ ; <S2SV_EndBug> ","<S2SV_ModStart> uint32_t data_siz ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> hmi_tmp += 4 ; <S2SV_ModStart> hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> <S2SV_ModStart> hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> , data_siz <S2SV_ModStart> data_siz -= setup_ret ; <S2SV_ModStart> data_siz && <S2SV_ModStart> if ( ! data_siz ) break ; <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> <S2SV_ModStart> if ( ! data_siz ) break ; <S2SV_ModStart> data_siz -- ; <S2SV_ModStart> if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; data_siz -- "
390,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>title<S2SV_blank>\'%s\'"" , gplot -> title ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>xlabel<S2SV_blank>\'%s\'"" , gplot -> xlabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>ylabel<S2SV_blank>\'%s\'"" , gplot -> ylabel ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>x"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""set<S2SV_blank>logscale<S2SV_blank>y"" ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\"" , <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"" , <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
391,<S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst 
392,"<S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""modifying<S2SV_blank>in-place"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> int offset ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( header -> h_hash ) ; <S2SV_ModStart> mb2_cache_entry_delete_block ( EXT2_SB ( sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
393,"<S2SV_StartBug> u8 ip_proto = 0 ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return true ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> key_basic -> n_proto = proto ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> key_basic -> n_proto = proto ; <S2SV_EndBug> <S2SV_StartBug> if ( skb_flow_dissector_uses_key ( flow_dissector , <S2SV_EndBug> ","<S2SV_ModStart> ; bool ret = false <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_good <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_good ; } goto out_good <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } out_good : ret = true ; out_bad : <S2SV_ModStart> return ret <S2SV_ModEnd> "
394,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
395,"<S2SV_StartBug> VP8Frame * av_uninit ( curframe ) , * prev_frame ; <S2SV_EndBug> ",<S2SV_ModStart> ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P ) 
396,"<S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> ","<S2SV_ModStart> strbuf_addstr ( base , name ) ; <S2SV_ModStart> -> buf , cb_data <S2SV_ModEnd> "
397,"<S2SV_StartBug> int64_t off = s -> off ; <S2SV_EndBug> <S2SV_StartBug> ""Range:<S2SV_blank>bytes=%"" PRId64 ""-"" , s -> off ) ; <S2SV_EndBug> <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> PRIu64 <S2SV_ModEnd> <S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
398,"<S2SV_StartBug> number_planes , <S2SV_EndBug> <S2SV_StartBug> if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) ) <S2SV_EndBug> <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , number_planes_filled <S2SV_ModStart> number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> <S2SV_ModStart> number_planes_filled <S2SV_ModEnd> "
399,"<S2SV_StartBug> uint32 rows , uint32 cols , int outskew , int inskew ) <S2SV_EndBug> ",<S2SV_ModStart> int64 <S2SV_ModEnd> 
400,"<S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug> ",<S2SV_ModStart> + 8 <S2SV_ModStart> const <S2SV_ModStart> ; const int <S2SV_ModEnd> 
401,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
402,<S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL 
403,<S2SV_StartBug> const char * bufptr ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write"" ) ; } "
404,"<S2SV_StartBug> static void update_read_synchronize ( rdpUpdate * update , wStream * s ) <S2SV_EndBug> <S2SV_StartBug> Stream_Seek_UINT16 ( s ) ; <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> return Stream_SafeSeek ( s , 2 <S2SV_ModEnd> "
405,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , icmp6_tstr <S2SV_ModEnd> "
406,<S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
407,<S2SV_StartBug> uchar buf [ JPG_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
408,<S2SV_StartBug> ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ; <S2SV_EndBug> ,<S2SV_ModStart> u2_forw_f_code = 7 ; ps_dec -> u2_back_f_code = 7 ; ps_dec -> 
409,"<S2SV_StartBug> memcpy ( vs_param_set -> ie , priv -> vs_ie [ id ] . ie , <S2SV_EndBug> ","<S2SV_ModStart> if ( le16_to_cpu ( vs_param_set -> header . len ) > MWIFIEX_MAX_VSIE_LEN ) { mwifiex_dbg ( priv -> adapter , ERROR , ""Invalid<S2SV_blank>param<S2SV_blank>length!\\n"" ) ; break ; } "
410,"<S2SV_StartBug> static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out ) <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! match ( pc -> x , sp , bol , flags , out ) ) <S2SV_EndBug> <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , int depth <S2SV_ModStart> result ; int <S2SV_ModStart> if ( depth > MAXREC ) return - 1 ; <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 1 ) return 1 <S2SV_ModEnd> <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) return 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> "
411,<S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
412,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
413,"<S2SV_StartBug> _ ( ""_Launch<S2SV_blank>Anyway"" ) , RESPONSE_RUN ) ; <S2SV_EndBug> <S2SV_StartBug> _ ( ""Mark<S2SV_blank>as<S2SV_blank>_Trusted"" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug> ","<S2SV_ModStart> ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> <S2SV_ModStart> ""Trust<S2SV_blank>and<S2SV_blank>_Launch"" ) , GTK_RESPONSE_OK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
414,<S2SV_StartBug> size_t size = ( alignment - MALLOC_ALIGNMENT ) + bytes ; <S2SV_EndBug> ,<S2SV_ModStart> if ( size < bytes ) { return NULL ; } 
415,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table ) ; "
416,"<S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( queue , skb ) ; <S2SV_EndBug> ","<S2SV_ModStart> csum = 0 ; __skb_queue_tail ( queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> append : <S2SV_ModEnd> "
417,<S2SV_StartBug> r = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
418,"<S2SV_StartBug> FIRSTPASS_STATS this_frame ; <S2SV_EndBug> <S2SV_StartBug> const int is_spatial_svc = ( svc -> number_spatial_layers > 1 ) && <S2SV_EndBug> <S2SV_StartBug> ( svc -> number_temporal_layers == 1 ) ; <S2SV_EndBug> <S2SV_StartBug> double frame_rate ; <S2SV_EndBug> <S2SV_StartBug> twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ; <S2SV_EndBug> <S2SV_StartBug> twopass -> total_stats = * twopass -> stats_in_end ; <S2SV_EndBug> <S2SV_StartBug> twopass -> total_left_stats = twopass -> total_stats ; <S2SV_EndBug> <S2SV_StartBug> frame_rate = 10000000.0 * twopass -> total_stats . count / <S2SV_EndBug> <S2SV_StartBug> if ( is_spatial_svc ) { <S2SV_EndBug> <S2SV_StartBug> ( int64_t ) ( twopass -> total_stats . duration * <S2SV_EndBug> <S2SV_StartBug> twopass -> bits_left = ( int64_t ) ( twopass -> total_stats . duration * <S2SV_EndBug> <S2SV_StartBug> cpi -> output_framerate = oxcf -> framerate ; <S2SV_EndBug> <S2SV_StartBug> double sum_iiratio = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> start_pos = twopass -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> while ( input_stats ( twopass , & this_frame ) != EOF ) { <S2SV_EndBug> <S2SV_StartBug> calculate_modified_err ( cpi , & this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> twopass -> modified_error_left = twopass -> modified_error_total ; <S2SV_EndBug> ","<S2SV_ModStart> const VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> is_two_pass_svc <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> TWO_PASS * const twopass = is_two_pass_svc ? <S2SV_ModEnd> <S2SV_ModStart> : & cpi -> twopass ; double frame_rate ; FIRSTPASS_STATS * stats ; <S2SV_ModEnd> <S2SV_ModStart> stats = & <S2SV_ModStart> ; * stats <S2SV_ModStart> * stats <S2SV_ModEnd> <S2SV_ModStart> stats -> count / stats -> <S2SV_ModEnd> <S2SV_ModStart> is_two_pass_svc <S2SV_ModEnd> <S2SV_ModStart> stats -> <S2SV_ModEnd> <S2SV_ModStart> stats -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const double avg_error = stats -> coded_error / DOUBLE_DIVIDE_CHECK ( stats -> count ) ; const FIRSTPASS_STATS * s = twopass -> stats_in ; double modified_error_total <S2SV_ModEnd> <S2SV_ModStart> twopass -> modified_error_min = ( avg_error * oxcf -> two_pass_vbrmin_section ) / 100 ; twopass -> modified_error_max = ( avg_error * oxcf -> two_pass_vbrmax_section ) / 100 <S2SV_ModEnd> <S2SV_ModStart> s < twopass -> stats_in_end ) { <S2SV_ModEnd> <S2SV_ModStart> twopass , oxcf , s ) ; ++ s <S2SV_ModEnd> <S2SV_ModStart> modified_error_total ; } cpi -> rc . vbr_bits_off_target = 0 ; cpi -> rc . vbr_bits_off_target_fast = 0 ; cpi -> rc . rate_error_estimate = 0 ; twopass -> kf_zeromotion_pct = 100 ; twopass -> last_kfgroup_zeromotion_pct = 100 ; if ( oxcf -> resize_mode != RESIZE_NONE ) { vp9_init_subsampling ( cpi <S2SV_ModEnd> "
419,<S2SV_StartBug> int overflow_error = 0 ; <S2SV_EndBug> <S2SV_StartBug> res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( u = 0 ; u < line_length ; u ++ ) { <S2SV_EndBug> <S2SV_StartBug> res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ; <S2SV_EndBug> <S2SV_StartBug> u -- ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i <= u ; i ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> weights_size ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> < <S2SV_ModEnd> "
420,"<S2SV_StartBug> Stream_Read_UINT16 ( s , <S2SV_EndBug> ",<S2SV_ModStart> if ( Stream_GetRemainingLength ( s ) < 8 ) return FALSE ; 
421,<S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
422,"<S2SV_StartBug> DRM_DEBUG ( ""clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( ""execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\n"" , args -> num_cliprects "
423,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_lineno ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_lineno ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_int ( tmp , & lineno , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( values , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & left , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_op ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_op ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_args ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_args ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_test ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_test ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & test , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( keys , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( values , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( elts , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> comprehension_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( generators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> comprehension_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( generators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_key ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_key ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & key , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> comprehension_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( generators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elt ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_elt ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> comprehension_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_comprehension ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( generators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( exists_not_none ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_left ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_left ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> cmpop_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_cmpop ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( ops , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( comparators , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_func ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_func ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( args , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> keyword_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( keywords , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_n ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_n ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( values , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_s ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_s ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_attr ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_slice ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_id ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_id ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( elts , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ctx ) ; <S2SV_EndBug> <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_elts ) ) { <S2SV_EndBug> <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> <S2SV_StartBug> asdl_seq_SET ( elts , i , value ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elts\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>expr"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>expr"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> col_offset <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_boolop ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""values\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""left\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & left , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ; return 1 ; } else { int res ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_right , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""right\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> right <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_unaryop ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_operand , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""operand\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & operand <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Lambda"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Lambda"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & orelse , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = IfExp ( test , body , orelse , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Dict_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * keys ; asdl_seq * values ; if ( lookup_attr_id ( obj , & PyId_keys , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keys\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""values\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> * out = Dict ( keys , values , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Set_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * elts ; if ( lookup_attr_id ( obj , & PyId_elts , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elts\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Set"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elt\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ListComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""generators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ListComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elt\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>SetComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""generators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>SetComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""key\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & key , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ; return 1 ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> value <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""generators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elt\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>GeneratorExp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""generators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>GeneratorExp"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Await"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>YieldFrom"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""left\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & left , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_ops , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ops\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_comparators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""comparators\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""func\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & func , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_keywords , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""n\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Num"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""s\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Str"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FormattedValue"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_conversion , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; conversion = 0 ; } else { int res ; res = obj2ast_int ( tmp , & conversion , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_format_spec , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; format_spec = NULL ; } else { int res <S2SV_ModEnd> <S2SV_ModStart> format_spec , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FormattedValue ( value , conversion , format_spec , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) JoinedStr_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * values ; if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""values\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>JoinedStr"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""s\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Bytes"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>NameConstant"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Constant"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_attr , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""attr\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & attr <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_slice , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""slice\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ; return 1 ; } else { int res ; res = obj2ast_slice ( tmp , & slice <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Starred"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Starred"" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""id\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Name"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & id , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Name"" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elts\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>List"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>List"" ) ; return 1 ; } else { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""elts\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ; return 1 ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> val <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""ctx\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple"" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Tuple ( elts , ctx , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> <S2SV_ModStart> ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>expr,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj <S2SV_ModEnd> "
424,"<S2SV_StartBug> parse_field ( netdissect_options * ndo , const char * * pptr , int * len ) <S2SV_EndBug> <S2SV_StartBug> if ( * len <= 0 || ! pptr || ! * pptr ) <S2SV_EndBug> <S2SV_StartBug> while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) { <S2SV_EndBug> <S2SV_StartBug> if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend ) <S2SV_EndBug> ","<S2SV_ModStart> , int * truncated <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( <S2SV_ModEnd> <S2SV_ModStart> ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\0' ) { break ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
425,<S2SV_StartBug> if ( ! ( assigned_dev -> flags & KVM_DEV_ASSIGN_ENABLE_IOMMU ) ) <S2SV_EndBug> <S2SV_StartBug> if ( pci_enable_device ( dev ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> u8 header_type ; <S2SV_ModStart> pci_read_config_byte ( dev , PCI_HEADER_TYPE , & header_type ) ; if ( ( header_type & PCI_HEADER_TYPE ) != PCI_HEADER_TYPE_NORMAL ) { r = - EPERM ; goto out_put ; } r = probe_sysfs_permissions ( dev ) ; if ( r ) goto out_put ; "
426,<S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug> ,"<S2SV_ModStart> struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq ) "
427,<S2SV_StartBug> struct kvm_lapic * apic = vcpu -> arch . apic ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> kvm_write_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> <S2SV_ModStart> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> "
428,"<S2SV_StartBug> dtls1_process_buffered_records ( s ) ; <S2SV_EndBug> <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) return - 1 <S2SV_ModStart> if ( <S2SV_ModStart> ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> dtls1_record_bitmap_update ( s , bitmap ) ; "
429,<S2SV_StartBug> if ( ctx -> img_avail ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( * iter ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> frame_parallel_decode && ctx -> available_threads > 0 && ! ctx -> flushed ) { return NULL ; } if ( ctx -> num_cache_frames > 0 ) { release_last_output_frame ( ctx ) ; ctx -> last_show_frame = ctx -> frame_cache [ ctx -> frame_cache_read ] . fb_idx ; if ( ctx -> need_resync ) return NULL ; img = & ctx -> frame_cache [ ctx -> frame_cache_read ] . img ; ctx -> frame_cache_read = ( ctx -> frame_cache_read + 1 ) % FRAME_CACHE_SIZE ; -- ctx -> num_cache_frames ; return img ; } if <S2SV_ModEnd> <S2SV_ModStart> == NULL && ctx -> frame_workers != NULL ) { do { YV12_BUFFER_CONFIG sd ; vp9_ppflags_t flags = { 0 , 0 , 0 } ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_output_worker_id ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; ctx -> next_output_worker_id = ( ctx -> next_output_worker_id + 1 ) % ctx -> num_frame_workers ; if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) set_ppflags ( ctx , & flags ) ; if ( winterface -> sync ( worker ) ) { if ( frame_worker_data -> received_frame == 1 ) { ++ ctx -> available_threads ; frame_worker_data -> received_frame = 0 ; check_resync ( ctx , frame_worker_data -> pbi ) ; } if ( vp9_get_raw_frame ( frame_worker_data -> pbi , & sd , & flags ) == 0 ) { VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; release_last_output_frame ( ctx ) ; ctx -> last_show_frame = frame_worker_data -> pbi -> common . new_fb_idx ; if ( ctx -> need_resync ) return NULL ; yuvconfig2image ( & ctx -> img , & sd , frame_worker_data -> user_priv ) ; ctx -> img . fb_priv = frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ; img = & ctx -> img ; return img ; } } else { frame_worker_data -> received_frame = 0 ; ++ ctx -> available_threads ; ctx -> need_resync = 1 ; if ( ctx -> flushed != 1 ) return NULL ; } } while ( ctx -> next_output_worker_id != ctx -> next_submit_worker_id ) ; } return NULL <S2SV_ModEnd> "
430,"<S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
431,<S2SV_StartBug> pairs = palloc ( count * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; "
432,"<S2SV_StartBug> ptr = realloc ( priv -> EF_C_DevAut , len ) ; <S2SV_EndBug> <S2SV_StartBug> priv -> EF_C_DevAut_len = len ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len > 0 ) { <S2SV_ModStart> } 
433,"<S2SV_StartBug> DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned long len = php_mysqlnd_net_field_length ( & p ) ; <S2SV_EndBug> ","<S2SV_ModStart> const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> const <S2SV_ModStart> if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , ""Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>"" MYSQLND_SZ_T_SPEC ""<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet"" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; } "
434,<S2SV_StartBug> return ; <S2SV_EndBug> ,<S2SV_ModStart> 0 
435,<S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> ,<S2SV_ModStart> rm -> atomic . op_active = 0 ; 
436,<S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> ,"<S2SV_ModStart> ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n"" ) "
437,"<S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; 
438,<S2SV_StartBug> return true ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( IS ( req -> method , METHOD_POST ) ) { const char * cookie = get_header ( req , ""Cookie"" ) ; const char * token = get_parameter ( req , ""securitytoken"" ) ; if ( ! cookie ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>cookie\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( ! token ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>parameter\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( ! Str_startsWith ( cookie , ""securitytoken="" ) ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>no<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>cookie\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } if ( Str_compareConstantTime ( cookie + 14 , token ) ) { LogError ( ""HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>mismatch\\n"" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , ""Invalid<S2SV_blank>CSRF<S2SV_blank>Token"" ) ; return false ; } } "
439,"<S2SV_StartBug> int n = 0 , size = 0 , ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> struct perf_event_context * ctx = leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> ret = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> goto unlock ; <S2SV_EndBug> <S2SV_StartBug> unlock : <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx = leader -> ctx ; <S2SV_ModStart> ; u64 count , enabled , running ; u64 values [ 5 ] ; lockdep_assert_held ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
440,"<S2SV_StartBug> int setpwnam ( struct passwd * pwd ) <S2SV_EndBug> <S2SV_StartBug> char * atomic_dir = ""/etc"" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) <S2SV_EndBug> ","<S2SV_ModStart> , const char * prefix <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/etc"" , prefix <S2SV_ModEnd> "
441,<S2SV_StartBug> PCI_DMA_FROMDEVICE ) ) <S2SV_EndBug> <S2SV_StartBug> buf_pa = MWIFIEX_SKB_DMA_ADDR ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree_skb ( skb ) ; kfree ( card -> evtbd_ring_vbase ) ; <S2SV_ModStart> } 
442,<S2SV_StartBug> if ( count < sizeof ( cmd . type ) ) { <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( 
443,<S2SV_StartBug> done = EAS_TRUE ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( ""b/26366256"" ) ; pWTIntFrame -> numSamples = 0 ; } "
444,<S2SV_StartBug> max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; <S2SV_EndBug> <S2SV_StartBug> max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; <S2SV_EndBug> ,"<S2SV_ModStart> { if ( CheckMemoryOverflow <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_ModEnd> <S2SV_ModStart> } "
445,"<S2SV_StartBug> struct strbuf * path , const char * last , <S2SV_EndBug> <S2SV_StartBug> char * name = path_name ( path , last ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ( char * ) name ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
446,<S2SV_StartBug> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sid > maxsector ) { <S2SV_EndBug> ,"<S2SV_ModStart> ( <S2SV_ModStart> / sizeof ( maxsector ) ) <S2SV_ModStart> >= maxsector ) { DPRINTF ( ( ""Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\n"" <S2SV_ModEnd> "
447,"<S2SV_StartBug> makewhite ( g , o ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( g -> gckind == KGC_INC ) 
448,<S2SV_StartBug> if ( ( wp -> path = websNormalizeUriPath ( path ) ) == 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> websValidateUriPath <S2SV_ModEnd> 
449,<S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> ,<S2SV_ModStart> && i < gemsafe_cert_max 
450,<S2SV_StartBug> if ( src_end - src < zsize ) <S2SV_EndBug> <S2SV_StartBug> bitbuf = * src ++ ; <S2SV_EndBug> ,<S2SV_ModStart> + ( sub_type != 2 ) <S2SV_ModStart> if ( src >= src_end ) return AVERROR_INVALIDDATA ; 
451,<S2SV_StartBug> if ( ! prev_pkt [ channel_id ] . read ) { <S2SV_EndBug> ,"<S2SV_ModStart> prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , ""RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n"" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if ( "
452,<S2SV_StartBug> int nAlloc = pSrc -> nSrc * 2 + nExtra ; <S2SV_EndBug> ,<S2SV_ModStart> sqlite3_int64 nAlloc = 2 * ( sqlite3_int64 ) pSrc -> nSrc <S2SV_ModEnd> 
453,<S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> 
454,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ plane ] 
455,<S2SV_StartBug> len = dp -> ip6r_len ; <S2SV_EndBug> ,<S2SV_ModStart> ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
456,"<S2SV_StartBug> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> <S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
457,"<S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> <S2SV_ModStart> arg <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
458,<S2SV_StartBug> if ( err ) <S2SV_EndBug> ,<S2SV_ModStart> < 0 
459,<S2SV_StartBug> if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) { <S2SV_EndBug> <S2SV_StartBug> name = p ; p += name_len ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> if ( name_len == 0 ) goto chunk_end ; 
460,<S2SV_StartBug> if ( ! file ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
461,"<S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
462,"<S2SV_StartBug> if ( istreq ( str , ""all"" ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ! str ) return false ; if ( 
463,<S2SV_StartBug> conn -> c_trans = trans ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } "
464,<S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; 
465,<S2SV_StartBug> if ( NCH ( n ) == 1 ) <S2SV_EndBug> <S2SV_StartBug> l = 0 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( NCH ( n ) - 1 ) ; i ++ ) <S2SV_EndBug> ,"<S2SV_ModStart> case func_body_suite : <S2SV_ModStart> i = 2 ; l = 0 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
466,"<S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct reloc_struct_t <S2SV_ModEnd> 
467,"<S2SV_StartBug> void vp9_loop_filter_rows ( const YV12_BUFFER_CONFIG * frame_buffer , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> <S2SV_StartBug> int mi_row , mi_col ; <S2SV_EndBug> <S2SV_StartBug> int use_420 = y_only || ( xd -> plane [ 1 ] . subsampling_y == 1 && <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 1 ] . subsampling_x == 1 ) ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + mi_row * cm -> mi_stride ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_dst_planes ( xd , frame_buffer , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> if ( use_420 ) <S2SV_EndBug> <S2SV_StartBug> vp9_setup_mask ( cm , mi_row , mi_col , mi_8x8 + mi_col , cm -> mi_stride , <S2SV_EndBug> <S2SV_StartBug> for ( plane = 0 ; plane < num_planes ; ++ plane ) { <S2SV_EndBug> <S2SV_StartBug> if ( use_420 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> <S2SV_ModStart> enum lf_path path <S2SV_ModEnd> <S2SV_ModStart> mi_row , mi_col ; if ( y_only ) path = LF_PATH_444 ; else if ( planes <S2SV_ModEnd> <S2SV_ModStart> planes <S2SV_ModEnd> <S2SV_ModStart> path = LF_PATH_420 ; else if ( planes [ 1 ] . subsampling_y == 0 && planes [ 1 ] . subsampling_x == 0 ) path = LF_PATH_444 ; else path = LF_PATH_SLOW <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> planes <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> vp9_filter_block_plane_ss00 ( cm , & planes [ 0 ] , mi_row , & lfm ) ; <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> switch ( path ) { case LF_PATH_420 : vp9_filter_block_plane_ss11 ( cm , & planes [ plane ] , mi_row , & lfm ) ; break ; case LF_PATH_444 : vp9_filter_block_plane_ss00 ( cm , & planes [ plane ] , mi_row , & lfm ) ; break ; case LF_PATH_SLOW : vp9_filter_block_plane_non420 ( cm , & planes [ plane ] , mi <S2SV_ModEnd> <S2SV_ModStart> break ; } "
468,<S2SV_StartBug> if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) return rdesc ; if ( * rsize < 4 
469,<S2SV_StartBug> config -> listeners [ config -> listener_count - 1 ] . security_options . password_file = config -> default_listener . security_options . password_file ; <S2SV_EndBug> ,<S2SV_ModStart> acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options . 
470,<S2SV_StartBug> EXT4_DESC_PER_BLOCK ( sb ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , ""first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)"" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } } "
471,"<S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
472,"<S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> rrec . seq_num ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) return - 1 
473,"<S2SV_StartBug> if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) && <S2SV_EndBug> <S2SV_StartBug> ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) || <S2SV_EndBug> <S2SV_StartBug> ! same_thread_group ( rtn , current ) || <S2SV_EndBug> <S2SV_StartBug> if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && <S2SV_EndBug> <S2SV_StartBug> ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> switch <S2SV_ModEnd> <S2SV_ModStart> ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! rtn <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> case SIGEV_SIGNAL : case SIGEV_THREAD : if <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> case SIGEV_NONE : <S2SV_ModStart> default : return NULL ; } 
474,<S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
475,"<S2SV_StartBug> r = parse_gid ( e + 1 , & gid ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ; 
476,<S2SV_StartBug> pch -> file . dead = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ; 
477,"<S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPDRL , LSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPDRH , MSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRW ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_EPAR <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPDRL <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPDRH <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> <S2SV_ModStart> DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> "
478,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> <S2SV_ModStart> ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb ) 
479,<S2SV_StartBug> goto retry ; <S2SV_EndBug> ,"<S2SV_ModStart> err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ; "
480,<S2SV_StartBug> if ( retval != 0 ) <S2SV_EndBug> ,<S2SV_ModStart> == 0 && server_ptr == NULL ) retval = KRB5_KDB_NOENTRY ; if ( retval 
481,"<S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; <S2SV_EndBug> ",<S2SV_ModStart> goto next <S2SV_ModEnd> <S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> <S2SV_ModStart> goto next <S2SV_ModEnd> <S2SV_ModStart> next : 
482,"<S2SV_StartBug> REQ ( CHILD ( n , 0 ) , ASYNC ) ; <S2SV_EndBug> <S2SV_StartBug> return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , NULL , <S2SV_EndBug> <S2SV_StartBug> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return ast_for_with_stmt ( c , CHILD ( n , 1 ) , <S2SV_EndBug> <S2SV_StartBug> return ast_for_for_stmt ( c , CHILD ( n , 1 ) , <S2SV_EndBug> ","<S2SV_ModStart> NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 <S2SV_ModEnd> <S2SV_ModStart> n <S2SV_ModEnd> <S2SV_ModStart> true <S2SV_ModEnd> <S2SV_ModStart> n , true <S2SV_ModEnd> <S2SV_ModStart> n , true <S2SV_ModEnd> "
483,<S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_ModStart> trunc : return - 1 ; 
484,"<S2SV_StartBug> metadatalength = GetDuration ( mp4 ) ; <S2SV_EndBug> <S2SV_StartBug> float in = 0.0 , out = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t fourcc = GPMF_Key ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n"" , PRINTF_4CC ( fourcc ) , rate ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( mp4 == 0 ) { printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n"" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> double in = 0.0 , out = 0.0 ; <S2SV_ModStart> , & in , & out ) ; printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n"" <S2SV_ModEnd> <S2SV_ModStart> , in , out "
485,"<S2SV_StartBug> For ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , int <S2SV_EndBug> <S2SV_StartBug> p -> v . For . orelse = orelse ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , int <S2SV_ModEnd> <S2SV_ModStart> ; p -> v . For . type_comment = type_comment "
486,"<S2SV_StartBug> strcpy ( the_url , evt -> navigate . to_url ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> "
487,"<S2SV_StartBug> int i , attr_id = 0 , nattr ; <S2SV_EndBug> ",<S2SV_ModStart> ; tagname [ 0 ] = '\\0' 
488,"<S2SV_StartBug> DWORD nbWritten = 0 ; <S2SV_EndBug> <S2SV_StartBug> Stream_Seek ( irp -> input , 20 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( CommWriteFile ( serial -> hComm , Stream_Pointer ( irp -> input ) , Length , & nbWritten , NULL ) ) <S2SV_EndBug> ","<S2SV_ModStart> void * ptr ; <S2SV_ModStart> if ( ! Stream_SafeSeek <S2SV_ModEnd> <S2SV_ModStart> ) return ERROR_INVALID_DATA <S2SV_ModStart> ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ptr <S2SV_ModEnd> "
489,<S2SV_StartBug> char * buf ; <S2SV_EndBug> ,"<S2SV_ModStart> struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( ""seamless_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ; } "
490,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) 
491,"<S2SV_StartBug> ret = hermes_enable_port ( hw , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> "
492,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin6 ) ; 
493,<S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> 
494,<S2SV_StartBug> uri -> port = port & INT_MAX ; <S2SV_EndBug> ,<S2SV_ModStart> USHRT_MAX <S2SV_ModEnd> 
495,<S2SV_StartBug> pch -> chan_net = net ; <S2SV_EndBug> ,<S2SV_ModStart> get_net ( net ) <S2SV_ModEnd> 
496,"<S2SV_StartBug> RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; } 
497,"<S2SV_StartBug> ret = hermes_enable_port ( hw , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> "
498,<S2SV_StartBug> tunnel_type = * ( tptr + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
499,"<S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> GSTD_GSS_ERROR ( maj , min , NULL , ""gss_accept_sec_context"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; gss_release_buffer ( & min , & in <S2SV_ModStart> gss_release_buffer ( & min , & out ) ; "
500,"<S2SV_StartBug> xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
501,<S2SV_StartBug> pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> Assert ( ncolumns <= MaxTupleAttributeNumber ) ; 
502,<S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; return 0 ; } <S2SV_ModEnd> "
503,"<S2SV_StartBug> int procfd ; <S2SV_EndBug> <S2SV_StartBug> pid_t to_cleanup_pid = pid ; <S2SV_EndBug> <S2SV_StartBug> status = 0 ; <S2SV_EndBug> <S2SV_StartBug> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( options -> stdin_fd == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; <S2SV_EndBug> <S2SV_StartBug> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> cleanup_error : <S2SV_EndBug> <S2SV_StartBug> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; <S2SV_EndBug> <S2SV_StartBug> . procfd = procfd <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int procfd = - 1 ; <S2SV_ModStart> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc."" <S2SV_ModEnd> <S2SV_ModStart> status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> <S2SV_ModStart> status ) <S2SV_ModEnd> <S2SV_ModStart> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" <S2SV_ModEnd> <S2SV_ModStart> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } <S2SV_ModStart> ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>"" ""from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>"" ""initialization<S2SV_blank>(2):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
504,"<S2SV_StartBug> static int try_filter_frame ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * const cpi , <S2SV_EndBug> <S2SV_StartBug> int filt_err ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_frame ( cm , & cpi -> mb . e_mbd , filt_level , 1 , partial_frame ) ; <S2SV_EndBug> <S2SV_StartBug> filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ; <S2SV_EndBug> ","<S2SV_ModStart> int64_t <S2SV_ModEnd> <S2SV_ModStart> int64_t filt_err ; if ( cpi -> num_workers > 1 ) vp9_loop_filter_frame_mt ( cm -> frame_to_show , cm , cpi -> td . mb . e_mbd . plane , filt_level , 1 , partial_frame , cpi -> workers , cpi -> num_workers , & cpi -> lf_row_sync ) ; else vp9_loop_filter_frame ( cm -> frame_to_show , <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { filt_err = vp9_highbd_get_y_sse ( sd , cm -> frame_to_show ) ; } else { <S2SV_ModStart> } # else filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ; # endif "
505,"<S2SV_StartBug> ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
506,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> ( void ) cpi ; ( void ) fullpixel ; 
507,"<S2SV_StartBug> void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) { <S2SV_EndBug> <S2SV_StartBug> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ; <S2SV_EndBug> <S2SV_StartBug> inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td ) { <S2SV_ModEnd> <S2SV_ModStart> = & td -> mb . e_mbd ; <S2SV_ModEnd> <S2SV_ModStart> ; const MB_MODE_INFO_EXT * mbmi_ext = td -> mb . mbmi_ext <S2SV_ModStart> mbmi_ext , <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> mbmi_ext , <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> "
508,"<S2SV_StartBug> static bool <S2SV_EndBug> <S2SV_StartBug> bool success = NS_TRUE ; <S2SV_EndBug> <S2SV_StartBug> size_t chunk_length ; <S2SV_EndBug> <S2SV_StartBug> success = NS_FALSE ; <S2SV_EndBug> <S2SV_StartBug> chunk_length = ( size_t ) strtol ( chunkStart , NULL , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( p + 2 + chunk_length > end ) { <S2SV_EndBug> <S2SV_StartBug> success = NS_FALSE ; <S2SV_EndBug> <S2SV_StartBug> memmove ( writeBuffer , p + 2 , chunk_length ) ; <S2SV_EndBug> <S2SV_StartBug> reqPtr -> chunkWriteOff += chunk_length ; <S2SV_EndBug> <S2SV_StartBug> * ( writeBuffer + chunk_length ) = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> reqPtr -> chunkStartOff += ( size_t ) ( p - chunkStart ) + 4u + chunk_length ; <S2SV_EndBug> <S2SV_StartBug> return success ; <S2SV_EndBug> ","<S2SV_ModStart> SockState <S2SV_ModEnd> <S2SV_ModStart> SockState result = SOCK_READY <S2SV_ModEnd> <S2SV_ModStart> long chunkLength <S2SV_ModEnd> <S2SV_ModStart> result = SOCK_MORE <S2SV_ModEnd> <S2SV_ModStart> chunkLength = <S2SV_ModEnd> <S2SV_ModStart> chunkLength < 0 ) { Ns_Log ( Warning , ""ChunkedDecode:<S2SV_blank>negative<S2SV_blank>chunk<S2SV_blank>length"" ) ; result = SOCK_BADREQUEST ; break ; } * p = '\\r' ; if ( <S2SV_ModStart> chunkLength <S2SV_ModEnd> <S2SV_ModStart> result = SOCK_MORE <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) chunkLength <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) chunkLength <S2SV_ModEnd> <S2SV_ModStart> chunkLength <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) chunkLength <S2SV_ModEnd> <S2SV_ModStart> result <S2SV_ModEnd> "
509,"<S2SV_StartBug> static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val ) <S2SV_EndBug> <S2SV_StartBug> ulonglong v ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> <S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
510,<S2SV_StartBug> char * buf ; <S2SV_EndBug> ,"<S2SV_ModStart> struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( ""lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state"" , & packet ) ; } "
511,"<S2SV_StartBug> PyObject * bufobj = PyObject_CallObject ( readline , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> _PyObject_CallNoArg ( readline <S2SV_ModEnd> 
512,"<S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ","<S2SV_ModStart> , struct desc_struct * desc <S2SV_ModStart> if ( desc ) * desc = seg_desc ; "
513,<S2SV_StartBug> data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x8b ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = offset ; <S2SV_EndBug> <S2SV_StartBug> return l ; <S2SV_EndBug> <S2SV_StartBug> if ( a -> bits == 64 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x25 ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; <S2SV_EndBug> <S2SV_StartBug> if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; <S2SV_EndBug> ,<S2SV_ModStart> % 6 <S2SV_ModStart> data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> } <S2SV_ModStart> } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } <S2SV_ModStart> op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED <S2SV_ModEnd> <S2SV_ModStart> op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 <S2SV_ModEnd> <S2SV_ModStart> if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> <S2SV_ModStart> op -> operands [ 1 ] . regs [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
514,<S2SV_StartBug> unsigned long size ) <S2SV_EndBug> <S2SV_StartBug> end_gfn = gfn + ( size >> PAGE_SHIFT ) ; <S2SV_EndBug> ,<S2SV_ModStart> npages <S2SV_ModEnd> <S2SV_ModStart> npages <S2SV_ModEnd> 
515,"<S2SV_StartBug> int lpc = 0 ; <S2SV_EndBug> <S2SV_StartBug> unsigned laddr ; <S2SV_EndBug> <S2SV_StartBug> # ifdef HAVE_GNUTLS_GNUTLS_H <S2SV_EndBug> <S2SV_StartBug> xmlNode * login = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ssock == remote_tls_fd ) { <S2SV_EndBug> <S2SV_StartBug> session = create_tls_session ( csock , GNUTLS_SERVER ) ; <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> login = crm_recv_remote_msg ( session , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> login = crm_recv_remote_msg ( GINT_TO_POINTER ( csock ) , FALSE ) ; <S2SV_EndBug> <S2SV_StartBug> bail : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int flag ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( flag = fcntl ( csock , F_GETFL ) ) >= 0 ) { if ( fcntl ( csock , F_SETFL , flag | O_NONBLOCK ) < 0 ) { crm_err ( ""fcntl()<S2SV_blank>write<S2SV_blank>failed"" ) ; close ( csock ) ; return TRUE ; } } else { crm_err ( ""fcntl()<S2SV_blank>read<S2SV_blank>failed"" ) ; close ( csock ) ; return TRUE ; } if ( <S2SV_ModStart> crm_create_anon_tls_session <S2SV_ModEnd> <S2SV_ModStart> , anon_cred_s <S2SV_ModStart> num_clients ++ ; new_client = calloc ( 1 , sizeof ( cib_client_t ) ) ; new_client -> id = crm_generate_uuid ( ) ; new_client -> callback_id = NULL ; new_client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , new_client <S2SV_ModEnd> <S2SV_ModStart> new_client -> encrypted = TRUE ; new_client -> session = session <S2SV_ModEnd> <S2SV_ModStart> new_client -> session = <S2SV_ModEnd> <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
516,<S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug> ,"<S2SV_ModStart> num_bulk_out <S2SV_ModEnd> <S2SV_ModStart> { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } <S2SV_ModEnd> "
517,<S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( <S2SV_ModStart> - 1 ) <S2SV_ModEnd> 
518,"<S2SV_StartBug> ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" <S2SV_EndBug> <S2SV_StartBug> ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" <S2SV_EndBug> <S2SV_StartBug> ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\'start\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Start<S2SV_blank>service\'>"" ""</form>"" ""</td>"" , s -> name , res -> token <S2SV_ModEnd> <S2SV_ModStart> ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\'stop\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Stop<S2SV_blank>service\'>"" ""</form>"" ""</td>"" , s -> name , res -> token <S2SV_ModEnd> <S2SV_ModStart> ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\'restart\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Restart<S2SV_blank>service\'>"" ""</form>"" ""</td>"" , s -> name , res -> token ) ; StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=%s>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>value=\'%s\'<S2SV_blank>name=action>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'%s\'>"" ""</form>"" ""</td>"" , s -> name , res -> token <S2SV_ModEnd> <S2SV_ModStart> StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ; "
519,"<S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
520,"<S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug> ","<S2SV_ModStart> * <S2SV_ModStart> if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> * "
521,"<S2SV_StartBug> static void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
522,<S2SV_StartBug> int mapping_address = address - mb_mapping -> start_bits ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) { <S2SV_EndBug> <S2SV_StartBug> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) { <S2SV_EndBug> ,<S2SV_ModStart> nb_bits = req [ offset + 5 ] ; int <S2SV_ModStart> || nb_bits * 8 < nb <S2SV_ModStart> ] ; int nb_bytes = req [ offset + 5 <S2SV_ModStart> < nb || nb_bytes * 8 
523,<S2SV_StartBug> if ( net != c_net || ! tc -> t_sock ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
524,"<S2SV_StartBug> struct resv_map * reservations = vma_resv_map ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
525,<S2SV_StartBug> sc = create_spnego_ctx ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> 0 
526,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ; 
527,<S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
528,<S2SV_StartBug> case '\\r' : <S2SV_EndBug> ,"<S2SV_ModStart> \'""\' : case '\\\\' : case "
529,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
530,"<S2SV_StartBug> int perf_event_overflow ( struct perf_event * event , int nmi , <S2SV_EndBug> <S2SV_StartBug> return __perf_event_overflow ( event , nmi , 1 , data , regs ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
531,<S2SV_StartBug> size_t i ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
532,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> err = crypto_ahash_export ( req , state ) ; <S2SV_EndBug> <S2SV_StartBug> ctx2 -> more = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> bool more ; <S2SV_ModStart> lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> <S2SV_ModStart> : 0 ; release_sock ( sk ) <S2SV_ModStart> more ; if ( ! more ) return err <S2SV_ModEnd> 
533,<S2SV_StartBug> flags |= EXT4_GET_BLOCKS_PRE_IO ; <S2SV_EndBug> ,<S2SV_ModStart> if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ; 
534,"<S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> ",<S2SV_ModStart> static 
535,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ; 
536,<S2SV_StartBug> const char * errstr ; <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> # if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) <S2SV_ModStart> = NULL ; # else int status ; # endif <S2SV_ModEnd> <S2SV_ModStart> if ( errstr ) return - 1 ; # else status = <S2SV_ModEnd> <S2SV_ModStart> if ( status != 1 <S2SV_ModEnd> <S2SV_ModStart> # endif 
537,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> new_mnemonic [ strlen ( new_mnemonic ) - 1 ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ; layoutHome ( ) ; return ; } <S2SV_ModStart> MAX ( 0u , strnlen ( new_mnemonic , sizeof ( new_mnemonic ) <S2SV_ModEnd> <S2SV_ModStart> ) "
538,"<S2SV_StartBug> Fp = fopen ( filename , ""wb"" ) ; <S2SV_EndBug> <S2SV_StartBug> return HTTP_UNAUTHORIZED ; <S2SV_EndBug> ",<S2SV_ModStart> # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> # else return HTTP_NOT_FOUND ; # endif 
539,<S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> ,"<S2SV_ModStart> uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s"" , ""cpSeparate2ContigByRow"" ) ; return 0 ; } "
540,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> 
541,<S2SV_StartBug> if ( iterator -> next ) rfbDecrClientRef ( iterator -> next ) ; <S2SV_EndBug> ,<S2SV_ModStart> iterator && 
542,<S2SV_StartBug> if ( key -> type -> destroy ) <S2SV_EndBug> ,"<S2SV_ModStart> test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && "
543,<S2SV_StartBug> if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) <S2SV_EndBug> <S2SV_StartBug> pbi -> decoding_thread_count = num_token_partitions - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; } 
544,<S2SV_StartBug> if ( fileblock < INDIRECT_BLOCKS ) <S2SV_EndBug> <S2SV_StartBug> else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } 
545,"<S2SV_StartBug> int32_t leftoverblock , int32_t ntbytes , int32_t maxbytes , <S2SV_EndBug> <S2SV_StartBug> _sw32 ( dest - 4 , - value ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ntbytes + maxout > maxbytes ) { <S2SV_EndBug> <S2SV_StartBug> maxout = ( int64_t ) maxbytes - ( int64_t ) ntbytes ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ntbytes + neblock ) > maxbytes ) { <S2SV_EndBug> ",<S2SV_ModStart> destsize <S2SV_ModEnd> <S2SV_ModStart> if ( ntbytes > destsize ) { return - 1 ; } <S2SV_ModStart> destsize <S2SV_ModEnd> <S2SV_ModStart> destsize <S2SV_ModEnd> <S2SV_ModStart> destsize <S2SV_ModEnd> 
546,<S2SV_StartBug> zval_ptr_dtor ( value ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
547,<S2SV_StartBug> BIO * tmpout = NULL ; <S2SV_EndBug> <S2SV_StartBug> tmpout = BIO_new ( BIO_s_mem ( ) ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
548,<S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> buffer_size -= ( size_t ) pkg_length ; 
549,"
","
"
550,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
551,"<S2SV_StartBug> int copylen ; <S2SV_EndBug> <S2SV_StartBug> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) <S2SV_EndBug> <S2SV_StartBug> copylen = vnet_hdr . hdr_len ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len ) "
552,<S2SV_StartBug> problem_data_reload_from_dump_dir ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
553,"<S2SV_StartBug> return kvm_x86_ops -> set_msr ( vcpu , msr ) ; <S2SV_EndBug> ",<S2SV_ModStart> switch ( msr -> index ) { case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ; break ; case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ; } 
554,"<S2SV_StartBug> struct perf_event_context * ctx ; <S2SV_EndBug> <S2SV_StartBug> struct perf_event_context * gctx = group_leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & gctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> perf_remove_from_context ( group_leader , false ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> , * uninitialized_var ( gctx ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; perf_remove_from_context ( group_leader , false ) ; perf_event__state_init ( group_leader ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , false ) ; perf_event__state_init ( sibling ) ; put_ctx ( gctx ) ; } } else { <S2SV_ModStart> ctx -> mutex ) ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { synchronize_rcu ( ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } } perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) { mutex_unlock ( & <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
555,"<S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> <S2SV_ModStart> if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ; "
556,<S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> ,<S2SV_ModStart> 1U << ( unsigned int ) <S2SV_ModEnd> 
557,<S2SV_StartBug> if ( attr >= 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS "
558,<S2SV_StartBug> int req_len ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned <S2SV_ModStart> ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL 
559,"<S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
560,"<S2SV_StartBug> const int min_frame_target = MAX ( rc -> min_frame_bandwidth , <S2SV_EndBug> <S2SV_StartBug> rc -> av_per_frame_bandwidth >> 5 ) ; <S2SV_EndBug> <S2SV_StartBug> return target ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig * oxcf = & cpi -> oxcf ; const <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; } "
561,<S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ,<S2SV_ModStart> rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if ( 
562,"<S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) "
563,<S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> out_put_key : <S2SV_EndBug> ,<S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
564,"
","
"
565,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
566,"<S2SV_StartBug> static char * print_value ( cJSON * item , int depth , int fmt ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_NULL : out = cJSON_strdup ( ""null"" ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_Number : out = print_number ( item ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_String : out = print_string ( item ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_Array : out = print_array ( item , depth , fmt ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case cJSON_Object : out = print_object ( item , depth , fmt ) ; break ; <S2SV_EndBug> ","<S2SV_ModStart> , printbuffer * p <S2SV_ModStart> if ( p ) { <S2SV_ModStart> { out = ensure ( p , 5 ) ; if ( out ) strcpy ( out , ""null"" ) ; break ; } case cJSON_False : { out = ensure ( p , 6 ) ; if ( out ) strcpy ( out , ""false"" ) ; break ; } case cJSON_True : { out = ensure ( p , 5 ) ; if ( out ) strcpy ( out , ""true"" ) ; break ; } case cJSON_Number : out = print_number ( item , p ) ; break ; case cJSON_String : out = print_string ( item , p ) ; break ; case cJSON_Array : out = print_array ( item , depth , fmt , p ) ; break ; case cJSON_Object : out = print_object ( item , depth , fmt , p ) ; break ; } } else { switch ( ( item -> type ) & 255 ) { case cJSON_NULL : <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 <S2SV_ModStart> , 0 ) ; break ; } <S2SV_ModEnd> "
567,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> ( void ) cpi ; ( void ) fullpixel ; 
568,"<S2SV_StartBug> static void update_coef_probs ( VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_stats frame_branch_ct [ TX_SIZES ] [ PLANE_TYPES ] ; <S2SV_EndBug> <S2SV_StartBug> for ( tx_size = TX_4X4 ; tx_size <= max_tx_size ; ++ tx_size ) <S2SV_EndBug> <S2SV_StartBug> update_coef_probs_common ( w , cpi , tx_size , frame_branch_ct [ tx_size ] ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { vp9_coeff_stats frame_branch_ct [ PLANE_TYPES ] ; vp9_coeff_probs_model frame_coef_probs [ PLANE_TYPES ] ; if ( cpi -> td . counts -> tx . tx_totals [ tx_size ] <= 20 || ( tx_size >= TX_16X16 && cpi -> sf . tx_size_search_method == USE_TX_8X8 ) ) { vpx_write_bit ( w , 0 ) ; } else { build_tree_distribution ( cpi , tx_size , frame_branch_ct , frame_coef_probs ) ; <S2SV_ModStart> , frame_coef_probs <S2SV_ModEnd> <S2SV_ModStart> } } "
569,"<S2SV_StartBug> ptr = strchr ( ptr + 1 , '/' ) + 1 ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> 
570,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
571,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> assert_regexp_syntax_error ( ""\\\\x0"" ) ; assert_regexp_syntax_error ( ""\\\\x"" ) ; assert_regexp_syntax_error ( ""\\\\xxy"" ) ; "
572,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> L -> oldpc = 0 ; 
573,"<S2SV_StartBug> const u_char * ep , uint32_t phase , uint32_t doi0 _U_ , <S2SV_EndBug> <S2SV_StartBug> uint32_t proto0 _U_ , int depth ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ; <S2SV_EndBug> <S2SV_StartBug> size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case IPSECDOI_NTYPE_REPLAY_STATUS : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> isakmp_print ( ndo , cp , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> _U_ <S2SV_ModStart> _U_ <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) <S2SV_ModStart> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , "")"" ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } "
574,<S2SV_StartBug> if ( filter [ i ] . jf ) <S2SV_EndBug> <S2SV_StartBug> t_offset += is_near ( f_offset ) ? 2 : 6 ; <S2SV_EndBug> ,<S2SV_ModStart> && f_offset <S2SV_ModStart> 5 <S2SV_ModEnd> 
575,"<S2SV_StartBug> if ( test_bit ( DMF_FREEING , & md -> flags ) || <S2SV_EndBug> <S2SV_StartBug> dm_deleting_md ( md ) ) <S2SV_EndBug> <S2SV_StartBug> dm_get ( md ) ; <S2SV_EndBug> ",<S2SV_ModStart> spin_lock ( & _minor_lock ) ; <S2SV_ModStart> { md = NULL ; goto out ; } <S2SV_ModEnd> <S2SV_ModStart> ) ; out : spin_unlock ( & _minor_lock 
576,<S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 2 ) <S2SV_EndBug> <S2SV_StartBug> else if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic ) <S2SV_EndBug> <S2SV_StartBug> num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; <S2SV_EndBug> <S2SV_StartBug> num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) <S2SV_EndBug> <S2SV_StartBug> if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) <S2SV_EndBug> <S2SV_StartBug> - ps_dec -> u2_total_mbs_coded ; <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic == 2 ) <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> prev_slice_err = 2 <S2SV_ModEnd> <S2SV_ModStart> ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } } else { if ( ( <S2SV_ModStart> ) > ps_dec -> u2_total_mbs_coded ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - <S2SV_ModEnd> <S2SV_ModStart> ; ps_cur_poc = & s_tmp_poc ; } else if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
577,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO 
578,<S2SV_StartBug> if ( L_ICANON ( tty ) ) <S2SV_EndBug> ,<S2SV_ModStart> && ! L_EXTPROC ( tty ) 
579,"<S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug> ","<S2SV_ModStart> bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> MagickMax ( <S2SV_ModStart> bytes_per_line * sun_info . width ) , <S2SV_ModStart>  <S2SV_ModEnd> "
580,"<S2SV_StartBug> int release_vp9_frame_buffer ( void * cb_priv , <S2SV_EndBug> ",<S2SV_ModStart> static 
581,"<S2SV_StartBug> void vp9_cost_tokens ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_tree <S2SV_ModEnd> 
582,"<S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long cr4 ; <S2SV_ModStart> HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> "
583,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) buffer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
584,"<S2SV_StartBug> code = validate_as_request ( kdc_active_realm , request , * princ , <S2SV_EndBug> ","<S2SV_ModStart> princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ; "
585,"<S2SV_StartBug> dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> ","<S2SV_ModStart> ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> "
586,"<S2SV_StartBug> u8 obuf [ 0x40 ] , ibuf [ 0x40 ] ; <S2SV_EndBug> <S2SV_StartBug> if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> switch ( num ) { <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 3 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 0 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x10 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , 1 , ibuf , 2 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 1 ] = ibuf [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> msg [ 0 ] . buf [ 0 ] = ibuf [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x08 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 3 , <S2SV_EndBug> <S2SV_StartBug> ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0x09 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = msg [ 0 ] . len ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 3 ] = msg [ 0 ] . addr ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & obuf [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d , obuf , msg [ 0 ] . len + 4 , <S2SV_EndBug> <S2SV_StartBug> ibuf , msg [ 1 ] . len + 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg [ 1 ] . buf , & ibuf [ 1 ] , msg [ 1 ] . len ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & d -> i2c_mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dw2102_state * state <S2SV_ModEnd> <S2SV_ModStart> state = d -> priv ; <S2SV_ModStart> if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> data_mutex ) ; mutex_unlock ( & d -> "
587,<S2SV_StartBug> blockcnt = ( ( len + pos ) + blocksize - 1 ) >> <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 1 || len == 0xffffffff ) { return - 1 ; } 
588,<S2SV_StartBug> struct cred * cred ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cred ) <S2SV_EndBug> <S2SV_StartBug> return create_user_ns ( cred ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; int err = - ENOMEM <S2SV_ModStart> cred ) { err = create_user_ns ( cred ) ; if ( err ) put_cred ( cred ) ; else <S2SV_ModEnd> <S2SV_ModStart> } return err <S2SV_ModEnd> 
589,<S2SV_StartBug> status = sctp_v4_protosw_init ( ) ; <S2SV_EndBug> <S2SV_StartBug> status = register_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> <S2SV_StartBug> err_protosw_init : <S2SV_EndBug> ,<S2SV_ModStart> register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> <S2SV_ModStart> sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> <S2SV_ModStart> : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults 
590,<S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> ,<S2SV_ModStart> atomic_dec ( & chip -> active ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
591,"<S2SV_StartBug> cntsize ( in , & sumlen , & nnode ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) "
592,<S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> ,<S2SV_ModStart> interlaced_dct = 0 ; s -> 
593,"<S2SV_StartBug> ret = read ( p_dev -> fd , & ev , sizeof ( ev ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
594,"<S2SV_StartBug> int status = 0 ; <S2SV_EndBug> <S2SV_StartBug> state = nfs4_do_open ( dir , & path , flags , sattr , cred ) ; <S2SV_EndBug> <S2SV_StartBug> status = nfs4_intent_set_file ( nd , & path , state ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_close_sync ( & path , state , flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> fmode_t fmode = flags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , fmode <S2SV_ModStart> , fmode <S2SV_ModStart> fmode <S2SV_ModEnd> "
595,<S2SV_StartBug> struct key * keyring ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( new -> thread_keyring ) return 0 
596,<S2SV_StartBug> if ( index > glyphCache -> glyphCache [ id ] . number ) <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
597,"<S2SV_StartBug> end = strchr ( * value + 1 , \'""\' ) ; <S2SV_EndBug> <S2SV_StartBug> end ++ ; <S2SV_EndBug> ","<S2SV_ModStart> char * p = end = <S2SV_ModEnd> <S2SV_ModStart> ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \'""\' ) break ; } p ++ ; end ++ ; } if ( * end != \'""\' <S2SV_ModEnd> <S2SV_ModStart> = ++ p <S2SV_ModEnd> "
598,"<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
599,<S2SV_StartBug> if ( ! file ) <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ,<S2SV_ModStart> || count > OE_SSIZE_MAX <S2SV_ModStart> if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } 
600,"<S2SV_StartBug> cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) : <S2SV_EndBug> ",<S2SV_ModStart> jas_stream_memopen2 <S2SV_ModEnd> 
601,"<S2SV_StartBug> checkstackp ( L , 1 , ra ) ; <S2SV_EndBug> ",<S2SV_ModStart> checkstackGCp <S2SV_ModEnd> 
602,<S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> ,"<S2SV_ModStart> 0 , 0 , "
603,<S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( zPath == 0 ) zPath = """" ; "
604,"<S2SV_StartBug> union sctp_addr_param * addr_param ; <S2SV_EndBug> <S2SV_StartBug> addr_param = ( union sctp_addr_param * ) hdr -> params ; <S2SV_EndBug> <S2SV_StartBug> ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) , <S2SV_EndBug> ","<S2SV_ModStart> __u32 serial <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> chunk , true , <S2SV_ModEnd> "
605,<S2SV_StartBug> vstart += entry -> vn_aux ; <S2SV_EndBug> ,<S2SV_ModStart> st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> 
606,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && src -> linesize 
607,"<S2SV_StartBug> n = r -> sector_count ; <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = n * 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , <S2SV_ModEnd> <S2SV_ModStart> n , scsi_read_complete , r ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
608,"<S2SV_StartBug> vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
609,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
610,<S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> <S2SV_ModStart> ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock "
611,"<S2SV_StartBug> error = xfs_da_shrink_inode ( args , 0 , bp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( bp && ( <S2SV_ModEnd> <S2SV_ModStart> != 0 ) <S2SV_ModEnd> 
612,<S2SV_StartBug> if ( ! stream -> config . cfg . g_w || ! stream -> config . cfg . g_h ) <S2SV_EndBug> <S2SV_StartBug> if ( stream -> config . cfg . g_profile != 0 && ! global -> experimental_bitstream ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! streami -> config . out_fn ) <S2SV_EndBug> <S2SV_StartBug> const char * a = stream -> config . out_fn ; <S2SV_EndBug> <S2SV_StartBug> const char * a = stream -> config . stats_fn ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) global ; <S2SV_ModStart> g_input_bit_depth > ( unsigned int ) stream -> config . cfg . g_bit_depth ) { fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>codec<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)<S2SV_blank>less<S2SV_blank>than<S2SV_blank>input<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)"" , stream -> index , ( int ) stream -> config . cfg . g_bit_depth , stream -> config . cfg . g_input_bit_depth ) ; } for ( streami = stream ; streami ; streami = streami -> next ) { if ( ! streami -> config . out_fn ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>Output<S2SV_blank>file<S2SV_blank>is<S2SV_blank>required<S2SV_blank>(specify<S2SV_blank>with<S2SV_blank>-o)"" , streami -> index ) ; if ( streami != stream ) { const char * a = stream <S2SV_ModEnd> <S2SV_ModStart> ; const char * b = streami -> config . out_fn ; if ( ! strcmp ( a , b ) && strcmp ( a , ""/dev/null"" ) && strcmp ( a , "":nul"" ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ; } <S2SV_ModEnd> <S2SV_ModStart> stats_fn ; const char * b = streami -> config . stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ; } # if CONFIG_FP_MB_STATS <S2SV_ModEnd> <S2SV_ModStart> fpmb_stats_fn ; const char * b = streami -> config . fpmb_stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( ""Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>mb<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)"" , streami -> index , stream -> index ) ; } # endif <S2SV_ModEnd> "
613,"<S2SV_StartBug> ip_printroute ( ndo , cp , option_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModStart> == - 1 ) goto trunc 
614,"<S2SV_StartBug> if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu "
615,"<S2SV_StartBug> bool issrc , isneg ; <S2SV_EndBug> <S2SV_StartBug> off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; <S2SV_EndBug> <S2SV_StartBug> if ( isneg ) <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; <S2SV_EndBug> <S2SV_StartBug> * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( issrc && isneg ) <S2SV_EndBug> ","<S2SV_ModStart> , isimm <S2SV_ModStart> isimm = aux -> alu_state & BPF_ALU_IMMEDIATE ; <S2SV_ModStart> isimm ) { <S2SV_ModEnd> <S2SV_ModStart> BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; } else { if ( isneg ) <S2SV_ModEnd> <S2SV_ModStart> BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 <S2SV_ModEnd> <S2SV_ModStart> BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit <S2SV_ModEnd> <S2SV_ModStart> BPF_SUB <S2SV_ModEnd> <S2SV_ModStart> BPF_ALU64_REG ( BPF_OR <S2SV_ModEnd> <S2SV_ModStart> off_reg <S2SV_ModEnd> <S2SV_ModStart> BPF_NEG <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; * patch ++ = <S2SV_ModStart> } <S2SV_ModStart> && ! isimm "
616,<S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> msg -> msg_namelen = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> 
617,"<S2SV_StartBug> size_t i , maxcount ; <S2SV_EndBug> <S2SV_StartBug> ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < CDF_TOLE4 ( si -> si_count ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> info , count , & maxcount ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> CDF_TOLE4 <S2SV_ModEnd> <S2SV_ModStart> if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
618,"<S2SV_StartBug> for ( j = 0 ; j < size ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( ""%02x"" , buf [ j + idx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . val != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( op . ptr != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""ptr"" , ""0x%08"" PFMT64x ""\\n"" , op . ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . refptr != - 1 ) <S2SV_EndBug> <S2SV_StartBug> printline ( ""refptr"" , ""%d\\n"" , op . refptr ) ; <S2SV_EndBug> ","<S2SV_ModStart> int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> minsz <S2SV_ModEnd> <S2SV_ModStart> ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> <S2SV_ModStart> ; r_cons_printf ( ""%02x"" , ch <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } "
619,"<S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> ","<S2SV_ModStart> open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> "
620,<S2SV_StartBug> if ( ret < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> goto error ; <S2SV_ModEnd> 
621,"<S2SV_StartBug> REQ ( CHILD ( n , 0 ) , ASYNC ) ; <S2SV_EndBug> <S2SV_StartBug> return ast_for_funcdef_impl ( c , CHILD ( n , 1 ) , decorator_seq , <S2SV_EndBug> <S2SV_StartBug> 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , ""async"" ) == 0 <S2SV_ModEnd> <S2SV_ModStart> n <S2SV_ModEnd> <S2SV_ModStart> true <S2SV_ModEnd> "
622,"<S2SV_StartBug> sprintf ( buf , ""%s.conf"" , set ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( buf , sizeof ( buf ) <S2SV_ModEnd> <S2SV_ModStart> ""\\\n<S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n"" <S2SV_ModEnd> "
623,<S2SV_StartBug> hdr = ( void * ) p - head -> iov_base ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( hdr > head -> iov_len ) return 0 
624,"<S2SV_StartBug> char * p , * q , * r ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( p = line + 18 ; isspace ( * p ) ; p ++ ) <S2SV_EndBug> <S2SV_StartBug> lenIV = atoi ( line + 6 ) ; <S2SV_EndBug> <S2SV_StartBug> && strstr ( line , ""readstring"" ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( p = strstr ( line , ""/Subrs"" ) ) && isdigit ( p [ 7 ] ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ( p = strstr ( line , ""/CharStrings"" ) ) && isdigit ( p [ 13 ] ) ) <S2SV_EndBug> <S2SV_StartBug> for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> set_lenIV ( line <S2SV_ModEnd> <S2SV_ModStart> ) { set_cs_start ( line ) <S2SV_ModEnd> <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) "
625,"<S2SV_StartBug> if ( * p ) { <S2SV_EndBug> <S2SV_StartBug> * q = 0 ; <S2SV_EndBug> <S2SV_StartBug> cmd = p + 1 ; <S2SV_EndBug> <S2SV_StartBug> * p = \'""\' ; <S2SV_EndBug> ",<S2SV_ModStart> char op0 = 0 ; <S2SV_ModStart> op0 = * q ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> op0 <S2SV_ModEnd> 
626,<S2SV_StartBug> ( mysql -> options . extension && mysql -> options . extension -> ssl_crlpath ) ) <S2SV_EndBug> <S2SV_StartBug> mysql -> options . use_ssl = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( mysql -> client_flag & CLIENT_SSL ) <S2SV_EndBug> <S2SV_StartBug> unsigned long ssl_error ; <S2SV_EndBug> ,"<S2SV_ModStart> || ( mysql -> options . extension && mysql -> options . extension -> ssl_enforce ) <S2SV_ModStart> TRUE <S2SV_ModEnd> <S2SV_ModStart> options . extension && mysql -> options . extension -> ssl_enforce ) { DBUG_ASSERT ( mysql -> options . use_ssl ) ; if ( ! ( mysql -> server_capabilities & CLIENT_SSL ) ) { set_mysql_extended_error ( mysql , CR_SSL_CONNECTION_ERROR , unknown_sqlstate , ER ( CR_SSL_CONNECTION_ERROR ) , ""SSL<S2SV_blank>is<S2SV_blank>required<S2SV_blank>but<S2SV_blank>the<S2SV_blank>server<S2SV_blank>doesn\'t<S2SV_blank>"" ""support<S2SV_blank>it"" ) ; goto error ; } } if ( ( mysql -> server_capabilities & CLIENT_SSL ) && mysql -> options . use_ssl <S2SV_ModEnd> <S2SV_ModStart> if ( ! mysql -> options . ssl_cipher ) { SET_OPTION ( ssl_cipher , default_ssl_cipher ) ; } "
627,<S2SV_StartBug> if ( header -> biSize >= 40U ) { <S2SV_EndBug> ,"<S2SV_ModStart> biBitCount == 0 ) { fprintf ( stderr , ""Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n"" , 0 ) ; return OPJ_FALSE ; } if ( header -> "
628,"<S2SV_StartBug> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; <S2SV_EndBug> ",<S2SV_ModStart> unlink ( path ) ; <S2SV_ModStart> O_EXCL <S2SV_ModEnd> 
629,<S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> ,<S2SV_ModStart> kfree_skb ( skb ) ; 
630,<S2SV_StartBug> vp8_clear_system_state ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> ctx -> si . w = 0 ; ctx -> si . h = 0 ; 
631,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> <S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
632,"<S2SV_StartBug> ldblk , sizeof ( * BImgBuff ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 
633,<S2SV_StartBug> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart> ; } else memset ( & ifr , 0 , sizeof ( ifr ) ) "
634,<S2SV_StartBug> if ( gfs ) <S2SV_EndBug> ,<S2SV_ModStart> last_name = 0 ; 
635,"<S2SV_StartBug> void bpf_map_inc ( struct bpf_map * map , bool uref ) <S2SV_EndBug> <S2SV_StartBug> atomic_inc ( & map -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct bpf_map * <S2SV_ModEnd> <S2SV_ModStart> if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec <S2SV_ModEnd> <S2SV_ModStart> return ERR_PTR ( - EBUSY ) ; } <S2SV_ModStart> return map ; 
636,<S2SV_StartBug> usb_conv_info -> class_data = u3v_conv_info ; <S2SV_EndBug> ,<S2SV_ModStart> ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0 
637,"<S2SV_StartBug> if ( plen == 0 ) { <S2SV_EndBug> <S2SV_StartBug> phdr = sctp_get_next_param ( m , offset , <S2SV_EndBug> ",<S2SV_ModStart> < sizeof ( struct sctp_paramhdr ) <S2SV_ModEnd> <S2SV_ModStart> if ( plen < sizeof ( struct sctp_asconf_addrv4_param ) ) { return ( - 101 ) ; } 
638,<S2SV_StartBug> else if ( verify & GNUTLS_CERT_INVALID ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } if ( error == NULL ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
639,"<S2SV_StartBug> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 
640,"<S2SV_StartBug> PyObject * logical = NULL ; <S2SV_EndBug> <S2SV_StartBug> FriBidiParType base = FRIBIDI_TYPE_RTL ; <S2SV_EndBug> <S2SV_StartBug> { ""logical"" , ""base_direction"" , ""encoding"" , ""clean"" , ""reordernsm"" , NULL } ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PyArg_ParseTupleAndKeywords ( args , kw , ""O|isii"" , kwargs , <S2SV_EndBug> <S2SV_StartBug> & logical , & base , & encoding , & clean , & reordernsm ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) <S2SV_EndBug> <S2SV_StartBug> if ( PyUnicode_Check ( logical ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( PyString_Check ( logical ) ) <S2SV_EndBug> ","<S2SV_ModStart> PyUnicodeObject <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""U|iii"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } return unicode_log2vis <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
641,<S2SV_StartBug> nfca_poll -> nfcid1_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_NFCID1_MAXSIZE ) "
642,"<S2SV_StartBug> int zero_bits = * in & 0x07 ; <S2SV_EndBug> <S2SV_StartBug> size_t octets_left = inlen - 1 ; <S2SV_EndBug> <S2SV_StartBug> int i , count = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <S2SV_ModEnd> "
643,<S2SV_StartBug> if ( uid >= AID_APP ) { <S2SV_EndBug> ,<S2SV_ModStart> multiuser_get_app_id ( uid ) <S2SV_ModEnd> 
644,"<S2SV_StartBug> ret = get_tag ( asn1 , len , & inner_tag , & asn1 , & len , & rem , & rlen ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
645,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * s , 1 ) ; "
646,"<S2SV_StartBug> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ff_set_dimensions ( avctx , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
647,"<S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> <S2SV_StartBug> char * src ; <S2SV_EndBug> <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> <S2SV_StartBug> ret += chars ; <S2SV_EndBug> <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> ","<S2SV_ModStart> struct iov_iter * from <S2SV_ModEnd> <S2SV_ModStart> = 0 <S2SV_ModStart> = 0 <S2SV_ModEnd> <S2SV_ModStart> = iov_iter_count ( from ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> <S2SV_ModStart> do_wakeup = 1 ; <S2SV_ModStart> ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> <S2SV_ModStart> int copied <S2SV_ModEnd> <S2SV_ModStart> copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> <S2SV_ModStart> copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> <S2SV_ModStart> copied <S2SV_ModEnd> <S2SV_ModStart> copied <S2SV_ModEnd> <S2SV_ModStart> if ( ! iov_iter_count ( from ) <S2SV_ModEnd> "
648,"<S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> ","<S2SV_ModStart> ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } <S2SV_ModStart> ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } "
649,"<S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , optlen + 2 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> ; if ( i + 2 + optlen > length ) return - 1 
650,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
651,<S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || shdr -> sh_size > SIZE_MAX 
652,<S2SV_StartBug> const gchar * to = xmpp_stanza_get_to ( message ) ; <S2SV_EndBug> <S2SV_StartBug> Jid * jid_to = jid_create ( to ) ; <S2SV_EndBug> ,"<S2SV_ModStart> Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( ""Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s"" , stanza_from ) ; return TRUE ; } <S2SV_ModStart>  <S2SV_ModEnd> "
653,<S2SV_StartBug> buff [ r ] = '\\0' ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> "
654,<S2SV_StartBug> return error ; <S2SV_EndBug> ,<S2SV_ModStart> < 0 ? error : 0 
655,<S2SV_StartBug> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <S2SV_EndBug> ,<S2SV_ModStart> || num >= 256 
656,"<S2SV_StartBug> register const u_char * tptr ) <S2SV_EndBug> <S2SV_StartBug> u_int hexdump = FALSE ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> <S2SV_ModStart> if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data"" ) ) ; return hexdump ; } <S2SV_ModStart> if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , ""(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)"" , length - 1 ) ) ; hexdump = TRUE ; break ; } "
657,"<S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
658,"<S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE ) "
659,"<S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
660,"<S2SV_StartBug> void vp9_write_nmv_probs ( VP9_COMMON * cm , int usehp , vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> nmv_context * const mvc = & cm -> fc . nmvc ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer * w , nmv_context_counts * const counts <S2SV_ModEnd> <S2SV_ModStart> -> nmvc ; <S2SV_ModEnd> "
661,"<S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rows , <S2SV_ModEnd> <S2SV_ModStart> columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> <S2SV_ModStart> rows <S2SV_ModEnd> "
662,"<S2SV_StartBug> int frame_count , <S2SV_EndBug> <S2SV_StartBug> int mb_cols = cpi -> common . mb_cols ; <S2SV_EndBug> <S2SV_StartBug> int mb_rows = cpi -> common . mb_rows ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned int , accumulator , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint16_t , count , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * mbd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * f = cpi -> frames [ alt_ref_index ] ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , predictor , 16 * 16 * 3 ) ; <S2SV_EndBug> <S2SV_StartBug> uint8_t * input_buffer [ MAX_MB_PLANE ] ; <S2SV_EndBug> <S2SV_StartBug> assert ( mbd -> plane [ 1 ] . subsampling_x == mbd -> plane [ 1 ] . subsampling_y ) ; <S2SV_EndBug> <S2SV_StartBug> # if ALT_REF_MC_ENABLED <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . mv_row_max = ( ( cpi -> common . mb_rows - 1 - mb_row ) * 16 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( accumulator , 0 , 16 * 16 * 3 * sizeof ( accumulator [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( count , 0 , 16 * 16 * 3 * sizeof ( count [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> # if ALT_REF_MC_ENABLED <S2SV_EndBug> <S2SV_StartBug> cpi -> mb . mv_col_max = ( ( cpi -> common . mb_cols - 1 - mb_col ) * 16 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> frames [ frame ] == NULL ) <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ alt_ref_index ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_stride ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> filter_weight = err < THRESH_LOW <S2SV_EndBug> <S2SV_StartBug> ? 2 : err < THRESH_HIGH ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> cpi -> frames [ frame ] -> y_buffer + mb_y_offset , <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ k ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst1 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> stride = cpi -> alt_ref_buffer . uv_stride ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < mb_uv_height ; j ++ , k ++ ) { <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ k ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst1 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> pval *= cpi -> fixed_divide [ count [ m ] ] ; <S2SV_EndBug> <S2SV_StartBug> dst2 [ byte ] = ( uint8_t ) pval ; <S2SV_EndBug> <S2SV_StartBug> byte += stride - mb_uv_height ; <S2SV_EndBug> <S2SV_StartBug> mb_y_offset += 16 ; <S2SV_EndBug> <S2SV_StartBug> mb_uv_offset += mb_uv_height ; <S2SV_EndBug> <S2SV_StartBug> mb_uv_offset += mb_uv_height * ( f -> uv_stride - mb_cols ) ; <S2SV_EndBug> ","<S2SV_ModStart> YV12_BUFFER_CONFIG * * frames , <S2SV_ModStart> ( frames [ alt_ref_index ] -> y_crop_width + 15 ) >> 4 <S2SV_ModEnd> <S2SV_ModStart> ( frames [ alt_ref_index ] -> y_crop_height + 15 ) >> 4 <S2SV_ModEnd> <S2SV_ModStart> DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ <S2SV_ModEnd> <S2SV_ModStart> ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> [ <S2SV_ModEnd> <S2SV_ModStart> ] <S2SV_ModStart> td . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , predictor16 [ 16 * 16 * 3 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> predictor8 [ 16 * 16 * 3 ] ) ; uint8_t * predictor ; # else DECLARE_ALIGNED ( 16 , uint8_t , predictor [ <S2SV_ModEnd> <S2SV_ModStart> ] ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> const int mb_uv_width = 16 >> mbd -> plane [ 1 ] . subsampling_x ; <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if <S2SV_ModEnd> <S2SV_ModStart> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { predictor = CONVERT_TO_BYTEPTR ( predictor16 ) ; } else { predictor = predictor8 ; } # endif <S2SV_ModEnd> <S2SV_ModStart> cpi -> td . <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> cpi -> td . <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const int thresh_low = 10000 ; const int thresh_high = 20000 ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> thresh_low <S2SV_ModEnd> <S2SV_ModStart> thresh_high <S2SV_ModEnd> <S2SV_ModStart> frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> u_buffer + mb_uv_offset , frames [ frame ] -> v_buffer + mb_uv_offset , frames [ frame ] -> y_stride , mb_uv_width , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { int adj_strength = strength + 2 * ( mbd -> bd - 8 ) ; vp9_highbd_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , adj_strength , filter_weight , accumulator , count ) ; vp9_highbd_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_highbd_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 512 , count + 512 ) ; } else { vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; } # else vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { uint16_t * dst1_16 ; uint16_t * dst2_16 ; dst1 = cpi -> alt_ref_buffer . y_buffer ; dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> <S2SV_ModStart> dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) ; dst2_16 = CONVERT_TO_SHORTPTR ( dst2 ) ; <S2SV_ModStart> mb_uv_width <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dst2_16 [ byte ] = ( uint16_t <S2SV_ModEnd> <S2SV_ModStart> mb_uv_width ; } } else { dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } } # else dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } # endif <S2SV_ModEnd> <S2SV_ModStart> ; mb_uv_offset += mb_uv_width ; } mb_y_offset += 16 * ( f -> y_stride - mb_cols ) <S2SV_ModStart> * <S2SV_ModEnd> <S2SV_ModStart> mb_uv_width * mb_cols <S2SV_ModEnd> "
663,<S2SV_StartBug> if ( l >= ( len - o ) ) { <S2SV_EndBug> ,<S2SV_ModStart> - 4 
664,<S2SV_StartBug> if ( ! rtlpriv -> usb_data ) <S2SV_EndBug> <S2SV_StartBug> spin_lock_init ( & rtlpriv -> locks . usb_lock ) ; <S2SV_EndBug> <S2SV_StartBug> complete ( & rtlpriv -> firmware_loading_complete ) ; <S2SV_EndBug> ,<S2SV_ModStart> { ieee80211_free_hw ( hw ) ; <S2SV_ModStart> } <S2SV_ModStart> ) ; kfree ( rtlpriv -> usb_data 
665,"<S2SV_StartBug> ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; <S2SV_EndBug> ",<S2SV_ModStart> ret = <S2SV_ModStart> if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; } 
666,<S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> ,<S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && <S2SV_ModStart> indexw < width && 
667,<S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ,<S2SV_ModStart> ( int ) <S2SV_ModStart> ( int ) <S2SV_ModStart> <= 0 || ( int ) ( g -> sect * g -> head ) 
668,"<S2SV_StartBug> int retval = 0 ; <S2SV_EndBug> <S2SV_StartBug> retval = - ENODEV ; <S2SV_EndBug> <S2SV_StartBug> bytes_read = snprintf ( in_buffer , 20 , ""%lld\\n"" , dev -> bbu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * ppos < bytes_read ) { <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ","<S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> "
669,<S2SV_StartBug> draw_info -> geometry = AcquireString ( geometry ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ( void ) CloneString ( & <S2SV_ModStart> , <S2SV_ModEnd> "
670,"<S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
671,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int layer ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; <S2SV_EndBug> ,"<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> sl , tl ; int alt_ref_idx = svc -> number_spatial_layers ; svc -> spatial_layer_id = 0 ; svc -> temporal_layer_id = 0 ; if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . pass == 2 ) { if ( vpx_realloc_frame_buffer ( & cpi -> svc . empty_frame . img , SMALL_FRAME_WIDTH , SMALL_FRAME_HEIGHT , cpi -> common . subsampling_x , cpi -> common . subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cpi -> common . use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , cpi -> common . byte_alignment , NULL , NULL , NULL ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>empty<S2SV_blank>frame<S2SV_blank>for<S2SV_blank>multiple<S2SV_blank>frame<S2SV_blank>"" ""contexts"" ) ; memset ( cpi -> svc . empty_frame . img . buffer_alloc , 0x80 , cpi -> svc . empty_frame . img . buffer_alloc_sz ) ; } for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { int layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * const lrc = & lc -> rc ; int i ; lc -> current_video_frame_in_layer = 0 ; lc -> layer_size = 0 ; lc -> frames_from_key_frame = 0 ; lc -> last_frame_type = FRAME_TYPES ; lrc -> ni_av_qi = oxcf -> worst_allowed_q ; lrc -> total_actual_bits = 0 ; lrc -> total_target_vs_actual = 0 ; lrc -> ni_tot_qi = 0 ; lrc -> tot_q = 0.0 ; lrc -> avg_q = 0.0 ; lrc -> ni_frames = 0 ; lrc -> decimation_count = 0 ; lrc -> decimation_factor = 0 ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { lrc -> rate_correction_factors [ i ] = 1.0 ; } if ( cpi -> oxcf . rc_mode == VPX_CBR ) { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ; } else { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; lrc -> last_q [ INTER_FRAME ] = oxcf -> best_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; lrc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; if ( oxcf -> ss_enable_auto_arf [ sl ] ) lc -> alt_ref_idx = alt_ref_idx ++ ; else lc -> alt_ref_idx = INVALID_IDX ; lc -> gold_ref_idx = INVALID_IDX ; } lrc -> buffer_level = oxcf -> starting_buffer_level_ms * lc -> target_bandwidth / 1000 ; lrc -> bits_off_target = lrc -> buffer_level ; } } if ( ! <S2SV_ModEnd> <S2SV_ModStart> && cpi -> oxcf . rc_mode == VPX_CBR ) && alt_ref_idx < REF_FRAMES ) <S2SV_ModEnd> <S2SV_ModStart> 0 ] . gold_ref_idx = alt_ref_idx ; <S2SV_ModEnd> "
672,"<S2SV_StartBug> struct inode * inode = page -> mapping -> host ; <S2SV_EndBug> <S2SV_StartBug> ret = f2fs_mpage_readpages ( page -> mapping , NULL , page , 1 , false ) ; <S2SV_EndBug> ",<S2SV_ModStart> page_file_mapping ( page ) <S2SV_ModEnd> <S2SV_ModStart> page_file_mapping ( page ) <S2SV_ModEnd> 
673,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( ""ANOPE_FLAGS_COMPAT"" , & chansvs . me -> conf_table ) ; "
674,<S2SV_StartBug> ddi . dinfo_nboards = dgnc_NumBoards ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & ddi , 0 , sizeof ( ddi ) ) ; "
675,<S2SV_StartBug> if ( po -> fanout ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out_unlock ; } <S2SV_ModEnd> 
676,<S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; 
677,"<S2SV_StartBug> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <S2SV_EndBug> <S2SV_StartBug> ext4_debug ( ""Dump<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>completed_io<S2SV_blank>list<S2SV_blank>\\n"" , inode -> i_ino ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ","<S2SV_ModStart> unsigned long flags ; <S2SV_ModStart> ) ; spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags <S2SV_ModStart> spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ; "
678,"<S2SV_StartBug> static int __perf_event_overflow ( struct perf_event * event , int nmi , <S2SV_EndBug> <S2SV_StartBug> if ( nmi ) { <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> perf_event_output ( event , nmi , data , regs ) ; <S2SV_EndBug> <S2SV_StartBug> if ( nmi ) { <S2SV_EndBug> <S2SV_StartBug> irq_work_queue ( & event -> pending ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( event -> overflow_handler ) event -> overflow_handler ( event , data , regs ) ; else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
679,"<S2SV_StartBug> assert_regexp_syntax_error ( "")"" ) ; <S2SV_EndBug> <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\ta\\0b\\0c\\0"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\ta\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0x\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0b\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""abc"" ) ; <S2SV_ModStart> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" <S2SV_ModEnd> "
680,"<S2SV_StartBug> static int jas_iccputsint ( jas_stream_t * out , int n , longlong val ) <S2SV_EndBug> <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ",<S2SV_ModStart> jas_longlong <S2SV_ModEnd> <S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
681,"<S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size <S2SV_ModStart>  <S2SV_ModEnd> "
682,<S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
683,"<S2SV_StartBug> static int changedline ( const Proto * p , int oldpc , int newpc ) { <S2SV_EndBug> ",<S2SV_ModStart> if ( p -> lineinfo == NULL ) return 0 ; 
684,"<S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool disconnect ; <S2SV_ModStart> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> disconnect ? & unmounted : NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> } "
685,"<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * codec , <S2SV_EndBug> <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
686,<S2SV_StartBug> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
687,"<S2SV_StartBug> static VALUE from_document ( VALUE klass , VALUE document ) <S2SV_EndBug> <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> ","<S2SV_ModStart> int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; xmlDocPtr doc ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ; Data_Get_Struct ( document , xmlDoc , doc ) ; doc = doc -> doc ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } <S2SV_ModEnd> <S2SV_ModStart> rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ; "
688,"<S2SV_StartBug> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; <S2SV_EndBug> <S2SV_StartBug> setup_syscalls_segments ( ctxt , & cs , & ss ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt 
689,"<S2SV_StartBug> static void send ( node_t * node , node_t * child , byte * fout ) { <S2SV_EndBug> <S2SV_StartBug> send ( node -> parent , node , fout ) ; <S2SV_EndBug> <S2SV_StartBug> if ( child ) { <S2SV_EndBug> ","<S2SV_ModStart> , int maxoffset <S2SV_ModStart> , maxoffset <S2SV_ModStart> if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; } "
690,"<S2SV_StartBug> int bytes_read = read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
691,"<S2SV_StartBug> if ( ! revs -> blob_objects ) <S2SV_EndBug> <S2SV_StartBug> show ( obj , path , name , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> size_t pathlen ; <S2SV_ModStart> pathlen = path -> len ; strbuf_addstr ( path , name ) ; <S2SV_ModStart> -> buf <S2SV_ModEnd> <S2SV_ModStart> strbuf_setlen ( path , pathlen ) ; "
692,"<S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> <S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> <S2SV_ModStart> ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> "
693,"<S2SV_StartBug> static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid , <S2SV_EndBug> <S2SV_StartBug> if ( ns_capable ( ns -> parent , cap_setid ) ) <S2SV_EndBug> ","<S2SV_ModStart> const struct file * file , <S2SV_ModStart> && file_ns_capable ( file , ns -> parent , cap_setid ) "
694,"<S2SV_StartBug> unsigned long cs ; <S2SV_EndBug> <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ; <S2SV_EndBug> ","<S2SV_ModStart> eip , cs ; u16 old_cs <S2SV_ModEnd> <S2SV_ModStart> struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <S2SV_ModStart> eip <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> "
695,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return body ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> } 
696,"<S2SV_StartBug> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> if ( bufLen < 2 ) break ; <S2SV_ModStart> bufLen -= 2 ; 
697,"<S2SV_StartBug> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
698,"<S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> 
699,<S2SV_StartBug> struct iovec iov ; <S2SV_EndBug> <S2SV_StartBug> if ( ret < local_nr_pages ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nr_pages ; j ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; struct bio_vec * bvec <S2SV_ModStart> unlikely ( <S2SV_ModStart> ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> <S2SV_ModStart> bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> "
700,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
701,"<S2SV_StartBug> ut8 * buf = calloc ( to - from , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> r_buf_read_at ( bf -> buf , from , buf , to - from ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( to - needle ) > 5 ) { <S2SV_EndBug> <S2SV_StartBug> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <S2SV_EndBug> ",<S2SV_ModStart> int len = to - from ; <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> + rc <S2SV_ModStart> ( <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) 
702,"
","
"
703,"<S2SV_StartBug> rd_create_ui ( ) ; <S2SV_EndBug> <S2SV_StartBug> in_uint16_le ( s , len_combined_caps ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , len_src_descriptor ) ) { rdp_protocol_error ( ""rdp_demand_active(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>source<S2SV_blank>descriptor<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
704,<S2SV_StartBug> block_length = data [ i ] * 256 + data [ i + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i + 1 < data_size ) 
705,"<S2SV_StartBug> switch ( type ) <S2SV_EndBug> <S2SV_StartBug> SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & <S2SV_EndBug> <S2SV_StartBug> ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; <S2SV_EndBug> <S2SV_StartBug> x -- ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ","<S2SV_ModStart> if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> <S2SV_ModStart> SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> <S2SV_ModStart> , exception <S2SV_ModEnd> <S2SV_ModStart> if ( x != image -> columns ) <S2SV_ModStart>  <S2SV_ModEnd> "
706,<S2SV_StartBug> if ( sock -> type == SOCK_RAW ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> sock -> ops = & rawsock_ops ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( ! capable ( CAP_NET_RAW ) ) return - EPERM ; <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
707,<S2SV_StartBug> set_caps ( ) ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ; <S2SV_ModEnd> 
708,<S2SV_StartBug> siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } "
709,<S2SV_StartBug> if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) <S2SV_EndBug> <S2SV_StartBug> else if ( temp_buffer < 0x120 ) <S2SV_EndBug> <S2SV_StartBug> else if ( temp_buffer < 0x130 ) <S2SV_EndBug> ,<S2SV_ModStart> temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> <S2SV_ModStart> >= 0x100 && temp_buffer <S2SV_ModStart> temp_buffer >= 0x120 && 
710,<S2SV_StartBug> if ( ! curbuf -> b_p_ma && ( ea . argt & MODIFY ) ) <S2SV_EndBug> ,"<S2SV_ModStart> restricted != 0 && ( ea . argt & RESTRICT ) ) { errormsg = _ ( ""E981:<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim"" ) ; goto doend ; } if ( "
711,"<S2SV_StartBug> chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> 
712,<S2SV_StartBug> unsigned int channo ; <S2SV_EndBug> ,<S2SV_ModStart> ; cdef -> ents = 0 
713,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ; 
714,"<S2SV_StartBug> guchar * match ; <S2SV_EndBug> <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug> ","<S2SV_ModStart> goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> <S2SV_ModStart> data , buffer -> <S2SV_ModStart> while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> <S2SV_ModStart> offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> "
715,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> strict = true ; 
716,<S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> ,"<S2SV_ModStart> memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> "
717,<S2SV_StartBug> size_t i ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
718,<S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <S2SV_EndBug> ,<S2SV_ModStart> { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> i_temp ; } <S2SV_ModEnd> 
719,<S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ,"<S2SV_ModStart> ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries "
720,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
721,"<S2SV_StartBug> # define PAM_END ( msg ) do { syslog ( LOG_ERR , ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; warnx ( ""%s:<S2SV_blank>%s"" , msg , pam_strerror ( pamh , pam_err ) ) ; pam_end ( pamh , pam_err ) ; exit ( EXIT_FAILURE ) ; } while ( 0 ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # ifndef HAVE_LOGIN_CAP_H <S2SV_EndBug> ","<S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> else # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresgid ( target_pw -> pw_gid , target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setresgid"" ) ; # else if ( setregid ( target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""setregid"" ) ; # endif if ( initgroups ( target_pw -> pw_name , target_pw -> pw_gid ) == - 1 ) err ( 1 , ""initgroups"" ) ; # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresuid ( target , target , target ) == - 1 ) err ( 1 , ""setresuid"" ) ; # else if ( setreuid ( target , target ) == - 1 ) err ( 1 , ""setreuid"" ) ; # endif # <S2SV_ModStart>  <S2SV_ModEnd> "
722,<S2SV_StartBug> be32_to_cpu ( agf -> agf_flcount ) <= xfs_agfl_size ( mp ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bp -> b_pag && be32_to_cpu ( agf -> agf_seqno ) != bp -> b_pag -> pag_agno ) <S2SV_EndBug> <S2SV_StartBug> be32_to_cpu ( agf -> agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) ) <S2SV_EndBug> ,<S2SV_ModStart> ) ) return __this_address ; if ( be32_to_cpu ( agf -> agf_length ) > mp -> m_sb . sb_dblocks ) return __this_address ; if ( be32_to_cpu ( agf -> agf_freeblks ) < be32_to_cpu ( agf -> agf_longest ) || be32_to_cpu ( agf -> agf_freeblks ) > be32_to_cpu ( agf -> agf_length <S2SV_ModStart> xfs_sb_version_hasrmapbt ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_rmap_blocks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ; if ( <S2SV_ModStart> be32_to_cpu ( agf -> agf_length ) ) return __this_address ; if ( xfs_sb_version_hasreflink ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_refcount_blocks ) > 
723,"<S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> <S2SV_StartBug> __skb_queue_tail ( queue , skb ) ; <S2SV_EndBug> ","<S2SV_ModStart> csum = 0 ; __skb_queue_tail ( queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> append : <S2SV_ModEnd> "
724,"<S2SV_StartBug> int byte_count = 0 , count ; <S2SV_EndBug> <S2SV_StartBug> { switch ( c ) <S2SV_EndBug> <S2SV_StartBug> ucptr = ( unsigned char * ) intptr ; <S2SV_EndBug> <S2SV_StartBug> intptr = va_arg ( argptr , unsigned int * ) ; <S2SV_EndBug> <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> <S2SV_StartBug> case 'G' : <S2SV_EndBug> <S2SV_StartBug> if ( count > 0 ) <S2SV_EndBug> <S2SV_StartBug> header_seek ( psf , count , SEEK_SET ) ; <S2SV_EndBug> <S2SV_StartBug> byte_count += count ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> * intptr = 0 ; <S2SV_ModStart> ; * intptr = 0 <S2SV_ModStart> memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets <S2SV_ModEnd> <S2SV_ModStart> 'z' : psf_log_printf ( psf , ""Format<S2SV_blank>conversion<S2SV_blank>\'z\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\n"" ) ; break ; case 'p' : <S2SV_ModEnd> <S2SV_ModStart> header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j' <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
725,<S2SV_StartBug> if ( ! ( info = bmp_getinfo ( in ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n"" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> JAS_DBGLOG ( 1 , ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>"" ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ; "
726,"<S2SV_StartBug> } else if ( ACTION ( RUN ) ) { <S2SV_EndBug> <S2SV_StartBug> handle_run ( req , res ) ; <S2SV_EndBug> <S2SV_StartBug> is_monit_running ( res ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ACTION ( STATUS ) ) { <S2SV_EndBug> ",<S2SV_ModStart> RUNTIME <S2SV_ModEnd> <S2SV_ModStart> handle_runtime <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { handle_service <S2SV_ModEnd> 
727,"<S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> <S2SV_StartBug> new_size ) ; <S2SV_EndBug> ","<S2SV_ModStart> btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> "
728,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ; 
729,"<S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> pr_fs_clear_cache ( ) ; <S2SV_EndBug> <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> <S2SV_ModStart> if ( errno == EPERM ) { <S2SV_ModEnd> <S2SV_ModStart> ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ; } <S2SV_ModEnd> "
730,<S2SV_StartBug> if ( length == 1 && bp [ 0 ] == 0xff ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> ND_TCHECK ( bp [ 3 ] ) ; 
731,"<S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , sad_array8 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> bestaddress , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ","<S2SV_ModStart> DECLARE_ALIGNED <S2SV_ModEnd> <S2SV_ModStart> int , sad_array8 [ 8 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
732,<S2SV_StartBug> hlist_del ( & pin -> m_list ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_del ( & pin -> s_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> hlist_del_init <S2SV_ModEnd> <S2SV_ModStart> hlist_del_init <S2SV_ModEnd> 
733,"<S2SV_StartBug> static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf ) <S2SV_EndBug> <S2SV_StartBug> if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> uid_t tuid , <S2SV_ModStart> ! may_move_pid ( tpid , tuid , <S2SV_ModEnd> <S2SV_ModStart> ) { fail = true ; break ; } if ( fprintf ( pids_file , ""%d"" , ( int ) cred . pid ) "
734,"<S2SV_StartBug> u_char * b , * s , * t , c ; <S2SV_EndBug> <S2SV_StartBug> b = ( uint8_t * ) malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) { <S2SV_EndBug> <S2SV_StartBug> if ( i > 1 ) { <S2SV_EndBug> <S2SV_StartBug> c = * s ++ ^ 0x20 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; const u_char * s <S2SV_ModStart> u_char <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && ND_TTEST ( * s ) <S2SV_ModStart> <= 1 || ! ND_TTEST ( * s ) ) break ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
735,<S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> "
736,<S2SV_StartBug> BUG_ON ( ret == - EEXIST ) ; <S2SV_EndBug> ,<S2SV_ModStart> || ret == - EOVERFLOW 
737,"<S2SV_StartBug> int opts ; <S2SV_EndBug> <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> ","<S2SV_ModStart> result ; int <S2SV_ModStart> result = <S2SV_ModEnd> <S2SV_ModStart> ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0 "
738,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> check_stack_depth ( ) ; 
739,"<S2SV_StartBug> int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
740,"<S2SV_StartBug> if ( ! ctx -> priv ) { <S2SV_EndBug> <S2SV_StartBug> vpx_codec_alg_priv_t * alg_priv = vpx_memalign ( 32 , sizeof ( * alg_priv ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( alg_priv == NULL ) <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_MEM_ERROR ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv = ( vpx_codec_priv_t * ) alg_priv ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> config . dec ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> ",<S2SV_ModStart> ( void ) data ; <S2SV_ModStart> const priv = vpx_calloc ( 1 <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv -> si . sz = sizeof ( priv -> si ) ; priv -> flushed = 0 ; priv -> frame_parallel_decode = ( ctx -> config . dec && ( ctx -> config . dec -> threads > 1 ) && ( ctx -> init_flags & VPX_CODEC_USE_FRAME_THREADING ) ) ? 1 : 0 ; <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> 
741,<S2SV_StartBug> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> <S2SV_StartBug> if ( args -> valuelen < valuelen ) { <S2SV_EndBug> <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> ,<S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> args -> rmtvaluelen <S2SV_ModEnd> 
742,"<S2SV_StartBug> char * sockaddr_url , * stratum_port , * tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_disable_client_reconnect ) { <S2SV_EndBug> <S2SV_StartBug> url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , ""Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting."" ) ; return false ; } <S2SV_ModEnd> <S2SV_ModStart> char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> snprintf ( address , sizeof ( address ) <S2SV_ModEnd> "
743,"<S2SV_StartBug> input ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""Cannot<S2SV_blank>mount<S2SV_blank>%s\\n"" , input ) ; <S2SV_EndBug> ",<S2SV_ModStart> { input ++ ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
744,<S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
745,<S2SV_StartBug> if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE && <S2SV_EndBug> <S2SV_StartBug> sbi -> s_inode_size ) { <S2SV_EndBug> ,<S2SV_ModStart> unsigned def_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; <S2SV_ModStart> == EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = 0 ; return ; } if ( sbi -> s_want_extra_isize < 4 ) { sbi -> s_want_extra_isize = def_extra_isize ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( ( sbi -> s_want_extra_isize > sbi -> s_inode_size ) || <S2SV_ModEnd> <S2SV_ModStart> ) { sbi -> s_want_extra_isize = def_extra_isize <S2SV_ModEnd> 
746,"<S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug> ",<S2SV_ModStart> mii_ioctl_data <S2SV_ModEnd> <S2SV_ModStart> if_mii ( rq ) <S2SV_ModEnd> <S2SV_ModStart> SIOCGMIIPHY : miidata -> phy_id = phy_addr ; <S2SV_ModEnd> <S2SV_ModStart> SIOCGMIIREG <S2SV_ModEnd> <S2SV_ModStart> val_out <S2SV_ModEnd> <S2SV_ModStart> SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> <S2SV_ModStart> val_in <S2SV_ModEnd> 
747,"<S2SV_StartBug> int hns_nic_net_xmit_hw ( struct net_device * ndev , <S2SV_EndBug> <S2SV_StartBug> wmb ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_tx_t <S2SV_ModEnd> <S2SV_ModStart> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; 
748,<S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> 
749,"<S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( query , ""select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`"" , table ) ; <S2SV_EndBug> <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> end = strmov ( strmov ( strmov ( query , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`"" ) , table ) , ""`"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> NAME_LEN + 100 ] ; int len <S2SV_ModEnd> <S2SV_ModStart> my_snprintf ( query , sizeof ( query ) <S2SV_ModEnd> <S2SV_ModStart> len = sizeof ( query ) ; len -= my_snprintf ( query , len , ""show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`%s`"" , table <S2SV_ModEnd> <S2SV_ModStart> && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> <S2SV_ModStart> my_snprintf ( query , sizeof ( query ) , ""show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`%s`"" , table <S2SV_ModEnd> "
750,"<S2SV_StartBug> VP8Frame * av_uninit ( curframe ) , * prev_frame ; <S2SV_EndBug> ",<S2SV_ModStart> ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P ) 
751,<S2SV_StartBug> ssize_t result ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES 
752,<S2SV_StartBug> img_buf_free ( img -> img_data ) ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_free <S2SV_ModEnd> 
753,"<S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t ) ( <S2SV_ModStart> 1U <S2SV_ModEnd> 
754,"<S2SV_StartBug> struct stat st ; <S2SV_EndBug> <S2SV_StartBug> pr_fs_clear_cache2 ( path ) ; <S2SV_EndBug> <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , ""error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s"" , path , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> <S2SV_ModStart> if ( errno == EPERM ) { <S2SV_ModEnd> <S2SV_ModStart> ""error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>"" ""(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)"" , path ) ; } <S2SV_ModEnd> "
755,"<S2SV_StartBug> af -> from_addr_param ( & addr , addr_param , <S2SV_EndBug> ",<S2SV_ModStart> if ( af == NULL ) break ; 
756,"<S2SV_StartBug> imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx * imsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf , background_color_index , imsx * imsy ) ; <S2SV_EndBug> <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> <S2SV_StartBug> dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( dmbuf , background_color_index , dmsx * dmsy ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) ResetMagickMemory ( imbuf + imsx * y + posision_x , color_index , repeat_count ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dmbuf = ( unsigned char * ) AcquireQuantumMemory ( dmsx * dmsy , 1 ) ) == NULL ) { <S2SV_EndBug> ","<S2SV_ModStart> , imsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> <S2SV_ModStart> ( size_t ) <S2SV_ModStart> ( size_t ) <S2SV_ModStart> , dmsy <S2SV_ModEnd> "
757,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS ( cp ) ; 
758,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" "
759,"<S2SV_StartBug> u64 base_addr , size ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( get_securelevel ( ) > 0 ) return - EPERM 
760,<S2SV_StartBug> if ( client -> rcSource ) <S2SV_EndBug> ,<S2SV_ModStart> width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE ) return FALSE ; if ( 
761,<S2SV_StartBug> if ( bee -> ui -> ft_in_start ) { <S2SV_EndBug> ,<S2SV_ModStart> && bu 
762,<S2SV_StartBug> if ( vps_id >= 16 ) { <S2SV_EndBug> ,<S2SV_ModStart> ( vps_id < 0 ) || ( <S2SV_ModStart> ) 
763,<S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING 
764,"<S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ","<S2SV_ModStart> uid_keyring <S2SV_ModEnd> <S2SV_ModStart> uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> <S2SV_ModStart> } "
765,<S2SV_StartBug> while ( ! kthread_should_stop ( ) ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> kthread_freezable_should_stop ( NULL <S2SV_ModEnd> <S2SV_ModStart> if ( signal_pending ( current ) ) flush_signals ( current ) ; <S2SV_ModStart> svc_exit_thread ( rqstp ) ; module_put_and_exit ( 0 ) ; 
766,"<S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> <S2SV_StartBug> q = p ; <S2SV_EndBug> <S2SV_StartBug> goto skip ; <S2SV_EndBug> <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> int skip = 0 ; <S2SV_ModStart> ; skip = 0 <S2SV_ModStart> skip = 1 <S2SV_ModEnd> <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } 
767,"<S2SV_StartBug> if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) { <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & child -> sighand -> siglock ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ignore_state || ( task_is_traced ( child ) && <S2SV_EndBug> <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ret && ! ignore_state ) <S2SV_EndBug> <S2SV_StartBug> ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> WARN_ON ( child -> state == __TASK_TRACED <S2SV_ModEnd> <S2SV_ModStart> ptrace_freeze_traced ( child <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { if ( ! <S2SV_ModEnd> <S2SV_ModStart> __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = <S2SV_ModEnd> <S2SV_ModStart> } } 
768,"<S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( display_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) { <S2SV_EndBug> <S2SV_StartBug> const VP9_COMMON * const cm = & ctx -> pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModEnd> <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> <S2SV_ModStart> return VPX_CODEC_OK ; <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
769,<S2SV_StartBug> altcol = ( altcol / tok -> alttabsize + 1 ) <S2SV_EndBug> <S2SV_StartBug> * tok -> alttabsize ; <S2SV_EndBug> <S2SV_StartBug> if ( indenterror ( tok ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( indenterror ( tok ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( indenterror ( tok ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( tok -> async_def ) { <S2SV_EndBug> ,<S2SV_ModStart> ALTTABSIZE <S2SV_ModEnd> <S2SV_ModStart> * ALTTABSIZE <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> tok -> async_always || 
770,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char filename [ dirent . namelen + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( hook ( filename , type , fdiro , closure ) ) <S2SV_EndBug> ",<S2SV_ModStart> char * filename = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( ! filename ) { break ; } <S2SV_ModStart> { free ( filename ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; <S2SV_ModEnd> <S2SV_ModStart> { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> 
771,"<S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( line += 18 ; isspace ( * line ) ; line ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( ; line < last && isspace ( * line ) ; line ++ ) <S2SV_EndBug> <S2SV_StartBug> else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] ) <S2SV_EndBug> <S2SV_StartBug> && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) 
772,<S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug> ,"<S2SV_ModStart> copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> "
773,<S2SV_StartBug> if ( ! from_buffer ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
774,<S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> ,"<S2SV_ModStart> can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> <S2SV_ModStart> update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
775,"<S2SV_StartBug> pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_EndBug> <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug> ","<S2SV_ModStart> ; msg -> msg_namelen = 0 <S2SV_ModStart> memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; "
776,<S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart>  <S2SV_ModEnd> 
777,"<S2SV_StartBug> unsigned char * buf ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && bufsize 
778,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
779,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , MACROBLOCKD * const xd <S2SV_ModEnd> <S2SV_ModStart> set_mode_info_offsets <S2SV_ModEnd> <S2SV_ModStart> , x <S2SV_ModStart>  <S2SV_ModEnd> "
780,"<S2SV_StartBug> sprintf ( address , ""%s:%s"" , url , port ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( address , 254 <S2SV_ModEnd> "
781,"<S2SV_StartBug> memset ( global , 0 , sizeof ( * global ) ) ; <S2SV_EndBug> <S2SV_StartBug> global -> codec = get_vpx_encoder_by_index ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> global -> use_i420 = 0 ; <S2SV_EndBug> <S2SV_StartBug> else if ( arg_match ( & arg , & experimental_bitstream , argi ) ) <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_VP9_ENCODER <S2SV_EndBug> ","<S2SV_ModStart> const int num_encoder = get_vpx_encoder_count ( ) ; if ( num_encoder < 1 ) die ( ""Error:<S2SV_blank>no<S2SV_blank>valid<S2SV_blank>encoder<S2SV_blank>available\\n"" ) ; <S2SV_ModStart> num_encoder - 1 ) ; global -> passes = 0 ; global -> color_type = I420 <S2SV_ModEnd> <S2SV_ModStart> color_type = YV12 ; else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> color_type = I420 ; else if ( arg_match ( & arg , & use_i422 , argi ) ) global -> color_type = I422 ; else if ( arg_match ( & arg , & use_i444 , argi ) ) global -> color_type = I444 ; else if ( arg_match ( & arg , & use_i440 , argi ) ) global -> color_type = I440 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || CONFIG_VP10_ENCODER if ( global -> codec != NULL && global -> codec -> name != NULL ) "
782,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> m -> msg_namelen = 0 ; 
783,<S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> 
784,<S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels 
785,<S2SV_StartBug> hndl = sock_diag_lock_handler ( req -> sdiag_family ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ; 
786,"<S2SV_StartBug> static inline ulong encode_twos_comp ( long n , int prec ) <S2SV_EndBug> <S2SV_StartBug> ulong result ; <S2SV_EndBug> ",<S2SV_ModStart> jas_ulong <S2SV_ModEnd> <S2SV_ModStart> jas_ulong <S2SV_ModEnd> 
787,<S2SV_StartBug> mptctl_eventquery ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> struct mpt_ioctl_eventquery karg ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
788,<S2SV_StartBug> if ( source == target ) <S2SV_EndBug> ,"<S2SV_ModStart> vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> "
789,<S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; 
790,"<S2SV_StartBug> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <S2SV_EndBug> <S2SV_StartBug> if ( ! options ) { <S2SV_EndBug> <S2SV_StartBug> case ecryptfs_opt_err : <S2SV_EndBug> ","<S2SV_ModStart> , uid_t * check_ruid <S2SV_ModStart> * check_ruid = 0 ; <S2SV_ModStart> ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case "
791,"<S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( obuf ) "
792,"<S2SV_StartBug> int Downmix_Reset ( downmix_object_t * pDownmixer , bool init ) { <S2SV_EndBug> ",<S2SV_ModStart> __unused <S2SV_ModStart> __unused 
793,<S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> <S2SV_ModStart> if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ; 
794,<S2SV_StartBug> if ( retval ) { <S2SV_EndBug> ,<S2SV_ModStart> || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0' 
795,<S2SV_StartBug> block_length = data [ i ] * 256 + data [ i + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i + 1 < data_size ) 
796,<S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && in -> data [ plane ] && in -> linesize [ plane ] 
797,"<S2SV_StartBug> RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_EndBug> <S2SV_StartBug> VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS next_frame = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * start_pos ; <S2SV_EndBug> <S2SV_StartBug> double gf_first_frame_err = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> const int max_bits = frame_max_bits ( rc , oxcf ) ; <S2SV_EndBug> <S2SV_StartBug> mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 10.0 ; <S2SV_EndBug> <S2SV_StartBug> active_max_gf_interval = rc -> max_gf_interval ; <S2SV_EndBug> <S2SV_StartBug> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( EOF == input_stats ( twopass , & next_frame ) ) <S2SV_EndBug> <S2SV_StartBug> loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) < <S2SV_EndBug> <S2SV_StartBug> if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate , <S2SV_EndBug> <S2SV_StartBug> boost_score += ( decay_accumulator * <S2SV_EndBug> <S2SV_StartBug> calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) || <S2SV_EndBug> <S2SV_StartBug> ( i > MIN_GF_INTERVAL ) && <S2SV_EndBug> <S2SV_StartBug> ( ( boost_score - old_boost_score ) < IIFACTOR ) ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( rc -> frames_to_key - i ) < MIN_GF_INTERVAL ) { <S2SV_EndBug> <S2SV_StartBug> while ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( i < rc -> frames_to_key ) { <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = i - 1 ; <S2SV_EndBug> <S2SV_StartBug> rc -> baseline_gf_interval = i ; <S2SV_EndBug> <S2SV_StartBug> ( i < cpi -> oxcf . lag_in_frames ) && <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> multi_arf_enabled && ( cpi -> common . frame_type != KEY_FRAME ) ) { <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const start_pos = twopass -> stats_in <S2SV_ModEnd> <S2SV_ModStart> # if GROUP_ADAPTIVE_MAXQ double gf_group_raw_error = 0.0 ; # endif double gf_group_skip_pct = 0.0 ; double gf_group_inactive_zone_rows = 0.0 ; <S2SV_ModStart> unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; int active_max_gf_interval ; int active_min_gf_interval ; int64_t gf_group_bits ; double gf_group_error_left ; int gf_arf_bits ; const int is_key_frame = frame_is_intra_only ( cm ) ; const int arf_active_or_kf = is_key_frame || rc -> source_alt_ref_active ; if ( is_key_frame == 0 ) { vp9_zero ( twopass -> gf_group ) ; } vpx_clear_system_state ( ) ; vp9_zero ( next_frame ) ; mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( arf_active_or_kf ) { <S2SV_ModEnd> <S2SV_ModStart> # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error -= this_frame -> coded_error ; # endif gf_group_skip_pct -= this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows -= this_frame -> inactive_zone_rows ; } mv_ratio_accumulator_thresh = ( cpi -> initial_height + cpi -> initial_width ) / 4.0 ; { int int_max_q = ( int ) ( vp9_convert_qindex_to_q ( twopass -> active_worst_quality , <S2SV_ModEnd> <S2SV_ModStart> bit_depth ) ) ; int int_lbq = ( int ) ( vp9_convert_qindex_to_q ( rc -> last_boosted_qindex , <S2SV_ModEnd> <S2SV_ModStart> bit_depth ) ) ; active_min_gf_interval = rc -> min_gf_interval + MIN ( 2 , int_max_q / 200 ) ; if ( active_min_gf_interval > rc -> max_gf_interval ) active_min_gf_interval = rc -> max_gf_interval ; if ( cpi -> multi_arf_allowed ) { active_max_gf_interval = rc -> max_gf_interval ; } else { active_max_gf_interval = 12 + MIN ( 4 , ( int_lbq / 6 ) ) ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval <S2SV_ModEnd> <S2SV_ModStart> if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval ; } } <S2SV_ModStart> twopass , oxcf , <S2SV_ModStart> # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , GF_MAX_BOOST <S2SV_ModEnd> <S2SV_ModStart> ( active_max_gf_interval + arf_active_or_kf ) && <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> >= active_min_gf_interval + arf_active_or_kf <S2SV_ModEnd> <S2SV_ModStart> BOOST_BREAKOUT <S2SV_ModEnd> <S2SV_ModStart> rc -> constrained_gf_group = ( i >= <S2SV_ModEnd> <S2SV_ModStart> ) ? 1 : 0 ; if ( allow_alt_ref && <S2SV_ModEnd> <S2SV_ModStart> cpi -> oxcf . lag_in_frames ) && ( i >= rc -> min_gf_interval ) ) { rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; rc -> source_alt_ref_pending = 1 ; cpi -> multi_arf_enabled = ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ; } else { rc -> gfu_boost = MAX ( ( int ) boost_score , MIN_ARF_GF_BOOST ) ; rc -> source_alt_ref_pending = 0 ; } rc -> baseline_gf_interval = i - ( is_key_frame || rc -> source_alt_ref_pending ) ; if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_gf_interval - rc -> baseline_gf_interval ; ++ j ) { <S2SV_ModEnd> <S2SV_ModStart> gf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; } <S2SV_ModEnd> <S2SV_ModStart> new_gf_interval ; } rc -> frames_till_gf_update_due = <S2SV_ModEnd> <S2SV_ModStart> ; reset_fpf_position ( twopass , start_pos ) ; gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ; # if GROUP_ADAPTIVE_MAXQ if ( ( <S2SV_ModEnd> <S2SV_ModStart> rc_mode != VPX_Q ) && ( rc -> baseline_gf_interval > 1 ) ) { const int vbr_group_bits_per_frame = ( int ) ( gf_group_bits / rc -> baseline_gf_interval ) ; const double group_av_err = gf_group_raw_error / rc -> baseline_gf_interval ; const double group_av_skip_pct = gf_group_skip_pct / rc -> baseline_gf_interval ; const double group_av_inactive_zone = ( ( gf_group_inactive_zone_rows * 2 ) / ( rc -> baseline_gf_interval * ( double ) cm -> mb_rows ) ) ; int tmp_q ; double rc_factor = 1.0 ; if ( rc -> rate_error_estimate > 0 ) { rc_factor = MAX ( RC_FACTOR_MIN , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } else { rc_factor = MIN ( RC_FACTOR_MAX , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } tmp_q = get_twopass_worst_quality ( cpi , group_av_err , ( group_av_skip_pct + group_av_inactive_zone ) , vbr_group_bits_per_frame , twopass -> kfgroup_inter_fraction * rc_factor ) ; twopass -> active_worst_quality = MAX ( tmp_q , twopass -> active_worst_quality >> 1 <S2SV_ModEnd> <S2SV_ModStart> gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , rc -> gfu_boost , gf_group_bits ) ; twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; if ( rc -> source_alt_ref_pending ) { gf_group_error_left = gf_group_err - mod_frame_err ; } else if ( is_key_frame == 0 ) { gf_group_error_left = gf_group_err - gf_first_frame_err ; } else { gf_group_error_left = gf_group_err ; } allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ; reset_fpf_position ( twopass , start_pos ) ; if <S2SV_ModEnd> <S2SV_ModStart> { twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ; } if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED <S2SV_ModEnd> "
798,<S2SV_StartBug> goto err_reprs_clean ; <S2SV_EndBug> <S2SV_StartBug> nfp_repr_free ( repr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( err ) { <S2SV_EndBug> ,<S2SV_ModStart> nfp_repr_free ( repr ) ; <S2SV_ModStart> kfree ( repr_priv ) ; <S2SV_ModStart> kfree ( repr_priv ) ; 
799,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
800,<S2SV_StartBug> if ( sp -> sa_protocol != PX_PROTO_PPTP ) <S2SV_EndBug> ,<S2SV_ModStart> sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if ( 
801,"<S2SV_StartBug> RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( work_to_do < 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( ret < 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> <S2SV_StartBug> netbk_tx_err ( vif , & txreq , idx ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , ""Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>"" ""req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n"" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> continue ; <S2SV_ModEnd> <S2SV_ModStart> continue ; <S2SV_ModEnd> <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> netbk_fatal_tx_err ( vif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
802,"<S2SV_StartBug> ret = vfs_dedupe_file_range ( file , same ) ; <S2SV_EndBug> ",<S2SV_ModStart> same -> dest_count = count ; 
803,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; } "
804,"<S2SV_StartBug> char * to , * repl ; <S2SV_EndBug> <S2SV_StartBug> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { <S2SV_EndBug> <S2SV_StartBug> to = g . hname ; <S2SV_EndBug> <S2SV_StartBug> len = strlen ( g . hname ) ; <S2SV_EndBug> <S2SV_StartBug> repl = g . decode && strcmp ( to + len , "".tgz"" ) ? """" : "".tar"" ; <S2SV_EndBug> <S2SV_StartBug> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( g . outf , to , len ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; <S2SV_EndBug> ","<S2SV_ModStart> = g . inf , * sufx = """" ; size_t pre = 0 <S2SV_ModEnd> <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> to ) ; } else if ( <S2SV_ModEnd> <S2SV_ModStart> == 0 ) sufx = "".tar"" ; } else sufx = g . sufx ; <S2SV_ModEnd> <S2SV_ModStart> pre + len + strlen ( sufx ) <S2SV_ModEnd> <S2SV_ModStart> g . inf , pre ) ; memcpy <S2SV_ModEnd> <S2SV_ModStart> pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> "
805,"<S2SV_StartBug> if ( mi < 0 ) <S2SV_EndBug> <S2SV_StartBug> idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT , <S2SV_EndBug> ",<S2SV_ModStart> struct uio_mem * mem ; <S2SV_ModStart> ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> mem -> <S2SV_ModEnd> 
806,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( UINT32_MAX - src -> width < ( x > 0 ? x : - x ) ) || ( UINT32_MAX - src -> height < ( y > 0 ? y : - y ) ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , ""overflow<S2SV_blank>in<S2SV_blank>compose_image"" ) ; # endif return 0 ; } "
807,"<S2SV_StartBug> mptctl_do_mpt_command ( struct mpt_ioctl_command karg , void __user * mfPtr ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> int iocnum , flagsLength ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
808,"<S2SV_StartBug> strcpy ( algo -> alg_name , auth -> alg_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( algo -> alg_name ) "
809,<S2SV_StartBug> u8 * output ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! ctx -> opid ) return GF_NON_COMPLIANT_BITSTREAM 
810,<S2SV_StartBug> if ( type == HUB_INIT2 ) <S2SV_EndBug> <S2SV_StartBug> if ( type == HUB_INIT3 ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> <S2SV_ModStart> device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; "
811,<S2SV_StartBug> param ++ ; <S2SV_EndBug> <S2SV_StartBug> while ( * param == '<S2SV_blank>' ) <S2SV_EndBug> <S2SV_StartBug> param ++ ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
812,<S2SV_StartBug> if ( code == gcode ) <S2SV_EndBug> ,<S2SV_ModStart> && wordlist [ key ] . index >= 0 
813,"<S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> <S2SV_StartBug> char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; <S2SV_EndBug> <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , * buf2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; <S2SV_ModEnd> <S2SV_ModStart> buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> <S2SV_ModStart> efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> "
814,"<S2SV_StartBug> GetPixelIndex ( image , q ) , q ) ; <S2SV_EndBug> ","<S2SV_ModStart> ConstrainColormapIndex ( image , <S2SV_ModStart> ) , exception "
815,<S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug> ,"<S2SV_ModStart> ! client -> auth_user ) { disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ; return false ; } if ( "
816,"<S2SV_StartBug> BUFPUTSL ( ob , ""<q>"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct html_renderopt * options = opaque ; <S2SV_ModStart> if ( options -> flags & HTML_ESCAPE ) escape_html ( ob , text -> data , text -> size ) ; else "
817,"<S2SV_StartBug> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
818,"<S2SV_StartBug> void validate_positive_rational ( const char * msg , <S2SV_EndBug> ",<S2SV_ModStart> static 
819,<S2SV_StartBug> continue ; <S2SV_EndBug> ,<S2SV_ModStart> buflen ++ ; 
820,"<S2SV_StartBug> fprintf ( out , ""[URL:<S2SV_blank>%s[StatusCode:<S2SV_blank>%u]"" , <S2SV_EndBug> <S2SV_StartBug> fprintf ( out , ""[ContentType:<S2SV_blank>%s]"" , flow -> http . content_type ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( out , ""[UserAgent:<S2SV_blank>%s]"" , flow -> http . user_agent ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""[URL:<S2SV_blank>%s][StatusCode:<S2SV_blank>%u]"" <S2SV_ModEnd> <S2SV_ModStart> ""[Content-Type:<S2SV_blank>%s]"" <S2SV_ModEnd> <S2SV_ModStart> ""[User-Agent:<S2SV_blank>%s]"" <S2SV_ModEnd> "
821,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , & data , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
822,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && in -> linesize [ plane ] 
823,<S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> ,<S2SV_ModStart> struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModEnd> <S2SV_ModStart> rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; } 
824,"<S2SV_StartBug> static void mark_object ( struct object * obj , struct strbuf * path , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
825,"<S2SV_StartBug> guchar * match ; <S2SV_EndBug> <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug> ","<S2SV_ModStart> goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> <S2SV_ModStart> data , buffer -> <S2SV_ModStart> while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> <S2SV_ModStart> offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> "
826,"<S2SV_StartBug> z . kind = 0 ; <S2SV_EndBug> <S2SV_StartBug> # define PARSE_STRING s = parse_field ( ndo , & parse , & parselen ) ; if ( ! s ) lose = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( lose ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int truncated = 0 ; <S2SV_ModStart> , & truncated ) ; if ( truncated ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|zephyr]<S2SV_blank>(%d)"" , length ) ) ; return ; "
827,<S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> ,<S2SV_ModStart> mp -> timer_armed && 
828,"<S2SV_StartBug> if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ; "
829,"<S2SV_StartBug> st = decrease_reservation ( nr_pages , GFP_USER ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ; 
830,<S2SV_StartBug> p += 2 ; <S2SV_EndBug> <S2SV_StartBug> p += 3 ; <S2SV_EndBug> <S2SV_StartBug> p += 4 ; <S2SV_EndBug> <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 2 ) return - 1 ; <S2SV_ModStart> if ( len < 3 ) return - 1 ; <S2SV_ModStart> if ( len < 4 ) return - 1 ; <S2SV_ModStart> if ( len < 2 ) return - 1 ; 
831,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> skb_free_datagram ( sk , skb ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
832,"<S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
833,<S2SV_StartBug> for ( i = 1 ; i <= SYSTEM_ID_LEN ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> sysid_len <S2SV_ModEnd> 
834,<S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; 
835,"<S2SV_StartBug> DBG_ENTER ( ""php_mysqlnd_rowp_read_text_protocol_aux"" ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned long len = php_mysqlnd_net_field_length ( & p ) ; <S2SV_EndBug> ","<S2SV_ModStart> const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> const <S2SV_ModStart> if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , ""Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>"" MYSQLND_SZ_T_SPEC ""<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet"" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; } "
836,<S2SV_StartBug> u8 odata [ 16 ] ; <S2SV_EndBug> ,<S2SV_ModStart> * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> 
837,"<S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug> ","<S2SV_ModStart> * <S2SV_ModStart> if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> * "
838,<S2SV_StartBug> if ( name_len == 0 ) goto chunk_end ; <S2SV_EndBug> <S2SV_StartBug> READ_ENCINT ( length ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue 
839,"<S2SV_StartBug> xim -> bytes_per_line * xim -> height , IPC_CREAT | 0777 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 0600 <S2SV_ModEnd> 
840,<S2SV_StartBug> if ( event -> attr . inherit || ! is_sampling_event ( event ) ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock <S2SV_ModEnd> <S2SV_ModStart> ret = _perf_event_refresh ( event , refresh ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret <S2SV_ModEnd> "
841,"<S2SV_StartBug> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> - EINVAL <S2SV_ModEnd> 
842,<S2SV_StartBug> section -> frame = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> section -> sr_coded_error = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> section -> pcnt_neutral = 0.0 ; <S2SV_EndBug> ,<S2SV_ModStart> = 0.0 ; section -> weight <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = 0.0 ; section -> intra_skip_pct = 0.0 ; section -> inactive_zone_rows = 0.0 ; section -> inactive_zone_cols 
843,<S2SV_StartBug> bool off_is_neg = off_reg -> smin_value < 0 ; <S2SV_EndBug> <S2SV_StartBug> alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; <S2SV_EndBug> ,<S2SV_ModStart> off_is_imm = tnum_is_const ( off_reg -> var_off ) ; bool <S2SV_ModStart> : 0 ; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE 
844,"<S2SV_StartBug> while ( * end_ptr != \'\\""\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> 
845,<S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug> ,<S2SV_ModStart> urb -> actual_length > 0 && 
846,"<S2SV_StartBug> Rd_WP_DWORD ( image , & Rec . RecordLength ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" "
847,"<S2SV_StartBug> return reply_msg ( c , MSG_JOB_TOO_BIG ) ; <S2SV_EndBug> ","<S2SV_ModStart> skip ( c , body_size + 2 <S2SV_ModEnd> "
848,<S2SV_StartBug> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> char t <S2SV_ModEnd> <S2SV_ModStart> ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>' 
849,<S2SV_StartBug> if ( buf -> pts == AV_NOPTS_VALUE ) { <S2SV_EndBug> ,<S2SV_ModStart> || av_fifo_size ( s -> fifo ) <= 0 
850,"<S2SV_StartBug> if ( fscanf ( f , ""PG%[<S2SV_blank>\\t]%c%c%[<S2SV_blank>\\t+-]%d%[<S2SV_blank>\\t]%d%[<S2SV_blank>\\t]%d"" , temp , & endian1 , <S2SV_EndBug> ","<S2SV_ModStart> ""PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d"" <S2SV_ModEnd> "
851,<S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
852,"<S2SV_StartBug> if ( value [ strlen ( value ) - 1 ] == ',' ) { <S2SV_EndBug> ",<S2SV_ModStart> * value == 0 || 
853,"<S2SV_StartBug> if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
854,"<S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> ","<S2SV_ModStart> alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE "
855,"<S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ; "
856,"<S2SV_StartBug> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> if ( bufLen < 2 ) break ; <S2SV_ModStart> bufLen -= 2 ; 
857,"<S2SV_StartBug> ptr = realloc ( priv -> EF_C_DevAut , len ) ; <S2SV_EndBug> <S2SV_StartBug> priv -> EF_C_DevAut_len = len ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len > 0 ) { <S2SV_ModStart> } 
858,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return 
859,<S2SV_StartBug> struct twopass_rc * const twopass = & cpi -> twopass ; <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS this_frame_copy ; <S2SV_EndBug> <S2SV_StartBug> double this_frame_intra_error ; <S2SV_EndBug> <S2SV_StartBug> int is_spatial_svc = ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) ; <S2SV_EndBug> <S2SV_StartBug> lc = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] ; <S2SV_EndBug> <S2SV_StartBug> cm -> current_video_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> frames_till_gf_update_due == 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> ; GF_GROUP * const gf_group = & twopass -> gf_group <S2SV_ModStart> int target_rate ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : 0 ; if ( lc != NULL ) { frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ; } else { frames_left = ( int ) ( twopass -> total_stats . count - cm -> current_video_frame ) ; } if ( ! twopass -> stats_in ) return ; if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) { int target_rate ; configure_buffer_updates ( cpi ) ; target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; cm -> frame_type = INTER_FRAME ; if ( lc != NULL ) { if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } } if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } return ; } vpx_clear_system_state ( ) ; if ( cpi -> oxcf . rc_mode == VPX_Q ) { twopass -> active_worst_quality = cpi -> oxcf . cq_level ; } else if ( cm -> current_video_frame == 0 || ( lc != NULL && lc -> current_video_frame_in_layer == 0 ) ) { const int section_target_bandwidth = ( int ) ( twopass -> bits_left / frames_left ) ; const double section_length = twopass -> total_left_stats . count ; const double section_error = twopass -> total_left_stats . coded_error / section_length ; const double section_intra_skip = twopass -> total_left_stats . intra_skip_pct / section_length ; const double section_inactive_zone = ( twopass -> total_left_stats . inactive_zone_rows * 2 ) / ( ( double ) cm -> mb_rows * section_length ) ; const int tmp_q = get_twopass_worst_quality ( cpi , section_error , section_intra_skip + section_inactive_zone , section_target_bandwidth , DEFAULT_GRP_WEIGHT ) ; twopass -> active_worst_quality = tmp_q ; twopass -> baseline_active_worst_quality = tmp_q ; rc -> ni_av_qi = tmp_q ; rc -> last_q [ INTER_FRAME ] = tmp_q ; rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q , cm -> bit_depth ) ; rc -> avg_frame_qindex [ INTER_FRAME ] = tmp_q ; rc -> last_q [ KEY_FRAME ] = ( tmp_q + cpi -> oxcf . best_allowed_q ) / 2 ; rc -> avg_frame_qindex [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; } vp9_zero ( this_frame ) ; if ( EOF == input_stats ( twopass , & this_frame ) ) return ; if ( this_frame . intra_skip_pct >= FC_ANIMATION_THRESH ) twopass -> fr_content_type = FC_GRAPHICS_ANIMATION ; else twopass -> fr_content_type = FC_NORMAL ; if ( rc -> frames_to_key == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) ) { <S2SV_ModStart> this_frame_copy = this_frame ; find_next_key_frame ( cpi , & this_frame ) ; this_frame = this_frame_copy ; } else { cm -> frame_type = INTER_FRAME ; } if ( lc != NULL ) { if ( <S2SV_ModEnd> <S2SV_ModStart> spatial_layer_id == 0 ) { lc -> is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; lc -> frames_from_key_frame = 0 ; cpi -> svc . encode_intra_empty_frame = 1 ; } } else { cm -> frame_type = INTER_FRAME ; lc -> is_key_frame = <S2SV_ModEnd> <S2SV_ModStart> 0 ] . is_key_frame ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; lc -> frames_from_key_frame = 0 ; } } } if ( rc -> frames_till_gf_update_due == 0 ) { define_gf_group ( cpi , & this_frame ) ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( lc != NULL ) cpi -> refresh_golden_frame = 1 ; # if ARF_STATS_OUTPUT { FILE * fpfile ; fpfile = fopen ( ""arf.stt"" , ""a"" ) ; ++ arf_count ; fprintf ( fpfile , ""%10d<S2SV_blank>%10ld<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10ld\\n"" , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , rc -> kf_boost , arf_count , rc -> gfu_boost ) ; fclose ( fpfile ) ; } # endif } configure_buffer_updates ( cpi ) ; if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; if ( cpi -> common . frame_type == KEY_FRAME ) target_rate = vp9_rc_clamp_iframe_target_size ( cpi , target_rate ) ; else target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; { const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; twopass -> mb_av_energy = log ( ( ( this_frame . intra_error * 256.0 ) / num_mbs ) + 1.0 ) ; } <S2SV_ModEnd> "
860,<S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> ,<S2SV_ModStart> g_malloc0 <S2SV_ModEnd> 
861,"<S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> if ( k < 0 ) continue <S2SV_ModEnd> 
862,"<S2SV_StartBug> if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <S2SV_EndBug> <S2SV_StartBug> switch ( ctxt -> mode ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> cs_sel = ( u16 ) msr_data ; <S2SV_EndBug> <S2SV_StartBug> ss_sel &= ~ SELECTOR_RPL_MASK ; <S2SV_EndBug> <S2SV_StartBug> if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) { <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = msr_data ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ; <S2SV_EndBug> ",<S2SV_ModStart> != X86EMUL_MODE_PROT64 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( efer & EFER_LMA ) ? msr_data : ( u32 ) <S2SV_ModStart> ( efer & EFER_LMA ) ? msr_data : ( u32 ) 
863,<S2SV_StartBug> if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) { <S2SV_EndBug> <S2SV_StartBug> name = p ; p += name_len ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> if ( name_len == 0 ) goto chunk_end ; 
864,<S2SV_StartBug> return error ; <S2SV_EndBug> ,<S2SV_ModStart> < 0 ? error : 0 
865,"<S2SV_StartBug> l2tp_bearer_cap_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
866,<S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> ,<S2SV_ModStart> = - nr <S2SV_ModStart> else { delta_munlocked ++ ; } <S2SV_ModStart>  <S2SV_ModEnd> 
867,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> "
868,<S2SV_StartBug> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
869,<S2SV_StartBug> update_db_bp_intercept ( & svm -> vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
870,"<S2SV_StartBug> if ( srp -> bio ) <S2SV_EndBug> <S2SV_StartBug> blk_end_request_all ( srp -> rq , - EIO ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ; <S2SV_ModStart> srp -> rq = NULL ; } 
871,"<S2SV_StartBug> fprintf ( stderr , ""Error:<S2SV_blank>invalid<S2SV_blank>.asoundrc<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * rp = realpath ( src , NULL ) ; if ( ! rp ) { <S2SV_ModStart> ""Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\n"" , src <S2SV_ModEnd> <S2SV_ModStart> if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { <S2SV_ModEnd> <S2SV_ModStart> ""Error:<S2SV_blank>.asoundrc<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file<S2SV_blank>outside<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; exit ( 1 ) ; } free ( rp ) ; } copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
872,"<S2SV_StartBug> if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { <S2SV_EndBug> ",<S2SV_ModStart> zend_hash_find <S2SV_ModEnd> 
873,"<S2SV_StartBug> rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; 
874,<S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
875,<S2SV_StartBug> mask -> matte = MagickFalse ; <S2SV_EndBug> <S2SV_StartBug> channel_image = mask ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> } 
876,"<S2SV_StartBug> addresses = state -> endpoints ; <S2SV_EndBug> <S2SV_StartBug> while ( ( address = stok ( addresses , ""<S2SV_blank>\\t,"" , & tok ) ) != 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> for ( addresses = sclone ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> ; addresses = tok ) { <S2SV_ModEnd> 
877,<S2SV_StartBug> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> 
878,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
879,<S2SV_StartBug> align_get_bits ( gb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 
880,"<S2SV_StartBug> list_for_each_entry_safe ( chain , nc , & ctx -> table -> chains , list ) { <S2SV_EndBug> <S2SV_StartBug> err = nft_delchain ( ctx ) ; <S2SV_EndBug> <S2SV_StartBug> list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { <S2SV_EndBug> <S2SV_StartBug> if ( set -> flags & NFT_SET_ANONYMOUS && <S2SV_EndBug> ","<S2SV_ModStart> list_for_each_entry ( chain <S2SV_ModEnd> <S2SV_ModStart> } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set <S2SV_ModEnd> <S2SV_ModStart> chain , nc <S2SV_ModEnd> <S2SV_ModStart> chains <S2SV_ModEnd> <S2SV_ModStart> ctx -> chain = chain ; err = nft_delchain ( ctx <S2SV_ModEnd> "
881,<S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , false "
882,<S2SV_StartBug> free_uid ( group -> inotify_data . user ) ; <S2SV_EndBug> ,<S2SV_ModStart> atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ; 
883,<S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> break <S2SV_ModEnd> 
884,"<S2SV_StartBug> length ; <S2SV_EndBug> <S2SV_StartBug> sun_pixels = sun_data ; <S2SV_EndBug> <S2SV_StartBug> ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> height , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart>  <S2SV_ModEnd> "
885,"<S2SV_StartBug> ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
886,<S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int <S2SV_ModEnd> <S2SV_ModStart> unsigned int len ; <S2SV_ModStart> len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> 
887,"<S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug> ","<S2SV_ModStart> int profile , level ; <S2SV_ModStart> , & profile , & level ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , ""Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n"" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; "
888,"<S2SV_StartBug> char err_msg [ 64 ] ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( err_msg , <S2SV_EndBug> <S2SV_StartBug> param_num , neatsvpv ( value , 0 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> * err_msg <S2SV_ModEnd> <S2SV_ModStart> err_msg = SvPVX ( sv_2mortal ( newSVpvf ( <S2SV_ModEnd> <S2SV_ModStart> ) ) 
889,<S2SV_StartBug> if ( frame_end - frame < width + 3 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
890,<S2SV_StartBug> int check_fragments_for_errors ( VP8D_COMP * pbi ) <S2SV_EndBug> ,<S2SV_ModStart> static 
891,"<S2SV_StartBug> for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( mask & 1 ) { <S2SV_EndBug> <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , & cm -> ref_frame_map [ ref_index ] , <S2SV_EndBug> <S2SV_StartBug> cm -> new_fb_idx ) ; <S2SV_EndBug> <S2SV_StartBug> if ( old_idx >= 0 && cm -> frame_bufs [ old_idx ] . ref_count == 0 ) <S2SV_EndBug> <S2SV_StartBug> cm -> frame_refs [ ref_index ] . idx = INT_MAX ; <S2SV_EndBug> ","<S2SV_ModStart> BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; lock_buffer_pool ( pool ) ; <S2SV_ModStart> const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( <S2SV_ModEnd> <S2SV_ModStart> && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) <S2SV_ModStart> decrease_ref_count ( old_idx , frame_bufs , pool ) ; cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 0 ; cm -> frame_to_show = get_frame_new_buffer ( cm ) ; if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) { lock_buffer_pool ( pool ) ; -- frame_bufs [ <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; unlock_buffer_pool ( pool ) ; } <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> "
892,<S2SV_StartBug> for ( s = 0 ; s < ns ; s ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> && row < imagelength 
893,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
894,"<S2SV_StartBug> mutt_error ( ""%s"" , s + 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart> 2 <S2SV_ModEnd> 
895,<S2SV_StartBug> switch ( quantum_info -> depth ) <S2SV_EndBug> ,<S2SV_ModStart> pixel = 0 ; 
896,"<S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer * w , <S2SV_ModEnd> <S2SV_ModStart> const TOKENEXTRA * const <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> td . <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart> const MODE_INFO * m = NULL ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
897,"<S2SV_StartBug> safe_print ( value , valsz , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> safe_print ( value , valsz , ""\\"""" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>\\\\\\""\'$`<>"" <S2SV_ModEnd> <S2SV_ModStart> ""\\""\\\\"" ) ; fputs ( ""\\"""" <S2SV_ModEnd> "
898,<S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( idx > 63 ) return AVERROR_INVALIDDATA ; 
899,"<S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> <S2SV_StartBug> dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> u32 * buf ; int i ; <S2SV_ModStart> buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
900,<S2SV_StartBug> const unsigned char * old_name ; <S2SV_EndBug> <S2SV_StartBug> if ( source == target ) <S2SV_EndBug> <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct name_snapshot old_name ; <S2SV_ModStart> take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , <S2SV_ModEnd> <S2SV_ModStart> , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> "
901,<S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
902,"<S2SV_StartBug> unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ; <S2SV_EndBug> ","<S2SV_ModStart> init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ; "
903,<S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> <S2SV_StartBug> return change ; <S2SV_EndBug> ,<S2SV_ModStart> ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; 
904,"<S2SV_StartBug> char * name ; <S2SV_EndBug> <S2SV_StartBug> if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL <S2SV_ModEnd> 
905,"<S2SV_StartBug> NICK_REC * list ; <S2SV_EndBug> <S2SV_StartBug> if ( list == nick || list -> next == NULL ) { <S2SV_EndBug> <S2SV_StartBug> g_hash_table_insert ( channel -> nicks , nick -> next -> nick , <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , * newlist <S2SV_ModStart> ) { newlist = <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> <S2SV_ModStart> newlist = list ; <S2SV_ModStart> g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( newlist != NULL ) { g_hash_table_insert ( channel -> nicks , newlist -> nick , newlist ) ; } "
906,"<S2SV_StartBug> jas_matrix_t * jas_seq2d_create ( int xstart , int ystart , int xend , int yend ) <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> "
907,"<S2SV_StartBug> imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false <S2SV_ModStart> , false "
908,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , dev -> bar [ i ] . type ) ; return <S2SV_ModEnd> "
909,"<S2SV_StartBug> ut8 * buf = calloc ( to - from , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> r_buf_read_at ( bf -> buf , from , buf , to - from ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( to - needle ) > 5 ) { <S2SV_EndBug> <S2SV_StartBug> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <S2SV_EndBug> ",<S2SV_ModStart> int len = to - from ; <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> + rc <S2SV_ModStart> ( <S2SV_ModStart> ) && ( <S2SV_ModEnd> <S2SV_ModStart> ) 
910,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
911,<S2SV_StartBug> if ( ( int ) arg >= cdi -> capacity ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
912,"<S2SV_StartBug> int bytes_returned , name_len ; <S2SV_EndBug> ",<S2SV_ModStart> ; unsigned int <S2SV_ModEnd> 
913,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
914,"<S2SV_StartBug> ""Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%"" PRIsize ""<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)"" , <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank><<S2SV_blank>_%u_<S2SV_blank><<S2SV_blank>%u<S2SV_blank>(BT_SHB_INSANE_MAX)"" <S2SV_ModEnd> "
915,<S2SV_StartBug> if ( bee -> ui -> ft_in_start ) { <S2SV_EndBug> ,<S2SV_ModStart> && bu 
916,"<S2SV_StartBug> strcpy ( cat_enum . szPath , fileName ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad1 , fileName ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad1 , sep + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> sep = strchr ( cat_enum . szRad1 , '*' ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad2 , sep + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> sep = strchr ( cat_enum . szRad2 , '%' ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sep ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> if ( strlen ( <S2SV_ModEnd> <S2SV_ModStart> >= sizeof <S2SV_ModEnd> <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( <S2SV_ModEnd> <S2SV_ModStart> ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> } <S2SV_ModStart> szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> <S2SV_ModStart> if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n"" , sep ) ) ; return GF_NOT_SUPPORTED ; } "
917,"<S2SV_StartBug> TLV_TCHECK ( 8 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> 12 <S2SV_ModEnd> <S2SV_ModStart> ""%s"" , tstr <S2SV_ModEnd> "
918,<S2SV_StartBug> hrtimer_cancel ( & stime -> hrt ) ; <S2SV_EndBug> ,<S2SV_ModStart> hrtimer_try_to_cancel <S2SV_ModEnd> 
919,<S2SV_StartBug> const unsigned char * old_name ; <S2SV_EndBug> <S2SV_StartBug> if ( source == target ) <S2SV_EndBug> <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct name_snapshot old_name ; <S2SV_ModStart> take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , <S2SV_ModEnd> <S2SV_ModStart> , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> "
920,"<S2SV_StartBug> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> <S2SV_ModStart> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart>  <S2SV_ModEnd> "
921,"<S2SV_StartBug> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; "
922,"<S2SV_StartBug> void bpf_map_inc ( struct bpf_map * map , bool uref ) <S2SV_EndBug> <S2SV_StartBug> atomic_inc ( & map -> refcnt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct bpf_map * <S2SV_ModEnd> <S2SV_ModStart> if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec <S2SV_ModEnd> <S2SV_ModStart> return ERR_PTR ( - EBUSY ) ; } <S2SV_ModStart> return map ; 
923,<S2SV_StartBug> struct pstore * ps = get_info ( store ) ; <S2SV_EndBug> <S2SV_StartBug> stride = ( ps -> exceptions_per_area + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ps -> next_free ++ ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; skip_metadata ( ps ) 
924,"<S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
925,"<S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ; "
926,"
","
"
927,"<S2SV_StartBug> static int decode_term_subexp ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) + 16 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 5 ) + 32 ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_read_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_read_literal <S2SV_ModEnd> 
928,"<S2SV_StartBug> int best_filt_val = cm -> filter_level ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> yv12_copy_partial_frame <S2SV_ModEnd> <S2SV_ModStart> yv12_copy_partial_frame <S2SV_ModEnd> <S2SV_ModStart> yv12_copy_partial_frame <S2SV_ModEnd> 
929,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( opened & FILE_OPENED ) ) { <S2SV_EndBug> ,<S2SV_ModStart> out2 <S2SV_ModEnd> <S2SV_ModStart> out2 : 
930,<S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> buffer <S2SV_ModEnd> <S2SV_ModStart> ; value |= <S2SV_ModEnd> <S2SV_ModStart> buffer [ 1 ] ; return <S2SV_ModStart>  <S2SV_ModEnd> 
931,"<S2SV_StartBug> if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
932,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> struct usb_interface_cache * intfc ; <S2SV_ModStart> intfc = <S2SV_ModEnd> <S2SV_ModStart> ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <S2SV_ModStart> ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV 
933,<S2SV_StartBug> if ( ! is_launcher ) <S2SV_EndBug> <S2SV_StartBug> if ( nautilus_file_can_execute ( file ) ) <S2SV_EndBug> ,"<S2SV_ModStart> g_autofree gchar * trusted = NULL ; <S2SV_ModStart> trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; <S2SV_ModStart> && trusted != NULL "
934,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ThrowReaderException ( CorruptImageError , <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ThrowDCMException <S2SV_ModEnd> 
935,"<S2SV_StartBug> if ( ! copy_from_iter_full ( kbuf , len , from ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> return ret < 0 ? ret : len ; <S2SV_EndBug> ",<S2SV_ModStart> { kfree ( kbuf ) ; <S2SV_ModStart> } <S2SV_ModStart> kfree ( kbuf ) ; 
936,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
937,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> WaitForMessage ( client , 100000 ) ; <S2SV_EndBug> <S2SV_StartBug> WaitForMessage ( client , 100000 ) ; <S2SV_EndBug> ","<S2SV_ModStart> const int USECS_WAIT_PER_RETRY = 100000 ; int retries = 0 ; <S2SV_ModStart> if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( ""Connection<S2SV_blank>timed<S2SV_blank>out\\n"" ) ; return FALSE ; } <S2SV_ModStart> USECS_WAIT_PER_RETRY <S2SV_ModEnd> <S2SV_ModStart> if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( ""Connection<S2SV_blank>timed<S2SV_blank>out\\n"" ) ; return FALSE ; } <S2SV_ModStart> USECS_WAIT_PER_RETRY <S2SV_ModEnd> "
938,<S2SV_StartBug> subobj_len = EXTRACT_16BITS ( obj_tptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( subobj_len == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> 
939,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
940,"<S2SV_StartBug> xdr_free ( xdr_func , xdr_ptr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
941,"<S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 15 <S2SV_ModEnd> <S2SV_ModStart> * 3 ; aligned_height = <S2SV_ModEnd> <S2SV_ModStart> + 15 <S2SV_ModEnd> 
942,<S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
943,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
944,"<S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> ","<S2SV_ModStart> unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
945,<S2SV_StartBug> log_flush ( LOG_MODE_ERROR ) ; <S2SV_EndBug> ,<S2SV_ModStart> LOG_MODE_BUFFER <S2SV_ModEnd> 
946,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_cur_slice_num ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ps_dec -> u4_first_slice_in_pic != 0 ) <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_ModStart> if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; <S2SV_ModStart> } <S2SV_ModEnd> 
947,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { return 0 ; } <S2SV_ModEnd> 
948,<S2SV_StartBug> if ( ! vct_iscrlf ( * p ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( ; ! vct_iscrlf ( * p ) ; p ++ ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
949,"<S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
950,<S2SV_StartBug> lua_newtable ( L ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ) ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"" "
951,<S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_SOP ) { <S2SV_EndBug> <S2SV_StartBug> if ( tcp -> csty & J2K_CP_CSTY_EPH ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , ""opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>"" ""output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n"" , length , 2 ) ; } return OPJ_FALSE ; } "
952,"<S2SV_StartBug> ( void ) data ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ctx -> priv ) <S2SV_EndBug> <S2SV_StartBug> vpx_codec_mmap_t mmap ; <S2SV_EndBug> <S2SV_StartBug> vp8_init_ctx ( ctx , & mmap ) ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> fragments . count = 0 ; <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> fragments . enabled = <S2SV_EndBug> <S2SV_StartBug> ( ctx -> priv -> alg_priv -> base . init_flags & <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> defer_alloc = 1 ; <S2SV_EndBug> <S2SV_StartBug> ( ctx -> priv -> alg_priv -> base . init_flags & <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> priv -> alg_priv -> yv12_frame_buffers . use_frame_threads && <S2SV_EndBug> <S2SV_StartBug> ( ( ctx -> priv -> alg_priv -> base . init_flags & <S2SV_EndBug> <S2SV_StartBug> VPX_CODEC_USE_ERROR_CONCEALMENT ) <S2SV_EndBug> <S2SV_StartBug> || ( ctx -> priv -> alg_priv -> base . init_flags & <S2SV_EndBug> ",<S2SV_ModStart> vpx_codec_alg_priv_t * priv = NULL ; <S2SV_ModStart> vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; priv = ( vpx_codec_alg_priv_t * ) <S2SV_ModEnd> <S2SV_ModStart> ; priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> } else { priv = ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> ; } priv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
953,<S2SV_StartBug> struct inode * inode = file_inode ( bprm -> file ) ; <S2SV_EndBug> <S2SV_StartBug> bprm -> cred -> euid = current_euid ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bprm_fill_uid ( bprm ) ; <S2SV_ModEnd> 
954,<S2SV_StartBug> if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
955,"<S2SV_StartBug> VP9_CONFIG * oxcf , <S2SV_EndBug> <S2SV_StartBug> oxcf -> profile = cfg -> g_profile ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> width = cfg -> g_w ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> bit_depth = extra_cfg -> bit_depth ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> framerate > 180 ) <S2SV_EndBug> <S2SV_StartBug> oxcf -> framerate = 30 ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_GOODQUALITY ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_FIRSTPASS ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> mode = MODE_SECONDPASS_BEST ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> end_usage = USAGE_LOCAL_FILE_PLAYBACK ; <S2SV_EndBug> <S2SV_StartBug> if ( cfg -> rc_end_usage == VPX_CQ ) <S2SV_EndBug> <S2SV_StartBug> oxcf -> target_bandwidth = cfg -> rc_target_bitrate ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> best_allowed_q = q_trans [ cfg -> rc_min_quantizer ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> worst_allowed_q = q_trans [ cfg -> rc_max_quantizer ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> cq_level = q_trans [ extra_cfg -> cq_level ] ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> maximum_buffer_size = cfg -> rc_buf_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> starting_buffer_level = cfg -> rc_buf_initial_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> optimal_buffer_level = cfg -> rc_buf_optimal_sz ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> cpu_used = extra_cfg -> cpu_used ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> output_pkt_list = extra_cfg -> pkt_list ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> arnr_type = extra_cfg -> arnr_type ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> tile_columns = extra_cfg -> tile_columns ; <S2SV_EndBug> <S2SV_StartBug> oxcf -> lossless = extra_cfg -> lossless ; <S2SV_EndBug> <S2SV_StartBug> if ( oxcf -> ss_number_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( oxcf -> ss_target_bitrate , cfg -> ss_target_bitrate ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( oxcf -> ss_number_layers == 1 ) { <S2SV_EndBug> <S2SV_StartBug> oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> const int is_vbr = cfg -> rc_end_usage == VPX_VBR ; int sl , tl ; <S2SV_ModStart> max_threads = ( int ) cfg -> g_threads ; oxcf -> <S2SV_ModStart> cfg -> g_bit_depth ; oxcf -> input_bit_depth = cfg -> g_input_bit_depth ; oxcf -> init_framerate <S2SV_ModEnd> <S2SV_ModStart> init_framerate <S2SV_ModEnd> <S2SV_ModStart> init_framerate = 30 ; oxcf -> mode = GOOD <S2SV_ModEnd> <S2SV_ModStart> pass = 0 <S2SV_ModEnd> <S2SV_ModStart> pass = 1 <S2SV_ModEnd> <S2SV_ModStart> pass = 2 <S2SV_ModEnd> <S2SV_ModStart> rc_mode = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 1000 * <S2SV_ModStart> rc_max_inter_bitrate_pct = extra_cfg -> rc_max_inter_bitrate_pct ; oxcf -> gf_cbr_boost_pct = extra_cfg -> gf_cbr_boost_pct ; oxcf -> best_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> vp9_quantizer_to_qindex ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> scaled_frame_width = cfg -> rc_scaled_width ; oxcf -> scaled_frame_height = cfg -> rc_scaled_height ; if ( cfg -> rc_resize_allowed == 1 ) { oxcf -> resize_mode = ( oxcf -> scaled_frame_width == 0 || oxcf -> scaled_frame_height == 0 ) ? RESIZE_DYNAMIC : RESIZE_FIXED ; } else { oxcf -> resize_mode = RESIZE_NONE ; } oxcf -> maximum_buffer_size_ms = is_vbr ? 240000 : <S2SV_ModEnd> <S2SV_ModStart> starting_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> <S2SV_ModStart> optimal_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> <S2SV_ModStart> speed = abs ( extra_cfg -> cpu_used ) <S2SV_ModEnd> <S2SV_ModStart> enable_auto_arf <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS oxcf -> firstpass_mb_stats_in = cfg -> rc_firstpass_mb_stats_in ; # endif oxcf -> color_space = extra_cfg -> color_space <S2SV_ModEnd> <S2SV_ModStart> min_gf_interval = extra_cfg -> min_gf_interval ; oxcf -> max_gf_interval = extra_cfg -> max_gf_interval <S2SV_ModEnd> <S2SV_ModStart> content = extra_cfg -> content ; oxcf -> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> oxcf -> ts_number_layers = cfg -> ts_number_layers ; oxcf -> temporal_layering_mode = ( enum vp9e_temporal_layering_mode ) cfg -> temporal_layering_mode ; for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ sl ] = cfg -> ss_enable_auto_alt_ref [ sl ] ; # endif for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { oxcf -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] = 1000 * cfg -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] ; } } if <S2SV_ModEnd> <S2SV_ModStart> == 1 && oxcf -> pass != 0 ) { oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ 0 ] = extra_cfg -> enable_auto_alt_ref ; # endif } if ( oxcf -> ts_number_layers <S2SV_ModStart> for ( tl = 0 ; tl < VPX_TS_MAX_LAYERS ; ++ tl ) { oxcf -> ts_rate_decimator [ tl ] = cfg -> ts_rate_decimator [ tl ] ? cfg -> ts_rate_decimator [ tl ] : 1 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
956,"<S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> indx , data , size , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; "
957,<S2SV_StartBug> if ( ! saw_digit ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> if ( * bp != '\\r' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> if ( * bp != '\\n' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> <S2SV_StartBug> return ( - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( - 5 ) ; <S2SV_EndBug> ,<S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> { bp ++ ; <S2SV_ModStart> } <S2SV_ModStart> * endp = bp ; <S2SV_ModStart> * endp = bp ; 
958,<S2SV_StartBug> len = dp -> ip6r_len ; <S2SV_EndBug> ,<S2SV_ModStart> ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
959,"<S2SV_StartBug> size_t cnt = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( ( ! __libc_enable_secure <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 1 ] , ""ORIGIN"" , 6 ) == 0 && ( len = 7 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> && strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> const char * const start = name ; <S2SV_ModStart> strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( ! __libc_enable_secure || ( ( name [ 7 ] == '\\0' || ( is_path && name [ 7 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) && ( len = 7 ) != 0 ) || ( <S2SV_ModEnd> <S2SV_ModStart> ""PLATFORM}"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && <S2SV_ModEnd> <S2SV_ModStart> || ( ( name [ 9 ] == '\\0' || ( is_path && name [ 9 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) <S2SV_ModEnd> "
960,"<S2SV_StartBug> retval = generic_gss_oid_decompose ( minor_status , <S2SV_EndBug> ",<S2SV_ModStart> if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } 
961,<S2SV_StartBug> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) | ( 1u << AC_VECTOR 
962,"<S2SV_StartBug> file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
963,"<S2SV_StartBug> tags = stok ( sclone ( tags ) , ""<S2SV_blank>"" , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
964,"<S2SV_StartBug> if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) { <S2SV_EndBug> ",<S2SV_ModStart> ( len > 12 ) && <S2SV_ModStart> ( len > 9 ) && 
965,<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
966,<S2SV_StartBug> int nalloca ; <S2SV_EndBug> <S2SV_StartBug> if ( skip == 0 && glob_pattern_p ( pat ) == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> hasglob ; int <S2SV_ModStart> hasglob = 0 ; <S2SV_ModStart> ( hasglob = <S2SV_ModStart> ) == 0 || hasglob == 2 <S2SV_ModEnd> 
967,<S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dp [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> dp [ 2 ] <S2SV_ModEnd> <S2SV_ModStart> dp [ 3 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dp [ 1 ] <S2SV_ModEnd> 
968,<S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> ,<S2SV_ModStart> dec_tables . T <S2SV_ModEnd> <S2SV_ModStart> dec_tables . T <S2SV_ModEnd> 
969,"<S2SV_StartBug> int32_t sessionId , <S2SV_EndBug> <S2SV_StartBug> int32_t ioId , <S2SV_EndBug> ",<S2SV_ModStart> __unused <S2SV_ModStart> __unused 
970,"<S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> { atomic_sub ( <S2SV_ModEnd> <S2SV_ModStart> , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> } "
971,"<S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug> ","<S2SV_ModStart> size_t size ; <S2SV_ModStart> if ( ! jas_safe_size_mul ( <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , & size <S2SV_ModEnd> <S2SV_ModStart> dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } "
972,"<S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
973,<S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug> ,<S2SV_ModStart> static 
974,"<S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> ",<S2SV_ModStart> && ps_stream -> u4_offset < ps_stream -> u4_max_offset 
975,"<S2SV_StartBug> struct is_skippable_args args = { x , & result } ; <S2SV_EndBug> ",<S2SV_ModStart> -> plane [ plane ] . eobs 
976,"<S2SV_StartBug> dev_data = pci_get_drvdata ( dev ) ; <S2SV_EndBug> <S2SV_StartBug> return pci_write_config_word ( dev , offset , value ) ; <S2SV_EndBug> ","<S2SV_ModStart> u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ; "
977,<S2SV_StartBug> yi . cfg . mask = 0xffffffff ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & yi , 0 , sizeof ( yi ) ) ; "
978,<S2SV_StartBug> if ( last_sec > 0 && last_usec > 0 ) { <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ,"<S2SV_ModStart> caplentoobig ) { printf ( ""\\n\\nCapture<S2SV_blank>file<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>damaged<S2SV_blank>or<S2SV_blank>corrupt.\\n"" ""Contains<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%u,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>snap<S2SV_blank>length<S2SV_blank>%u\\n"" , caplen , pcap_fh . snaplen ) ; close ( fd ) ; break ; } if ( <S2SV_ModStart> break <S2SV_ModEnd> "
979,<S2SV_StartBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> <S2SV_StartBug> tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> ptr -> quality_entry_count = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> <S2SV_StartBug> tmp_str [ j ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> <S2SV_StartBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> tmp_strsize = ( u32 ) ptr -> size - 8 ; <S2SV_EndBug> <S2SV_StartBug> tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ptr -> fragment_run_table_count = gf_bs_read_u8 ( bs ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ISOM_DECREASE_SIZE ( ptr , 1 ) "
980,<S2SV_StartBug> uint32_t sampleRate ; <S2SV_EndBug> <S2SV_StartBug> if ( ! config -> num_channels ) { <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> || ! config -> sample_rate 
981,"<S2SV_StartBug> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
982,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> pdo_row_ce -> unserialize = zend_class_unserialize_deny ; 
983,<S2SV_StartBug> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) <S2SV_EndBug> ,<S2SV_ModStart> EOFBlob ( image ) ) break ; if ( 
984,<S2SV_StartBug> s32 smin_val = src_reg -> smin_value ; <S2SV_EndBug> <S2SV_StartBug> u32 umin_val = src_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_min_value = dst_reg -> umin_value ; <S2SV_EndBug> <S2SV_StartBug> dst_reg -> s32_max_value = dst_reg -> umax_value ; <S2SV_EndBug> ,<S2SV_ModStart> s32_min_value <S2SV_ModEnd> <S2SV_ModStart> u32_min_value <S2SV_ModEnd> <S2SV_ModStart> u32_min_value <S2SV_ModEnd> <S2SV_ModStart> u32_max_value <S2SV_ModEnd> 
985,<S2SV_StartBug> if ( setpwnam ( ctl -> pw ) < 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> , "".chfn"" "
986,<S2SV_StartBug> for ( row = 0 ; row < 6 ; row ++ ) <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> homo = ( char ( * ) [ TS ] [ TS ] ) ( buffer + TS * TS * ( ndir * 10 + 6 ) ) ; <S2SV_EndBug> <S2SV_StartBug> allhex [ row ] [ col ] [ 0 ] [ c ^ ( g * 2 & d ) ] = h + v * width ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> row -- ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( width < TS || height < TS ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; <S2SV_ModStart> for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 8 ; l ++ ) allhex [ i ] [ j ] [ k ] [ l ] = 32700 ; <S2SV_ModStart> ; int minv = 0 , maxv = 0 , minh = 0 , maxh = 0 <S2SV_ModStart> minv = MIN ( v , minv ) ; maxv = MAX ( v , maxv ) ; minh = MIN ( v , minh ) ; maxh = MAX ( v , maxh ) ; <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 8 ; l ++ ) if ( allhex [ i ] [ j ] [ k ] [ l ] > maxh + maxv * width + 1 || allhex [ i ] [ j ] [ k ] [ l ] < minh + minv * width - 1 ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; int retrycount = 0 ; # endif <S2SV_ModStart> { <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( retrycount ++ > width * height ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif } "
987,<S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> 
988,<S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
989,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ii -> ii_ioapic_irq > 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ii -> ii_pirq_pin = pirq_alloc_pin ( dev ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
990,<S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> ,"<S2SV_ModStart> MIN ( <S2SV_ModStart> , sizeof buf ) "
991,"<S2SV_StartBug> write ( logfile_fd , data , length ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
992,"<S2SV_StartBug> s_cmd -> command += ec -> cmd_offset ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) ) <S2SV_EndBug> ",<S2SV_ModStart> if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <S2SV_ModStart> s_cmd -> <S2SV_ModEnd> 
993,<S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> vpx_free <S2SV_ModEnd> 
994,<S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> env -> insn_aux_data [ insn_idx ] . seen = true ; 
995,<S2SV_StartBug> u1_num_mbs ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; 
996,<S2SV_StartBug> return true ; <S2SV_EndBug> <S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> <S2SV_ModStart> if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ; 
997,<S2SV_StartBug> if ( ! replay_esn || ! rp ) <S2SV_EndBug> <S2SV_StartBug> if ( xfrm_replay_state_esn_len ( replay_esn ) != <S2SV_EndBug> <S2SV_StartBug> xfrm_replay_state_esn_len ( up ) ) <S2SV_EndBug> ,<S2SV_ModStart> int ulen ; <S2SV_ModStart> ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || <S2SV_ModEnd> <S2SV_ModStart> ulen <S2SV_ModEnd> 
998,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int do_recon ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) ; <S2SV_EndBug> <S2SV_StartBug> int last_part_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) <S2SV_EndBug> <S2SV_StartBug> partition = partition_lookup [ bsl ] [ bs_type ] ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_16X16 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & none_rate , & none_dist , bsize , <S2SV_EndBug> <S2SV_StartBug> if ( none_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> none_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> none_rd = RDCOST ( x -> rdmult , x -> rddiv , none_rate , none_dist ) ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( last_part_rate != INT_MAX && <S2SV_EndBug> <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + ( mi_step >> 1 ) , mi_col , & rt , & dt , <S2SV_EndBug> <S2SV_StartBug> subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( last_part_rate != INT_MAX && <S2SV_EndBug> <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ( mi_step >> 1 ) , & rt , & dt , <S2SV_EndBug> <S2SV_StartBug> subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> <S2SV_StartBug> last_part_rate = 0 ; <S2SV_EndBug> <S2SV_StartBug> int rt ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> i != 3 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> last_part_rate += rt ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( last_part_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> last_part_rate += x -> partition_cost [ pl ] [ partition ] ; <S2SV_EndBug> <S2SV_StartBug> last_part_rd = RDCOST ( x -> rdmult , x -> rddiv , last_part_rate , last_part_dist ) ; <S2SV_EndBug> <S2SV_StartBug> chosen_rate = 0 ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> int rt = 0 ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , split_subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + y_idx , mi_col + x_idx , & rt , & dt , <S2SV_EndBug> <S2SV_StartBug> if ( rt == INT_MAX || dt == INT64_MAX ) { <S2SV_EndBug> <S2SV_StartBug> chosen_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> chosen_rate += rt ; <S2SV_EndBug> <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , 0 , <S2SV_EndBug> <S2SV_StartBug> split_subsize ) ; <S2SV_EndBug> <S2SV_StartBug> chosen_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> if ( chosen_rate < INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> chosen_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> chosen_rd = RDCOST ( x -> rdmult , x -> rddiv , chosen_rate , chosen_dist ) ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( chosen_rate < INT_MAX && chosen_dist < INT64_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> <S2SV_StartBug> * dist = chosen_dist ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> <S2SV_ModStart> , PC_TREE * pc_tree <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart> RD_COST last_part_rdc , none_rdc , chosen_rdc <S2SV_ModEnd> <S2SV_ModStart> PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; <S2SV_ModStart> vp9_rd_cost_reset ( & last_part_rdc ) ; vp9_rd_cost_reset ( & none_rdc ) ; vp9_rd_cost_reset ( & chosen_rdc ) ; <S2SV_ModStart> pc_tree -> partitioning = partition ; save_context ( x <S2SV_ModEnd> <S2SV_ModStart> && cpi -> oxcf . aq_mode <S2SV_ModStart> tile_info , x <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , & none_rdc , bsize , ctx <S2SV_ModEnd> <S2SV_ModStart> none_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> none_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> none_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> none_rdc . rate , none_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = partition <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , & last_part_rdc , bsize , ctx <S2SV_ModEnd> <S2SV_ModStart> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> horizontal [ 0 ] , <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) <S2SV_ModEnd> <S2SV_ModStart> td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc <S2SV_ModEnd> <S2SV_ModStart> & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> vertical [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) <S2SV_ModEnd> <S2SV_ModStart> td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc <S2SV_ModEnd> <S2SV_ModStart> & pc_tree -> vertical [ bsize > BLOCK_8X8 ] , <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> if ( bsize == BLOCK_8X8 ) { rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , pc_tree -> leaf_split [ 0 ] , INT64_MAX ) ; break ; } last_part_rdc . rate = 0 ; last_part_rdc . dist = 0 ; last_part_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> RD_COST tmp_rdc <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_init ( & tmp_rdc ) ; rd_use_partition ( cpi , td , tile_data , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx , subsize , & tmp_rdc . rate , & tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> , pc_tree -> split [ i ] ) ; if ( tmp_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> break ; <S2SV_ModStart> last_part_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> last_part_rdc . rate , last_part_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate = 0 ; chosen_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModStart> RD_COST tmp_rdc <S2SV_ModEnd> <S2SV_ModStart> save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; pc_tree -> split [ i ] -> partitioning = PARTITION_NONE ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row + y_idx , mi_col + x_idx , & tmp_rdc , split_subsize , & pc_tree -> split [ i ] -> none , INT64_MAX ) ; restore_context ( x <S2SV_ModEnd> <S2SV_ModStart> if ( tmp_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> vp9_rd_cost_reset ( & chosen_rdc ) <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate += tmp_rdc . rate ; chosen_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> td , tile_info <S2SV_ModEnd> <S2SV_ModStart> , pc_tree -> split [ i ] <S2SV_ModStart> chosen_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate , chosen_rdc . dist ) ; } } if ( last_part_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = partition ; chosen_rdc = last_part_rdc ; } if ( none_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = PARTITION_NONE ; chosen_rdc = none_rdc <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , bsize , pc_tree ) ; } * rate = chosen_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> chosen_rdc . dist <S2SV_ModEnd> "
999,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>method=%s"" , len - 4 , <S2SV_EndBug> <S2SV_StartBug> if ( 1 < ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> <S2SV_StartBug> return ( const u_char * ) ext + len ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" <S2SV_ModEnd> <S2SV_ModStart> len > 4 ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
1000,"<S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0U ; i < ( maxh & ~ ( unsigned int ) 1U ) ; i += 2U ) <S2SV_EndBug> <S2SV_StartBug> ny = y + maxw ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> if ( j < maxw ) <S2SV_EndBug> <S2SV_StartBug> if ( i < maxh ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> <S2SV_ModStart> size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d2 = b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> loopmaxh <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t j ; <S2SV_ModStart> if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> loopmaxw <S2SV_ModEnd> <S2SV_ModStart> loopmaxh ) { size_t j ; <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> <S2SV_ModStart> dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> <S2SV_ModStart> dy = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1001,"<S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug> ",<S2SV_ModStart> inline <S2SV_ModStart> len - i >= 8 * 32 <S2SV_ModEnd> <S2SV_ModStart> for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; } 
1002,"<S2SV_StartBug> ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> bcount != chunk_header . ckSize ) { <S2SV_EndBug> <S2SV_StartBug> ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) { <S2SV_EndBug> ",<S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> <S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> <S2SV_ModStart> sizeof ( DS64Chunk ) <S2SV_ModEnd> 
1003,"<S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; <S2SV_ModEnd> <S2SV_ModStart> res <S2SV_ModEnd> <S2SV_ModStart> res <S2SV_ModEnd> "
1004,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! strcmp ( line , ""HASHSEED"" ) ) { conf . have_hashseed = 1 ; conf . hashseed = atoi ( val ) ; } else { conf . have_hashseed = 0 ; } "
1005,"<S2SV_StartBug> } else if ( cpkt . cptype == MT_CPTYPE_PASSWORD ) { <S2SV_EndBug> <S2SV_StartBug> syslog ( LOG_WARNING , _ ( ""(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d"" ) , curconn -> seskey , cpkt . cptype ) ; <S2SV_EndBug> ","<S2SV_ModStart> && cpkt . length == 17 <S2SV_ModStart> ""(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> , cpkt . length "
1006,<S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> u64 insn_bitness = <S2SV_ModEnd> <S2SV_ModStart> == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> <S2SV_ModStart> >= insn_bitness <S2SV_ModEnd> <S2SV_ModStart> >= insn_bitness <S2SV_ModEnd> <S2SV_ModStart> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } "
1007,"<S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } "
1008,"<S2SV_StartBug> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; <S2SV_EndBug> <S2SV_StartBug> return ( DestroyImageList ( image ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( <S2SV_ModEnd> <S2SV_ModStart> + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> <S2SV_ModStart> ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" <S2SV_ModEnd> "
1009,"<S2SV_StartBug> ret = copy_to_user ( uattr , attr , usize ) ; <S2SV_EndBug> ",<S2SV_ModStart> attr -> size <S2SV_ModEnd> 
1010,"<S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> "
1011,"<S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> <S2SV_StartBug> sctp_clear_pd ( oldsk ) ; <S2SV_EndBug> ","<S2SV_ModStart> sctp_sock_rfree_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_skb_set_owner_r_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_sock_rfree_frag <S2SV_ModEnd> <S2SV_ModStart> sctp_skb_set_owner_r_frag <S2SV_ModEnd> <S2SV_ModStart> ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk "
1012,"<S2SV_StartBug> static void nsc_decode ( NSC_CONTEXT * context ) <S2SV_EndBug> <S2SV_StartBug> UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> BYTE shift = context -> ColorLossLevel - 1 ; <S2SV_EndBug> <S2SV_StartBug> BYTE * bmpdata = context -> BitmapData ; <S2SV_EndBug> <S2SV_StartBug> * bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! bmpdata ) return FALSE <S2SV_ModStart> if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <S2SV_ModStart> return TRUE ; 
1013,<S2SV_StartBug> dst [ y * linesize + x ] = clr ; <S2SV_EndBug> ,<S2SV_ModStart> if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ; 
1014,<S2SV_StartBug> return - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> fclose ( mapf ) ; 
1015,"<S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> psf_allocate ( <S2SV_ModEnd> 
1016,<S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; } "
1017,<S2SV_StartBug> devc -> voc [ voice ] . panning = value ; <S2SV_EndBug> ,<S2SV_ModStart> if ( voice < 0 || voice >= devc -> nr_voice ) return ; 
1018,"<S2SV_StartBug> cib_remote_opaque_t * private = cib -> variant_opaque ; <S2SV_EndBug> <S2SV_StartBug> gnutls_bye ( * ( private -> command . session ) , GNUTLS_SHUT_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_bye ( * ( private -> callback . session ) , GNUTLS_SHUT_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_anon_free_client_credentials ( anon_cred_c ) ; <S2SV_EndBug> <S2SV_StartBug> gnutls_global_deinit ( ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( private -> command . session ) { <S2SV_ModStart> } if ( private -> callback . session ) { <S2SV_ModStart> } private -> command . session = NULL ; private -> callback . session = NULL ; if ( remote_gnutls_credentials_init ) { <S2SV_ModStart> remote_gnutls_credentials_init = FALSE ; } <S2SV_ModStart> if ( private -> command . socket ) { shutdown ( private -> command . socket , SHUT_RDWR ) ; close ( private -> command . socket ) ; } if ( private -> callback . socket ) { shutdown ( private -> callback . socket , SHUT_RDWR ) ; close ( private -> callback . socket ) ; } private -> command . socket = 0 ; private -> callback . socket = 0 ; free ( private -> command . recv_buf ) ; free ( private -> callback . recv_buf ) ; private -> command . recv_buf = NULL ; private -> callback . recv_buf = NULL ; "
1019,<S2SV_StartBug> if ( ! is_exception ( intr_info ) ) <S2SV_EndBug> ,<S2SV_ModStart> is_nmi <S2SV_ModEnd> 
1020,"<S2SV_StartBug> static int update_mv ( vp9_writer * w , const unsigned int ct [ 2 ] , vp9_prob * cur_p , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd_p ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_prob new_p = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) | 1 ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , update , upd_p ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , new_p >> 1 , 7 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_write <S2SV_ModEnd> <S2SV_ModStart> vpx_write_literal <S2SV_ModEnd> 
1021,"<S2SV_StartBug> defaultoptions ( & h ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , res ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , f ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushnumber ( L , d ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! lua_isnumber ( L , - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> luaL_error ( L , ""format<S2SV_blank>`c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pop ( L , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushlstring ( L , data + pos , size ) ; <S2SV_EndBug> <S2SV_StartBug> lua_pushlstring ( L , data + pos , size - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return lua_gettop ( L ) - 2 ; <S2SV_EndBug> ","<S2SV_ModStart> int n = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 2 <S2SV_ModEnd> <S2SV_ModStart> n ++ ; <S2SV_ModStart> n ++ ; <S2SV_ModStart> n ++ ; <S2SV_ModStart> n == 0 || <S2SV_ModStart> ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" <S2SV_ModEnd> <S2SV_ModStart> n -- ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && pos <= ld - size , <S2SV_ModEnd> <S2SV_ModStart> ; n ++ <S2SV_ModStart> n ++ ; <S2SV_ModStart> n + 1 <S2SV_ModEnd> "
1022,<S2SV_StartBug> for ( i = 0 ; i < ctx -> msgcount ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> if ( strlen ( line ) == 0 ) return - 1 ; 
1023,<S2SV_StartBug> int overflow_error = 0 ; <S2SV_EndBug> <S2SV_StartBug> res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( u = 0 ; u < line_length ; u ++ ) { <S2SV_EndBug> <S2SV_StartBug> res -> ContribRow [ u ] . Weights = ( double * ) gdMalloc ( windows_size * sizeof ( double ) ) ; <S2SV_EndBug> <S2SV_StartBug> u -- ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i <= u ; i ++ ) { <S2SV_EndBug> ,"<S2SV_ModStart> size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> weights_size ) ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> < <S2SV_ModEnd> "
1024,<S2SV_StartBug> timer -> it_overrun += 1 << i ; <S2SV_EndBug> ,<S2SV_ModStart> 1LL <S2SV_ModEnd> 
1025,"<S2SV_StartBug> map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ; <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
1026,"<S2SV_StartBug> net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , <S2SV_EndBug> ","<S2SV_ModStart> server -> connrec -> address , "
1027,"<S2SV_StartBug> static void write_segment_id ( vp9_writer * w , const struct segmentation * seg , <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> 
1028,<S2SV_StartBug> FLACHeader hdr ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( last ) break ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ctx -> in_error ) return GF_NON_COMPLIANT_BITSTREAM <S2SV_ModStart> GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>magic\\n"" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM ; <S2SV_ModStart> ; } if ( ! dsi_end ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( ""[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>header\\n"" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM "
1029,<S2SV_StartBug> if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & 
1030,<S2SV_StartBug> struct dentry * dir ; <S2SV_EndBug> <S2SV_StartBug> ci = d_inode ( dir ) -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> dir_has_key = ( ci != NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> 
1031,<S2SV_StartBug> fp -> protocol = altsd -> bInterfaceProtocol ; <S2SV_EndBug> ,<S2SV_ModStart> if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } 
1032,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! uc_more_data_flag && ! i2_mb_skip_run && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; } 
1033,<S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> ,<S2SV_ModStart> bad_format_axis ( optarg ) ) { <S2SV_ModEnd> <S2SV_ModStart> bad_format_axis ( optarg ) ) { <S2SV_ModEnd> 
1034,"<S2SV_StartBug> kvmclock_reset ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vcpu -> arch . time_offset & <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . time_page = <S2SV_EndBug> <S2SV_StartBug> gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; <S2SV_EndBug> ","<S2SV_ModStart> u64 gpa_offset ; <S2SV_ModStart> gpa_offset <S2SV_ModEnd> <S2SV_ModStart> gpa_offset <S2SV_ModEnd> <S2SV_ModStart> if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> <S2SV_ModStart> & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> "
1035,"<S2SV_StartBug> unsigned v = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_planes = get_rac ( c , state ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_h_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> chroma_v_shift = get_symbol ( c , state , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> f -> transparency = get_rac ( c , state ) ; <S2SV_EndBug> ","<S2SV_ModStart> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency "
1036,"<S2SV_StartBug> usb_set_intfdata ( interface , dev ) ; <S2SV_EndBug> <S2SV_StartBug> exit : <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , ""Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n"" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , ""LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>"" ""%d<S2SV_blank>minor<S2SV_blank>%d\\n"" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; "
1037,"<S2SV_StartBug> int i , length_modes , length_chars ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> old_length_chars , <S2SV_ModStart> ; old_length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 <S2SV_ModStart> length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 ; if ( server -> prefix_chars && ( length_chars != old_length_chars ) ) irc_nick_realloc_prefixes ( server , old_length_chars , length_chars ) ; "
1038,<S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> ) ; mutex_unlock ( & q -> timer_mutex 
1039,<S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ,<S2SV_ModStart> plen <S2SV_ModEnd> 
1040,<S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping ) <S2SV_EndBug> ,<S2SV_ModStart> hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
1041,"<S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> ",<S2SV_ModStart> ; int err <S2SV_ModStart> err = <S2SV_ModEnd> <S2SV_ModStart> ; if ( err <S2SV_ModStart> ERR_PTR ( err ) <S2SV_ModEnd> 
1042,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> limit_r_end - limit_r_begin <S2SV_ModEnd> 
1043,<S2SV_StartBug> if ( length > 4 ) <S2SV_EndBug> <S2SV_StartBug> if ( length > 6 ) <S2SV_EndBug> ,<S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> 7 <S2SV_ModEnd> 
1044,<S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> ,<S2SV_ModStart> ; CLEAR ( WaveHeader ) 
1045,<S2SV_StartBug> void unix_notinflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight -- ; <S2SV_EndBug> ,"<S2SV_ModStart> struct user_struct * user , <S2SV_ModStart>  <S2SV_ModEnd> "
1046,<S2SV_StartBug> if ( argReg >= regsz ) { <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> <S2SV_ModStart> return ; 
1047,"<S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rows , <S2SV_ModEnd> <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> <S2SV_ModStart> rows <S2SV_ModEnd> "
1048,<S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; } "
1049,"<S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ; <S2SV_EndBug> <S2SV_StartBug> if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; <S2SV_EndBug> ","<S2SV_ModStart> manager_ctx * manager , struct <S2SV_ModStart> ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method <S2SV_ModStart>  <S2SV_ModEnd> "
1050,<S2SV_StartBug> if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) { <S2SV_EndBug> <S2SV_StartBug> rc = ses -> server -> ops -> generate_signingkey ( ses ) ; <S2SV_EndBug> <S2SV_StartBug> goto keygen_exit ; <S2SV_EndBug> <S2SV_StartBug> keygen_exit : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1051,<S2SV_StartBug> if ( type == HUB_INIT2 ) <S2SV_EndBug> <S2SV_StartBug> if ( type == HUB_INIT3 ) <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> <S2SV_ModStart> device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; "
1052,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> else kvm_iommu_unmap_pages ( kvm , & old ) ; "
1053,<S2SV_StartBug> unsigned char buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,"<S2SV_ModStart> * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> kfree ( buffer ) ; "
1054,<S2SV_StartBug> const char * base ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1055,"<S2SV_StartBug> fprintf ( file , ""<S2SV_blank>%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> ","<S2SV_ModStart> fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> <S2SV_ModStart> file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> , file "
1056,"<S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> ","<S2SV_ModStart> js_doregexec ( J , <S2SV_ModEnd> "
1057,"<S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> ","<S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> <S2SV_ModStart> true , NULL <S2SV_ModEnd> "
1058,"<S2SV_StartBug> int qindex , double rate_target_ratio ) { <S2SV_EndBug> <S2SV_StartBug> const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 ) ; <S2SV_EndBug> <S2SV_StartBug> target_index = i ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 ) <= target_bits_per_mb ) <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth <S2SV_ModStart> , bit_depth <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , bit_depth <S2SV_ModStart> { target_index = i ; break ; } <S2SV_ModEnd> "
1059,"<S2SV_StartBug> strlcpy ( racomp . type , ""acomp"" , sizeof ( racomp . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
1060,"<S2SV_StartBug> s = strchr ( token , '?' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
1061,"<S2SV_StartBug> if ( ( datao + 8 < datao ) || ( datao + 8 < 8 ) || ( datao + 8 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> <S2SV_StartBug> ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ; <S2SV_EndBug> <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ","<S2SV_ModStart> CHECKOVERFLOW ( datao , buf_size , 8 <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataPentax"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnotePentax"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_pentax_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart> ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataPentax"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>"" ""of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataPentax"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s <S2SV_ModEnd> "
1062,"<S2SV_StartBug> memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; 
1063,"<S2SV_StartBug> err = ops -> cee_peer_getpg ( netdev , & pg ) ; <S2SV_EndBug> <S2SV_StartBug> struct cee_pfc pfc ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( & pg , 0 , sizeof ( pg ) ) ; <S2SV_ModStart> ; memset ( & pfc , 0 , sizeof ( pfc ) ) "
1064,"<S2SV_StartBug> unsigned facility ; <S2SV_EndBug> <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> <S2SV_StartBug> while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndDRS:f:p:i:mM::g::Gt::"" <S2SV_EndBug> <S2SV_StartBug> case 't' : <S2SV_EndBug> ","<S2SV_ModStart> ; mode_t new_umask_val <S2SV_ModStart> { ""umask"" , required_argument , NULL , 'u' } , <S2SV_ModStart> "":vhlndu:DRS:f:p:i:mM::g::Gt::"" <S2SV_ModEnd> <S2SV_ModStart> 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case "
1065,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> match_data -> cmp = asymmetric_key_cmp ; 
1066,"<S2SV_StartBug> struct address_space * mapping = inode -> i_mapping ; <S2SV_EndBug> <S2SV_StartBug> if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { <S2SV_EndBug> <S2SV_StartBug> truncate_pagecache_range ( inode , start , end - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> flags , mode ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem 
1067,"<S2SV_StartBug> ap_assert ( stream ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> has_response ) { <S2SV_EndBug> <S2SV_StartBug> return h2_stream_set_error ( stream , <S2SV_EndBug> <S2SV_StartBug> return h2_stream_set_error ( stream , <S2SV_EndBug> <S2SV_StartBug> HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ) ; <S2SV_EndBug> ","<S2SV_ModStart> int error = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return APR_EINVAL ; } ++ stream -> request_headers_added ; <S2SV_ModStart> error = HTTP_REQUEST_URI_TOO_LARGE <S2SV_ModEnd> <S2SV_ModStart> error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 ) { if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 + 100 ) { return APR_ECONNRESET ; } ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream -> session -> c , ""h2_stream(%ld-%d):<S2SV_blank>too<S2SV_blank>many<S2SV_blank>header<S2SV_blank>lines"" , stream -> session -> id , stream -> id ) ; error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( h2_stream_is_scheduled ( stream ) ) { return add_trailer ( stream , name , nlen , value , vlen ) ; } else if ( error ) { <S2SV_ModStart> error <S2SV_ModEnd> "
1068,<S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; } 
1069,<S2SV_StartBug> pte_unmap ( page_table ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS 
1070,<S2SV_StartBug> if ( * p == FAC_CCITT_DEST_NSAP ) { <S2SV_EndBug> ,<S2SV_ModStart> l < 10 || l > 20 ) return - 1 ; if ( 
1071,<S2SV_StartBug> if ( cluster != fs -> clusters - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> 
1072,<S2SV_StartBug> GHashTableIter iter ; <S2SV_EndBug> ,"<S2SV_ModStart> value = get_map_string_item_or_NULL ( settings , ""PrivateReports"" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , ""PrivateReports"" ) ; } "
1073,<S2SV_StartBug> if ( split_flag ) { <S2SV_EndBug> ,<S2SV_ModStart> && size >= MIN_BLOCK_SIZE 
1074,"<S2SV_StartBug> int size ; <S2SV_EndBug> <S2SV_StartBug> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <S2SV_EndBug> ","<S2SV_ModStart> ; int base_size <S2SV_ModStart> base_size = sizeof ( path -> <S2SV_ModEnd> <S2SV_ModStart> * npts ; size = offsetof ( PATH , <S2SV_ModEnd> <S2SV_ModStart> + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> "
1075,<S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> ,<S2SV_ModStart> && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) 
1076,"<S2SV_StartBug> if ( optstr ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> ( ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> ""mincolors<S2SV_blank>%d\\n"" , info -> len , info -> width , info -> height , info -> numplanes , <S2SV_EndBug> <S2SV_StartBug> info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , <S2SV_EndBug> <S2SV_StartBug> info -> numcolors , info -> mincolors ) ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> <S2SV_StartBug> jas_image_destroy ( image ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> bmp_info_destroy ( info ) ; <S2SV_EndBug> ","<S2SV_ModStart> image = 0 ; info = 0 ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> ""BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>"" ""depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>"" ""mincolors<S2SV_blank>%ld\\n"" , JAS_CAST ( long <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) , JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) , JAS_CAST ( long <S2SV_ModStart> ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( ""corrupt<S2SV_blank>bit<S2SV_blank>stream\\n"" ) ; goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error ; } <S2SV_ModStart> return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> "
1077,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } "
1078,<S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES 
1079,<S2SV_StartBug> if ( tag == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( len <= 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( n > sizeof ( size_t ) - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> for ( len = 0 ; n > 0 ; n -- ) { <S2SV_EndBug> <S2SV_StartBug> dp += len ; <S2SV_EndBug> ,<S2SV_ModStart> ASN1_EOC <S2SV_ModEnd> <S2SV_ModStart> goto check_length ; <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> len = 0 ; for ( <S2SV_ModEnd> <S2SV_ModStart> check_length : if ( len > datalen - dp ) goto data_overrun_error ; 
1080,"<S2SV_StartBug> rinfo = kmalloc ( SZ_SG_REQ_INFO * SG_MAX_QUEUE , <S2SV_EndBug> ",<S2SV_ModStart> kzalloc <S2SV_ModEnd> 
1081,<S2SV_StartBug> if ( ! is_launcher ) <S2SV_EndBug> <S2SV_StartBug> if ( nautilus_file_can_execute ( file ) ) <S2SV_EndBug> ,"<S2SV_ModStart> g_autofree gchar * trusted = NULL ; <S2SV_ModStart> trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; <S2SV_ModStart> && trusted != NULL "
1082,<S2SV_StartBug> commonlen = COMPUTESIZE ( state . num ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ; "
1083,"<S2SV_StartBug> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <S2SV_EndBug> ","<S2SV_ModStart> fc -> uid , "
1084,"<S2SV_StartBug> void vp9_idct16x16_add ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> <S2SV_StartBug> vp9_idct16x16_1_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct16x16_10_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_idct16x16_256_add ( input , dest , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_idct16x16_1_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct16x16_10_add <S2SV_ModEnd> <S2SV_ModStart> vpx_idct16x16_256_add <S2SV_ModEnd> 
1085,"<S2SV_StartBug> uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> # define MUS_SZ 4 <S2SV_ModStart> MUS_SZ <S2SV_ModStart> , MUS_SZ "
1086,<S2SV_StartBug> gdImagePtr im ; <S2SV_EndBug> ,"<S2SV_ModStart> check_file ( ""heap_overflow_1.tga"" ) ; check_file ( ""heap_overflow_2.tga"" <S2SV_ModEnd> "
1087,"<S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , ""Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> <S2SV_ModStart> ""reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> "
1088,"<S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ","<S2SV_ModStart> netdissect_options * ndo , <S2SV_ModStart> if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; } "
1089,"<S2SV_StartBug> queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ; <S2SV_EndBug> <S2SV_StartBug> queue_foreach ( att -> disconn_list , disconn_handler , INT_TO_PTR ( err ) ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> att -> in_disc = true ; queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> ind_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> write_queue , NULL , NULL , disc_att_send_op ) ; att -> in_disc = false ; "
1090,"<S2SV_StartBug> int segment_id , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) { <S2SV_EndBug> <S2SV_StartBug> const int skip = vp9_read ( r , cm -> fc . skip_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ",<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> segfeature_active <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> 
1091,"<S2SV_StartBug> return xfrm6_rcv_spi ( skb , spi ) ; <S2SV_EndBug> ",<S2SV_ModStart> > 0 ? : 0 
1092,<S2SV_StartBug> OPJ_UNUSED ( p_manager ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1093,<S2SV_StartBug> size_t mask = ( size_t ) self -> mt_mask ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1094,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * tptr , 1 ) ) <S2SV_EndBug> ",<S2SV_ModStart> 2 <S2SV_ModEnd> 
1095,<S2SV_StartBug> ops -> destroy ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
1096,"<S2SV_StartBug> char * pin , * pout ; <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; if ( ( in_len < 0 ) || ( ( uint32 ) in_len >= ( RD_UINT32_MAX / 2 ) ) ) { logger ( Protocol , Error , ""rdp_in_unistr(),<S2SV_blank>length<S2SV_blank>of<S2SV_blank>unicode<S2SV_blank>data<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds."" ) ; abort ( ) ; } if ( ! s_check_rem ( s , in_len ) ) { rdp_protocol_error ( ""rdp_in_unistr(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>unicode<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
1097,<S2SV_StartBug> { size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> SF_MIN ( <S2SV_ModStart> , layout_tag & 0xffff ) "
1098,"<S2SV_StartBug> } else if ( ! strncmp ( network_line , ""GET_DN<S2SV_blank>"" , strlen ( ""GET_DN<S2SV_blank>"" ) ) && msg_id != UINT32_MAX && network_client_get_version ( fd ) > 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> version > PROTOCOL_UNKNOWN && version < PROTOCOL_3 <S2SV_ModEnd> 
1099,<S2SV_StartBug> vp9_ppflags_t flags = { 0 } ; <S2SV_EndBug> ,<S2SV_ModStart> ; vp9_zero ( flags ) <S2SV_ModEnd> 
1100,<S2SV_StartBug> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) <S2SV_EndBug> ,<S2SV_ModStart> ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco ) 
1101,<S2SV_StartBug> # ifdef CONFIG_FUTEX <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( tsk -> robust_list ) ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif <S2SV_ModStart>  <S2SV_ModEnd> "
1102,"<S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> ","<S2SV_ModStart> struct stream packet = * s ; <S2SV_ModStart> ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } if ( "
1103,<S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> ,<S2SV_ModStart> mp -> timer_armed && 
1104,<S2SV_StartBug> assert ( status != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( status == NULL ) status = ""UNKNOWN_REASON"" <S2SV_ModEnd> "
1105,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n"" , gso -> u . gso . type ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif 
1106,"<S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> int error = 0 ; <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""refcount<S2SV_blank>now=0;<S2SV_blank>freeing"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_ModStart> mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1107,"<S2SV_StartBug> ( sctp_paramhdr_t * ) addip_hdr -> params , <S2SV_EndBug> ","<S2SV_ModStart> asconf_ack , false , <S2SV_ModEnd> "
1108,<S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> ,<S2SV_ModStart> VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ; 
1109,"<S2SV_StartBug> ip_printroute ( ndo , cp , option_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModStart> == - 1 ) goto trunc 
1110,"<S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( buf2 ) <S2SV_ModStart> , sizeof ( buf2 ) "
1111,<S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; } 
1112,<S2SV_StartBug> char * tmpptr = key + strlen ( key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1113,<S2SV_StartBug> atomic_inc ( & sb -> s_active ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; 
1114,<S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1115,"<S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> encode_txfm_probs ( cm , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> update_skip_probs ( cm , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> prob_diff_update ( vp9_inter_mode_tree , cm -> fc . inter_mode_probs [ i ] , <S2SV_EndBug> <S2SV_StartBug> cm -> counts . inter_mode [ i ] , INTER_MODES , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> update_switchable_interp_probs ( cm , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . intra_inter [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> allow_comp_inter_inter ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( & header_bc , use_compound_pred ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_bit ( & header_bc , use_hybrid_pred ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . comp_inter [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . single_ref [ i ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . single_ref [ i ] [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . comp_ref [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> prob_diff_update ( vp9_intra_mode_tree , cm -> fc . y_mode_prob [ i ] , <S2SV_EndBug> <S2SV_StartBug> cm -> counts . y_mode [ i ] , INTRA_MODES , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> cm -> counts . partition [ i ] , PARTITION_TYPES , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_nmv_probs ( cm , cm -> allow_high_precision_mv , & header_bc ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_stop_encode ( & header_bc ) ; <S2SV_EndBug> ","<S2SV_ModStart> td . <S2SV_ModStart> cm -> fc ; FRAME_COUNTS * counts = cpi -> td . counts ; vpx_writer header_bc ; vpx_start_encode <S2SV_ModEnd> <S2SV_ModStart> , counts <S2SV_ModStart> , counts <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , counts <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_write_bit <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> counts -> <S2SV_ModEnd> <S2SV_ModStart> , & counts -> mv <S2SV_ModStart> vpx_stop_encode <S2SV_ModEnd> "
1116,"<S2SV_StartBug> if ( packet -> payload_packet_len >= 40 ) { <S2SV_EndBug> <S2SV_StartBug> ovpn_payload += 2 ; <S2SV_EndBug> <S2SV_StartBug> htons ( packet -> udp -> source ) , htons ( packet -> udp -> dest ) , packet -> payload_packet_len ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( packet -> payload_packet_len == 112 ) <S2SV_EndBug> <S2SV_StartBug> || ( ( packet -> payload_packet_len == 80 ) <S2SV_EndBug> <S2SV_StartBug> alen = ovpn_payload [ P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ] ; <S2SV_EndBug> <S2SV_StartBug> session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) + 1 + alen * 4 ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( flow -> ovpn_session_id , session_remote , 8 ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int16_t ovpn_payload_len = <S2SV_ModEnd> <S2SV_ModStart> ; if ( ovpn_payload_len <S2SV_ModStart> , ovpn_payload_len -= 2 ; <S2SV_ModStart> ovpn_payload_len <S2SV_ModEnd> <S2SV_ModStart> ovpn_payload_len <S2SV_ModEnd> <S2SV_ModStart> ovpn_payload_len <S2SV_ModEnd> <S2SV_ModStart> u_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ; <S2SV_ModStart> offset <S2SV_ModEnd> <S2SV_ModStart> offset += <S2SV_ModEnd> <S2SV_ModStart> ( offset + 8 ) <= ovpn_payload_len ) { session_remote = & ovpn_payload [ offset ] ; if ( <S2SV_ModStart> } else failed = 1 ; "
1117,<S2SV_StartBug> case 0x2f8 : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1118,<S2SV_StartBug> return TRUE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ; 
1119,<S2SV_StartBug> if ( ( data & ~ mask ) != PSW_USER_BITS ) <S2SV_EndBug> ,<S2SV_ModStart> ^ PSW_USER_BITS ) <S2SV_ModStart> return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> 
1120,"<S2SV_StartBug> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> boost_score = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> int projected_buffer_level = ( int ) cpi -> buffer_level ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1121,"<S2SV_StartBug> const uint8_t * end , * ptr = avpkt -> data ; <S2SV_EndBug> <S2SV_StartBug> end = avpkt -> data + avpkt -> size ; <S2SV_EndBug> <S2SV_StartBug> while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 ) <S2SV_EndBug> <S2SV_StartBug> size *= 94 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ncolors ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < avctx -> width ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> <S2SV_ModStart> end - ptr > 9 && <S2SV_ModStart> ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> <S2SV_ModStart> 95 <S2SV_ModEnd> <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> end - ptr < cpp <S2SV_ModEnd> <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> end - ptr < cpp <S2SV_ModEnd> "
1122,"<S2SV_StartBug> struct in6_addr * addr , uint32_t * ifindex ) <S2SV_EndBug> <S2SV_StartBug> unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 && <S2SV_EndBug> <S2SV_StartBug> cmsghdr -> cmsg_type == IPV6_PKTINFO && <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , int * hoplimit <S2SV_ModStart> 2 * <S2SV_ModStart> != IPPROTO_IPV6 ) continue ; switch ( <S2SV_ModEnd> <S2SV_ModStart> ) { case IPV6_PKTINFO : if ( <S2SV_ModEnd> <S2SV_ModStart> break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; } "
1123,"<S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> ",<S2SV_ModStart> { clear_tfile_check_list ( ) ; <S2SV_ModStart> } 
1124,"<S2SV_StartBug> dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> ","<S2SV_ModStart> ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> "
1125,"<S2SV_StartBug> mlx4_dbg ( dev , ""Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n"" , free ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( free < 0 ) { err = - ENOMEM ; goto out ; } 
1126,"<S2SV_StartBug> unsigned facility ; <S2SV_EndBug> <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> <S2SV_StartBug> while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndDRS:f:p:i:mM::g::Gt::"" <S2SV_EndBug> <S2SV_StartBug> case 't' : <S2SV_EndBug> ","<S2SV_ModStart> ; mode_t new_umask_val <S2SV_ModStart> { ""umask"" , required_argument , NULL , 'u' } , <S2SV_ModStart> "":vhlndu:DRS:f:p:i:mM::g::Gt::"" <S2SV_ModEnd> <S2SV_ModStart> 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case "
1127,"<S2SV_StartBug> strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
1128,"<S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> ","<S2SV_ModStart> _gdImageWBMPCtx <S2SV_ModEnd> <S2SV_ModStart> fg , out <S2SV_ModEnd> "
1129,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> int_mv arf_top_mv , gld_top_mv ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO mi_local = { { 0 } } ; <S2SV_EndBug> <S2SV_StartBug> int_mv arf_left_mv , gld_left_mv ; <S2SV_EndBug> <S2SV_StartBug> int gld_y_in_offset = gld_y_offset ; <S2SV_EndBug> <S2SV_StartBug> arf_left_mv . as_int = mb_stats -> ref [ ALTREF_FRAME ] . m . mv . as_int ; <S2SV_EndBug> ","<S2SV_ModStart> td . <S2SV_ModStart> MV gld_top_mv = { 0 , 0 } <S2SV_ModEnd> <S2SV_ModStart> ; vp9_zero ( mi_local ) <S2SV_ModEnd> <S2SV_ModStart> MV gld_left_mv = gld_top_mv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> gld_left_mv <S2SV_ModEnd> <S2SV_ModStart> GOLDEN_FRAME <S2SV_ModEnd> <S2SV_ModStart> as_mv ; if ( mb_col == 0 ) { gld_top_mv = gld_left_mv <S2SV_ModEnd> "
1130,"<S2SV_StartBug> dfa * d1 = PyGrammar_FindDFA ( <S2SV_EndBug> <S2SV_StartBug> D ( printf ( ""<S2SV_blank>Push<S2SV_blank>...\\n"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; if ( nt == func_body_suite && ! ( ps -> p_flags & PyCF_TYPE_COMMENTS ) ) { D ( printf ( ""<S2SV_blank>[switch<S2SV_blank>func_body_suite<S2SV_blank>to<S2SV_blank>suite]"" ) ) ; nt = suite ; } d1 <S2SV_ModStart> ""<S2SV_blank>Push<S2SV_blank>\'%s\'\\n"" , d1 -> d_name <S2SV_ModEnd> "
1131,"<S2SV_StartBug> char buffer [ 64 ] = { '\\0' } , rdnSeqBuf [ 1024 ] = { '\\0' } ; <S2SV_EndBug> ",<S2SV_ModStart> 2048 <S2SV_ModEnd> 
1132,"<S2SV_StartBug> if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) { <S2SV_EndBug> ",<S2SV_ModStart> || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> 
1133,"<S2SV_StartBug> if ( jp2_getuint16 ( in , & pclr -> numlutents ) || <S2SV_EndBug> ",<S2SV_ModStart> pclr -> bpc = 0 ; 
1134,"<S2SV_StartBug> FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double * this_frame_mv_in_out , <S2SV_EndBug> <S2SV_StartBug> double motion_pct ; <S2SV_EndBug> <S2SV_StartBug> * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ; <S2SV_EndBug> <S2SV_StartBug> * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ; <S2SV_EndBug> <S2SV_StartBug> * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ; <S2SV_EndBug> <S2SV_StartBug> if ( motion_pct > 0.05 ) { <S2SV_EndBug> <S2SV_StartBug> const double this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ; <S2SV_EndBug> <S2SV_StartBug> const double this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ; <S2SV_EndBug> <S2SV_StartBug> * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs ) <S2SV_EndBug> <S2SV_StartBug> ? ( this_frame_mvr_ratio * motion_pct ) <S2SV_EndBug> <S2SV_StartBug> * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) <S2SV_EndBug> <S2SV_StartBug> ? ( this_frame_mvc_ratio * motion_pct ) <S2SV_EndBug> ",<S2SV_ModStart> const FIRSTPASS_STATS * stats <S2SV_ModEnd> <S2SV_ModStart> mv_in_out <S2SV_ModEnd> <S2SV_ModStart> const double pct = stats <S2SV_ModEnd> <S2SV_ModStart> mv_in_out = stats <S2SV_ModEnd> <S2SV_ModStart> pct <S2SV_ModEnd> <S2SV_ModStart> * mv_in_out <S2SV_ModEnd> <S2SV_ModStart> * mv_in_out <S2SV_ModEnd> <S2SV_ModStart> pct <S2SV_ModEnd> <S2SV_ModStart> mvr_ratio <S2SV_ModEnd> <S2SV_ModStart> stats <S2SV_ModEnd> <S2SV_ModStart> stats <S2SV_ModEnd> <S2SV_ModStart> mvc_ratio <S2SV_ModEnd> <S2SV_ModStart> stats <S2SV_ModEnd> <S2SV_ModStart> stats <S2SV_ModEnd> <S2SV_ModStart> pct * ( mvr_ratio < stats -> mvr_abs ? mvr_ratio : stats <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pct * ( mvc_ratio < stats -> mvc_abs ? mvc_ratio : stats <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1135,<S2SV_StartBug> ( ( flags & O_ACCMODE ) == O_WRONLY || <S2SV_EndBug> <S2SV_StartBug> ( flags & O_ACCMODE ) == O_RDWR ) ) { <S2SV_EndBug> ,<S2SV_ModStart> != O_RDONLY <S2SV_ModEnd> <S2SV_ModStart> ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> 
1136,"<S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> ","<S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> <S2SV_ModStart> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> "
1137,"<S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\n"" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <S2SV_ModStart>  <S2SV_ModEnd> "
1138,<S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ; "
1139,"<S2SV_StartBug> static char buf [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , ""%s%s"" , <S2SV_EndBug> <S2SV_StartBug> sepstr , lp -> s ) ; <S2SV_EndBug> <S2SV_StartBug> if ( buflen == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size <S2SV_ModEnd> <S2SV_ModStart> if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp <S2SV_ModEnd> <S2SV_ModStart> , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size <S2SV_ModEnd> <S2SV_ModStart> bufp == buf <S2SV_ModEnd> "
1140,"<S2SV_StartBug> cpi -> framerate = ( double ) ( oxcf -> timebase . den ) / <S2SV_EndBug> <S2SV_StartBug> ( double ) ( oxcf -> timebase . num ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_change_config ( cpi , oxcf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( oxcf -> timebase . num > 0 ) { <S2SV_ModStart> } else { cpi -> framerate = 30 ; } <S2SV_ModStart> cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1 ; 
1141,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
1142,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; 
1143,"<S2SV_StartBug> static void rd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int * totalrate , int64_t * totaldist , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> double rdmult_ratio ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> x -> skip_recode = 0 ; <S2SV_EndBug> <S2SV_StartBug> x -> source_variance = get_sby_perpixel_variance ( cpi , x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> rdmult_ratio = vp9_vaq_rdmult_ratio ( energy ) ; <S2SV_EndBug> <S2SV_StartBug> orig_rdmult = x -> rdmult ; <S2SV_EndBug> <S2SV_StartBug> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult += ( ( x -> rdmult * ( complexity - 128 ) ) / 256 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ) <S2SV_EndBug> <S2SV_StartBug> vp9_rd_pick_intra_mode_sb ( cpi , x , totalrate , totaldist , bsize , ctx , <S2SV_EndBug> <S2SV_StartBug> if ( bsize >= BLOCK_8X8 ) <S2SV_EndBug> <S2SV_StartBug> vp9_rd_pick_inter_mode_sb ( cpi , x , tile , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> totalrate , totaldist , bsize , ctx , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> vp9_rd_pick_inter_mode_sub8x8 ( cpi , x , tile , mi_row , mi_col , totalrate , <S2SV_EndBug> <S2SV_StartBug> if ( aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> <S2SV_StartBug> if ( * totalrate != INT_MAX ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( aq_mode == COMPLEXITY_AQ || aq_mode == CYCLIC_REFRESH_AQ ) { <S2SV_EndBug> ","<S2SV_ModStart> TileDataEnc * tile_data , MACROBLOCK * const x <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost <S2SV_ModEnd> <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state ( ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tile_info , x <S2SV_ModEnd> <S2SV_ModStart> ctx -> skippable = 0 ; ctx -> pred_pixel_ready = 0 ; <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> vp9_high_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize , xd -> bd ) ; } else { x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; } # else x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; # endif orig_rdmult = x -> rdmult <S2SV_ModEnd> <S2SV_ModStart> get_segment_id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> <S2SV_ModStart> cyclic_refresh_segment_id_boosted ( get_segment_id <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> rd_cost , bsize , ctx , <S2SV_ModEnd> <S2SV_ModStart> { if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) vp9_rd_pick_inter_mode_sb_seg_skip ( cpi , tile_data , x , rd_cost , bsize , ctx , best_rd ) ; else <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> rd_cost <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> rd_cost <S2SV_ModEnd> <S2SV_ModStart> } if ( ( rd_cost -> rate <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> ) && ( bsize >= BLOCK_16X16 ) && ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) ) { vp9_caq_select_segment ( cpi , x , bsize , mi_row , mi_col , rd_cost -> rate ) ; } x -> rdmult = orig_rdmult ; if ( rd_cost -> rate == INT_MAX ) rd_cost -> rdcost = INT64_MAX ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist ; <S2SV_ModEnd> "
1144,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( s == 0 ) return ( ( void * ) NULL ) ; 
1145,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = - EIO ; goto out <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
1146,"<S2SV_StartBug> gboolean use_box_blur ; <S2SV_EndBug> <S2SV_StartBug> sy = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> if ( use_box_blur ) { <S2SV_EndBug> <S2SV_StartBug> col_buffer = g_new0 ( guchar , height * bpp * 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> gboolean use_box_blur ; if ( sx < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ; <S2SV_ModStart> gboolean use_box_blur ; if ( sy < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ; 
1147,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> "
1148,"<S2SV_StartBug> if ( ssl_derive ( s , ckey , skey ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( "
1149,"<S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , struct rt6_info * rt <S2SV_ModStart> , rt "
1150,"<S2SV_StartBug> static int ion_handle_put ( struct ion_handle * handle ) <S2SV_EndBug> <S2SV_StartBug> ret = kref_put ( & handle -> ref , ion_handle_destroy ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ion_handle_put_nolock ( handle <S2SV_ModEnd> 
1151,"<S2SV_StartBug> WORD32 pu_skip_wd , pu_skip_ht ; <S2SV_EndBug> <S2SV_StartBug> ps_codec -> s_parse . i4_pic_pu_idx = i4_pic_pu_idx ; <S2SV_EndBug> <S2SV_StartBug> ps_codec -> s_parse . ps_tu ++ ; <S2SV_EndBug> <S2SV_StartBug> tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; <S2SV_EndBug> ",<S2SV_ModStart> tu_coeff_data_reset_size ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ihevcd_set_ctb_skip ( ps_codec ) <S2SV_ModEnd> <S2SV_ModStart> ihevcd_set_ctb_skip ( ps_codec ) <S2SV_ModEnd> 
1152,<S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> <S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> ,<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1153,"<S2SV_StartBug> int nmi , struct perf_sample_data * data , <S2SV_EndBug> <S2SV_StartBug> return perf_swevent_overflow ( event , 1 , nmi , data , regs ) ; <S2SV_EndBug> <S2SV_StartBug> perf_swevent_overflow ( event , 0 , nmi , data , regs ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1154,<S2SV_StartBug> return PTR_ERR ( tty ) ; <S2SV_EndBug> ,<S2SV_ModStart> tty_driver_kref_put ( driver ) ; 
1155,<S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m1 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m2 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> <S2SV_ModStart> { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> 
1156,<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> len = ( int ) ( cp - ( ip_as_string + 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len > ( int ) sizeof ( buf ) - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1157,"<S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , ""<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> <S2SV_ModStart> , sizeof line <S2SV_ModStart> ( sizeof <S2SV_ModEnd> <S2SV_ModStart> '\\0' ; line [ strlen ( line ) - 1 ] = "
1158,<S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1159,<S2SV_StartBug> tread . event = SNDRV_TIMER_EVENT_EARLY ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & tread , 0 , sizeof ( tread ) ) ; "
1160,"<S2SV_StartBug> j = cJSON_CreateInt ( va_arg ( argp , int64_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> j = cJSON_CreateFloat ( va_arg ( argp , double ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> cJSON_CreateNumber <S2SV_ModEnd> <S2SV_ModStart> cJSON_CreateNumber <S2SV_ModEnd> 
1161,"<S2SV_StartBug> void options_free ( ) { <S2SV_EndBug> <S2SV_StartBug> parse_global_option ( CMD_FREE , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int current ) { GLOBAL_OPTIONS * global = current ? & global_options : & new_global_options ; SERVICE_OPTIONS * service = current ? & service_options : & new_service_options ; <S2SV_ModEnd> <S2SV_ModStart> , global <S2SV_ModStart> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; while ( service ) { SERVICE_OPTIONS * tmp = service ; service = service -> next ; tmp -> next = NULL ; service_free ( tmp ) ; } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; "
1162,"<S2SV_StartBug> ast_for_call ( struct compiling * c , const node * n , expr_ty func ) <S2SV_EndBug> <S2SV_StartBug> int i , nargs , nkeywords , ngens ; <S2SV_EndBug> <S2SV_StartBug> ngens = 0 ; <S2SV_EndBug> <S2SV_StartBug> ngens ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> , bool allowgen <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { nargs ++ ; if ( ! allowgen ) { ast_error ( c , ch , ""invalid<S2SV_blank>syntax"" ) ; return NULL ; } if ( NCH ( n ) > 1 ) { ast_error ( c , ch , ""Generator<S2SV_blank>expression<S2SV_blank>must<S2SV_blank>be<S2SV_blank>parenthesized"" ) ; return NULL ; } } <S2SV_ModEnd> <S2SV_ModStart> args = _Ta3_asdl_seq_new ( nargs <S2SV_ModEnd> "
1163,<S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> ,<S2SV_ModStart> ( ( <S2SV_ModStart> ) && ( kk < input -> length ) ) 
1164,"<S2SV_StartBug> char combname [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
1165,<S2SV_StartBug> idata -> state = IMAP_AUTHENTICATED ; <S2SV_EndBug> ,"<S2SV_ModStart> # if defined ( USE_SSL ) if ( ! idata -> conn -> ssf ) { if ( option ( OPTSSLFORCETLS ) || ( query_quadoption ( OPT_SSLSTARTTLS , _ ( ""Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?"" ) ) != MUTT_NO ) ) { mutt_error _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } } # endif "
1166,"<S2SV_StartBug> return sprintf ( buf , ""%s\\n"" , pdev -> driver_override ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ssize_t len ; device_lock ( dev ) ; len = <S2SV_ModEnd> <S2SV_ModStart> device_unlock ( dev ) ; return len ; 
1167,<S2SV_StartBug> cJSON * ref ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ref = cJSON_New_Item ( ) ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! ref ) <S2SV_ModEnd> 
1168,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart> KERN_ERR , "
1169,"<S2SV_StartBug> fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( fc . messages == NULL ) return - 1 
1170,<S2SV_StartBug> block_in_file = ( sector_t ) page -> index ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PageUptodate ( page ) && ! cleancache_get_page ( page ) ) { <S2SV_EndBug> ,<S2SV_ModStart> page_index ( page ) <S2SV_ModEnd> <S2SV_ModStart> ( ! PageSwapCache ( page ) && <S2SV_ModStart> ) 
1171,"<S2SV_StartBug> vpx_memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
1172,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1173,"<S2SV_StartBug> if ( ( opt_len != mp_dss_len ( mdss , 1 ) && <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_A ) { <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_a ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( mdss -> flags & MP_DSS_m ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_16BITS ( opt ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt_len == mp_dss_len ( mdss , 1 ) ) <S2SV_EndBug> ","<S2SV_ModStart> opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> <S2SV_ModStart> opt_len -= 4 ; <S2SV_ModStart> if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt_len -= 8 ; <S2SV_ModStart> if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> opt_len -= 4 ; <S2SV_ModStart> if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> opt_len -= 8 ; <S2SV_ModStart> if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> <S2SV_ModStart> opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>csum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> "
1174,"<S2SV_StartBug> int hours , minutes , seconds ; <S2SV_EndBug> ",<S2SV_ModStart> int64_t <S2SV_ModEnd> 
1175,"<S2SV_StartBug> ( void ) & line ; <S2SV_EndBug> <S2SV_StartBug> if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len ) <S2SV_EndBug> <S2SV_StartBug> CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> ss <S2SV_ModEnd> <S2SV_ModStart> ss <S2SV_ModEnd> <S2SV_ModStart> ss <S2SV_ModEnd> 
1176,<S2SV_StartBug> void fdct4_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> ,<S2SV_ModStart> static <S2SV_ModStart> ( int16_t ) 
1177,<S2SV_StartBug> sbinfo -> max_blocks = config . nr_blocks ; <S2SV_EndBug> <S2SV_StartBug> sbinfo -> free_blocks = config . nr_blocks ; <S2SV_EndBug> <S2SV_StartBug> if ( ! inode ) <S2SV_EndBug> <S2SV_StartBug> root = d_alloc_root ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> kfree ( sbinfo ) ; <S2SV_EndBug> ,"<S2SV_ModStart> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sbinfo -> spool = NULL ; if ( <S2SV_ModEnd> <S2SV_ModStart> != - 1 ) { sbinfo -> spool = hugepage_new_subpool ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sbinfo -> spool <S2SV_ModEnd> <S2SV_ModStart> } sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ; if ( ! inode ) goto out_free ; <S2SV_ModStart> if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ; "
1178,"
","
"
1179,"<S2SV_StartBug> status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_LINKIF ) ; <S2SV_EndBug> <S2SV_StartBug> value = enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) ; <S2SV_EndBug> <S2SV_StartBug> value = enc624j600ReadPhyReg ( interface , ENC624J600_PHY_REG_PHSTAT3 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( value & PHSTAT3_SPDDPX2 ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_PKTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE | EIE_PKTIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC624J600_EIR ) ; if ( ( status & ENC624J600_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR , ENC624J600_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_ESTAT ) ; if ( ( value & ENC624J600_ESTAT_PHYLNK <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_PHSTAT3 ) ; if ( ( value & ENC624J600_PHSTAT3_SPDDPX1 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_PHSTAT3_SPDDPX2 <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR_PKTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIR , ENC624J600_EIR_PKTIF <S2SV_ModEnd> <S2SV_ModStart> ENC624J600_EIE , ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE <S2SV_ModEnd> "
1180,<S2SV_StartBug> if ( ! esil ) <S2SV_EndBug> ,<S2SV_ModStart> { return ; } <S2SV_ModEnd> 
1181,"<S2SV_StartBug> int a = getnum ( L , fmt , MAXALIGN ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1182,<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> len = ( int ) ( cp - ( ip_as_string + 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len > ( int ) sizeof ( buf ) - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1183,<S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) ) "
1184,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> break ; default : fastd_buffer_free ( buffer ) ; pr_debug ( ""received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>%P[%I]"" , peer , remote_addr ) ; "
1185,"<S2SV_StartBug> assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
1186,<S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 4 ) { return ; } 
1187,<S2SV_StartBug> struct inet_sock * inet = inet_sk ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> srr ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> "
1188,<S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cifs_small_buf_release ( req ) ; 
1189,"<S2SV_StartBug> sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( name > 1024 ) { <S2SV_ModStart> else { eprintf ( ""Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\n"" , name ) ; } } "
1190,"<S2SV_StartBug> char lbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char ltest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strtest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strbase ) ; <S2SV_EndBug> <S2SV_StartBug> int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( nbase != 255 && ntest != 255 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> 512 <S2SV_ModEnd> <S2SV_ModStart> ""%511[^\\r\\n]"" <S2SV_ModEnd> <S2SV_ModStart> ""%511[^\\r\\n]"" <S2SV_ModEnd> <S2SV_ModStart> 511 <S2SV_ModEnd> <S2SV_ModStart> 511 <S2SV_ModEnd> "
1191,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , <S2SV_EndBug> ",<S2SV_ModStart> msg -> msg_namelen = 0 ; 
1192,<S2SV_StartBug> if ( ( data & ~ mask ) != PSW_USER_BITS ) <S2SV_EndBug> ,<S2SV_ModStart> ^ PSW_USER_BITS ) <S2SV_ModStart> return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> 
1193,<S2SV_StartBug> struct net_device * dev = vif -> dev ; <S2SV_EndBug> <S2SV_StartBug> if ( netif_carrier_ok ( dev ) ) { <S2SV_EndBug> <S2SV_StartBug> xenvif_down ( vif ) ; <S2SV_EndBug> <S2SV_StartBug> rtnl_unlock ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vif -> <S2SV_ModEnd> <S2SV_ModStart> xenvif_carrier_off <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1194,<S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> ; xen_cpu_init_eoi ( cpu ) 
1195,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> abort ( ) <S2SV_ModEnd> 
1196,<S2SV_StartBug> struct IGDdatas * datas = ( struct IGDdatas * ) d ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1 
1197,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc16"" , ""%s"" , ""cc%(2*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
1198,<S2SV_StartBug> if ( filter [ i ] . jf ) <S2SV_EndBug> <S2SV_StartBug> t_offset += is_near ( f_offset ) ? 2 : 6 ; <S2SV_EndBug> ,<S2SV_ModStart> && f_offset <S2SV_ModStart> 5 <S2SV_ModEnd> 
1199,<S2SV_StartBug> int err = - EIO ; <S2SV_EndBug> <S2SV_StartBug> uint32_t pos ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bh ) <S2SV_EndBug> <S2SV_StartBug> out : <S2SV_EndBug> <S2SV_StartBug> kunmap ( page ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> <S2SV_ModStart> out_unlock_inode <S2SV_ModEnd> <S2SV_ModStart> out_unmap : 
1200,<S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> io -> io_cleanup = port_cleanup ; 
1201,"<S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ss = <S2SV_ModEnd> <S2SV_ModStart> ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n"" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> pos <S2SV_ModEnd> "
1202,"<S2SV_StartBug> if ( ! io_end || ! size ) <S2SV_EndBug> <S2SV_StartBug> wq = EXT4_SB ( io_end -> inode -> i_sb ) -> dio_unwritten_wq ; <S2SV_EndBug> <S2SV_StartBug> list_add_tail ( & io_end -> list , <S2SV_EndBug> <S2SV_StartBug> & EXT4_I ( io_end -> inode ) -> i_completed_io_list ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned long flags ; struct ext4_inode_info * ei ; <S2SV_ModStart> io_end -> flag = EXT4_IO_UNWRITTEN ; <S2SV_ModStart> ei = EXT4_I ( io_end -> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> & ei -> i_completed_io_list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags <S2SV_ModEnd> "
1203,"<S2SV_StartBug> err = aead_register_instance ( tmpl , inst ) ; <S2SV_EndBug> ",<S2SV_ModStart> inst -> free = pcrypt_free ; 
1204,"<S2SV_StartBug> if ( srp -> bio ) <S2SV_EndBug> <S2SV_StartBug> blk_end_request_all ( srp -> rq , - EIO ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ; <S2SV_ModStart> srp -> rq = NULL ; } 
1205,<S2SV_StartBug> if ( ! rc && cifs_sb -> prepathlen && tcon ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1206,"<S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> != c ) break 
1207,"<S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> <S2SV_StartBug> return retval ; <S2SV_EndBug> ",<S2SV_ModStart> | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; } 
1208,"<S2SV_StartBug> static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> <S2SV_StartBug> FillMemory ( out , len , value ) ; <S2SV_EndBug> <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> ","<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> , UINT32 outSize <S2SV_ModStart> if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> "
1209,"<S2SV_StartBug> static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , <S2SV_EndBug> <S2SV_StartBug> size_t bit ; ssize_t x ; <S2SV_EndBug> <S2SV_StartBug> register Quantum * q ; <S2SV_EndBug> <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) SyncAuthenticPixels ( image , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; <S2SV_EndBug> <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , * p , exception ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickBooleanType <S2SV_ModEnd> <S2SV_ModStart> bpp <S2SV_ModEnd> <S2SV_ModStart> int bit ; Quantum index <S2SV_ModEnd> <S2SV_ModStart> * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> <S2SV_ModStart> bpp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ssize_t ) ( <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ) & 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0x0f <S2SV_ModEnd> <S2SV_ModStart> if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart> for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> <S2SV_ModStart> ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> <S2SV_ModStart> SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> <S2SV_ModStart> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> <S2SV_ModStart> ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> "
1210,"<S2SV_StartBug> rc = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) <S2SV_EndBug> <S2SV_StartBug> ipxitf_put ( ipxif ) ; <S2SV_EndBug> ","<S2SV_ModStart> 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1211,<S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> < <S2SV_ModEnd> 
1212,<S2SV_StartBug> struct dentry * upper = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> err = - ESTALE ; <S2SV_EndBug> <S2SV_StartBug> if ( upper -> d_parent == upperdir ) { <S2SV_EndBug> <S2SV_StartBug> dput ( upper ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> inode_unlock ( dir ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dput ( upper ) ; <S2SV_ModStart> out_unlock : "
1213,<S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug> ,<S2SV_ModStart> d -> log_file = eventfp ; 
1214,"<S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug> ","<S2SV_ModStart> int slen , <S2SV_ModStart> int dlen <S2SV_ModEnd> <S2SV_ModStart> slen <S2SV_ModEnd> <S2SV_ModStart> dlen , "
1215,<S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug> ,"<S2SV_ModStart> copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> "
1216,<S2SV_StartBug> unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ; <S2SV_EndBug> <S2SV_StartBug> pos += skb_headlen ( list_skb ) ; <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( ! nfrags ) ; <S2SV_EndBug> <S2SV_StartBug> * nskb_frag = * frag ; <S2SV_EndBug> ,"<S2SV_ModStart> ; struct sk_buff * frag_skb = head_skb <S2SV_ModStart> frag_skb = list_skb ; <S2SV_ModStart> frag_skb = list_skb ; <S2SV_ModStart> if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ; "
1217,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
1218,<S2SV_StartBug> if ( new_fs ) { <S2SV_EndBug> ,<S2SV_ModStart> new_ns -> mounts ++ ; 
1219,<S2SV_StartBug> gdFree ( tmp_im ) ; <S2SV_EndBug> ,<S2SV_ModStart> gdImageDestroy <S2SV_ModEnd> 
1220,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
1221,<S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> <S2SV_StartBug> ! ( opt_len == 24 && flags & TH_ACK ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) <S2SV_ModStart> ( <S2SV_ModStart> ) 
1222,"<S2SV_StartBug> ngx_int_t rc ; <S2SV_EndBug> <S2SV_StartBug> size_t size ; <S2SV_EndBug> <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , <S2SV_EndBug> <S2SV_StartBug> rc = ngx_http_lua_set_content_length_header ( sr , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> # if 1 <S2SV_EndBug> <S2SV_StartBug> if ( ngx_http_lua_copy_request_headers ( sr , r ) != NGX_OK ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int pr_not_chunked = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sr -> request_body = NULL ; } else { if ( ! r -> headers_in . chunked ) { pr_not_chunked = 1 ; } if ( sr -> request_body && sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) <S2SV_ModEnd> <S2SV_ModStart> } } <S2SV_ModEnd> <S2SV_ModStart> , pr_not_chunked <S2SV_ModStart>  <S2SV_ModEnd> "
1223,"<S2SV_StartBug> ( void ) SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
1224,<S2SV_StartBug> tcp_init_send_head ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ; 
1225,"<S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> txtLen <S2SV_ModEnd> <S2SV_ModStart> snprintf ( txt , txtLeft <S2SV_ModEnd> <S2SV_ModStart> txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> txt , txtLeft - 1 <S2SV_ModEnd> "
1226,"<S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1227,"
","
"
1228,<S2SV_StartBug> int64_t i = 0 ; <S2SV_EndBug> <S2SV_StartBug> int isint = 1 ; <S2SV_EndBug> <S2SV_StartBug> f = ( f * 10.0 ) + ( * num - '0' ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * num >= '0' && * num <= '9' ) ; <S2SV_EndBug> <S2SV_StartBug> isint = 0 ; <S2SV_EndBug> <S2SV_StartBug> ++ num ; <S2SV_EndBug> <S2SV_StartBug> else if ( * num == '-' ) { <S2SV_EndBug> <S2SV_StartBug> signsubscale = - 1 ; <S2SV_EndBug> <S2SV_StartBug> i = sign * i ; <S2SV_EndBug> <S2SV_StartBug> item -> valueint = i ; <S2SV_EndBug> ,"<S2SV_ModStart> double n = 0 , sign = 1 , scale <S2SV_ModEnd> <S2SV_ModStart> subscale = 0 , signsubscale = 1 ; if ( * num == '-' ) sign = - 1 , num ++ ; if ( * num == '0' ) num ++ ; if ( * num >= '1' && * num <= '9' ) do n = ( n * 10.0 ) + ( * num ++ - '0' ) ; while ( * num >= '0' && * num <= '9' ) ; if ( * num == '.' && num [ 1 ] >= '0' && num [ 1 ] <= '9' ) { num ++ ; do n = ( n <S2SV_ModEnd> <S2SV_ModStart> ++ - '0' ) , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> num ++ ; <S2SV_ModEnd> <S2SV_ModStart> num ++ ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , num ++ ; while ( * num >= '0' && * num <= '9' ) subscale = ( subscale * 10 ) + ( * num ++ - '0' ) ; } n <S2SV_ModEnd> <S2SV_ModStart> n * pow ( 10.0 , ( scale + subscale * signsubscale ) ) ; item -> valuedouble = n <S2SV_ModEnd> <S2SV_ModStart> ( int64_t ) n ; <S2SV_ModEnd> "
1229,<S2SV_StartBug> mutex_init ( & tu -> tread_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ioctl_lock <S2SV_ModEnd> 
1230,"<S2SV_StartBug> vpx_memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memmove <S2SV_ModEnd> <S2SV_ModStart> vp8_pack_tokens <S2SV_ModEnd> 
1231,<S2SV_StartBug> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <S2SV_EndBug> ,<S2SV_ModStart> char t <S2SV_ModEnd> <S2SV_ModStart> ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>' 
1232,<S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> <S2SV_StartBug> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <S2SV_EndBug> <S2SV_StartBug> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned int ) ( value & 0xffffffff ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModEnd> <S2SV_ModStart> ; return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1233,<S2SV_StartBug> i ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; } "
1234,"<S2SV_StartBug> int n , length ; <S2SV_EndBug> <S2SV_StartBug> struct l2tp_dict_attr_t * da ; <S2SV_EndBug> <S2SV_StartBug> struct l2tp_attr_t * attr , * RV = NULL ; <S2SV_EndBug> <S2SV_StartBug> socklen_t len = sizeof ( addr ) ; <S2SV_EndBug> <S2SV_StartBug> struct msghdr msg ; <S2SV_EndBug> <S2SV_StartBug> struct cmsghdr * cmsg ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_controllen = 128 ; <S2SV_EndBug> <S2SV_StartBug> n = recvfrom ( fd , buf , L2TP_MAX_PACKET_SIZE , 0 , & addr , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( n < 6 ) { <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> T == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( n < ntohs ( hdr -> length ) ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%i)\\n"" , n , ntohs ( hdr -> length ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( hdr -> ver == 2 ) { <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( avp -> length > length ) { <S2SV_EndBug> <S2SV_StartBug> if ( conf_verbose ) <S2SV_EndBug> <S2SV_StartBug> log_warn ( ""l2tp:<S2SV_blank>unknown<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%u)\\n"" , ntohs ( avp -> type ) , avp -> M ) ; <S2SV_EndBug> <S2SV_StartBug> if ( da -> M != - 1 && da -> M != avp -> M ) { <S2SV_EndBug> <S2SV_StartBug> if ( da -> H != - 1 && da -> H != avp -> H ) { <S2SV_EndBug> <S2SV_StartBug> if ( avp -> H ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> orig_avp_len = avp -> length ; <S2SV_EndBug> <S2SV_StartBug> attr -> attr = da ; <S2SV_EndBug> <S2SV_StartBug> attr -> M = avp -> M ; <S2SV_EndBug> <S2SV_StartBug> attr -> length = orig_avp_len - sizeof ( * avp ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += avp -> length ; <S2SV_EndBug> <S2SV_StartBug> length -= avp -> length ; <S2SV_EndBug> ","<S2SV_ModStart> struct l2tp_packet_t * pack <S2SV_ModEnd> <S2SV_ModStart> l2tp_attr_t * <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> addr_len ; uint16_t orig_avp_len ; void * orig_avp_val ; uint8_t * buf , * ptr ; int n , length ; * p = NULL ; if ( pkt_info ) { <S2SV_ModEnd> <S2SV_ModStart> ; struct cmsghdr * cmsg <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sizeof ( msg_control ) <S2SV_ModEnd> <S2SV_ModStart> addr_len = sizeof ( addr ) ; <S2SV_ModStart> addr_len <S2SV_ModEnd> <S2SV_ModStart> sizeof ( * hdr ) <S2SV_ModEnd> <S2SV_ModStart> hdr -> flags = ntohs ( hdr -> flags ) ; if ( ! ( hdr -> flags & L2TP_FLAG_T ) <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( hdr -> flags & L2TP_FLAG_L ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n"" ) ; goto out_err_hdr ; } if ( ! ( hdr -> flags & L2TP_FLAG_S ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(S=0)\\n"" ) ; goto out_err_hdr ; } switch ( hdr -> flags & L2TP_VER_MASK ) { case 2 : if ( hdr -> flags & L2TP_FLAG_O ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(O=1)\\n"" ) ; goto out_err_hdr ; } break ; case 3 : break ; default : if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%i<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n"" , hdr -> flags & L2TP_VER_MASK ) ; goto out_err_hdr ; } length = ntohs ( hdr -> length ) ; if ( length < sizeof ( * hdr ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%zu)\\n"" , length , sizeof ( * hdr ) ) ; goto out_err_hdr ; } else <S2SV_ModStart> length ) <S2SV_ModEnd> <S2SV_ModStart> length ) <S2SV_ModEnd> <S2SV_ModStart> pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( ""l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length -= sizeof ( * hdr ) ; while ( length > 0 ) { struct l2tp_dict_attr_t * da ; struct l2tp_attr_t * attr ; uint16_t avp_len ; if ( length < sizeof ( * avp ) <S2SV_ModEnd> <S2SV_ModStart> ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n"" ) ; goto out_err ; } <S2SV_ModEnd> <S2SV_ModStart> avp -> flags = ntohs ( avp -> flags ) ; avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len < sizeof ( * avp ) ) { if ( conf_verbose ) log_warn ( ""l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n"" ) ; goto out_err ; } else if ( length < avp_len <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) ; } if ( ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> <S2SV_ModStart> ! <S2SV_ModStart> ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) , da <S2SV_ModEnd> <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_ModStart> ! <S2SV_ModStart> ! ( avp -> flags & L2TP_AVP_FLAG_H ) ) { if ( conf_verbose ) { log_warn ( ""l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n"" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_H ) , da <S2SV_ModEnd> <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_ModStart> flags & L2TP_AVP_FLAG_H <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> avp_len <S2SV_ModEnd> <S2SV_ModStart> = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; attr <S2SV_ModStart> ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> <S2SV_ModStart> ) ; list_add_tail ( & attr -> entry , & pack -> attrs <S2SV_ModStart> avp_len <S2SV_ModEnd> <S2SV_ModStart> avp_len <S2SV_ModEnd> "
1235,<S2SV_StartBug> port -> exists = false ; <S2SV_EndBug> <S2SV_StartBug> port -> serio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModStart>  <S2SV_ModEnd> 
1236,"<S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> ","<S2SV_ModStart> aio_setup_single_vector ( READ , file , <S2SV_ModEnd> <S2SV_ModStart> aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1237,<S2SV_StartBug> register const u_char * ep ; <S2SV_EndBug> <S2SV_StartBug> register const struct pim * pim = ( const struct pim * ) bp ; <S2SV_EndBug> <S2SV_StartBug> switch ( PIM_VER ( pim -> pim_typever ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( pim -> pim_typever ) ; <S2SV_ModStart> trunc : ND_PRINT ( ( ndo , ""[|pim]"" ) ) ; return ; "
1238,"<S2SV_StartBug> static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1239,"<S2SV_StartBug> char * p ; <S2SV_EndBug> <S2SV_StartBug> p = memchr ( str + 1 , ']' , str_len - 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * portno = atoi ( p + 2 ) ; <S2SV_EndBug> <S2SV_StartBug> * portno = atoi ( colon + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return host ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char * <S2SV_ModStart> , * e = NULL <S2SV_ModStart> strtol <S2SV_ModEnd> <S2SV_ModStart> , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\""%s\\"""" , str ) ; } return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> char * e = NULL ; <S2SV_ModStart> strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1240,"<S2SV_StartBug> ""truncated<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%"" PRIsize ""<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%"" PRIsize , <S2SV_EndBug> ","<S2SV_ModStart> ""truncated<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%"" <S2SV_ModEnd> "
1241,<S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> ,<S2SV_ModStart> WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if ( 
1242,"<S2SV_StartBug> file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> fopen_safe <S2SV_ModEnd> 
1243,"<S2SV_StartBug> ret = perf_output_begin ( & handle , event , read_event . header . size , 0 , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1244,"<S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1245,<S2SV_StartBug> iocb -> private = ext4_init_io_end ( inode ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , GFP_NOFS "
1246,"<S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> _gdImageGifCtx <S2SV_ModEnd> <S2SV_ModStart> out <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1247,<S2SV_StartBug> if ( map_data ) <S2SV_EndBug> <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> fail : 
1248,<S2SV_StartBug> is_kvmppc_hv_enabled ( kvm ) ; <S2SV_EndBug> ,<S2SV_ModStart> hv_enabled <S2SV_ModEnd> 
1249,"<S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> <S2SV_StartBug> if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\n]"" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> = """" <S2SV_ModStart> ""%1023s<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>%c<S2SV_blank>%8191[^\\n]"" <S2SV_ModEnd> <S2SV_ModStart> { mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n"" , line ) ; <S2SV_ModStart> } "
1250,"<S2SV_StartBug> AcquireNextImage ( image_info , image ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; "
1251,<S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING ) <S2SV_EndBug> <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> 
1252,"<S2SV_StartBug> actd = ( vp8_variance16x16 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ; <S2SV_EndBug> <S2SV_StartBug> act = ( vp8_variance16x16 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ; <S2SV_EndBug> <S2SV_StartBug> sad = ( vp8_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> vsad = ( vp8_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> act = ( vp8_variance8x8 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ; <S2SV_EndBug> <S2SV_StartBug> sad = ( vp8_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> usad = ( vp8_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> vsad = ( vp8_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( udp , up , uvblksize ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , uvblksize ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> sse + 128 ) >> 8 ; vpx_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 32 ) >> 6 ; vpx_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 32 ) >> 6 ; # else sad = ( vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart> ) + 128 ) >> 8 ; usad = ( vpx_sad8x8 ( u , uv_stride , ud , uvd_stride ) + 32 ) >> 6 ; vsad = ( vpx_sad8x8 ( v , uv_stride , vd , uvd_stride ) + 32 ) >> 6 ; # endif } else { actd = ( vpx_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x8 <S2SV_ModEnd> <S2SV_ModStart> vpx_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> sse + 32 ) >> 6 ; vpx_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 8 ) >> 4 ; vpx_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 8 ) >> 4 ; # else sad = ( vpx_sad8x8 <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4 <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> vpx_sad4x4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> "
1253,<S2SV_StartBug> PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> <S2SV_ModStart> , NULL ) <S2SV_ModEnd> "
1254,<S2SV_StartBug> return err ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> 
1255,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1256,<S2SV_StartBug> char temp [ 500 ] ; <S2SV_EndBug> <S2SV_StartBug> temp [ i ] = fgetc ( fp ) ; <S2SV_EndBug> ,"<S2SV_ModStart> int temp_size = 500 ; char * temp = malloc ( temp_size ) <S2SV_ModEnd> <S2SV_ModStart> if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; } "
1257,"<S2SV_StartBug> encode_share_access ( xdr , arg -> open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode <S2SV_ModEnd> 
1258,<S2SV_StartBug> av_freep ( & h -> DPB ) ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ; "
1259,<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1260,"<S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> ","<S2SV_ModStart> , false "
1261,<S2SV_StartBug> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1262,<S2SV_StartBug> return dcfg ; <S2SV_EndBug> ,<S2SV_ModStart> dcfg -> xml_external_entity = NOT_SET ; 
1263,"<S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> pdf -> name = malloc ( strlen ( ""Unknown"" ) + 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> <S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
1264,<S2SV_StartBug> if ( * off >= skb -> len ) { <S2SV_EndBug> ,<S2SV_ModStart> && skb -> len 
1265,"<S2SV_StartBug> size2 , mime ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
1266,<S2SV_StartBug> r -> rtm_flags |= RTM_F_NOTIFY ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT 
1267,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> _TIFFfree ( working_copy ) ; 
1268,<S2SV_StartBug> if ( indev != NULL ) { <S2SV_EndBug> ,<S2SV_ModStart> && indev -> ifa_list <S2SV_ModEnd> 
1269,"<S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug> ",<S2SV_ModStart> down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem 
1270,"<S2SV_StartBug> int procfd ; <S2SV_EndBug> <S2SV_StartBug> pid_t to_cleanup_pid = pid ; <S2SV_EndBug> <S2SV_StartBug> status = 0 ; <S2SV_EndBug> <S2SV_StartBug> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( options -> stdin_fd == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; <S2SV_EndBug> <S2SV_StartBug> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; <S2SV_EndBug> <S2SV_StartBug> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; <S2SV_EndBug> <S2SV_StartBug> cleanup_error : <S2SV_EndBug> <S2SV_StartBug> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; <S2SV_EndBug> <S2SV_StartBug> . procfd = procfd <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int procfd = - 1 ; <S2SV_ModStart> procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc."" <S2SV_ModEnd> <S2SV_ModStart> status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> <S2SV_ModStart> status ) <S2SV_ModEnd> <S2SV_ModStart> ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" <S2SV_ModEnd> <S2SV_ModStart> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } <S2SV_ModStart> ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>"" ""from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" <S2SV_ModEnd> <S2SV_ModStart> ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>"" ""initialization<S2SV_blank>(2):<S2SV_blank>%s."" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( ""Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s."" , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1271,<S2SV_StartBug> rp [ 0 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; } "
1272,<S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s -> <S2SV_ModStart> if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; 
1273,"<S2SV_StartBug> args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
1274,<S2SV_StartBug> int valuelen = args -> valuelen ; <S2SV_EndBug> <S2SV_StartBug> ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen 
1275,"<S2SV_StartBug> int openasuser ; <S2SV_EndBug> <S2SV_StartBug> int should_free_authpending_file = 0 ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , authfile_dir_len , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cfg -> auth_file = buf ; <S2SV_EndBug> <S2SV_StartBug> openasuser = geteuid ( ) == 0 && cfg -> openasuser ; <S2SV_EndBug> <S2SV_StartBug> if ( openasuser ) { <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( pw_s . pw_uid ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> ; PAM_MODUTIL_DEF_PRIVS ( privs ) <S2SV_ModStart> openasuser = geteuid ( ) == 0 ? 1 : 0 ; <S2SV_ModStart> if ( ! openasuser ) { DBG ( ""WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>"" ""consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration"" <S2SV_ModEnd> <S2SV_ModStart> } } DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; <S2SV_ModStart> if ( ! openasuser ) { openasuser <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> DBG ( ""Dropping<S2SV_blank>privileges"" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw <S2SV_ModEnd> <S2SV_ModStart> pw -> <S2SV_ModEnd> <S2SV_ModStart> pw -> <S2SV_ModEnd> <S2SV_ModStart> pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( ""could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges"" <S2SV_ModEnd> <S2SV_ModStart> ""Restored<S2SV_blank>privileges"" <S2SV_ModEnd> "
1276,<S2SV_StartBug> if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && <S2SV_EndBug> <S2SV_StartBug> vma -> vm_userfaultfd_ctx . ctx != ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) 
1277,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> "
1278,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1279,<S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> "
1280,"<S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } "
1281,<S2SV_StartBug> struct user_struct * user = group -> inotify_data . user ; <S2SV_EndBug> <S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1282,"<S2SV_StartBug> * lastrow , <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ",<S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row ) ) ; if ( last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> 
1283,<S2SV_StartBug> if ( retval ) { <S2SV_EndBug> ,<S2SV_ModStart> || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0' 
1284,"<S2SV_StartBug> static void mark_object ( struct object * obj , struct strbuf * path , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1285,"<S2SV_StartBug> void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) <S2SV_EndBug> <S2SV_StartBug> vcpu -> arch . apic -> vapic_addr = vapic_addr ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( vapic_addr ) { if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & <S2SV_ModStart> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ; <S2SV_ModEnd> <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> vcpu -> arch . apic -> vapic_addr = vapic_addr ; return 0 ; } "
1286,"<S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> if ( update_info ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) <S2SV_EndBug> <S2SV_StartBug> * update_info = ctx -> pbi -> refresh_frame_flags ; <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModEnd> <S2SV_ModStart> frame_worker_data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> VPX_CODEC_ERROR <S2SV_ModEnd> <S2SV_ModStart> return VPX_CODEC_INVALID_PARAM ; } "
1287,<S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> ,<S2SV_ModStart> + <S2SV_ModEnd> <S2SV_ModStart> > vdev -> config_len ) { return ; } <S2SV_ModEnd> 
1288,"<S2SV_StartBug> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
1289,<S2SV_StartBug> mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ; <S2SV_EndBug> ,<S2SV_ModStart> TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> 
1290,"<S2SV_StartBug> const int16_t * src , int16_t * dst , int src_stride ) { <S2SV_EndBug> <S2SV_StartBug> vp9_fdct32x32_rd ( src , dst , src_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_fdct32x32 ( src , dst , src_stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct32x32_rd <S2SV_ModEnd> <S2SV_ModStart> vpx_fdct32x32 <S2SV_ModEnd> 
1291,"<S2SV_StartBug> if ( strncmp ( line , ""currentfile<S2SV_blank>eexec"" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( line += 18 ; isspace ( * line ) ; line ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( ; line < last && isspace ( * line ) ; line ++ ) <S2SV_EndBug> <S2SV_StartBug> else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] ) <S2SV_EndBug> <S2SV_StartBug> && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) ) <S2SV_EndBug> ",<S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) <S2SV_ModStart> ( unsigned char ) 
1292,<S2SV_StartBug> gfp_mask = sk -> sk_allocation ; <S2SV_EndBug> <S2SV_StartBug> int npages ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; err = - EMSGSIZE ; if ( npages > MAX_SKB_FRAGS ) goto failure ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1293,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ar_tpa ( ap ) , PROTO_LEN ( ap ) ) ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""who-has<S2SV_blank>%s"" , ipaddr_string ( ndo , TPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>tell<S2SV_blank>%s"" , ipaddr_string ( ndo , SPA ( ap ) ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>is-at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , THA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>at<S2SV_blank>%s"" , <S2SV_EndBug> <S2SV_StartBug> linkaddr_string ( ndo , SHA ( ap ) , linkaddr , HRD_LEN ( ap ) ) , <S2SV_EndBug> ","<S2SV_ModStart> TPA <S2SV_ModEnd> <S2SV_ModStart> ""who-has<S2SV_blank>"" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""<S2SV_blank>tell<S2SV_blank>"" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>is-at<S2SV_blank>%s"" <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>at<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> "
1294,<S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int layer ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> RATE_CONTROL * const lrc = & lc -> rc ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> <S2SV_StartBug> lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ; <S2SV_EndBug> <S2SV_StartBug> lc -> framerate = oxcf -> framerate ; <S2SV_EndBug> <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> sl , tl , layer = 0 , spatial_layer_target ; float bitrate_alloc = 1.0 ; if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) { for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { spatial_layer_target = 0 ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; } layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ; spatial_layer_target = svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ; RATE_CONTROL * const lrc = & lc -> rc ; lc -> spatial_layer_target_bandwidth = spatial_layer_target ; bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } } } else { int layer_end <S2SV_ModEnd> <S2SV_ModStart> && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModStart> ; lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) <S2SV_ModStart> && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> } "
1295,"<S2SV_StartBug> psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ",<S2SV_ModStart> if ( psf -> fileoffset < psf -> filelength ) { <S2SV_ModStart> } ; 
1296,<S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; "
1297,"<S2SV_StartBug> return ast_for_call ( c , CHILD ( n , 1 ) , left_expr ) ; <S2SV_EndBug> ","<S2SV_ModStart> , true "
1298,"<S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> ",<S2SV_ModStart> { clear_tfile_check_list ( ) ; <S2SV_ModStart> } 
1299,<S2SV_StartBug> else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) { <S2SV_EndBug> ,<S2SV_ModStart> cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> 
1300,<S2SV_StartBug> print_bpf_insn ( insn ) ; <S2SV_EndBug> ,"<S2SV_ModStart> env , "
1301,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> mono_reflection_shutdown ( ) ; 
1302,"<S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> while ( tmp ) <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> tptr += stlv_len ; len -= stlv_len ; "
1303,"<S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> if ( cidx == NULL ) { goto fail1 ; } "
1304,"<S2SV_StartBug> assert ( ( occ0 % rowsize ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ; <S2SV_EndBug> ","<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""occ0%rowsize<S2SV_blank>!=<S2SV_blank>0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 "
1305,<S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> out2 <S2SV_ModEnd> 
1306,"<S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart> return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE "
1307,"<S2SV_StartBug> u_char showspi , showdata , showsomedata ; <S2SV_EndBug> <S2SV_StartBug> showdata = 0 ; <S2SV_EndBug> <S2SV_StartBug> showsomedata = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( 3 < ndo -> ndo_vflag ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) { <S2SV_EndBug> <S2SV_StartBug> } else if ( showsomedata && cp < ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cp < ep ) { if ( <S2SV_ModEnd> <S2SV_ModStart> > 3 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } 
1308,"<S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_LNKCHGI ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ISR_PT ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_PRI ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR_LNKCHGI <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR_PT ) != 0 ) { if ( ( dm9000ReadReg ( DM9000_NSR ) & ( DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ) != 0 <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR , DM9000_ISR_PT ) ; } if ( ( status & DM9000_ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR_PRI <S2SV_ModEnd> "
1309,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO 
1310,"<S2SV_StartBug> ext4_show_quota_options ( seq , sb ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( test_opt ( sb , DIOREAD_NOLOCK ) ) seq_puts ( seq , "",dioread_nolock"" ) ; "
1311,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ; 
1312,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
1313,<S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else <S2SV_ModEnd> 
1314,<S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) "
1315,"<S2SV_StartBug> int i , pktsz , ret ; <S2SV_EndBug> <S2SV_StartBug> dev_dbg ( dev , ""Checking<S2SV_blank>memory<S2SV_blank>size\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x12345678 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> i = 0x87654321 ; <S2SV_EndBug> <S2SV_StartBug> catc_write_mem ( catc , 0xfa80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> catc_read_mem ( catc , 0x7a80 , & i , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( i ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> u32 * buf ; int i ; <S2SV_ModStart> buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> * buf <S2SV_ModEnd> <S2SV_ModStart> kfree ( buf ) ; "
1316,"<S2SV_StartBug> void * p = au -> reply_buf ; <S2SV_EndBug> <S2SV_StartBug> ret = ceph_x_decrypt ( & th -> session_key , & p , end , & reply , sizeof ( reply ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> preply = & reply ; void * <S2SV_ModStart> preply <S2SV_ModEnd> 
1317,"<S2SV_StartBug> cp += advance ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> <S2SV_StartBug> advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> <S2SV_StartBug> advance = ah_print ( ndo , cp ) ; <S2SV_EndBug> <S2SV_StartBug> nh = enh & 0xff ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> if ( advance < 0 ) return ; <S2SV_ModStart> ND_TCHECK ( * cp ) ; <S2SV_ModStart> if ( advance < 0 ) return ; <S2SV_ModStart> ; if ( advance < 0 ) return <S2SV_ModStart> if ( advance < 0 ) return ; 
1318,<S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) || ( <S2SV_ModEnd> <S2SV_ModStart> ) 
1319,"<S2SV_StartBug> ""?"" , tptr [ 0 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; ND_TCHECK ( tptr [ 1 ] 
1320,<S2SV_StartBug> jpc_tsfb_band_t bnds [ 64 ] ; <S2SV_EndBug> ,<S2SV_ModStart> JPC_MAXBANDS <S2SV_ModEnd> 
1321,<S2SV_StartBug> if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) <S2SV_EndBug> ,<S2SV_ModStart> validate_core_offset ( reg ) ) return - EINVAL ; if ( 
1322,<S2SV_StartBug> list_del ( & ti -> active_list ) ; <S2SV_EndBug> ,<S2SV_ModStart> list_del_init <S2SV_ModEnd> 
1323,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
1324,"<S2SV_StartBug> g_return_if_fail ( RS_IS_FILTER ( filter ) ) ; <S2SV_EndBug> <S2SV_StartBug> g_file_set_contents ( ""/tmp/rs-filter-graph"" , str -> str , str -> len , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 0 != system ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>/tmp/rs-filter-graph.png<S2SV_blank></tmp/rs-filter-graph"" ) ) <S2SV_EndBug> <S2SV_StartBug> if ( 0 != system ( ""gnome-open<S2SV_blank>/tmp/rs-filter-graph.png"" ) ) <S2SV_EndBug> <S2SV_StartBug> g_warning ( ""Calling<S2SV_blank>gnome-open<S2SV_blank>failed."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; gchar * dot_filename ; gchar * png_filename ; gchar * command_line <S2SV_ModStart> dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ; png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ; g_file_set_contents ( dot_filename <S2SV_ModEnd> <S2SV_ModStart> command_line = g_strdup_printf ( ""dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s"" , png_filename , dot_filename ) ; <S2SV_ModStart> command_line <S2SV_ModEnd> <S2SV_ModStart> g_free ( command_line ) ; command_line = g_strdup_printf ( ""gnome-open<S2SV_blank>%s"" , png_filename ) ; <S2SV_ModStart> command_line <S2SV_ModEnd> <S2SV_ModStart> ) ; g_free ( command_line ) ; g_free ( dot_filename ) ; g_free ( png_filename "
1325,<S2SV_StartBug> return res ; <S2SV_EndBug> ,<S2SV_ModStart> cleanup : <S2SV_ModEnd> 
1326,<S2SV_StartBug> sb -> s_op = & ext2_sops ; <S2SV_EndBug> <S2SV_StartBug> percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext2_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ; goto failed_mount3 ; } # endif <S2SV_ModStart> if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; "
1327,"<S2SV_StartBug> ( IN_DEV_SHARED_MEDIA ( out_dev ) || <S2SV_EndBug> <S2SV_StartBug> inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) { <S2SV_EndBug> ",<S2SV_ModStart> skb -> protocol == htons ( ETH_P_IP ) && <S2SV_ModStart> IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ; <S2SV_ModEnd> 
1328,<S2SV_StartBug> unsigned long kflags = key -> flags ; <S2SV_EndBug> <S2SV_StartBug> if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) { <S2SV_EndBug> <S2SV_StartBug> ctx -> result = ERR_PTR ( key -> reject_error ) ; <S2SV_EndBug> ,<S2SV_ModStart> READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> <S2SV_ModStart> state < 0 ) { <S2SV_ModEnd> <S2SV_ModStart> state <S2SV_ModEnd> 
1329,<S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> ,<S2SV_ModStart> c -> mpeg4_studio_profile <S2SV_ModEnd> 
1330,<S2SV_StartBug> subsampling_dx = parameters -> subsampling_dx ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; } "
1331,<S2SV_StartBug> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; retval = - EINVAL ; goto error ; } "
1332,"<S2SV_StartBug> mask |= FS_EVENT_ON_CHILD ; <S2SV_EndBug> <S2SV_StartBug> if ( path ) <S2SV_EndBug> <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct name_snapshot name ; <S2SV_ModStart> take_dentry_name_snapshot ( & name , dentry ) ; <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> name <S2SV_ModEnd> <S2SV_ModStart> ) ; release_dentry_name_snapshot ( & name "
1333,"<S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> - EINVAL <S2SV_ModEnd> 
1334,"<S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%"" PRIu64 ""<S2SV_blank>bytes\\n"" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; } "
1335,"<S2SV_StartBug> mptctl_hp_targetinfo ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> hp_target_info_t karg ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> <S2SV_StartBug> ( ioc == NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> karg . hdr . id >= MPT_MAX_FC_DEVICES ) return - EINVAL ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_hp_targetinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ( ioc -> bus_type == SAS ) || ( ioc -> bus_type == FC ) ) return 0 ; if ( ( ioc -> spi_data . sdp0length == 0 ) || ( ioc -> sh <S2SV_ModEnd> <S2SV_ModStart> return 0 ; if ( ioc -> sh -> host_no != karg . hdr . host ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1336,"<S2SV_StartBug> ++ v ; <S2SV_EndBug> <S2SV_StartBug> ( void ) __writev ( STDERR_FILENO , iov , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( buf [ bufsize - 1 ] != '\\n' ) { <S2SV_ModStart> } <S2SV_ModStart> v - iov + 1 <S2SV_ModEnd> 
1337,<S2SV_StartBug> if ( xWantedSize > 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> && ( ( xWantedSize + heapSTRUCT_SIZE ) > xWantedSize ) ) <S2SV_ModStart> + ( portBYTE_ALIGNMENT - ( xWantedSize <S2SV_ModStart> ) ) > xWantedSize <S2SV_ModEnd> <S2SV_ModStart> configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ; } else { xWantedSize = 0 ; } } else { xWantedSize = 0 ; <S2SV_ModEnd> <S2SV_ModStart> <= xFreeBytesRemaining <S2SV_ModEnd> 
1338,<S2SV_StartBug> if ( * t ++ != * q ++ ) return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> t >= tend ) return 0 ; if ( 
1339,"<S2SV_StartBug> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> BOOL <S2SV_ModEnd> <S2SV_ModStart> return TRUE ; 
1340,"<S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> stringlen <S2SV_ModEnd> <S2SV_ModStart> stringlen <S2SV_ModEnd> 
1341,"<S2SV_StartBug> if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1342,<S2SV_StartBug> bh -> b_bdev = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ; 
1343,"<S2SV_StartBug> if ( JAS_CAST ( uint , jas_stream_write ( out , ( char * ) ppm -> data , ppm -> len ) ) != ppm -> len ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_uint <S2SV_ModEnd> 
1344,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( tm2interval ( tm , fsec , result ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <S2SV_ModEnd> <S2SV_ModStart> free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1345,"<S2SV_StartBug> AsyncWith ( asdl_seq * items , asdl_seq * body , int lineno , int col_offset , int <S2SV_EndBug> <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> ","<S2SV_ModStart> string type_comment , <S2SV_ModStart> v . AsyncWith . type_comment = type_comment ; p -> "
1346,<S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> struct xfrm_dump_info info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cb -> args [ 0 ] ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1347,<S2SV_StartBug> case 'h' : <S2SV_EndBug> ,<S2SV_ModStart> # include < sslopt - case . h > 
1348,"<S2SV_StartBug> assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) , <S2SV_EndBug> ","<S2SV_ModStart> size_t ss = <S2SV_ModEnd> <S2SV_ModStart> ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> pos , <S2SV_ModEnd> "
1349,"<S2SV_StartBug> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <S2SV_EndBug> <S2SV_StartBug> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <S2SV_EndBug> ","<S2SV_ModStart> loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> "
1350,"<S2SV_StartBug> unsigned char signature [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> unsigned int siglen = sizeof signature ; <S2SV_EndBug> <S2SV_StartBug> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ",<S2SV_ModStart> * signature = NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <S2SV_ModStart> free ( signature ) ; 
1351,<S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> ,<S2SV_ModStart> fsnotify_put_group ( group ) ; 
1352,<S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> cancel_autoload_drivers ( ) ; 
1353,"<S2SV_StartBug> uint32_t tag = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( tcm_tmr < 0 ) { <S2SV_EndBug> <S2SV_StartBug> rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1354,<S2SV_StartBug> case '\\r' : <S2SV_EndBug> ,"<S2SV_ModStart> \'""\' : case '\\\\' : case "
1355,<S2SV_StartBug> exit ( i ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , ""Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n"" , tmp_dir ) ; exit ( 1 ) ; } # endif "
1356,"<S2SV_StartBug> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <S2SV_EndBug> ","<S2SV_ModStart> kcalloc ( nvec , <S2SV_ModEnd> "
1357,<S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ,<S2SV_ModStart> if ( len < 2 ) { return NULL ; } 
1358,<S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> limit_r_end - limit_r_begin <S2SV_ModEnd> 
1359,<S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1360,"<S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> 
1361,<S2SV_StartBug> uint8_t * result ; <S2SV_EndBug> ,<S2SV_ModStart> if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; } 
1362,<S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
1363,<S2SV_StartBug> case 0x2f8 : <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1364,"<S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , XEN_NETIF_RSP_OKAY <S2SV_ModStart> xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , XEN_NETIF_RSP_OKAY <S2SV_ModStart> , XEN_NETIF_RSP_OKAY "
1365,"<S2SV_StartBug> args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; <S2SV_EndBug> ",<S2SV_ModStart> rmtvaluelen = valuelen ; args . 
1366,"<S2SV_StartBug> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> hdr . w1 = ntohl ( buf [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> if ( fg_off + len > dg_size ) return 0 ; 
1367,<S2SV_StartBug> s = & pit_state -> channels [ addr ] ; <S2SV_EndBug> ,<S2SV_ModStart> if ( addr == 3 ) return 0 ; 
1368,"<S2SV_StartBug> fd = open ( authfile , O_RDONLY , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> else if ( fd >= 0 ) <S2SV_EndBug> ",<S2SV_ModStart> | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> <S2SV_ModStart> ; } else { fd = - 1 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != - 1 <S2SV_ModEnd> 
1369,<S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
1370,"<S2SV_StartBug> static mongo_message * mongo_message_create ( int len , int id , int responseTo , int op ) { <S2SV_EndBug> <S2SV_StartBug> mm -> head . len = len ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> ( int ) 
1371,<S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( depth >= 64 ) break 
1372,<S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> bsnamemem <S2SV_ModEnd> <S2SV_ModStart> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> <S2SV_ModStart> bs_name <S2SV_ModEnd> 
1373,<S2SV_StartBug> i += 1 ; <S2SV_EndBug> ,<S2SV_ModStart> ++ <S2SV_ModEnd> 
1374,"<S2SV_StartBug> sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> 
1375,"<S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%"" PRIu64 ""<S2SV_blank>bytes\\n"" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; } "
1376,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_32BITS ( obj_tptr ) ; 
1377,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin6 ) ; 
1378,<S2SV_StartBug> smb_ofile_t * of = NULL ; <S2SV_EndBug> <S2SV_StartBug> of = sr -> fid_ofile ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> smb_ofile_flush ( sr , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1379,<S2SV_StartBug> } else { <S2SV_EndBug> ,<S2SV_ModStart> rdev -> ena_pin = NULL ; return ; 
1380,"<S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> ",<S2SV_ModStart> static <S2SV_ModStart> const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> <S2SV_ModStart> ( UINT64 ) <S2SV_ModStart> ; if ( offset <S2SV_ModEnd> 
1381,<S2SV_StartBug> if ( rv < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree ( bmc ) ; <S2SV_ModStart> } 
1382,"<S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , sizeof ( out2 ) <S2SV_ModStart> , sizeof ( out2 ) "
1383,"<S2SV_StartBug> if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1384,"<S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> <S2SV_StartBug> q = p ; <S2SV_EndBug> <S2SV_StartBug> goto skip ; <S2SV_EndBug> <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> ",<S2SV_ModStart> int skip = 0 ; <S2SV_ModStart> ; skip = 0 <S2SV_ModStart> skip = 1 <S2SV_ModEnd> <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } <S2SV_ModStart> if ( ! skip ) { <S2SV_ModStart> } 
1385,"<S2SV_StartBug> status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_LINKIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ReadPhyReg ( interface , ENC28J60_PHY_REG_PHIR ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_LINKIF ) ; <S2SV_EndBug> <S2SV_StartBug> value = enc28j60ReadPhyReg ( interface , ENC28J60_PHY_REG_PHSTAT2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( value & PHSTAT2_LSTAT ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_PKTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE | EIE_PKTIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_EIR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHIR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR , ENC28J60_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHSTAT2 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_PHSTAT2_LSTAT <S2SV_ModEnd> <S2SV_ModStart> enc28j60ReadReg ( interface , ENC28J60_EPKTCNT <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR , ENC28J60_EIR_PKTIF <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_LINKIE | ENC28J60_EIE_PKTIE <S2SV_ModEnd> "
1386,<S2SV_StartBug> linkname = archive_entry_hardlink ( a -> entry ) ; <S2SV_EndBug> <S2SV_StartBug> # else <S2SV_EndBug> ,"<S2SV_ModStart> char * linkname_copy ; struct archive_string error_string ; int error_number ; <S2SV_ModStart> archive_string_init ( & error_string ) ; linkname_copy = strdup ( linkname ) ; if ( linkname_copy == NULL ) { return ( EPERM ) ; } r = cleanup_pathname_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } r = check_symlinks_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , ""%s"" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } free ( linkname_copy ) ; "
1387,"<S2SV_StartBug> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""cipher"" , sizeof ( rcipher . type ) <S2SV_ModEnd> "
1388,<S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ; 
1389,"<S2SV_StartBug> void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> <S2SV_StartBug> vp9_iwht4x4_16_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_iwht4x4_1_add ( input , dest , stride ) ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> vpx_iwht4x4_16_add <S2SV_ModEnd> <S2SV_ModStart> vpx_iwht4x4_1_add <S2SV_ModEnd> 
1390,"<S2SV_StartBug> BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; 
1391,"
","
"
1392,"<S2SV_StartBug> struct ip_options * opt = inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> rt = skb_rtable ( skb ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> daddr = opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) <S2SV_EndBug> <S2SV_StartBug> skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> optlen ) { <S2SV_EndBug> <S2SV_StartBug> iph -> ihl += opt -> optlen >> 2 ; <S2SV_EndBug> <S2SV_StartBug> ip_options_build ( skb , opt , inet -> inet_daddr , rt , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu * inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> inet_opt && inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt && inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt ? inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt && inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> & inet_opt -> 
1393,<S2SV_StartBug> timr -> it_overrun = - 1 ; <S2SV_EndBug> <S2SV_StartBug> info -> si_overrun += timr -> it_overrun_last ; <S2SV_EndBug> ,"<S2SV_ModStart> 1LL <S2SV_ModEnd> <S2SV_ModStart> = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> "
1394,<S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < memo -> mt_allocated ; ++ i ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> size_t 
1395,<S2SV_StartBug> if ( sk -> sk_protocol == IPPROTO_TCP ) <S2SV_EndBug> ,<S2SV_ModStart> && sk -> sk_type == SOCK_STREAM 
1396,"<S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> "
1397,"<S2SV_StartBug> StreamTcpSetEvent ( p , STREAM_PKT_BROKEN_ACK ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; goto error 
1398,"<S2SV_StartBug> u8 obuf [ ] = { 0xde , 0 } ; <S2SV_EndBug> <S2SV_StartBug> state -> initialized = 1 ; <S2SV_EndBug> <S2SV_StartBug> return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int ret = 0 <S2SV_ModEnd> <S2SV_ModStart> mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> 
1399,<S2SV_StartBug> void unix_notinflight ( struct file * fp ) <S2SV_EndBug> <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight -- ; <S2SV_EndBug> ,"<S2SV_ModStart> struct user_struct * user , <S2SV_ModStart>  <S2SV_ModEnd> "
1400,<S2SV_StartBug> # ifdef AUTOKEY <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1401,"<S2SV_StartBug> int expected_count = 1 + extra_count ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> radix_tree_replace_slot ( pslot , newpage ) ; <S2SV_EndBug> <S2SV_StartBug> __dec_zone_page_state ( page , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> __inc_zone_page_state ( newpage , NR_FILE_PAGES ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) { <S2SV_EndBug> ","<S2SV_ModStart> struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone <S2SV_ModEnd> <S2SV_ModStart> __inc_zone_state ( newzone <S2SV_ModEnd> <S2SV_ModStart> PageSwapBacked ( page ) && <S2SV_ModStart> ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> "
1402,<S2SV_StartBug> struct futex_hash_bucket * hb ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1403,"<S2SV_StartBug> static char buf [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> buflen += snprintf ( buf + buflen , sizeof ( buf ) - buflen , ""%s%s"" , <S2SV_EndBug> <S2SV_StartBug> sepstr , lp -> s ) ; <S2SV_EndBug> <S2SV_StartBug> if ( buflen == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size <S2SV_ModEnd> <S2SV_ModStart> if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp <S2SV_ModEnd> <S2SV_ModStart> , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size <S2SV_ModEnd> <S2SV_ModStart> bufp == buf <S2SV_ModEnd> "
1404,<S2SV_StartBug> length = extent ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) "
1405,"<S2SV_StartBug> if ( ( r = ssh_packet_set_compress_state ( ssh , m ) ) != 0 || <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1406,<S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1407,<S2SV_StartBug> case RESPONSE_RUN : <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1408,"<S2SV_StartBug> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>output<S2SV_blank>file<S2SV_blank>%s"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file<S2SV_blank>\'%s\'"" <S2SV_ModEnd> "
1409,<S2SV_StartBug> int n = 0 ; <S2SV_EndBug> <S2SV_StartBug> sock = ap_get_conn_socket ( r -> connection ) ; <S2SV_EndBug> <S2SV_StartBug> lua_websocket_read ( L ) ; <S2SV_EndBug> ,<S2SV_ModStart> do_read = 1 ; int <S2SV_ModStart> ; while ( do_read ) { do_read = 0 <S2SV_ModStart> do_read = 1 ; } <S2SV_ModEnd> 
1410,"<S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> ",<S2SV_ModStart> if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> <= <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> if ( pixel . blue <= GetQuantumRange ( depth ) ) 
1411,"<S2SV_StartBug> if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) { <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1412,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> "
1413,<S2SV_StartBug> if ( p -> tokenpos == p -> tokenlen ) { <S2SV_EndBug> ,<S2SV_ModStart> >= ( <S2SV_ModEnd> <S2SV_ModStart> - 1 ) 
1414,<S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> ,<S2SV_ModStart> 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> 
1415,"<S2SV_StartBug> p = parse_tags ( render_priv , p , args [ cnt ] . end , k ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( args [ cnt ] . end < end ) { <S2SV_ModStart> } else { assert ( q == end ) ; pwr = k ; q = p ; } 
1416,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1417,<S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; luaL_checkstack ( L , 3 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map"" ) "
1418,"<S2SV_StartBug> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> "
1419,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
1420,<S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> is_two_pass_svc ( cpi ) <S2SV_ModEnd> 
1421,"<S2SV_StartBug> fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( fc . messages == NULL ) return - 1 
1422,<S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> ,<S2SV_ModStart> && i > 0 
1423,"<S2SV_StartBug> return xfrm6_rcv_spi ( skb , spi ) ; <S2SV_EndBug> ",<S2SV_ModStart> > 0 ? : 0 
1424,<S2SV_StartBug> unix_notinflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> user , scm -> fp -> "
1425,<S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> the_url <S2SV_ModEnd> 
1426,<S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1427,"<S2SV_StartBug> u8 ip_proto = 0 ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return true ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> key_basic -> n_proto = proto ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> <S2SV_StartBug> key_basic -> n_proto = proto ; <S2SV_EndBug> <S2SV_StartBug> if ( skb_flow_dissector_uses_key ( flow_dissector , <S2SV_EndBug> ","<S2SV_ModStart> ; bool ret = false <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_good <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_good ; } goto out_good <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> goto out_bad <S2SV_ModEnd> <S2SV_ModStart> if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } out_good : ret = true ; out_bad : <S2SV_ModStart> return ret <S2SV_ModEnd> "
1428,"<S2SV_StartBug> * lastrow , <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ",<S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row ) ) ; if ( last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> <S2SV_ModStart> last_row <S2SV_ModEnd> 
1429,"<S2SV_StartBug> dbg_hid ( ""%s,<S2SV_blank>size:%d\\n"" , __func__ , size ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , ""%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n"" , __func__ , dj_report -> device_index ) ; return false ; } "
1430,"<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return Curl_urldecode <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , NULL , TRUE ) <S2SV_ModEnd> "
1431,<S2SV_StartBug> bh -> b_bdev = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ; 
1432,<S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> ,<S2SV_ModStart> q -> fq = NULL ; 
1433,"<S2SV_StartBug> int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> <S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> flags | RR_REGARD_XA <S2SV_ModEnd> "
1434,"<S2SV_StartBug> perror ( ""malloc<S2SV_blank>(ret)"" ) ; <S2SV_EndBug> <S2SV_StartBug> image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ; <S2SV_EndBug> <S2SV_StartBug> dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ; <S2SV_EndBug> <S2SV_StartBug> if ( image_infos [ idx ] . pathFileOffset > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""corrupted<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , ( ut8 * ) image_infos , sz <S2SV_ModStart> r_buf_read64le <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> int pfo = <S2SV_ModEnd> <S2SV_ModStart> ; if ( pfo < 0 || pfo <S2SV_ModStart> ""corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n"" , pfo <S2SV_ModEnd> <S2SV_ModStart> r_buf_read_string <S2SV_ModEnd> <S2SV_ModStart> , pfo , 64 <S2SV_ModEnd> "
1435,<S2SV_StartBug> static ssize_t aio_setup_single_vector ( struct kiocb * kiocb ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ; <S2SV_EndBug> ,"<S2SV_ModStart> int type , struct file * file , <S2SV_ModStart> int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> bytes <S2SV_ModEnd> "
1436,<S2SV_StartBug> struct snd_kcontrol * kctl ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0 
1437,<S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1438,"<S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug> ",<S2SV_ModStart> user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED 
1439,"<S2SV_StartBug> p -> src . buf = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ; <S2SV_EndBug> <S2SV_StartBug> pd -> pre [ 0 ] . buf = & pd -> pre [ 0 ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> <S2SV_StartBug> pd -> pre [ 1 ] . buf = & pd -> pre [ 1 ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> ",<S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset <S2SV_ModEnd> 
1440,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
1441,<S2SV_StartBug> ND_TCHECK ( * pptr ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> ,"<S2SV_ModStart> tptr <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""[|esis]"" ) ) <S2SV_ModEnd> "
1442,"<S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rv ) <S2SV_EndBug> <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> ",<S2SV_ModStart> copy_file_as_user <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1443,<S2SV_StartBug> gctx = group_leader -> ctx ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> ,"<S2SV_ModStart> __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> <S2SV_ModStart> if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> <S2SV_ModStart> perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> "
1444,"<S2SV_StartBug> void * * p , void * end , <S2SV_EndBug> <S2SV_StartBug> void * dp , * dend ; <S2SV_EndBug> <S2SV_StartBug> struct ceph_crypto_key old_key ; <S2SV_EndBug> <S2SV_StartBug> dlen = ceph_x_decrypt ( secret , p , end , dbuf , <S2SV_EndBug> <S2SV_StartBug> tp = ticket_buf ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ceph_decode_need ( p , end , dlen , bad ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> dbuf = NULL ; void * <S2SV_ModStart> ; void * ticket_buf = NULL <S2SV_ModStart> & dbuf , 0 <S2SV_ModEnd> <S2SV_ModStart> if ( is_enc ) { dout ( ""<S2SV_blank>encrypted<S2SV_blank>ticket\\n"" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> <S2SV_ModStart> tp = ticket_buf ; <S2SV_ModStart> ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> kfree ( ticket_buf ) ; kfree ( dbuf ) ; "
1445,"<S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_MCID_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> tptr = tptr + sizeof ( struct isis_subtlv_spb_mcid ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , stlv_len ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN <S2SV_ModEnd> <S2SV_ModStart> if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_ModStart> while ( stlv_len <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_ModStart> tptr += stlv_len ; len -= stlv_len ; "
1446,<S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> ,"<S2SV_ModStart> rc = assign_eip_near ( ctxt , <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModStart> rc = assign_eip_near ( ctxt , <S2SV_ModEnd> <S2SV_ModStart> ) "
1447,"<S2SV_StartBug> file_sb_list_add ( f , inode -> i_sb ) ; <S2SV_EndBug> <S2SV_StartBug> file_sb_list_del ( f ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1448,<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt != NULL && inet -> opt -> srr ) { <S2SV_EndBug> <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt == NULL || ! inet -> opt -> srr ) <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt != NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> ; struct ip_options_rcu * inet_opt <S2SV_ModStart> inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt <S2SV_ModEnd> <S2SV_ModStart> inet_opt -> opt . <S2SV_ModEnd> <S2SV_ModStart> inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> "
1449,"<S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , ""<S2SV_blank>"" ) ; <S2SV_EndBug> <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> <S2SV_ModStart> , sizeof line <S2SV_ModStart> ( sizeof <S2SV_ModEnd> <S2SV_ModStart> '\\0' ; line [ strlen ( line ) - 1 ] = "
1450,<S2SV_StartBug> int iskew = imagew - tilew ; <S2SV_EndBug> <S2SV_StartBug> if ( colb + tilew > imagew ) { <S2SV_EndBug> ,<S2SV_ModStart> int64 iskew = ( int64 ) imagew - ( int64 ) <S2SV_ModEnd> <S2SV_ModStart> > iskew <S2SV_ModEnd> 
1451,<S2SV_StartBug> if ( isLua ( L -> ci ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1452,<S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> ,<S2SV_ModStart> uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1453,<S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> <S2SV_StartBug> return len ; <S2SV_EndBug> ,"<S2SV_ModStart> { # ifdef CONFIG_RETPOLINE WARN_ONCE ( ""Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n"" , ( void * ) addr ) ; # endif <S2SV_ModStart> } "
1454,"<S2SV_StartBug> ret = mount ( path , destpath , ""none"" , MS_BIND , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( path , destpath , ""none"" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> "
1455,"<S2SV_StartBug> const FRAME_TYPE frame_type = cm -> frame_type ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . auto_filter == 0 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> filter_level > 0 ) <S2SV_EndBug> ","<S2SV_ModStart> int update_any_ref_buffers = 1 ; if ( cpi -> common . refresh_last_frame == 0 && cpi -> common . refresh_golden_frame == 0 && cpi -> common . refresh_alt_ref_frame == 0 ) { update_any_ref_buffers = 0 ; } <S2SV_ModStart> { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level_fast ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level_fast ( <S2SV_ModEnd> <S2SV_ModStart> } # else vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; # endif } else { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { vp8cx_pick_filter_level ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level ( <S2SV_ModEnd> <S2SV_ModStart> } # else vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; # endif } <S2SV_ModStart> && update_any_ref_buffers "
1456,"<S2SV_StartBug> int vp8_denoiser_filter_neon ( YV12_BUFFER_CONFIG * mc_running_avg , <S2SV_EndBug> <S2SV_StartBug> unsigned char * sig = signal -> thismb ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 16 ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> int8x16_t v_sum_diff = vdupq_n_s8 ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( abs ( sum_diff ) > SUM_DIFF_THRESHOLD ) <S2SV_EndBug> <S2SV_StartBug> vp8_copy_mem16x16 ( running_avg -> y_buffer + y_offset , running_avg_y_stride , <S2SV_EndBug> <S2SV_StartBug> signal -> thismb , sig_stride ) ; <S2SV_EndBug> ","<S2SV_ModStart> unsigned char * mc_running_avg_y , int mc_running_avg_y_stride , unsigned char * running_avg_y , int running_avg_y_stride , <S2SV_ModEnd> <S2SV_ModStart> , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { int shift_inc = ( increase_denoising && motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 1 : 0 ; const uint8x16_t v_level1_adjustment = vmovq_n_u8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 4 + shift_inc : 3 ) ; const uint8x16_t v_delta_level_1_and_2 = vdupq_n_u8 ( 1 ) ; const uint8x16_t v_delta_level_2_and_3 = vdupq_n_u8 ( 2 ) ; const uint8x16_t v_level1_threshold = vmovq_n_u8 ( 4 + shift_inc ) ; const uint8x16_t v_level2_threshold = vdupq_n_u8 ( 8 ) ; const uint8x16_t v_level3_threshold = vdupq_n_u8 ( 16 ) ; int64x2_t v_sum_diff_total = vdupq_n_s64 ( 0 ) ; int r <S2SV_ModEnd> <S2SV_ModStart> r <S2SV_ModEnd> <S2SV_ModStart> r <S2SV_ModEnd> <S2SV_ModStart> r ) { const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_level1_mask = vcleq_u8 ( v_level1_threshold , v_abs_diff ) ; const uint8x16_t v_level2_mask = vcleq_u8 ( v_level2_threshold , v_abs_diff ) ; const uint8x16_t v_level3_mask = vcleq_u8 ( v_level3_threshold , v_abs_diff ) ; const uint8x16_t v_level2_adjustment = vandq_u8 ( v_level2_mask , v_delta_level_1_and_2 ) ; const uint8x16_t v_level3_adjustment = vandq_u8 ( v_level3_mask , v_delta_level_2_and_3 ) ; const uint8x16_t v_level1and2_adjustment = vaddq_u8 ( v_level1_adjustment , v_level2_adjustment ) ; const uint8x16_t v_level1and2and3_adjustment = vaddq_u8 ( v_level1and2_adjustment , v_level3_adjustment ) ; const uint8x16_t v_abs_adjustment = vbslq_u8 ( v_level1_mask , v_level1and2and3_adjustment , v_abs_diff ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; uint8x16_t v_running_avg_y = vqaddq_u8 ( v_sig , v_pos_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const <S2SV_ModEnd> <S2SV_ModStart> vqsubq_s8 ( vreinterpretq_s8_u8 ( v_pos_adjustment ) , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) <S2SV_ModEnd> <S2SV_ModStart> { int64x1_t x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; int sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; int sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( sum_diff > sum_diff_thresh ) { int delta = ( ( sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const uint8x16_t k_delta = vmovq_n_u8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_running_avg_y_stride * 16 ; running_avg_y -= running_avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { uint8x16_t v_running_avg_y = vld1q_u8 ( running_avg_y ) ; const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_abs_adjustment = vminq_u8 ( v_abs_diff , ( k_delta ) ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_pos_adjustment ) ; v_running_avg_y = vqaddq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const int8x16_t v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_neg_adjustment ) , vreinterpretq_s8_u8 ( v_pos_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) ; } sig += sig_stride ; mc_running_avg_y += mc_running_avg_y_stride ; running_avg_y += running_avg_y_stride ; } { x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; if ( sum_diff > sum_diff_thresh ) { <S2SV_ModEnd> <S2SV_ModStart> } } } else { return COPY_BLOCK ; } } } running_avg_y -= running_avg_y_stride * 16 ; sig -= sig_stride * 16 ; vp8_copy_mem16x16 ( running_avg_y <S2SV_ModEnd> <S2SV_ModStart> sig <S2SV_ModEnd> "
1457,"<S2SV_StartBug> if ( unlikely ( copied == 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> iov_iter_advance ( i , copied ) ; <S2SV_EndBug> ","<S2SV_ModStart> iov_iter_advance ( i , copied ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
1458,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t req_size = 0 ; <S2SV_ModStart> if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ; "
1459,"<S2SV_StartBug> gchar * filename ; <S2SV_EndBug> <S2SV_StartBug> filename = g_build_filename ( g_get_tmp_dir ( ) , ""gimp-test.xcf"" , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL ; gint file_handle <S2SV_ModStart> file_handle = g_file_open_tmp ( ""gimp-test-XXXXXX.xcf"" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle <S2SV_ModEnd> "
1460,"<S2SV_StartBug> xdr_free ( xdr_func , xdr_ptr ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1461,"<S2SV_StartBug> if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) { <S2SV_EndBug> <S2SV_StartBug> pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> + len <S2SV_ModStart> + len 
1462,<S2SV_StartBug> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ; 
1463,"<S2SV_StartBug> int ctrl_id , <S2SV_EndBug> <S2SV_StartBug> vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_decrypt_init <S2SV_ModEnd> <S2SV_ModStart> vpx_decrypt_init <S2SV_ModEnd> 
1464,<S2SV_StartBug> zval_ptr_dtor ( value ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1465,"<S2SV_StartBug> if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <S2SV_EndBug> ","<S2SV_ModStart> fmode , data -> o_arg . open_flags <S2SV_ModEnd> "
1466,<S2SV_StartBug> struct hci_filter * f = & hci_pi ( sk ) -> filter ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & uf , 0 , sizeof ( uf ) ) "
1467,"
","
"
1468,"<S2SV_StartBug> struct scatterlist sg [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> sg_init_one ( sg , buf , count ) ; <S2SV_EndBug> <S2SV_StartBug> return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ; void * data ; int ret <S2SV_ModStart> data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> kfree ( data ) ; return ret ; "
1469,"<S2SV_StartBug> metadatalength = GetDuration ( mp4 ) ; <S2SV_EndBug> <S2SV_StartBug> float in = 0.0 , out = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t fourcc = GPMF_Key ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n"" , PRINTF_4CC ( fourcc ) , rate ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( mp4 == 0 ) { printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n"" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> double in = 0.0 , out = 0.0 ; <S2SV_ModStart> , & in , & out ) ; printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n"" <S2SV_ModEnd> <S2SV_ModStart> , in , out "
1470,<S2SV_StartBug> cur_logical ++ ; <S2SV_EndBug> ,<S2SV_ModStart> if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ; 
1471,"<S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> ","<S2SV_ModStart> tiocgetd ( tty , <S2SV_ModEnd> "
1472,"<S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> <S2SV_ModStart> track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> <S2SV_ModStart> tmp_val <S2SV_ModEnd> <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> track_size [ i ] , <S2SV_ModStart> track_size [ i ] -= 3 ; <S2SV_ModStart> track_size [ i ] -= setup_ret ; <S2SV_ModStart> if ( ! track_size [ i ] ) break ; <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> track_size [ i ] , <S2SV_ModStart> track_size [ i ] -= setup_ret ; <S2SV_ModStart> if ( ! track_size [ i ] ) break ; <S2SV_ModStart> track_size [ i ] -- ; <S2SV_ModStart> if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> ; track_size [ i ] -- <S2SV_ModStart> free ( track_size ) ; "
1473,<S2SV_StartBug> if ( group_leader -> ctx -> type != ctx -> type ) <S2SV_EndBug> ,<S2SV_ModStart> task <S2SV_ModEnd> <S2SV_ModStart> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> 
1474,"<S2SV_StartBug> ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1475,<S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & entry , 0 , sizeof ( entry ) ) "
1476,<S2SV_StartBug> free ( p ) ; <S2SV_EndBug> ,<S2SV_ModStart> * pp = p -> next ; 
1477,"<S2SV_StartBug> char * dbuf ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return ret ; } return 0 <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1478,"<S2SV_StartBug> int fit_config_verify_required_sigs ( const void * fit , int conf_noffset , <S2SV_EndBug> <S2SV_StartBug> int noffset ; <S2SV_EndBug> <S2SV_StartBug> const char * reqd_mode ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> const char * name = fit_get_name ( fit , conf_noffset , NULL ) ; <S2SV_ModStart> if ( strchr ( name , '@' ) ) { printf ( ""Configuration<S2SV_blank>node<S2SV_blank>\'%s\'<S2SV_blank>contains<S2SV_blank>\'@\'\\n"" , name ) ; return - EPERM ; } "
1479,<S2SV_StartBug> void vp9_rc_init_minq_luts ( ) { <S2SV_EndBug> ,"<S2SV_ModStart> void ) { init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ; # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ; init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ; # endif <S2SV_ModEnd> "
1480,<S2SV_StartBug> if ( log_mode != LOG_MODE_CONFIGURED || new_mode != LOG_MODE_ERROR ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1481,"<S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> ","<S2SV_ModStart> | CVAR_PROTECTED <S2SV_ModStart> if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; } "
1482,<S2SV_StartBug> if ( args -> buffer_count < 1 ) { <S2SV_EndBug> ,<S2SV_ModStart> || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ) 
1483,"<S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug> ","<S2SV_ModStart> bool disconnect ; <S2SV_ModStart> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> disconnect ? & unmounted : NULL <S2SV_ModEnd> <S2SV_ModStart> if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> } "
1484,"<S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> ",<S2SV_ModStart> tmp_line_len >= 1 && <S2SV_ModStart> tmp_line_len >= 1 && <S2SV_ModStart> \\\n} <S2SV_ModEnd> 
1485,<S2SV_StartBug> char added ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1486,"<S2SV_StartBug> if ( disk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> const int blocksize = 512 ; <S2SV_EndBug> <S2SV_StartBug> if ( bio ) iob = bio ; <S2SV_EndBug> <S2SV_StartBug> ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , <S2SV_EndBug> <S2SV_StartBug> ( ut8 * ) buf , size * blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == - 1 ) <S2SV_EndBug> <S2SV_StartBug> } else eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ! disk ) { eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; return 1 ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart>  <S2SV_ModEnd> "
1487,"<S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> ","<S2SV_ModStart> tiocgetd ( tty , <S2SV_ModEnd> "
1488,<S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) return NULL ; 
1489,<S2SV_StartBug> error = ERROR_END_OF_STREAM ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> error = ERROR_FAILURE ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
1490,"<S2SV_StartBug> vp9_writer residual_bc ; <S2SV_EndBug> <S2SV_StartBug> TOKENEXTRA * tok [ 4 ] [ 1 << 6 ] , * tok_end ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * <S2SV_EndBug> <S2SV_StartBug> tok [ 0 ] [ 0 ] = cpi -> tok ; <S2SV_EndBug> <S2SV_StartBug> tok_end = tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_start_encode ( & residual_bc , data_ptr + total_size ) ; <S2SV_EndBug> <S2SV_StartBug> write_modes ( cpi , & tile , & residual_bc , & tok [ tile_row ] [ tile_col ] , tok_end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( tok [ tile_row ] [ tile_col ] == tok_end ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_stop_encode ( & residual_bc ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { int tile_idx = tile_row * tile_cols + tile_col ; TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ] <S2SV_ModEnd> <S2SV_ModStart> cpi -> tile_tok [ tile_row ] [ tile_col ] + <S2SV_ModEnd> <S2SV_ModStart> vpx_start_encode <S2SV_ModEnd> <S2SV_ModStart> vpx_start_encode <S2SV_ModEnd> <S2SV_ModStart> cpi -> tile_data [ tile_idx ] . tile_info , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_stop_encode <S2SV_ModEnd> "
1491,<S2SV_StartBug> struct channel_info * info = <S2SV_EndBug> ,<S2SV_ModStart> ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info 
1492,<S2SV_StartBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_EndBug> ,<S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> 
1493,<S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
1494,"<S2SV_StartBug> static void reset_fpf_position ( struct twopass_rc * p , <S2SV_EndBug> ",<S2SV_ModStart> TWO_PASS <S2SV_ModEnd> 
1495,<S2SV_StartBug> if ( offset > ds || offset + 6 > ds ) { <S2SV_EndBug> ,<S2SV_ModStart> - 6 <S2SV_ModEnd> 
1496,<S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> ,"<S2SV_ModStart> atomic_set ( & opt2 -> refcnt , 1 ) ; "
1497,"<S2SV_StartBug> if ( ( packetLength > INT_MAX ) || ! Stream_EnsureCapacity ( s , packetLength ) ) <S2SV_EndBug> ",<S2SV_ModStart> || ( packetLength < header ) 
1498,"<S2SV_StartBug> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . user = user ; <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . fa = NULL ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> fa = NULL <S2SV_ModEnd> <S2SV_ModStart> user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> 
1499,<S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> ,<S2SV_ModStart> auth_capable = new -> peer . auth_capable ; asoc -> peer . 
1500,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( length > 3 ) { <S2SV_EndBug> <S2SV_StartBug> print_string ( ndo , dat + 3 , length - 3 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 3 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> dat += 3 ; length -= 3 ; <S2SV_ModStart> != 0 <S2SV_ModEnd> <S2SV_ModStart> , length <S2SV_ModEnd> "
1501,<S2SV_StartBug> cur_token = * indx ; <S2SV_EndBug> <S2SV_StartBug> res = r ; <S2SV_EndBug> ,<S2SV_ModStart> clist * list ; <S2SV_ModStart> ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list ) 
1502,<S2SV_StartBug> kfree ( ubufs ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1503,"<S2SV_StartBug> void fdct16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
1504,<S2SV_StartBug> ACPI_FUNCTION_TRACE ( ns_terminate ) ; <S2SV_EndBug> <S2SV_StartBug> union acpi_operand_object * next ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart>  <S2SV_ModEnd> 
1505,<S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> } 
1506,<S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart> # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free <S2SV_ModEnd> 
1507,<S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug> ,<S2SV_ModStart> = false ; bool do_vnet <S2SV_ModStart> { <S2SV_ModStart> do_vnet = true ; } <S2SV_ModStart> { <S2SV_ModStart> do_vnet = false ; } <S2SV_ModStart> do_vnet = false ; <S2SV_ModStart> do_vnet <S2SV_ModEnd> 
1508,"<S2SV_StartBug> memcpy ( own_dir , ""."" , 2 ) ; <S2SV_EndBug> ","<S2SV_ModStart> # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ; # else <S2SV_ModStart> # endif "
1509,"<S2SV_StartBug> static int can_open_delegated ( struct nfs_delegation * delegation , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> if ( ( delegation -> type & open_flags ) != open_flags ) <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode ) != fmode <S2SV_ModEnd> 
1510,"<S2SV_StartBug> unsigned short sel ; <S2SV_EndBug> <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ; <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> ","<S2SV_ModStart> , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , cpl , false , & new_desc <S2SV_ModStart> rc = assign_eip_far ( ctxt <S2SV_ModEnd> <S2SV_ModStart> val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <S2SV_ModEnd> <S2SV_ModStart> rc ; } return rc <S2SV_ModEnd> "
1511,"<S2SV_StartBug> static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> <S2SV_StartBug> * corrupted = pbi -> common . frame_to_show -> corrupted ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const YV12_BUFFER_CONFIG * const frame <S2SV_ModEnd> <S2SV_ModStart> ; if ( frame == NULL ) return VPX_CODEC_ERROR ; * corrupted = frame 
1512,"<S2SV_StartBug> char src [ PATH_MAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( src , dir , dir_len ) ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( dir_len > PATH_MAX ) { uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n"" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> <S2SV_ModStart> , """" , 0 ) <S2SV_ModEnd> <S2SV_ModStart> free ( src ) ; <S2SV_ModStart> free ( src ) ; "
1513,"<S2SV_StartBug> int index , count , i ; <S2SV_EndBug> <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> ",<S2SV_ModStart> unsigned <S2SV_ModStart> unsigned 
1514,"<S2SV_StartBug> return mptctl_getiocinfo ( arg , _IOC_SIZE ( cmd ) ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_gettargetinfo ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_readtest ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_eventquery ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_eventenable ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_eventreport ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> return mptctl_replace_fw ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_fw_download ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_mpt_command ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_do_reset ( arg ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_hp_hostinfo ( arg , _IOC_SIZE ( cmd ) ) ; <S2SV_EndBug> <S2SV_StartBug> ret = mptctl_hp_targetinfo ( arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , <S2SV_ModStart> iocp , "
1515,"<S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> ","<S2SV_ModStart> , const char * elems <S2SV_ModStart> long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> ; if ( target_offset < size_of_base_struct ) return - EINVAL "
1516,<S2SV_StartBug> goto end ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1517,<S2SV_StartBug> assert ( bidx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || <S2SV_EndBug> <S2SV_StartBug> pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( addr + size > <S2SV_ModEnd> <S2SV_ModStart> addr + <S2SV_ModEnd> <S2SV_ModStart> size ) { pr_err ( ""%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range\\n"" , __func__ ) ; return - ESRCH ; } <S2SV_ModEnd> "
1518,"<S2SV_StartBug> void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , int xstart , <S2SV_EndBug> ","<S2SV_ModStart> jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> "
1519,<S2SV_StartBug> INIT_LIST_HEAD ( & card -> controls ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_init ( & card -> user_ctl_lock ) ; 
1520,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1521,"<S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
1522,<S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1523,"<S2SV_StartBug> UINT16 count ; <S2SV_EndBug> <S2SV_StartBug> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <S2SV_EndBug> ",<S2SV_ModStart> UINT32 <S2SV_ModEnd> <S2SV_ModStart> BITMAP_DATA * 
1524,<S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; 
1525,"<S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t ext_size = 0 ; <S2SV_ModStart> ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> "
1526,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
1527,"<S2SV_StartBug> return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> MODE_INVALID <S2SV_ModEnd> 
1528,"<S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ","<S2SV_ModStart> scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error = "
1529,<S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; } 
1530,"<S2SV_StartBug> memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( p , 0 , sizeof ( * p ) ) ; "
1531,<S2SV_StartBug> frame_end : <S2SV_EndBug> ,<S2SV_ModStart> if ( ! s -> studio_profile ) 
1532,<S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> ,<S2SV_ModStart> = { 0 } 
1533,"<S2SV_StartBug> int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qstart ) <S2SV_EndBug> <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) <S2SV_EndBug> ","<S2SV_ModStart> , vpx_bit_depth_t bit_depth <S2SV_ModStart> , bit_depth <S2SV_ModStart> , bit_depth "
1534,<S2SV_StartBug> const char * old_name ; <S2SV_EndBug> <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> <S2SV_StartBug> fsnotify_oldname_free ( old_name ) ; <S2SV_EndBug> ,"<S2SV_ModStart> struct name_snapshot <S2SV_ModEnd> <S2SV_ModStart> take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> <S2SV_ModStart> release_dentry_name_snapshot ( & <S2SV_ModEnd> "
1535,"<S2SV_StartBug> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> return ( value ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> ( int ) 
1536,<S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int <S2SV_ModEnd> 
1537,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1538,<S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> ,<S2SV_ModStart> shader_rec_offset < args -> bin_cl_size || 
1539,<S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart>  <S2SV_ModEnd> 
1540,<S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> inet_opt <S2SV_ModEnd> 
1541,"<S2SV_StartBug> dtls1_process_buffered_records ( s ) ; <S2SV_EndBug> <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) return - 1 <S2SV_ModStart> if ( <S2SV_ModStart> ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> dtls1_record_bitmap_update ( s , bitmap ) ; "
1542,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> atomic_set ( & opt2 -> refcnt , 1 ) ; "
1543,<S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; "
1544,"<S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> int * totrate , int64_t * totdist ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> <S2SV_StartBug> int rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> subsize = ( bsize >= BLOCK_8X8 ) ? mi_8x8 [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ; <S2SV_EndBug> <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + hbs , <S2SV_EndBug> <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row + hbs , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = mi_8x8 [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> subsize , output_enabled , totrate , totdist ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp , <S2SV_EndBug> <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis , tp , <S2SV_EndBug> <S2SV_StartBug> mi_row + hbs , mi_col , subsize , output_enabled , <S2SV_EndBug> <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_64X64 && output_enabled ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> RD_COST * dummy_cost , PC_TREE * pc_tree <S2SV_ModEnd> <S2SV_ModStart> TileInfo * tile_info = & tile_data -> tile_info ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> b_width_log2_lookup [ bsize ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mi <S2SV_ModEnd> <S2SV_ModStart> if ( output_enabled && bsize != BLOCK_4X4 ) { int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; td -> counts -> partition [ ctx ] [ partition ] ++ ; } <S2SV_ModStart> pc_tree -> none . pred_pixel_ready = 1 ; <S2SV_ModStart> tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> none ) ; pc_tree -> none . <S2SV_ModEnd> <S2SV_ModStart> ; pc_tree -> none . mbmi_ext = * x -> mbmi_ext ; pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> none . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) <S2SV_ModStart> pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> <S2SV_ModStart> ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModStart> && bsize > BLOCK_8X8 ) { pc_tree -> vertical [ 1 ] . pred_pixel_ready <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col + hbs , dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> <S2SV_ModStart> ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) <S2SV_ModStart> && bsize > BLOCK_8X8 ) { pc_tree -> horizontal [ 1 ] . pred_pixel_ready <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row + hbs , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> xd -> mi <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( bsize == BLOCK_8X8 ) { nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , pc_tree -> leaf_split [ 0 ] ) ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> dummy_cost , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> dummy_cost , pc_tree -> split [ 1 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis , tp , mi_row + hbs , mi_col , subsize , output_enabled , dummy_cost , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> <S2SV_ModStart> td , tile_data , mi <S2SV_ModEnd> <S2SV_ModStart> + hbs <S2SV_ModStart> + hbs <S2SV_ModStart> dummy_cost , pc_tree -> split [ 3 ] ) <S2SV_ModEnd> <S2SV_ModStart> 0 && <S2SV_ModStart> break ; <S2SV_ModStart> partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1545,<S2SV_StartBug> * state = CCS_VALUE ; <S2SV_EndBug> ,<S2SV_ModStart> if ( * state != CCS_START ) 
1546,<S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> 
1547,<S2SV_StartBug> nfcb_poll -> sensb_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_SENSB_RES_MAXSIZE ) "
1548,"<S2SV_StartBug> GsmXSMPClient * client ; <S2SV_EndBug> <S2SV_StartBug> client = ice_conn -> context ; <S2SV_EndBug> <S2SV_StartBug> g_return_val_if_fail ( client != NULL , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ; <S2SV_EndBug> ","<S2SV_ModStart> GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> <S2SV_ModStart> data <S2SV_ModEnd> <S2SV_ModStart> free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> <S2SV_ModStart> GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> "
1549,<S2SV_StartBug> if ( ( * name != '\\0' ) && ( * name != '#' ) ) <S2SV_EndBug> ,<S2SV_ModStart> count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( ( 
1550,"<S2SV_StartBug> static void fadst4 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int x0 , x1 , x2 , x3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( s0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( s1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = fdct_round_shift ( s2 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = fdct_round_shift ( s3 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t * input , tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t x0 , x1 , x2 , x3 ; tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) "
1551,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> INTL_CHECK_LOCALE_LEN ( slocale_len ) ; 
1552,<S2SV_StartBug> return true ; <S2SV_EndBug> ,<S2SV_ModStart> ( * field_rtrn != NULL ) <S2SV_ModEnd> 
1553,"<S2SV_StartBug> NetTxAncillary ancillary ; <S2SV_EndBug> <S2SV_StartBug> error = udpSendBuffer ( socket -> interface , & message -> srcIpAddr , <S2SV_EndBug> ",<S2SV_ModStart> NetInterface * interface ; <S2SV_ModStart> if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModStart>  <S2SV_ModEnd> 
1554,<S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ; 
1555,"<S2SV_StartBug> len = args -> count = min ( args -> count , max_blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
1556,"<S2SV_StartBug> set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; set_exception_intercept ( svm , AC_VECTOR "
1557,"<S2SV_StartBug> if ( ! av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""file"" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , ""ALL"" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , ""Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n"" ""If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n"" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <S2SV_ModStart> ) { ; } else <S2SV_ModEnd> "
1558,"<S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug> ",<S2SV_ModStart> new_ns -> mounts ++ ; 
1559,"<S2SV_StartBug> case VPX_IMG_FMT_I422 : <S2SV_EndBug> <S2SV_StartBug> case VPX_IMG_FMT_I444 : <S2SV_EndBug> <S2SV_StartBug> ""supported."" ) ; <S2SV_EndBug> ","<S2SV_ModStart> VPX_IMG_FMT_I42016 : break ; case <S2SV_ModStart> case VPX_IMG_FMT_I440 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 ) { ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile."" ) ; } break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44416 : case VPX_IMG_FMT_I44016 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 && ctx -> cfg . g_profile != ( unsigned int ) PROFILE_3 ) { ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>16-bit<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile."" ) ; } <S2SV_ModStart> ; break "
1560,<S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> goto bail <S2SV_ModEnd> <S2SV_ModStart> bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ; 
1561,"<S2SV_StartBug> unsigned int maxfraglen , fragheaderlen ; <S2SV_EndBug> <S2SV_StartBug> int hh_len ; <S2SV_EndBug> <S2SV_StartBug> fragheaderlen , skb , rt ) ; <S2SV_EndBug> ","<S2SV_ModStart> , mtu <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , np -> pmtudisc == IPV6_PMTUDISC_PROBE "
1562,<S2SV_StartBug> return - ENOBUFS ; <S2SV_EndBug> ,<S2SV_ModStart> goto nla_put_failure <S2SV_ModEnd> 
1563,"<S2SV_StartBug> assert ( errno == ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> ""for<S2SV_blank>management<S2SV_blank>address"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname "
1564,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1565,"<S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; } <S2SV_ModStart> } 
1566,<S2SV_StartBug> if ( * p == '#' ) { <S2SV_EndBug> ,"<S2SV_ModStart> len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ; "
1567,"<S2SV_StartBug> void nfs4_close_sync ( struct path * path , struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> <S2SV_StartBug> __nfs4_close ( path , state , mode , 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
1568,<S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_crop_width = img -> d_w ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_crop_height = img -> d_h ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_width = img -> d_w ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_height = img -> d_h ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> uv_width = ( 1 + yv12 -> y_width ) / 2 ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> uv_height = ( 1 + yv12 -> y_height ) / 2 ; <S2SV_EndBug> ,<S2SV_ModStart> const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> y_w <S2SV_ModEnd> <S2SV_ModStart> y_h <S2SV_ModEnd> <S2SV_ModStart> y_w <S2SV_ModEnd> <S2SV_ModStart> y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h <S2SV_ModEnd> <S2SV_ModStart> uv_w ; yv12 -> uv_height = uv_h ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> w <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1569,<S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> ,"<S2SV_ModStart> # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif "
1570,<S2SV_StartBug> if ( tlen < oid_len ) { <S2SV_EndBug> ,<S2SV_ModStart> 1U + 
1571,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
1572,<S2SV_StartBug> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <S2SV_EndBug> ,<S2SV_ModStart> & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> 
1573,"<S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> return 0 ; "
1574,"<S2SV_StartBug> err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , <S2SV_EndBug> <S2SV_StartBug> rcu_read_unlock ( ) ; <S2SV_EndBug> ","<S2SV_ModStart> { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> <S2SV_ModStart> } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ; "
1575,"<S2SV_StartBug> r = send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1576,"<S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> ",<S2SV_ModStart> tcp_filter <S2SV_ModEnd> <S2SV_ModStart> ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) 
1577,<S2SV_StartBug> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <S2SV_EndBug> <S2SV_StartBug> encode_nops ( & hdr ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ; "
1578,"<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> current_cred ( ) <S2SV_ModEnd> 
1579,"<S2SV_StartBug> ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1580,"<S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
1581,"<S2SV_StartBug> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( id >= KVM_MAX_VCPUS ) return - EINVAL ; 
1582,<S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> || ! SecIsValidHandle ( handle ) 
1583,<S2SV_StartBug> hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_EndBug> ,<S2SV_ModStart> if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } 
1584,"<S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ",<S2SV_ModStart> msg -> msg_namelen = 0 ; <S2SV_ModStart>  <S2SV_ModEnd> 
1585,"<S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> <S2SV_ModStart> , TRUE , phdr "
1586,"<S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> <S2SV_StartBug> fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> <S2SV_StartBug> p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> highbd_fdct32x32 <S2SV_ModEnd> <S2SV_ModStart> vpx_highbd_quantize_b_32x32 <S2SV_ModEnd> <S2SV_ModStart> dqcoeff , <S2SV_ModEnd> <S2SV_ModStart> eob , <S2SV_ModEnd> <S2SV_ModStart> vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_highbd_quantize_b <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_16X16 : vpx_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_8X8 : vpx_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; default : assert ( 0 ) ; break "
1587,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> "
1588,"<S2SV_StartBug> if ( ! headcount ) { <S2SV_EndBug> <S2SV_StartBug> msg . msg_iovlen = in ; <S2SV_EndBug> <S2SV_StartBug> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err != sock_len ) ) { <S2SV_EndBug> ","<S2SV_ModStart> unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n"" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; "
1589,<S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> ,<S2SV_ModStart> strlen ( token ) > 4 && 
1590,"<S2SV_StartBug> size_t wcs_length = len ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( wcs_length == 0 ) { <S2SV_EndBug> <S2SV_StartBug> wcs_length = mbs_length ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> # if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , mbs_length , & shift_state ) ; # else r = mbtowc ( wcs , mbs , mbs_length ) ; # endif if ( r == ( size_t ) - 1 || r == ( size_t ) - 2 ) { ret_val = - 1 ; break ; } if ( r == 0 || r > mbs_length ) break ; wcs ++ ; mbs += r ; mbs_length -= r ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1591,"<S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1592,<S2SV_StartBug> newnp -> ipv6_ac_list = NULL ; <S2SV_EndBug> <S2SV_StartBug> newinet -> inet_opt = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> = NULL ; newnp -> ipv6_mc_list 
1593,"<S2SV_StartBug> int alt ; <S2SV_EndBug> <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct usb_host_interface * <S2SV_ModEnd> <S2SV_ModStart> ! alt ) return - ENODEV <S2SV_ModEnd> <S2SV_ModStart> alt -> <S2SV_ModEnd> <S2SV_ModStart> -> desc . bAlternateSetting 
1594,"<S2SV_StartBug> # line 52 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 53 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 54 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 55 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 56 ""dt_test2.pgc"" <S2SV_EndBug> <S2SV_StartBug> # line 57 ""dt_test2.pgc"" <S2SV_EndBug> ",<S2SV_ModStart> 62 <S2SV_ModEnd> <S2SV_ModStart> 63 <S2SV_ModEnd> <S2SV_ModStart> 64 <S2SV_ModEnd> <S2SV_ModStart> 65 <S2SV_ModEnd> <S2SV_ModStart> 66 <S2SV_ModEnd> <S2SV_ModStart> 67 <S2SV_ModEnd> 
1595,"<S2SV_StartBug> ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1596,"<S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ofpact_finish_BUNDLE ( ofpacts , & bundle ) ; <S2SV_EndBug> ",<S2SV_ModStart> else { <S2SV_ModStart> } 
1597,"<S2SV_StartBug> char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( prefix != '+' && prefix != '-' && prefix != '=' ) { <S2SV_EndBug> <S2SV_StartBug> YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; <S2SV_EndBug> <S2SV_StartBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } <S2SV_EndBug> <S2SV_StartBug> { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } <S2SV_EndBug> <S2SV_StartBug> case 237 : <S2SV_EndBug> <S2SV_StartBug> # line 1082 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1090 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1091 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1095 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1106 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1120 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1124 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1125 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1129 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1130 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1134 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1135 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1140 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1144 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1148 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1152 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1153 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1158 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1162 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1163 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1168 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1170 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1172 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1174 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1176 ""ntp_parser.y"" <S2SV_EndBug> <S2SV_StartBug> # line 3826 ""ntp_parser.c"" <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; switch ( <S2SV_ModEnd> <S2SV_ModStart> [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> <S2SV_ModStart> ) ; } break ; case 235 : # line 1082 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> <S2SV_ModStart> , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 ""ntp_parser.y"" { ( yyval <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 1092 <S2SV_ModEnd> <S2SV_ModStart> 1100 <S2SV_ModEnd> <S2SV_ModStart> 1101 <S2SV_ModEnd> <S2SV_ModStart> 1105 <S2SV_ModEnd> <S2SV_ModStart> 1116 <S2SV_ModEnd> <S2SV_ModStart> 1130 <S2SV_ModEnd> <S2SV_ModStart> 1134 <S2SV_ModEnd> <S2SV_ModStart> 1135 <S2SV_ModEnd> <S2SV_ModStart> 1139 <S2SV_ModEnd> <S2SV_ModStart> 1140 <S2SV_ModEnd> <S2SV_ModStart> 1144 <S2SV_ModEnd> <S2SV_ModStart> 1145 <S2SV_ModEnd> <S2SV_ModStart> 1150 <S2SV_ModEnd> <S2SV_ModStart> 1154 <S2SV_ModEnd> <S2SV_ModStart> 1158 <S2SV_ModEnd> <S2SV_ModStart> 1162 <S2SV_ModEnd> <S2SV_ModStart> 1163 <S2SV_ModEnd> <S2SV_ModStart> 1168 <S2SV_ModEnd> <S2SV_ModStart> 1172 <S2SV_ModEnd> <S2SV_ModStart> 1173 <S2SV_ModEnd> <S2SV_ModStart> 1178 <S2SV_ModEnd> <S2SV_ModStart> 1180 <S2SV_ModEnd> <S2SV_ModStart> 1182 <S2SV_ModEnd> <S2SV_ModStart> 1184 <S2SV_ModEnd> <S2SV_ModStart> 1186 <S2SV_ModEnd> <S2SV_ModStart> 3836 <S2SV_ModEnd> "
1598,<S2SV_StartBug> blkif -> st_ds_req ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( err == - EOPNOTSUPP ) { <S2SV_EndBug> ,"<S2SV_ModStart> struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n"" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> fail_response : "
1599,<S2SV_StartBug> blkif -> st_ds_req ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( err == - EOPNOTSUPP ) { <S2SV_EndBug> ,"<S2SV_ModStart> struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n"" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> fail_response : "
1600,"<S2SV_StartBug> int nNew = sizeof ( char * ) * ( iArg + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ; <S2SV_EndBug> ",<S2SV_ModStart> sqlite3_int64 <S2SV_ModEnd> <S2SV_ModStart> sqlite3_realloc64 <S2SV_ModEnd> 
1601,"<S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> ","<S2SV_ModStart> ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> intptr_t <S2SV_ModEnd> <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) <S2SV_ModStart> ( intptr_t ) "
1602,"<S2SV_StartBug> strncpy ( hid -> name , req -> name , 128 ) ; <S2SV_EndBug> ",<S2SV_ModStart> sizeof ( req -> name ) - 1 <S2SV_ModEnd> 
1603,"<S2SV_StartBug> handle_t * handle = NULL ; <S2SV_EndBug> <S2SV_StartBug> ext4_debug ( ""ext4_get_block_write:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>create<S2SV_blank>flag<S2SV_blank>%d\\n"" , <S2SV_EndBug> <S2SV_StartBug> create = EXT4_GET_BLOCKS_IO_CREATE_EXT ; <S2SV_EndBug> <S2SV_StartBug> ret = ext4_get_blocks ( handle , inode , iblock , max_blocks , bh_result , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ext4_journal_current_handle ( ) <S2SV_ModEnd> <S2SV_ModStart> int started = 0 ; <S2SV_ModStart> if ( ! handle ) { <S2SV_ModStart> started = 1 ; } <S2SV_ModStart> if ( started ) 
1604,<S2SV_StartBug> uint32_t backup_handle ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE < <S2SV_EndBug> <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> } else { backup_handle = req -> buffer_handle ; } 
1605,<S2SV_StartBug> if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> ,"<S2SV_ModStart> print_primaries ( w , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1606,"<S2SV_StartBug> ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret "
1607,"<S2SV_StartBug> ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , <S2SV_EndBug> ",<S2SV_ModStart> if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ; 
1608,<S2SV_StartBug> proto = EXTRACT_16BITS ( & p [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * ( p + 1 ) == 0x81 || <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <S2SV_ModStart> length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <S2SV_ModStart> trunc : ND_PRINT ( ( ndo , ""[|chdlc]"" ) ) ; return ndo -> ndo_snapend - bp ; "
1609,<S2SV_StartBug> if ( ! esil ) <S2SV_EndBug> ,<S2SV_ModStart> { return ; } <S2SV_ModEnd> 
1610,"<S2SV_StartBug> struct dentry * res ; <S2SV_EndBug> <S2SV_StartBug> state = nfs4_do_open ( dir , & path , nd -> intent . open . flags , & attr , cred ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_intent_set_file ( nd , & path , state ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; fmode_t fmode = nd -> intent . open . flags & ( FMODE_READ | FMODE_WRITE | FMODE_EXEC ) <S2SV_ModStart> fmode , <S2SV_ModStart> , fmode "
1611,"<S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> arpt_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
1612,<S2SV_StartBug> thread -> tp_value = childregs -> ARM_r3 ; <S2SV_EndBug> ,<S2SV_ModStart> [ 0 ] <S2SV_ModStart> ; thread -> tp_value [ 1 ] = get_tpuser ( ) 
1613,"<S2SV_StartBug> if ( options_file ( configuration_file , type , & section ) ) <S2SV_EndBug> <S2SV_StartBug> if ( init_section ( 1 , & section ) ) <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> { s_log ( LOG_ERR , ""Configuration<S2SV_blank>failed"" ) ; options_free ( 0 ) ; <S2SV_ModStart> } "
1614,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ; 
1615,<S2SV_StartBug> nName ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> nName = ( int ) strlen ( zName ) ; 
1616,"<S2SV_StartBug> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { <S2SV_EndBug> ","<S2SV_ModStart> || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK "
1617,<S2SV_StartBug> if ( is_file_hugepages ( shm_file ) ) <S2SV_EndBug> ,<S2SV_ModStart> shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if ( 
1618,"<S2SV_StartBug> if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS "
1619,"<S2SV_StartBug> if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) ) <S2SV_EndBug> ","<S2SV_ModStart> if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( ""Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory"" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( ""abrt"" ) ; if ( ! gr ) { error_msg ( ""Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access"" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed"" , dirname ) ; return 403 ; } } else "
1620,"<S2SV_StartBug> if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> return psf_fread ( ptr , 1 , bytes , psf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + bytes > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + bytes > psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> { count = psf_fread ( psf -> header + psf -> headend , 1 , bytes - ( psf -> headend - psf -> headindex ) , psf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( count != bytes - ( int ) ( psf -> headend - psf -> headindex ) ) <S2SV_EndBug> <S2SV_StartBug> psf -> headend += count ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( ptr , psf -> header + psf -> headindex , bytes ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += bytes ; <S2SV_EndBug> ","<S2SV_ModStart> header . indx + bytes >= <S2SV_ModEnd> <S2SV_ModStart> . len && psf_bump_header_allocation ( psf , bytes <S2SV_ModStart> count <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . end <S2SV_ModEnd> <S2SV_ModStart> . ptr <S2SV_ModStart> header . indx <S2SV_ModEnd> <S2SV_ModStart> header . indx <S2SV_ModEnd> "
1621,"<S2SV_StartBug> or_circuit_t * or_circ = NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) <S2SV_EndBug> <S2SV_StartBug> or_circ = TO_OR_CIRCUIT ( circ ) ; <S2SV_EndBug> <S2SV_StartBug> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_NOTDIRECTORY , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_INTERNAL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> END_STREAM_REASON_EXITPOLICY , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> origin_circuit_t * origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; <S2SV_EndBug> <S2SV_StartBug> origin_circ -> cpath -> prev ) ; <S2SV_EndBug> ",<S2SV_ModStart> = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> { <S2SV_ModStart> } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> <S2SV_ModStart> tor_assert ( origin_circ <S2SV_ModEnd> <S2SV_ModStart> layer_hint <S2SV_ModEnd> 
1622,"<S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( <S2SV_ModEnd> <S2SV_ModStart> <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModEnd> <S2SV_ModStart> goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart>  <S2SV_ModEnd> "
1623,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
1624,<S2SV_StartBug> struct cpuinfo_x86 * c ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM 
1625,"<S2SV_StartBug> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; SecInvalidateHandle ( & credssp -> context 
1626,"<S2SV_StartBug> rc = fuse_dev_release ( inode , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> fuse_conn_put ( & cc -> fc ) ; 
1627,<S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> ,"<S2SV_ModStart> scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> <S2SV_ModStart> ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret "
1628,"<S2SV_StartBug> static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) { <S2SV_EndBug> <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> ",<S2SV_ModStart> SVC_LOG_LEVEL <S2SV_ModEnd> <S2SV_ModStart> SvcInternal_t <S2SV_ModEnd> 
1629,<S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> 1LL <S2SV_ModEnd> 
1630,"<S2SV_StartBug> int <S2SV_EndBug> <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug> ","<S2SV_ModStart> MagickBooleanType status ; <S2SV_ModStart> status = MagickTrue ; <S2SV_ModStart> { <S2SV_ModEnd> <S2SV_ModStart> if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> fclose ( input <S2SV_ModEnd> <S2SV_ModStart> remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> <S2SV_ModStart> status <S2SV_ModEnd> "
1631,<S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1632,"<S2SV_StartBug> priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! r ) return - EINVAL ; 
1633,"<S2SV_StartBug> ret = poll ( & pfd , 1 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1634,<S2SV_StartBug> int i ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> 
1635,"<S2SV_StartBug> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
1636,<S2SV_StartBug> if ( report -> id == REPORT_KEY_STATE ) { <S2SV_EndBug> ,"<S2SV_ModStart> size > 64 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n"" , size ) ; return 0 ; } if ( "
1637,"<S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
1638,"<S2SV_StartBug> if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsMask + iconInfo -> cbBitsColor ) <S2SV_EndBug> <S2SV_StartBug> Stream_Read ( s , iconInfo -> colorTable , iconInfo -> cbColorTable ) ; <S2SV_EndBug> <S2SV_StartBug> newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ; <S2SV_EndBug> <S2SV_StartBug> Stream_Read ( s , iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ; <S2SV_EndBug> ","<S2SV_ModStart> newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsMask , iconInfo -> cbBitsMask ) ; if ( ! newBitMask ) { free ( iconInfo -> bitsMask ) ; iconInfo -> bitsMask = NULL ; return FALSE ; } iconInfo -> bitsMask = newBitMask ; <S2SV_ModStart> ) return FALSE <S2SV_ModEnd> <S2SV_ModStart> { if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbColorTable ) return FALSE ; <S2SV_ModStart> } <S2SV_ModStart> if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsColor ) return FALSE ; "
1639,<S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } "
1640,<S2SV_StartBug> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <S2SV_EndBug> <S2SV_StartBug> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> coerce_reg_to_size <S2SV_ModEnd> <S2SV_ModStart> , 4 "
1641,<S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug> ,<S2SV_ModStart> skcipher_setkey <S2SV_ModEnd> 
1642,"<S2SV_StartBug> void vp9_fwht4x4_c ( const int16_t * input , int16_t * output , int stride ) { <S2SV_EndBug> <S2SV_StartBug> int a1 , b1 , c1 , d1 , e1 ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * ip = input ; <S2SV_EndBug> <S2SV_StartBug> int16_t * op = output ; <S2SV_EndBug> <S2SV_StartBug> a1 = ip [ 0 * stride ] ; <S2SV_EndBug> <S2SV_StartBug> d1 = ip [ 3 * stride ] ; <S2SV_EndBug> <S2SV_StartBug> op [ 0 ] = a1 ; <S2SV_EndBug> <S2SV_StartBug> op [ 8 ] = d1 ; <S2SV_EndBug> <S2SV_StartBug> op [ 12 ] = b1 ; <S2SV_EndBug> <S2SV_StartBug> op [ 0 ] = a1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 1 ] = c1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 2 ] = d1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 3 ] = b1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> ",<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ip_pass0 <S2SV_ModEnd> <S2SV_ModStart> const tran_low_t * ip = NULL ; tran_low_t <S2SV_ModEnd> <S2SV_ModStart> ip_pass0 [ 0 * stride ] ; b1 = ip_pass0 [ 1 * stride ] ; c1 = ip_pass0 <S2SV_ModEnd> <S2SV_ModStart> ip_pass0 <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) a1 ; op [ 4 ] = ( tran_low_t ) <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) b1 ; ip_pass0 <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) ( <S2SV_ModStart> ) ; op [ 1 ] = ( tran_low_t ) ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> ( tran_low_t ) ( <S2SV_ModStart> ) <S2SV_ModStart> ( tran_low_t ) ( <S2SV_ModStart> ) 
1643,<S2SV_StartBug> struct sock * sk ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL 
1644,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> key -> reject_error = - error ; <S2SV_EndBug> ","<S2SV_ModStart> key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> <S2SV_ModStart> mark_key_instantiated ( key , - error <S2SV_ModEnd> "
1645,"<S2SV_StartBug> if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } <S2SV_EndBug> <S2SV_StartBug> c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < g -> values ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> m -> coupling_steps = get_bits ( f , 8 ) + 1 ; <S2SV_EndBug> ","<S2SV_ModStart> current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; <S2SV_ModStart> ( uint32 ) values <S2SV_ModEnd> <S2SV_ModStart> - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup ) "
1646,<S2SV_StartBug> for ( i = 0 ; i < st -> duration ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
1647,<S2SV_StartBug> int kb ; <S2SV_EndBug> <S2SV_StartBug> kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; <S2SV_EndBug> ,"<S2SV_ModStart> , r <S2SV_ModStart> ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_debug_errno ( r , ""Keyboard<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>XLATE<S2SV_blank>or<S2SV_blank>UNICODE<S2SV_blank>mode,<S2SV_blank>not<S2SV_blank>resetting:<S2SV_blank>%m"" ) ; return 0 ; } else if ( r < 0 ) return r "
1648,"<S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> & cmd <S2SV_ModEnd> <S2SV_ModStart> cmd <S2SV_ModEnd> 
1649,<S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug> ,<S2SV_ModStart> ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX 
1650,"<S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> ",<S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> <S2SV_ModStart> capable_wrt_inode_uidgid <S2SV_ModEnd> 
1651,"<S2SV_StartBug> if ( strstr ( token , ""PM"" ) != NULL ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( strchr ( token , 'd' ) != NULL ) <S2SV_EndBug> <S2SV_StartBug> if ( strchr ( token , 'w' ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrstr <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } if ( osStrchr <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } 
1652,<S2SV_StartBug> while ( tmp && alen < tmp ) { <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK2 ( * tptr , alen ) ; "
1653,"<S2SV_StartBug> char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded = NULL ; <S2SV_EndBug> <S2SV_StartBug> mask2 = weechat_string_replace ( mask , dir_separator , ""\\01"" ) ; <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 = malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! mask_decoded5 ) <S2SV_EndBug> <S2SV_StartBug> mask_decoded5 [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ; <S2SV_EndBug> <S2SV_StartBug> weechat_string_tolower ( mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> mask , mask_decoded5 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mask_decoded ) <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded2 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded3 ) ; <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded4 ) ; <S2SV_EndBug> <S2SV_StartBug> return mask_decoded5 ; <S2SV_EndBug> ","<S2SV_ModStart> mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> <S2SV_ModStart> mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> <S2SV_ModStart> length = strlen ( mask <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> mask2 <S2SV_ModEnd> <S2SV_ModStart> if ( strftime ( mask2 <S2SV_ModEnd> <S2SV_ModStart> mask <S2SV_ModEnd> <S2SV_ModStart> == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\01"" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , ""\\01"" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> mask7 <S2SV_ModEnd> <S2SV_ModStart> mask7 <S2SV_ModEnd> <S2SV_ModStart> mask3 <S2SV_ModEnd> <S2SV_ModStart> mask3 ) ; if ( mask4 <S2SV_ModEnd> <S2SV_ModStart> mask4 ) ; if ( mask5 <S2SV_ModEnd> <S2SV_ModStart> mask5 ) ; if ( mask6 <S2SV_ModEnd> <S2SV_ModStart> mask6 <S2SV_ModEnd> <S2SV_ModStart> mask7 <S2SV_ModEnd> "
1654,"<S2SV_StartBug> r_set_size ( op , size ) ; <S2SV_EndBug> <S2SV_StartBug> r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ; <S2SV_EndBug> <S2SV_StartBug> r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> op -> tas . rsize = size <S2SV_ModEnd> <S2SV_ModStart> op [ - 3 ] . <S2SV_ModEnd> <S2SV_ModStart> if ( forward ) { op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ; op [ - 3 ] . tas . rsize = count ; } else { op [ - 1 ] . tas . rsize = count ; op [ - 3 ] . tas . rsize -= count + size ; } <S2SV_ModEnd> 
1655,"<S2SV_StartBug> char * method = manager -> method ; <S2SV_EndBug> <S2SV_StartBug> build_config ( working_dir , server ) ; <S2SV_EndBug> <S2SV_StartBug> ""%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf"" , <S2SV_EndBug> <S2SV_StartBug> executable , method , manager -> manager_address , <S2SV_EndBug> <S2SV_StartBug> working_dir , server -> port , working_dir , server -> port ) ; <S2SV_EndBug> ","<S2SV_ModStart> int i ; int port ; port = atoi ( server -> port ) <S2SV_ModEnd> <S2SV_ModStart> manager , server ) <S2SV_ModEnd> <S2SV_ModStart> ""%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
1656,"<S2SV_StartBug> struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; <S2SV_EndBug> <S2SV_StartBug> int chan = sa -> rc_channel ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) { <S2SV_EndBug> <S2SV_StartBug> bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ; <S2SV_EndBug> <S2SV_StartBug> rfcomm_pi ( sk ) -> channel = chan ; <S2SV_EndBug> ","<S2SV_ModStart> sa <S2SV_ModEnd> <S2SV_ModStart> len , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa . rc_bdaddr ) ; <S2SV_ModStart> sa . rc_channel <S2SV_ModEnd> <S2SV_ModStart> sa . rc_channel , & sa . <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> sa . rc_channel <S2SV_ModEnd> "
1657,"<S2SV_StartBug> int open_debug_log ( void ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( debug_file_fp = fopen ( debug_file , ""a+"" ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> ( void ) fcntl ( fileno ( debug_file_fp ) , F_SETFD , FD_CLOEXEC ) ; <S2SV_EndBug> ","<S2SV_ModStart> int fh ; struct stat st ; <S2SV_ModStart> fh = open ( debug_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) return ERROR ; if ( ( debug_file_fp = fdopen ( fh <S2SV_ModEnd> <S2SV_ModStart> if ( ( fstat ( fh , & st ) ) == - 1 ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } <S2SV_ModStart> fh <S2SV_ModEnd> "
1658,<S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } 
1659,<S2SV_StartBug> if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) { <S2SV_EndBug> ,<S2SV_ModStart> data_len > MT_PACKET_LEN - 4 - <S2SV_ModStart>  <S2SV_ModEnd> 
1660,<S2SV_StartBug> drop_cloexec ( data -> instance_id_fd ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( data -> env_fd != - 1 ) drop_cloexec ( data -> env_fd 
1661,"<S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cifs_small_buf_release ( req ) ; 
1662,<S2SV_StartBug> return ms ; <S2SV_EndBug> ,<S2SV_ModStart> ms -> elf_notes_max = FILE_ELF_NOTES_MAX ; 
1663,"<S2SV_StartBug> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1664,<S2SV_StartBug> return error ; <S2SV_EndBug> ,<S2SV_ModStart> < 0 ? error : 0 
1665,<S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> ,<S2SV_ModStart> ses -> server -> vals = & smb21_values ; <S2SV_ModStart> { <S2SV_ModStart> ses -> server -> vals = & smb311_values ; } 
1666,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
1667,<S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> ; bool checksum_valid = false <S2SV_ModStart> checksum_valid = ! <S2SV_ModEnd> <S2SV_ModStart> ; if ( ! checksum_valid <S2SV_ModStart> checksum_valid || 
1668,"<S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * cp == '\\0' || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart>  <S2SV_ModEnd> "
1669,"<S2SV_StartBug> uint32_t len ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n"" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> qiov . size <S2SV_ModEnd> <S2SV_ModStart> scsi_init_iovec ( r ) <S2SV_ModEnd> <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> 
1670,<S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc ( <S2SV_ModEnd> 
1671,<S2SV_StartBug> if ( current -> mm ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> leave_mm ( smp_processor_id ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> smp_mb ( ) ; } 
1672,"<S2SV_StartBug> if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) <S2SV_EndBug> <S2SV_StartBug> file = drive_get_file_by_id ( drive , irp -> FileId ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) ) <S2SV_EndBug> ","<S2SV_ModStart> void * ptr ; <S2SV_ModStart> ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ptr <S2SV_ModEnd> "
1673,<S2SV_StartBug> if ( border < 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> || color < 0 
1674,<S2SV_StartBug> uint8_t * result ; <S2SV_EndBug> ,<S2SV_ModStart> if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; } 
1675,"<S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> <S2SV_ModStart> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart>  <S2SV_ModEnd> "
1676,"<S2SV_StartBug> return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ; <S2SV_EndBug> ",<S2SV_ModStart> segfeature_active <S2SV_ModEnd> 
1677,"<S2SV_StartBug> savesegment ( es , prev -> es ) ; <S2SV_EndBug> <S2SV_StartBug> loadsegment ( ds , next -> ds ) ; <S2SV_EndBug> ","<S2SV_ModStart> fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart>  <S2SV_ModEnd> "
1678,<S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if ( "
1679,<S2SV_StartBug> goto fail ; <S2SV_EndBug> ,<S2SV_ModStart> ret = - EINVAL ; 
1680,"<S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> 
1681,"<S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug> ","<S2SV_ModStart> domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; } "
1682,"<S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return parse_cosine_packet <S2SV_ModEnd> <S2SV_ModStart> buf , line <S2SV_ModEnd> "
1683,"<S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
1684,<S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
1685,"<S2SV_StartBug> int lineno ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & annotation , arena ) ; <S2SV_EndBug> <S2SV_StartBug> * out = arg ( arg , annotation , lineno , col_offset , end_lineno , end_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> string type_comment ; <S2SV_ModStart> , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModStart> type_comment , "
1686,<S2SV_StartBug> cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & cinfo , 0 , sizeof ( cinfo ) ) ; "
1687,"<S2SV_StartBug> const uint8_t * data_end = data + data_sz ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> <S2SV_StartBug> int frames_this_pts , frame_count = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( data == NULL || data_sz == 0 ) <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> <S2SV_StartBug> parse_superframe_index ( data , data_sz , sizes , & frames_this_pts ) ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t marker = * data_start ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> ; uint32_t frame_sizes <S2SV_ModEnd> <S2SV_ModStart> frame_count <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> { ctx -> flushed = 1 ; return VPX_CODEC_OK ; } ctx -> flushed = 0 ; if ( ctx -> frame_workers == NULL ) { const vpx_codec_err_t res = init_decoder ( ctx ) ; if ( res != VPX_CODEC_OK ) return res ; } res = vp9_parse_superframe_index <S2SV_ModEnd> <S2SV_ModStart> frame_sizes , & frame_count , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( res != VPX_CODEC_OK ) return res ; if ( ctx -> frame_parallel_decode ) { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ; return VPX_CODEC_CORRUPT_FRAME ; } if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data , data_sz , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; } } else { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; vpx_codec_err_t res ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ; return VPX_CODEC_CORRUPT_FRAME ; } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { while ( data_start < data_end ) { const uint32_t frame_size = ( uint32_t ) ( data_end - data_start ) ; const vpx_codec_err_t res = decode_one ( ctx , & data_start , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; while ( data_start < data_end <S2SV_ModEnd> <S2SV_ModStart> read_marker ( ctx -> decrypt_cb , ctx -> decrypt_state , data_start ) ; if ( marker ) break ; ++ data_start ; } } } } <S2SV_ModEnd> "
1688,"<S2SV_StartBug> opts = fcntl ( s , F_GETFL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fcntl ( s , F_SETFL , opts ) < 0 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
1689,<S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ,"<S2SV_ModStart> ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries "
1690,<S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ,<S2SV_ModStart> ; bpcc -> bpcs = 0 
1691,"<S2SV_StartBug> assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; "
1692,"<S2SV_StartBug> struct resv_map * reservations = vma_resv_map ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ; <S2SV_EndBug> ",<S2SV_ModStart> ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> hugepage_subpool_put_pages ( spool <S2SV_ModEnd> 
1693,<S2SV_StartBug> szLineConv [ i ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; 
1694,<S2SV_StartBug> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) <S2SV_EndBug> ,<S2SV_ModStart> IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> 
1695,"<S2SV_StartBug> long length , offset , size , at ; <S2SV_EndBug> <S2SV_StartBug> goto exit_toc ; <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%li,\\n"" <S2SV_EndBug> <S2SV_StartBug> unsigned long in_remaining = length ; <S2SV_EndBug> <S2SV_StartBug> int lret ; <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , <S2SV_EndBug> <S2SV_StartBug> length , at , errbuff ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned long write_len ; <S2SV_EndBug> <S2SV_StartBug> write_len = MIN ( ( size_t ) ( ctx -> engine -> maxfilesize ) , ( size_t ) length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( blockp = ( void * ) fmap_need_off_once ( map , at , length ) ) ) { <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , <S2SV_EndBug> <S2SV_StartBug> xar_hash_update ( a_hash_ctx , blockp , length , a_hash ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cli_writen ( fd , blockp , write_len ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n"" , length , at ) ; <S2SV_EndBug> <S2SV_StartBug> cli_warnmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors,<S2SV_blank>use<S2SV_blank>--debug<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info.\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> ; } if ( hdr . toc_length_decompressed != strm . total_out ) { cli_dbgmsg ( ""TOC<S2SV_blank>decompress<S2SV_blank>length<S2SV_blank>%"" PRIu64 ""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>amount<S2SV_blank>decompressed<S2SV_blank>%lu\\n"" , hdr . toc_length_decompressed , strm . total_out ) ; toc [ strm . total_out ] = '\\0' ; hdr . toc_length_decompressed = strm . total_out <S2SV_ModStart> ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%zu,\\n"" ""from<S2SV_blank>xar<S2SV_blank>heap<S2SV_blank>offset<S2SV_blank>%zu<S2SV_blank>length<S2SV_blank>%zu\\n"" <S2SV_ModEnd> <S2SV_ModStart> MIN ( length , map -> len - at ) <S2SV_ModEnd> <S2SV_ModStart> ; if ( length > in_remaining ) length = in_remaining <S2SV_ModStart> ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , CLI_LZMA_HDR_SIZE <S2SV_ModEnd> <S2SV_ModStart> lz . avail_in <S2SV_ModEnd> <S2SV_ModStart> size_t writelen = MIN ( map -> len - at , length ) <S2SV_ModEnd> <S2SV_ModStart> writelen <S2SV_ModEnd> <S2SV_ModStart> writelen ) <S2SV_ModEnd> <S2SV_ModStart> writelen <S2SV_ModEnd> <S2SV_ModStart> ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%zu,<S2SV_blank>errno:%s.\\n"" , writelen <S2SV_ModEnd> <S2SV_ModStart> writelen <S2SV_ModEnd> <S2SV_ModStart> writelen <S2SV_ModEnd> <S2SV_ModStart> ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n"" , writelen <S2SV_ModEnd> <S2SV_ModStart> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors.\\n"" <S2SV_ModEnd> "
1696,<S2SV_StartBug> opt_type = * bp ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } "
1697,"<S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; 
1698,<S2SV_StartBug> uchar buf [ PGX_MAGICLEN ] ; <S2SV_EndBug> ,<S2SV_ModStart> jas_uchar <S2SV_ModEnd> 
1699,<S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( depth >= 64 ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
1700,"<S2SV_StartBug> void * data , <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int mi_size ) { <S2SV_EndBug> <S2SV_StartBug> const int64_t threshold_multiplier = 25 ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> vt . part_variances -> vert [ 0 ] . variance < threshold && <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col + block_width / 2 , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row + block_height / 2 , mi_col , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> MACROBLOCK * const x , MACROBLOCKD * const xd , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> int64_t threshold , BLOCK_SIZE bsize_min , int force_split <S2SV_ModEnd> <S2SV_ModStart> int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) <S2SV_ModEnd> <S2SV_ModStart> force_split == 1 ) return 0 ; if ( bsize == bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( <S2SV_ModStart> x , xd , mi_row , mi_col , bsize ) ; return 1 ; } return 0 ; } else if ( bsize > bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( cm -> frame_type == KEY_FRAME && ( bsize > BLOCK_32X32 || vt . part_variances -> none . variance > ( threshold << 4 ) ) ) { return 0 ; } if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_ModEnd> <S2SV_ModStart> none <S2SV_ModEnd> <S2SV_ModStart> ) { set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ; return 1 ; } if ( mi_row + block_height / 2 < cm -> mi_rows <S2SV_ModEnd> <S2SV_ModStart> get_variance ( & vt . part_variances -> vert [ 0 ] ) ; get_variance ( & vt . part_variances -> vert [ 1 ] ) ; if ( vt . part_variances -> vert [ 0 ] . variance < threshold && vt . part_variances -> vert [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_variance ( & vt . part_variances -> horz [ 0 ] ) ; get_variance ( & vt . part_variances -> horz [ 1 ] ) ; if ( vt . part_variances -> horz [ 0 ] . variance < threshold && vt . part_variances -> horz [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> x , xd <S2SV_ModEnd> <S2SV_ModStart> } return 0 ; } "
1701,"<S2SV_StartBug> static void perf_event_output ( struct perf_event * event , int nmi , <S2SV_EndBug> <S2SV_StartBug> if ( perf_output_begin ( & handle , event , header . size , nmi , 1 ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
1702,"<S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug> ","<S2SV_ModStart> le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if ( "
1703,<S2SV_StartBug> ret = fscrypt_get_crypt_info ( dir ) ; <S2SV_EndBug> ,<S2SV_ModStart> fscrypt_get_encryption_info <S2SV_ModEnd> 
1704,<S2SV_StartBug> opts -> max_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> opts -> max_size = atoi ( jas_tvparser_getval ( tvp ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> max_samples = 64 * JAS_MEBI <S2SV_ModEnd> <S2SV_ModStart> max_samples <S2SV_ModEnd> 
1705,<S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> ,"<S2SV_ModStart> fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n"" ) ; "
