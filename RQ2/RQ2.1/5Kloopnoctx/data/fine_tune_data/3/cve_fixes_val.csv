,source,target
0,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ; "
1,"<S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> const int64_t diff = oxcf -> optimal_buffer_level - rc -> buffer_level ; <S2SV_EndBug> <S2SV_StartBug> const int64_t one_pct_bits = 1 + oxcf -> optimal_buffer_level / 100 ; <S2SV_EndBug> <S2SV_StartBug> int min_frame_target = MAX ( rc -> av_per_frame_bandwidth >> 4 , <S2SV_EndBug> <S2SV_StartBug> int target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 && <S2SV_EndBug> <S2SV_StartBug> const LAYER_CONTEXT * lc = & svc -> layer_context [ current_temporal_layer ] ; <S2SV_EndBug> <S2SV_StartBug> return MAX ( min_frame_target , target ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9EncoderConfig <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> <S2SV_ModStart> avg_frame_bandwidth <S2SV_ModEnd> <S2SV_ModStart> ; if ( oxcf -> gf_cbr_boost_pct ) { const int af_ratio_pct = oxcf -> gf_cbr_boost_pct + 100 ; target = cpi -> refresh_golden_frame ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio_pct ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) : ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * 100 ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) ; } else { target = rc -> avg_frame_bandwidth ; } if ( is_one_pass_cbr_svc ( cpi ) ) { int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> layer <S2SV_ModEnd> <S2SV_ModStart> if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; } "
2,"<S2SV_StartBug> . dump = link -> dump , <S2SV_EndBug> ","<S2SV_ModStart> start = link -> start , . "
3,<S2SV_StartBug> if ( ! ( mask & KADM5_ATTRIBUTES ) || <S2SV_EndBug> ,<S2SV_ModStart> password == NULL || 
4,<S2SV_StartBug> struct address_space * mapping = page -> mapping ; <S2SV_EndBug> ,<S2SV_ModStart> page_file_mapping ( page ) <S2SV_ModEnd> 
5,<S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> - 1 <S2SV_ModEnd> <S2SV_ModStart> if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> - 1 <S2SV_ModEnd> 
6,"<S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
7,"<S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> "
8,<S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
9,"<S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ; msg -> msg_namelen = 0 <S2SV_ModStart> msg -> msg_namelen = sizeof ( * sin ) ; 
10,"<S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) <S2SV_ModStart> ) ; rcu_read_unlock ( 
11,"<S2SV_StartBug> u8 obuf [ ] = { 0xde , 0 } ; <S2SV_EndBug> <S2SV_StartBug> state -> initialized = 1 ; <S2SV_EndBug> <S2SV_StartBug> return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int ret = 0 <S2SV_ModEnd> <S2SV_ModStart> mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> 
12,"<S2SV_StartBug> const char * arch = info -> arch ; <S2SV_EndBug> <S2SV_StartBug> if ( info -> cpu && * info -> cpu ) { <S2SV_EndBug> <S2SV_StartBug> r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ; <S2SV_EndBug> <S2SV_StartBug> r_core_bin_set_cur ( r , binfile ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( cpu ) ; free ( arch 
13,"<S2SV_StartBug> int ip_options_get ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( opt -> __data , data , optlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . 
14,"<S2SV_StartBug> change = ue -> tlv_data_size != size ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> return - ENXIO ; <S2SV_EndBug> <S2SV_StartBug> if ( size < ue -> tlv_data_size ) <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto err_unlock ; } <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto err_unlock ; } <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ; 
15,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> "
16,<S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cifs_small_buf_release ( req ) ; 
17,"<S2SV_StartBug> struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ; <S2SV_EndBug> <S2SV_StartBug> netdev_notifier_info_init ( & info , dev ) ; <S2SV_EndBug> ",<S2SV_ModStart> in_device * idev <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( idev -> dead ) return NOTIFY_DONE ; <S2SV_ModStart> idev -> 
18,<S2SV_StartBug> v |= ( c << 24 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> "
19,"<S2SV_StartBug> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> SCTP_CMD_SET_ASOC <S2SV_ModEnd> 
20,"<S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , ""w"" ) ; <S2SV_EndBug> <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> ","<S2SV_ModStart> = fopen_safe <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> "
21,"<S2SV_StartBug> run_cmd ( int fd , ... ) <S2SV_EndBug> <S2SV_StartBug> char cmd [ 512 ] ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> strcpy ( cmd , EXEC ) ; <S2SV_EndBug> <S2SV_StartBug> fd_printf ( STDERR_FILENO , ""%s\\n"" , & cmd [ sizeof ( EXEC ) - 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( 42 ) ; <S2SV_EndBug> ","<S2SV_ModStart> const char * cmd , const char * args_extra <S2SV_ModEnd> <S2SV_ModStart> int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> <S2SV_ModStart> argc = 0 ; r = split_quoted <S2SV_ModEnd> <S2SV_ModStart> & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>command\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , ""No<S2SV_blank>command<S2SV_blank>given\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , ""$<S2SV_blank>%s<S2SV_blank>%s\\n"" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <S2SV_ModEnd> <S2SV_ModStart> ""exec:<S2SV_blank>%s\\n"" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> RUNCMD_EXEC_FAIL <S2SV_ModEnd> "
22,"<S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ; <S2SV_EndBug> <S2SV_StartBug> if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; <S2SV_EndBug> ","<S2SV_ModStart> manager_ctx * manager , struct <S2SV_ModStart> ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method <S2SV_ModStart>  <S2SV_ModEnd> "
23,<S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> sysctl_head_finish ( head ) ; <S2SV_EndBug> ,<S2SV_ModStart> goto out <S2SV_ModEnd> <S2SV_ModStart> out : 
24,"<S2SV_StartBug> char * dest , * src ; <S2SV_EndBug> <S2SV_StartBug> dest = src = a -> name ; <S2SV_EndBug> <S2SV_StartBug> if ( * src == '\\0' ) { <S2SV_EndBug> <S2SV_StartBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , <S2SV_EndBug> <S2SV_StartBug> # if defined ( __CYGWIN__ ) <S2SV_EndBug> <S2SV_StartBug> return ( ARCHIVE_FAILED ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = cleanup_pathname_fsobj ( <S2SV_ModEnd> <S2SV_ModStart> , & error_number , & error_string , a -> flags ) <S2SV_ModStart> rc != ARCHIVE_OK <S2SV_ModEnd> <S2SV_ModStart> error_number , ""%s"" , error_string . s <S2SV_ModEnd> <S2SV_ModStart> archive_string_free ( & error_string <S2SV_ModEnd> <S2SV_ModStart> rc <S2SV_ModEnd> "
25,<S2SV_StartBug> ps_dec -> s_high_profile . u1_scaling_present = 0 ; <S2SV_EndBug> <S2SV_StartBug> ps_dec -> u2_cur_slice_num = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> u2_cur_slice_num = 0 ; ps_dec -> <S2SV_ModStart>  <S2SV_ModEnd> 
26,"<S2SV_StartBug> struct mb_cache * <S2SV_EndBug> <S2SV_StartBug> ext4_xattr_create_cache ( char * name ) <S2SV_EndBug> <S2SV_StartBug> return mb_cache_create ( name , HASH_BUCKET_BITS ) ; <S2SV_EndBug> ",<S2SV_ModStart> mb2_cache <S2SV_ModEnd> <S2SV_ModStart> void <S2SV_ModEnd> <S2SV_ModStart> mb2_cache_create ( <S2SV_ModEnd> 
27,<S2SV_StartBug> DEFiRet ; <S2SV_EndBug> <S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> ,"<S2SV_ModStart> int bHaveUnprocessed ; DEFiRet ; do { bHaveUnprocessed = 0 ; for ( iStart = 0 ; iStart < pBatch -> nElem && pBatch -> pElem [ iStart ] . state == BATCH_STATE_DISC ; ++ iStart ) ; if ( iStart == pBatch -> nElem ) break ; <S2SV_ModEnd> <S2SV_ModStart> currRuleset = batchElemGetRuleset ( pBatch , iStart ) ; iNew = 0 ; for ( i = iStart ; i < pBatch -> nElem ; ++ i ) { if ( batchElemGetRuleset ( pBatch , i ) == currRuleset ) { snglRuleBatch . pElem [ iNew ] . pUsrp = pBatch -> pElem [ i ] . pUsrp ; snglRuleBatch . pElem [ iNew ] . state = pBatch -> pElem [ i ] . state ; ++ iNew ; pBatch -> pElem [ i ] . state = BATCH_STATE_DISC ; } else { bHaveUnprocessed = 1 ; } } snglRuleBatch . nElem = iNew ; batchSetSingleRuleset ( & snglRuleBatch , 1 ) ; processBatch ( & snglRuleBatch ) ; batchFree ( & snglRuleBatch ) ; } while ( bHaveUnprocessed == 1 <S2SV_ModEnd> "
28,"<S2SV_StartBug> h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> <S2SV_StartBug> h -> emptyFileBools = calloc ( empty_streams , <S2SV_EndBug> <S2SV_StartBug> h -> antiBools = calloc ( empty_streams , <S2SV_EndBug> <S2SV_StartBug> if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) <S2SV_EndBug> <S2SV_StartBug> h -> attrBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> ",<S2SV_ModStart> if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> ) return ( - 1 ) ; if ( zip -> entry_names != NULL <S2SV_ModStart> if ( h -> attrBools != NULL ) return ( - 1 ) ; 
29,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> <S2SV_StartBug> ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> ","<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""Rootname:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> "
30,"<S2SV_StartBug> ngx_uint_t n , sec , min , hour , mday , mon , year , wday , days , leap ; <S2SV_EndBug> <S2SV_StartBug> n = ( ngx_uint_t ) t ; <S2SV_EndBug> <S2SV_StartBug> wday = ( 4 + days ) % 7 ; <S2SV_EndBug> <S2SV_StartBug> n %= 86400 ; <S2SV_EndBug> <S2SV_StartBug> n %= 3600 ; <S2SV_EndBug> <S2SV_StartBug> min = n / 60 ; <S2SV_EndBug> <S2SV_StartBug> sec = n % 60 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( t < 0 ) { t = 0 ; } days = t <S2SV_ModEnd> <S2SV_ModStart> sec = t % 86400 ; <S2SV_ModStart> hour = sec <S2SV_ModEnd> <S2SV_ModStart> sec <S2SV_ModEnd> <S2SV_ModStart> sec <S2SV_ModEnd> <S2SV_ModStart> %= <S2SV_ModEnd> 
31,<S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
32,"<S2SV_StartBug> int len ; <S2SV_EndBug> <S2SV_StartBug> if ( config . hostsocket != NULL ) <S2SV_EndBug> <S2SV_StartBug> len = snprintf ( config . prompt , sizeof ( config . prompt ) , ""redis<S2SV_blank>%s"" , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sds prompt = sdsempty ( ) ; <S2SV_ModStart> { prompt = sdscatfmt ( prompt , ""redis<S2SV_blank>%s"" , config . hostsocket ) ; } else { char addr [ 256 ] ; anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ; prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ; } if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , ""[%i]"" , config . dbnum ) ; prompt = sdscatlen ( prompt , ""><S2SV_blank>"" , 2 ) ; <S2SV_ModEnd> <S2SV_ModStart> ""%s"" , prompt ) ; sdsfree ( prompt <S2SV_ModEnd> "
33,<S2SV_StartBug> total = le32_to_cpu ( raw_super -> segment_count ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( f2fs_cp_error ( sbi ) ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int main_segs , blocks_per_seg ; int i ; <S2SV_ModStart> main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } "
34,<S2SV_StartBug> __be16 type ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1 
35,"<S2SV_StartBug> . dump = link -> dump , <S2SV_EndBug> ","<S2SV_ModStart> start = link -> start , . "
36,"<S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! dev && capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> int no_module ; <S2SV_ModStart> no_module = ! dev ; if ( no_module <S2SV_ModEnd> <S2SV_ModStart> no_module = request_module ( ""netdev-%s"" , name ) ; if ( no_module && capable ( CAP_SYS_MODULE ) ) { if ( ! <S2SV_ModStart> ) pr_err ( ""Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>"" ""with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>"" ""instead\\n"" , name ) ; } } <S2SV_ModEnd> "
37,<S2SV_StartBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ; <S2SV_EndBug> <S2SV_StartBug> cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_EndBug> ,<S2SV_ModStart> ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS 
38,"<S2SV_StartBug> if ( setting_MakeCompatCore && ulimit_c != 0 ) <S2SV_EndBug> <S2SV_StartBug> dd = dd_create_skeleton ( path , fsuid , DEFAULT_DUMP_DIR_MODE , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> const uid_t dduid = g_settings_privatereports ? 0 : fsuid ; <S2SV_ModStart> dduid <S2SV_ModEnd> 
39,"<S2SV_StartBug> logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; <S2SV_EndBug> <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; quantum_info = ( QuantumInfo * ) NULL <S2SV_ModStart> if ( quantum_info != ( QuantumInfo * ) NULL ) 
40,"<S2SV_StartBug> static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags ) { <S2SV_EndBug> <S2SV_StartBug> nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
41,"<S2SV_StartBug> const uint8_t * * remainder_out , size_t * rlen_out ) <S2SV_EndBug> <S2SV_StartBug> p = asn1 ; <S2SV_EndBug> <S2SV_StartBug> ret = get_tag ( p , len , & t , & c , & clen , & p , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , int recursion <S2SV_ModStart> if ( recursion >= 32 ) return ASN1_OVERFLOW ; <S2SV_ModStart> , recursion + 1 "
42,"<S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ; "
43,<S2SV_StartBug> if ( code == gcode ) <S2SV_EndBug> ,<S2SV_ModStart> && wordlist [ key ] . index >= 0 
44,<S2SV_StartBug> static void <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
45,"<S2SV_StartBug> int copied , err ; <S2SV_EndBug> <S2SV_StartBug> sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_EndBug> <S2SV_StartBug> if ( sock -> type == SOCK_PACKET ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> copied = skb -> len ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_name ) <S2SV_EndBug> <S2SV_StartBug> msg -> msg_namelen ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> <S2SV_ModStart> } memcpy <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } "
46,"<S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> ",<S2SV_ModStart> file -> f_cred -> fsuid <S2SV_ModEnd> <S2SV_ModStart> file -> f_cred -> fsgid <S2SV_ModEnd> 
47,<S2SV_StartBug> char * ret ; <S2SV_EndBug> <S2SV_StartBug> if ( ptr [ strlen ( ptr ) - 1 ] == '\\n' ) <S2SV_EndBug> <S2SV_StartBug> ptr [ strlen ( ptr ) - 1 ] = '\\0' ; <S2SV_EndBug> ,<S2SV_ModStart> ; size_t len <S2SV_ModStart> len = <S2SV_ModEnd> <S2SV_ModStart> ; if ( len > 0 && ptr [ len <S2SV_ModStart> len <S2SV_ModEnd> 
48,<S2SV_StartBug> fid -> udf . generation = inode -> i_generation ; <S2SV_EndBug> ,<S2SV_ModStart> parent_partref = 0 ; fid -> udf . 
49,"<S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> if ( k < 0 ) continue <S2SV_ModEnd> 
50,<S2SV_StartBug> SEPARATE_ZVAL ( ( var ) ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . x = Z_LVAL_PP ( var ) ; <S2SV_EndBug> <S2SV_StartBug> SEPARATE_ZVAL ( var ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . y = Z_LVAL_PP ( var ) ; <S2SV_EndBug> <S2SV_StartBug> if ( filled ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> <S2SV_ModStart> & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { points [ i ] . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> <S2SV_ModStart> & lval <S2SV_ModEnd> <S2SV_ModStart> Z_LVAL ( lval ) ; } else { points [ i ] . y = <S2SV_ModStart> } 
51,"<S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! _gdImageGifCtx <S2SV_ModEnd> <S2SV_ModStart> ) { <S2SV_ModEnd> <S2SV_ModStart> } else { rv = NULL ; } 
52,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> ( void ) mbmi ; 
53,"<S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ipt_entry * e <S2SV_ModEnd> <S2SV_ModStart> e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> 
54,"<S2SV_StartBug> err = bnep_add_connection ( & ca , nsock ) ; <S2SV_EndBug> ",<S2SV_ModStart> ca . device [ sizeof ( ca . device ) - 1 ] = 0 ; 
55,"<S2SV_StartBug> vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
56,<S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> ,<S2SV_ModStart> char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
57,<S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> ,<S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> <S2SV_ModStart> bailout <S2SV_ModEnd> 
58,<S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> while <S2SV_ModEnd> <S2SV_ModStart> ++ 
59,"<S2SV_StartBug> ftpClientFormatCommand ( context , ""LIST"" , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> ftpClientFormatCommand ( context , ""LIST"" , path ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
60,"<S2SV_StartBug> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> "
61,<S2SV_StartBug> req -> started = false ; <S2SV_EndBug> <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> ,"<S2SV_ModStart> dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
62,<S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulonglong <S2SV_ModEnd> 
63,<S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ninst == 0 ) return - E_INVALID 
64,<S2SV_StartBug> return new_ns ; <S2SV_EndBug> ,<S2SV_ModStart> new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ; 
65,<S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> ,<S2SV_ModStart> SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> 
66,<S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> ,"<S2SV_ModStart> bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> <S2SV_ModStart> F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
67,"<S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> done : <S2SV_EndBug> ","<S2SV_ModStart> = 0 ; size_t data_size <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } "
68,"<S2SV_StartBug> ast_for_for_stmt ( struct compiling * c , const node * n , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> type_comment , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> ","<S2SV_ModStart> n0 , bool <S2SV_ModEnd> <S2SV_ModStart> const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> n0 ) , n0 <S2SV_ModEnd> "
69,<S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> ,<S2SV_ModStart> && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) 
70,"<S2SV_StartBug> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <S2SV_EndBug> <S2SV_StartBug> snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>\\""%s\\"""" , subscribe ? """" : ""un"" , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t len = 0 ; <S2SV_ModStart> len = <S2SV_ModStart> ""%smailboxes<S2SV_blank>"" <S2SV_ModEnd> <S2SV_ModStart> ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <S2SV_ModEnd> "
71,<S2SV_StartBug> dsize += svbranch . len ; <S2SV_EndBug> ,<S2SV_ModStart> + 1 
72,<S2SV_StartBug> length = icon_file . directory [ i ] . size ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) "
73,<S2SV_StartBug> if ( old -> curframe != cur -> curframe ) <S2SV_EndBug> ,<S2SV_ModStart> ) return false ; if ( old -> speculative && ! cur -> speculative 
74,"<S2SV_StartBug> * image ; <S2SV_EndBug> <S2SV_StartBug> value , <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . red = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . green = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . blue = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . red = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . green = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; int c <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( MagickRealType ) <S2SV_ModStart> ( MagickRealType ) <S2SV_ModStart> ( MagickRealType ) <S2SV_ModStart> 0.0 <S2SV_ModEnd> <S2SV_ModStart> 0.0 <S2SV_ModEnd> <S2SV_ModStart> 0.0 <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> ; if ( c < 0 ) break <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> c <S2SV_ModEnd> <S2SV_ModStart> ; if ( c < 0 ) break <S2SV_ModStart> c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) <S2SV_ModEnd> <S2SV_ModStart> unsigned int <S2SV_ModEnd> "
75,"<S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> 1 , <S2SV_ModStart> 1 , <S2SV_ModStart> 0 , "
76,<S2SV_StartBug> int rv ; <S2SV_EndBug> ,"<S2SV_ModStart> ; clear_bit ( WDM_OVERFLOW , & desc -> flags ) "
77,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
78,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return vm_iomap_memory <S2SV_ModEnd> <S2SV_ModStart> fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> "
79,"<S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 
80,"<S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> <S2SV_StartBug> status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_LINKIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_PKTIE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ( EIR_TXIF | EIE_TXERIE ) ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIE_TXERIE ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> ","<S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR_LINKIF <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_LINKIE <S2SV_ModEnd> <S2SV_ModStart> enc28j60ReadReg ( interface , ENC28J60_EPKTCNT <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_PKTIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> "
81,<S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> ,<S2SV_ModStart> if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; 
82,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
83,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
84,"<S2SV_StartBug> static int t220_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x86 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> obuf [ 0 ] = 0xe ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 1 ] = 0x80 ; <S2SV_EndBug> <S2SV_StartBug> obuf [ 2 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> msleep ( 50 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_EndBug> <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( cxd2820r_attach , & cxd2820r_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe != NULL ) { <S2SV_EndBug> <S2SV_StartBug> if ( dvb_attach ( tda18271_attach , d -> fe_adap [ 0 ] . fe , 0x60 , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap , & tda18271_config ) ) { <S2SV_EndBug> ","<S2SV_ModStart> adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 1 ] = 0x80 ; state -> data <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> msleep ( 50 ) ; state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> , state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data <S2SV_ModEnd> <S2SV_ModStart> state -> data [ 0 ] = 0x51 <S2SV_ModEnd> <S2SV_ModStart> , state -> data , 1 , state -> data <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart> adap <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
85,"<S2SV_StartBug> if ( ! validate_event ( & fake_pmu , leader ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , sibling ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , event ) ) <S2SV_EndBug> ","<S2SV_ModStart> event -> pmu , <S2SV_ModStart> event -> pmu , <S2SV_ModStart> event -> pmu , "
86,"<S2SV_StartBug> fd = open ( authfile , O_RDONLY , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> goto err ; <S2SV_EndBug> <S2SV_StartBug> else if ( fd >= 0 ) <S2SV_EndBug> ",<S2SV_ModStart> | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> <S2SV_ModStart> ; } else { fd = - 1 <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> != - 1 <S2SV_ModEnd> 
87,<S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING 
88,"<S2SV_StartBug> if ( ACTION ( RUN ) ) <S2SV_EndBug> <S2SV_StartBug> handle_do_action ( req , res ) ; <S2SV_EndBug> <S2SV_StartBug> handle_action ( req , res ) ; <S2SV_EndBug> ","<S2SV_ModStart> RUNTIME ) ) handle_runtime_action ( req , res ) ; else if ( ACTION ( VIEWLOG ) ) do_viewlog <S2SV_ModEnd> <S2SV_ModStart> handle_doaction <S2SV_ModEnd> <S2SV_ModStart> handle_service_action <S2SV_ModEnd> "
89,"<S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> ",<S2SV_ModStart> kvm_get_kvm ( kvm ) ; <S2SV_ModStart> kvm_put_kvm ( kvm ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
90,<S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; } "
91,"<S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> txtLen <S2SV_ModEnd> <S2SV_ModStart> snprintf ( txt , txtLeft <S2SV_ModEnd> <S2SV_ModStart> txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> txt , txtLeft - 1 <S2SV_ModEnd> "
92,<S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> ,<S2SV_ModStart> INADDR_LOOPBACK <S2SV_ModEnd> 
93,"<S2SV_StartBug> while ( ! EOFBlob ( image ) ) <S2SV_EndBug> <S2SV_StartBug> if ( filepos != ( unsigned int ) filepos ) <S2SV_EndBug> <S2SV_StartBug> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <S2SV_EndBug> <S2SV_StartBug> ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> filepos < GetBlobSize ( image ) && <S2SV_ModStart> > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> <S2SV_ModStart> >= <S2SV_ModEnd> <S2SV_ModStart> ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" "
94,"<S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> ",<S2SV_ModStart> const 
95,"<S2SV_StartBug> static void vp8_init_ctx ( vpx_codec_ctx_t * ctx , const vpx_codec_mmap_t * mmap ) <S2SV_EndBug> <S2SV_StartBug> ctx -> priv = mmap -> base ; <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> config . dec ) <S2SV_EndBug> <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> ","<S2SV_ModStart> ) { vpx_codec_alg_priv_t * priv = ( vpx_codec_alg_priv_t * ) vpx_calloc ( 1 , sizeof ( * priv ) ) <S2SV_ModEnd> <S2SV_ModStart> ( vpx_codec_priv_t * ) priv <S2SV_ModEnd> <S2SV_ModStart> priv -> si . sz = sizeof ( priv -> si ) ; priv -> decrypt_cb = NULL ; priv -> decrypt_state = NULL ; <S2SV_ModStart> priv <S2SV_ModEnd> <S2SV_ModStart> priv <S2SV_ModEnd> "
96,"<S2SV_StartBug> int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; <S2SV_EndBug> <S2SV_StartBug> uint16 bps , nstrips , planar , strips_per_sample ; <S2SV_EndBug> ","<S2SV_ModStart> bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> <S2SV_ModStart> planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> "
97,"<S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> <S2SV_StartBug> unsigned v ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; size_t copy <S2SV_ModStart> copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> <S2SV_ModStart> copy <S2SV_ModEnd> <S2SV_ModStart> copy + 1 <S2SV_ModEnd> "
98,"<S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> ",<S2SV_ModStart> PAGE_KERNEL <S2SV_ModEnd> 
99,"<S2SV_StartBug> rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb , <S2SV_EndBug> ",<S2SV_ModStart> foreach_shareopt <S2SV_ModEnd> 
100,<S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return AVERROR_PATCHWELCOME ; } "
101,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
102,<S2SV_StartBug> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ; 
103,<S2SV_StartBug> if ( esd ) { <S2SV_EndBug> ,<S2SV_ModStart> && esd -> decoderConfig 
104,"<S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> ",<S2SV_ModStart> cache_id ( <S2SV_ModStart> ) 
105,<S2SV_StartBug> if ( val == 0 && sp -> do_auto_asconf ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; 
106,<S2SV_StartBug> char * authn_header = oidc_cfg_dir_authn_header ( r ) ; <S2SV_EndBug> ,<S2SV_ModStart> oidc_scrub_headers ( r ) ; 
107,<S2SV_StartBug> char fnam [ PROCLEN ] ; <S2SV_EndBug> <S2SV_StartBug> char * line = NULL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( nextcg ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp <S2SV_ModEnd> <S2SV_ModStart> return false <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> out : free ( c2 <S2SV_ModEnd> "
108,"<S2SV_StartBug> if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , <S2SV_EndBug> ","<S2SV_ModStart> _open_as_other ( path_name , req <S2SV_ModEnd> <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied"" , path_name <S2SV_ModEnd> "
109,<S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
110,"<S2SV_StartBug> static char * <S2SV_EndBug> <S2SV_StartBug> if ( enc == NULL ) <S2SV_EndBug> <S2SV_StartBug> char * dec = g_strdup ( enc ) ; <S2SV_EndBug> <S2SV_StartBug> g_base64_decode_inplace ( dec , & len ) ; <S2SV_EndBug> ",<S2SV_ModStart> gchar <S2SV_ModEnd> <S2SV_ModStart> gchar * dec ; gsize len ; <S2SV_ModStart> dec = ( gchar * ) g_base64_decode ( enc <S2SV_ModEnd> <S2SV_ModStart> if ( dec ) 
111,<S2SV_StartBug> if ( socket -> interface != NULL ) <S2SV_EndBug> ,<S2SV_ModStart> if ( message -> interface != NULL ) { interface = message -> interface ; } else 
112,<S2SV_StartBug> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; <S2SV_EndBug> ,"<S2SV_ModStart> TIFFhowmany_32_maxuint_compat <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> "
113,<S2SV_StartBug> if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) <S2SV_EndBug> ,<S2SV_ModStart> validate_core_offset ( reg ) ) return - EINVAL ; if ( 
114,"<S2SV_StartBug> safe_print ( value , valsz , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> safe_print ( value , valsz , ""\\"""" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""<S2SV_blank>\\\\\\""\'$`<>"" <S2SV_ModEnd> <S2SV_ModStart> ""\\""\\\\"" ) ; fputs ( ""\\"""" <S2SV_ModEnd> "
115,<S2SV_StartBug> if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( SSL_USE_ETM ( s ) && mac_size != 0 ) { <S2SV_EndBug> ,<S2SV_ModStart> SSL_WRITE_ETM <S2SV_ModEnd> <S2SV_ModStart> SSL_WRITE_ETM <S2SV_ModEnd> 
116,"<S2SV_StartBug> static int read_frame_stats ( const struct twopass_rc * p , <S2SV_EndBug> <S2SV_StartBug> const FIRSTPASS_STATS * fps_ptr = p -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> if ( offset >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] >= p -> stats_in_end ) <S2SV_EndBug> <S2SV_StartBug> } else if ( offset < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] < p -> stats_in_start ) <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> const FIRSTPASS_STATS * <S2SV_ModEnd> <S2SV_ModStart> TWO_PASS * p <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> && p -> stats_in + offset <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> && p -> stats_in + offset <S2SV_ModEnd> <S2SV_ModStart> ) { return NULL ; } return & p -> stats_in <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
117,<S2SV_StartBug> goto err_unregister_v4l2_dev ; <S2SV_EndBug> <S2SV_StartBug> err_unregister_v4l2_dev : <S2SV_EndBug> ,<S2SV_ModStart> err_free_controls <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
118,"<S2SV_StartBug> static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
119,<S2SV_StartBug> if ( noblock ) <S2SV_EndBug> ,<S2SV_ModStart> cond_resched ( ) <S2SV_ModEnd> 
120,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> key_is_positive ( key <S2SV_ModEnd> 
121,"<S2SV_StartBug> for ( j = 0 ; j < len ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
122,<S2SV_StartBug> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ret = - ENOTCONN ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> lock_sock ( sk ) ; <S2SV_ModStart> release_sock ( sk ) ; <S2SV_ModStart> release_sock ( sk ) ; 
123,<S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m1 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m2 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> <S2SV_ModStart> { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> <S2SV_ModStart> Z_DVAL ( dval ) ; } <S2SV_ModEnd> 
124,<S2SV_StartBug> jas_stream_t * stream ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( stream = jas_stream_create ( ) ) ) { <S2SV_EndBug> <S2SV_StartBug> obj -> bufsize_ = 1024 ; <S2SV_EndBug> <S2SV_StartBug> obj -> bufsize_ = bufsize ; <S2SV_EndBug> <S2SV_StartBug> obj -> growable_ = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> char * new_buf ; size_t new_bufsize <S2SV_ModEnd> <S2SV_ModStart> bufsize < 0 ) { jas_deprecated ( ""negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen"" ) ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( ""Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n"" ) ; jas_deprecated ( ""A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>"" ""jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n"" ) ; } <S2SV_ModEnd> <S2SV_ModStart> new_bufsize = 0 ; new_buf = 0 <S2SV_ModEnd> <S2SV_ModStart> new_bufsize <S2SV_ModEnd> <S2SV_ModStart> new_buf = buf ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) <S2SV_ModEnd> "
125,<S2SV_StartBug> if ( sk -> sk_protocol == IPPROTO_TCP ) <S2SV_EndBug> ,<S2SV_ModStart> && sk -> sk_type == SOCK_STREAM 
126,<S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ; "
127,<S2SV_StartBug> overrun = timr -> it_overrun_last ; <S2SV_EndBug> ,"<S2SV_ModStart> timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> "
128,"<S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart>  <S2SV_ModEnd> "
129,"<S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> ","<S2SV_ModStart> uint32 length ; struct stream packet = * s <S2SV_ModEnd> <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; } "
130,"<S2SV_StartBug> int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , getpid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , pid ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( setns ( fd , 0 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> close ( fd ) ; fd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> char ifname [ IFNAMSIZ ] , * namep = ifname ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> goto out_err ; <S2SV_EndBug> <S2SV_StartBug> if ( setns ( ofd , 0 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ","<S2SV_ModStart> uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( <S2SV_ModEnd> <S2SV_ModStart> goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>"" ""user<S2SV_blank>IDs:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <S2SV_ModEnd> <S2SV_ModStart> CLONE_NEWNET ) ; <S2SV_ModEnd> <S2SV_ModStart> fd = - 1 ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>"" ""the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n"" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <S2SV_ModEnd> <S2SV_ModStart> ifindex = if_nametoindex ( oldname ) ; <S2SV_ModStart> ifindex ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n"" , ret , <S2SV_ModEnd> <S2SV_ModStart> ; goto do_full_cleanup <S2SV_ModEnd> <S2SV_ModStart> ; char <S2SV_ModEnd> <S2SV_ModStart> usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> <S2SV_ModStart> do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <S2SV_ModEnd> <S2SV_ModStart> CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>"" ""of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> "
131,<S2SV_StartBug> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> ++ i <S2SV_ModEnd> <S2SV_ModStart> ++ i <S2SV_ModEnd> <S2SV_ModStart> vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; "
132,<S2SV_StartBug> if ( strlen ( parv [ 1 ] ) > 400 ) <S2SV_EndBug> ,"<S2SV_ModStart> ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , ""*"" , ""AUTHENTICATE"" , ""Invalid<S2SV_blank>parameter"" ) ; return 0 ; } if ( "
133,"<S2SV_StartBug> if ( strchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> osStrchr <S2SV_ModEnd> 
134,<S2SV_StartBug> struct dentry * dentry = path -> dentry ; <S2SV_EndBug> <S2SV_StartBug> struct inode * inode = dentry -> d_inode ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vfs_select_inode ( path -> <S2SV_ModEnd> <S2SV_ModStart> file -> f_path = * path ; <S2SV_ModEnd> 
135,<S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; <S2SV_ModStart> ret = <S2SV_ModEnd> <S2SV_ModStart> goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> "
136,"<S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl <S2SV_ModStart> ) return error <S2SV_ModEnd> "
137,<S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> 
138,"<S2SV_StartBug> status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( image == ( Image * ) NULL ) <S2SV_EndBug> ","<S2SV_ModStart> if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
139,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> int i , table_size ; <S2SV_EndBug> <S2SV_StartBug> assert ( dev -> msix . table != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModEnd> <S2SV_ModStart> ) { pr_err ( ""%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>memory!\\n"" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> <S2SV_ModStart> return 0 ; "
140,"<S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> err = crypto_ahash_export ( req , state ) ; <S2SV_EndBug> <S2SV_StartBug> ctx2 -> more = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> bool more ; <S2SV_ModStart> lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> <S2SV_ModStart> : 0 ; release_sock ( sk ) <S2SV_ModStart> more ; if ( ! more ) return err <S2SV_ModEnd> 
141,<S2SV_StartBug> case DB_VECTOR : <S2SV_EndBug> ,"<S2SV_ModStart> AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case "
142,<S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> ,<S2SV_ModStart> 1U << ( unsigned int ) <S2SV_ModEnd> 
143,<S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> ,"<S2SV_ModStart> < p ) { DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n"" , q , p ) ) ; goto out ; } if ( q "
144,<S2SV_StartBug> struct completion * vfork_done = tsk -> vfork_done ; <S2SV_EndBug> ,<S2SV_ModStart> # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif 
145,"<S2SV_StartBug> rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
146,<S2SV_StartBug> void * zmalloc ( size_t size ) { <S2SV_EndBug> ,<S2SV_ModStart> ASSERT_NO_SIZE_OVERFLOW ( size ) ; 
147,<S2SV_StartBug> ret = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> key_put ( keyring ) ; 
148,<S2SV_StartBug> pWTIntFrame -> numSamples = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ; "
149,<S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> switch ( EXTRACT_16BITS ( bp ) ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } return ; <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( bp ) ; 
150,<S2SV_StartBug> int fourcc_is_ivf ( const char detect [ 4 ] ) { <S2SV_EndBug> ,<S2SV_ModStart> static 
151,<S2SV_StartBug> OPJ_UNUSED ( p_manager ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
152,<S2SV_StartBug> int ret ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( current_chrooted ( ) ) return - EPERM 
153,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> GTextFieldSaved ( gt ) ; 
154,<S2SV_StartBug> continue ; <S2SV_EndBug> ,<S2SV_ModStart> buflen ++ ; 
155,<S2SV_StartBug> while ( len -- ) <S2SV_EndBug> <S2SV_StartBug> while ( len -- ) <S2SV_EndBug> ,<S2SV_ModStart> > 0 <S2SV_ModStart> > 0 
156,"<S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
157,"<S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> ","<S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> subtype ) , subtype <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> ND_TCHECK_8BITS ( tptr + 5 ) ; "
158,"<S2SV_StartBug> int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) { <S2SV_EndBug> <S2SV_StartBug> int labelfd = - 1 ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( on_exec ) { <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( write ( labelfd , command , size + 1 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( labelfd != - 1 ) <S2SV_EndBug> <S2SV_StartBug> close ( labelfd ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> static <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> { int fret <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> <S2SV_ModStart> return 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s."" , command ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , command ) ; } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ; } else <S2SV_ModEnd> <S2SV_ModStart> goto out ; } fret = 0 ; <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> lsm_labelfd <S2SV_ModEnd> <S2SV_ModStart> fret <S2SV_ModEnd> "
159,"<S2SV_StartBug> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> ",<S2SV_ModStart> static 
160,"<S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug> ",<S2SV_ModStart> == 0 || apic -> lapic_timer . period 
161,"<S2SV_StartBug> __clear_bit ( * old_keycode , dev -> keybit ) ; <S2SV_EndBug> <S2SV_StartBug> __set_bit ( ke -> keycode , dev -> keybit ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < dev -> keycodemax ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( * old_keycode <= KEY_MAX ) { <S2SV_ModStart> for ( i = 0 ; i < dev -> keycodemax ; i ++ ) { if ( input_fetch_keycode ( dev , i ) == * old_keycode ) { __set_bit ( * old_keycode <S2SV_ModEnd> <S2SV_ModStart> break ; } } } __set_bit ( ke -> keycode , dev -> keybit ) ; return 0 ; <S2SV_ModEnd> "
162,"<S2SV_StartBug> l2tp_accm_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> ","<S2SV_ModStart> , u_int length <S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> <S2SV_ModStart> if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } "
163,<S2SV_StartBug> if ( handle && ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> <S2SV_StartBug> if ( sbi -> s_journal && ! handle ) <S2SV_EndBug> ,<S2SV_ModStart> ! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
164,"<S2SV_StartBug> if ( ++ l2cap_pi ( sk ) -> conf_retry < L2CAP_CONF_MAX_RETRIES ) { <S2SV_EndBug> <S2SV_StartBug> l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , <S2SV_EndBug> <S2SV_StartBug> goto done ; <S2SV_EndBug> ","<S2SV_ModStart> l2cap_pi ( sk ) -> num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP ) { int len = cmd -> len - sizeof ( * rsp ) ; char req [ 64 ] ; result = L2CAP_CONF_SUCCESS ; len = l2cap_parse_conf_rsp ( sk , rsp -> data , len , req , & result ) ; if ( len < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) <S2SV_ModEnd> <S2SV_ModStart> L2CAP_DISCONN_REQ , sizeof ( req ) , & <S2SV_ModEnd> <S2SV_ModStart> ; } l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , len , req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ; if ( result != L2CAP_CONF_SUCCESS ) goto done ; break "
165,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ; 
166,"<S2SV_StartBug> Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( Stream_GetRemainingLength ( s ) < 4 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } "
167,<S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> ,<S2SV_ModStart> ( ICANON | EXTPROC ) <S2SV_ModEnd> 
168,"<S2SV_StartBug> f = fopen ( filepath , ""rb"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""r"" <S2SV_ModEnd> "
169,"<S2SV_StartBug> len = b - a ; <S2SV_EndBug> <S2SV_StartBug> err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\'<>\'<S2SV_blank>"" <S2SV_EndBug> <S2SV_StartBug> if ( a >= tok -> line_start ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> col_offset = - 1 ; <S2SV_EndBug> ",<S2SV_ModStart> ( a != NULL && b != NULL ) ? <S2SV_ModStart> : 0 <S2SV_ModStart> expected = NOTEQUAL <S2SV_ModEnd> <S2SV_ModStart> != NULL && a <S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> } 
170,<S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ,<S2SV_ModStart> ; ND_TCHECK_16BITS ( & ip -> ip_len ) 
171,"<S2SV_StartBug> pid_t pid ; <S2SV_EndBug> <S2SV_StartBug> memset ( c_path , 0 , sizeof ( c_path ) ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix , <S2SV_EndBug> <S2SV_StartBug> hdl -> instance , ( long unsigned ) pid ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""%s%s%d_C_XXXXXX"" <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
172,"<S2SV_StartBug> const u_char * p , const u_char * ep , <S2SV_EndBug> <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""value="" ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> } if ( ep2 <S2SV_ModEnd> <S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( & p [ 2 ] <S2SV_ModStart> { if ( ! <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } } <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) { <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> trunc : return NULL ; "
173,"<S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> ",<S2SV_ModStart> int remaining ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> 
174,"<S2SV_StartBug> if ( mount ( ""proc"" , path , ""proc"" , 0 , NULL ) ) <S2SV_EndBug> ","<S2SV_ModStart> safe_mount <S2SV_ModEnd> <S2SV_ModStart> , rootfs ) < 0 <S2SV_ModEnd> "
175,<S2SV_StartBug> ( ( flags & O_ACCMODE ) == O_WRONLY || <S2SV_EndBug> <S2SV_StartBug> ( flags & O_ACCMODE ) == O_RDWR ) ) { <S2SV_EndBug> ,<S2SV_ModStart> != O_RDONLY <S2SV_ModEnd> <S2SV_ModStart> ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> 
176,<S2SV_StartBug> if ( cmd & 0x01 ) off = * delta ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x10 ) len = * delta ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x20 ) len |= * delta ++ << 8UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x40 ) len |= * delta ++ << 16UL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! len ) len = 0x10000 ; <S2SV_EndBug> ,"<S2SV_ModStart> # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) <S2SV_ModEnd> <S2SV_ModStart> shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( off , 16UL ) <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( off , <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( len , 0UL ) <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( len , 8UL ) <S2SV_ModEnd> <S2SV_ModStart> ADD_DELTA ( len , 16UL ) <S2SV_ModEnd> <S2SV_ModStart> # undef ADD_DELTA "
177,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 2 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( length > 4 ) { <S2SV_EndBug> <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 4 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> ; length -= 2 <S2SV_ModStart> == 0 ) return ; if ( length < <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""<S2SV_blank>AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> length -= 2 ; <S2SV_ModEnd> <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
178,"<S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> ",<S2SV_ModStart> KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> KEY_ALLOC_UID_KEYRING | 
179,"<S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>G"" , grayscale ) ; <S2SV_EndBug> <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>g"" , grayscale ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
180,"<S2SV_StartBug> if ( par == STROKING ) { outpos += sprintf ( outpos , ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K"" ) ; } <S2SV_EndBug> <S2SV_StartBug> else { outpos += sprintf ( outpos , ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>k"" ) ; } <S2SV_EndBug> ",<S2SV_ModStart> send ( <S2SV_ModEnd> <S2SV_ModStart> send ( <S2SV_ModEnd> 
181,<S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> ,"<S2SV_ModStart> struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> "
182,"<S2SV_StartBug> sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( op -> buf_asm ) , <S2SV_ModStart> snprintf <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( op -> buf_asm ) <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> <S2SV_ModStart> snprintf ( str , sizeof ( str ) <S2SV_ModEnd> "
183,<S2SV_StartBug> skb_dst_force ( skb ) ; <S2SV_EndBug> ,<S2SV_ModStart> skb_set_err_queue ( skb ) ; 
184,"<S2SV_StartBug> vpx_memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> 
185,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug> ","<S2SV_ModStart> ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl ) ; if ( rc <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
186,<S2SV_StartBug> u32 data ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> <S2SV_ModStart> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> "
187,<S2SV_StartBug> cpuctx -> ctx . type = cpu_context ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
188,"<S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> 1 <S2SV_ModEnd> "
189,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> return - ENOMEM ; } return <S2SV_ModEnd> 
190,"<S2SV_StartBug> sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length , <S2SV_EndBug> ",<S2SV_ModStart> + image -> rows 
191,"<S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_ISR ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_LNKCHG ) ; <S2SV_EndBug> <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_NSR ) ; <S2SV_EndBug> <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_NCR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & ISR_PR ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PR ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR | IMR_LNKCHGI | IMR_PTI | IMR_PRI ) ; <S2SV_EndBug> ","<S2SV_ModStart> DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR , DM9000_ISR_LNKCHG <S2SV_ModEnd> <S2SV_ModStart> DM9000_NSR ) ; if ( ( status & DM9000_NSR_LINKST ) != 0 ) { if ( ( status & DM9000_NSR_SPEED <S2SV_ModEnd> <S2SV_ModStart> DM9000_NCR ) ; if ( ( status & DM9000_NCR_FDX <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR_PR <S2SV_ModEnd> <S2SV_ModStart> DM9000_ISR , DM9000_ISR_PR <S2SV_ModEnd> <S2SV_ModStart> DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI <S2SV_ModEnd> "
192,"<S2SV_StartBug> int index , count , i ; <S2SV_EndBug> <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> ",<S2SV_ModStart> unsigned <S2SV_ModStart> unsigned 
193,"<S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> static u32 ip6_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> ) ) ; net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra <S2SV_ModStart> hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ; "
194,<S2SV_StartBug> if ( p -> question -> n_keys != 1 ) <S2SV_EndBug> ,<S2SV_ModStart> ! p -> question ) return 0 ; if ( 
195,<S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> 
196,"<S2SV_StartBug> static void encode_b_rt ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state_rt ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , x <S2SV_ModStart> td , ctx <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && output_enabled && cpi -> common . frame_type != KEY_FRAME ) { vp9_denoiser_denoise ( & cpi -> denoiser , x , mi_row , mi_col , MAX ( BLOCK_8X8 , bsize ) , ctx ) ; } # endif <S2SV_ModStart> , td <S2SV_ModStart> , ctx <S2SV_ModStart> & cpi -> common , td <S2SV_ModEnd> "
197,"<S2SV_StartBug> u32 i , j , page_count = 0 , sg_per_table ; <S2SV_EndBug> <S2SV_StartBug> sg_table = rd_dev -> sg_table_array ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( sg_table ) ; <S2SV_EndBug> ","<S2SV_ModStart> page_count <S2SV_ModEnd> <S2SV_ModStart> page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
198,"<S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> arg = ( arg != NULL ) ? arg : """" ; "
199,<S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } "
200,"<S2SV_StartBug> static int64_t rd_pick_intra4x4block ( VP9_COMP * cpi , MACROBLOCK * x , int ib , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> <S2SV_StartBug> const uint8_t * src_init = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , ib , <S2SV_EndBug> <S2SV_StartBug> uint8_t * dst_init = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , ib , <S2SV_EndBug> <S2SV_StartBug> assert ( ib < 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tl , l , sizeof ( tl ) ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( tempa , ta , sizeof ( ta ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( templ , tl , sizeof ( tl ) ) ; <S2SV_EndBug> <S2SV_StartBug> const int block = ib + idy * 2 + idx ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const src_diff = raster_block_offset_int16 ( BLOCK_8X8 , block , <S2SV_EndBug> <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , block , 1 , <S2SV_EndBug> <S2SV_StartBug> dst , dst_stride , idx , idy , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_fwht4x4 ( src_diff , coeff , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> goto next ; <S2SV_EndBug> <S2SV_StartBug> p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; <S2SV_EndBug> <S2SV_StartBug> distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , <S2SV_EndBug> <S2SV_StartBug> 16 , & unused ) >> 2 ; <S2SV_EndBug> <S2SV_StartBug> goto next ; <S2SV_EndBug> <S2SV_StartBug> dst , dst_stride , p -> eobs [ block ] ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( a , tempa , sizeof ( tempa ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( l , templ , sizeof ( templ ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , <S2SV_EndBug> <S2SV_StartBug> num_4x4_blocks_wide * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> next : <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , <S2SV_EndBug> <S2SV_StartBug> num_4x4_blocks_wide * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> row , int col , PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> row * 4 * src_stride + col * 4 <S2SV_ModEnd> <S2SV_ModStart> row * 4 * src_stride + col * 4 <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH uint16_t best_dst16 [ 8 * 8 ] ; # endif memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> ( row + idy ) <S2SV_ModEnd> <S2SV_ModStart> ( col + idx ) <S2SV_ModEnd> <S2SV_ModStart> vp9_raster_block_offset_int16 <S2SV_ModEnd> <S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> col + idx , row + idy , 0 ) ; vpx_highbd_subtract_block <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> vp9_highbd_fwht4x4 <S2SV_ModEnd> <S2SV_ModStart> next_highbd ; vp9_highbd_iwht4x4_add <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> if ( tx_type == DCT_DCT ) vpx_highbd_fdct4x4 ( src_diff , coeff , 8 ) ; else vp9_highbd_fht4x4 <S2SV_ModEnd> <S2SV_ModStart> vp9_highbd_block_error ( <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> next_highbd ; vp9_highbd_iht4x4_add <S2SV_ModEnd> <S2SV_ModStart> , xd -> bd <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> { memcpy ( best_dst16 <S2SV_ModEnd> <S2SV_ModStart> CONVERT_TO_SHORTPTR ( <S2SV_ModStart> ) <S2SV_ModStart> * sizeof ( uint16_t ) <S2SV_ModStart> } next_highbd <S2SV_ModEnd> <S2SV_ModStart> { memcpy ( CONVERT_TO_SHORTPTR <S2SV_ModEnd> <S2SV_ModStart> ) , best_dst16 <S2SV_ModEnd> <S2SV_ModStart> * sizeof ( uint16_t ) ) ; } <S2SV_ModEnd> <S2SV_ModStart> # endif for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { int64_t this_rd ; int ratey = 0 ; int64_t distortion = 0 ; int rate = bmode_costs [ mode ] ; if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) continue ; if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { if ( conditional_skipintra ( mode , * best_mode ) ) continue ; } memcpy ( tempa , ta , sizeof ( ta ) ) ; memcpy ( templ , tl , sizeof ( tl ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high ; ++ idy ) { for ( idx = 0 ; idx < num_4x4_blocks_wide ; ++ idx ) { const int block = ( row + idy ) * 2 + ( col + idx ) ; const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ; uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ; int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ; tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ; vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ; vpx_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; if ( xd -> lossless ) { const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; vp9_fwht4x4 ( src_diff , coeff , 8 ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } else { int64_t unused ; const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ; const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused ) >> 2 ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } } } rate += ratey ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; memcpy ( a , tempa , sizeof ( tempa ) ) ; memcpy ( l , templ , sizeof ( templ ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , num_4x4_blocks_wide * 4 ) ; } next : { } } if ( best_rd >= rd_thresh || x -> skip_encode ) return best_rd ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , num_4x4_blocks_wide * 4 ) ; return best_rd ; } "
201,"<S2SV_StartBug> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> return 0 ; 
202,<S2SV_StartBug> vp9_free_frame_buffers ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_free_internal_frame_buffers ( & cm -> int_frame_buffers ) ; <S2SV_EndBug> ,<S2SV_ModStart> vp9_free_context_buffers <S2SV_ModEnd> <S2SV_ModStart> vpx_free ( cm -> fc ) ; cm -> fc = NULL ; vpx_free ( cm -> frame_contexts ) ; cm -> frame_contexts = NULL <S2SV_ModEnd> 
203,<S2SV_StartBug> if ( po -> fanout ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out_unlock ; } <S2SV_ModEnd> 
204,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , icmp6_tstr <S2SV_ModEnd> "
205,"<S2SV_StartBug> int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
206,<S2SV_StartBug> BUG_ON ( ! io ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; if ( io -> page ) put_page ( io -> page 
207,"<S2SV_StartBug> void * shared_kaddr ; <S2SV_EndBug> <S2SV_StartBug> struct pvclock_vcpu_time_info * guest_hv_clock ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vcpu -> time_page ) <S2SV_EndBug> <S2SV_StartBug> shared_kaddr = kmap_atomic ( vcpu -> time_page ) ; <S2SV_EndBug> <S2SV_StartBug> pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock , <S2SV_EndBug> <S2SV_StartBug> kunmap_atomic ( shared_kaddr ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pv_time_enabled <S2SV_ModEnd> <S2SV_ModStart> if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 <S2SV_ModEnd> <S2SV_ModStart> . <S2SV_ModEnd> <S2SV_ModStart> kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
208,"<S2SV_StartBug> # line 105 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1340 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 114 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1348 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 118 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1363 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 129 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> node = yr_re_node_create ( RE_NODE_EMPTY , NULL , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> # line 1382 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 147 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1390 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 151 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1402 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 162 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1420 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 176 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1440 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 192 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1458 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 206 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1478 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 222 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1505 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 245 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1533 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 269 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1559 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 291 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1586 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 314 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1594 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 318 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1604 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 324 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1614 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 330 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1624 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 336 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1634 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 345 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1642 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 349 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1652 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 355 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1664 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 363 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1674 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 369 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1684 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 375 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1694 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 381 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1704 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 387 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1714 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 393 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1724 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 399 ""re_grammar.y"" <S2SV_EndBug> <S2SV_StartBug> # line 1736 ""re_grammar.c"" <S2SV_EndBug> <S2SV_StartBug> # line 1740 ""re_grammar.c"" <S2SV_EndBug> ","<S2SV_ModStart> 113 <S2SV_ModEnd> <S2SV_ModStart> 1348 <S2SV_ModEnd> <S2SV_ModStart> 122 <S2SV_ModEnd> <S2SV_ModStart> 1356 <S2SV_ModEnd> <S2SV_ModStart> 126 <S2SV_ModEnd> <S2SV_ModStart> incr_ast_levels ( ) ; <S2SV_ModStart> 1372 <S2SV_ModEnd> <S2SV_ModStart> 138 <S2SV_ModEnd> <S2SV_ModStart> incr_ast_levels ( ) ; <S2SV_ModStart> 1392 <S2SV_ModEnd> <S2SV_ModStart> 157 <S2SV_ModEnd> <S2SV_ModStart> 1400 <S2SV_ModEnd> <S2SV_ModStart> 161 ""re_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1414 <S2SV_ModEnd> <S2SV_ModStart> 174 <S2SV_ModEnd> <S2SV_ModStart> 1432 <S2SV_ModEnd> <S2SV_ModStart> 188 <S2SV_ModEnd> <S2SV_ModStart> 1452 <S2SV_ModEnd> <S2SV_ModStart> 204 <S2SV_ModEnd> <S2SV_ModStart> 1470 <S2SV_ModEnd> <S2SV_ModStart> 218 <S2SV_ModEnd> <S2SV_ModStart> 1490 <S2SV_ModEnd> <S2SV_ModStart> 234 <S2SV_ModEnd> <S2SV_ModStart> 1517 <S2SV_ModEnd> <S2SV_ModStart> 257 <S2SV_ModEnd> <S2SV_ModStart> 1545 <S2SV_ModEnd> <S2SV_ModStart> 281 <S2SV_ModEnd> <S2SV_ModStart> 1571 <S2SV_ModEnd> <S2SV_ModStart> 303 <S2SV_ModEnd> <S2SV_ModStart> 1598 <S2SV_ModEnd> <S2SV_ModStart> 326 <S2SV_ModEnd> <S2SV_ModStart> 1606 <S2SV_ModEnd> <S2SV_ModStart> 330 <S2SV_ModEnd> <S2SV_ModStart> 1616 <S2SV_ModEnd> <S2SV_ModStart> 336 <S2SV_ModEnd> <S2SV_ModStart> 1626 <S2SV_ModEnd> <S2SV_ModStart> 342 <S2SV_ModEnd> <S2SV_ModStart> 1636 <S2SV_ModEnd> <S2SV_ModStart> 348 <S2SV_ModEnd> <S2SV_ModStart> 1646 <S2SV_ModEnd> <S2SV_ModStart> 357 ""re_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> <S2SV_ModStart> 1656 <S2SV_ModEnd> <S2SV_ModStart> 363 <S2SV_ModEnd> <S2SV_ModStart> 1666 <S2SV_ModEnd> <S2SV_ModStart> 369 <S2SV_ModEnd> <S2SV_ModStart> 1678 <S2SV_ModEnd> <S2SV_ModStart> 377 <S2SV_ModEnd> <S2SV_ModStart> 1688 <S2SV_ModEnd> <S2SV_ModStart> 383 <S2SV_ModEnd> <S2SV_ModStart> 1698 <S2SV_ModEnd> <S2SV_ModStart> 389 <S2SV_ModEnd> <S2SV_ModStart> 1708 <S2SV_ModEnd> <S2SV_ModStart> 395 <S2SV_ModEnd> <S2SV_ModStart> 1718 <S2SV_ModEnd> <S2SV_ModStart> 401 <S2SV_ModEnd> <S2SV_ModStart> 1728 <S2SV_ModEnd> <S2SV_ModStart> 407 <S2SV_ModEnd> <S2SV_ModStart> 1738 <S2SV_ModEnd> <S2SV_ModStart> 413 <S2SV_ModEnd> <S2SV_ModStart> 1750 <S2SV_ModEnd> <S2SV_ModStart> 1754 <S2SV_ModEnd> "
209,<S2SV_StartBug> u32 now ; <S2SV_EndBug> <S2SV_StartBug> challenge_timestamp = now ; <S2SV_EndBug> <S2SV_StartBug> challenge_count = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> count , <S2SV_ModStart> u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> "
210,"<S2SV_StartBug> err = tfm -> seed ( tfm , seed , slen ) ; <S2SV_EndBug> ",<S2SV_ModStart> crypto_rng_alg ( tfm ) <S2SV_ModEnd> 
211,<S2SV_StartBug> update_db_bp_intercept ( & svm -> vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
212,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( pool ) ; 
213,<S2SV_StartBug> int tstype ) <S2SV_EndBug> <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> ,"<S2SV_ModStart> , bool opt_stats <S2SV_ModStart> ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ; serr -> opt_stats = opt_stats "
214,<S2SV_StartBug> switch ( c = ( * dis_getc ) ( stream ) ) <S2SV_EndBug> ,"<S2SV_ModStart> if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; } "
215,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> dc -> vmsd = & vmstate_stellaris_enet ; 
216,"<S2SV_StartBug> void vp9_first_pass ( VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const PICK_MODE_CONTEXT * ctx = & x -> sb64_context ; <S2SV_EndBug> <S2SV_StartBug> YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> int intrapenalty = 256 ; <S2SV_EndBug> <S2SV_StartBug> uint32_t lastmv_as_int = 0 ; <S2SV_EndBug> <S2SV_StartBug> const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( scaled_ref_buf != NULL ) { <S2SV_EndBug> <S2SV_StartBug> first_ref_buf = scaled_ref_buf ; <S2SV_EndBug> <S2SV_StartBug> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; ++ mb_row ) { <S2SV_EndBug> <S2SV_StartBug> int_mv best_ref_mv ; <S2SV_EndBug> <S2SV_StartBug> double error_weight = 1.0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> <S2SV_StartBug> intra_error += ( int64_t ) this_error ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> current_video_frame > 0 ) { <S2SV_EndBug> <S2SV_StartBug> int tmp_err , motion_error ; <S2SV_EndBug> <S2SV_StartBug> motion_error = zz_motion_search ( x ) ; <S2SV_EndBug> <S2SV_StartBug> mv . as_int = tmp_mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> current_video_frame > 1 && gld_yv12 != NULL ) { <S2SV_EndBug> <S2SV_StartBug> gf_motion_error = zz_motion_search ( x ) ; <S2SV_EndBug> <S2SV_StartBug> first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv , <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> <S2SV_StartBug> best_ref_mv . as_int = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) && <S2SV_EndBug> <S2SV_StartBug> this_error < 2 * intrapenalty ) <S2SV_EndBug> <S2SV_StartBug> ++ neutral_count ; <S2SV_EndBug> <S2SV_StartBug> mv . as_mv . col *= 8 ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = mv ; <S2SV_EndBug> <S2SV_StartBug> sum_mvr += mv . as_mv . row ; <S2SV_EndBug> <S2SV_StartBug> sum_mvr_abs += abs ( mv . as_mv . row ) ; <S2SV_EndBug> <S2SV_StartBug> sum_mvc += mv . as_mv . col ; <S2SV_EndBug> <S2SV_StartBug> sum_mvc_abs += abs ( mv . as_mv . col ) ; <S2SV_EndBug> <S2SV_StartBug> sum_mvrs += mv . as_mv . row * mv . as_mv . row ; <S2SV_EndBug> <S2SV_StartBug> sum_mvcs += mv . as_mv . col * mv . as_mv . col ; <S2SV_EndBug> <S2SV_StartBug> best_ref_mv . as_int = mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_int != lastmv_as_int ) <S2SV_EndBug> <S2SV_StartBug> lastmv_as_int = mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_mv . row > 0 ) <S2SV_EndBug> <S2SV_StartBug> else if ( mv . as_mv . row < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_mv . row > 0 ) <S2SV_EndBug> <S2SV_StartBug> else if ( mv . as_mv . row < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_mv . col > 0 ) <S2SV_EndBug> <S2SV_StartBug> else if ( mv . as_mv . col < 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( mv . as_mv . col > 0 ) <S2SV_EndBug> <S2SV_StartBug> else if ( mv . as_mv . col < 0 ) <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> fps . frame = cm -> current_video_frame ; <S2SV_EndBug> <S2SV_StartBug> fps . spatial_layer_id = cpi -> svc . spatial_layer_id ; <S2SV_EndBug> <S2SV_StartBug> fps . intra_error = ( double ) ( intra_error >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_inter = ( double ) intercount / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_second_ref = ( double ) second_ref_count / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_neutral = ( double ) neutral_count / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / mvcount ) ) / mvcount ; <S2SV_EndBug> <S2SV_StartBug> fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / mvcount ) ) / mvcount ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_motion = ( double ) mvcount / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ; <S2SV_EndBug> <S2SV_StartBug> accumulate_stats ( & twopass -> total_stats , & fps ) ; <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> <S2SV_StartBug> swap_yv12 ( lst_yv12 , new_yv12 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> current_video_frame == 0 && gld_yv12 != NULL ) { <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , const struct lookahead_entry * source <S2SV_ModStart> td . <S2SV_ModStart> cpi -> td . pc_root -> none <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> const <S2SV_ModStart> INTRA_MODE_PENALTY ; double neutral_count ; int intra_skip_count = 0 ; int image_data_start_row = INVALID_ROW <S2SV_ModEnd> <S2SV_ModStart> MV lastmv = { 0 , 0 } ; TWO_PASS <S2SV_ModEnd> <S2SV_ModStart> int recon_y_stride , recon_uv_stride , uv_mb_height ; YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ; <S2SV_ModStart> LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & <S2SV_ModEnd> <S2SV_ModStart> layer_context [ cpi -> svc . spatial_layer_id ] : NULL ; double intra_factor ; double brightness_factor ; BufferPool * const pool = cm -> buffer_pool ; assert ( new_yv12 <S2SV_ModEnd> <S2SV_ModStart> ; assert ( ( lc != NULL ) || frame_is_intra_only ( cm ) || ( lst_yv12 != NULL ) ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { vp9_zero_array ( cpi -> twopass . frame_mb_stats_buf , cm -> initial_mbs ) ; } # endif vpx_clear_system_state ( ) ; intra_factor = 0.0 ; brightness_factor = 0.0 ; neutral_count = 0.0 ; set_first_pass_params ( cpi ) ; vp9_set_quantizer ( cm , find_fp_qindex ( cm -> bit_depth ) ) ; if ( lc != NULL ) { twopass = & lc -> twopass ; cpi -> lst_fb_idx = cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags = VP9_LAST_FLAG ; if ( cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id < REF_FRAMES ) { cpi -> gld_fb_idx = cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags |= VP9_GOLD_FLAG ; cpi -> refresh_golden_frame = ( lc -> current_video_frame_in_layer == 0 ) ; } else { cpi -> refresh_golden_frame = 0 ; } if ( lc -> current_video_frame_in_layer == 0 ) cpi -> ref_frame_flags = 0 ; vp9_scale_references ( cpi ) ; if ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) <S2SV_ModStart> vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ; if ( first_ref_buf == NULL ) first_ref_buf = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; } if ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) { gld_yv12 = vp9_get_scaled_ref_frame ( cpi , GOLDEN_FRAME ) ; if ( gld_yv12 == NULL ) { gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } } else { gld_yv12 = NULL ; } set_ref_ptrs ( cm , xd , ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ? LAST_FRAME : NONE , ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ? GOLDEN_FRAME : NONE ) ; cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , & cpi -> scaled_source ) ; } vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; vp9_setup_dst_planes ( xd -> plane , new_yv12 , 0 , 0 ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_setup_pre_planes ( xd , 0 , first_ref_buf , 0 , 0 , NULL ) ; } xd -> mi = cm -> mi_grid_visible ; xd -> mi [ 0 ] = cm -> mi <S2SV_ModEnd> <S2SV_ModStart> recon_y_stride = new_yv12 -> y_stride ; recon_uv_stride = new_yv12 -> uv_stride ; uv_mb_height = 16 >> ( new_yv12 -> y_height > new_yv12 -> uv_height ) ; <S2SV_ModStart> MV best_ref_mv = { 0 , 0 } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> double log_intra ; int level_sample ; # if CONFIG_FP_MB_STATS const int mb_index = mb_row * cm -> mb_cols + mb_col ; # endif vpx_clear_system_state <S2SV_ModEnd> <S2SV_ModStart> x -> skip_encode = 0 ; xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; xd -> mi [ 0 ] -> mbmi . tx_size = use_dc_pred ? ( bsize >= BLOCK_16X16 ? TX_16X16 : TX_8X8 ) : TX_4X4 ; vp9_encode_intra_block_plane ( x , bsize , 0 ) ; this_error = vpx_get_mb_ss ( x -> plane [ 0 ] . src_diff ) ; if ( this_error < UL_INTRA_THRESH ) { ++ intra_skip_count ; } else if ( ( mb_col > 0 ) && ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = mb_row ; } # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { switch ( cm -> bit_depth ) { case VPX_BITS_8 : break ; case VPX_BITS_10 : this_error >>= 4 ; break ; case VPX_BITS_12 : this_error >>= 8 ; break ; default : assert ( 0 && ""cm->bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>"" ""VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return ; } } # endif vpx_clear_system_state ( ) ; log_intra = log ( this_error + 1.0 ) ; if ( log_intra < 10.0 ) intra_factor += 1.0 + ( ( 10.0 - log_intra ) * 0.05 ) ; else intra_factor += 1.0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) level_sample = CONVERT_TO_SHORTPTR ( x -> plane [ 0 ] . src . buf ) [ 0 ] ; else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # endif if ( ( level_sample < DARK_THRESH ) && ( log_intra < 9.0 ) ) brightness_factor += 1.0 + ( 0.01 * ( DARK_THRESH - level_sample ) ) ; else brightness_factor += 1.0 ; <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; } # endif <S2SV_ModStart> ( lc == NULL && <S2SV_ModStart> || ( lc != NULL && lc -> current_video_frame_in_layer > 0 ) ) <S2SV_ModStart> , raw_motion_error ; MV mv = { 0 , 0 } , tmp_mv = { 0 , 0 } ; struct buf_2d unscaled_last_source_buf_2d <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif unscaled_last_source_buf_2d . buf = cpi -> unscaled_last_source -> y_buffer + recon_yoffset ; unscaled_last_source_buf_2d . stride = cpi -> unscaled_last_source -> y_stride ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { raw_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d , xd -> bd ) ; } else { raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; } # else raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; # endif if ( raw_motion_error > 25 || lc != NULL ) { first_pass_motion_search ( cpi , x , & best_ref_mv , & mv , & motion_error ) ; if ( ! is_zero_mv ( & best_ref_mv ) ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & tmp_err ) ; <S2SV_ModEnd> <S2SV_ModStart> = tmp_mv ; } } if ( ( ( lc == NULL && <S2SV_ModEnd> <S2SV_ModStart> ) || ( lc != NULL && lc -> current_video_frame_in_layer > 1 ) ) <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { gf_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> } else { sr_coded_error += motion_error ; } best_ref_mv . row = 0 ; best_ref_mv . col = 0 ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state ( ) ; <S2SV_ModStart> ( this_error < ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { neutral_count += 1.0 ; } else if ( ( this_error > NCOUNT_INTRA_THRESH ) && ( this_error < ( NCOUNT_INTRA_FACTOR * motion_error ) ) ) { neutral_count += ( double ) motion_error / DOUBLE_DIVIDE_CHECK ( ( double ) this_error ) ; } mv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . as_mv <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = mv ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif if ( ! is_zero_mv ( & mv ) <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_MOTION_ZERO_MASK ; <S2SV_ModStart> as_mv . col > 0 && mv . as_mv . col >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_RIGHT_MASK ; } else if ( mv . as_mv . row < 0 && abs ( mv . as_mv . row ) >= abs ( mv . as_mv . col ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_UP_MASK ; } else if ( mv . as_mv . col < 0 && abs ( mv . as_mv . col ) >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_LEFT_MASK ; } else { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_DOWN_MASK ; } } # endif if ( ! is_equal_mv ( & mv , & lastmv ) <S2SV_ModEnd> <S2SV_ModStart> lastmv = mv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state ( ) ; } if ( ( image_data_start_row > cm -> mb_rows / 2 ) || ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = cm -> mb_rows / 2 ; } if ( image_data_start_row > 0 ) { intra_skip_count = MAX ( 0 , intra_skip_count - ( image_data_start_row * cm -> mb_cols * 2 ) ) ; } <S2SV_ModEnd> <S2SV_ModStart> const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; const double min_err = 200 * sqrt ( num_mbs ) ; intra_factor = intra_factor / ( double ) num_mbs ; brightness_factor = brightness_factor / ( double ) num_mbs ; fps . weight = intra_factor * brightness_factor ; fps . <S2SV_ModEnd> <S2SV_ModStart> ; fps . coded_error = ( double ) ( coded_error >> 8 ) + min_err ; fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) + min_err <S2SV_ModStart> + min_err <S2SV_ModEnd> <S2SV_ModStart> num_mbs <S2SV_ModEnd> <S2SV_ModStart> num_mbs <S2SV_ModEnd> <S2SV_ModStart> num_mbs ; fps . intra_skip_pct = ( double ) intra_skip_count / num_mbs ; fps . inactive_zone_rows = ( double ) image_data_start_row ; fps . inactive_zone_cols = ( double ) 0 <S2SV_ModEnd> <S2SV_ModStart> ( ( double ) sum_mvr * sum_mvr <S2SV_ModEnd> <S2SV_ModStart> ( ( double ) sum_mvc * sum_mvc <S2SV_ModEnd> <S2SV_ModStart> num_mbs <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { output_fpmb_stats ( twopass -> frame_mb_stats_buf , cm , cpi -> output_pkt_list ) ; } # endif <S2SV_ModStart> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> <S2SV_ModStart> vpx_extend_frame_borders ( new_yv12 ) ; if ( lc != NULL <S2SV_ModEnd> <S2SV_ModStart> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> lst_fb_idx ] , cm -> new_fb_idx ) ; } <S2SV_ModEnd> <S2SV_ModStart> cpi -> gld_fb_idx != INVALID_IDX && lc == <S2SV_ModEnd> <S2SV_ModStart> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> use_svc ) vp9_inc_frame_in_layer ( cpi ) ; "
217,<S2SV_StartBug> static const int16_t * filter = vp9_down2_symeven_half_filter ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
218,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> l2cap_pi ( sk ) -> num_conf_req ++ ; 
219,<S2SV_StartBug> if ( user -> uid_keyring ) { <S2SV_EndBug> ,<S2SV_ModStart> && user -> session_keyring 
220,<S2SV_StartBug> const int length ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
221,<S2SV_StartBug> efx -> mac_op -> update_stats ( efx ) ; <S2SV_EndBug> ,<S2SV_ModStart> net_dev -> gso_max_segs = EFX_TSO_MAX_SEGS ; 
222,"<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * codec , <S2SV_EndBug> <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> int got_pkts = 0 ; <S2SV_ModStart> got_pkts = 1 ; <S2SV_ModStart> return got_pkts ; 
223,<S2SV_StartBug> if ( ! seig_entry -> key_info [ 0 ] ) <S2SV_EndBug> ,<S2SV_ModStart> seig_entry && 
224,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
225,"<S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> ","<S2SV_ModStart> i >= 0 && <S2SV_ModStart> if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } "
226,"<S2SV_StartBug> int size ; <S2SV_EndBug> <S2SV_StartBug> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <S2SV_EndBug> ","<S2SV_ModStart> ; int base_size <S2SV_ModStart> base_size = sizeof ( path -> <S2SV_ModEnd> <S2SV_ModStart> * npts ; size = offsetof ( PATH , <S2SV_ModEnd> <S2SV_ModStart> + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> "
227,<S2SV_StartBug> size = INT_MAX ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT "
228,<S2SV_StartBug> mptctl_gettargetinfo ( unsigned long arg ) <S2SV_EndBug> <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> <S2SV_StartBug> int * pdata ; <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ,"<S2SV_ModStart> MPT_ADAPTER * ioc , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
229,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
230,<S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> ,"<S2SV_ModStart> create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ; "
231,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ; 
232,"<S2SV_StartBug> hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , <S2SV_EndBug> ",<S2SV_ModStart> if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; } 
233,"<S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> } <S2SV_ModStart> if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\n"" , chunksize ) ; return AVERROR_INVALIDDATA ; } "
234,<S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } if ( "
235,"<S2SV_StartBug> SEPARATE_ZVAL ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double ( * var2 ) ; <S2SV_EndBug> <S2SV_StartBug> matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> if ( Z_TYPE_PP <S2SV_ModEnd> <S2SV_ModStart> != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) <S2SV_ModStart> & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( <S2SV_ModEnd> <S2SV_ModStart> } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , <S2SV_ModEnd> <S2SV_ModStart> div , ( float ) offset ) ; if ( res ) { RETURN_TRUE <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
236,"<S2SV_StartBug> static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type , <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> ",<S2SV_ModStart> bool <S2SV_ModEnd> <S2SV_ModStart> false ; * type |= <S2SV_ModEnd> <S2SV_ModStart> ; * mask |= algt -> mask & <S2SV_ModEnd> <S2SV_ModStart> * type & * <S2SV_ModEnd> <S2SV_ModStart> return true ; else return false <S2SV_ModEnd> 
237,"<S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi = cm -> mi_grid_visible ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cm -> counts ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> coef_counts ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> tx_stepdown_count ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> rd_comp_pred_diff ) ; <S2SV_EndBug> <S2SV_StartBug> switch_lossless_mode ( cpi , cpi -> mb . e_mbd . lossless ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_initialize_me_consts ( cpi , cm -> base_qindex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) <S2SV_EndBug> <S2SV_StartBug> cm -> prev_mi = get_prev_mi ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = & cpi -> mb . sb64_context ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . partition_search_type == SOURCE_VAR_BASED_PARTITION && <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> const int tile_cols = 1 << cm -> log2_tile_cols ; <S2SV_EndBug> <S2SV_StartBug> encode_rd_sb_row ( cpi , & tile , mi_row , & tp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sf -> skip_encode_sb ) { <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * const td = & cpi -> td ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> RD_COUNTS * const rdc = & cpi -> td . rd_counts ; <S2SV_ModStart> * td <S2SV_ModEnd> <S2SV_ModStart> rdc <S2SV_ModEnd> <S2SV_ModStart> rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> rdc -> filter_diff ) ; xd -> <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) x -> fwd_txm4x4 = xd -> lossless ? vp9_highbd_fwht4x4 : vpx_highbd_fdct4x4 ; else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; x -> highbd_itxm_add = xd -> lossless ? vp9_highbd_iwht4x4_add : vp9_highbd_idct4x4_add ; # else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; # endif x -> itxm_add = xd -> lossless ? vp9_iwht4x4_add : vp9_idct4x4_add ; if ( xd -> lossless ) x -> optimize = 0 ; cm -> tx_mode = select_tx_mode <S2SV_ModEnd> <S2SV_ModStart> xd <S2SV_ModEnd> <S2SV_ModStart> x , <S2SV_ModStart> cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> intra_only && cm -> last_show_frame <S2SV_ModEnd> <S2SV_ModStart> cm -> use_prev_frame_mvs ? cm -> prev_mip + cm -> mi_stride + 1 : NULL ; x -> quant_fp = cpi -> sf . use_quant_fp ; vp9_zero ( x -> skip_txfm <S2SV_ModEnd> <S2SV_ModStart> td . pc_root -> none <S2SV_ModEnd> <S2SV_ModStart> cm -> frame_type != KEY_FRAME && cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) cpi -> ref_frame_flags &= ( ~ VP9_GOLD_FLAG ) ; if ( sf -> <S2SV_ModEnd> <S2SV_ModStart> ) source_var_based_partition_search_method ( cpi ) ; <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { input_fpmb_stats ( & cpi -> twopass . firstpass_mb_stats , cm , & cpi -> twopass . this_frame_mb_stats ) ; } # endif if ( MIN ( cpi -> oxcf . max_threads , <S2SV_ModEnd> <S2SV_ModStart> ) > 1 ) vp9_encode_tiles_mt ( cpi <S2SV_ModEnd> <S2SV_ModStart> encode_tiles ( cpi ) ; <S2SV_ModEnd> <S2SV_ModStart> sf -> skip_encode_frame = sf -> skip_encode_sb ? get_skip_encode_frame ( cm , td ) : 0 ; <S2SV_ModEnd> "
238,"<S2SV_StartBug> size_t input_size , <S2SV_EndBug> <S2SV_StartBug> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_EndBug> <S2SV_StartBug> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_EndBug> <S2SV_StartBug> input -= character_size ; <S2SV_EndBug> <S2SV_StartBug> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; <S2SV_EndBug> <S2SV_StartBug> match = IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> <S2SV_StartBug> match = ! IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> <S2SV_StartBug> ! ( flags & RE_FLAGS_NOT_AT_START ) && <S2SV_EndBug> <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) <S2SV_EndBug> <S2SV_StartBug> kill = input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> <S2SV_StartBug> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; <S2SV_EndBug> <S2SV_StartBug> input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> { if ( <S2SV_ModEnd> <S2SV_ModStart> || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> else { <S2SV_ModStart> input_forwards_size <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> <S2SV_ModStart> _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size < character_size ) { <S2SV_ModEnd> <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> <S2SV_ModStart> < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size <S2SV_ModEnd> <S2SV_ModStart> input_backwards_size > 0 <S2SV_ModEnd> <S2SV_ModStart> input_forwards_size <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
239,"<S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" "
240,<S2SV_StartBug> r = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
241,"<S2SV_StartBug> __be32 saddr , __be32 daddr , struct ip_options * opt ) <S2SV_EndBug> <S2SV_StartBug> skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt && opt -> optlen ) { <S2SV_EndBug> <S2SV_StartBug> iph -> ihl += opt -> optlen >> 2 ; <S2SV_EndBug> <S2SV_StartBug> ip_options_build ( skb , opt , daddr , rt , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> & opt -> 
242,<S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers 
243,"<S2SV_StartBug> log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\n"" , <S2SV_EndBug> <S2SV_StartBug> xkb_file_type_to_string ( file -> file_type ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n"" ) ; } else { <S2SV_ModStart> } "
244,"<S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length > <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; "
245,<S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
246,<S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> 
247,"<S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
248,"<S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> ",<S2SV_ModStart> struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> ) ; mutex_unlock ( & ldata -> output_lock 
249,"<S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
250,<S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> <S2SV_ModStart> && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> <S2SV_ModStart> flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ; "
251,"<S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> & enc_tables <S2SV_ModEnd> <S2SV_ModStart> enc_tables <S2SV_ModEnd> 
252,"<S2SV_StartBug> memcpy ( buf + x , data , state -> xsize ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
253,<S2SV_StartBug> gfp_mask = sk -> sk_allocation ; <S2SV_EndBug> <S2SV_StartBug> int npages ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; err = - EMSGSIZE ; if ( npages > MAX_SKB_FRAGS ) goto failure ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
254,<S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
255,"<S2SV_StartBug> char * prime_arg1 , <S2SV_EndBug> <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> free ( prime_arg1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> = NULL , * prime_arg2 = NULL <S2SV_ModEnd> <S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : free ( prime_arg1 ) ; free ( prime_arg2 ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
256,<S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> p -> status = - EINVAL ; <S2SV_EndBug> ,"<S2SV_ModStart> < 0 || param2 <S2SV_ModStart> if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32438598"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> param2 < 0 || <S2SV_ModStart> if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32436341"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> param2 < 0 || <S2SV_ModStart> if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32247948"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } "
257,"<S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> valid_hex ( nonce1 ) <S2SV_ModEnd> <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> <S2SV_ModStart> n2size < 2 || n2size > 16 <S2SV_ModEnd> <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> "
258,"<S2SV_StartBug> if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , <S2SV_EndBug> ","<S2SV_ModStart> _open_as_other ( path_name , req <S2SV_ModEnd> <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied"" , path_name <S2SV_ModEnd> "
259,"<S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> ","<S2SV_ModStart> unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> nr <S2SV_ModEnd> "
260,"<S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug> ",<S2SV_ModStart> segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; 
261,"<S2SV_StartBug> void * zrealloc ( void * ptr , size_t size ) { <S2SV_EndBug> ",<S2SV_ModStart> ASSERT_NO_SIZE_OVERFLOW ( size ) ; 
262,"<S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_reader_init ( & r , data , partition_size ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_reader_has_error ( & r ) ; <S2SV_EndBug> ","<S2SV_ModStart> cm -> fc ; vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_reader_init <S2SV_ModEnd> <S2SV_ModStart> , pbi -> decrypt_cb , pbi -> decrypt_state <S2SV_ModStart> vpx_reader_has_error <S2SV_ModEnd> "
263,<S2SV_StartBug> if ( numrows < 0 || numcols < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> matrix -> datasize_ = numrows * numcols ; <S2SV_EndBug> <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> size_t size ; matrix = 0 ; <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> goto error <S2SV_ModEnd> <S2SV_ModStart> error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; "
264,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> else { matvar -> name [ tmp - 1 ] = '\\0' ; } 
265,<S2SV_StartBug> * dst = * src ; <S2SV_EndBug> ,<S2SV_ModStart> __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ; 
266,"<S2SV_StartBug> int flags = fcntl ( semaphore -> fd , F_GETFL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( fcntl ( semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( fcntl ( semaphore -> fd , F_SETFL , flags ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
267,"<S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK ( bp -> bp_flags ) ; 
268,"<S2SV_StartBug> int idx , ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { <S2SV_EndBug> ","<S2SV_ModStart> 0 <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> || hlist_empty ( <S2SV_ModEnd> <S2SV_ModStart> ) ) { pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n"" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] "
269,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
270,<S2SV_StartBug> if ( ( unsigned int ) arg >= cdi -> capacity ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
271,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
272,<S2SV_StartBug> struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; } 
273,"<S2SV_StartBug> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( id >= KVM_MAX_VCPUS ) return - EINVAL ; 
274,<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> ,<S2SV_ModStart> void 
275,<S2SV_StartBug> ld -> bytes_left = ld -> buffer_size - words * 4 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else 
276,"<S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> ","<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } "
277,"<S2SV_StartBug> if ( strchr ( str , ':' ) ) <S2SV_EndBug> <S2SV_StartBug> if ( strchr ( str , '.' ) ) <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> != NULL <S2SV_ModStart> osStrchr <S2SV_ModEnd> <S2SV_ModStart> != NULL 
278,"<S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> ",<S2SV_ModStart> >> PAGE_SHIFT <S2SV_ModStart> >> PAGE_SHIFT 
279,"<S2SV_StartBug> switch ( bank ) <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( bank == BANK_0 ) { <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ; } else if ( bank == BANK_1 ) { <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else if ( bank == BANK_2 ) { <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else { <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) <S2SV_ModEnd> "
280,<S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff "
281,"<S2SV_StartBug> c -> c_normalize_args = Py_BuildValue ( ""(sN)"" , ""NFKC"" , Py_None ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
282,<S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug> ,<S2SV_ModStart> INT_MIN ) return - ESRCH ; if ( upid == 
283,"<S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> "
284,"<S2SV_StartBug> pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> ",<S2SV_ModStart> hdr -> sadb_msg_reserved = 0 ; 
285,"<S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> ",<S2SV_ModStart> rc = <S2SV_ModStart> rc = <S2SV_ModStart> rc = 
286,<S2SV_StartBug> if ( current -> mm ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> leave_mm ( smp_processor_id ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } else { <S2SV_ModEnd> <S2SV_ModStart> smp_mb ( ) ; } 
287,"<S2SV_StartBug> static int conditional_skipintra ( MB_PREDICTION_MODE mode , <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE mode , PREDICTION_MODE <S2SV_ModEnd> "
288,<S2SV_StartBug> struct channel_info * info = <S2SV_EndBug> ,<S2SV_ModStart> ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info 
289,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ; 
290,"<S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug> ","<S2SV_ModStart> bytes , <S2SV_ModStart> bytes <S2SV_ModEnd> <S2SV_ModStart> bytes <S2SV_ModEnd> <S2SV_ModStart> if ( copied < bytes ) break ; <S2SV_ModStart> ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] ) "
291,<S2SV_StartBug> break ; <S2SV_EndBug> ,<S2SV_ModStart> * tl_data_head = NULL ; 
292,"<S2SV_StartBug> static void write_inter_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_writer <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
293,"<S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> <S2SV_ModStart> func <S2SV_ModEnd> 
294,"<S2SV_StartBug> int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; <S2SV_EndBug> <S2SV_StartBug> uint16 bps , nstrips , planar , strips_per_sample ; <S2SV_EndBug> ","<S2SV_ModStart> bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> <S2SV_ModStart> planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> "
295,<S2SV_StartBug> int i ; <S2SV_EndBug> ,<S2SV_ModStart> jas_matind_t i ; jas_matind_t <S2SV_ModEnd> 
296,"<S2SV_StartBug> size_t count , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> <S2SV_StartBug> if ( ! NOTMIME ( ms ) ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2mime ) ; <S2SV_EndBug> ",<S2SV_ModStart> cdf_directory_t * root_storage <S2SV_ModEnd> <S2SV_ModStart> && root_storage <S2SV_ModStart> root_storage -> d_storage_uuid <S2SV_ModEnd> 
297,<S2SV_StartBug> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argc > MAX_PACK_ARGS ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart>  <S2SV_ModEnd> "
298,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
299,<S2SV_StartBug> if ( ( msr -> msc_reqbody_spilltodisk ) <S2SV_EndBug> ,<S2SV_ModStart> ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON 
300,"<S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( <S2SV_ModStart> < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> "
301,"<S2SV_StartBug> parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> & new_global_options , "
302,<S2SV_StartBug> char fnam [ PROCLEN ] ; <S2SV_EndBug> <S2SV_StartBug> char * line = NULL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> if ( nextcg ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp <S2SV_ModEnd> <S2SV_ModStart> return false <S2SV_ModEnd> <S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> out : free ( c2 <S2SV_ModEnd> "
303,<S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j >= 0 && j < elements * size ) { 
304,"<S2SV_StartBug> uint32_t off = offset , tmp , finish ; <S2SV_EndBug> <S2SV_StartBug> finish = fru -> size ; <S2SV_EndBug> <S2SV_StartBug> offset + length , finish - offset ) ; <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> <S2SV_StartBug> memcpy ( ( frubuf + off ) - offset , rsp -> data + 1 , tmp ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp == 0 && off < finish ) <S2SV_EndBug> ","<S2SV_ModStart> ; uint32_t tmp , finish ; uint32_t size_left_in_buffer <S2SV_ModEnd> <S2SV_ModStart> memset ( frubuf + fru -> size , 0 , length - fru -> size ) ; <S2SV_ModStart> ; length = finish - offset <S2SV_ModStart> size_left_in_buffer = length ; <S2SV_ModStart> if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) { printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ; return - 1 ; } <S2SV_ModStart> size_left_in_buffer -= tmp ; "
305,<S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ,<S2SV_ModStart> 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 
306,<S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug> ,<S2SV_ModStart> ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
307,"<S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> <S2SV_StartBug> ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> uint64_t <S2SV_ModEnd> <S2SV_ModStart> == UINT64_MAX ) <S2SV_ModEnd> <S2SV_ModStart> == UINT64_MAX ) && s -> off < <S2SV_ModEnd> <S2SV_ModStart> PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> "
308,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
309,"<S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ; 
310,"<S2SV_StartBug> vp8_mse16x16 ( orig + col , orig_stride , <S2SV_EndBug> ",<S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> 
311,<S2SV_StartBug> if ( * rsize >= 74 && <S2SV_EndBug> <S2SV_StartBug> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && <S2SV_EndBug> ,"<S2SV_ModStart> 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>"" ""report<S2SV_blank>descriptor\\n"" ) ; <S2SV_ModEnd> <S2SV_ModStart> = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 <S2SV_ModEnd> "
312,<S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> ,"<S2SV_ModStart> size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> alloc_size <S2SV_ModEnd> "
313,"<S2SV_StartBug> char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ; <S2SV_EndBug> ",<S2SV_ModStart> union { char bytes <S2SV_ModEnd> <S2SV_ModStart> msg ; } buf ; rfbSetEncodingsMsg * se = & buf . msg <S2SV_ModEnd> <S2SV_ModStart> . bytes <S2SV_ModStart> . bytes 
314,"<S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> ","<S2SV_ModStart> int len <S2SV_ModEnd> <S2SV_ModStart> ( hdr -> filename = fn ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( len = <S2SV_ModStart> ) < 2 <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) if ( ! ( * fn ++ <S2SV_ModEnd> <S2SV_ModStart> if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> <S2SV_ModStart> - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> <S2SV_ModStart> ; fn -- <S2SV_ModStart> ( len = <S2SV_ModStart> ) < 2 <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> ) if ( ! ( * fn ++ <S2SV_ModEnd> <S2SV_ModStart> if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> <S2SV_ModStart> - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> <S2SV_ModStart> ; fn -- "
315,<S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug> ,<S2SV_ModStart> : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : 
316,<S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ,<S2SV_ModStart> ; bpcc -> bpcs = 0 
317,"<S2SV_StartBug> return print_value ( item , 0 , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> , 0 "
318,"<S2SV_StartBug> int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) , <S2SV_EndBug> <S2SV_StartBug> if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ",<S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ; int <S2SV_ModEnd> <S2SV_ModStart> ) { if ( <S2SV_ModEnd> <S2SV_ModStart> 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> } 
319,<S2SV_StartBug> if ( setpwnam ( pw ) < 0 ) <S2SV_EndBug> ,"<S2SV_ModStart> , "".chsh"" "
320,"<S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> <S2SV_StartBug> data ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> GetByteContext gb <S2SV_ModEnd> <S2SV_ModStart> data >= data_end <S2SV_ModEnd> <S2SV_ModStart> bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> <S2SV_ModStart> return amf_get_field_value2 ( & gb <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModEnd> "
321,<S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; } 
322,<S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> [ plane ] && in -> linesize 
323,"<S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> ","<S2SV_ModStart> open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> "
324,"<S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } , <S2SV_EndBug> <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%r/proc/tty"" <S2SV_ModEnd> <S2SV_ModStart> ""%r/proc/tty"" <S2SV_ModEnd> <S2SV_ModStart> safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> "
325,"<S2SV_StartBug> PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 || <S2SV_EndBug> <S2SV_StartBug> PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> _PyDict_SetItemId <S2SV_ModEnd> <S2SV_ModStart> & PyId__fields <S2SV_ModEnd> <S2SV_ModStart> _PyDict_SetItemId <S2SV_ModEnd> <S2SV_ModStart> & PyId__attributes <S2SV_ModEnd> 
326,<S2SV_StartBug> if ( <S2SV_EndBug> ,<S2SV_ModStart> p -> replacement_session_keyring = NULL ; 
327,<S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( unsigned short ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
328,<S2SV_StartBug> dsize += svbranch . len ; <S2SV_EndBug> ,<S2SV_ModStart> + 1 
329,<S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> ,<S2SV_ModStart> atomic_dec ( & chip -> active ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
330,"<S2SV_StartBug> separator = strchr ( line , ':' ) ; <S2SV_EndBug> ",<S2SV_ModStart> osStrchr <S2SV_ModEnd> 
331,"<S2SV_StartBug> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( up , 0 , sizeof ( * up ) ) ; "
332,"<S2SV_StartBug> static void encode_share_access ( struct xdr_stream * xdr , int open_flags ) <S2SV_EndBug> <S2SV_StartBug> switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) { <S2SV_EndBug> <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> <S2SV_ModStart> WRITE32 ( 0 <S2SV_ModEnd> 
333,"<S2SV_StartBug> if ( ! headcount ) { <S2SV_EndBug> <S2SV_StartBug> msg . msg_iovlen = in ; <S2SV_EndBug> <S2SV_StartBug> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err != sock_len ) ) { <S2SV_EndBug> ","<S2SV_ModStart> unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> 1 <S2SV_ModEnd> <S2SV_ModStart> pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n"" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; "
334,"<S2SV_StartBug> name . name = buf ; <S2SV_EndBug> <S2SV_StartBug> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> err = - EINVAL ; if ( size != sizeof ( outarg ) + <S2SV_ModEnd> <S2SV_ModStart> goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) "
335,<S2SV_StartBug> trust_data . dwUIChoice = WTD_UI_ALL ; <S2SV_EndBug> <S2SV_StartBug> return r ; <S2SV_EndBug> ,"<S2SV_ModStart> WTD_UI_NONE <S2SV_ModEnd> <S2SV_ModStart> switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( ""PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( ""PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s"" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; } "
336,<S2SV_StartBug> len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ; <S2SV_EndBug> ,<S2SV_ModStart> = 20 + level <S2SV_ModEnd> 
337,"<S2SV_StartBug> pid_t child ; <S2SV_EndBug> <S2SV_StartBug> tmpdir = mkdtemp ( template ) ; <S2SV_EndBug> <S2SV_StartBug> if ( mount ( ""/proc/self/fd"" , tmpdir , NULL , MS_BIND , NULL ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>%s,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n"" , <S2SV_EndBug> <S2SV_StartBug> lo -> proc_self_fd = open ( tmpdir , O_PATH ) ; <S2SV_EndBug> <S2SV_StartBug> fuse_log ( FUSE_LOG_ERR , ""open(%s,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n"" , tmpdir ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""/proc"" <S2SV_ModEnd> <S2SV_ModStart> ""mount(/proc/self/fd,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n"" <S2SV_ModEnd> <S2SV_ModStart> ""/proc"" <S2SV_ModEnd> <S2SV_ModStart> ""open(/proc,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n"" ) ; exit ( 1 <S2SV_ModEnd> "
338,<S2SV_StartBug> int c_sz ; <S2SV_EndBug> <S2SV_StartBug> _img -> bps = _y4m -> vpx_bps ; <S2SV_EndBug> <S2SV_StartBug> pic_sz = _y4m -> pic_w * _y4m -> pic_h ; <S2SV_EndBug> <S2SV_StartBug> c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ; <S2SV_EndBug> <S2SV_StartBug> _img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w ; <S2SV_EndBug> <S2SV_StartBug> _img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_Y ] = _y4m -> dst_buf ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ; <S2SV_EndBug> ,<S2SV_ModStart> ; int bytes_per_sample = _y4m -> bit_depth > 8 ? 2 : 1 <S2SV_ModStart> bps <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample <S2SV_ModStart> c_w *= bytes_per_sample ; <S2SV_ModStart> VPX_PLANE_Y <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_ALPHA ] = <S2SV_ModEnd> <S2SV_ModStart> * bytes_per_sample <S2SV_ModStart> VPX_PLANE_U <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_V <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_Y <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_U <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_V <S2SV_ModEnd> <S2SV_ModStart> VPX_PLANE_ALPHA <S2SV_ModEnd> 
339,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
340,"<S2SV_StartBug> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> ",<S2SV_ModStart> strncpy <S2SV_ModEnd> 
341,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
342,"<S2SV_StartBug> WORD32 i ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; <S2SV_EndBug> ","<S2SV_ModStart> , j <S2SV_ModStart> j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> <S2SV_ModStart> j <S2SV_ModEnd> "
343,<S2SV_StartBug> sraSpanRemove ( sraSpan * span ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> span ) { if ( <S2SV_ModStart> } 
344,<S2SV_StartBug> prog [ N ] . pred = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! N ) { ret = - EINVAL ; parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ; goto out_free ; } "
345,<S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> ref ) { <S2SV_EndBug> ,<S2SV_ModStart> if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart>  <S2SV_ModEnd> 
346,"<S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> ",<S2SV_ModStart> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart>  <S2SV_ModEnd> 
347,<S2SV_StartBug> static inline __u32 dccp_v6_init_sequence ( struct sk_buff * skb ) <S2SV_EndBug> ,<S2SV_ModStart> __u64 <S2SV_ModEnd> 
348,<S2SV_StartBug> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <S2SV_EndBug> ,<S2SV_ModStart> tk_rebind_retry = 2 ; task -> 
349,"<S2SV_StartBug> expr_ty returns ; <S2SV_EndBug> <S2SV_StartBug> * out = FunctionDef ( name , args , body , decorator_list , returns , lineno , <S2SV_EndBug> <S2SV_StartBug> expr_ty returns ; <S2SV_EndBug> <S2SV_StartBug> * out = AsyncFunctionDef ( name , args , body , decorator_list , returns , <S2SV_EndBug> <S2SV_StartBug> lineno , col_offset , end_lineno , end_col_offset , <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_LookupAttrId ( obj , & PyId_targets , & tmp ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> * out = Assign ( targets , value , lineno , col_offset , end_lineno , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * orelse ; <S2SV_EndBug> <S2SV_StartBug> * out = For ( target , iter , body , orelse , lineno , col_offset , end_lineno , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * orelse ; <S2SV_EndBug> <S2SV_StartBug> * out = AsyncFor ( target , iter , body , orelse , lineno , col_offset , <S2SV_EndBug> <S2SV_StartBug> if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> * out = With ( items , body , lineno , col_offset , end_lineno , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * body ; <S2SV_EndBug> <S2SV_StartBug> * out = AsyncWith ( items , body , lineno , col_offset , end_lineno , <S2SV_EndBug> ","<S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> string type_comment ; <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , <S2SV_ModStart> string type_comment ; <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , type_comment <S2SV_ModStart> ; string type_comment <S2SV_ModStart> if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> type_comment , "
350,<S2SV_StartBug> if ( s -> width != avctx -> width && s -> height != avctx -> height ) { <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> 
351,<S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> sctp_copy_descendant <S2SV_ModEnd> 
352,"<S2SV_StartBug> struct snd_ctl_elem_id id ; <S2SV_EndBug> <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> ",<S2SV_ModStart> ; unsigned int count <S2SV_ModStart> count = kcontrol -> count ; <S2SV_ModStart>  <S2SV_ModEnd> 
353,"<S2SV_StartBug> if ( nelements == 0 ) { <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , <S2SV_EndBug> ","<S2SV_ModStart> > CDF_ELEMENT_LIMIT || nelements <S2SV_ModStart> ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
354,<S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> ) 
355,"<S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> ","<S2SV_ModStart> = 0 <S2SV_ModStart> || numChannels > 256 <S2SV_ModStart> if ( ! config -> num_channels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } "
356,"<S2SV_StartBug> BIGNUM a , c , d , e ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> a . neg = rand_neg ( ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sqr ( & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> <S2SV_StartBug> BN_print ( bp , & c ) ; <S2SV_EndBug> <S2SV_StartBug> BN_div ( & d , & e , & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sub ( & d , & d , & a ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ","<S2SV_ModStart> * a , * c , * d , * <S2SV_ModEnd> <S2SV_ModStart> , ret = 0 ; a = BN_new ( ) ; c = BN_new ( ) ; d = BN_new ( ) ; e = BN_new ( ) ; if ( a == NULL || c == NULL || d == NULL || e == NULL ) { goto err ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> c , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> d , e , c , <S2SV_ModEnd> <S2SV_ModStart> d , d , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> e ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; goto err ; } } BN_hex2bn ( & a , ""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d <S2SV_ModEnd> <S2SV_ModStart> ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } BN_hex2bn ( & a , ""80000000000000000000000080000001FFFFFFFE000000000000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } ret = 1 ; err : if ( a != NULL ) BN_free ( a ) ; if ( c != NULL ) BN_free ( c ) ; if ( d != NULL ) BN_free ( d ) ; if ( e != NULL ) BN_free ( e <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
357,"<S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> <S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> <S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> ",<S2SV_ModStart> 1U <S2SV_ModEnd> <S2SV_ModStart> 1U <S2SV_ModEnd> <S2SV_ModStart> 1U <S2SV_ModEnd> 
358,<S2SV_StartBug> if ( verify_vc_kbmode ( fd_d ) < 0 ) <S2SV_EndBug> ,<S2SV_ModStart> vt_verify_kbmode <S2SV_ModEnd> 
359,<S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> ,"<S2SV_ModStart> raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ; "
360,<S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> ,<S2SV_ModStart> ; fpm_globals . listening_socket = dup ( wp -> listening_socket ) 
361,<S2SV_StartBug> goto retry ; <S2SV_EndBug> ,"<S2SV_ModStart> err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ; "
362,"<S2SV_StartBug> fprintf ( file , ""<S2SV_blank>%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> ","<S2SV_ModStart> fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> <S2SV_ModStart> file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> , file "
363,"<S2SV_StartBug> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> <S2SV_StartBug> if ( vdaux < 1 ) { <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> ",<S2SV_ModStart> end - <S2SV_ModStart> > i <S2SV_ModEnd> <S2SV_ModStart> || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> end - vstart < <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> end - vstart < <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
364,<S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; next_input = input + i * input_incr <S2SV_ModStart> bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ; "
365,<S2SV_StartBug> random_ether_addr ( dev -> dev_addr ) ; <S2SV_EndBug> ,<S2SV_ModStart> dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; 
366,"<S2SV_StartBug> near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 2 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 4 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 5 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 3 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 6 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 7 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
367,<S2SV_StartBug> out_dqrele : <S2SV_EndBug> ,"<S2SV_ModStart> xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; "
368,<S2SV_StartBug> static void parse_input ( h2o_http2_conn_t * conn ) <S2SV_EndBug> <S2SV_StartBug> close_connection ( conn ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> 0 <S2SV_ModStart> return 0 ; 
369,"<S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> <S2SV_StartBug> data + offset , <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> offset , data_size - "
370,"<S2SV_StartBug> if ( ! av_strstart ( proto_name , ""http"" , NULL ) && ! av_strstart ( proto_name , ""file"" , NULL ) ) <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""file"" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , ""ALL"" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , ""Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n"" ""If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n"" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <S2SV_ModStart> ) { ; } else <S2SV_ModEnd> "
371,<S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> <S2SV_StartBug> return union_desc ; <S2SV_EndBug> ,"<S2SV_ModStart> >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , ""Too<S2SV_blank>large<S2SV_blank>descriptor\\n"" ) ; return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , ""Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)"" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> "
372,"<S2SV_StartBug> i += 2 ; <S2SV_EndBug> <S2SV_StartBug> ( i + 2 == NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == COMMA ) ) { <S2SV_EndBug> <S2SV_StartBug> res = handle_keywordonly_args ( c , n , i , <S2SV_EndBug> <S2SV_StartBug> i += 3 ; <S2SV_EndBug> <S2SV_StartBug> i += 3 ; <S2SV_EndBug> ","<S2SV_ModStart> 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) <S2SV_ModStart> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } <S2SV_ModStart> 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } <S2SV_ModEnd> <S2SV_ModStart> 2 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 <S2SV_ModEnd> "
373,<S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> } 
374,<S2SV_StartBug> ASSERT ( redir_index < IOAPIC_NUM_PINS ) ; <S2SV_EndBug> <S2SV_StartBug> redir_content = ioapic -> redirtbl [ redir_index ] . bits ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; else redir_content = ~ 0ULL 
375,"<S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
376,"<S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> goto out_errno ; <S2SV_EndBug> <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ","<S2SV_ModStart> error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> <S2SV_ModStart> fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <S2SV_ModEnd> <S2SV_ModStart> out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> <S2SV_ModStart> ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> "
377,<S2SV_StartBug> pvc . sap_family = AF_ATMPVC ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & pvc , 0 , sizeof ( pvc ) ) ; "
378,<S2SV_StartBug> cancel_delayed_work_sync ( & ln -> grace_period_end ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
379,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
380,<S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> ,<S2SV_ModStart> req ) ; kfree ( 
381,"<S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> posix_acl_update_mode ( inode <S2SV_ModEnd> <S2SV_ModStart> , & acl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
382,"<S2SV_StartBug> netdev_dbg ( vif -> dev , ""Need<S2SV_blank>more<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Too<S2SV_blank>many<S2SV_blank>frags\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Frags<S2SV_blank>galore\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> netdev_dbg ( vif -> dev , ""txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n"" , <S2SV_EndBug> <S2SV_StartBug> txp -> offset , txp -> size ) ; <S2SV_EndBug> ","<S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> netdev_err ( vif -> dev , ""Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> <S2SV_ModStart> netdev_err <S2SV_ModEnd> <S2SV_ModStart> ) ; netbk_fatal_tx_err ( vif "
383,<S2SV_StartBug> const struct aodv_hello * ah ; <S2SV_EndBug> <S2SV_StartBug> goto trunc ; <S2SV_EndBug> ,"<S2SV_ModStart> ; ND_TCHECK ( * ep ) <S2SV_ModStart> if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , ""\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u"" , ep -> length ) ) ; break ; } "
384,<S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock 
385,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> DeleteCriticalSection ( & reference_queue_mutex ) ; 
386,"<S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> start , * <S2SV_ModStart> start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> start <S2SV_ModEnd> <S2SV_ModStart> var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> var -> already_scanned = 0 ; "
387,"<S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> if ( strlen ( <S2SV_ModEnd> <S2SV_ModStart> >= sizeof ( szVal ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 ) "
388,<S2SV_StartBug> out_put : <S2SV_EndBug> <S2SV_StartBug> return datagrams ; <S2SV_EndBug> <S2SV_StartBug> return datagrams ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( err == 0 ) goto out_put ; if ( datagrams <S2SV_ModEnd> <S2SV_ModStart> { datagrams = err ; goto out_put ; } <S2SV_ModEnd> <S2SV_ModStart> out_put : fput_light ( sock -> file , fput_needed ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
389,<S2SV_StartBug> message -> srcIpAddr = queueItem -> srcIpAddr ; <S2SV_EndBug> ,<S2SV_ModStart> interface = queueItem -> interface ; message -> 
390,"<S2SV_StartBug> int hns_nic_net_xmit_hw ( struct net_device * ndev , <S2SV_EndBug> <S2SV_StartBug> wmb ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> netdev_tx_t <S2SV_ModEnd> <S2SV_ModStart> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; 
391,<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> return 1 ; "
392,"<S2SV_StartBug> vma_stop ( priv , vma ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! IS_ERR ( vma ) ) 
393,"<S2SV_StartBug> if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret > 0 ) <S2SV_EndBug> ","<S2SV_ModStart> size_t data_size = 0 ; <S2SV_ModStart> , & data_size <S2SV_ModStart> ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ( ssize_t ) ( data_size ) ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret > "
394,"<S2SV_StartBug> slapi_pblock_get ( pb , SLAPI_PB_RESULT_TEXT , & pbtext ) ; <S2SV_EndBug> ",<S2SV_ModStart> SLAPI_RESULT_TEXT <S2SV_ModEnd> 
395,"<S2SV_StartBug> if ( jas_init ( ) ) { <S2SV_EndBug> <S2SV_StartBug> infile = 0 ; <S2SV_EndBug> <S2SV_StartBug> case OPT_MAXMEM : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( numcmpts = jas_image_numcmpts ( image ) ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { <S2SV_EndBug> <S2SV_StartBug> printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t max_samples ; char optstr [ 32 ] ; <S2SV_ModStart> max_samples = 64 * JAS_MEBI ; <S2SV_ModStart> OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <S2SV_ModStart> snprintf ( optstr , sizeof ( optstr ) , ""max_samples=%-zu"" , max_samples ) ; <S2SV_ModStart> optstr <S2SV_ModEnd> <S2SV_ModStart> fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( ""format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\n"" ) ; return EXIT_FAILURE ; } if ( ! ( <S2SV_ModStart> printf ( ""%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n"" , fmtname <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( long , <S2SV_ModEnd> <S2SV_ModStart> ) "
396,"<S2SV_StartBug> static void update_state ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> const struct segmentation * const seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> if ( seg -> enabled && output_enabled ) { <S2SV_EndBug> <S2SV_StartBug> vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) { <S2SV_EndBug> <S2SV_StartBug> mi_row , mi_col , bsize , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_32X32 ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk , <S2SV_EndBug> <S2SV_StartBug> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) { <S2SV_EndBug> <S2SV_StartBug> vp9_update_mv_count ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> ++ cm -> counts . switchable_interp [ ctx ] [ mbmi -> interp_filter ] ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_diff [ i ] += ctx -> best_filter_diff [ i ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , <S2SV_ModStart> RD_COUNTS * const rdc = & td -> rd_counts ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h <S2SV_ModStart> * x -> mbmi_ext = ctx -> mbmi_ext ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_segment_id <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ctx -> rate , ctx -> dist , x -> skip <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> td -> counts -> <S2SV_ModEnd> <S2SV_ModStart> rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> rdc -> comp_pred_diff <S2SV_ModEnd> <S2SV_ModStart> rdc -> filter_diff <S2SV_ModEnd> <S2SV_ModStart> for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } } "
397,"<S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> ","<S2SV_ModStart> _gdImageWBMPCtx <S2SV_ModEnd> <S2SV_ModStart> fg , out <S2SV_ModEnd> "
398,"<S2SV_StartBug> oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ; <S2SV_EndBug> <S2SV_StartBug> const char * error_description = NULL ; <S2SV_EndBug> <S2SV_StartBug> ""Malformed<S2SV_blank>URL"" , error_description , <S2SV_EndBug> ","<S2SV_ModStart> char * error_str = NULL ; char * error_description = NULL ; <S2SV_ModStart> if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) { <S2SV_ModEnd> <S2SV_ModStart> error_str , error_description , HTTP_BAD_REQUEST <S2SV_ModEnd> "
399,"<S2SV_StartBug> uint16 bitspersample , samplesperpixel = 1 ; <S2SV_EndBug> ",<S2SV_ModStart> = 1 
400,"<S2SV_StartBug> int error ; <S2SV_EndBug> <S2SV_StartBug> error = pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ; <S2SV_EndBug> <S2SV_StartBug> error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) ; <S2SV_EndBug> <S2SV_StartBug> error = pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
401,"<S2SV_StartBug> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <S2SV_EndBug> ",<S2SV_ModStart> ASN1_F_ASN1_ITEM_VERIFY <S2SV_ModEnd> 
402,<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } else if ( ctx -> might_cancel ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> { __timerfd_remove_cancel <S2SV_ModEnd> <S2SV_ModStart> spin_unlock ( & ctx -> cancel_lock ) ; 
403,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> case EGRESS_VLAN_NAME : <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; * data && i < length ; i ++ , data ++ ) <S2SV_EndBug> ","<S2SV_ModStart> goto trunc ; <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; if ( * data ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; } <S2SV_ModEnd> <S2SV_ModStart> if ( length < 1 ) goto trunc ; <S2SV_ModStart> i < length && * data <S2SV_ModEnd> "
404,<S2SV_StartBug> as -> length + len * 2 + 1 ) == NULL ) <S2SV_EndBug> ,"<S2SV_ModStart> max ( <S2SV_ModStart> , ( size_t ) MB_CUR_MAX ) "
405,"<S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( tm2interval ( tm , fsec , result ) != 0 ) <S2SV_EndBug> ","<S2SV_ModStart> > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <S2SV_ModEnd> <S2SV_ModStart> free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
406,<S2SV_StartBug> sas_port_delete ( phy -> port ) ; <S2SV_EndBug> ,"<S2SV_ModStart> list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> "
407,"<S2SV_StartBug> log_err ( ctx , ""Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\n"" , <S2SV_EndBug> <S2SV_StartBug> xkb_file_type_to_string ( file -> file_type ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , ""Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n"" ) ; } else { <S2SV_ModStart> } "
408,<S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
409,"<S2SV_StartBug> static VALUE from_document ( VALUE klass , VALUE document ) <S2SV_EndBug> <S2SV_StartBug> Data_Get_Struct ( document , xmlDoc , doc ) ; <S2SV_EndBug> <S2SV_StartBug> doc = doc -> doc ; <S2SV_EndBug> <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> ","<S2SV_ModStart> int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; int parse_options_int ; <S2SV_ModEnd> <S2SV_ModStart> int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & document , & parse_options ) ; <S2SV_ModStart> ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) <S2SV_ModStart> rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ; "
410,<S2SV_StartBug> usb_unanchor_urb ( urb ) ; <S2SV_EndBug> ,<S2SV_ModStart> ( urb ) ; usb_free_urb 
411,"<S2SV_StartBug> int fd = accept ( socket -> fd , NULL , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
412,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <S2SV_EndBug> <S2SV_StartBug> perf_event_for_each_child ( event , perf_event_enable ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct perf_event_context * ctx ; <S2SV_ModStart> { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> _perf_event_enable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> "
413,<S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> <S2SV_StartBug> return get_desc_base ( desc ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> get_desc ( & desc , sel ) <S2SV_ModEnd> <S2SV_ModStart> & "
414,"<S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> * cp == '\\0' || <S2SV_ModEnd> <S2SV_ModStart> || <S2SV_ModEnd> <S2SV_ModStart> ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart>  <S2SV_ModEnd> "
415,"<S2SV_StartBug> pfd . events = POLLIN ; <S2SV_EndBug> <S2SV_StartBug> len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len < 0 ) { <S2SV_EndBug> <S2SV_StartBug> syslog ( LOG_ERR , ""recv<S2SV_blank>failed;<S2SV_blank>error:%d"" , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <S2SV_ModStart> recvfrom <S2SV_ModEnd> <S2SV_ModStart> , addr_p , & addr_l <S2SV_ModStart> || addr . nl_pid <S2SV_ModStart> ""recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s"" , addr . nl_pid , errno , strerror ( errno ) <S2SV_ModEnd> "
416,"<S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
417,<S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> ,"<S2SV_ModStart> u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModStart> ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , ""USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n"" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart>  <S2SV_ModEnd> "
418,"<S2SV_StartBug> struct nfs4_state_owner * sp , int flags , <S2SV_EndBug> <S2SV_StartBug> p -> o_arg . open_flags = flags , <S2SV_EndBug> ","<S2SV_ModStart> , fmode_t fmode <S2SV_ModStart> ; p -> o_arg . fmode = fmode & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModEnd> "
419,<S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ,"<S2SV_ModStart> ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL "
420,"<S2SV_StartBug> struct page * pages [ NFS4ACL_MAXPAGES ] ; <S2SV_EndBug> <S2SV_StartBug> struct page * localpage = NULL ; <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > args . acl_len ) <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res . acl_len > buflen ) <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( buf , resp_buf , res . acl_len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> __free_page ( localpage ) ; <S2SV_EndBug> ","<S2SV_ModStart> = { NULL , } <S2SV_ModStart> int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> <S2SV_ModStart> res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> <S2SV_ModStart> acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + res . acl_data_offset , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> _copy_from_pages <S2SV_ModEnd> <S2SV_ModStart> pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> <S2SV_ModStart> for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> <S2SV_ModStart> pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> "
421,"<S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> <S2SV_StartBug> opt = inet_sk ( sk ) -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug> <S2SV_StartBug> return cipso_v4_getattr ( opt -> __data + opt -> cipso - sizeof ( struct iphdr ) , <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> ip_options_rcu <S2SV_ModEnd> <S2SV_ModStart> int res = - ENOMSG ; rcu_read_lock ( ) ; opt = rcu_dereference ( <S2SV_ModEnd> <S2SV_ModStart> inet_opt ) <S2SV_ModEnd> <S2SV_ModStart> && opt -> opt . cipso ) res = <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> rcu_read_unlock ( ) ; return res ; 
422,<S2SV_StartBug> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <S2SV_EndBug> <S2SV_StartBug> encode_nops ( & hdr ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ; "
423,<S2SV_StartBug> char common_name [ FIELD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> FIELD_SIZE ) == 0 ) <S2SV_EndBug> ,<S2SV_ModStart> if ( validate_hostname ( <S2SV_ModEnd> <S2SV_ModStart> cert ) == MatchFound <S2SV_ModEnd> 
424,<S2SV_StartBug> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <S2SV_EndBug> ,<S2SV_ModStart> tk_rebind_retry = 2 ; task -> 
425,<S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
426,"<S2SV_StartBug> vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> 
427,<S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> ,<S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModEnd> <S2SV_ModStart> - p ) 
428,<S2SV_StartBug> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <S2SV_EndBug> <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( ubufs ) ; <S2SV_EndBug> ,<S2SV_ModStart> vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> <S2SV_ModStart> vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> 
429,"<S2SV_StartBug> vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { vp8_denoiser_free ( & cpi -> denoiser ) ; vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ; } # endif "
430,"<S2SV_StartBug> jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" <S2SV_ModStart> if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( ""RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n"" ) ; return - 1 ; } "
431,<S2SV_StartBug> outpos += <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> sprintf ( outputbuffer <S2SV_ModEnd> <S2SV_ModStart> sendClean ( outputbuffer ) ; 
432,<S2SV_StartBug> if ( class == - 1 ) { <S2SV_EndBug> ,"<S2SV_ModStart> || class == CLIENT_TYPE_MASTER ) { err = ""Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>"" ""an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits."" <S2SV_ModEnd> "
433,"<S2SV_StartBug> while ( * end_ptr != \'\\""\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> 
434,"<S2SV_StartBug> sk_wait_data ( sk , & timeo , NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ; 
435,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( inode_capable ( inode , CAP_FOWNER ) ) <S2SV_EndBug> ","<S2SV_ModStart> struct user_namespace * ns ; <S2SV_ModStart> ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> "
436,<S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> qboolean isLocalConfig ; <S2SV_ModStart> isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> if ( isLocalConfig && search -> pack ) continue ; "
437,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> assert ( profile < MAX_PROFILES ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , profile & 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , profile >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> switch ( profile ) { case PROFILE_0 : vpx_wb_write_literal ( wb , 0 , 2 ) ; break ; case PROFILE_1 : vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> 2 , 2 ) ; break ; case PROFILE_2 : vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> 1 , 2 ) ; break ; case PROFILE_3 : vpx_wb_write_literal ( wb , 6 , 3 ) ; break ; default : assert ( 0 <S2SV_ModEnd> <S2SV_ModStart> } "
438,<S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
439,<S2SV_StartBug> struct IGDdatas * datas = ( struct IGDdatas * ) d ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1 
440,"<S2SV_StartBug> if ( PyDict_SetItemString ( d , ""mod"" , ( PyObject * ) mod_type ) < 0 ) return NULL ; <S2SV_EndBug> <S2SV_StartBug> if ( PyDict_SetItemString ( d , ""Suite"" , ( PyObject * ) Suite_type ) < 0 ) return <S2SV_EndBug> <S2SV_StartBug> if ( PyDict_SetItemString ( d , ""withitem"" , ( PyObject * ) withitem_type ) < 0 ) <S2SV_EndBug> ","<S2SV_ModStart> PyModule_AddIntMacro ( m , PyCF_TYPE_COMMENTS ) < 0 ) return NULL ; if ( <S2SV_ModStart> ""FunctionType"" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , <S2SV_ModStart> ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""type_ignore"" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , ""TypeIgnore"" , ( PyObject * ) TypeIgnore_type "
441,"<S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; 
442,"<S2SV_StartBug> L3 = emitjump ( J , F , OP_JUMP ) ; <S2SV_EndBug> ","<S2SV_ModStart> emit ( J , F , OP_ENDTRY ) ; "
443,"<S2SV_StartBug> unsigned int depth ) { <S2SV_EndBug> <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_alloc_frame_buffer ( & ctx -> buf [ i ] . img , <S2SV_EndBug> <S2SV_StartBug> VP9_ENC_BORDER_IN_PIXELS ) ) <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> const int legacy_byte_alignment = 0 ; <S2SV_ModStart> vpx_alloc_frame_buffer <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment <S2SV_ModEnd> "
444,<S2SV_StartBug> if ( err ) <S2SV_EndBug> <S2SV_StartBug> goto err_cqwq ; <S2SV_EndBug> ,<S2SV_ModStart> { kvfree ( in ) ; <S2SV_ModStart> } 
445,<S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> ,<S2SV_ModStart> mp -> timer_armed && 
446,"<S2SV_StartBug> static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) <S2SV_EndBug> <S2SV_StartBug> io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> io -> error = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> , gfp_t flags <S2SV_ModStart> flags <S2SV_ModEnd> <S2SV_ModStart> page = NULL <S2SV_ModEnd> "
447,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( _TIFFReadEncodedStripAndAllocBuffer ( tif , <S2SV_EndBug> <S2SV_StartBug> ( ( row + img -> row_offset ) % rowsperstrip + nrowsub ) * scanline ) == ( tmsize_t ) ( - 1 ) <S2SV_EndBug> ","<S2SV_ModStart> uint32 temp ; <S2SV_ModStart> temp = ( row + img -> row_offset ) % rowsperstrip + nrowsub ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , ""Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripContig"" ) ; return 0 ; } <S2SV_ModStart> temp <S2SV_ModEnd> "
448,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
449,"<S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
450,<S2SV_StartBug> if ( count >= 4 ) { <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
451,"<S2SV_StartBug> const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ; <S2SV_EndBug> <S2SV_StartBug> struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( ref = 0 ; ref < 2 ; ++ ref ) { <S2SV_EndBug> <S2SV_StartBug> ref_mv [ ref ] = mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> for ( ite = 0 ; ite < 4 ; ite ++ ) { <S2SV_EndBug> <S2SV_StartBug> int_mv tmp_mv ; <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , <S2SV_EndBug> <S2SV_StartBug> & xd -> block_refs [ ! id ] -> sf , <S2SV_EndBug> <S2SV_StartBug> tmp_mv . as_int = frame_mv [ refs [ id ] ] . as_int ; <S2SV_EndBug> <S2SV_StartBug> tmp_mv . as_mv . row >>= 3 ; <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_refining_search_8p_c ( x , & tmp_mv . as_mv , sadpb , <S2SV_EndBug> <S2SV_StartBug> bestsme = vp9_get_mvpred_av_var ( x , & tmp_mv . as_mv , & ref_mv [ id ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> bestsme = cpi -> find_fractional_mv_step_comp ( <S2SV_EndBug> <S2SV_StartBug> x , & tmp_mv . as_mv , <S2SV_EndBug> <S2SV_StartBug> & ref_mv [ id ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> 0 , cpi -> sf . subpel_iters_per_step , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] = scaled_first_yv12 ; <S2SV_EndBug> <S2SV_StartBug> frame_mv [ refs [ id ] ] . as_int = tmp_mv . as_int ; <S2SV_EndBug> <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ ref ] ] [ 0 ] . as_mv , <S2SV_EndBug> <S2SV_StartBug> vpx_free ( second_pred ) ; <S2SV_EndBug> ","<S2SV_ModStart> VP9_COMMON * const cm = & cpi -> common ; const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vp9_filter_kernels [ <S2SV_ModEnd> <S2SV_ModStart> ] ; struct scale_factors sf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ; uint8_t * second_pred ; # else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ; # endif <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ; # endif <S2SV_ModStart> MV <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ; vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE , xd -> bd ) ; } else { second_pred = ( uint8_t * ) second_pred_alloc_16 ; <S2SV_ModStart> sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; } # else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; # endif if ( id ) xd -> <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> as_mv ; tmp_mv <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] <S2SV_ModStart> second_pred <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> find_fractional_mv_step <S2SV_ModEnd> <S2SV_ModStart> , & ref_mv [ id ] <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mv . subpel_iters_per_step , NULL , <S2SV_ModEnd> <S2SV_ModStart> ref_yv12 [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> as_mv = tmp_mv <S2SV_ModEnd> <S2SV_ModStart> x -> mbmi_ext <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
452,<S2SV_StartBug> if ( ( tot_len - offset - 4 ) < bodyLength ) { <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) 
453,<S2SV_StartBug> v -> count = c ; <S2SV_EndBug> <S2SV_StartBug> if ( c > 0 ) <S2SV_EndBug> ,<S2SV_ModStart> log2_count <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
454,"<S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> <S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , <S2SV_ModStart> p_total_data_size , "
455,"<S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> ",<S2SV_ModStart> static 
456,<S2SV_StartBug> dst [ dst_byte_offset ] = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
457,"<S2SV_StartBug> ret = copy_to_user ( uattr , attr , usize ) ; <S2SV_EndBug> ",<S2SV_ModStart> attr -> size <S2SV_ModEnd> 
458,<S2SV_StartBug> ulong tmp ; <S2SV_EndBug> ,<S2SV_ModStart> jas_ulong <S2SV_ModEnd> 
459,<S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( error == 0 ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ops != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ! ops ) { pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n"" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> <S2SV_ModStart> if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> <S2SV_ModStart> if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> <S2SV_ModStart> if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> <S2SV_ModStart> if ( ! ops ) { pr_warn ( ""No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n"" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> "
460,"<S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
461,"<S2SV_StartBug> for ( j = 0 ; j < len ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> av_log ( s , AV_LOG_DEBUG , ""%X"" , avio_r8 ( pb ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> } 
462,"
","
"
463,<S2SV_StartBug> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) <S2SV_EndBug> ,"<S2SV_ModStart> strcmp ( sub_demuxer -> name , ""srt"" ) && strcmp ( sub_demuxer -> name , ""ass"" ) ) goto error ; if ( "
464,"<S2SV_StartBug> unsigned char * const seg_map = cpi -> segmentation_map ; <S2SV_EndBug> <S2SV_StartBug> const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ; <S2SV_EndBug> <S2SV_StartBug> ( cpi -> svc . temporal_layer_id > 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME ) <S2SV_EndBug> <S2SV_StartBug> cr -> sb_index = 0 ; <S2SV_EndBug> <S2SV_StartBug> int i , block_count , bl_index , sb_rows , sb_cols , sbs_in_frame ; <S2SV_EndBug> <S2SV_StartBug> const float rate_ratio_qdelta = 2.0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_set_segdata ( seg , 1 , SEG_LVL_ALT_Q , qindex_delta ) ; <S2SV_EndBug> <S2SV_StartBug> sb_cols = ( cm -> mi_cols + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( cm -> current_video_frame == 0 ) cr -> low_content_avg = 0.0 <S2SV_ModStart> || ( cpi -> svc . spatial_layer_id > 0 ) ) { unsigned char * const seg_map = cpi -> segmentation_map ; memset <S2SV_ModEnd> <S2SV_ModStart> { memset ( cr -> last_coded_q_map , MAXQ , cm -> mi_rows * cm -> mi_cols * sizeof ( * cr -> last_coded_q_map ) ) ; <S2SV_ModStart> } <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> double q = vp9_convert_qindex_to_q ( cm -> base_qindex , cm -> bit_depth ) ; vpx_clear_system_state ( ) ; cr -> thresh_rate_sb = ( ( int64_t ) ( rc -> sb64_target_rate ) << 8 ) << 2 ; cr -> thresh_dist_sb = ( ( int64_t ) ( q * q ) ) << 2 ; vp9_enable_segmentation ( & cm -> seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , CR_SEGMENT_ID_BASE , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , cr -> rate_ratio_qdelta ) ; cr -> qindex_delta [ 1 ] = qindex_delta <S2SV_ModEnd> <S2SV_ModStart> CR_SEGMENT_ID_BOOST1 <S2SV_ModEnd> <S2SV_ModStart> qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , MIN ( CR_MAX_RATE_TARGET_RATIO , 0.1 * cr -> rate_boost_fac * cr -> rate_ratio_qdelta ) ) ; cr -> qindex_delta [ 2 ] = qindex_delta ; vp9_set_segdata ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q , qindex_delta ) ; cyclic_refresh_update_map ( cpi ) <S2SV_ModEnd> "
465,"<S2SV_StartBug> bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <S2SV_EndBug> ",<S2SV_ModStart> KVM_MAX_VCPU_ID <S2SV_ModEnd> 
466,"<S2SV_StartBug> ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; <S2SV_EndBug> <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> ",<S2SV_ModStart> quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> if ( quantum_info != ( QuantumInfo * ) NULL ) 
467,<S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL 
468,"<S2SV_StartBug> register u_int length = h -> len ; <S2SV_EndBug> <S2SV_StartBug> return ( chdlc_print ( ndo , p , length ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModEnd> <S2SV_ModStart> h -> len <S2SV_ModEnd> 
469,<S2SV_StartBug> if ( block ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
470,"<S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> <S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> ",<S2SV_ModStart> if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <S2SV_ModStart> if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } 
471,"<S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug> ","<S2SV_ModStart> size_t size ; <S2SV_ModStart> if ( ! jas_safe_size_mul ( <S2SV_ModEnd> <S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> , & size <S2SV_ModEnd> <S2SV_ModStart> dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( ""numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n"" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } "
472,<S2SV_StartBug> tfrc . tfrctx_x = hc -> tx_x ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & tfrc , 0 , sizeof ( tfrc ) ) ; "
473,<S2SV_StartBug> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
474,"<S2SV_StartBug> if ( jp2_getuint16 ( in , & pclr -> numlutents ) || <S2SV_EndBug> ",<S2SV_ModStart> pclr -> bpc = 0 ; 
475,<S2SV_StartBug> if ( item_num > 65536 ) { <S2SV_EndBug> ,<S2SV_ModStart> || item_num < 0 
476,"<S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""gnuplot<S2SV_blank>%s"" , cmdname ) ; <S2SV_EndBug> <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""wgnuplot<S2SV_blank>%s"" , cmdname ) ; <S2SV_EndBug> ",<S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> L_BUFSIZE <S2SV_ModEnd> 
477,"<S2SV_StartBug> dprintk ( 2 , ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> ","<S2SV_ModStart> ""vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> "
478,"<S2SV_StartBug> run_cmd ( int fd , ... ) <S2SV_EndBug> <S2SV_StartBug> char cmd [ 512 ] ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> strcpy ( cmd , EXEC ) ; <S2SV_EndBug> <S2SV_StartBug> fd_printf ( STDERR_FILENO , ""%s\\n"" , & cmd [ sizeof ( EXEC ) - 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> exit ( 42 ) ; <S2SV_EndBug> ","<S2SV_ModStart> const char * cmd , const char * args_extra <S2SV_ModEnd> <S2SV_ModStart> int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> <S2SV_ModStart> argc = 0 ; r = split_quoted <S2SV_ModEnd> <S2SV_ModStart> & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>command\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , ""Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , ""No<S2SV_blank>command<S2SV_blank>given\\n"" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , ""$<S2SV_blank>%s<S2SV_blank>%s\\n"" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <S2SV_ModEnd> <S2SV_ModStart> ""exec:<S2SV_blank>%s\\n"" , strerror ( errno ) <S2SV_ModEnd> <S2SV_ModStart> RUNCMD_EXEC_FAIL <S2SV_ModEnd> "
479,<S2SV_StartBug> aio_free_ring ( ctx ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
480,"<S2SV_StartBug> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <S2SV_EndBug> ","<S2SV_ModStart> siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n"" ) ; return - 1 ; } if ( "
481,"<S2SV_StartBug> char * driver_override , * old = pdev -> driver_override , * cp ; <S2SV_EndBug> <S2SV_StartBug> if ( strlen ( driver_override ) ) { <S2SV_EndBug> <S2SV_StartBug> kfree ( old ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> device_unlock ( dev ) ; 
482,"<S2SV_StartBug> save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; <S2SV_EndBug> ",<S2SV_ModStart> { <S2SV_ModStart> problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; } 
483,<S2SV_StartBug> root_storage -> d_storage_uuid ) ) < 0 ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
484,"<S2SV_StartBug> & msg -> addrto , & msg -> ifindex ) ; <S2SV_EndBug> <S2SV_StartBug> dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & msg -> hoplimit <S2SV_ModStart> ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" <S2SV_ModEnd> <S2SV_ModStart> , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , ""ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)"" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> "
485,"<S2SV_StartBug> int i ; <S2SV_EndBug> <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug> ",<S2SV_ModStart> ret = pci_read_config_word <S2SV_ModEnd> <S2SV_ModStart> ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> <S2SV_ModStart> cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> 
486,"<S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) { <S2SV_EndBug> <S2SV_StartBug> return ( MB_PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ; <S2SV_EndBug> ",<S2SV_ModStart> PREDICTION_MODE read_intra_mode ( vpx_reader <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE ) vpx_read_tree <S2SV_ModEnd> 
487,<S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug> ,<S2SV_ModStart> = { } 
488,"<S2SV_StartBug> vpx_memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> 
489,"<S2SV_StartBug> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( hlist_unhashed ( & mp -> mglist ) ) 
490,"<S2SV_StartBug> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <S2SV_EndBug> ","<S2SV_ModStart> ff_set_dimensions ( avctx , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
491,"<S2SV_StartBug> DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" , <S2SV_EndBug> <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> ","<S2SV_ModStart> if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ; continue ; } <S2SV_ModStart> if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized"" , filegen_file ) ; continue ; } "
492,<S2SV_StartBug> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> can_follow_write_pte ( pte , flags <S2SV_ModEnd> "
493,<S2SV_StartBug> kfree ( ubufs ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
494,"<S2SV_StartBug> static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_EndBug> <S2SV_StartBug> struct segmentation * const seg = & cm -> seg ; <S2SV_EndBug> <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> int mi_offset , int x_mis , int y_mis , vpx_reader <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> } <S2SV_ModStart> mi_offset , x_mis , y_mis <S2SV_ModEnd> "
495,"<S2SV_StartBug> ext2_xattr_cache_insert ( struct buffer_head * bh ) <S2SV_EndBug> <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ; <S2SV_EndBug> <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> ea_bdebug ( bh , ""inserting<S2SV_blank>[%x]<S2SV_blank>(%d<S2SV_blank>cache<S2SV_blank>entries)"" , ( int ) hash , <S2SV_EndBug> ","<S2SV_ModStart> struct mb2_cache * cache , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> error = mb2_cache_entry_create ( cache , GFP_NOFS , hash <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ""inserting<S2SV_blank>[%x]"" <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> "
496,"<S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , ""missing<S2SV_blank>endpoints\\n"" ) ; return - ENODEV ; } "
497,"<S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> <S2SV_StartBug> vp9_remove_common ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_free ( pbi -> lf_worker . data1 ) ; <S2SV_EndBug> <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_worker_end ( worker ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_free ( worker -> data1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_free ( worker -> data2 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pbi -> num_tile_workers ) { <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_dealloc ( & pbi -> lf_row_sync , sb_rows ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vpx_get_worker_interface ( ) -> end <S2SV_ModEnd> <S2SV_ModStart> ) ; vpx_free ( pbi -> tile_data <S2SV_ModStart> VPxWorker <S2SV_ModEnd> <S2SV_ModStart> vpx_get_worker_interface ( ) -> end <S2SV_ModEnd> <S2SV_ModStart> } vpx_free ( pbi -> tile_worker_data <S2SV_ModEnd> <S2SV_ModStart> pbi -> tile_worker_info ) ; <S2SV_ModEnd> <S2SV_ModStart> > 0 ) { <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
498,"<S2SV_StartBug> char * fpath = NULL , * cgdir = NULL , * controller ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""rmdir:<S2SV_blank>verifying<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%s:%s<S2SV_blank>(req<S2SV_blank>path<S2SV_blank>%s)\\n"" , <S2SV_EndBug> <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! cgfs_remove ( controller , cgroup ) ) { <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ","<S2SV_ModStart> , * next = NULL <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <S2SV_ModEnd> <S2SV_ModStart> caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> free ( next ) ; "
499,"<S2SV_StartBug> if ( dec -> ihdr -> data . ihdr . numcmpts != JAS_CAST ( uint , <S2SV_EndBug> <S2SV_StartBug> for ( i = 1 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> if ( dec -> bpcc -> data . bpcc . numcmpts != JAS_CAST ( uint , jas_image_numcmpts ( <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dec -> cmap -> data . cmap . ents [ i ] . cmptno >= JAS_CAST ( uint , <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < JAS_CAST ( uint , jas_image_numcmpts ( dec -> image ) ) ; ++ i ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> <S2SV_ModStart> jas_uint <S2SV_ModEnd> 
500,"<S2SV_StartBug> return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , <S2SV_EndBug> ",<S2SV_ModStart> && jas_seq2d_size ( a ) 
501,<S2SV_StartBug> spin_lock_init ( & port -> phy_list_lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> INIT_LIST_HEAD ( & port -> sas_port_del_list ) ; 
502,<S2SV_StartBug> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <S2SV_EndBug> ,<S2SV_ModStart> ! cm_id -> device || 
503,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
504,"<S2SV_StartBug> lua_pushvalue ( L , i ) ; <S2SV_EndBug> ","<S2SV_ModStart> luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ; "
505,<S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> ,<S2SV_ModStart> pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> 
506,<S2SV_StartBug> r = vapic_enter ( vcpu ) ; <S2SV_EndBug> <S2SV_StartBug> vapic_exit ( vcpu ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
507,"<S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , ""LEN=%9u"" , & pkt_len ) ; <S2SV_EndBug> <S2SV_StartBug> * err_info = g_strdup ( ""toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> int pkt_len , <S2SV_ModEnd> <S2SV_ModStart> ""LEN=%9d"" <S2SV_ModEnd> <S2SV_ModStart> ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"" "
508,<S2SV_StartBug> struct llc_pktinfo info ; <S2SV_EndBug> ,"<S2SV_ModStart> ; memset ( & info , 0 , sizeof ( info ) ) "
509,"<S2SV_StartBug> unsigned int len ; <S2SV_EndBug> <S2SV_StartBug> struct au1200fb_device * fbdev = info -> par ; <S2SV_EndBug> <S2SV_StartBug> return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> vm_iomap_memory <S2SV_ModEnd> <S2SV_ModStart> fbdev -> fb_phys , fbdev -> fb_len <S2SV_ModEnd> "
510,"<S2SV_StartBug> rpc_delay ( task , 3 * HZ ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ; 
511,"<S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> ","<S2SV_ModStart> memset ( vec , 1 , nr <S2SV_ModEnd> <S2SV_ModStart> * vec = 0 <S2SV_ModEnd> <S2SV_ModStart> * vec = ! ! <S2SV_ModEnd> <S2SV_ModStart> ; <S2SV_ModEnd> "
512,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> rdp -> nego -> transport -> credssp = NULL ; 
513,"<S2SV_StartBug> exfat_error ( ""exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) <S2SV_EndBug> ","<S2SV_ModStart> ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>small<S2SV_blank>sector<S2SV_blank>size:<S2SV_blank>2^%hhd"" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( ""too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^(%hhd+%hhd)"" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <S2SV_ModStart>  <S2SV_ModEnd> "
514,"<S2SV_StartBug> exo_job_info_message ( EXO_JOB ( job ) , g_file_info_get_display_name ( info ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> ""%s"" , "
515,<S2SV_StartBug> if ( is_file_hugepages ( shm_file ) ) <S2SV_EndBug> ,<S2SV_ModStart> shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if ( 
516,<S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> ,<S2SV_ModStart> ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> 
517,<S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & line , 0 , sizeof ( line ) ) ; "
518,<S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> <S2SV_StartBug> ! ( opt_len == 24 && flags & TH_ACK ) ) <S2SV_EndBug> ,<S2SV_ModStart> ( <S2SV_ModStart> ) <S2SV_ModStart> ( <S2SV_ModStart> ) 
519,<S2SV_StartBug> && ( ( ( packet -> payload [ 0 ] == 0x07 ) && ( packet -> payload [ 1 ] == 0xff ) && ( packet -> payload [ 2 ] == 0x00 ) ) <S2SV_EndBug> ,<S2SV_ModStart> payload_packet_len >= 3 && packet -> 
520,"<S2SV_StartBug> strcpy ( the_url , url_arg ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( the_url , ""MP4Client<S2SV_blank>"" GPAC_FULL_VERSION ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , ""Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n"" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <S2SV_ModStart> } <S2SV_ModStart> { strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <S2SV_ModEnd> <S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> "
521,<S2SV_StartBug> { <S2SV_EndBug> ,"<S2SV_ModStart> if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ; "
522,"<S2SV_StartBug> int res ; <S2SV_EndBug> <S2SV_StartBug> const void * data ; <S2SV_EndBug> <S2SV_StartBug> u_int32_t vendor ; <S2SV_EndBug> <S2SV_StartBug> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & data , & len ) == FAILURE ) { <S2SV_EndBug> <S2SV_StartBug> res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; <S2SV_EndBug> <S2SV_StartBug> add_assoc_long ( return_value , ""attr"" , res ) ; <S2SV_EndBug> <S2SV_StartBug> add_assoc_stringl ( return_value , ""data"" , ( char * ) data , len , 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , * raw <S2SV_ModStart> ; unsigned char type ; size_t data_len <S2SV_ModStart> raw <S2SV_ModEnd> <S2SV_ModStart> if ( <S2SV_ModEnd> <S2SV_ModStart> type , & data , & data_len , raw , len ) <S2SV_ModEnd> <S2SV_ModStart> type <S2SV_ModEnd> <S2SV_ModStart> data_len <S2SV_ModEnd> "
523,"<S2SV_StartBug> sas_unregister_dev ( port , dev ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; sas_destruct_devices ( port 
524,"<S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
525,"<S2SV_StartBug> static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> int mi_col , BLOCK_SIZE bsize , int * rate , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; <S2SV_EndBug> <S2SV_StartBug> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> <S2SV_StartBug> num_8x8_blocks_high_lookup [ bsize ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_16X16 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && <S2SV_EndBug> <S2SV_StartBug> do_split &= bsize > cpi -> sf . min_partition_size ; <S2SV_EndBug> <S2SV_StartBug> save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> sf . disable_split_var_thresh && partition_none_allowed ) { <S2SV_EndBug> <S2SV_StartBug> if ( source_variancey < cpi -> sf . disable_split_var_thresh / 2 ) <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize , <S2SV_EndBug> <S2SV_StartBug> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; <S2SV_EndBug> <S2SV_StartBug> int64_t stop_thresh = 4096 ; <S2SV_EndBug> <S2SV_StartBug> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; <S2SV_EndBug> <S2SV_StartBug> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> * get_sb_index ( x , subsize ) = i ; <S2SV_EndBug> <S2SV_StartBug> rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , <S2SV_EndBug> <S2SV_StartBug> & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( partition_horz_allowed && do_rect ) { <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_VERT ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) { <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> pred_interp_filter = <S2SV_EndBug> <S2SV_StartBug> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , <S2SV_EndBug> <S2SV_StartBug> sum_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> sum_rate += this_rate ; <S2SV_EndBug> <S2SV_StartBug> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { <S2SV_EndBug> <S2SV_StartBug> best_rate ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_rate < INT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( best_dist < INT64_MAX ) ; <S2SV_EndBug> ","<S2SV_ModStart> ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> <S2SV_ModStart> int mi_col , <S2SV_ModEnd> <S2SV_ModStart> RD_COST * rd_cost , int64_t best_rd , PC_TREE * pc_tree <S2SV_ModEnd> <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> td <S2SV_ModEnd> <S2SV_ModStart> & pc_tree -> none <S2SV_ModEnd> <S2SV_ModStart> RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> <S2SV_ModStart> BLOCK_SIZE min_size = x -> min_partition_size ; BLOCK_SIZE max_size = x -> max_partition_size ; # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ; int none_complexity = 0 ; # endif <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) ; vp9_rd_cost_init ( & this_rdc ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize <S2SV_ModStart> && cpi -> oxcf . aq_mode ) <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size <S2SV_ModEnd> <S2SV_ModStart> max_size && bsize >= min_size <S2SV_ModEnd> <S2SV_ModStart> max_size && bsize > min_size <S2SV_ModEnd> <S2SV_ModStart> max_size && bsize > min_size <S2SV_ModEnd> <S2SV_ModStart> min_size <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; MOTION_DIRECTION this_mv ; MOTION_DIRECTION right_mv ; MOTION_DIRECTION bottom_mv ; this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; if ( c != mb_col_end - 1 ) { right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; } if ( r != mb_row_end - 1 ) { bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; } } } if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { partition_none_allowed <S2SV_ModEnd> <S2SV_ModStart> } } # endif <S2SV_ModEnd> <S2SV_ModStart> tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx , best_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> this_rdc . rate , this_rdc . dist ) ; } if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; best_rdc = this_rdc <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> partitioning = PARTITION_NONE ; dist_breakout_thr <S2SV_ModEnd> <S2SV_ModStart> rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && best_rdc . rate < rate_breakout_thr ) ) { do_split = 0 ; do_rect = 0 ; } # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; int skip = 1 ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c <S2SV_ModEnd> <S2SV_ModStart> ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) { skip = 0 ; break ; } } if ( skip == 0 ) { break ; } } if ( skip ) { if ( src_diff_var == UINT_MAX ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } if ( src_diff_var < 8 <S2SV_ModEnd> <S2SV_ModStart> # endif } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { i = 4 ; if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rate == INT_MAX ) sum_rdc . rdcost = INT64_MAX ; } else { <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> split [ i ] -> index = i <S2SV_ModEnd> <S2SV_ModStart> td , tile_data <S2SV_ModEnd> <S2SV_ModStart> this_rdc , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> break ; <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } } if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += cpi <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> <S2SV_ModStart> x <S2SV_ModEnd> <S2SV_ModStart> ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 ) { PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; <S2SV_ModEnd> <S2SV_ModStart> td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { subsize <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> && bsize > BLOCK_8X8 <S2SV_ModStart> td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> <S2SV_ModStart> tile_data , x <S2SV_ModEnd> <S2SV_ModStart> this_rdc , subsize , & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rdcost <S2SV_ModEnd> <S2SV_ModStart> sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> best_rdc . dist <S2SV_ModEnd> <S2SV_ModStart> pc_tree -> index != 3 <S2SV_ModEnd> <S2SV_ModStart> encode_sb ( cpi , td , tile_info , tp <S2SV_ModEnd> <S2SV_ModStart> bsize , pc_tree <S2SV_ModEnd> <S2SV_ModStart> best_rdc . rate <S2SV_ModEnd> <S2SV_ModStart> best_rdc . dist <S2SV_ModEnd> "
526,<S2SV_StartBug> event_data -> snk_config = <S2SV_EndBug> ,<S2SV_ModStart> cpu = cpumask_first ( mask ) ; 
527,<S2SV_StartBug> daddy = malloc ( sizeof ( creator_template ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> safe_calloc <S2SV_ModEnd> 
528,"<S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char fpath [ grub_strlen ( currpath ) + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> * currfound = currnode ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_BAD_FILE_TYPE , ""not<S2SV_blank>a<S2SV_blank>directory"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( grub_errno ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_SYMLINK_LOOP , <S2SV_EndBug> <S2SV_StartBug> free_node ( oldnode , c ) ; <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return grub_error ( GRUB_ERR_FILE_NOT_FOUND , ""file<S2SV_blank>not<S2SV_blank>found"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * fpath = grub_malloc ( <S2SV_ModEnd> <S2SV_ModStart> ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; free ( fpath ) <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> { free ( fpath ) ; <S2SV_ModStart> } <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> ) ; free ( fpath <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> free ( fpath ) ; <S2SV_ModStart> free ( fpath ) ; "
529,<S2SV_StartBug> int error ; <S2SV_EndBug> ,"<S2SV_ModStart> unsigned int inode_size = EXT4_INODE_SIZE ( inode -> i_sb ) ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; int error ; if ( ( EXT4_GOOD_OLD_INODE_SIZE + ei -> i_extra_isize > inode_size ) || ( ei -> i_extra_isize & 3 ) ) { EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>extra_isize<S2SV_blank>%u<S2SV_blank>(inode<S2SV_blank>size<S2SV_blank>%u)"" , ei -> i_extra_isize , EXT4_INODE_SIZE ( inode -> i_sb ) ) ; return - EFSCORRUPTED ; } if ( ( new_extra_isize < ei -> i_extra_isize ) || ( new_extra_isize < 4 ) || ( new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE ) ) return - EINVAL <S2SV_ModEnd> "
530,<S2SV_StartBug> if ( track -> timescale > UINT16_MAX ) { <S2SV_EndBug> ,<S2SV_ModStart> || ! track -> par -> channels 
531,<S2SV_StartBug> const struct oe_sockaddr * dest_add = <S2SV_EndBug> <S2SV_StartBug> ( const struct oe_sockaddr * ) arg5 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( <S2SV_ModEnd> 
532,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> "
533,<S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
534,"<S2SV_StartBug> ext3_msg ( sb , ""error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld"" , <S2SV_EndBug> ","<S2SV_ModStart> KERN_ERR , "
535,<S2SV_StartBug> sr -> bytes_to_send = finfo . size ; <S2SV_EndBug> ,<S2SV_ModStart> fd_is_fdt = MK_FALSE ; sr -> 
536,<S2SV_StartBug> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> 
537,<S2SV_StartBug> { <S2SV_EndBug> ,<S2SV_ModStart> if ( rc -> uwbd . task ) 
538,"<S2SV_StartBug> u64 rem ; <S2SV_EndBug> <S2SV_StartBug> sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> ",<S2SV_ModStart> u32 <S2SV_ModEnd> <S2SV_ModStart> div_u64_rem <S2SV_ModEnd> 
539,"<S2SV_StartBug> int disable_inter_mode_mask , int this_mode , int ref_frame , <S2SV_EndBug> <S2SV_StartBug> frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) { <S2SV_EndBug> <S2SV_StartBug> int rfc = mode_context [ ref_frame ] ; <S2SV_EndBug> <S2SV_StartBug> if ( second_ref_frame == NONE ) { <S2SV_EndBug> <S2SV_StartBug> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) || <S2SV_EndBug> <S2SV_StartBug> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 && <S2SV_EndBug> <S2SV_StartBug> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 && <S2SV_EndBug> ","<S2SV_ModStart> int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) { if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> <S2SV_ModStart> ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> "
540,"<S2SV_StartBug> value = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> oob ) { <S2SV_EndBug> <S2SV_StartBug> nbits = bits & 7 ; <S2SV_EndBug> <S2SV_StartBug> Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ; <S2SV_EndBug> <S2SV_StartBug> value |= ( get << ( i + nbits ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> , msg -> cursize << 3 <S2SV_ModStart> if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } "
541,"<S2SV_StartBug> dictionary * iniparser_load ( const char * ininame ) <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d):\\n"" , <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""-><S2SV_blank>%s\\n"" , line ) ; <S2SV_EndBug> ","<S2SV_ModStart> , load_options options <S2SV_ModStart> if ( options & HIDE_ERRORED_LINE_CONTENT ) { <S2SV_ModStart> ""iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d)\\n"" , ininame , lineno ) ; } else { fprintf ( stderr , <S2SV_ModStart> } "
542,"<S2SV_StartBug> struct strbuf * path , const char * name , <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
543,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ; 
544,"<S2SV_StartBug> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> memset ( up , 0 , sizeof ( * up ) ) ; "
545,"<S2SV_StartBug> fprintf ( fp , ""%s=%s\\n"" , key , value ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( strchr ( value , '\\n' ) ) die ( ""credential<S2SV_blank>value<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>contains<S2SV_blank>newline"" , key ) ; "
546,"<S2SV_StartBug> end = strchr ( * value + 1 , \'""\' ) ; <S2SV_EndBug> <S2SV_StartBug> end ++ ; <S2SV_EndBug> ","<S2SV_ModStart> char * p = end = <S2SV_ModEnd> <S2SV_ModStart> ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \'""\' ) break ; } p ++ ; end ++ ; } if ( * end != \'""\' <S2SV_ModEnd> <S2SV_ModStart> = ++ p <S2SV_ModEnd> "
547,"<S2SV_StartBug> static const char * parse_string ( cJSON * item , const char * str ) <S2SV_EndBug> <S2SV_StartBug> const char * ptr = str + 1 ; <S2SV_EndBug> <S2SV_StartBug> ep = str ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> while ( * ptr != \'\\""\' && * ptr && ++ len ) <S2SV_EndBug> <S2SV_StartBug> if ( * ptr ++ == '\\\\' ) <S2SV_EndBug> <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) ) <S2SV_EndBug> <S2SV_StartBug> while ( * ptr != \'\\""\' && * ptr ) { <S2SV_EndBug> <S2SV_StartBug> sscanf ( ptr + 1 , ""%4x"" , & uc ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += 4 ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> if ( uc >= 0xD800 && uc <= 0xDBFF ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> sscanf ( ptr + 3 , ""%4x"" , & uc2 ) ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> uc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ; <S2SV_EndBug> <S2SV_StartBug> len = 1 ; <S2SV_EndBug> <S2SV_StartBug> ++ ptr ; <S2SV_EndBug> <S2SV_StartBug> ++ ptr ; <S2SV_EndBug> ","<S2SV_ModStart> , <S2SV_ModEnd> <S2SV_ModStart> * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * <S2SV_ModEnd> <S2SV_ModStart> * <S2SV_ModStart> return 0 ; <S2SV_ModEnd> <S2SV_ModStart> end_ptr <S2SV_ModEnd> <S2SV_ModStart> end_ptr <S2SV_ModEnd> <S2SV_ModStart> if ( * end_ptr <S2SV_ModEnd> <S2SV_ModStart> end_ptr ++ ; out = ( char * ) cJSON_malloc ( len + 1 ) <S2SV_ModEnd> <S2SV_ModStart> out ) return 0 ; item -> valuestring <S2SV_ModEnd> <S2SV_ModStart> item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) <S2SV_ModEnd> <S2SV_ModStart> uc = parse_hex4 ( ptr + 1 ) ; <S2SV_ModEnd> <S2SV_ModStart> if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } <S2SV_ModStart> { * ep = str ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> { * ep = str ; return 0 ; } uc2 = parse_hex4 <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> { * ep = str ; return 0 ; } <S2SV_ModEnd> <S2SV_ModStart> + ( <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> len = 1 ; <S2SV_ModEnd> <S2SV_ModStart> ptr ++ <S2SV_ModEnd> <S2SV_ModStart> ptr ++ <S2SV_ModEnd> "
548,"<S2SV_StartBug> bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX ) <S2SV_EndBug> <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
549,<S2SV_StartBug> u8 opcode = BPF_OP ( insn -> code ) ; <S2SV_EndBug> <S2SV_StartBug> if ( known && ( ptr_reg -> off + smin_val == <S2SV_EndBug> <S2SV_StartBug> if ( dst_reg == off_reg ) { <S2SV_EndBug> ,"<S2SV_ModStart> ; int ret <S2SV_ModStart> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } <S2SV_ModStart> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } "
550,"<S2SV_StartBug> psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; <S2SV_EndBug> ",<S2SV_ModStart> g -> gcstate = GCSswpallgc ; 
551,<S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> ,<S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> long <S2SV_ModEnd> <S2SV_ModStart> 1UL <S2SV_ModEnd> 
552,"<S2SV_StartBug> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ; <S2SV_ModStart> memcpy_short_addr <S2SV_ModEnd> <S2SV_ModStart> memcpy_short_addr <S2SV_ModEnd> <S2SV_ModStart> memcpy_short_addr <S2SV_ModEnd> <S2SV_ModStart> return ; } else { assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy ( dst , src , src_ybc -> y_width ) ; src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ; "
553,<S2SV_StartBug> s -> chunksize = - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> UINT64_MAX <S2SV_ModEnd> 
554,"<S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( void ) ctx ; ( void ) args ; 
555,<S2SV_StartBug> while ( lp -> s != NULL ) { <S2SV_EndBug> <S2SV_StartBug> l2info -> bundle = l2info -> cookie [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> l2info -> bundle = l2info -> cookie [ 1 ] ; <S2SV_EndBug> ,"<S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> ND_TCHECK2 ( p [ 0 ] , 2 ) ; <S2SV_ModStart> ND_TCHECK2 ( p [ 0 ] , 2 ) ; "
556,<S2SV_StartBug> if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
557,"<S2SV_StartBug> case 'l' : RBININFO ( ""libs"" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ; break ; <S2SV_EndBug> <S2SV_StartBug> case 'i' : RBININFO ( ""imports"" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ; break ; <S2SV_EndBug> ",<S2SV_ModStart> { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> } <S2SV_ModStart> { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> } 
558,"<S2SV_StartBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const BLOCK_SIZE bsize = mbmi -> sb_type ; <S2SV_EndBug> <S2SV_StartBug> predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <S2SV_EndBug> <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> <S2SV_StartBug> if ( seg -> temporal_update ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ; <S2SV_EndBug> <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> int predicted_segment_id , segment_id ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ? dec_get_segment_id ( cm , cm -> last_frame_seg_map , mi_offset , x_mis , y_mis ) : 0 <S2SV_ModEnd> <S2SV_ModStart> { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> } <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_read <S2SV_ModEnd> <S2SV_ModStart> mi_offset , x_mis , y_mis <S2SV_ModEnd> "
559,"<S2SV_StartBug> int i , len ; <S2SV_EndBug> <S2SV_StartBug> const char __user * p ; <S2SV_EndBug> <S2SV_StartBug> audit_log_format ( * ab , ""argc=%d"" , context -> execve . argc ) ; <S2SV_EndBug> <S2SV_StartBug> buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! buf ) { <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < context -> execve . argc ; i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> long len_max ; long len_rem ; long len_full ; long len_buf ; long len_abuf ; long len_tmp ; bool require_data ; bool encode ; unsigned int iter ; unsigned int arg ; char * buf_head ; char * buf <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> char abuf [ 96 ] ; WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; len_max = MAX_EXECVE_AUDIT_LEN ; buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; if ( ! buf_head ) { audit_panic ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string"" ) ; return ; } buf = buf_head ; <S2SV_ModStart> len_rem = len_max ; len_buf = 0 ; len_full = 0 ; require_data = true ; encode = false ; iter = 0 ; arg = 0 ; do { if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; if ( require_data ) { if ( buf != buf_head ) { memmove ( buf_head , buf , len_buf ) ; buf = buf_head ; } len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ; if ( len_tmp == - EFAULT ) { send_sig ( SIGKILL , current , 0 ) ; goto out ; } else if ( len_tmp == ( len_max - len_buf ) ) { require_data = true ; encode = true ; len_full = len_full * 2 ; p += len_tmp ; } else { require_data = false ; if ( ! encode ) encode = audit_string_contains_control ( buf , len_tmp ) ; if ( len_full < len_max ) len_full = ( encode ? len_tmp * 2 : len_tmp ) ; p += len_tmp + 1 ; } len_buf += len_tmp ; buf_head [ len_buf ] = '\\0' ; len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; } if ( len_buf > 0 ) { if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { len_rem = len_max ; audit_log_end ( * ab ) ; * ab = audit_log_start ( context , GFP_KERNEL , AUDIT_EXECVE <S2SV_ModEnd> <S2SV_ModStart> * ab ) goto out ; } len_tmp = 0 ; if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { if ( iter == 0 ) { len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d_len=%lu"" , arg , len_full ) ; } len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d[%d]="" , arg , iter ++ ) ; } else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , ""<S2SV_blank>a%d="" , arg ) ; WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; abuf [ sizeof ( abuf ) - 1 ] = '\\0' ; audit_log_format ( * ab , ""%s"" , abuf ) ; len_rem -= len_tmp ; len_tmp = len_buf ; if ( encode ) { if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ; audit_log_n_hex ( * ab , buf , len_tmp ) ; len_rem -= len_tmp * 2 ; len_abuf -= len_tmp * 2 ; } else { if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ; audit_log_n_string ( * ab , buf , len_tmp ) ; len_rem -= len_tmp + 2 ; len_abuf -= len_tmp ; } len_buf -= len_tmp ; buf += len_tmp ; } if ( ( len_buf == 0 ) && ! require_data ) { arg ++ ; iter = 0 ; len_full = 0 ; require_data = true ; encode = false ; } } while ( arg <S2SV_ModEnd> <S2SV_ModStart> ) ; out : kfree ( buf_head <S2SV_ModEnd> "
560,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
561,"<S2SV_StartBug> if ( JAS_CAST ( ulong , jas_stream_tell ( tmpstream ) ) != ms -> len ) { <S2SV_EndBug> ",<S2SV_ModStart> jas_ulong <S2SV_ModEnd> 
562,<S2SV_StartBug> int i ; <S2SV_EndBug> ,"<S2SV_ModStart> ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user ) "
563,"<S2SV_StartBug> dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
564,"<S2SV_StartBug> double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags ) <S2SV_EndBug> <S2SV_StartBug> double rate = 0.0 ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> indexcount > 3 ) <S2SV_EndBug> <S2SV_StartBug> testend -- ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> uint32_t * payload = GetPayload ( handle , NULL , teststart ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t payloadsize = GetPayloadSize ( handle , teststart ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret != GPMF_OK ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> payload = GetPayload ( handle , payload , teststart ) ; <S2SV_EndBug> <S2SV_StartBug> payloadsize = GetPayloadSize ( handle , teststart ) ; <S2SV_EndBug> <S2SV_StartBug> ret = GPMF_Init ( ms , payload , payloadsize ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t samples = GPMF_Repeat ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) && GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) <S2SV_EndBug> <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> uint32_t * repeatarray = malloc ( mp4 -> indexcount * 4 + 4 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( payloadpos = teststart ; payloadpos < testend ; payloadcount ++ , payloadpos ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) <S2SV_EndBug> <S2SV_StartBug> float in , out ; <S2SV_EndBug> <S2SV_StartBug> GetPayloadTime ( handle , payloadpos , & in , & out ) ; <S2SV_EndBug> <S2SV_StartBug> uint32_t repeat = GPMF_Repeat ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> float in , out ; <S2SV_EndBug> <S2SV_StartBug> GetPayloadTime ( handle , payloadpos , & in , & out ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] - meanY ) ; <S2SV_EndBug> <S2SV_StartBug> bot += ( ( double ) out - meanX ) * ( ( double ) out - meanX ) ; <S2SV_EndBug> <S2SV_StartBug> # if 0 <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> printf ( ""%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)\\n"" , PRINTF_4CC ( fourcc ) , intercept , 1000.0 * intercept / slope ) ; <S2SV_EndBug> <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> , double * firstsampletime , double * lastsampletime <S2SV_ModStart> ; uint32_t * payload ; uint32_t payloadsize ; int32_t ret <S2SV_ModStart> payload = GetPayload ( handle , NULL , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; { uint64_t minimumtimestamp = 0 ; uint64_t starttimestamp = 0 ; uint64_t endtimestamp = 0 ; uint32_t startsamples = 0 ; uint32_t endsamples = 0 ; double intercept = 0.0 ; while ( teststart < <S2SV_ModEnd> <S2SV_ModStart> && ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) <S2SV_ModEnd> <S2SV_ModStart> payload = GetPayload ( handle , payload , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } if ( ret == GPMF_OK && payload ) { uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) startsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) - samples ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) starttimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & find_stream ) ) ; if ( starttimestamp ) { GPMF_stream any_stream ; GPMF_Init ( & any_stream , payload , payloadsize ) ; minimumtimestamp = starttimestamp ; while ( GPMF_OK == GPMF_FindNext ( & any_stream , GPMF_KEY_TIME_STAMP , GPMF_RECURSE_LEVELS ) ) { uint64_t timestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & any_stream ) ) ; if ( timestamp < minimumtimestamp ) minimumtimestamp = timestamp ; } } testend = mp4 -> indexcount ; do { <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> payload , testend ) ; <S2SV_ModEnd> <S2SV_ModStart> testend ) ; <S2SV_ModEnd> <S2SV_ModStart> } while ( testend > 0 <S2SV_ModEnd> <S2SV_ModStart> ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ; else { uint32_t i ; for ( i = teststart ; i <= testend ; i ++ ) { <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i ) ; if ( GPMF_OK == <S2SV_ModEnd> <S2SV_ModStart> ) if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) endsamples += GPMF_PayloadSampleCount ( ms ) ; } } if ( starttimestamp != 0 <S2SV_ModEnd> <S2SV_ModStart> last_samples = GPMF_PayloadSampleCount ( ms ) ; uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples ; double time_stamp_scale = 1000000000.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) endtimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData <S2SV_ModEnd> <S2SV_ModStart> ) ) ; if ( endtimestamp ) { double approxrate = 0.0 ; if ( endsamples > startsamples ) approxrate <S2SV_ModEnd> <S2SV_ModStart> if ( approxrate == 0.0 ) approxrate <S2SV_ModEnd> <S2SV_ModStart> while ( time_stamp_scale >= 1 ) { rate = ( double ) ( totaltimestamped_samples ) / ( ( double ) ( endtimestamp - starttimestamp ) / time_stamp_scale ) ; if ( rate * 0.9 < approxrate && approxrate < rate * 1.1 ) break ; time_stamp_scale *= 0.1 ; } if ( time_stamp_scale < 1.0 ) rate = 0.0 ; intercept = ( ( ( double ) minimumtimestamp - ( double ) starttimestamp ) / time_stamp_scale ) * rate ; } } if ( rate == 0.0 ) { if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) ) { if ( endsamples > startsamples ) rate = ( double ) ( endsamples - startsamples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) <S2SV_ModEnd> <S2SV_ModStart> ) ; if ( rate == 0.0 ) rate = ( double ) ( samples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ; double in , out ; if ( GPMF_OK == GetPayloadTime ( handle , teststart , & in , & out ) ) intercept = ( double ) - in * rate ; } else { uint32_t payloadpos = 0 , payloadcount = 0 ; double slope , top = 0.0 , bot = 0.0 , meanX = 0 , meanY = 0 ; uint32_t * repeatarray = malloc ( mp4 -> indexcount <S2SV_ModStart> <= testend ; payloadpos ++ ) { payload = GetPayload ( handle , payload , payloadpos ) ; payloadsize = GetPayloadSize ( handle , payloadpos ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) { GPMF_stream find_stream2 ; GPMF_CopyState ( ms , & find_stream2 ) ; payloadcount ++ <S2SV_ModEnd> <S2SV_ModStart> & find_stream2 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> if ( GPMF_OK == <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> GPMF_PayloadSampleCount <S2SV_ModEnd> <S2SV_ModStart> double <S2SV_ModEnd> <S2SV_ModStart> if ( GPMF_OK == <S2SV_ModStart> ) <S2SV_ModEnd> <S2SV_ModStart> else { <S2SV_ModEnd> <S2SV_ModStart> = 0 ; } } if ( repeatarray ) { meanY /= ( double ) payloadcount ; meanX /= ( double ) payloadcount ; for ( payloadpos = teststart ; payloadpos <= testend ; payloadpos ++ ) { double in , out ; if ( repeatarray [ payloadpos ] && GPMF_OK == GetPayloadTime ( handle , payloadpos , & in , & out ) ) { top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] <S2SV_ModStart> } <S2SV_ModStart> rate = slope ; intercept = meanY - slope * meanX ; <S2SV_ModStart> printf ( ""%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f\\n"" <S2SV_ModEnd> <S2SV_ModStart> , rate ) ; printf ( ""%c%c%c%c<S2SV_blank>first<S2SV_blank>sample<S2SV_blank>at<S2SV_blank>time<S2SV_blank>%.3fms\\n"" , PRINTF_4CC ( fourcc ) , - 1000.0 * intercept / slope ) ; # endif <S2SV_ModEnd> <S2SV_ModStart> } } if ( firstsampletime && lastsampletime ) { uint32_t endpayload = mp4 -> indexcount ; do { endpayload -- ; payload = GetPayload ( handle , payload , endpayload ) ; payloadsize = GetPayloadSize ( handle , endpayload ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } while ( endpayload > 0 && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ; if ( endpayload > 0 && ret == GPMF_OK ) { uint32_t totalsamples = endsamples - startsamples ; float timo = 0.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_OFFSET , GPMF_CURRENT_LEVEL ) ) GPMF_FormattedData ( & find_stream , & timo , 4 , 0 , 1 ) ; double first , last ; first = - intercept / rate - timo ; last = first + ( double ) totalsamples / rate ; if ( firstsampletime ) * firstsampletime = first ; if ( lastsampletime ) * lastsampletime = last ; } <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
565,<S2SV_StartBug> r1 . event = event ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & r1 , 0 , sizeof ( r1 ) ) ; "
566,<S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <S2SV_EndBug> ,<S2SV_ModStart> limit || ( unsigned char * ) e + e -> next_offset > 
567,"<S2SV_StartBug> int old_bin_num , bin_num ; <S2SV_EndBug> <S2SV_StartBug> bin_num = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ; <S2SV_EndBug> <S2SV_StartBug> return ptr ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> } 
568,<S2SV_StartBug> int hstartcol ; <S2SV_EndBug> <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> ,<S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> <S2SV_ModStart> hstartrow <S2SV_ModEnd> 
569,"<S2SV_StartBug> unsigned long cs ; <S2SV_EndBug> <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return rc ; <S2SV_EndBug> <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ; <S2SV_EndBug> ","<S2SV_ModStart> eip , cs ; u16 old_cs <S2SV_ModEnd> <S2SV_ModStart> struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <S2SV_ModStart> eip <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> "
570,<S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; 
571,"<S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> <S2SV_StartBug> exit_func : <S2SV_EndBug> ",<S2SV_ModStart> = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> <S2SV_ModStart> exit_func : <S2SV_ModStart>  <S2SV_ModEnd> 
572,<S2SV_StartBug> psf_close_rsrc ( psf ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; free ( psf -> header . ptr 
573,<S2SV_StartBug> int is_valid ; <S2SV_EndBug> <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> = ( error == GIT_OK ) <S2SV_ModStart>  <S2SV_ModEnd> 
574,"<S2SV_StartBug> hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , 0 ) ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chunk_end [ i ] = 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( * hmp_chunk [ i ] < 0x80 ) { <S2SV_EndBug> <S2SV_StartBug> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( * hmp_chunk [ i ] < 0x80 ) ; <S2SV_EndBug> <S2SV_StartBug> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; <S2SV_EndBug> <S2SV_StartBug> hmp_chunk [ i ] ++ ; <S2SV_EndBug> ","<S2SV_ModStart> [ i ] ; chunk_length [ i ] -= chunk_ofs <S2SV_ModStart> chunk_length [ i ] -= 3 ; <S2SV_ModStart> [ i ] , chunk_length <S2SV_ModStart> ; chunk_length [ i ] -= 3 <S2SV_ModStart> chunk_length [ i ] -= setup_ret ; <S2SV_ModStart> chunk_length [ i ] && <S2SV_ModStart> if ( ! chunk_length [ i ] ) break ; <S2SV_ModStart> chunk_length [ i ] -- ; <S2SV_ModStart> if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , ""file<S2SV_blank>too<S2SV_blank>short"" , 0 ) ; goto _hmp_end ; } <S2SV_ModStart> ; chunk_length [ i ] -- "
575,"<S2SV_StartBug> c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> macinf -> lchid [ j + chan ] = c_t + 1 ; <S2SV_EndBug> <S2SV_StartBug> macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ; <S2SV_EndBug> ",<S2SV_ModStart> ( <S2SV_ModStart> + 1 ) % 0xf <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
576,"<S2SV_StartBug> struct sctp_sockaddr_entry * laddr ; <S2SV_EndBug> <S2SV_StartBug> __u8 matchlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> ","<S2SV_ModStart> ipv6_pinfo * np = inet6_sk ( sk ) ; struct <S2SV_ModStart> struct in6_addr * final_p , final ; <S2SV_ModStart> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> final_p <S2SV_ModEnd> <S2SV_ModStart> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> final_p <S2SV_ModEnd> "
577,"<S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> ",<S2SV_ModStart> return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> 
578,<S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = safe_calloc ( <S2SV_ModEnd> <S2SV_ModStart> long 
579,<S2SV_StartBug> number_planes_filled * sizeof ( * pixels ) ) ; <S2SV_EndBug> <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * number_planes_filled ; <S2SV_EndBug> ,"<S2SV_ModStart> MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> <S2SV_ModStart> MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> "
580,<S2SV_StartBug> if ( len < 20 ) <S2SV_EndBug> ,"<S2SV_ModStart> 32 ) ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]"" <S2SV_ModEnd> "
581,<S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> data -> multi_easy = NULL ; } 
582,"
","
"
583,"<S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> ",<S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) 
584,<S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> ,<S2SV_ModStart> kfree ( clk_src ) ; 
585,"<S2SV_StartBug> vpx_memset ( upred_ptr , expected_udc , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( vpred_ptr , expected_vdc , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( upred_ptr , uabove_row , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ; <S2SV_EndBug> ",<S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> 
586,<S2SV_StartBug> if ( ctxt -> rip_relative ) <S2SV_EndBug> ,<S2SV_ModStart> && likely ( ctxt -> memopp ) 
587,"<S2SV_StartBug> security_decrypt ( s -> p , length , rdp ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE 
588,"<S2SV_StartBug> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( ! data_interface || ! control_interface ) return - ENODEV 
589,"<S2SV_StartBug> o = 2 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < nelements ; j ++ , i ++ ) { <S2SV_EndBug> ","<S2SV_ModStart> if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } <S2SV_ModStart> && i < sh . sh_properties ; <S2SV_ModEnd> "
590,"<S2SV_StartBug> static int <S2SV_EndBug> <S2SV_StartBug> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <S2SV_EndBug> <S2SV_StartBug> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_EndBug> <S2SV_StartBug> pdu_type , pdu_len ) ) ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_END_OF_DATA_PDU : <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case RPKI_RTR_CACHE_RESPONSE_PDU : <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_ipv6_prefix * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> pdu = ( const rpki_rtr_pdu_error_report * ) tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , encapsulated_pdu_length ) ; <S2SV_EndBug> <S2SV_StartBug> tptr += sizeof ( * pdu ) ; <S2SV_EndBug> <S2SV_StartBug> if ( encapsulated_pdu_length && <S2SV_EndBug> <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , indent + 2 ) ) <S2SV_EndBug> <S2SV_StartBug> tlen -= encapsulated_pdu_length ; <S2SV_EndBug> <S2SV_StartBug> text_length = 0 ; <S2SV_EndBug> <S2SV_StartBug> text_length = EXTRACT_32BITS ( tptr ) ; <S2SV_EndBug> <S2SV_StartBug> tlen -= 4 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( * tptr , text_length ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ","<S2SV_ModStart> u_int <S2SV_ModEnd> <S2SV_ModStart> const u_int len , const u_char recurse , const <S2SV_ModStart> ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u<S2SV_blank>(unknown)"" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , ""(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)"" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> tlen += 4 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> ; } tlen <S2SV_ModEnd> <S2SV_ModStart> } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + tlen ) ; tlen <S2SV_ModEnd> <S2SV_ModStart> if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , ""%sError<S2SV_blank>text:<S2SV_blank>"" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> <S2SV_ModStart> pdu_len ) ; <S2SV_ModEnd> <S2SV_ModStart> pdu_len ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> <S2SV_ModStart> ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; return len <S2SV_ModEnd> "
591,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> x % ( 1 << rpx ) ) ) && <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> y % ( 1 << rpy ) ) ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
592,"<S2SV_StartBug> if ( pack -> hdr . ver == 2 ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> log_ppp_debug ( ""<S2SV_blank>Ns=%u<S2SV_blank>Nr=%u"" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> switch ( pack -> hdr . flags & L2TP_VER_MASK ) { case 2 : <S2SV_ModEnd> <S2SV_ModStart> break ; case 3 : <S2SV_ModEnd> <S2SV_ModStart> ; break ; default : print ( ""[L2TP<S2SV_blank>unknown<S2SV_blank>version]\\n"" ) ; return "
593,"<S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> ",<S2SV_ModStart> bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> <S2SV_ModStart> ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> 
594,"<S2SV_StartBug> puts ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>"" <S2SV_EndBug> ","<S2SV_ModStart> ""Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>2015,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>"" <S2SV_ModEnd> "
595,"<S2SV_StartBug> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( r , s ) ; <S2SV_EndBug> ","<S2SV_ModStart> size_t len = strlen ( s ) + 1 ; <S2SV_ModStart> len ) ; memcpy <S2SV_ModEnd> <S2SV_ModStart> , len "
596,<S2SV_StartBug> if ( size_left && size_left < 4 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
597,"<S2SV_StartBug> OPJ_UINT32 * p_data_written , <S2SV_EndBug> <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOT , <S2SV_EndBug> ","<S2SV_ModStart> p_total_data_size , OPJ_UINT32 <S2SV_ModStart> if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } "
598,"<S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> int i ; <S2SV_ModStart> for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> i <S2SV_ModEnd> <S2SV_ModStart> i <S2SV_ModEnd> 
599,"<S2SV_StartBug> if ( utimes ( vect [ 0 ] , tv ) == - 1 ) <S2SV_EndBug> ",<S2SV_ModStart> ( void ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
600,"<S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug> ",<S2SV_ModStart> m -> msg_namelen = 0 ; 
601,"<S2SV_StartBug> inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; <S2SV_EndBug> ","<S2SV_ModStart> s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_free ; } "
602,<S2SV_StartBug> } else if ( options . compression == COMP_DELAYED ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
603,"<S2SV_StartBug> struct flowi4 fl4 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! IS_ERR ( rt ) ) <S2SV_EndBug> <S2SV_StartBug> __sk_dst_set ( sk , & rt -> dst ) ; <S2SV_EndBug> ","<S2SV_ModStart> dst_entry * dst ; struct <S2SV_ModStart> rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <S2SV_ModStart> dst || ! dst -> obsolete || dst -> ops -> check ( dst <S2SV_ModEnd> <S2SV_ModStart> { rcu_read_unlock ( ) ; return ; } <S2SV_ModEnd> <S2SV_ModStart> dst = <S2SV_ModEnd> <S2SV_ModStart> ? <S2SV_ModEnd> <S2SV_ModStart> dst : NULL ; sk_dst_set ( sk , "
604,"<S2SV_StartBug> num = port >= 0 ? port : 0 ; <S2SV_EndBug> <S2SV_StartBug> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & client -> ports_mutex ) ; <S2SV_EndBug> ","<S2SV_ModStart> snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> sprintf ( new_port -> name , ""port-%d"" , num ) ; <S2SV_ModStart>  <S2SV_ModEnd> "
605,"<S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> <S2SV_ModStart> buf <S2SV_ModEnd> <S2SV_ModStart> if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ; "
606,"<S2SV_StartBug> if ( sscanf ( l_line , ""%u<S2SV_blank>%u<S2SV_blank>%u"" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> <S2SV_StartBug> l_row -- ; <S2SV_EndBug> ",<S2SV_ModStart> 3 == <S2SV_ModStart> && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> <S2SV_ModStart> LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ; 
607,"<S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sk_inet -> is_icsk ) { <S2SV_EndBug> <S2SV_StartBug> if ( sk_inet -> opt ) <S2SV_EndBug> <S2SV_StartBug> sk_conn -> icsk_ext_hdr_len -= sk_inet -> opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> sk_conn -> icsk_ext_hdr_len += opt -> optlen ; <S2SV_EndBug> <S2SV_StartBug> opt = xchg ( & sk_inet -> opt , opt ) ; <S2SV_EndBug> ","<S2SV_ModStart> ip_options_rcu * old , <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> opt . <S2SV_ModStart> old = rcu_dereference_protected ( sk_inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> old <S2SV_ModEnd> <S2SV_ModStart> old -> opt . <S2SV_ModEnd> <S2SV_ModStart> opt . <S2SV_ModStart> rcu_assign_pointer ( sk_inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <S2SV_ModEnd> "
608,"<S2SV_StartBug> int zero_bits = * in & 0x07 ; <S2SV_EndBug> <S2SV_StartBug> size_t octets_left = inlen - 1 ; <S2SV_EndBug> <S2SV_StartBug> int i , count = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <S2SV_ModEnd> "
609,"<S2SV_StartBug> & len , & iovec , compat ) ; <S2SV_EndBug> <S2SV_StartBug> len , iovec ) ; <S2SV_EndBug> <S2SV_StartBug> iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ; <S2SV_EndBug> ","<S2SV_ModStart> , & iter <S2SV_ModStart> , & iter <S2SV_ModStart> ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <S2SV_ModEnd> "
610,"<S2SV_StartBug> unsigned char signature [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> unsigned int siglen = sizeof signature ; <S2SV_EndBug> <S2SV_StartBug> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <S2SV_EndBug> <S2SV_StartBug> err : <S2SV_EndBug> ",<S2SV_ModStart> * signature = NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <S2SV_ModStart> free ( signature ) ; 
611,<S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; } 
612,"<S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , lf -> filter_level , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , changed ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta < 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , changed ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta < 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> vpx_write_bit_buffer <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_literal <S2SV_ModEnd> <S2SV_ModStart> vpx_wb_write_bit <S2SV_ModEnd> 
613,"<S2SV_StartBug> char * header , * c ; <S2SV_EndBug> <S2SV_StartBug> header = get_header ( fp ) ; <S2SV_EndBug> <S2SV_StartBug> ( c + strlen ( ""%PDF-M.m"" ) + 2 ) ) <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; const char * c <S2SV_ModStart> ( c + 6 ) [ 0 ] == '.' ) && isdigit ( ( c + 5 ) [ 0 ] ) && isdigit ( ( c + 7 ) [ 0 ] <S2SV_ModEnd> 
614,"<S2SV_StartBug> struct in6_addr * saddr = NULL , * final_p , final ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <S2SV_EndBug> <S2SV_StartBug> np -> opt -> opt_nflen ) ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ipv6_txoptions * opt <S2SV_ModStart> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> opt <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
615,"<S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> 
616,"<S2SV_StartBug> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <S2SV_EndBug> ","<S2SV_ModStart> pszFileName , <S2SV_ModStart>  <S2SV_ModEnd> "
617,"<S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ",<S2SV_ModStart> ssplit <S2SV_ModEnd> 
618,"<S2SV_StartBug> u_char * b , * s , * t , c ; <S2SV_EndBug> <S2SV_StartBug> b = ( uint8_t * ) malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) { <S2SV_EndBug> <S2SV_StartBug> if ( i > 1 ) { <S2SV_EndBug> <S2SV_StartBug> c = * s ++ ^ 0x20 ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ; const u_char * s <S2SV_ModStart> u_char <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && ND_TTEST ( * s ) <S2SV_ModStart> <= 1 || ! ND_TTEST ( * s ) ) break ; <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
619,<S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug> ,<S2SV_ModStart> ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> 
620,<S2SV_StartBug> mutex_lock ( & src_ctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & src_ctx -> mutex ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,"<S2SV_ModStart> mutex_lock_double ( & src_ctx -> mutex , & dst_ctx <S2SV_ModEnd> <S2SV_ModStart> synchronize_rcu ( <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock ( & src_ctx -> mutex ) ; "
621,<S2SV_StartBug> atomic_inc ( & prog -> aux -> refcnt ) ; <S2SV_EndBug> ,<S2SV_ModStart> prog = bpf_prog_inc ( prog <S2SV_ModEnd> 
622,"<S2SV_StartBug> static INLINE void write_buffer_8x8 ( int16_t * output , __m128i * res , int stride ) { <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 0 * stride ) , res [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 1 * stride ) , res [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 2 * stride ) , res [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 3 * stride ) , res [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 4 * stride ) , res [ 4 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 5 * stride ) , res [ 5 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 6 * stride ) , res [ 6 ] ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 7 * stride ) , res [ 7 ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t <S2SV_ModEnd> <S2SV_ModStart> store_output ( & res [ 0 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 1 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 2 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 3 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 4 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 5 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 6 ] , <S2SV_ModEnd> <S2SV_ModStart> ) ; store_output ( & res [ 7 ] , <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
623,<S2SV_StartBug> same_page : <S2SV_EndBug> ,<S2SV_ModStart> if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } } 
624,<S2SV_StartBug> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
625,<S2SV_StartBug> uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ; <S2SV_EndBug> <S2SV_StartBug> assert ( send_buf != NULL ) ; <S2SV_EndBug> ,<S2SV_ModStart> ; if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) { return - 1 ; } pkg_size <S2SV_ModStart> if ( send_buf == NULL ) { return - 1 ; } <S2SV_ModEnd> 
626,"<S2SV_StartBug> update_read_synchronize ( update , s ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( ! <S2SV_ModStart> ) goto fail 
627,<S2SV_StartBug> * p == SSL3_MT_CLIENT_HELLO ) && <S2SV_EndBug> ,<S2SV_ModStart> s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> 
628,"<S2SV_StartBug> ND_TCHECK ( pptr [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> plen -= 32 ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <S2SV_EndBug> ","<S2SV_ModStart> char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> 5 <S2SV_ModEnd> <S2SV_ModStart> asbuf <S2SV_ModEnd> "
629,"<S2SV_StartBug> static void consume_one_event ( unsigned cpu , <S2SV_EndBug> <S2SV_StartBug> unsigned priority , unsigned long * ready , <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( drop ) ) <S2SV_EndBug> <S2SV_StartBug> handle_irq_for_port ( port ) ; <S2SV_EndBug> ","<S2SV_ModStart> , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ctrl <S2SV_ModEnd> <S2SV_ModStart> , ctrl "
630,<S2SV_StartBug> cstate = 0 ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || <S2SV_EndBug> ,"<S2SV_ModStart> siz -> comps = 0 ; <S2SV_ModStart> goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( ""reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( ""tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n"" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( ""number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( ""XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( ""YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( ""XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( ""YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n"" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( ""invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n"" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
631,<S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( ""+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n"" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> "
632,<S2SV_StartBug> last_id = ntohs ( * pid ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( plen < 0 ) return 0 ; 
633,"<S2SV_StartBug> ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Sending<S2SV_blank>request<S2SV_blank>to<S2SV_blank>chained<S2SV_blank>program:<S2SV_blank>%s\\n"" , squidguard ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( sgfpw , ""%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , httpinf . url , clientip , username , httpinf . method ) ; <S2SV_EndBug> <S2SV_StartBug> fflush ( sgfpw ) ; <S2SV_EndBug> ","<S2SV_ModStart> char * rbuff = NULL ; <S2SV_ModStart> rbuff = replace ( httpinf . url , ""%"" , ""%25"" ) ; <S2SV_ModStart> rbuff <S2SV_ModEnd> <S2SV_ModStart> ) ; xfree ( rbuff "
634,<S2SV_StartBug> if ( ! values [ k ] . name ) <S2SV_EndBug> ,<S2SV_ModStart> { continue ; } <S2SV_ModEnd> 
635,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
636,"<S2SV_StartBug> encT ) ; <S2SV_EndBug> <S2SV_StartBug> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <S2SV_EndBug> ",<S2SV_ModStart> enc_tables . T <S2SV_ModEnd> <S2SV_ModStart> enc_tables . T <S2SV_ModEnd> 
637,<S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> } <S2SV_ModStart> if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> } 
638,<S2SV_StartBug> if ( s -> width != avctx -> width && s -> height != avctx -> height ) { <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> 
639,<S2SV_StartBug> if ( length == 1 && bp [ 0 ] == 0xff ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> ND_TCHECK ( bp [ 3 ] ) ; 
640,"<S2SV_StartBug> if ( sizeof ( content_type ) - 1 == klen && 0 == strncasecmp ( key , content_type , sizeof ( content_type ) - 1 ) ) { <S2SV_EndBug> <S2SV_StartBug> rb_hash_aset ( hh , content_type_val , rb_str_new ( val , vlen ) ) ; <S2SV_EndBug> <S2SV_StartBug> rb_hash_aset ( hh , content_length_val , rb_str_new ( val , vlen ) ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( hkey , ""HTTP_"" ) ; <S2SV_EndBug> <S2SV_StartBug> rb_hash_aset ( hh , rb_str_new ( hkey , klen + 5 ) , sval ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> VALUE v ; <S2SV_ModStart> if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_type_val , Qnil ) ) ) { <S2SV_ModStart> } else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , rb_str_new ( val , vlen ) ) ; rb_hash_aset ( hh , content_type_val , a ) ; } <S2SV_ModStart> if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_length_val , Qnil ) ) ) { <S2SV_ModStart> } else { rb_raise ( rb_eArgError , ""Multiple<S2SV_blank>Content-Length<S2SV_blank>headers."" ) ; } <S2SV_ModStart> volatile VALUE kval ; <S2SV_ModStart> kval = <S2SV_ModEnd> <S2SV_ModStart> ; if ( Qnil == ( v = rb_hash_lookup2 ( hh , kval , Qnil ) ) ) { rb_hash_aset ( hh , kval <S2SV_ModStart> else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , sval ) ; rb_hash_aset ( hh , kval , a ) ; } } "
641,"<S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> ","<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ; "
642,"<S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , ""archive_write_data"" ) ; <S2SV_EndBug> ",<S2SV_ModStart> const size_t max_write = INT_MAX ; <S2SV_ModStart> ; if ( s > max_write ) s = max_write 
643,<S2SV_StartBug> if ( 0 == ps_dec -> u4_frm_buf_stride ) <S2SV_EndBug> <S2SV_StartBug> else if ( ( u2_width > ps_dec -> u2_create_max_width ) <S2SV_EndBug> <S2SV_StartBug> || ( u2_height > ps_dec -> u2_create_max_height ) ) <S2SV_EndBug> <S2SV_StartBug> return e_error ; <S2SV_EndBug> ,<S2SV_ModStart> } else { <S2SV_ModStart> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_horizontal_size < MIN_WIDTH <S2SV_ModEnd> <S2SV_ModStart> ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS <S2SV_ModEnd> <S2SV_ModStart> ; } if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS 
644,<S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> x % ( 1 << rpx ) ) ) && <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> y % ( 1 << rpy ) ) ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> <S2SV_ModStart> JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> "
645,<S2SV_StartBug> if ( p -> tcph -> th_flags & TH_RST ) { <S2SV_EndBug> ,"<S2SV_ModStart> StateSynSentValidateTimestamp ( ssn , p ) == false ) return - 1 ; if ( "
646,<S2SV_StartBug> int result = RLC_OK ; <S2SV_EndBug> <S2SV_StartBug> if ( ! bn_is_zero ( t ) ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> if ( pad != RSA_PAD ) { <S2SV_EndBug> <S2SV_StartBug> result = RLC_ERR ; <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> ,"<S2SV_ModStart> RLC_ERR ; bn_t t ; RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> == <S2SV_ModEnd> <S2SV_ModStart> RLC_OK <S2SV_ModEnd> <S2SV_ModStart> } "
647,<S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug> ,<S2SV_ModStart> e <S2SV_ModEnd> 
648,"<S2SV_StartBug> char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rfbWriteExact ( cl , buf , len ) < 0 ) { <S2SV_EndBug> ",<S2SV_ModStart> union { char bytes <S2SV_ModEnd> <S2SV_ModStart> msg ; } buf ; rfbSetColourMapEntriesMsg * scme = & buf . msg <S2SV_ModEnd> <S2SV_ModStart> . bytes <S2SV_ModStart> . bytes 
649,<S2SV_StartBug> char key [ 32 ] = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> if ( vdaux < 1 || vstart + vdaux < vstart ) { <S2SV_EndBug> <S2SV_StartBug> vstart += vdaux ; <S2SV_EndBug> <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> ,<S2SV_ModStart> size_t vstart_off = i ; <S2SV_ModStart> shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> <S2SV_ModStart> += vdaux ; vstart_off <S2SV_ModStart> vstart_off += aux . vda_next ; 
650,<S2SV_StartBug> if ( current -> active_mm != mm ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> ,<S2SV_ModStart> { smp_mb ( ) ; <S2SV_ModStart> } <S2SV_ModStart> smp_mb ( ) ; 
651,<S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ; 
652,"<S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( req -> buf != NULL ) 
653,"<S2SV_StartBug> net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , <S2SV_EndBug> ","<S2SV_ModStart> server -> connrec -> address , "
654,"<S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> ( last_boosted_q * 0.75 ) ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> rc -> kf_boost , <S2SV_EndBug> <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = get_active_quality ( <S2SV_EndBug> <S2SV_StartBug> active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = inter_minq [ active_worst_quality ] ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ; <S2SV_EndBug> <S2SV_StartBug> active_best_quality = inter_minq [ active_worst_quality ] ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> ","<S2SV_ModStart> int * rtc_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ; <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> get_kf_active_quality ( rc , <S2SV_ModEnd> <S2SV_ModStart> cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> , cm -> bit_depth <S2SV_ModStart> get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> <S2SV_ModStart> rtc_minq <S2SV_ModEnd> <S2SV_ModStart> rtc_minq <S2SV_ModEnd> <S2SV_ModStart> rtc_minq <S2SV_ModEnd> <S2SV_ModStart> rtc_minq <S2SV_ModEnd> <S2SV_ModStart> && <S2SV_ModEnd> <S2SV_ModStart> { int qdelta = 0 ; vpx_clear_system_state ( ) ; qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> "
655,"<S2SV_StartBug> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <S2SV_EndBug> <S2SV_StartBug> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <S2SV_EndBug> <S2SV_StartBug> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <S2SV_EndBug> ","<S2SV_ModStart> uaddr_t end_addr = 0 ; <S2SV_ModStart> end_addr <S2SV_ModEnd> <S2SV_ModStart> ROUNDDOWN ( uaddr , addr_incr ) <S2SV_ModEnd> <S2SV_ModStart> end_addr <S2SV_ModEnd> "
656,<S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> ,<S2SV_ModStart> Py_RETURN_NONE <S2SV_ModEnd> 
657,"<S2SV_StartBug> old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ) <S2SV_EndBug> <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> ","<S2SV_ModStart> struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> rc = __load_segment_descriptor <S2SV_ModEnd> <S2SV_ModStart> , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <S2SV_ModEnd> <S2SV_ModStart> rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <S2SV_ModEnd> "
658,"<S2SV_StartBug> UINT16 count ; <S2SV_EndBug> <S2SV_StartBug> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <S2SV_EndBug> ",<S2SV_ModStart> UINT32 <S2SV_ModEnd> <S2SV_ModStart> BITMAP_DATA * 
659,"<S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> grub_memcpy ( buf , data + pos + real_offset , len ) ; <S2SV_EndBug> ",<S2SV_ModStart> { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <S2SV_ModStart> } 
660,<S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; } "
661,<S2SV_StartBug> if ( chunk_num > chm -> num_chunks ) return NULL ; <S2SV_EndBug> ,<S2SV_ModStart> >= <S2SV_ModEnd> 
662,<S2SV_StartBug> if ( ! el ) <S2SV_EndBug> ,"<S2SV_ModStart> { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> "
663,"<S2SV_StartBug> rc -> uwbd . task = kthread_run ( uwbd , rc , ""uwbd"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> uwbd . task == NULL ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> struct task_struct * <S2SV_ModEnd> <S2SV_ModStart> IS_ERR ( task ) ) { <S2SV_ModStart> = NULL ; <S2SV_ModEnd> <S2SV_ModStart> } else { rc -> uwbd . task = task ; <S2SV_ModEnd> <S2SV_ModStart> } 
664,<S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> ,<S2SV_ModStart> if ( ! mmget_still_valid ( mm ) ) return NULL ; 
665,<S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> ,"<S2SV_ModStart> user , scm -> fp -> "
666,"<S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_arg ) ) { <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( tmp , & arg , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( tmp , & annotation , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_string ( tmp , & type_comment , arena ) ; <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""arg\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; annotation = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & annotation <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno <S2SV_ModEnd> <S2SV_ModStart> if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) <S2SV_ModEnd> "
667,"<S2SV_StartBug> int count , i ; <S2SV_EndBug> ",<S2SV_ModStart> unsigned 
668,"<S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> ","<S2SV_ModStart> elems , e -> "
669,"<S2SV_StartBug> stat ( options -> in_file , & filestats ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( filestats . st_size < 8 ) { printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n"" ) ; return - 1 ; } "
670,<S2SV_StartBug> if ( client -> priv -> protocol_timeout ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
671,"<S2SV_StartBug> checkstackp ( L , nextra , where ) ; <S2SV_EndBug> ",<S2SV_ModStart> checkstackGCp <S2SV_ModEnd> 
672,"<S2SV_StartBug> const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <S2SV_EndBug> <S2SV_StartBug> const int * bmode_costs = mb -> mbmode_cost ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE best_mode = DC_PRED ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , i ) ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , i ) ; <S2SV_EndBug> <S2SV_StartBug> bmode_costs = mb -> y_mode_costs [ A ] [ L ] ; <S2SV_EndBug> ","<S2SV_ModStart> above_mi <S2SV_ModEnd> <S2SV_ModStart> left_mi <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> memcpy <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> cpi -> y_mode_costs [ A ] [ L ] ; } this_rd = rd_pick_intra4x4block ( cpi , mb , idy , idx <S2SV_ModEnd> "
673,"<S2SV_StartBug> if ( strcmp ( ptr , ""get<S2SV_blank>"" ) && strcmp ( ptr , ""gets<S2SV_blank>"" ) ) { <S2SV_EndBug> ","<S2SV_ModStart> ptr - c -> rcurr > 100 || ( strncmp ( ptr , ""get<S2SV_blank>"" , 4 ) && strncmp <S2SV_ModEnd> <S2SV_ModStart> , 5 ) "
674,"<S2SV_StartBug> int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; } 
675,<S2SV_StartBug> static int udp_push_pending_frames ( struct sock * sk ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
676,<S2SV_StartBug> for ( pass = 0 ; pass < 10 ; pass ++ ) { <S2SV_EndBug> ,<S2SV_ModStart> || image 
677,<S2SV_StartBug> if ( source == target ) <S2SV_EndBug> ,"<S2SV_ModStart> vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> "
678,"<S2SV_StartBug> bool tsonly ; <S2SV_EndBug> <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug> ","<S2SV_ModStart> , opt_stats = false <S2SV_ModStart> { <S2SV_ModStart> opt_stats = true ; } <S2SV_ModStart> , opt_stats "
679,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> _TIFFfree ( working_copy ) ; 
680,<S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> <S2SV_ModStart> ) ; <S2SV_ModEnd> <S2SV_ModStart> loop_index_mutex <S2SV_ModEnd> 
681,<S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> ,<S2SV_ModStart> ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> 
682,<S2SV_StartBug> for ( plane = 0 ; inpic -> data [ plane ] && plane < 4 ; plane ++ ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> && inpic -> data [ plane ] && inpic -> linesize [ plane ] 
683,"<S2SV_StartBug> re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> ","<S2SV_ModStart> 0 , "
684,"<S2SV_StartBug> ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep ) <S2SV_EndBug> <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> } if ( ep2 <S2SV_ModEnd> <S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> if ( ! <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> <S2SV_ModStart> totlen - 4 ) ) { <S2SV_ModEnd> <S2SV_ModStart> goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> trunc : return NULL ; "
685,"<S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> ",<S2SV_ModStart> return <S2SV_ModStart>  <S2SV_ModEnd> 
686,"<S2SV_StartBug> inl = i2d ( data , NULL ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; } "
687,"<S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> ",<S2SV_ModStart> key_default_cmp <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
688,"<S2SV_StartBug> if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! bpf_map_ptr_unpriv ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( prog -> jit_requested && BITS_PER_LONG == 64 && <S2SV_EndBug> <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> goto patch_call_imm ; <S2SV_EndBug> <S2SV_StartBug> ops = map_ptr -> ops ; <S2SV_EndBug> <S2SV_StartBug> cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; <S2SV_EndBug> <S2SV_StartBug> BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , <S2SV_EndBug> ","<S2SV_ModStart> == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <S2SV_ModEnd> <S2SV_ModStart> aux -> alu_state <S2SV_ModEnd> <S2SV_ModStart> isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <S2SV_ModEnd> <S2SV_ModStart> insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <S2SV_ModEnd> <S2SV_ModStart> ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <S2SV_ModStart> { verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n"" ) ; return - EINVAL ; } <S2SV_ModEnd> <S2SV_ModStart> insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <S2SV_ModEnd> <S2SV_ModStart> struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <S2SV_ModEnd> <S2SV_ModStart> if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } "
689,<S2SV_StartBug> iterator = rfbGetClientIterator ( rfbScreen ) ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ; "
690,"<S2SV_StartBug> if ( Stream_GetRemainingLength ( s ) < 2 ) <S2SV_EndBug> <S2SV_StartBug> Stream_Read_UINT16 ( s , * length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( * length == 0x8000 ) <S2SV_EndBug> <S2SV_StartBug> rdp_read_flow_control_pdu ( s , type ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ( size_t ) * length - 2 ) > Stream_GetRemainingLength ( s ) ) <S2SV_EndBug> <S2SV_StartBug> if ( * length > 4 ) <S2SV_EndBug> ",<S2SV_ModStart> UINT16 len ; <S2SV_ModStart> len ) ; * length = len <S2SV_ModEnd> <S2SV_ModStart> len <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return FALSE <S2SV_ModStart> len < 4 ) || ( ( len <S2SV_ModEnd> <S2SV_ModStart> ) <S2SV_ModStart> len <S2SV_ModEnd> 
691,"<S2SV_StartBug> err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ; <S2SV_EndBug> <S2SV_StartBug> err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ; <S2SV_EndBug> <S2SV_StartBug> err = ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug> ",<S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) <S2SV_ModStart> TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) 
692,"<S2SV_StartBug> int get_down2_steps ( int in_length , int out_length ) { <S2SV_EndBug> ",<S2SV_ModStart> static 
693,<S2SV_StartBug> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <S2SV_EndBug> ,<S2SV_ModStart> 18 <S2SV_ModEnd> 
694,<S2SV_StartBug> prefix = report [ i ] ; <S2SV_EndBug> <S2SV_StartBug> case 3 : <S2SV_EndBug> ,"<S2SV_ModStart> ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , ""Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\n"" , i + size , length ) ; break ; } <S2SV_ModEnd> <S2SV_ModStart> 4 : <S2SV_ModEnd> "
695,<S2SV_StartBug> # ifndef PGEN <S2SV_EndBug> ,<S2SV_ModStart> if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; } 
696,"<S2SV_StartBug> static void set_segment_id ( VP9_COMMON * cm , BLOCK_SIZE bsize , <S2SV_EndBug> <S2SV_StartBug> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <S2SV_EndBug> <S2SV_StartBug> for ( y = 0 ; y < ymis ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( x = 0 ; x < xmis ; x ++ ) <S2SV_EndBug> <S2SV_StartBug> cm -> last_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ; <S2SV_EndBug> ","<S2SV_ModStart> int mi_offset , int x_mis , int y_mis <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> y_mis <S2SV_ModEnd> <S2SV_ModStart> x_mis <S2SV_ModEnd> <S2SV_ModStart> current_frame_seg_map <S2SV_ModEnd> "
697,"<S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> <S2SV_StartBug> key -> reject_error = - error ; <S2SV_EndBug> ","<S2SV_ModStart> key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> <S2SV_ModStart> mark_key_instantiated ( key , - error <S2SV_ModEnd> "
698,"<S2SV_StartBug> size_t i , maxcount ; <S2SV_EndBug> <S2SV_StartBug> ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < CDF_TOLE4 ( si -> si_count ) ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> info , count , & maxcount ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> CDF_TOLE4 <S2SV_ModEnd> <S2SV_ModStart> if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
699,<S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 1 ) <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> . ptr [ <S2SV_ModEnd> <S2SV_ModStart> . indx <S2SV_ModEnd> 
700,"
","
"
701,"<S2SV_StartBug> Total += vp8_mse16x16 ( src + j , source -> y_stride , <S2SV_EndBug> ",<S2SV_ModStart> vpx_mse16x16 <S2SV_ModEnd> 
702,<S2SV_StartBug> calldata -> arg . open_flags = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> fmode <S2SV_ModEnd> 
703,"<S2SV_StartBug> ext4_io_end_t * io ; <S2SV_EndBug> <S2SV_StartBug> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) <S2SV_EndBug> <S2SV_StartBug> while ( ! list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <S2SV_EndBug> <S2SV_StartBug> io = list_entry ( EXT4_I ( inode ) -> i_completed_io_list . next , <S2SV_EndBug> <S2SV_StartBug> ret = ext4_end_io_nolock ( io ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ret2 < 0 ) ? ret2 : 0 ; <S2SV_EndBug> ","<S2SV_ModStart> ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags <S2SV_ModStart> ei <S2SV_ModEnd> <S2SV_ModStart> spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> ei <S2SV_ModEnd> <S2SV_ModStart> ei <S2SV_ModEnd> <S2SV_ModStart> spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags <S2SV_ModStart> spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; "
704,"<S2SV_StartBug> unsigned char type , void * * ptr ) <S2SV_EndBug> <S2SV_StartBug> if ( header -> bLength < 2 ) { <S2SV_EndBug> <S2SV_StartBug> if ( header -> bDescriptorType == type ) { <S2SV_EndBug> ","<S2SV_ModStart> , size_t minsize <S2SV_ModStart> || header -> bLength > size <S2SV_ModStart> && header -> bLength >= minsize "
705,"<S2SV_StartBug> sprintf ( outfilename , ""%s_%05d.j2k"" , argv [ 2 ] , snum ) ; <S2SV_EndBug> <S2SV_StartBug> fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n"" , outfilename ) ; <S2SV_EndBug> ","<S2SV_ModStart> { int num = snprintf <S2SV_ModEnd> <S2SV_ModStart> sizeof ( outfilename ) , <S2SV_ModStart> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , ""maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n"" ) ; free ( frame_codestream ) ; return 1 ; } } <S2SV_ModEnd> <S2SV_ModStart> ) ; free ( frame_codestream "
706,"<S2SV_StartBug> if ( j >= length ) return - 1 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( cp , packet + j , label_len ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( j + label_len > length ) return - 1 ; 
707,"<S2SV_StartBug> if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> <S2SV_StartBug> else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ","<S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , <S2SV_ModStart> ndo , "
708,<S2SV_StartBug> subsampling_dx = parameters -> subsampling_dx ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; } "
709,"<S2SV_StartBug> snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> strncpy <S2SV_ModEnd> <S2SV_ModStart> ""compression"" , sizeof ( rcomp . type ) <S2SV_ModEnd> "
710,"<S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_lock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> mutex_unlock <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
711,<S2SV_StartBug> var = vp8_variance16x16 <S2SV_EndBug> ,<S2SV_ModStart> vpx_variance16x16 <S2SV_ModEnd> 
712,"<S2SV_StartBug> int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { <S2SV_EndBug> <S2SV_StartBug> int sent = recv ( conn -> sock , cbuf , len , 0 ) ; <S2SV_EndBug> ",<S2SV_ModStart> size_t <S2SV_ModEnd> <S2SV_ModStart> size_t <S2SV_ModEnd> 
713,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
714,<S2SV_StartBug> vpx_free ( cr ) ; <S2SV_EndBug> ,<S2SV_ModStart> -> last_coded_q_map ) ; vpx_free ( cr 
715,<S2SV_StartBug> return in ; <S2SV_EndBug> ,<S2SV_ModStart> NULL <S2SV_ModEnd> 
716,<S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> ,<S2SV_ModStart> && value [ n ] - min < field -> maxusage <S2SV_ModStart> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> value [ n ] - min < field -> maxusage && 
717,<S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) <S2SV_EndBug> ,<S2SV_ModStart> 4 <S2SV_ModEnd> 
718,<S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> ,<S2SV_ModStart> > <S2SV_ModEnd> 
719,"<S2SV_StartBug> list_del ( & key -> graveyard_link ) ; <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <S2SV_EndBug> <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> ",<S2SV_ModStart> short state = key -> state ; <S2SV_ModStart> state == KEY_IS_POSITIVE && <S2SV_ModEnd> <S2SV_ModStart> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> 
720,<S2SV_StartBug> PCI_DMA_FROMDEVICE ) ) <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> ,<S2SV_ModStart> { kfree_skb ( skb ) ; <S2SV_ModStart> } 
721,<S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( bi == NULL ) { pr_err ( ""%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n"" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> "
722,"<S2SV_StartBug> if ( mount ( console -> name , path , ""none"" , MS_BIND , 0 ) ) { <S2SV_EndBug> ","<S2SV_ModStart> safe_mount ( console -> name , path , ""none"" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> "
723,<S2SV_StartBug> if ( wp -> listening_socket != STDIN_FILENO ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
724,<S2SV_StartBug> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> UPLOAD_BUFSIZE <S2SV_ModEnd> <S2SV_ModStart> DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ; 
725,"<S2SV_StartBug> struct vp9_ref_frame ref ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref ) ; <S2SV_EndBug> <S2SV_StartBug> find_mismatch ( & enc_img , & dec_img , y , u , v ) ; <S2SV_EndBug> ","<S2SV_ModStart> ref_enc , ref_dec ; ref_enc <S2SV_ModEnd> <S2SV_ModStart> ref_dec . idx = 0 ; <S2SV_ModStart> ref_enc ) ; enc_img = ref_enc <S2SV_ModEnd> <S2SV_ModStart> ref_dec ) ; dec_img = ref_dec . img ; # if CONFIG_VP9_HIGHBITDEPTH if ( ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) != ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ) { if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & enc_img , enc_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , enc_img . d_w , enc_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & enc_img , & ref_enc . img ) ; } if ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & dec_img , dec_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , dec_img . d_w , dec_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & dec_img , & ref_dec . img ) ; } } # endif <S2SV_ModEnd> <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { find_mismatch_high ( & enc_img , & dec_img , y , u , v ) ; } else { <S2SV_ModStart> } # else find_mismatch ( & enc_img , & dec_img , y , u , v ) ; # endif "
726,"<S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> ","<S2SV_ModStart> images ) { const Image * next ; <S2SV_ModEnd> <S2SV_ModStart> columns , <S2SV_ModStart> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> images <S2SV_ModEnd> "
727,"<S2SV_StartBug> static void <S2SV_EndBug> <S2SV_StartBug> horDiff16 ( tif , cp0 , cc ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> int <S2SV_ModEnd> <S2SV_ModStart> if ( ! <S2SV_ModStart> ) return 0 <S2SV_ModStart> return 1 ; 
728,<S2SV_StartBug> return 0 ; <S2SV_EndBug> ,<S2SV_ModStart> hrtimer_try_to_cancel ( & stime -> hrt ) ; 
729,<S2SV_StartBug> if ( f -> map & ( 1 << rec ) ) { <S2SV_EndBug> ,"<S2SV_ModStart> rec >= f -> num ) { ldm_error ( ""REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)"" , rec , f -> num ) ; return false ; } if ( "
730,"<S2SV_StartBug> static void estimate_ref_frame_costs ( VP9_COMP * cpi , int segment_id , <S2SV_EndBug> <S2SV_StartBug> vp9_prob * comp_mode_p ) { <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ref_costs_comp , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_comp ) ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob comp_inter_p = 128 ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p ( cm , xd ) ; <S2SV_EndBug> ","<S2SV_ModStart> const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> int seg_ref_active = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { memset <S2SV_ModEnd> <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> <S2SV_ModStart> vpx_prob <S2SV_ModEnd> "
731,"<S2SV_StartBug> int i , j ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ; int mag_test = 2 ; int frames_test = 4 ; int index_sz_test = 2 + mag_test * frames_test ; marker_test |= frames_test - 1 ; marker_test |= ( mag_test - 1 ) << 3 ; * x ++ = marker_test ; for ( i = 0 ; i < mag_test * frames_test ; ++ i ) * x ++ = 0 ; * x ++ = marker_test ; ctx -> pending_cx_data_sz += index_sz_test ; printf ( ""Added<S2SV_blank>supplemental<S2SV_blank>superframe<S2SV_blank>data\\n"" ) ; # endif <S2SV_ModStart> # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ; # endif "
732,<S2SV_StartBug> if ( c -> chunk_size == 0 ) <S2SV_EndBug> <S2SV_StartBug> else { <S2SV_EndBug> ,<S2SV_ModStart> <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <S2SV_ModEnd> <S2SV_ModStart> av_assert0 ( len <= c -> chunk_size ) ; 
733,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> ","<S2SV_ModStart> { ND_TCHECK ( <S2SV_ModEnd> <S2SV_ModStart> ; ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> "
734,<S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> <S2SV_StartBug> return false ; <S2SV_EndBug> ,"<S2SV_ModStart> bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> <S2SV_ModStart> F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
735,"<S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , <S2SV_EndBug> <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> ",<S2SV_ModStart> \\\n{ <S2SV_ModEnd> <S2SV_ModStart> \\\n} <S2SV_ModEnd> <S2SV_ModStart> for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] 
736,"<S2SV_StartBug> int i , y ; <S2SV_EndBug> <S2SV_StartBug> fwrite ( buf , 1 , w , file ) ; <S2SV_EndBug> ",<S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; # else const int bytes_per_sample = 1 ; # endif <S2SV_ModStart> bytes_per_sample <S2SV_ModEnd> 
737,<S2SV_StartBug> uint8_t clear_buffer [ 9 ] ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( ( profile >= 2 && data_sz <= 1 ) || data_sz < 1 ) <S2SV_EndBug> <S2SV_StartBug> if ( data_sz <= 8 ) <S2SV_EndBug> ,<S2SV_ModStart> 10 <S2SV_ModEnd> <S2SV_ModStart> if ( data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_ModStart> vpx_rb_read_bit ( & rb ) ) { if ( profile > <S2SV_ModEnd> <S2SV_ModStart> < 2 ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_ModEnd> <S2SV_ModStart> < 10 <S2SV_ModEnd> 
738,<S2SV_StartBug> # endif <S2SV_EndBug> <S2SV_StartBug> read_config_file ( ) ; <S2SV_EndBug> <S2SV_StartBug> umask ( 0 ) ; <S2SV_EndBug> ,<S2SV_ModStart> umask ( 022 ) ; <S2SV_ModStart> global_data -> umask = umask_val ; <S2SV_ModStart>  <S2SV_ModEnd> 
739,"<S2SV_StartBug> ut8 * directory_base ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <S2SV_EndBug> ","<S2SV_ModStart> struct minidump_directory entry <S2SV_ModEnd> <S2SV_ModStart> ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> ut32 delta = <S2SV_ModEnd> <S2SV_ModStart> ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <S2SV_ModStart> if ( r ) { <S2SV_ModStart> & <S2SV_ModStart> } "
740,"<S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" "
741,<S2SV_StartBug> return MS_FALSE ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , ""Invalid<S2SV_blank>time<S2SV_blank>filter."" , ""msPostGISLayerSetTimeFilter()"" ) ; return MS_FALSE ; } "
742,<S2SV_StartBug> struct kvm_lapic * apic = vcpu -> arch . apic ; <S2SV_EndBug> <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> kvm_write_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> <S2SV_ModStart> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> "
743,<S2SV_StartBug> gint * ac ; <S2SV_EndBug> ,<S2SV_ModStart> ; g_assert ( box_width > 0 ) 
744,<S2SV_StartBug> struct tcp_sock_t * tcp_socket ; <S2SV_EndBug> <S2SV_StartBug> while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL && <S2SV_EndBug> <S2SV_StartBug> g_options . only_desired_port == 0 ) { <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> uint16_t real_port = tcp_port_number_get ( tcp_socket ) ; <S2SV_EndBug> <S2SV_StartBug> uint16_t pid ; <S2SV_EndBug> <S2SV_StartBug> args -> tcp = tcp_conn_accept ( tcp_socket ) ; <S2SV_EndBug> <S2SV_StartBug> cleanup_usb : <S2SV_EndBug> ,"<S2SV_ModStart> = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <S2SV_ModEnd> <S2SV_ModStart> ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <S2SV_ModEnd> <S2SV_ModStart> ) break ; <S2SV_ModEnd> <S2SV_ModStart> NOTE ( ""Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d"" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <S2SV_ModEnd> <S2SV_ModStart> ; if ( tcp_socket ) real_port <S2SV_ModStart> ) ; else real_port = tcp_port_number_get ( tcp6_socket <S2SV_ModStart> NOTE ( ""Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable"" , real_port , tcp_socket ? """" : ""not<S2SV_blank>"" , tcp6_socket ? """" : ""not<S2SV_blank>"" ) ; <S2SV_ModStart> tcp_conn_select ( tcp_socket , tcp6_socket <S2SV_ModEnd> <S2SV_ModStart> if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ; "
745,<S2SV_StartBug> static int done ; <S2SV_EndBug> <S2SV_StartBug> for ( c = 'a' ; c <= 'z' ; c ++ ) <S2SV_EndBug> ,<S2SV_ModStart> = 0 <S2SV_ModStart> 0 ; c < CHAR_SET_SIZE ; ++ c ) if ( ISALNUM ( c ) <S2SV_ModEnd> 
746,"<S2SV_StartBug> YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( frame_stats -> mb_stats , 0 , <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; assert ( golden_ref != NULL <S2SV_ModStart> memset <S2SV_ModEnd> <S2SV_ModStart> vpx_clear_system_state <S2SV_ModEnd> 
747,<S2SV_StartBug> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n"" ) ; retval = - EINVAL ; goto error ; } "
748,"<S2SV_StartBug> exit_client ( client_p , client_p , client_p , ""Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , ""Malformed<S2SV_blank>AUTHENTICATE"" "
749,"<S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( rsvp_obj_ctype ) { <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , <S2SV_EndBug> ",<S2SV_ModStart> switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; 
750,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = sizeof ( * maddr ) <S2SV_ModEnd> 
751,"<S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> ","<S2SV_ModStart> mark_key_instantiated ( key , 0 <S2SV_ModEnd> "
752,"<S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> ","<S2SV_ModStart> rcu_read_lock ( ) ; <S2SV_ModStart> rcu_dereference ( <S2SV_ModStart> ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> "
753,<S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> = sizeof ( * maddr ) <S2SV_ModEnd> 
754,<S2SV_StartBug> bool slow ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> * addr_len = sizeof ( * sin ) ; 
755,<S2SV_StartBug> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <S2SV_EndBug> ,<S2SV_ModStart> ) ; ND_TCHECK_32BITS ( & hellop -> hello_options 
756,"<S2SV_StartBug> case 0 : <S2SV_EndBug> <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ; "
757,<S2SV_StartBug> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <S2SV_EndBug> ,<S2SV_ModStart> && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> 
758,"<S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug> ","<S2SV_ModStart> __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> "
759,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU<S2SV_blank>size<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> if ( tlv_len < 6 ) { return hexdump ; } 
760,"<S2SV_StartBug> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <S2SV_EndBug> ",<S2SV_ModStart> get_alg_priv ( ctx ) <S2SV_ModEnd> 
761,"<S2SV_StartBug> int res , ret ; <S2SV_EndBug> ",<S2SV_ModStart> ; if ( uaddr == uaddr2 ) return - EINVAL 
762,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> tty -> disc_data = NULL ; tty -> receive_room = 0 ; 
763,<S2SV_StartBug> if ( n <= 0 ) return ( n ) ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
764,<S2SV_StartBug> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <S2SV_EndBug> ,<S2SV_ModStart> inet_sk ( newsk ) -> mc_list = NULL ; 
765,<S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> if <S2SV_ModEnd> <S2SV_ModStart> goto do_error 
766,<S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> ,<S2SV_ModStart> 3 <S2SV_ModEnd> 
767,"<S2SV_StartBug> ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; <S2SV_EndBug> ","<S2SV_ModStart> ep2 <S2SV_ModEnd> <S2SV_ModStart> if ( cp == NULL ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } "
768,"<S2SV_StartBug> static void fdct8 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <S2SV_EndBug> <S2SV_StartBug> int t0 , t1 , t2 , t3 ; <S2SV_EndBug> <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 4 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 6 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> <S2SV_StartBug> t2 = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( t0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = fdct_round_shift ( t2 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 5 ] = fdct_round_shift ( t1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 7 ] = fdct_round_shift ( t3 ) ; <S2SV_EndBug> ","<S2SV_ModStart> tran_low_t * input , tran_low_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t <S2SV_ModEnd> <S2SV_ModStart> tran_high_t t0 , t1 , t2 , t3 ; tran_high_t <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) fdct_round_shift ( t0 ) ; t3 = ( tran_low_t ) <S2SV_ModEnd> <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) <S2SV_ModStart> ( tran_low_t ) "
769,"<S2SV_StartBug> size2 , mime ) ; <S2SV_EndBug> ",<S2SV_ModStart> NULL <S2SV_ModEnd> 
770,<S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> ,<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
771,"<S2SV_StartBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ; <S2SV_EndBug> <S2SV_StartBug> mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ; <S2SV_EndBug> ","<S2SV_ModStart> vpx_reader <S2SV_ModEnd> <S2SV_ModStart> above_mi <S2SV_ModEnd> <S2SV_ModStart> left_mi <S2SV_ModEnd> <S2SV_ModStart> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ; <S2SV_ModStart> mi_offset , x_mis , y_mis <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
772,"
","
"
773,<S2SV_StartBug> if ( len <= 0 ) <S2SV_EndBug> <S2SV_StartBug> len -= bytes ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ; 
774,"<S2SV_StartBug> length ; <S2SV_EndBug> <S2SV_StartBug> sun_pixels = sun_data ; <S2SV_EndBug> <S2SV_StartBug> ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> height , <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart>  <S2SV_ModEnd> "
775,"<S2SV_StartBug> if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || <S2SV_EndBug> <S2SV_StartBug> set_tls_desc ( target , <S2SV_EndBug> ",<S2SV_ModStart> int i ; <S2SV_ModStart> for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ; 
776,"<S2SV_StartBug> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <S2SV_EndBug> <S2SV_StartBug> valuelen = args -> valuelen ; <S2SV_EndBug> ",<S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> <S2SV_ModStart> rmtvaluelen <S2SV_ModEnd> 
777,"<S2SV_StartBug> set_exception_intercept ( svm , AC_VECTOR ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; set_exception_intercept ( svm , DB_VECTOR "
778,<S2SV_StartBug> H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; <S2SV_EndBug> ,<S2SV_ModStart> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; 
779,"<S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; } "
780,<S2SV_StartBug> int strindex = 0 ; <S2SV_EndBug> ,<S2SV_ModStart> size_t <S2SV_ModEnd> 
781,<S2SV_StartBug> if ( old -> curframe != cur -> curframe ) <S2SV_EndBug> ,<S2SV_ModStart> ) return false ; if ( old -> speculative && ! cur -> speculative 
782,"<S2SV_StartBug> set_exception_intercept ( svm , AC_VECTOR ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; set_exception_intercept ( svm , DB_VECTOR "
783,"<S2SV_StartBug> if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) <S2SV_EndBug> <S2SV_StartBug> if ( ! bpf_map_ptr_unpriv ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( prog -> jit_requested && BITS_PER_LONG == 64 && <S2SV_EndBug> <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> goto patch_call_imm ; <S2SV_EndBug> <S2SV_StartBug> ops = map_ptr -> ops ; <S2SV_EndBug> <S2SV_StartBug> cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; <S2SV_EndBug> <S2SV_StartBug> BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , <S2SV_EndBug> ","<S2SV_ModStart> == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <S2SV_ModEnd> <S2SV_ModStart> aux -> alu_state <S2SV_ModEnd> <S2SV_ModStart> isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <S2SV_ModEnd> <S2SV_ModStart> insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <S2SV_ModEnd> <S2SV_ModStart> ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <S2SV_ModStart> { verbose ( env , ""tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n"" ) ; return - EINVAL ; } <S2SV_ModEnd> <S2SV_ModStart> insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <S2SV_ModEnd> <S2SV_ModStart> struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <S2SV_ModEnd> <S2SV_ModStart> if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , ""bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n"" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } "
784,<S2SV_StartBug> context . Xtogo = i -> width ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } "
785,<S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> <S2SV_StartBug> # endif <S2SV_EndBug> ,<S2SV_ModStart> free <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
786,"<S2SV_StartBug> if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> apply_printer_defaults ( printer , job ) ; <S2SV_EndBug> ","<S2SV_ModStart> attr = ippFindAttribute ( con -> request , ""requesting-user-name"" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( ""Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s"" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart>  <S2SV_ModEnd> "
787,<S2SV_StartBug> client -> desktopName = malloc ( ( uint64_t ) client -> si . nameLength + 1 ) ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( ""Too<S2SV_blank>big<S2SV_blank>desktop<S2SV_blank>name<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n"" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; } <S2SV_ModStart>  <S2SV_ModEnd> "
788,<S2SV_StartBug> size_t <S2SV_EndBug> <S2SV_StartBug> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] << 16 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 2 ] << 8 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> ,<S2SV_ModStart> unsigned int <S2SV_ModEnd> <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart> ( unsigned int ) <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
789,"<S2SV_StartBug> ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , <S2SV_EndBug> ",<S2SV_ModStart> ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; 
790,<S2SV_StartBug> char added ; <S2SV_EndBug> <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
791,"<S2SV_StartBug> flush_dcache_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> iov_iter_advance ( ii , tmp ) ; <S2SV_EndBug> ","<S2SV_ModStart> ) ; iov_iter_advance ( ii , tmp <S2SV_ModStart>  <S2SV_ModEnd> "
792,<S2SV_StartBug> if ( namelen > 32 ) <S2SV_EndBug> ,<S2SV_ModStart> len <S2SV_ModEnd> 
793,"<S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> ","<S2SV_ModStart> , rootfs -> mount "
794,<S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> pReplyData == NULL || <S2SV_EndBug> <S2SV_StartBug> || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> ,<S2SV_ModStart> replySize == NULL || <S2SV_ModStart> == NULL || replySize <S2SV_ModStart> == NULL || replySize <S2SV_ModStart> replySize == NULL || <S2SV_ModStart> replySize == NULL || <S2SV_ModStart> == NULL || replySize 
795,<S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
796,<S2SV_StartBug> if ( debug ) { <S2SV_EndBug> <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> ,<S2SV_ModStart> d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart>  <S2SV_ModEnd> 
797,"<S2SV_StartBug> tlen = len - sizeof ( struct eigrp_common_header ) ; <S2SV_EndBug> <S2SV_StartBug> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u"" , <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; <S2SV_EndBug> <S2SV_StartBug> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>"" , <S2SV_EndBug> ","<S2SV_ModStart> if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , ""EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , tok2str ( eigrp_opcode_values , ""unknown<S2SV_blank>(%u)"" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)"" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; } "
798,"<S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> ","<S2SV_ModStart> if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } <S2SV_ModStart> if ( strlen ( <S2SV_ModEnd> <S2SV_ModStart> >= sizeof ( szVal ) ) { fprintf ( stderr , ""Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n"" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 ) "
799,<S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> ,<S2SV_ModStart> && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE 
800,<S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 5 : <S2SV_EndBug> <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> ,<S2SV_ModStart> elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> <S2SV_ModStart> elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart>  <S2SV_ModEnd> 
801,<S2SV_StartBug> if ( refill_pi_state_cache ( ) ) <S2SV_EndBug> <S2SV_StartBug> goto out_put_key1 ; <S2SV_EndBug> ,"<S2SV_ModStart> uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } "
802,<S2SV_StartBug> if ( key_is_instantiated ( keyring ) ) { <S2SV_EndBug> ,<S2SV_ModStart> key_is_positive <S2SV_ModEnd> 
803,<S2SV_StartBug> pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ; <S2SV_EndBug> ,<S2SV_ModStart> Assert ( ncolumns <= MaxTupleAttributeNumber ) ; 
804,"<S2SV_StartBug> uint16_t n ; <S2SV_EndBug> <S2SV_StartBug> Enc28j60Context * context ; <S2SV_EndBug> <S2SV_StartBug> if ( enc28j60ReadReg ( interface , ENC28J60_REG_EPKTCNT ) ) <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTH , MSB ( context -> nextPacket ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ReadBuffer ( interface , ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ReadBuffer ( interface , context -> rxBuffer , n ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( context -> nextPacket - 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( context -> nextPacket - 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON2 , ECON2_PKTDEC ) ; <S2SV_EndBug> <S2SV_StartBug> nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; <S2SV_EndBug> ","<S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> uint8_t header [ 6 ] ; <S2SV_ModStart> ENC28J60_EPKTCNT ) != 0 ) { enc28j60WriteReg ( interface , ENC28J60_ERDPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERDPTH <S2SV_ModEnd> <S2SV_ModStart> header <S2SV_ModEnd> <S2SV_ModStart> header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD16LE ( header + 4 <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_RSV_RECEIVED_OK <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTL <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ERXRDPTH <S2SV_ModEnd> <S2SV_ModStart> ENC28J60_ECON2 , ENC28J60_ECON2_PKTDEC <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> "
805,"<S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> <S2SV_StartBug> base_path = xasprintf ( ""/run/user/%d/.bubblewrap"" , real_uid ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModEnd> <S2SV_ModStart> ""/tmp"" ; <S2SV_ModEnd> "
806,<S2SV_StartBug> if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { <S2SV_EndBug> ,<S2SV_ModStart> && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED 
807,<S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> int name_len ; <S2SV_EndBug> ,"<S2SV_ModStart> avio_skip ( pb , name_len <S2SV_ModEnd> <S2SV_ModStart> ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA "
808,<S2SV_StartBug> * head = NULL ; <S2SV_EndBug> ,"<S2SV_ModStart> giterr_set_str ( GITERR_NET , ""Invalid<S2SV_blank>empty<S2SV_blank>packet"" ) ; return GIT_ERROR <S2SV_ModEnd> "
809,"<S2SV_StartBug> int xmkstemp ( char * * tmpname , char * dir ) <S2SV_EndBug> <S2SV_StartBug> char * tmpenv ; <S2SV_EndBug> <S2SV_StartBug> if ( dir != NULL ) <S2SV_EndBug> <S2SV_StartBug> tmpenv = dir ; <S2SV_EndBug> <S2SV_StartBug> if ( tmpenv ) <S2SV_EndBug> <S2SV_StartBug> program_invocation_short_name ) ; <S2SV_EndBug> ","<S2SV_ModStart> const <S2SV_ModStart> , const char * prefix <S2SV_ModStart> const <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ? dir : <S2SV_ModEnd> <S2SV_ModStart> ! tmpenv ) tmpenv = _PATH_TMP ; <S2SV_ModEnd> <S2SV_ModStart> prefix <S2SV_ModEnd> "
810,<S2SV_StartBug> if ( length < sizeof ( DhcpMessage ) ) <S2SV_EndBug> ,<S2SV_ModStart> || <S2SV_ModEnd> 
811,"<S2SV_StartBug> if ( ! revs -> blob_objects ) <S2SV_EndBug> <S2SV_StartBug> show ( obj , path , name , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ","<S2SV_ModStart> size_t pathlen ; <S2SV_ModStart> pathlen = path -> len ; strbuf_addstr ( path , name ) ; <S2SV_ModStart> -> buf <S2SV_ModEnd> <S2SV_ModStart> strbuf_setlen ( path , pathlen ) ; "
812,<S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug> ,<S2SV_ModStart> - <S2SV_ModEnd> 
813,"<S2SV_StartBug> static void __nfs4_close ( struct path * path , struct nfs4_state * state , mode_t mode , int wait ) <S2SV_EndBug> <S2SV_StartBug> int newstate ; <S2SV_EndBug> <S2SV_StartBug> switch ( mode & ( FMODE_READ | FMODE_WRITE ) ) { <S2SV_EndBug> ",<S2SV_ModStart> fmode_t fmode <S2SV_ModEnd> <S2SV_ModStart> fmode_t <S2SV_ModEnd> <S2SV_ModStart> fmode <S2SV_ModEnd> 
814,<S2SV_StartBug> tread . event = SNDRV_TIMER_EVENT_EARLY ; <S2SV_EndBug> ,"<S2SV_ModStart> memset ( & tread , 0 , sizeof ( tread ) ) ; "
815,<S2SV_StartBug> if ( sock_owned_by_user ( sk ) ) { <S2SV_EndBug> ,<S2SV_ModStart> sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if ( 
816,"<S2SV_StartBug> ""?"" , tptr [ 0 ] ) ) ) ; <S2SV_EndBug> ",<S2SV_ModStart> ) ; ND_TCHECK ( tptr [ 1 ] 
817,"<S2SV_StartBug> return chg ; <S2SV_EndBug> <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> ret = hugetlb_acct_memory ( h , chg ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ",<S2SV_ModStart> { ret = chg ; goto out_err ; } <S2SV_ModEnd> <S2SV_ModStart> { ret = <S2SV_ModEnd> <S2SV_ModStart> goto out_err ; } <S2SV_ModStart> goto out_err <S2SV_ModEnd> <S2SV_ModStart> out_err : resv_map_put ( vma ) ; return ret ; 
818,<S2SV_StartBug> CLEANUP_FREE char * * lines = NULL ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> free ( lines ) ; 
819,<S2SV_StartBug> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <S2SV_EndBug> ,<S2SV_ModStart> perf_paranoid_tracepoint_raw <S2SV_ModEnd> 
820,"<S2SV_StartBug> case 'c' : return getnum ( L , fmt , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <S2SV_EndBug> ",<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
821,<S2SV_StartBug> return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ; <S2SV_EndBug> ,<S2SV_ModStart> READ_ONCE ( <S2SV_ModStart> ) 
822,"<S2SV_StartBug> static int do_16x16_motion_search ( VP9_COMP * cpi , const int_mv * ref_mv , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> int_mv tmp_mv ; <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , <S2SV_EndBug> <S2SV_StartBug> tmp_err = do_16x16_motion_iteration ( cpi , & ref_mv -> as_mv , & tmp_mv . as_mv , <S2SV_EndBug> ","<S2SV_ModStart> MV * ref_mv , int_mv * <S2SV_ModEnd> <S2SV_ModStart> td . <S2SV_ModStart> MV tmp_mv ; err = vpx_sad16x16 <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_mv = tmp_mv ; } if ( ref_mv -> row != 0 || ref_mv -> col != 0 ) { unsigned int tmp_err ; MV zero_ref_mv = { 0 , 0 } , tmp_mv ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_mv = tmp_mv <S2SV_ModEnd> "
823,<S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( segment -> flags & TCP_FLAG_FIN ) <S2SV_EndBug> <S2SV_StartBug> ackNum ++ ; <S2SV_EndBug> ,<S2SV_ModStart> { <S2SV_ModStart> } <S2SV_ModStart> { <S2SV_ModStart> } 
824,<S2SV_StartBug> struct snd_timer_user * tu ; <S2SV_EndBug> <S2SV_StartBug> switch ( cmd ) { <S2SV_EndBug> <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> ,"<S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> long ret <S2SV_ModEnd> <S2SV_ModStart> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg ) <S2SV_ModEnd> <S2SV_ModStart> ioctl_lock <S2SV_ModEnd> <S2SV_ModStart> ret <S2SV_ModEnd> "
825,<S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ,<S2SV_ModStart>  <S2SV_ModEnd> 
826,<S2SV_StartBug> in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; <S2SV_EndBug> ,"<S2SV_ModStart> if ( <S2SV_ModStart> < <S2SV_ModEnd> <S2SV_ModStart> ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , ""RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\n"" ) ; } <S2SV_ModEnd> "
827,"<S2SV_StartBug> v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> <S2SV_StartBug> v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ; <S2SV_EndBug> ",<S2SV_ModStart> ! ! <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> ! ! <S2SV_ModStart>  <S2SV_ModEnd> 
828,<S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug> ,<S2SV_ModStart> ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX 
829,<S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> ,<S2SV_ModStart> sock * sk = asoc -> base . sk ; struct <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> 
830,<S2SV_StartBug> xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> void * ptr = malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> num , size_t <S2SV_ModStart> size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> res <S2SV_ModEnd> "
831,<S2SV_StartBug> sys -> free ( lzx -> inbuf ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( lzx -> inbuf ) <S2SV_ModStart> if ( lzx -> window ) 
832,<S2SV_StartBug> if ( NAPI_GRO_CB ( skb ) -> udp_mark || <S2SV_EndBug> <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 1 ; <S2SV_EndBug> ,<S2SV_ModStart> encap_mark <S2SV_ModEnd> <S2SV_ModStart> encap_mark <S2SV_ModEnd> 
833,"<S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> <S2SV_StartBug> int64_t this_distortion , this_sse ; <S2SV_EndBug> <S2SV_StartBug> super_block_uvrd ( cpi , x , & this_rate_tokenonly , <S2SV_EndBug> <S2SV_StartBug> & this_distortion , & s , & this_sse , bsize , best_rd ) ; <S2SV_EndBug> <S2SV_StartBug> x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ; <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> select_txfm_size ) { <S2SV_EndBug> ","<S2SV_ModStart> PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> <S2SV_ModStart> ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) <S2SV_ModStart> if ( ! <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> cpi <S2SV_ModEnd> <S2SV_ModStart> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ; <S2SV_ModEnd> "
834,"<S2SV_StartBug> if ( exists_not_none ( obj , & PyId_arg ) ) { <S2SV_EndBug> <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_identifier ( tmp , & arg , arena ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> ","<S2SV_ModStart> lookup_attr_id <S2SV_ModEnd> <S2SV_ModStart> , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; arg = NULL ; } else <S2SV_ModEnd> <S2SV_ModStart> res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <S2SV_ModEnd> <S2SV_ModStart> Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>keyword"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value <S2SV_ModEnd> <S2SV_ModStart>  <S2SV_ModEnd> "
835,<S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( ! enable ) { wake_up_interruptible ( & sunkbd -> wait ) ; cancel_work_sync ( & sunkbd -> tq ) ; } 
836,"<S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> ",<S2SV_ModStart> _dh <S2SV_ModEnd> 
837,"<S2SV_StartBug> static int read_fragment_table ( long long * directory_table_end ) <S2SV_EndBug> <S2SV_StartBug> int bytes = SQUASHFS_FRAGMENT_BYTES ( sBlk . s . fragments ) ; <S2SV_EndBug> <S2SV_StartBug> int indexes = SQUASHFS_FRAGMENT_INDEXES ( sBlk . s . fragments ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sBlk . s . fragments == 0 ) { <S2SV_EndBug> <S2SV_StartBug> SQUASHFS_FRAGMENT_INDEX_BYTES ( sBlk . s . fragments ) , <S2SV_EndBug> <S2SV_StartBug> * directory_table_end = fragment_table_index [ 0 ] ; <S2SV_EndBug> ","<S2SV_ModStart> table_start <S2SV_ModEnd> <S2SV_ModStart> long long <S2SV_ModEnd> <S2SV_ModStart> ( long long ) <S2SV_ModStart> ( long long ) sBlk . s . fragments ) ; int length = SQUASHFS_FRAGMENT_INDEX_BYTES ( ( long long ) sBlk . s . fragments ) ; long long * fragment_table_index ; if ( length != ( * table_start - sBlk . s . fragment_table_start ) ) { ERROR ( ""read_fragment_table:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } <S2SV_ModEnd> <S2SV_ModStart> fragment_table_index = alloc_index_table ( indexes ) ; <S2SV_ModEnd> <S2SV_ModStart> length <S2SV_ModEnd> <S2SV_ModStart> table_start <S2SV_ModEnd> "
838,<S2SV_StartBug> assert ( numcolors <= RAS_CMAP_MAXSIZ ) ; <S2SV_EndBug> ,<S2SV_ModStart> if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> 
839,"<S2SV_StartBug> sprintf ( efbuf , ""REG_%s"" , name ) ; <S2SV_EndBug> ","<S2SV_ModStart> snprintf ( efbuf , sizeof ( efbuf ) <S2SV_ModEnd> "
840,<S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> ,<S2SV_ModStart> if ( dlen < 2 ) break ; <S2SV_ModStart>  <S2SV_ModEnd> 
841,<S2SV_StartBug> nfcb_poll -> sensb_res_len = * data ++ ; <S2SV_EndBug> ,"<S2SV_ModStart> min_t ( __u8 , <S2SV_ModStart> , NFC_SENSB_RES_MAXSIZE ) "
842,"<S2SV_StartBug> unsigned int maxfraglen , fragheaderlen ; <S2SV_EndBug> <S2SV_StartBug> int hh_len ; <S2SV_EndBug> <S2SV_StartBug> fragheaderlen , skb , rt ) ; <S2SV_EndBug> ","<S2SV_ModStart> , mtu <S2SV_ModStart>  <S2SV_ModEnd> <S2SV_ModStart> , np -> pmtudisc == IPV6_PMTUDISC_PROBE "
843,"<S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> ","<S2SV_ModStart> = 0 , desc_chunk <S2SV_ModStart> ; desc_chunk = 1 <S2SV_ModStart> desc_chunk || ! "
844,"<S2SV_StartBug> static int cost_segmap ( int * segcounts , vp9_prob * probs ) { <S2SV_EndBug> ",<S2SV_ModStart> vpx_prob <S2SV_ModEnd> 
845,<S2SV_StartBug> motion_pct = this_frame -> pcnt_motion ; <S2SV_EndBug> ,<S2SV_ModStart> ( void ) cpi ; 
846,"<S2SV_StartBug> char extbuf [ sizeof ( c -> binary_header ) + BIN_MAX_EXTLEN ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( extbuf + sizeof ( c -> binary_header ) , c -> rcurr + sizeof ( c -> binary_header ) , extlen ) ; <S2SV_EndBug> ",<S2SV_ModStart> + 1 <S2SV_ModStart> extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN : 
847,<S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> ,<S2SV_ModStart> ( int ) 
848,<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> ,"<S2SV_ModStart> , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> <S2SV_ModStart> * num "
849,<S2SV_StartBug> offset = tbl -> indent ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> if ( offset < 0 ) offset = 0 ; 
850,<S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ,<S2SV_ModStart> int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> && len < buflen <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> goto beach <S2SV_ModEnd> <S2SV_ModStart> beach : free ( ptr ) ; return ret ; 
851,<S2SV_StartBug> default : <S2SV_EndBug> ,<S2SV_ModStart> case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ; 
852,"<S2SV_StartBug> tr_variantInitDict ( & node -> sorted , n ) ; <S2SV_EndBug> <S2SV_StartBug> node -> sorted . val . l . vals [ i ] = * tmp [ i ] . val ; <S2SV_EndBug> <S2SV_StartBug> node -> sorted . val . l . count = n ; <S2SV_EndBug> <S2SV_StartBug> node -> v = & node -> sorted ; <S2SV_EndBug> <S2SV_StartBug> node -> v = v ; <S2SV_EndBug> ","<S2SV_ModStart> node -> sorted = tr_new ( tr_variant , 1 ) ; tr_variantInitDict ( <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> -> <S2SV_ModEnd> <S2SV_ModStart> v = <S2SV_ModEnd> <S2SV_ModStart> sorted = NULL ; } node -> v = v ; <S2SV_ModEnd> "
